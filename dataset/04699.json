{
  "Title": "[05] The kerosene price can be manipulated via donation attacks",
  "Content": "\nhttps://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.kerosine.unbounded.sol#L50-L68\n\n```solidity\n  function assetPrice()\n    public\n    view\n    override\n    returns (uint) {\n      uint tvl;\n      address[] memory vaults = kerosineManager.getVaults();\n      uint numberOfVaults = vaults.length;\n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[i]);\n        tvl += vault.asset().balanceOf(address(vault))\n                * vault.assetPrice() * 1e18\n                / (10**vault.asset().decimals())\n                / (10**vault.oracle().decimals());\n      }\n      uint numerator   = tvl - dyad.totalSupply();\n      uint denominator = kerosineDenominator.denominator();\n      return numerator * 1e8 / denominator;\n  }\n```\n\nWould be key to note that this function is also used in the bounded vault to get the asset price via [here](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.kerosine.bounded.sol#L43-L49).\n\n```solidity\n  function assetPrice()\n    public\n    view\n    override\n    returns (uint) {\n      return unboundedKerosineVault.assetPrice() * 2;\n  }\n```\n\nThe issue with this stems from how the Kerosene token price is calculated, the TVL is determined by fetching the balance of each vault's asset using the `balanceOf()` function and then multiplying it by the vault's asset price:\n\n```solidity\n        tvl += vault.asset().balanceOf(address(vault))\n                * vault.assetPrice() * 1e18\n                / (10**vault.asset().decimals())\n                / (10**vault.oracle().decimals());\n```\n\nHowever, this method relies on the `balanceOf()` function to retrieve the asset balance of each vault, rather than using a storage variable that internally tracks deposits. This opens up a vulnerability where an attacker could donate an arbitrary amount of assets to any vault, thereby artificially increasing the Kerosene token price.\n\n### Recommended Mitigation Steps\n\nDevise a solution that ensures the accurate calculation of the Kerosene token price without being susceptible to manipulation via unauthorized asset donations, this can be done by having a storage variable tracking the deposits internally\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-04-dyad",
  "Code": [
    {
      "filename": "src/core/Vault.kerosine.unbounded.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {KerosineVault}        from \"./Vault.kerosine.sol\";\nimport {IVaultManager}        from \"../interfaces/IVaultManager.sol\";\nimport {Vault}                from \"./Vault.sol\";\nimport {Dyad}                 from \"./Dyad.sol\";\nimport {KerosineManager}      from \"./KerosineManager.sol\";\nimport {BoundedKerosineVault} from \"./Vault.kerosine.bounded.sol\";\nimport {KerosineDenominator}  from \"../staking/KerosineDenominator.sol\";\n\nimport {ERC20}           from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"@solmate/src/utils/SafeTransferLib.sol\";\n\ncontract UnboundedKerosineVault is KerosineVault {\n  using SafeTransferLib for ERC20;\n\n  Dyad                 public immutable dyad;\n  KerosineDenominator  public kerosineDenominator;\n\n  constructor(\n      IVaultManager   _vaultManager,\n      ERC20           _asset, \n      Dyad            _dyad, \n      KerosineManager _kerosineManager\n  ) KerosineVault(_vaultManager, _asset, _kerosineManager) {\n      dyad = _dyad;\n  }\n\n  function withdraw(\n    uint    id,\n    address to,\n    uint    amount\n  ) \n    external \n      onlyVaultManager\n  {\n    id2asset[id] -= amount;\n    asset.safeTransfer(to, amount); \n    emit Withdraw(id, to, amount);\n  }\n\n  function setDenominator(KerosineDenominator _kerosineDenominator) \n    external \n      onlyOwner\n  {\n    kerosineDenominator = _kerosineDenominator;\n  }\n\n  function assetPrice() \n    public \n    view \n    override\n    returns (uint) {\n      uint tvl;\n      address[] memory vaults = kerosineManager.getVaults();\n      uint numberOfVaults = vaults.length;\n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[i]);\n        tvl += vault.asset().balanceOf(address(vault)) \n                * vault.assetPrice() * 1e18\n                / (10**vault.asset().decimals()) \n                / (10**vault.oracle().decimals());\n      }\n      uint numerator   = tvl - dyad.totalSupply();\n      uint denominator = kerosineDenominator.denominator();\n      return numerator * 1e8 / denominator;\n  }\n}"
    },
    {
      "filename": "src/core/Vault.kerosine.bounded.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {KerosineVault}          from \"./Vault.kerosine.sol\";\nimport {IVaultManager}          from \"../interfaces/IVaultManager.sol\";\nimport {Dyad}                   from \"./Dyad.sol\";\nimport {KerosineManager}        from \"./KerosineManager.sol\";\nimport {UnboundedKerosineVault} from \"./Vault.kerosine.unbounded.sol\";\n\nimport {ERC20} from \"@solmate/src/tokens/ERC20.sol\";\n\ncontract BoundedKerosineVault is KerosineVault {\n  error NotWithdrawable(uint id, address to, uint amount);\n\n  UnboundedKerosineVault public unboundedKerosineVault;\n\n  constructor(\n    IVaultManager   _vaultManager,\n    ERC20           _asset, \n    KerosineManager _kerosineManager\n  ) KerosineVault(_vaultManager, _asset, _kerosineManager) {}\n\n  function setUnboundedKerosineVault(\n    UnboundedKerosineVault _unboundedKerosineVault\n  )\n    external\n    onlyOwner\n  {\n    unboundedKerosineVault = _unboundedKerosineVault;\n  }\n\n  function withdraw(\n    uint    id,\n    address to,\n    uint    amount\n  ) \n    external \n    view\n      onlyVaultManager\n  {\n    revert NotWithdrawable(id, to, amount);\n  }\n\n  function assetPrice() \n    public \n    view \n    override\n    returns (uint) {\n      return unboundedKerosineVault.assetPrice() * 2;\n  }\n}"
    }
  ]
}