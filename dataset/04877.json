{
  "Title": "[G-45]  Do not declare local variables used only once",
  "Content": "\n<details>\n\n**Files:** `L2ContractHelper.sol`, `Compressor.sol`, `L2SharedBridge.sol`, `Mailbox.sol`, `L1ERC20Bridge.sol`, `NonceHolder.sol`, `DefaultAccount.sol`, `EfficientCall.sol`, `AccountCodeStorage.sol`, `L1SharedBridge.sol`, `Diamond.sol`, `L2StandardERC20.sol`, `SystemContractHelper.sol`, `KnownCodesStorage.sol`, `Admin.sol`, `ContractDeployer.sol`\n\n[File: code/contracts/zksync/contracts/bridge/L2StandardERC20.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2StandardERC20.sol#L119)\n```solidity\n119:         address beaconAddress = _getBeacon();\n120:         require(msg.sender == UpgradeableBeacon(beaconAddress).owner(), \"tt\");\n```\n\nVariable `beaconAddress` is used only once, thus this variable is redundant. Above code can be rewritten to:\n\n```\nrequire(msg.sender == UpgradeableBeacon(_getBeacon()).owner(), \"tt\");\n```\n\n[File: code/contracts/zksync/contracts/bridge/L2SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L64)\n```solidity\n64:             address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n65:             l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n```\n\nVariable `l2StandardToken` is used only once, thus it is redundant. Above code can be changed to:\n\n```\nl2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(address(new L2StandardERC20{salt: bytes32(0)}()));\n```\n\n[File: code/contracts/zksync/contracts/bridge/L2SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L110)\n```solidity\n110:         bytes32 salt = _getCreate2Salt(_l1Token);\n111: \n112:         BeaconProxy l2Token = _deployBeaconProxy(salt);\n```\n\nVariable `salt` is used only once, thus it is redundant. Above code can be changed to:\n\n```\nBeaconProxy l2Token = _deployBeaconProxy(_getCreate2Salt(_l1Token));\n```\n\n[File: code/contracts/zksync/contracts/bridge/L2SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L150)\n```solidity\n150:         bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n151:         bytes32 salt = _getCreate2Salt(_l1Token);\n152:         return\n153:             L2ContractHelper.computeCreate2Address(address(this), salt, l2TokenProxyBytecodeHash, constructorInputHash);\n```\n\nVariables `constructorInputHash` and `salt` are used only once, thus they are redundant. Above code can be changed to:\n\n```\nreturn\n    L2ContractHelper.computeCreate2Address(address(this), _getCreate2Salt(_l1Token), l2TokenProxyBytecodeHash, keccak256(abi.encode(address(l2TokenBeacon), \"\")));\n```\n\n[File: code/system-contracts/contracts/libraries/EfficientCall.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/libraries/EfficientCall.sol#L261)\n```solidity\n261:         uint32 shrinkTo = uint32(msg.data.length - (_data.length + dataOffset));\n262:         SystemContractHelper.ptrShrinkIntoActive(shrinkTo);\n263: \n264:         uint32 gas = Utils.safeCastToU32(_gas);\n265:         uint256 farCallAbi = SystemContractsCaller.getFarCallABIWithEmptyFatPointer(\n266:             gas,\n```\n\n`shrinkTo` and `gas` are used only once, thus there's no need to declare them at all:\n\n```\n        SystemContractHelper.ptrShrinkIntoActive(uint32(msg.data.length - (_data.length + dataOffset)));\n\n        uint256 farCallAbi = SystemContractsCaller.getFarCallABIWithEmptyFatPointer(\n            Utils.safeCastToU32(_gas),\n```\n\n[File: code/system-contracts/contracts/libraries/SystemContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L217)\n```solidity\n217:         uint256 shifted = (meta << (256 - size - offset));\n218:         // Then we shift everything back\n219:         result = (shifted >> (256 - size));\n```\n\n`shifted` is used only once, thus there's no need to declare this variable at all:\n\n```\nresult = ((meta << (256 - size - offset)) >> (256 - size));\n```\n\n[File: code/system-contracts/contracts/NonceHolder.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/NonceHolder.sol#L92)\n```solidity\n92:         uint256 addressAsKey = uint256(uint160(msg.sender));\n93: \n94:         nonceValues[addressAsKey][_key] = _value;\n```\n\n`addressAsKey` is used only once, thus there's no need to declare this variable at all:\n\n```\n nonceValues[uint256(uint160(msg.sender))][_key] = _value;\n```\n\n[File: code/system-contracts/contracts/NonceHolder.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/NonceHolder.sol#L103)\n```solidity\n103:         uint256 addressAsKey = uint256(uint160(msg.sender));\n104:         return nonceValues[addressAsKey][_key];\n```\n\n`addressAsKey` is used only once, thus there's no need to declare this variable at all:\n\n```\n return nonceValues[uint256(uint160(msg.sender))][_key];\n```\n\n[File: code/system-contracts/contracts/KnownCodesStorage.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/KnownCodesStorage.sol#L75)\n```solidity\n75:         uint8 version = uint8(_bytecodeHash[0]);\n76:         require(version == 1 && _bytecodeHash[1] == bytes1(0), \"Incorrectly formatted bytecodeHash\");\n```\n\n`version` is used only once, thus there's no need to declare this variable at all:\n\n```\nrequire(uint8(_bytecodeHash[0]) == 1 && _bytecodeHash[1] == bytes1(0), \"Incorrectly formatted bytecodeHash\");\n```\n\n[File: code/system-contracts/contracts/DefaultAccount.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/DefaultAccount.sol#L099)\n```solidity\n099:         uint256 totalRequiredBalance = _transaction.totalRequiredBalance();\n100:         require(totalRequiredBalance <= address(this).balance, \"Not enough balance for fee + value\");\n```\n\n`totalRequiredBalance` is used only once, thus there's no need to declare this variable at all:\n\n```\nrequire(_transaction.totalRequiredBalance() <= address(this).balance, \"Not enough balance for fee + value\");\n```\n\n[File: code/system-contracts/contracts/ContractDeployer.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/ContractDeployer.sol#L121)\n```solidity\n121:         bytes32 hash = keccak256(\n122:             bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))\n123:         );\n124: \n125:         newAddress = address(uint160(uint256(hash)));\n```\n\n`hash` is used only once, thus there's no need to declare this variable at all:\n\n```\nnewAddress = address(uint160(uint256(keccak256(bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))))));\n```\n\n[File: code/system-contracts/contracts/ContractDeployer.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/ContractDeployer.sol#L302)\n```solidity\n302:         uint256 knownCodeMarker = KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash);\n303:         require(knownCodeMarker > 0, \"The code hash is not known\");\n```\n\n`knownCodeMarker` is used only once, thus there's no need to declare this variable at all:\n\n```\nrequire(KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash) > 0, \"The code hash is not known\");\n```\n\n[File: code/system-contracts/contracts/Compressor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/Compressor.sol#L65)\n```solidity\n65:                 uint64 encodedChunk = dictionary.readUint64(indexOfEncodedChunk);\n66:                 uint64 realChunk = _bytecode.readUint64(encodedDataPointer * 4);\n67: \n68:                 require(encodedChunk == realChunk, \"Encoded chunk does not match the original bytecode\");\n```\n\n`encodedChunk` and `realChunk` are used only once, thus there's no need to declare those variables at all:\n\n```\nrequire(dictionary.readUint64(indexOfEncodedChunk) == _bytecode.readUint64(encodedDataPointer * 4), \"Encoded chunk does not match the original bytecode\");\n```\n\n[File: code/system-contracts/contracts/AccountCodeStorage.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/AccountCodeStorage.sol#L60)\n```solidity\n60:         bytes32 constructedBytecodeHash = Utils.constructedBytecodeHash(codeHash);\n61: \n62:         _storeCodeHash(_address, constructedBytecodeHash);\n```\n\n`constructedBytecodeHash` is used only once, thus there's no need to declare this variable at all:\n\n```\n_storeCodeHash(_address, Utils.constructedBytecodeHash(codeHash));\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol#L192)\n```solidity\n192:         uint256 selectorsLength = ds.facetToSelectors[_facet].selectors.length;\n193:         // If there are no selectors associated with facet then save facet as new one\n194:         if (selectorsLength == 0) {\n```\n\n`selectorsLength` is used only once, thus there's no need to declare this variable at all:\n\n```\nif (ds.facetToSelectors[_facet].selectors.length == 0) {\n```\n\n[File: code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L40)\n```solidity\n40:         uint8 version = uint8(_bytecodeHash[0]);\n41:         require(version == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n```\n\n`version` is used once, thus there's no need to declare this variable at all:\n\n```\nrequire(uint8(_bytecodeHash[0]) == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n```\n\n[File: code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L66)\n```solidity\n66:         bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n67:         bytes32 data = keccak256(\n68:             bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n69:         );\n70: \n71:         return address(uint160(uint256(data)));\n```\n\n`senderBytes` and `data` are used once, thus there's no need to declare those variables:\n\n```\nreturn address(uint160(uint256( keccak256(\n            bytes.concat(CREATE2_PREFIX, bytes32(uint256(uint160(_sender))), _salt, _bytecodeHash, _constructorInputHash)\n        ))));\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L104)\n```solidity\n104:         bytes32 cutHashInput = keccak256(abi.encode(_diamondCut));\n105:         require(\n106:             cutHashInput == IStateTransitionManager(s.stateTransitionManager).upgradeCutHash(_oldProtocolVersion),\n107:             \"StateTransition: cutHash mismatch\"\n108:         );\n109: \n```\n\n`cutHashInput` is used only once, thus there's no need to declare this variable at all:\n\n```\n        require(\n            keccak256(abi.encode(_diamondCut)) == IStateTransitionManager(s.stateTransitionManager).upgradeCutHash(_oldProtocolVersion),\n            \"StateTransition: cutHash mismatch\"\n        );\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L41)\n```solidity\n41:         uint256 amount = address(this).balance;\n42:         address sharedBridgeAddress = s.baseTokenBridge;\n43:         IL1SharedBridge(sharedBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n```\n\n`amount` and `sharedBridgeAddress` are used only once, thus there's no need to declare those variables at all:\n\n```\nIL1SharedBridge(s.baseTokenBridge).receiveEth{value: address(this).balance}(ERA_CHAIN_ID);\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L123)\n```solidity\n123:         bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n124:         bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n125: \n126:         return actualRootHash == calculatedRootHash;\n```\n\n`calculatedRootHash` and `actualRootHash` are used only once, thus there's no need to declare those variables at all:\n\n```\nreturn Merkle.calculateRoot(_proof, _index, hashedLog) == s.l2LogsRootHashes[_batchNumber];\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L148)\n```solidity\n148:         uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n149:         return l2GasPrice * _l2GasLimit;\n```\n\n`l2GasPrice` is used only once, thus there's no need to declare this variable at all:\n\n```\nreturn _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit) * _l2GasLimit;;\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L271)\n```solidity\n271:         uint256 baseCost = _params.l2GasPrice * _params.l2GasLimit;\n272:         require(_mintValue >= baseCost + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n```\n\n`baseCost` is used only once, thus there's no need to declare this variable at all:\n\n```\nrequire(_mintValue >= _params.l2GasPrice * _params.l2GasLimit + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n```\n\n[File: code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L160)\n```solidity\n160:             uint256 amount = _depositFunds(_prevMsgSender, IERC20(_l1Token), _amount); // note if _prevMsgSender is this contract, this will return 0. This does not happen.\n161:             require(amount == _amount, \"3T\"); // The token has non-standard transfer logic\n```\n\n`amount` is used only once, thus there's no need to declare this variable at all:\n\n```\nrequire(_depositFunds(_prevMsgSender, IERC20(_l1Token), _amount) == _amount, \"3T\"); // The token has non-standard transfer logic\n```\n\n[File: code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L205)\n```solidity\n205:             uint256 withdrawAmount = _depositFunds(_prevMsgSender, IERC20(_l1Token), _depositAmount);\n206:             require(withdrawAmount == _depositAmount, \"5T\"); // The token has non-standard transfer logic\n```\n\n`withdrawAmount` is used only once, thus there's no need to declare this variable at all:\n\n```\n require(_depositFunds(_prevMsgSender, IERC20(_l1Token), _depositAmount) == _depositAmount, \"5T\"); // The token has non-standard transfer logic\n```\n\n[File: code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L340)\n```solidity\n340:                 bytes32 dataHash = depositHappened[_chainId][_l2TxHash];\n341:                 bytes32 txDataHash = keccak256(abi.encode(_depositSender, _l1Token, _amount));\n342:                 require(dataHash == txDataHash, \"ShB: d.it not hap\");\n```\n\n`dataHash` and `txDataHash` are used only once, thus there's no need to declare those variables at all:\n\n```\nrequire(depositHappened[_chainId][_l2TxHash] == keccak256(abi.encode(_depositSender, _l1Token, _amount)), \"ShB: d.it not hap\");\n```\n\n[File: code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L76)\n```solidity\n76:         bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, \"\"));\n77:         bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n78: \n79:         return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n```\n\n`constructorInputHash` and `salt` are used only once, thus there's no need to declare those variables at all:\n\n```\nreturn L2ContractHelper.computeCreate2Address(l2Bridge,  bytes32(uint256(uint160(_l1Token))), l2TokenProxyBytecodeHash, keccak256(abi.encode(l2TokenBeacon, \"\")));\n```\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/zksync/contracts/bridge/L2StandardERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport {ERC1967Upgrade} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\n\nimport {IL2StandardToken} from \"./interfaces/IL2StandardToken.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The ERC20 token implementation, that is used in the \"default\" ERC20 bridge. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\ncontract L2StandardERC20 is ERC20PermitUpgradeable, IL2StandardToken, ERC1967Upgrade {\n    /// @dev Describes whether there is a specific getter in the token.\n    /// @notice Used to explicitly separate which getters the token has and which it does not.\n    /// @notice Different tokens in L1 can implement or not implement getter function as `name`/`symbol`/`decimals`,\n    /// @notice Our goal is to store all the getters that L1 token implements, and for others, we keep it as an unimplemented method.\n    struct ERC20Getters {\n        bool ignoreName;\n        bool ignoreSymbol;\n        bool ignoreDecimals;\n    }\n\n    ERC20Getters private availableGetters;\n\n    /// @dev The decimals of the token, that are used as a value for `decimals` getter function.\n    /// @notice A private variable is used only for decimals, but not for `name` and `symbol`, because standard\n    /// @notice OpenZeppelin token represents `name` and `symbol` as storage variables and `decimals` as constant.\n    uint8 private decimals_;\n\n    /// @dev Address of the L2 bridge that is used as trustee who can mint/burn tokens\n    address public override l2Bridge;\n\n    /// @dev Address of the L1 token that can be deposited to mint this L2 token\n    address public override l1Address;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    constructor() {\n        // Disable initialization to prevent Parity hack.\n        _disableInitializers();\n    }\n\n    /// @notice Initializes a contract token for later use. Expected to be used in the proxy.\n    /// @dev Stores the L1 address of the bridge and set `name`/`symbol`/`decimals` getters that L1 token has.\n    /// @param _l1Address Address of the L1 token that can be deposited to mint this L2 token\n    /// @param _data The additional data that the L1 bridge provide for initialization.\n    /// In this case, it is packed `name`/`symbol`/`decimals` of the L1 token.\n    function bridgeInitialize(address _l1Address, bytes memory _data) external initializer {\n        require(_l1Address != address(0), \"in6\"); // Should be non-zero address\n        l1Address = _l1Address;\n\n        l2Bridge = msg.sender;\n\n        // We parse the data exactly as they were created on the L1 bridge\n        (bytes memory nameBytes, bytes memory symbolBytes, bytes memory decimalsBytes) = abi.decode(\n            _data,\n            (bytes, bytes, bytes)\n        );\n\n        ERC20Getters memory getters;\n        string memory decodedName;\n        string memory decodedSymbol;\n\n        // L1 bridge didn't check if the L1 token return values with proper types for `name`/`symbol`/`decimals`\n        // That's why we need to try to decode them, and if it works out, set the values as getters.\n\n        // NOTE: Solidity doesn't have a convenient way to try to decode a value:\n        // - Decode them manually, i.e. write a function that will validate that data in the correct format\n        // and return decoded value and a boolean value - whether it was possible to decode.\n        // - Use the standard abi.decode method, but wrap it into an external call in which error can be handled.\n        // We use the second option here.\n\n        try this.decodeString(nameBytes) returns (string memory nameString) {\n            decodedName = nameString;\n        } catch {\n            getters.ignoreName = true;\n        }\n\n        try this.decodeString(symbolBytes) returns (string memory symbolString) {\n            decodedSymbol = symbolString;\n        } catch {\n            getters.ignoreSymbol = true;\n        }\n\n        // Set decoded values for name and symbol.\n        __ERC20_init_unchained(decodedName, decodedSymbol);\n\n        // Set the name for EIP-712 signature.\n        __ERC20Permit_init(decodedName);\n\n        try this.decodeUint8(decimalsBytes) returns (uint8 decimalsUint8) {\n            // Set decoded value for decimals.\n            decimals_ = decimalsUint8;\n        } catch {\n            getters.ignoreDecimals = true;\n        }\n\n        availableGetters = getters;\n        emit BridgeInitialize(_l1Address, decodedName, decodedSymbol, decimals_);\n    }\n\n    /// @notice A method to be called by the governor to update the token's metadata.\n    /// @param _availableGetters The getters that the token has.\n    /// @param _newName The new name of the token.\n    /// @param _newSymbol The new symbol of the token.\n    /// @param _version The version of the token that will be initialized.\n    /// @dev The _version must be exactly the version higher by 1 than the current version. This is needed\n    /// to ensure that the governor can not accidentally disable future reinitialization of the token.\n    function reinitializeToken(\n        ERC20Getters calldata _availableGetters,\n        string memory _newName,\n        string memory _newSymbol,\n        uint8 _version\n    ) external onlyNextVersion(_version) reinitializer(_version) {\n        // It is expected that this token is deployed as a beacon proxy, so we'll\n        // allow the governor of the beacon to reinitialize the token.\n        address beaconAddress = _getBeacon();\n        require(msg.sender == UpgradeableBeacon(beaconAddress).owner(), \"tt\");\n\n        __ERC20_init_unchained(_newName, _newSymbol);\n        __ERC20Permit_init(_newName);\n        availableGetters = _availableGetters;\n\n        emit BridgeInitialize(l1Address, _newName, _newSymbol, decimals_);\n    }\n\n    modifier onlyBridge() {\n        require(msg.sender == l2Bridge, \"xnt\"); // Only L2 bridge can call this method\n        _;\n    }\n\n    modifier onlyNextVersion(uint8 _version) {\n        // The version should be incremented by 1. Otherwise, the governor risks disabling\n        // future reinitialization of the token by providing too large a version.\n        require(_version == _getInitializedVersion() + 1, \"v\");\n        _;\n    }\n\n    /// @dev Mint tokens to a given account.\n    /// @param _to The account that will receive the created tokens.\n    /// @param _amount The amount that will be created.\n    /// @notice Should be called by bridge after depositing tokens from L1.\n    function bridgeMint(address _to, uint256 _amount) external override onlyBridge {\n        _mint(_to, _amount);\n        emit BridgeMint(_to, _amount);\n    }\n\n    /// @dev Burn tokens from a given account.\n    /// @param _from The account from which tokens will be burned.\n    /// @param _amount The amount that will be burned.\n    /// @notice Should be called by bridge before withdrawing tokens to L1.\n    function bridgeBurn(address _from, uint256 _amount) external override onlyBridge {\n        _burn(_from, _amount);\n        emit BridgeBurn(_from, _amount);\n    }\n\n    function name() public view override returns (string memory) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        if (availableGetters.ignoreName) revert();\n        return super.name();\n    }\n\n    function symbol() public view override returns (string memory) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        if (availableGetters.ignoreSymbol) revert();\n        return super.symbol();\n    }\n\n    function decimals() public view override returns (uint8) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        if (availableGetters.ignoreDecimals) revert();\n        return decimals_;\n    }\n\n    /// @dev External function to decode a string from bytes.\n    function decodeString(bytes memory _input) external pure returns (string memory result) {\n        (result) = abi.decode(_input, (string));\n    }\n\n    /// @dev External function to decode a uint8 from bytes.\n    function decodeUint8(bytes memory _input) external pure returns (uint8 result) {\n        (result) = abi.decode(_input, (uint8));\n    }\n}"
    },
    {
      "filename": "code/contracts/zksync/contracts/bridge/L2SharedBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport {IL1ERC20Bridge} from \"./interfaces/IL1ERC20Bridge.sol\";\nimport {IL2SharedBridge} from \"./interfaces/IL2SharedBridge.sol\";\nimport {IL2StandardToken} from \"./interfaces/IL2StandardToken.sol\";\n\nimport {L2StandardERC20} from \"./L2StandardERC20.sol\";\nimport {AddressAliasHelper} from \"../vendor/AddressAliasHelper.sol\";\nimport {L2ContractHelper, DEPLOYER_SYSTEM_CONTRACT, L2_BASE_TOKEN_ADDRESS, IContractDeployer} from \"../L2ContractHelper.sol\";\nimport {SystemContractsCaller} from \"../SystemContractsCaller.sol\";\nimport {ERA_CHAIN_ID, ERA_WETH_ADDRESS} from \"../Config.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The \"default\" bridge implementation for the ERC20 tokens. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\ncontract L2SharedBridge is IL2SharedBridge, Initializable {\n    /// @dev The address of the L1 bridge counterpart.\n    address public override l1Bridge;\n\n    /// @dev Contract that stores the implementation address for token.\n    /// @dev For more details see https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableBeacon.\n    UpgradeableBeacon public l2TokenBeacon;\n\n    /// @dev Bytecode hash of the proxy for tokens deployed by the bridge.\n    bytes32 internal l2TokenProxyBytecodeHash;\n\n    /// @dev A mapping l2 token address => l1 token address\n    mapping(address l2TokenAddress => address l1TokenAddress) public override l1TokenAddress;\n\n    address private l1LegacyBridge;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Disable the initialization to prevent Parity hack.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the bridge contract for later use. Expected to be used in the proxy.\n    /// @param _l1Bridge The address of the L1 Bridge contract.\n    /// @param _l2TokenProxyBytecodeHash The bytecode hash of the proxy for tokens deployed by the bridge.\n    /// @param _aliasedOwner The address of the governor contract.\n    function initialize(\n        address _l1Bridge,\n        address _l1LegecyBridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _aliasedOwner\n    ) external reinitializer(2) {\n        require(_l1Bridge != address(0), \"bf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n        require(_aliasedOwner != address(0), \"sf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n\n        l1Bridge = _l1Bridge;\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n\n        if (block.chainid != ERA_CHAIN_ID) {\n            address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        } else {\n            require(_l1LegecyBridge != address(0), \"bf2\");\n            // l2StandardToken and l2TokenBeacon are already deployed on ERA, and stored in the proxy\n        }\n    }\n\n    /// @notice Finalize the deposit and mint funds\n    /// @param _l1Sender The account address that initiated the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1\n    /// @param _amount Total amount of tokens deposited from L1\n    /// @param _data The additional data that user can pass with the deposit\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override {\n        // Only the L1 bridge counterpart can initiate and finalize the deposit.\n        require(\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1Bridge ||\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1LegacyBridge,\n            \"mq\"\n        );\n        require(msg.value == 0, \"Value should be 0 for ERC20 bridge\");\n\n        address expectedL2Token = l2TokenAddress(_l1Token);\n        address currentL1Token = l1TokenAddress[expectedL2Token];\n        if (currentL1Token == address(0)) {\n            address deployedToken = _deployL2Token(_l1Token, _data);\n            require(deployedToken == expectedL2Token, \"mt\");\n            l1TokenAddress[expectedL2Token] = _l1Token;\n        } else {\n            require(currentL1Token == _l1Token, \"gg\"); // Double check that the expected value equal to real one\n        }\n\n        IL2StandardToken(expectedL2Token).bridgeMint(_l2Receiver, _amount);\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, expectedL2Token, _amount);\n    }\n\n    /// @dev Deploy and initialize the L2 token for the L1 counterpart\n    function _deployL2Token(address _l1Token, bytes calldata _data) internal returns (address) {\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        BeaconProxy l2Token = _deployBeaconProxy(salt);\n        L2StandardERC20(address(l2Token)).bridgeInitialize(_l1Token, _data);\n\n        return address(l2Token);\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @param _l1Receiver The account address that should receive funds on L1\n    /// @param _l2Token The L2 token address which is withdrawn\n    /// @param _amount The total amount of tokens to be withdrawn\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external override {\n        require(_amount > 0, \"Amount cannot be zero\");\n\n        IL2StandardToken(_l2Token).bridgeBurn(msg.sender, _amount);\n\n        address l1Token = l1TokenAddress[_l2Token];\n        require(l1Token != address(0), \"yh\");\n\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, l1Token, _amount);\n        L2ContractHelper.sendMessageToL1(message);\n\n        emit WithdrawalInitiated(msg.sender, _l1Receiver, _l2Token, _amount);\n    }\n\n    /// @dev Encode the message for l2ToL1log sent with withdraw initialization\n    function _getL1WithdrawMessage(\n        address _to,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        // note we use the IL1ERC20Bridge.finalizeWithdrawal function selector to specify the selector for L1<>L2 messages,\n        // and we use this interface so that when the switch happened the old messages could be processed\n        return abi.encodePacked(IL1ERC20Bridge.finalizeWithdrawal.selector, _to, _l1Token, _amount);\n    }\n\n    /// @return Address of an L2 token counterpart\n    function l2TokenAddress(address _l1Token) public view override returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n        bytes32 salt = _getCreate2Salt(_l1Token);\n        return\n            L2ContractHelper.computeCreate2Address(address(this), salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n\n    /// @dev Convert the L1 token address to the create2 salt of deployed L2 token\n    function _getCreate2Salt(address _l1Token) internal pure returns (bytes32 salt) {\n        salt = bytes32(uint256(uint160(_l1Token)));\n    }\n\n    /// @dev Deploy the beacon proxy for the L2 token, while using ContractDeployer system contract.\n    /// @dev This function uses raw call to ContractDeployer to make sure that exactly `l2TokenProxyBytecodeHash` is used\n    /// for the code of the proxy.\n    function _deployBeaconProxy(bytes32 salt) internal returns (BeaconProxy proxy) {\n        (bool success, bytes memory returndata) = SystemContractsCaller.systemCallWithReturndata(\n            uint32(gasleft()),\n            DEPLOYER_SYSTEM_CONTRACT,\n            0,\n            abi.encodeCall(\n                IContractDeployer.create2,\n                (salt, l2TokenProxyBytecodeHash, abi.encode(address(l2TokenBeacon), \"\"))\n            )\n        );\n\n        // The deployment should be successful and return the address of the proxy\n        require(success, \"mk\");\n        proxy = BeaconProxy(abi.decode(returndata, (address)));\n    }\n}"
    },
    {
      "filename": "code/contracts/zksync/contracts/bridge/L2SharedBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport {IL1ERC20Bridge} from \"./interfaces/IL1ERC20Bridge.sol\";\nimport {IL2SharedBridge} from \"./interfaces/IL2SharedBridge.sol\";\nimport {IL2StandardToken} from \"./interfaces/IL2StandardToken.sol\";\n\nimport {L2StandardERC20} from \"./L2StandardERC20.sol\";\nimport {AddressAliasHelper} from \"../vendor/AddressAliasHelper.sol\";\nimport {L2ContractHelper, DEPLOYER_SYSTEM_CONTRACT, L2_BASE_TOKEN_ADDRESS, IContractDeployer} from \"../L2ContractHelper.sol\";\nimport {SystemContractsCaller} from \"../SystemContractsCaller.sol\";\nimport {ERA_CHAIN_ID, ERA_WETH_ADDRESS} from \"../Config.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The \"default\" bridge implementation for the ERC20 tokens. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\ncontract L2SharedBridge is IL2SharedBridge, Initializable {\n    /// @dev The address of the L1 bridge counterpart.\n    address public override l1Bridge;\n\n    /// @dev Contract that stores the implementation address for token.\n    /// @dev For more details see https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableBeacon.\n    UpgradeableBeacon public l2TokenBeacon;\n\n    /// @dev Bytecode hash of the proxy for tokens deployed by the bridge.\n    bytes32 internal l2TokenProxyBytecodeHash;\n\n    /// @dev A mapping l2 token address => l1 token address\n    mapping(address l2TokenAddress => address l1TokenAddress) public override l1TokenAddress;\n\n    address private l1LegacyBridge;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Disable the initialization to prevent Parity hack.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the bridge contract for later use. Expected to be used in the proxy.\n    /// @param _l1Bridge The address of the L1 Bridge contract.\n    /// @param _l2TokenProxyBytecodeHash The bytecode hash of the proxy for tokens deployed by the bridge.\n    /// @param _aliasedOwner The address of the governor contract.\n    function initialize(\n        address _l1Bridge,\n        address _l1LegecyBridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _aliasedOwner\n    ) external reinitializer(2) {\n        require(_l1Bridge != address(0), \"bf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n        require(_aliasedOwner != address(0), \"sf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n\n        l1Bridge = _l1Bridge;\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n\n        if (block.chainid != ERA_CHAIN_ID) {\n            address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        } else {\n            require(_l1LegecyBridge != address(0), \"bf2\");\n            // l2StandardToken and l2TokenBeacon are already deployed on ERA, and stored in the proxy\n        }\n    }\n\n    /// @notice Finalize the deposit and mint funds\n    /// @param _l1Sender The account address that initiated the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1\n    /// @param _amount Total amount of tokens deposited from L1\n    /// @param _data The additional data that user can pass with the deposit\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override {\n        // Only the L1 bridge counterpart can initiate and finalize the deposit.\n        require(\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1Bridge ||\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1LegacyBridge,\n            \"mq\"\n        );\n        require(msg.value == 0, \"Value should be 0 for ERC20 bridge\");\n\n        address expectedL2Token = l2TokenAddress(_l1Token);\n        address currentL1Token = l1TokenAddress[expectedL2Token];\n        if (currentL1Token == address(0)) {\n            address deployedToken = _deployL2Token(_l1Token, _data);\n            require(deployedToken == expectedL2Token, \"mt\");\n            l1TokenAddress[expectedL2Token] = _l1Token;\n        } else {\n            require(currentL1Token == _l1Token, \"gg\"); // Double check that the expected value equal to real one\n        }\n\n        IL2StandardToken(expectedL2Token).bridgeMint(_l2Receiver, _amount);\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, expectedL2Token, _amount);\n    }\n\n    /// @dev Deploy and initialize the L2 token for the L1 counterpart\n    function _deployL2Token(address _l1Token, bytes calldata _data) internal returns (address) {\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        BeaconProxy l2Token = _deployBeaconProxy(salt);\n        L2StandardERC20(address(l2Token)).bridgeInitialize(_l1Token, _data);\n\n        return address(l2Token);\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @param _l1Receiver The account address that should receive funds on L1\n    /// @param _l2Token The L2 token address which is withdrawn\n    /// @param _amount The total amount of tokens to be withdrawn\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external override {\n        require(_amount > 0, \"Amount cannot be zero\");\n\n        IL2StandardToken(_l2Token).bridgeBurn(msg.sender, _amount);\n\n        address l1Token = l1TokenAddress[_l2Token];\n        require(l1Token != address(0), \"yh\");\n\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, l1Token, _amount);\n        L2ContractHelper.sendMessageToL1(message);\n\n        emit WithdrawalInitiated(msg.sender, _l1Receiver, _l2Token, _amount);\n    }\n\n    /// @dev Encode the message for l2ToL1log sent with withdraw initialization\n    function _getL1WithdrawMessage(\n        address _to,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        // note we use the IL1ERC20Bridge.finalizeWithdrawal function selector to specify the selector for L1<>L2 messages,\n        // and we use this interface so that when the switch happened the old messages could be processed\n        return abi.encodePacked(IL1ERC20Bridge.finalizeWithdrawal.selector, _to, _l1Token, _amount);\n    }\n\n    /// @return Address of an L2 token counterpart\n    function l2TokenAddress(address _l1Token) public view override returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n        bytes32 salt = _getCreate2Salt(_l1Token);\n        return\n            L2ContractHelper.computeCreate2Address(address(this), salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n\n    /// @dev Convert the L1 token address to the create2 salt of deployed L2 token\n    function _getCreate2Salt(address _l1Token) internal pure returns (bytes32 salt) {\n        salt = bytes32(uint256(uint160(_l1Token)));\n    }\n\n    /// @dev Deploy the beacon proxy for the L2 token, while using ContractDeployer system contract.\n    /// @dev This function uses raw call to ContractDeployer to make sure that exactly `l2TokenProxyBytecodeHash` is used\n    /// for the code of the proxy.\n    function _deployBeaconProxy(bytes32 salt) internal returns (BeaconProxy proxy) {\n        (bool success, bytes memory returndata) = SystemContractsCaller.systemCallWithReturndata(\n            uint32(gasleft()),\n            DEPLOYER_SYSTEM_CONTRACT,\n            0,\n            abi.encodeCall(\n                IContractDeployer.create2,\n                (salt, l2TokenProxyBytecodeHash, abi.encode(address(l2TokenBeacon), \"\"))\n            )\n        );\n\n        // The deployment should be successful and return the address of the proxy\n        require(success, \"mk\");\n        proxy = BeaconProxy(abi.decode(returndata, (address)));\n    }\n}"
    },
    {
      "filename": "code/contracts/zksync/contracts/bridge/L2SharedBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport {IL1ERC20Bridge} from \"./interfaces/IL1ERC20Bridge.sol\";\nimport {IL2SharedBridge} from \"./interfaces/IL2SharedBridge.sol\";\nimport {IL2StandardToken} from \"./interfaces/IL2StandardToken.sol\";\n\nimport {L2StandardERC20} from \"./L2StandardERC20.sol\";\nimport {AddressAliasHelper} from \"../vendor/AddressAliasHelper.sol\";\nimport {L2ContractHelper, DEPLOYER_SYSTEM_CONTRACT, L2_BASE_TOKEN_ADDRESS, IContractDeployer} from \"../L2ContractHelper.sol\";\nimport {SystemContractsCaller} from \"../SystemContractsCaller.sol\";\nimport {ERA_CHAIN_ID, ERA_WETH_ADDRESS} from \"../Config.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The \"default\" bridge implementation for the ERC20 tokens. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\ncontract L2SharedBridge is IL2SharedBridge, Initializable {\n    /// @dev The address of the L1 bridge counterpart.\n    address public override l1Bridge;\n\n    /// @dev Contract that stores the implementation address for token.\n    /// @dev For more details see https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableBeacon.\n    UpgradeableBeacon public l2TokenBeacon;\n\n    /// @dev Bytecode hash of the proxy for tokens deployed by the bridge.\n    bytes32 internal l2TokenProxyBytecodeHash;\n\n    /// @dev A mapping l2 token address => l1 token address\n    mapping(address l2TokenAddress => address l1TokenAddress) public override l1TokenAddress;\n\n    address private l1LegacyBridge;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Disable the initialization to prevent Parity hack.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the bridge contract for later use. Expected to be used in the proxy.\n    /// @param _l1Bridge The address of the L1 Bridge contract.\n    /// @param _l2TokenProxyBytecodeHash The bytecode hash of the proxy for tokens deployed by the bridge.\n    /// @param _aliasedOwner The address of the governor contract.\n    function initialize(\n        address _l1Bridge,\n        address _l1LegecyBridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _aliasedOwner\n    ) external reinitializer(2) {\n        require(_l1Bridge != address(0), \"bf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n        require(_aliasedOwner != address(0), \"sf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n\n        l1Bridge = _l1Bridge;\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n\n        if (block.chainid != ERA_CHAIN_ID) {\n            address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        } else {\n            require(_l1LegecyBridge != address(0), \"bf2\");\n            // l2StandardToken and l2TokenBeacon are already deployed on ERA, and stored in the proxy\n        }\n    }\n\n    /// @notice Finalize the deposit and mint funds\n    /// @param _l1Sender The account address that initiated the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1\n    /// @param _amount Total amount of tokens deposited from L1\n    /// @param _data The additional data that user can pass with the deposit\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override {\n        // Only the L1 bridge counterpart can initiate and finalize the deposit.\n        require(\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1Bridge ||\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1LegacyBridge,\n            \"mq\"\n        );\n        require(msg.value == 0, \"Value should be 0 for ERC20 bridge\");\n\n        address expectedL2Token = l2TokenAddress(_l1Token);\n        address currentL1Token = l1TokenAddress[expectedL2Token];\n        if (currentL1Token == address(0)) {\n            address deployedToken = _deployL2Token(_l1Token, _data);\n            require(deployedToken == expectedL2Token, \"mt\");\n            l1TokenAddress[expectedL2Token] = _l1Token;\n        } else {\n            require(currentL1Token == _l1Token, \"gg\"); // Double check that the expected value equal to real one\n        }\n\n        IL2StandardToken(expectedL2Token).bridgeMint(_l2Receiver, _amount);\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, expectedL2Token, _amount);\n    }\n\n    /// @dev Deploy and initialize the L2 token for the L1 counterpart\n    function _deployL2Token(address _l1Token, bytes calldata _data) internal returns (address) {\n        bytes32 salt = _getCreate2Salt(_l1Token);\n\n        BeaconProxy l2Token = _deployBeaconProxy(salt);\n        L2StandardERC20(address(l2Token)).bridgeInitialize(_l1Token, _data);\n\n        return address(l2Token);\n    }\n\n    /// @notice Initiates a withdrawal by burning funds on the contract and sending the message to L1\n    /// where tokens would be unlocked\n    /// @param _l1Receiver The account address that should receive funds on L1\n    /// @param _l2Token The L2 token address which is withdrawn\n    /// @param _amount The total amount of tokens to be withdrawn\n    function withdraw(address _l1Receiver, address _l2Token, uint256 _amount) external override {\n        require(_amount > 0, \"Amount cannot be zero\");\n\n        IL2StandardToken(_l2Token).bridgeBurn(msg.sender, _amount);\n\n        address l1Token = l1TokenAddress[_l2Token];\n        require(l1Token != address(0), \"yh\");\n\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, l1Token, _amount);\n        L2ContractHelper.sendMessageToL1(message);\n\n        emit WithdrawalInitiated(msg.sender, _l1Receiver, _l2Token, _amount);\n    }\n\n    /// @dev Encode the message for l2ToL1log sent with withdraw initialization\n    function _getL1WithdrawMessage(\n        address _to,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory) {\n        // note we use the IL1ERC20Bridge.finalizeWithdrawal function selector to specify the selector for L1<>L2 messages,\n        // and we use this interface so that when the switch happened the old messages could be processed\n        return abi.encodePacked(IL1ERC20Bridge.finalizeWithdrawal.selector, _to, _l1Token, _amount);\n    }\n\n    /// @return Address of an L2 token counterpart\n    function l2TokenAddress(address _l1Token) public view override returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n        bytes32 salt ="
    }
  ]
}