{
  "Title": "Timestamp usage",
  "Content": "The code [uses timestamps for contract logic](https://github.com/ether-camp/virtual-accelerator/blob/6d4097a08669c2520e0d5bab317b60f1d13df44e/contracts/DSTContract.sol#L341). There’s a problem with using timestamps and `now` (alias for `block.timestamp`) for contract logic, based on the fact that miners can perform some manipulation. In general, [it’s better not to rely on timestamps for contract logic](https://github.com/ConsenSys/smart-contract-best-practices#timestamp-dependence). The solutions is to use `block.number` instead, and approximate dates with expected block heights.\n\n\nGiven the nature of the contract, we think the risk of miner manipulation is really low. We recommend the EtherCamp team to consider the potential risk and switch to `block.number` if necessary.\n\n\nFor more info on this topic, see [this stack exchange question](https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp).\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/DSTContract.sol",
      "content": "import \"StandardToken.sol\";\nimport \"EventInfo.sol\";\nimport \"HackerGold.sol\";\n\npragma solidity ^0.4.2;\n\n/*\n * DSTContract - DST stands for decentralized startup team.\n *               the contract ensures funding for a decentralized\n *               team in 2 phases: \n *\n *                +. Funding by HKG during the hackathon event. \n *                +. Funding by Ether after the event is over. \n *\n *               After the funds been collected there is a governence\n *               mechanism managed by proposition to withdraw funds\n *               for development usage. \n *\n *               The DST ensures that backers of the projects keeps\n *               some influence on the project by ability to reject\n *               propositions they find as non effective. \n *\n *               In very radical occasions the backers may loose \n *               the trust in the team completelly, in that case \n *               there is an option to propose impeachment process\n *               completelly removing the execute and assigning new\n *               person to manage the funds. \n *\n */\ncontract DSTContract is StandardToken{\n\n\n    address   selfAddress;\n    address   executive; \n        \n    EventInfo eventInfo;\n    \n    // Indicateds where the DST is threaded\n    address virtualExchangeAddress;\n    \n    HackerGold hackerGold;\n        \n    mapping (address => uint256) votingRights;\n\n\n    // 1 - HKG => DST qty; tokens for 1 HKG\n    uint hkgPrice;\n    \n    // 1 - Ether => DST qty; tokens for 1 Ether\n    uint etherPrice;\n    \n    string public name = \"...\";                   \n    uint8  public decimals = 3;                 \n    string public symbol = \"...\";\n    \n    bool ableToIssueTokens = true; \n    \n    uint preferedQtySold;\n\n    uint collectedHKG; \n    uint collectedEther;    \n    \n    // Proposal of the funds spending\n    mapping (bytes32 => Proposal) proposals;\n\n    enum ProposalCurrency { HKG, ETHER }\n    ProposalCurrency enumDeclaration;\n                  \n       \n    struct Proposal{\n        \n        bytes32 id;\n        uint value;\n\n        string urlDetails;\n\n        uint votindEndTS;\n                \n        uint votesObjecting;\n        \n        address submitter;\n        bool redeemed;\n\n        ProposalCurrency proposalCurrency;\n        \n        mapping (address => bool) voted;\n    }\n    uint counterProposals;\n    uint timeOfLastProposal;\n    \n    Proposal[] listProposals;\n    \n\n    /**\n     * Impeachment process proposals\n     */    \n    struct ImpeachmentProposal{\n        \n        string urlDetails;\n        \n        address newExecutive;\n\n        uint votindEndTS;        \n        uint votesSupporting;\n        \n        mapping (address => bool) voted;        \n    }\n    \n    ImpeachmentProposal lastImpeachmentProposal;\n\n        \n    /*\n     * \n     *  Set date for early adapters\n     *\n     */ \n    function DSTContract(EventInfo eventInfoAddr, HackerGold hackerGoldAddr, string dstName, string dstSymbol){\n    \n      selfAddress = this; \n      executive   = msg.sender;  \n      name        = dstName;\n      symbol      = dstSymbol;\n\n      hackerGold = HackerGold(hackerGoldAddr);\n      eventInfo  = EventInfo(eventInfoAddr);\n    }\n    \n\n    function() payable {\n                \n        // If the hack event is not over return \n        // sent ether.\n        if (now < eventInfo.getEventEnd()) {\n            throw;\n        }\n        \n        // there is tokens left from hackathon \n        if (etherPrice == 0) throw;\n        \n        uint tokens = msg.value / (1 finney) * etherPrice;\n        \n        // check if demand of tokens is \n        // overflow the suply \n        if (balances[this] < tokens){\n            \n            tokens = balances[this];\n            uint retEther = msg.value - tokens / etherPrice * (1 finney);\n        \n            // return left ether \n            if (!msg.sender.send(retEther)) throw;\n        }\n        \n        \n        // do transfer\n        balances[msg.sender] += tokens;\n        balances[this] -= tokens;\n        \n        // count collected ether \n        collectedEther += msg.value; \n        \n        // todo: ... event for transfer\n        \n    }\n\n    \n    \n    /**\n     * \n     * qtyForOneHKG - \n     * \n     */    \n     function setHKGPrice(uint qtyForOneHKG) onlyExecutive {\n         \n         hkgPrice = qtyForOneHKG;\n         PriceHKGChange(qtyForOneHKG);\n     }\n     \n     \n    \n    /**\n     * \n     * issuePreferedTokens - prefered tokens issued on the hackathon event\n     *                       tain special rights\n     * \n     */\n    function issuePreferedTokens(uint qtyForOneHKG, \n                                 uint qtyToEmit) onlyExecutive \n                                                 onlyIfAbleToIssueTokens\n                                                 onlyBeforeEnd\n                                                 onlyAfterTradingStart {\n        \n        // the issuer of the token disabled futer issuance                                                        \n        if (!ableToIssueTokens) {\n            throw;\n        }                \n                \n        // no issuence is allowed before enlisted on the\n        // exchange \n        if (virtualExchangeAddress == 0x0) throw;\n            \n        totalSupply    += qtyToEmit;\n        balances[this] += qtyToEmit;\n        hkgPrice = qtyForOneHKG;\n        \n        \n        // now spender can use balance in \n        // ammount of value from owner balance\n        allowed[this][virtualExchangeAddress] = qtyToEmit;\n        \n        // rise event about the transaction\n        Approval(this, virtualExchangeAddress, qtyToEmit);\n        \n        \n        // ...todo... emit event for new tokens + price\n        // DstTokensIssued(indexed uint qtyForOneEther, indexed uint qtyToEmit, indexed uint totalSupply)\n    }\n\n    \n    \n    \n    /**\n     * \n     * buyForHackerGold - on the hack event this function is available \n     *                    the buyer for hacker gold will gain votes to \n     *                    influence future proposals on the DST\n     *    \n     *  @param hkgValue - qty of this DST tokens for 1 HKG     \n     * \n     */\n    function buyForHackerGold(uint hkgValue) onlyBeforeEnd \n                                             returns (bool success) {\n    \n\n      // Validate that the caller is official accelerator HKG Exchange\n      if (msg.sender != virtualExchangeAddress) throw;\n      \n    \n      // Transfer token \n      address sender = tx.origin;\n      \n      uint tokensQty = hkgValue * hkgPrice;\n\n\n      // Gain voting rights\n      votingRights[sender] +=tokensQty;\n      preferedQtySold += tokensQty;\n      collectedHKG += hkgValue;\n      \n                  \n      transferFrom(this, \n                   virtualExchangeAddress, tokensQty);\n      transfer(sender, tokensQty);        \n            \n      BuyForHKGTransaction(tokensQty, hkgPrice, balances[this], tokensQty);\n        \n      return true;\n    }\n        \n    \n    /**\n     * \n     * issueTokens - function will issue tokens after the \n     *               event\n     * \n     * @param qtyForOneEther - ...\n     * @param qtyToEmit      - ...     \n     *\n     */\n    function issueTokens(uint qtyForOneEther, \n                         uint qtyToEmit) onlyAfterEnd \n                                         onlyExecutive {\n         \n        // If the user already declared end \n        // of issuence\n        if (!ableToIssueTokens) {\n            throw;\n        }\n         \n         balances[this] += qtyToEmit;\n         etherPrice = qtyForOneEther;\n         totalSupply    += qtyToEmit;\n         \n         // todo: event for this \n    }\n     \n    \n    /**\n     * setEtherPrice - \n     *\n     */     \n    function setEtherPrice(uint qtyForOneEther) onlyAfterEnd\n                                                onlyExecutive {\n         etherPrice = qtyForOneEther; \n\n         // todo: event for this \n    }    \n    \n\n    /**\n     *  disableTokenIssuance - function will disable any \n     *                         option for future issuence\n     *\n     *\n     */\n    function disableTokenIssuance() onlyExecutive {\n        ableToIssueTokens = false;\n        \n        DisableTokenIssuance();\n    }\n\n    \n    /**\n     *  burnRemainToken -  \n     *                    \n     *\n     *\n     */\n    function burnRemainToken() onlyExecutive {\n    \n        balances[this] = 0;\n        \n        // todo: event for this\n    }\n    \n    /**\n     *  submitEtherProposal - \n     *\n     *   @param requestValue - \n     *   @param url - \n     */ \n    function submitEtherProposal(uint requestValue, string url) onlyAfterEnd \n                                                                onlyExecutive returns (bytes32 resultId, bool resultSucces) {       \n    \n        // ensure there is no more issuence available \n        if (ableToIssueTokens) throw;\n            \n        // ensure there is no more tokens available \n        if (balanceOf(this) > 0) throw;\n\n        // Possible to submit a proposal once 2 weeks \n        if (now < (timeOfLastProposal + 2 weeks)) throw;\n            \n        uint percent = collectedEther / 100;\n            \n        if (requestValue > 20 * percent) throw;\n\n        // if remained value is less than requested gain all.\n        if (requestValue > this.balance) \n            requestValue = this.balance;    \n            \n        // set id of the proposal\n        // submit proposal to the map\n        bytes32 id = sha3(msg.data, now);\n        uint timeEnds = now + 10 days; \n            \n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER);\n        proposals[id] = newProposal;\n        listProposals.push(newProposal);\n            \n        timeOfLastProposal = now;                        \n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\n        \n        return (id, true);\n    }\n    \n    \n     \n    /**\n     * \n     * submitHKGProposal - \n     * \n     *  @param requestValue - \n     *  @param url - \n     */\n    function submitHKGProposal(uint requestValue, string url) onlyAfterEnd\n                                                              onlyExecutive returns (bytes32 resultId, bool resultSucces){\n        \n\n        // If there is no 2 months over since the last event.\n        // There is no posible to get any HKG. After 2 months\n        // all the HKG is available. \n        if (now < (eventInfo.getEventEnd() + 8 weeks)) {\n            throw;\n        }\n\n        // Possible to submit a proposal once 2 weeks \n        if (now < (timeOfLastProposal + 2 weeks)) throw;\n\n        uint percent = preferedQtySold / 100;\n        \n        // validate the ammount is legit\n        // first 5 proposals should be less than 20% \n        if (counterProposals <= 5 && \n            requestValue     >  20 * percent) throw;\n                \n        // if remained value is less than requested \n        // gain all.\n        if (requestValue > getHKGOwned()) \n            requestValue = getHKGOwned();\n        \n        \n        // set id of the proposal\n        // submit proposal to the map\n        bytes32 id = sha3(msg.data, now);\n        uint timeEnds = now + 10 days; \n        \n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG);\n        proposals[id] = newProposal;\n        listProposals.push(newProposal);\n        \n        ++counterProposals;\n        timeOfLastProposal = now;                \n                \n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\n        \n        return (id, true);        \n    }  \n    \n    \n    \n    /**\n     * objectProposal - \n     * \n     *  @param id \n     */\n     function objectProposal(bytes32 id){\n         \n        Proposal memory proposal = proposals[id];\n         \n        // check proposal exist \n        if (proposals[id].id == 0) throw;\n\n        // check already redeemed\n        if (proposals[id].redeemed) throw;\n         \n        // ensure objection time\n        if (now >= proposals[id].votindEndTS) throw;\n         \n        // ensure not voted  \n        if (proposals[id].voted[msg.sender]) throw;\n         \n         // submit votes\n         uint votes = votingRights[msg.sender];\n         proposals[id].votesObjecting += votes;\n         \n         // mark voted \n         proposals[id].voted[msg.sender] = true; \n         \n         uint idx = getIndexByProposalId(id);\n         listProposals[idx] = proposals[id];   \n\n         ObjectedVote(id, msg.sender, votes);         \n     }\n     \n     \n     function getIndexByProposalId(bytes32 id) returns (uint result){\n         \n         for (uint i = 0; i < listProposals.length; ++i){\n             if (id == listProposals[i].id) return i;\n         }\n     }\n    \n    \n   \n    /**\n     * redeemProposalFunds - \n     * \n     * @param id bytes32: the id of the proposal to redeem\n     */\n    function redeemProposalFunds(bytes32 id) onlyExecutive {\n\n        if (proposals[id].id == 0) throw;\n        if (proposals[id].submitter != msg.sender) throw;\n\n        // ensure objection time\n        if (now < proposals[id].votindEndTS) throw;\n                           \n    \n            // check already redeemed\n        if (proposals[id].redeemed) throw;\n\n        // check votes objection => 55% of total votes\n        uint objectionThreshold = preferedQtySold / 100 * 55;\n        if (proposals[id].votesObjecting  > objectionThreshold) throw;\n    \n    \n        if (proposals[id].proposalCurrency == ProposalCurrency.HKG){\n            \n            // send hacker gold \n            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \n                        \n        } else {\n                        \n           // send ether              \n           bool success = proposals[id].submitter.send(proposals[id].value); \n\n           // rise event\n           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \n        }\n        \n        // execute the proposal \n        proposals[id].redeemed = true; \n    }\n    \n    \n    /**\n     *  getAllTheFunds\n     * \n     * \n     */             \n    function getAllTheFunds() onlyExecutive {\n        \n        // If there is a deadlock in voting participates\n        // the funds can be redeemed completelly in 6 months\n        if (now < (eventInfo.getEventEnd() + 24 weeks)) {\n            throw;\n        }  \n        \n        // all the Ether\n        bool success = msg.sender.send(this.balance);        \n        \n        // all the HKG\n        hackerGold.transfer(msg.sender, getHKGOwned());              \n    }\n    \n    \n    /**\n     * submitImpeachmentProposal - \n     * \n     *  @param urlDetails  -\n     *  @param newExecutive - \n     * \n     */             \n     function submitImpeachmentProposal(string urlDetails, address newExecutive){\n         \n        // to offer impeachment you should have \n        // voting rights\n        if (votingRights[msg.sender] == 0) throw;\n         \n        // the submission of the first impeachment \n        // proposal is possible only after 3 months\n        // since the hackathon is over\n        if (now < (eventInfo.getEventEnd() + 12 weeks)) throw;\n        \n                \n        // check there is 1 months over since last one\n        if (lastImpeachmentProposal.votindEndTS != 0 && \n            lastImpeachmentProposal.votindEndTS +  2 weeks > now) throw;\n\n\n        // submit impeachment proposal\n        // add the votes of the submitter \n        // to the proposal right away\n        lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender]);\n        lastImpeachmentProposal.voted[msg.sender] = true;\n         \n        // rise event\n        ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive);\n     }\n    \n    \n    /**\n     * supportImpeachment - vote for impeachment proposal \n     *                      that is currently in progress\n     *\n     */\n    function supportImpeachment(){\n\n        // ensure that support is for exist proposal \n        if (lastImpeachmentProposal.newExecutive == 0x0) throw;\n    \n        // to offer impeachment you should have \n        // voting rights\n        if (votingRights[msg.sender] == 0) throw;\n        \n        // check if not voted already \n        if (lastImpeachmentProposal.voted[msg.sender]) throw;\n        \n        // check if not finished the 2 weeks of voting \n        if (lastImpeachmentProposal.votindEndTS + 2 weeks <= now) throw;\n                \n        // support the impeachment\n        lastImpeachmentProposal.voted[msg.sender] = true;\n        lastImpeachmentProposal.votesSupporting += votingRights[msg.sender];\n\n        // rise impeachment suppporting event\n        ImpeachmentSupport(msg.sender, votingRights[msg.sender]);\n        \n        // if the vote is over 70% execute the switch \n        uint percent = preferedQtySold / 100; \n        \n        if (lastImpeachmentProposal.votesSupporting >= 70 * percent){\n            executive = lastImpeachmentProposal.newExecutive;\n            \n            // impeachment event\n            ImpeachmentAccepted(executive);\n        }\n        \n    } \n    \n      \n    \n    // **************************** //\n    // *     Constant Getters     * //\n    // **************************** //    \n    \n    function votingRightsOf(address _owner) constant returns (uint256 result) {\n        result = votingRights[_owner];\n    }\n    \n    function getPreferedQtySold() constant returns (uint result){\n        return preferedQtySold;\n    }\n    \n    function setVirtualExchange(address virtualExchangeAddr){\n        virtualExchangeAddress = virtualExchangeAddr;\n    }\n\n    function getHKGOwned() constant returns (uint result){\n        return hackerGold.balanceOf(this);\n    }\n    \n    function getEtherValue() constant returns (uint result){\n        return this.balance;\n    }\n    \n    function getExecutive() constant returns (address result){\n        return executive;\n    }\n    \n    function getHKGPrice() constant returns (uint result){\n        return hkgPrice;\n    }\n\n    function getEtherPrice() constant returns (uint result){\n        return etherPrice;\n    }\n    \n    function getDSTName() constant returns(string result){\n        return name;\n    }    \n    \n    function getDSTNameBytes() constant returns(bytes32 result){\n        return convert(name);\n    }    \n\n    function getDSTSymbol() constant returns(string result){\n        return symbol;\n    }    \n    \n    function getDSTSymbolBytes() constant returns(bytes32 result){\n        return convert(symbol);\n    }    \n\n    function getAddress() constant returns (address result) {\n        return selfAddress;\n    }\n    \n    function getTotalSupply() constant returns (uint result) {\n        return totalSupply;\n    } \n        \n    function getCollectedEther() constant returns (uint results) {        \n        return collectedEther;\n    }\n    \n    function getCounterProposals() constant returns (uint result){\n        return counterProposals;\n    }\n        \n    function getProposalIdByIndex(uint i) constant returns (bytes32 result){\n        return listProposals[i].id;\n    }    \n\n    function getProposalObjectionByIndex(uint i) constant returns (uint result){\n        return listProposals[i].votesObjecting;\n    }    \n    \n    function getCurrentImpeachmentUrlDetails() constant returns (string result){\n        return lastImpeachmentProposal.urlDetails;\n    }\n    \n    \n    function getCurrentImpeachmentVotesSupporting() constant returns (uint result){\n        return lastImpeachmentProposal.votesSupporting;\n    }\n    \n    function convert(string key) returns (bytes32 ret) {\n            if (bytes(key).length > 32) {\n                throw;\n            }      \n\n            assembly {\n                ret := mload(add(key, 32))\n            }\n    }    \n    \n    \n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //    \n \n    modifier onlyBeforeEnd() { if (now  >=  eventInfo.getEventEnd()) throw; _; }\n    modifier onlyAfterEnd()  { if (now  <   eventInfo.getEventEnd()) throw; _; }\n    \n    modifier onlyAfterTradingStart()  { if (now  < eventInfo.getTradingStart()) throw; _; }\n    \n    modifier onlyExecutive()     { if (msg.sender != executive) throw; _; }\n                                       \n    modifier onlyIfAbleToIssueTokens()  { if (!ableToIssueTokens) throw; _; } \n    \n\n    // ****************** //\n    // *     Events     * //\n    // ****************** //        \n\n    \n    event PriceHKGChange(uint qtyForOneHKG);\n    event BuyForHKGTransaction(uint tokensAmount, uint qtyForOneHKG, uint tokensAvailable, uint tokensSold);\n    \n    event ProposalRequestSubmitted(bytes32 id, uint value, uint timeEnds, string url, address sender);\n    \n    event EtherRedeemAccepted(address sender, uint value);\n    \n    event ObjectedVote(bytes32 id, address voter, uint votes);\n    \n    event ImpeachmentProposed(address submitter, string urlDetails, uint votindEndTS, address newExecutive);\n    event ImpeachmentSupport(address supportter, uint votes);\n    \n    event ImpeachmentAccepted(address newExecutive);\n\n    event DisableTokenIssuance();\n    \n}"
    }
  ]
}