{
  "Title": "[N-01] Typos, wrong comments and naming",
  "Content": "1. These comments are copy-pasted from Auth.sol, we don't check the owner here\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/Dependencies/AuthNoOwner.sol#L33-L34\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/Dependencies/AuthNoOwner.sol#L39-L40\n\n2. Fee floor is actually 0%\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/Dependencies/EbtcBase.sol#L35\n\n3. Entire system debt\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/Dependencies/EbtcBase.sol#L73\n\n4. Memorizing typo\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/Dependencies/Auth.sol#L33\n\n5. `sending EBTC directly to a Liquity`\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/EBTCToken.sol#L22\n\n6. \\_NICR would be more appropriate name\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/HintHelpers.sol#L165\n\nCR is associated with collateral ratio, however in this function we use NICR values to find a hint\n\n7. Wrong pair names in comments\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/PriceFeed.sol#L784\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/PriceFeed.sol#L786\nshould be stETH-ETH feed\n\n8. ETH-USD comment from Liquity\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/CdpManager.sol#L594\n\nshould be stETH-BTC\n\n**[ronnyx2017 (Judge) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/67#issuecomment-1829519278):**\n> There are some other Low/Non-Critical issues downgraded from High/Medium that are also worth noting:\n\n- [Not having a borrowing fee can weaken the peg stability.](https://github.com/code-423n4/2023-10-badger-findings/issues/159)\n- [RolesAuthority: Incorrectly removing the function signature from the target.](https://github.com/code-423n4/2023-10-badger-findings/issues/244)\n- [`LeverageMacroFactory` is susceptible to chain reorganization events.](https://github.com/code-423n4/2023-10-badger-findings/issues/224)\n- [Incorrect calculations in `_chainlinkPriceChangeAboveMax`.](https://github.com/code-423n4/2023-10-badger-findings/issues/73)\n- [`FeeRecipient` address is inconsistent through multiple contracts.](https://github.com/code-423n4/2023-10-badger-findings/issues/70)\n- [`Governor.getUsersByRole` and `Governor.getRolesForUser` return 255 results at most.](https://github.com/code-423n4/2023-10-badger-findings/issues/185) \n- [`LeverageMacroBase.doOperation` being used by openCdp may cause OOG in some cases.](https://github.com/code-423n4/2023-10-badger-findings/issues/151)\n- [Unnecessary restrictions make functions unavailable.](https://github.com/code-423n4/2023-10-badger-findings/issues/112)\n- [Inconsistency in the `feeRecipientAddress` variable setting.](https://github.com/code-423n4/2023-10-badger-findings/issues/17) \n- [`fetchPrice` returns a staler price when oracle is frozen.](https://github.com/code-423n4/2023-10-badger-findings/issues/261)\n- [`CollSurplusPool`'s `FeeRecipientAddress` is defined as immutable and will be out of sync.](https://github.com/code-423n4/2023-10-badger-findings/issues/150)\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/Dependencies/AuthNoOwner.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Authority} from \"./Authority.sol\";\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Modified by BadgerDAO to remove owner\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ncontract AuthNoOwner {\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    Authority private _authority;\n    bool private _authorityInitialized;\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"Auth: UNAUTHORIZED\");\n\n        _;\n    }\n\n    function authority() public view returns (Authority) {\n        return _authority;\n    }\n\n    function authorityInitialized() public view returns (bool) {\n        return _authorityInitialized;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = _authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig));\n    }\n\n    function setAuthority(address newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(_authority.canCall(msg.sender, address(this), msg.sig));\n\n        _authority = Authority(newAuthority);\n\n        // Once authority is set once via any means, ensure it is initialized\n        if (!_authorityInitialized) {\n            _authorityInitialized = true;\n        }\n\n        emit AuthorityUpdated(msg.sender, Authority(newAuthority));\n    }\n\n    /// @notice Changed constructor to initialize to allow flexiblity of constructor vs initializer use\n    /// @notice sets authorityInitiailzed flag to ensure only one use of\n    function _initializeAuthority(address newAuthority) internal {\n        require(address(_authority) == address(0), \"Auth: authority is non-zero\");\n        require(!_authorityInitialized, \"Auth: authority already initialized\");\n\n        _authority = Authority(newAuthority);\n        _authorityInitialized = true;\n\n        emit AuthorityUpdated(address(this), Authority(newAuthority));\n    }\n}"
    },
    {
      "filename": "packages/contracts/contracts/Dependencies/AuthNoOwner.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Authority} from \"./Authority.sol\";\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Modified by BadgerDAO to remove owner\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ncontract AuthNoOwner {\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    Authority private _authority;\n    bool private _authorityInitialized;\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"Auth: UNAUTHORIZED\");\n\n        _;\n    }\n\n    function authority() public view returns (Authority) {\n        return _authority;\n    }\n\n    function authorityInitialized() public view returns (bool) {\n        return _authorityInitialized;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = _authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig));\n    }\n\n    function setAuthority(address newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(_authority.canCall(msg.sender, address(this), msg.sig));\n\n        _authority = Authority(newAuthority);\n\n        // Once authority is set once via any means, ensure it is initialized\n        if (!_authorityInitialized) {\n            _authorityInitialized = true;\n        }\n\n        emit AuthorityUpdated(msg.sender, Authority(newAuthority));\n    }\n\n    /// @notice Changed constructor to initialize to allow flexiblity of constructor vs initializer use\n    /// @notice sets authorityInitiailzed flag to ensure only one use of\n    function _initializeAuthority(address newAuthority) internal {\n        require(address(_authority) == address(0), \"Auth: authority is non-zero\");\n        require(!_authorityInitialized, \"Auth: authority already initialized\");\n\n        _authority = Authority(newAuthority);\n        _authorityInitialized = true;\n\n        emit AuthorityUpdated(address(this), Authority(newAuthority));\n    }\n}"
    },
    {
      "filename": "packages/contracts/contracts/Dependencies/EbtcBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./BaseMath.sol\";\nimport \"./EbtcMath.sol\";\nimport \"../Interfaces/IActivePool.sol\";\nimport \"../Interfaces/IPriceFeed.sol\";\nimport \"../Interfaces/IEbtcBase.sol\";\nimport \"../Dependencies/ICollateralToken.sol\";\n\n/*\n * Base contract for CdpManager, BorrowerOperations. Contains global system constants and\n * common functions.\n */\ncontract EbtcBase is BaseMath, IEbtcBase {\n    // Collateral Ratio applied for Liquidation Incentive\n    // i.e., liquidator repay $1 worth of debt to get back $1.03 worth of collateral\n    uint256 public constant LICR = 1030000000000000000; // 103%\n\n    // Minimum collateral ratio for individual cdps\n    uint256 public constant MCR = 1100000000000000000; // 110%\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint256 public constant CCR = 1250000000000000000; // 125%\n\n    // Amount of stETH collateral to be locked in active pool on opening cdps\n    uint256 public constant LIQUIDATOR_REWARD = 2e17;\n\n    // Minimum amount of stETH collateral a CDP must have\n    uint256 public constant MIN_NET_STETH_BALANCE = 2e18;\n\n    uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n    uint256 public constant BORROWING_FEE_FLOOR = 0; // 0.5%\n\n    uint256 public constant STAKING_REWARD_SPLIT = 5_000; // taking 50% cut from staking reward\n\n    uint256 public constant MAX_REWARD_SPLIT = 10_000;\n\n    IActivePool public immutable activePool;\n\n    IPriceFeed public immutable override priceFeed;\n\n    // the only collateral token allowed in CDP\n    ICollateralToken public immutable collateral;\n\n    /// @notice Initializes the contract with the provided addresses\n    /// @param _activePoolAddress The address of the ActivePool contract\n    /// @param _priceFeedAddress The address of the PriceFeed contract\n    /// @param _collateralAddress The address of the CollateralToken contract\n    constructor(address _activePoolAddress, address _priceFeedAddress, address _collateralAddress) {\n        activePool = IActivePool(_activePoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        collateral = ICollateralToken(_collateralAddress);\n    }\n\n    // --- Gas compensation functions ---\n\n    function _calcNetStEthBalance(uint256 _stEthBalance) internal pure returns (uint256) {\n        return _stEthBalance - LIQUIDATOR_REWARD;\n    }\n\n    /// @notice Get the entire system collateral\n    /// @notice Entire system collateral = collateral allocated to system in ActivePool, using it's internal accounting\n    /// @dev Collateral tokens stored in ActivePool for liquidator rewards, fees, or coll in CollSurplusPool, are not included\n    function getSystemCollShares() public view returns (uint256 entireSystemColl) {\n        return (activePool.getSystemCollShares());\n    }\n\n    /**\n        @notice Get the entire system debt\n        @notice Entire system collateral = collateral stored in ActivePool, using their internal accounting\n     */\n    function _getSystemDebt() internal view returns (uint256 entireSystemDebt) {\n        return (activePool.getSystemDebt());\n    }\n\n    function _getCachedTCR(uint256 _price) internal view returns (uint256 TCR) {\n        (TCR, , ) = _getTCRWithSystemDebtAndCollShares(_price);\n    }\n\n    function _getTCRWithSystemDebtAndCollShares(\n        uint256 _price\n    ) internal view returns (uint256 TCR, uint256 _coll, uint256 _debt) {\n        uint256 systemCollShares = getSystemCollShares();\n        uint256 systemDebt = _getSystemDebt();\n\n        uint256 _systemStEthBalance = collateral.getPooledEthByShares(systemCollShares);\n        TCR = EbtcMath._computeCR(_systemStEthBalance, systemDebt, _price);\n\n        return (TCR, systemCollShares, systemDebt);\n    }\n\n    function _checkRecoveryMode(uint256 _price) internal view returns (bool) {\n        return _checkRecoveryModeForTCR(_getCachedTCR(_price));\n    }\n\n    function _checkRecoveryModeForTCR(uint256 _tcr) internal view returns (bool) {\n        return _tcr < CCR;\n    }\n\n    function _requireUserAcceptsFee(\n        uint256 _fee,\n        uint256 _amount,\n        uint256 _maxFeePercentage\n    ) internal pure {\n        uint256 feePercentage = (_fee * DECIMAL_PRECISION) / _amount;\n        require(feePercentage <= _maxFeePercentage, \"Fee exceeded provided maximum\");\n    }\n\n    // Convert debt denominated in ETH to debt denominated in BTC given that _price is ETH/BTC\n    // _debt is denominated in ETH\n    // _price is ETH/BTC\n    function _convertDebtDenominationToBtc(\n        uint256 _debt,\n        uint256 _price\n    ) internal pure returns (uint256) {\n        return (_debt * _price) / DECIMAL_PRECISION;\n    }\n\n    /// @dev return true if given ICR is qualified for liquidation compared to configured threshold\n    /// @dev this function ONLY checks numbers not check grace period switch for Recovery Mode\n    function _checkICRAgainstLiqThreshold(uint256 _icr, uint _tcr) internal view returns (bool) {\n        // Either undercollateralized\n        // OR, it's RM AND they meet the requirement\n        // Swapped Requirement && RM to save gas\n        return\n            _checkICRAgainstMCR(_icr) ||\n            (_checkICRAgainstTCR(_icr, _tcr) && _checkRecoveryModeForTCR(_tcr));\n    }\n\n    /// @dev return true if given ICR is qualified for liquidation compared to MCR\n    function _checkICRAgainstMCR(uint256 _icr) internal view returns (bool) {\n        return _icr < MCR;\n    }\n\n    /// @dev return true if given ICR is qualified for liquidation compared to TCR\n    /// @dev typically used in Recovery Mode\n    function _checkICRAgainstTCR(uint256 _icr, uint _tcr) internal view returns (bool) {\n        /// @audit is _icr <= _tcr more dangerous for overal system safety?\n        /// @audit Should we use _icr < CCR to allow any risky CDP being liquidated?\n        return _icr <= _tcr;\n    }\n}"
    },
    {
      "filename": "packages/contracts/contracts/Dependencies/EbtcBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./BaseMath.sol\";\nimport \"./EbtcMath.sol\";\nimport \"../Interfaces/IActivePool.sol\";\nimport \"../Interfaces/IPriceFeed.sol\";\nimport \"../Interfaces/IEbtcBase.sol\";\nimport \"../Dependencies/ICollateralToken.sol\";\n\n/*\n * Base contract for CdpManager, BorrowerOperations. Contains global system constants and\n * common functions.\n */\ncontract EbtcBase is BaseMath, IEbtcBase {\n    // Collateral Ratio applied for Liquidation Incentive\n    // i.e., liquidator repay $1 worth of debt to get back $1.03 worth of collateral\n    uint256 public constant LICR = 1030000000000000000; // 103%\n\n    // Minimum collateral ratio for individual cdps\n    uint256 public constant MCR = 1100000000000000000; // 110%\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint256 public constant CCR = 1250000000000000000; // 125%\n\n    // Amount of stETH collateral to be locked in active pool on opening cdps\n    uint256 public constant LIQUIDATOR_REWARD = 2e17;\n\n    // Minimum amount of stETH collateral a CDP must have\n    uint256 public constant MIN_NET_STETH_BALANCE = 2e18;\n\n    uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n    uint256 public constant BORROWING_FEE_FLOOR = 0; // 0.5%\n\n    uint256 public constant STAKING_REWARD_SPLIT = 5_000; // taking 50% cut from staking reward\n\n    uint256 public constant MAX_REWARD_SPLIT = 10_000;\n\n    IActivePool public immutable activePool;\n\n    IPriceFeed public immutable override priceFeed;\n\n    // the only collateral token allowed in CDP\n    ICollateralToken public immutable collateral;\n\n    /// @notice Initializes the contract with the provided addresses\n    /// @param _activePoolAddress The address of the ActivePool contract\n    /// @param _priceFeedAddress The address of the PriceFeed contract\n    /// @param _collateralAddress The address of the CollateralToken contract\n    constructor(address _activePoolAddress, address _priceFeedAddress, address _collateralAddress) {\n        activePool = IActivePool(_activePoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        collateral = ICollateralToken(_collateralAddress);\n    }\n\n    // --- Gas compensation functions ---\n\n    function _calcNetStEthBalance(uint256 _stEthBalance) internal pure returns (uint256) {\n        return _stEthBalance - LIQUIDATOR_REWARD;\n    }\n\n    /// @notice Get the entire system collateral\n    /// @notice Entire system collateral = collateral allocated to system in ActivePool, using it's internal accounting\n    /// @dev Collateral tokens stored in ActivePool for liquidator rewards, fees, or coll in CollSurplusPool, are not included\n    function getSystemCollShares() public view returns (uint256 entireSystemColl) {\n        return (activePool.getSystemCollShares());\n    }\n\n    /**\n        @notice Get the entire system debt\n        @notice Entire system collateral = collateral stored in ActivePool, using their internal accounting\n     */\n    function _getSystemDebt() internal view returns (uint256 entireSystemDebt) {\n        return (activePool.getSystemDebt());\n    }\n\n    function _getCachedTCR(uint256 _price) internal view returns (uint256 TCR) {\n        (TCR, , ) = _getTCRWithSystemDebtAndCollShares(_price);\n    }\n\n    function _getTCRWithSystemDebtAndCollShares(\n        uint256 _price\n    ) internal view returns (uint256 TCR, uint256 _coll, uint256 _debt) {\n        uint256 systemCollShares = getSystemCollShares();\n        uint256 systemDebt = _getSystemDebt();\n\n        uint256 _systemStEthBalance = collateral.getPooledEthByShares(systemCollShares);\n        TCR = EbtcMath._computeCR(_systemStEthBalance, systemDebt, _price);\n\n        return (TCR, systemCollShares, systemDebt);\n    }\n\n    function _checkRecoveryMode(uint256 _price) internal view returns (bool) {\n        return _checkRecoveryModeForTCR(_getCachedTCR(_price));\n    }\n\n    function _checkRecoveryModeForTCR(uint256 _tcr) internal view returns (bool) {\n        return _tcr < CCR;\n    }\n\n    function _requireUserAcceptsFee(\n        uint256 _fee,\n        uint256 _amount,\n        uint256 _maxFeePercentage\n    ) internal pure {\n        uint256 feePercentage = (_fee * DECIMAL_PRECISION) / _amount;\n        require(feePercentage <= _maxFeePercentage, \"Fee exceeded provided maximum\");\n    }\n\n    // Convert debt denominated in ETH to debt denominated in BTC given that _price is ETH/BTC\n    // _debt is denominated in ETH\n    // _price is ETH/BTC\n    function _convertDebtDenominationToBtc(\n        uint256 _debt,\n        uint256 _price\n    ) internal pure returns (uint256) {\n        return (_debt * _price) / DECIMAL_PRECISION;\n    }\n\n    /// @dev return true if given ICR is qualified for liquidation compared to configured threshold\n    /// @dev this function ONLY checks numbers not check grace period switch for Recovery Mode\n    function _checkICRAgainstLiqThreshold(uint256 _icr, uint _tcr) internal view returns (bool) {\n        // Either undercollateralized\n        // OR, it's RM AND they meet the requirement\n        // Swapped Requirement && RM to save gas\n        return\n            _checkICRAgainstMCR(_icr) ||\n            (_checkICRAgainstTCR(_icr, _tcr) && _checkRecoveryModeForTCR(_tcr));\n    }\n\n    /// @dev return true if given ICR is qualified for liquidation compared to MCR\n    function _checkICRAgainstMCR(uint256 _icr) internal view returns (bool) {\n        return _icr < MCR;\n    }\n\n    /// @dev return true if given ICR is qualified for liquidation compared to TCR\n    /// @dev typically used in Recovery Mode\n    function _checkICRAgainstTCR(uint256 _icr, uint _tcr) internal view returns (bool) {\n        /// @audit is _icr <= _tcr more dangerous for overal system safety?\n        /// @audit Should we use _icr < CCR to allow any risky CDP being liquidated?\n        return _icr <= _tcr;\n    }\n}"
    },
    {
      "filename": "packages/contracts/contracts/Dependencies/Auth.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Authority} from \"./Authority.sol\";\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnershipTransferred(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"Auth: UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return\n            (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) ||\n            user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function transferOwnership(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}"
    },
    {
      "filename": "packages/contracts/contracts/EBTCToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Interfaces/IEBTCToken.sol\";\n\nimport \"./Dependencies/AuthNoOwner.sol\";\nimport \"./Dependencies/PermitNonce.sol\";\n\n/*\n *\n * Based upon OpenZeppelin's ERC20 contract:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n *\n * and their EIP2612 (ERC20Permit / ERC712) functionality:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\n *\n *\n * --- Functionality added specific to the EBTCToken ---\n *\n * 1) Transfer protection: blocklist of addresses that are invalid recipients (i.e. core Ebtc contracts) in external transfer() and transferFrom() calls.\n * The purpose is to protect users from losing tokens by mistakenly sending EBTC directly to a Liquity.\n * core contract, when they should rather call the right function.\n */\n\ncontract EBTCToken is IEBTCToken, AuthNoOwner, PermitNonce {\n    uint256 private _totalSupply;\n    string internal constant _NAME = \"EBTC Stablecoin\";\n    string internal constant _SYMBOL = \"EBTC\";\n    string internal constant _VERSION = \"1\";\n    uint8 internal constant _DECIMALS = 18;\n\n    // --- Data for EIP2612 ---\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant _TYPE_HASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n\n    // User data for EBTC token\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    // --- Addresses ---\n    address public immutable cdpManagerAddress;\n    address public immutable borrowerOperationsAddress;\n\n    /// @param _cdpManagerAddress Address of the CDP Manager\n    /// @param _borrowerOperationsAddress Address of the Borrower Operations\n    /// @param _authorityAddress Address of the authority for the contract\n    constructor(\n        address _cdpManagerAddress,\n        address _borrowerOperationsAddress,\n        address _authorityAddress\n    ) {\n        _initializeAuthority(_authorityAddress);\n\n        cdpManagerAddress = _cdpManagerAddress;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n\n        bytes32 hashedName = keccak256(bytes(_NAME));\n        bytes32 hashedVersion = keccak256(bytes(_VERSION));\n\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _chainID();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);\n    }\n\n    /// @notice Mint new tokens\n    /// @dev Internal system function - only callable by BorrowerOperations or CDPManager\n    /// @dev Governance can also expand the list of approved minters to enable other systems to mint tokens\n    /// @param _account The address to receive the newly minted tokens\n    /// @param _amount The amount of tokens to mint\n    function mint(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorCdpMOrAuth();\n        _mint(_account, _amount);\n    }\n\n    /// @notice Burn existing tokens\n    /// @dev Internal system function - only callable by BorrowerOperations or CDPManager\n    /// @dev Governance can also expand the list of approved burners to enable other systems to burn tokens\n    /// @param _account The address to burn tokens from\n    /// @param _amount The amount of tokens to burn\n    function burn(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorCdpMOrAuth();\n        _burn(_account, _amount);\n    }\n\n    /// @notice Burn existing tokens from caller\n    /// @dev Internal system function - only callable by BorrowerOperations or CDPManager\n    /// @dev Governance can also expand the list of approved burners to enable other systems to burn tokens\n    /// @param _amount The amount of tokens to burn\n    function burn(uint256 _amount) external {\n        _requireCallerIsBOorCdpMOrAuth();\n        _burn(msg.sender, _amount);\n    }\n\n    // --- External functions ---\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(sender, recipient, amount);\n\n        uint256 cachedAllowance = _allowances[sender][msg.sender];\n        if (cachedAllowance != type(uint256).max) {\n            require(cachedAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n            unchecked {\n                _approve(sender, msg.sender, cachedAllowance - amount);\n            }\n        }\n        return true;\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) external override returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) external override returns (bool) {\n        uint256 cachedAllowances = _allowances[msg.sender][spender];\n        require(cachedAllowances >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(msg.sender, spender, cachedAllowances - subtractedValue);\n        }\n        return true;\n    }\n\n    // --- EIP 2612 Functionality (https://eips.ethereum.org/EIPS/eip-2612) ---\n\n    /// @notice This function returns the domain separator for current chain\n    /// @return EIP712 compatible Domain definition\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return domainSeparator();\n    }\n\n    /// @notice This function returns the domain separator for current chain\n    /// @return EIP712 compatible Domain definition\n    function domainSeparator() public view override returns (bytes32) {\n        if (_chainID() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    /// @notice This function approve given amount for specified owner and spender\n    /// @notice by verifying the validity of given deadline and signature parameters (v, r, s).\n    /// @param owner The token owner\n    /// @param spender The consumer to which owner want to grant approval\n    /// @param amount The token expenditure budget to be set\n    /// @param deadline The permit valid deadline\n    /// @param v The v part of signature from owner\n    /// @param r The r part of signature from owner\n    /// @param s The s part of signature from owner\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"EBTC: expired deadline\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator(),\n                keccak256(\n                    abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner]++, deadline)\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == owner, \"EBTC: invalid signature\");\n        _approve(owner, spender, amount);\n    }\n\n    /// @dev Return current nonce for specified owner fOR EIP-2612 compatibility\n    /// @param owner The address whose nonce to be queried\n    function nonces(address owner) external view override(IERC2612, PermitNonce) returns (uint256) {\n        return _nonces[owner];\n    }\n\n    // --- Internal operations ---\n\n    function _chainID() private view returns (uint256) {\n        return block.chainid;\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 name,\n        bytes32 version\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, name, version, _chainID(), address(this)));\n    }\n\n    // --- Internal operations ---\n    // Warning: sanity checks (for sender and recipient) should have been done before calling these internal functions\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"EBTCToken: zero sender!\");\n        require(recipient != address(0), \"EBTCToken: zero recipient!\");\n\n        uint256 cachedSenderBalances = _balances[sender];\n        require(cachedSenderBalances >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        unchecked {\n            // Safe because of the check above\n            _balances[sender] = cachedSenderBalances - amount;\n        }\n\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"EBTCToken: mint to zero recipient!\");\n\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"EBTCToken: burn from zero account!\");\n\n        uint256 cachedBalance = _balances[account];\n        require(cachedBalance >= amount, \"ERC20: burn amount exceeds balance\");\n\n        unchecked {\n            // Safe because of the check above\n            _balances[account] = cachedBalance - amount;\n        }\n\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"EBTCToken: zero approve owner!\");\n        require(spender != address(0), \"EBTCToken: zero approve spender!\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"EBTC: Cannot transfer tokens directly to the EBTC token contract or the zero address\"\n        );\n        require(\n            _recipient != cdpManagerAddress && _recipient != borrowerOperationsAddress,\n            \"EBTC: Cannot transfer tokens directly to the CdpManager or BorrowerOps\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"EBTCToken: Caller is not BorrowerOperations\"\n        );\n    }\n\n    /// @dev authority check last to short-circuit in the case of use by usual immutable addresses\n    function _requireCallerIsBOorCdpMOrAuth() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == cdpManagerAddress ||\n                isAuthorized(msg.sender, msg.sig),\n            \"EBTC: Caller is neither BorrowerOperations nor CdpManager nor authorized\"\n        );\n    }\n\n    function _requireCallerIsCdpM() internal view {\n        require(msg.sender == cdpManagerAddress, \"EBTC: Caller is not CdpManager\");\n    }\n\n    // --- Optional functions ---\n\n    /// @notice Returns the name of the token\n    /// @return Name of the token\n    function name() external pure override returns (string memory) {\n        return _NAME;\n    }\n\n    /// @notice Returns the symbol of the token\n    /// @return Symbol of the token\n    functi"
    }
  ]
}