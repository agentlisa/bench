{
  "Title": "[G-19] Amounts should be checked for 0 before calling a transfer",
  "Content": "\nChecking non-zero transfer values can avoid an expensive external call and save gas.\nWhile this is done at some places, itâ€™s not consistently done in the solution.\nI suggest adding a non-zero-value \n\n\n```solidity\nfile:  contracts/RangeManager.sol\n\n96     ASSET_0.safeTransferFrom(msg.sender, address(this), amount0);\n\n98     ASSET_1.safeTransferFrom(msg.sender, address(this), amount1);\n\n176    transferAssetsIntoStep(tokenisedRanges[step], step, amount0, amount1);\n\n185    transferAssetsIntoStep(tokenisedTicker[step], step, amount0, amount1);\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/RangeManager.sol#L96\n\n\n```solidity\nfile:  contracts/helper/V3Proxy.sol\n\n164    ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n\n165    ogInAsset.safeApprove(address(ROUTER), amountInMax);\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/helper/V3Proxy.sol#L164\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-08-goodentry",
  "Code": [
    {
      "filename": "contracts/RangeManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"../interfaces/IAaveLendingPoolV2.sol\";\nimport \"../interfaces/IAaveOracle.sol\";\nimport \"../interfaces/IUniswapV2Pair.sol\";\nimport \"../interfaces/IUniswapV2Factory.sol\";\nimport \"../interfaces/IUniswapV2Router01.sol\";\nimport \"../interfaces/ISwapRouter.sol\";\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"./TokenisableRange.sol\";\nimport \"./openzeppelin-solidity/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"./openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\n\n\n/// @title Range middleware between ROE lending pool and various ranges\ncontract RangeManager is ReentrancyGuard, Ownable {\n  using SafeERC20 for ERC20;\n  ILendingPool public LENDING_POOL;\n  event Withdraw(address user, address asset, uint amount);\n  event Deposit(address user, address asset, uint amount);\n  event AddRange(uint128 startX10, uint128 endX10, uint step);\n\n  ERC20 public ASSET_0;\n  ERC20 public ASSET_1;\n\n  // Constant across chains - https://docs.uniswap.org/protocol/reference/deployments\n  INonfungiblePositionManager constant public POS_MGR = INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);  \n\n  struct Step {\n    uint128 start;\n    uint128 end;\n  }\n\n  Step [] public stepList; \n  TokenisableRange [] public tokenisedRanges;\n  TokenisableRange [] public tokenisedTicker;\n  \n  \n  constructor(ILendingPool lendingPool, ERC20 _asset0, ERC20 _asset1)  {\n    require( address(lendingPool) != address(0x0), \"Invalid address\" );\n    LENDING_POOL = lendingPool;\n    ASSET_0 = _asset0 < _asset1 ? _asset0 : _asset1;\n    ASSET_1 = _asset0 < _asset1 ? _asset1 : _asset0;\n  }\n\n\n  /// @notice Checks validity and non overlap of the price ranges\n  /// @param start range low price bound\n  /// @param end range high price bound\n  function checkNewRange(uint128 start, uint128 end) internal view {\n    require(start < end, \"Range invalid\");\n    uint256 len = stepList.length;\n    for (uint i = 0; i < len; i++) {\n      if (start >= stepList[i].end || end <= stepList[i].start) {\n        continue;\n      }\n      revert(\"Range overlap\");\n    } \n  }\n  \n  /// @notice Generate Ticker and Ranger ranges\n  /// @param startX10 Range lower price scaled by 1e10\n  /// @param endX10 Range high price scaled by 1e10\n  /// @param startName Name of the range lower bound \n  /// @param endName Name of the range higher bound\n  function generateRange(uint128 startX10, uint128 endX10, string memory startName, string memory endName, address beacon) external onlyOwner {\n    require(beacon != address(0x0), \"Invalid beacon\");\n    checkNewRange(startX10, endX10);\n    stepList.push( Step(startX10, endX10) );\n    BeaconProxy trbp = new BeaconProxy(beacon, \"\");\n    tokenisedRanges.push( TokenisableRange(address(trbp)) );\n    trbp = new BeaconProxy(beacon, \"\");\n    tokenisedTicker.push( TokenisableRange(address(trbp)) );\n    IAaveOracle oracle = IAaveOracle(ILendingPoolAddressesProvider( LENDING_POOL.getAddressesProvider() ).getPriceOracle());\n    \n    tokenisedRanges[ tokenisedRanges.length - 1 ].initProxy(oracle, ASSET_0, ASSET_1, startX10, endX10, startName, endName, false);\n    tokenisedTicker[ tokenisedTicker.length - 1 ].initProxy(oracle, ASSET_0, ASSET_1, startX10, endX10, startName, endName, true); \n    emit AddRange(startX10, endX10, tokenisedRanges.length - 1);\n  }\n  \n  \n  /// @notice Initialize a previously created ticker\n  /// @param tr Range address\n  /// @param amount0 Amount of token0\n  /// @param amount1 Amount of token1\n  function initRange(address tr, uint amount0, uint amount1) external onlyOwner {\n    ASSET_0.safeTransferFrom(msg.sender, address(this), amount0);\n    ASSET_0.safeIncreaseAllowance(tr, amount0);\n    ASSET_1.safeTransferFrom(msg.sender, address(this), amount1);\n    ASSET_1.safeIncreaseAllowance(tr, amount1);\n    TokenisableRange(tr).init(amount0, amount1);\n    ERC20(tr).safeTransfer(msg.sender, TokenisableRange(tr).balanceOf(address(this)));\n  }\n\n\n  /// @notice Remove assets from tokenisedRanges\n  /// @param step Id of the range+ticker step from which to remove assets\n  function removeFromStep(uint256 step) internal {\n    require(step < tokenisedRanges.length && step < tokenisedTicker.length, \"Invalid step\");\n    uint256 trAmt;\n    \n    trAmt = ERC20(LENDING_POOL.getReserveData(address(tokenisedRanges[step])).aTokenAddress).balanceOf(msg.sender);   \n    if (trAmt > 0) {       \n        LENDING_POOL.PMTransfer(\n          LENDING_POOL.getReserveData(address(tokenisedRanges[step])).aTokenAddress, \n          msg.sender, \n          trAmt\n        );\n        trAmt = LENDING_POOL.withdraw(address(tokenisedRanges[step]), type(uint256).max, address(this));\n        tokenisedRanges[step].withdraw(trAmt, 0, 0);\n        emit Withdraw(msg.sender, address(tokenisedRanges[step]), trAmt);\n    }        \n\n    trAmt = ERC20(LENDING_POOL.getReserveData(address(tokenisedTicker[step])).aTokenAddress).balanceOf(msg.sender);\n    if (trAmt > 0) {    \n        LENDING_POOL.PMTransfer(\n          LENDING_POOL.getReserveData(address(tokenisedTicker[step])).aTokenAddress, \n          msg.sender, \n          trAmt\n        );\n        uint256 ttAmt = LENDING_POOL.withdraw(address(tokenisedTicker[step]), type(uint256).max, address(this));\n        tokenisedTicker[step].withdraw(ttAmt, 0, 0);\n        emit Withdraw(msg.sender, address(tokenisedTicker[step]), trAmt);\n    }           \n  }\n\n\n  /// @notice Remove assets from tokenisedRanges\n  /// @param step Id of the range+ticker step from which to remove assets\n  function removeAssetsFromStep(uint256 step) nonReentrant external {\n    removeFromStep(step);\n    cleanup();\n  }\n  \n  \n  /// @notice Transfer assets from the lending pool to a tokenizedRange\n  /// @param tr TokenisableRange instance into which to transfer assets\n  /// @param step Id of the range+ticker step from which to remove assets\n  /// @param amount0 Amount of asset0 to transfer in the TR\n  /// @param amount1 Amount of asset1 to transfer in the TR\n  /// @dev Useful to remove from a previous range and deposit into a new TR when price moves\n  function transferAssetsIntoStep(TokenisableRange tr, uint256 step, uint256 amount0, uint256 amount1) internal {\n    removeFromStep(step);\n    if (amount0 > 0) {    \n      LENDING_POOL.PMTransfer( LENDING_POOL.getReserveData(address(ASSET_0)).aTokenAddress, msg.sender, amount0 );\n      LENDING_POOL.withdraw( address(ASSET_0), amount0, address(this) );\n      ASSET_0.safeIncreaseAllowance(address(tr), amount0);\n    }\n    if (amount1 > 0) {\n      LENDING_POOL.PMTransfer( LENDING_POOL.getReserveData(address(ASSET_1)).aTokenAddress, msg.sender, amount1 );\n      LENDING_POOL.withdraw( address(ASSET_1), amount1, address(this) );\n      ASSET_1.safeIncreaseAllowance(address(tr), amount1);\n    }\n    uint256 lpAmt = tr.deposit(amount0, amount1);\n    emit Deposit(msg.sender, address(tr), lpAmt);\n    tr.approve(address(LENDING_POOL), lpAmt);\n    LENDING_POOL.deposit(address(tr), lpAmt, msg.sender, 0);\n    cleanup();\n  }\n\n\n  /// @notice Transfer assets from the lending pool to a Ranger\n  /// @param step Id of the range+ticker step from which to remove assets\n  /// @param amount0 Amount of asset0 to transfer in the Range\n  /// @param amount1 Amount of asset1 to transfer in the Range\n  function transferAssetsIntoRangerStep(uint256 step, uint256 amount0, uint256 amount1) nonReentrant external {\n    transferAssetsIntoStep(tokenisedRanges[step], step, amount0, amount1);\n  }\n\n\n  /// @notice Transfer assets from the lending pool to a Ticker\n  /// @param step Id of the range+ticker step from which to remove assets\n  /// @param amount0 Amount of asset0 to transfer in the Ticker\n  /// @param amount1 Amount of asset1 to transfer in the Ticker\n  function transferAssetsIntoTickerStep(uint256 step, uint256 amount0, uint256 amount1) nonReentrant external {\n    transferAssetsIntoStep(tokenisedTicker[step], step, amount0, amount1);\n  }\n\n\n  /// @notice Check token balances and return assets to the user\n  function cleanup() internal {\n    uint256 asset0_amt = ASSET_0.balanceOf(address(this));\n    uint256 asset1_amt = ASSET_1.balanceOf(address(this));\n    \n    if (asset0_amt > 0) {\n      ASSET_0.safeIncreaseAllowance(address(LENDING_POOL), asset0_amt);\n      LENDING_POOL.deposit(address(ASSET_0), asset0_amt, msg.sender, 0);\n    }\n    \n    if (asset1_amt > 0) {\n      ASSET_1.safeIncreaseAllowance(address(LENDING_POOL), asset1_amt);\n      LENDING_POOL.deposit(address(ASSET_1), asset1_amt, msg.sender, 0);\n    }\n    \n    // Check that health factor is not put into liquidation / with buffer\n    (,,,,,uint256 hf) = LENDING_POOL.getUserAccountData(msg.sender);\n    require(hf > 1.01e18, \"Health factor is too low\");\n  }\n\n\n  /// @notice Get length of stepList\n  /// @return listLength Length\n  function getStepListLength() external view returns (uint256 listLength) {\n    listLength = stepList.length;\n  }\n}"
    },
    {
      "filename": "contracts/helper/V3Proxy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.19;\nimport \"../openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"../openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\"; \n\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n    function refundETH() external payable;\n    function WETH9() external view returns (address);\n}\n\n\ninterface IQuoter {\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n    \n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n\ninterface IWETH9 is IERC20 {\n    function withdraw(uint) external;\n}\n\ncontract V3Proxy is ReentrancyGuard, Ownable {\n    using SafeERC20 for ERC20;\n    ISwapRouter immutable public ROUTER;\n    IQuoter     immutable public QUOTER;\n    uint24      immutable public feeTier; \n    bool acceptPayable;\n    \n    event Swap(\n        address indexed user, \n        address indexed assetIn,\n        address indexed assetOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    \n    constructor(ISwapRouter _router, IQuoter _quoter, uint24 _fee) {\n        ROUTER = _router;\n        QUOTER = _quoter;\n        feeTier = _fee;\n    \n    }\n    \n    function WETH() external view returns (address) {\n        return ROUTER.WETH9();\n    }     \n    \n    receive() external payable {\n        require(acceptPayable, \"CannotReceiveETH\");\n    }\n    \n    fallback() external payable {\n       require(acceptPayable, \"CannotReceiveETH\");\n    }\n    \n    function emergencyWithdraw(ERC20 token) onlyOwner external {   \n        token.safeTransfer(msg.sender, token.balanceOf( address(this) ) );  // msg.sender has been Required to be owner\n    }\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        amounts = new uint[](2);\n        amounts[0] = amountIn;\n        amounts[1] = QUOTER.quoteExactInputSingle(path[0], path[1], feeTier, amountIn, 0);\n    }\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        amounts = new uint[](2);\n        amounts[0] = QUOTER.quoteExactOutputSingle(path[0], path[1], feeTier, amountOut, 0);\n        amounts[1] = amountOut;\n    }\n\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountIn);\n        ogInAsset.safeApprove(address(ROUTER), amountIn);\n        amounts = new uint[](2);\n        amounts[0] = amountIn;         \n        amounts[1] = ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountIn, amountOutMin, 0));\n        ogInAsset.safeApprove(address(ROUTER), 0);\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n        ogInAsset.safeApprove(address(ROUTER), amountInMax);\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountOut, amountInMax, 0));         \n        amounts[1] = amountOut; \n        ogInAsset.safeTransfer(msg.sender, ogInAsset.balanceOf(address(this)));\n        ogInAsset.safeApprove(address(ROUTER), 0);\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[0] == ROUTER.WETH9(), \"Invalid path\");\n        amounts = new uint[](2);\n        amounts[0] = msg.value;         \n        amounts[1] = ROUTER.exactInputSingle{value: msg.value}(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, msg.value, amountOutMin, 0));\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]);  \n    }\n\n    \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[0] == ROUTER.WETH9(), \"Invalid path\");\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle{value: msg.value}(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountOut, msg.value, 0));         \n        amounts[1] = amountOut;\n        acceptPayable = true;\n        ROUTER.refundETH();\n        acceptPayable = false;\n        msg.sender.call{value: msg.value - amounts[0]}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n    \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[1] == ROUTER.WETH9(), \"Invalid path\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n        ogInAsset.safeApprove(address(ROUTER), amountInMax);\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, address(this), deadline, amountOut, amountInMax, 0));         \n        amounts[1] = amountOut; \n        ogInAsset.safeApprove(address(ROUTER), 0);\n        IWETH9 weth = IWETH9(ROUTER.WETH9());\n        acceptPayable = true;\n        weth.withdraw(amountOut);\n        acceptPayable = false;\n        payable(msg.sender).call{value: amountOut}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n       \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[1] == ROUTER.WETH9(), \"Invalid path\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountIn);\n        ogInAsset.safeApprove(address(ROUTER), amountIn);\n        amounts = new uint[](2);\n        amounts[0] = amountIn;         \n        amounts[1] = ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, address(this), deadline, amountIn, amountOutMin, 0));\n        ogInAsset.safeApprove(address(ROUTER), 0); \n        IWETH9 weth = IWETH9(ROUTER.WETH9());\n        acceptPayable = true;\n        weth.withdraw(amounts[1]);\n        acceptPayable = false;\n        payable(msg.sender).call{value: amounts[1]}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]);                 \n    }\n\n}"
    }
  ]
}