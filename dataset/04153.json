{
  "Title": "[L10] Repeated code",
  "Content": "Throughout the code base, there is consistent use of repeated code. Some instances of repeated code are as follows:\n\n\n* All the arithmetic functions, such as in [`AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L155-L163) or in [`OracleRelayer`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/OracleRelayer.sol#L121-L157), are repeated in many contracts. Note that these arithmetic functions are well covered by [OpenZeppelin Math libraries](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/release-v3.1.0/contracts/math), which are battle tested and widely adopted contracts.\n* The governance functions [`addAuthorization` and `removeAuthorization`, and the modifier `isAuthorized`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L61-L79) are repetitive.\n* Similarly, the [`either`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L496) and [`both`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L499) functions, which are just performing logical `OR` and `AND` operations, are often repeated in the code base.\n* Lines [199-201](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/StabilityFeeTreasury.sol#L199-L201) of the `disableContract` function in the `StabilityFeeTreasury` contract are the same as the [`joinAllCoins`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/StabilityFeeTreasury.sol#L216) function.\n* The conditions on lines [317-320](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L317-L320) and [line 348](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L348) of the `LiquidationEngine` contract are identical.\n* Lines [489-491](https://github.com/reflexer-labs/geb/blob/master/src/SAFEEngine.sol#L489-L491) and [353-355](https://github.com/reflexer-labs/geb/blob/master/src/SAFEEngine.sol#L353-L355) of the `SAFEEngine` contract are repeated.\n* Lines [717](https://github.com/reflexer-labs/geb/blob/master/src/CollateralAuctionHouse.sol#L717) and [726](https://github.com/reflexer-labs/geb/blob/master/src/CollateralAuctionHouse.sol#L726) of the `FixedDiscountCollateralAuctionHouse` contract are repeated.\n* [`getApproximateCollateralBought`](https://github.com/reflexer-labs/geb/blob/master/src/CollateralAuctionHouse.sol#L708) and [`getCollateralBought`](https://github.com/reflexer-labs/geb/blob/master/src/CollateralAuctionHouse.sol#L750)  \n\nfunctions of the `FixedDiscountCollateralAuctionHouse` contract are almost identical.\n\n\nSolidity language provides the use of libraries to call functions that need to be accessed by several contracts and that are always the same. Having libraries is easy for code maintenance since any bug or new functionality can be coded in only one single contract that serves all the others. Also, libraries can also help in reducing the gas cost associated with deployment and use of the contracts while reducing the potential attack surface. Contracts can also define internal functions that are then called internally in many places.\n\n\nConsider adopting libraries and internal functions design to improve code size, quality and readability at the same time.\n\n\n***Update:** Partially fixed in [pull request #84](https://github.com/reflexer-labs/geb/pull/84/files). Lines [199-201 in `StabilityFeeTreasury`](https://github.com/reflexer-labs/geb/pull/84/files#diff-e601d3dfb2a01df7d2653dbdc4614c85871f9ef0e44cab28d9872a862c226dd7L199-R199) have been replaced with a call to `joinAllCoins`, and the [`getAdjustedBid` function](https://github.com/reflexer-labs/geb/pull/84/files#diff-80c57ef7b55d3f669cd4d6f09cd61023b6fad55d93312c251a09bc236a52b5faR667-R692) has been created to consolidate functionality for `getApproximateCollateralBought` and `getCollateralBought`.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/AccountingEngine.sol",
      "content": "/// AccountingEngine.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract DebtAuctionHouseLike {\n    function startAuction(address incomeReceiver, uint amountToSell, uint initialBid) virtual public returns (uint);\n    function protocolToken() virtual public view returns (address);\n    function disableContract() virtual external;\n    function contractEnabled() virtual public view returns (uint);\n}\n\nabstract contract SurplusAuctionHouseLike {\n    function startAuction(uint, uint) virtual public returns (uint);\n    function protocolToken() virtual public view returns (address);\n    function disableContract() virtual external;\n    function contractEnabled() virtual public view returns (uint);\n}\n\nabstract contract SAFEEngineLike {\n    function coinBalance(address) virtual public view returns (uint);\n    function debtBalance(address) virtual public view returns (uint);\n    function settleDebt(uint256) virtual external;\n    function transferInternalCoins(address,address,uint256) virtual external;\n    function approveSAFEModification(address) virtual external;\n    function denySAFEModification(address) virtual external;\n}\n\nabstract contract ProtocolTokenAuthorityLike {\n    function authorizedAccounts(address) virtual public view returns (uint);\n}\n\ncontract AccountingEngine {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        require(contractEnabled == 1, \"AccountingEngine/contract-not-enabled\");\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"AccountingEngine/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    // SAFE database\n    SAFEEngineLike             public safeEngine;\n    // Contract that handles auctions for surplus stability fees (sell coins for protocol tokens that are then burned)\n    SurplusAuctionHouseLike    public surplusAuctionHouse;\n    /**\n      Contract that handles auctions for debt that couldn't be covered by collateral\n      auctions (it prints protocol tokens in exchange for coins that will settle the debt)\n    **/\n    DebtAuctionHouseLike       public debtAuctionHouse;\n    // Permissions registry for who can burn and mint protocol tokens\n    ProtocolTokenAuthorityLike public protocolTokenAuthority;\n    // Contract that auctions extra surplus after settlement is triggered\n    address                    public postSettlementSurplusDrain;\n\n    /**\n      Debt blocks that need to be covered by auctions. There is a delay to pop debt from\n      this queue and either settle it with surplus that came from collateral auctions or with debt auctions\n      that print protocol tokens\n    **/\n    mapping (uint256 => uint256) public debtQueue;          // [unix timestamp => rad]\n    // Total debt in the queue (that the system tries to cover with collateral auctions)\n    uint256 public totalQueuedDebt;                         // [rad]\n    // Total debt being auctioned in DebtAuctionHouse (printing protocol tokens for coins that will settle the debt)\n    uint256 public totalOnAuctionDebt;                      // [rad]\n    // When the last surplus auction was triggered; enforces a delay in case we use DEX surplus auctions\n    uint256 public lastSurplusAuctionTime;                  // [unix timestamp]\n    // Delay between surplus auctions\n    uint256 public surplusAuctionDelay;                     // [seconds]\n    // Delay after which debt can be popped from debtQueue\n    uint256 public popDebtDelay;                            // [seconds]\n    // Amount of protocol tokens to be minted post-auction\n    uint256 public initialDebtAuctionMintedTokens;          // [wad]\n    // Amount of debt sold in one debt auction (initial coin bid for initialDebtAuctionMintedTokens protocol tokens)\n    uint256 public debtAuctionBidSize;                      // [rad]\n\n    // Amount of surplus stability fees sold in one surplus auction\n    uint256 public surplusAuctionAmountToSell;              // [rad]\n    // Amount of stability fees that need to accrue in this contract before any surplus auction can start\n    uint256 public surplusBuffer;                           // [rad]\n\n    // Time to wait (post settlement) until any remaining surpluscan be transferred to the settlement auctioneer\n    uint256 public disableCooldown;                         // [seconds]\n    // When the contract was disabled\n    uint256 public disableTimestamp;                        // [unix timestamp]\n\n    // Whether this contract is enabled or not\n    uint256 public contractEnabled;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event PushDebtToQueue(uint timestamp, uint debtQueueBlock, uint totalQueuedDebt);\n    event PopDebtFromQueue(uint timestamp, uint debtQueueBlock, uint totalQueuedDebt);\n    event SettleDebt(uint rad, uint coinBalance, uint debtBalance);\n    event CancelAuctionedDebtWithSurplus(uint rad, uint totalOnAuctionDebt, uint coinBalance, uint debtBalance);\n    event AuctionDebt(uint id, uint totalOnAuctionDebt, uint debtBalance);\n    event AuctionSurplus(uint id, uint lastSurplusAuctionTime, uint coinBalance);\n    event DisableContract(uint disableTimestamp, uint disableCooldown, uint coinBalance, uint debtBalance);\n    event TransferPostSettlementSurplus(address postSettlementSurplusDrain, uint coinBalance, uint debtBalance);\n\n    // --- Init ---\n    constructor(\n      address safeEngine_,\n      address surplusAuctionHouse_,\n      address debtAuctionHouse_\n    ) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SAFEEngineLike(safeEngine_);\n        surplusAuctionHouse = SurplusAuctionHouseLike(surplusAuctionHouse_);\n        debtAuctionHouse = DebtAuctionHouseLike(debtAuctionHouse_);\n        safeEngine.approveSAFEModification(surplusAuctionHouse_);\n        lastSurplusAuctionTime = now;\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function minimum(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n\n    // --- Administration ---\n    /**\n     * @notice Modify general uint params for auctions\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized {\n        if (parameter == \"surplusAuctionDelay\") surplusAuctionDelay = data;\n        else if (parameter == \"popDebtDelay\") popDebtDelay = data;\n        else if (parameter == \"surplusAuctionAmountToSell\") surplusAuctionAmountToSell = data;\n        else if (parameter == \"debtAuctionBidSize\") debtAuctionBidSize = data;\n        else if (parameter == \"initialDebtAuctionMintedTokens\") initialDebtAuctionMintedTokens = data;\n        else if (parameter == \"surplusBuffer\") surplusBuffer = data;\n        else if (parameter == \"disableCooldown\") disableCooldown = data;\n        else revert(\"AccountingEngine/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify dependency addresses\n     * @param parameter The name of the auction type we want to change the address for\n     * @param data New address for the auction\n     */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        if (parameter == \"surplusAuctionHouse\") {\n            safeEngine.denySAFEModification(address(surplusAuctionHouse));\n            surplusAuctionHouse = SurplusAuctionHouseLike(data);\n            safeEngine.approveSAFEModification(data);\n        }\n        else if (parameter == \"debtAuctionHouse\") debtAuctionHouse = DebtAuctionHouseLike(data);\n        else if (parameter == \"postSettlementSurplusDrain\") postSettlementSurplusDrain = data;\n        else if (parameter == \"protocolTokenAuthority\") protocolTokenAuthority = ProtocolTokenAuthorityLike(data);\n        else revert(\"AccountingEngine/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Getters ---\n    function unqueuedUnauctionedDebt() public view returns (uint256) {\n        return subtract(subtract(safeEngine.debtBalance(address(this)), totalQueuedDebt), totalOnAuctionDebt);\n    }\n\n    // --- Debt Queueing ---\n    /**\n     * @notice Push debt (that the system tries to cover with collateral auctions) to a queue\n     * @dev Debt is locked in a queue to give the system enough time to auction collateral\n     *      and gather surplus\n     * @param debtBlock Amount of debt to push\n     */\n    function pushDebtToQueue(uint debtBlock) external isAuthorized {\n        debtQueue[now] = addition(debtQueue[now], debtBlock);\n        totalQueuedDebt = addition(totalQueuedDebt, debtBlock);\n        emit PushDebtToQueue(now, debtQueue[now], totalQueuedDebt);\n    }\n    /**\n     * @notice A block of debt can be popped from the queue after popDebtDelay seconds passed since it was\n     *         added there\n     * @param debtBlockTimestamp Timestamp of the block of debt that should be popped out\n     */\n    function popDebtFromQueue(uint debtBlockTimestamp) external {\n        require(addition(debtBlockTimestamp, popDebtDelay) <= now, \"AccountingEngine/pop-debt-delay-not-passed\");\n        totalQueuedDebt = subtract(totalQueuedDebt, debtQueue[debtBlockTimestamp]);\n        debtQueue[debtBlockTimestamp] = 0;\n        emit PopDebtFromQueue(now, debtQueue[now], totalQueuedDebt);\n    }\n\n    // Debt settlement\n    /**\n     * @notice Destroy an equal amount of coins and debt\n     * @dev We can only destroy debt that is not locked in the queue and also not in a debt auction\n     * @param rad Amount of coins/debt to destroy (number with 45 decimals)\n    **/\n    function settleDebt(uint rad) external {\n        require(rad <= safeEngine.coinBalance(address(this)), \"AccountingEngine/insufficient-surplus\");\n        require(rad <= unqueuedUnauctionedDebt(), \"AccountingEngine/insufficient-debt\");\n        safeEngine.settleDebt(rad);\n        emit SettleDebt(rad, safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this)));\n    }\n    /**\n     * @notice Use surplus coins to destroy debt that is/was in a debt auction\n     * @param rad Amount of coins/debt to destroy (number with 45 decimals)\n    **/\n    function cancelAuctionedDebtWithSurplus(uint rad) external {\n        require(rad <= totalOnAuctionDebt, \"AccountingEngine/not-enough-debt-being-auctioned\");\n        require(rad <= safeEngine.coinBalance(address(this)), \"AccountingEngine/insufficient-surplus\");\n        totalOnAuctionDebt = subtract(totalOnAuctionDebt, rad);\n        safeEngine.settleDebt(rad);\n        emit CancelAuctionedDebtWithSurplus(rad, totalOnAuctionDebt, safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this)));\n    }\n\n    // Debt auction\n    /**\n     * @notice Start a debt auction (print protocol tokens in exchange for coins so that the\n     *         system can accumulate surplus)\n     * @dev We can only auction debt that is not already being auctioned and is not locked in the debt queue\n    **/\n    function auctionDebt() external returns (uint id) {\n        require(debtAuctionBidSize <= unqueuedUnauctionedDebt(), \"AccountingEngine/insufficient-debt\");\n        require(safeEngine.coinBalance(address(this)) == 0, \"AccountingEngine/surplus-not-zero\");\n        require(debtAuctionHouse.protocolToken() != address(0), \"AccountingEngine/debt-auction-house-null-prot\");\n        require(protocolTokenAuthority.authorizedAccounts(address(debtAuctionHouse)) == 1, \"AccountingEngine/debt-auction-house-cannot-print-prot\");\n        totalOnAuctionDebt = addition(totalOnAuctionDebt, debtAuctionBidSize);\n        id = debtAuctionHouse.startAuction(address(this), initialDebtAuctionMintedTokens, debtAuctionBidSize);\n        emit AuctionDebt(id, totalOnAuctionDebt, safeEngine.debtBalance(address(this)));\n    }\n\n    // Surplus auction\n    /**\n     * @notice Start a surplus auction\n     * @dev We can only auction surplus if we wait at least 'surplusAuctionDelay' seconds since the last\n     *      auction trigger, if we keep enough surplus in the buffer and if there is no bad debt to settle\n    **/\n    function auctionSurplus() external returns (uint id) {\n        require(\n          now >= addition(lastSurplusAuctionTime, surplusAuctionDelay),\n          \"AccountingEngine/surplus-auction-delay-not-passed\"\n        );\n        require(\n          safeEngine.coinBalance(address(this)) >=\n          addition(addition(safeEngine.debtBalance(address(this)), surplusAuctionAmountToSell), surplusBuffer),\n          \"AccountingEngine/insufficient-surplus\"\n        );\n        require(\n          unqueuedUnauctionedDebt() == 0,\n          \"AccountingEngine/debt-not-zero\"\n        );\n        require(surplusAuctionHouse.protocolToken() != address(0), \"AccountingEngine/surplus-auction-house-null-prot\");\n        lastSurplusAuctionTime = now;\n        id = surplusAuctionHouse.startAuction(surplusAuctionAmountToSell, 0);\n        emit AuctionSurplus(id, lastSurplusAuctionTime, safeEngine.coinBalance(address(this)));\n    }\n\n    /**\n     * @notice Disable this contract (normally called by Global Settlement)\n     * @dev When we disable, the contract tries to settle as much debt as possible (if there's any) with\n            any surplus that's left in the system. After erasing debt, the contract will either transfer any\n            remaining surplus right away (if disableCooldown == 0) or will only record the timestamp when\n            it was disabled\n    **/\n    function disableContract() external isAuthorized {\n        require(contractEnabled == 1, \"AccountingEngine/contract-not-enabled\");\n\n        contractEnabled = 0;\n        totalQueuedDebt = 0;\n        totalOnAuctionDebt = 0;\n\n        disableTimestamp = now;\n\n        surplusAuctionHouse.disableContract();\n        debtAuctionHouse.disableContract();\n\n        safeEngine.settleDebt(minimum(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this))));\n\n        emit DisableContract(disableTimestamp, disableCooldown, safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this)));\n    }\n    /**\n     * @notice Transfer any remaining surplus after the disable cooldown has passed. Meant to be a backup in case GlobalSettlement.processSAFE\n               has a bug, governance doesn't have power over the system and there's still surplus left in the AccountingEngine\n               which then blocks GlobalSettlement.setOutstandingCoinSupply.\n     * @dev Transfer any remaining surplus after disableCooldown seconds have passed since disabling the contract\n    **/\n    function transferPostSettlementSurplus() external {\n        require(contractEnabled == 0, \"AccountingEngine/still-enabled\");\n        require(addition(disableTimestamp, disableCooldown) <= now, \"AccountingEngine/cooldown-not-passed\");\n        safeEngine.settleDebt(minimum(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this))));\n        safeEngine.transferInternalCoins(address(this), postSettlementSurplusDrain, safeEngine.coinBalance(address(this)));\n        emit TransferPostSettlementSurplus(\n          postSettlementSurplusDrain,\n          safeEngine.coinBalance(address(this)),\n          safeEngine.debtBalance(address(this))\n        );\n    }\n}"
    },
    {
      "filename": "src/LiquidationEngine.sol",
      "content": "/// LiquidationEngine.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract CollateralAuctionHouseLike {\n    function startAuction(\n      address forgoneCollateralReceiver,\n      address initialBidder,\n      uint amountToRaise,\n      uint collateralToSell,\n      uint initialBid\n    ) virtual public returns (uint);\n}\nabstract contract SAFESaviourLike {\n    function saveSAFE(address,bytes32,address) virtual external returns (bool,uint256,uint256);\n}\nabstract contract SAFEEngineLike {\n    function collateralTypes(bytes32) virtual public view returns (\n        uint256 debtAmount,        // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,       // [ray]\n        uint256 debtCeiling,       // [rad]\n        uint256 debtFloor,         // [rad]\n        uint256 liquidationPrice   // [ray]\n    );\n    function safes(bytes32,address) virtual public view returns (\n        uint256 lockedCollateral,  // [wad]\n        uint256 generatedDebt      // [wad]\n    );\n    function confiscateSAFECollateralAndDebt(bytes32,address,address,address,int,int) virtual external;\n    function canModifySAFE(address, address) virtual public view returns (bool);\n    function approveSAFEModification(address) virtual external;\n    function denySAFEModification(address) virtual external;\n}\nabstract contract AccountingEngineLike {\n    function pushDebtToQueue(uint) virtual external;\n}\n\ncontract LiquidationEngine {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"LiquidationEngine/account-not-authorized\");\n        _;\n    }\n\n    // --- SAFE Saviours ---\n    // Contracts that can save SAFEs from liquidation\n    mapping (address => uint) public safeSaviours;\n    /**\n    * @notice Authed function to add contracts that can save SAFEs from liquidation\n    * @param saviour SAFE saviour contract to be whitelisted\n    **/\n    function connectSAFESaviour(address saviour) external isAuthorized {\n        (bool ok, uint256 collateralAdded, uint256 liquidatorReward) =\n          SAFESaviourLike(saviour).saveSAFE(address(this), \"\", address(0));\n        require(ok, \"LiquidationEngine/saviour-not-ok\");\n        require(both(collateralAdded == uint(-1), liquidatorReward == uint(-1)), \"LiquidationEngine/invalid-amounts\");\n        safeSaviours[saviour] = 1;\n        emit ConnectSAFESaviour(saviour);\n    }\n    /**\n    * @notice Governance used function to remove contracts that can save SAFEs from liquidation\n    * @param saviour SAFE saviour contract to be removed\n    **/\n    function disconnectSAFESaviour(address saviour) external isAuthorized {\n        safeSaviours[saviour] = 0;\n        emit DisconnectSAFESaviour(saviour);\n    }\n\n    // --- Data ---\n    struct CollateralType {\n        // Address of the collateral auction house handling liquidations for this collateral type\n        address collateralAuctionHouse;\n        // Penalty applied to every liquidation involving this collateral type. Discourages SAFE users from bidding on their own SAFEs\n        uint256 liquidationPenalty;                                                                                                   // [wad]\n        // Max amount of system coins to request in one auction\n        uint256 liquidationQuantity;                                                                                                  // [rad]\n    }\n\n    // Collateral types included in the system\n    mapping (bytes32 => CollateralType)              public collateralTypes;\n    // Saviour contract chosen for each SAFE by its creator\n    mapping (bytes32 => mapping(address => address)) public chosenSAFESaviour;\n    // Mutex used to block against re-entrancy when 'liquidateSAFE' passes execution to a saviour\n    mapping (bytes32 => mapping(address => uint8))   public mutex;\n\n    // Max amount of system coins that can be on liquidation at any time\n    uint256 public onAuctionSystemCoinLimit;                                // [rad]\n    // Current amount of system coins out for liquidation\n    uint256 public currentOnAuctionSystemCoins;                             // [rad]\n    // Whether this contract is enabled\n    uint256 public contractEnabled;\n\n    SAFEEngineLike       public safeEngine;\n    AccountingEngineLike public accountingEngine;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ConnectSAFESaviour(address saviour);\n    event DisconnectSAFESaviour(address saviour);\n    event UpdateCurrentOnAuctionSystemCoins(uint currentOnAuctionSystemCoins);\n    event ModifyParameters(bytes32 parameter, uint256 data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event ModifyParameters(\n      bytes32 collateralType,\n      bytes32 parameter,\n      uint data\n    );\n    event ModifyParameters(\n      bytes32 collateralType,\n      bytes32 parameter,\n      address data\n    );\n    event DisableContract();\n    event Liquidate(\n      bytes32 indexed collateralType,\n      address indexed safe,\n      uint256 collateralAmount,\n      uint256 debtAmount,\n      uint256 amountToRaise,\n      address collateralAuctioneer,\n      uint256 auctionId\n    );\n    event SaveSAFE(\n      bytes32 indexed collateralType,\n      address indexed safe,\n      uint256 collateralAdded\n    );\n    event FailedSAFESave(bytes failReason);\n    event ProtectSAFE(\n      bytes32 collateralType,\n      address safe,\n      address saviour\n    );\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SAFEEngineLike(safeEngine_);\n        onAuctionSystemCoinLimit = uint(-1);\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"onAuctionSystemCoinLimit\", uint(-1));\n    }\n\n    // --- Math ---\n    uint256 constant WAD = 10 ** 18;\n    uint256 constant RAY = 10 ** 27;\n    uint256 constant MAX_LIQUIDATION_QUANTITY = uint256(-1) / RAY;\n\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function minimum(uint x, uint y) internal pure returns (uint z) {\n        if (x > y) { z = y; } else { z = x; }\n    }\n\n    // --- Utils ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Administration ---\n    /*\n    * @notice Modify uint256 parameters\n    * @param paramter The name of the parameter modified\n    * @param data Value for the new parameter\n    */\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"onAuctionSystemCoinLimit\") onAuctionSystemCoinLimit = data;\n        else revert(\"LiquidationEngine/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify contract integrations\n     * @param parameter The name of the parameter modified\n     * @param data New address for the parameter\n     */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        if (parameter == \"accountingEngine\") accountingEngine = AccountingEngineLike(data);\n        else revert(\"LiquidationEngine/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify liquidation params\n     * @param collateralType The collateral type we change parameters for\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(\n        bytes32 collateralType,\n        bytes32 parameter,\n        uint data\n    ) external isAuthorized {\n        if (parameter == \"liquidationPenalty\") collateralTypes[collateralType].liquidationPenalty = data;\n        else if (parameter == \"liquidationQuantity\") {\n          require(data <= MAX_LIQUIDATION_QUANTITY, \"LiquidationEngine/liquidation-quantity-overflow\");\n          collateralTypes[collateralType].liquidationQuantity = data;\n        }\n        else revert(\"LiquidationEngine/modify-unrecognized-param\");\n        emit ModifyParameters(\n          collateralType,\n          parameter,\n          data\n        );\n    }\n    /**\n     * @notice Modify collateral auction integration\n     * @param collateralType The collateral type we change parameters for\n     * @param parameter The name of the integration modified\n     * @param data New address for the integration contract\n     */\n    function modifyParameters(\n        bytes32 collateralType,\n        bytes32 parameter,\n        address data\n    ) external isAuthorized {\n        if (parameter == \"collateralAuctionHouse\") {\n            safeEngine.denySAFEModification(collateralTypes[collateralType].collateralAuctionHouse);\n            collateralTypes[collateralType].collateralAuctionHouse = data;\n            safeEngine.approveSAFEModification(data);\n        }\n        else revert(\"LiquidationEngine/modify-unrecognized-param\");\n        emit ModifyParameters(\n            collateralType,\n            parameter,\n            data\n        );\n    }\n    /**\n     * @notice Disable this contract (normally called by GlobalSettlement)\n     */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    // --- SAFE Liquidation ---\n    /**\n     * @notice Choose a saviour contract for your SAFE\n     * @param collateralType The SAFE's collateral type\n     * @param safe The SAFE's address\n     * @param saviour The chosen saviour\n     */\n    function protectSAFE(\n        bytes32 collateralType,\n        address safe,\n        address saviour\n    ) external {\n        require(safeEngine.canModifySAFE(safe, msg.sender), \"LiquidationEngine/cannot-modify-safe\");\n        require(saviour == address(0) || safeSaviours[saviour] == 1, \"LiquidationEngine/saviour-not-authorized\");\n        chosenSAFESaviour[collateralType][safe] = saviour;\n        emit ProtectSAFE(\n            collateralType,\n            safe,\n            saviour\n        );\n    }\n    /**\n     * @notice Liquidate a SAFE\n     * @param collateralType The SAFE's collateral type\n     * @param safe The SAFE's address\n     */\n    function liquidateSAFE(bytes32 collateralType, address safe) external returns (uint auctionId) {\n        require(mutex[collateralType][safe] == 0, \"LiquidationEngine/non-null-mutex\");\n        mutex[collateralType][safe] = 1;\n\n        (, uint accumulatedRate, , , uint debtFloor, uint liquidationPrice) = safeEngine.collateralTypes(collateralType);\n        (uint safeCollateral, uint safeDebt) = safeEngine.safes(collateralType, safe);\n\n        require(contractEnabled == 1, \"LiquidationEngine/contract-not-enabled\");\n        require(both(\n          liquidationPrice > 0,\n          multiply(safeCollateral, liquidationPrice) < multiply(safeDebt, accumulatedRate)\n        ), \"LiquidationEngine/safe-not-unsafe\");\n        require(\n          both(currentOnAuctionSystemCoins < onAuctionSystemCoinLimit,\n          subtract(onAuctionSystemCoinLimit, currentOnAuctionSystemCoins) >= debtFloor),\n          \"LiquidationEngine/liquidation-limit-hit\"\n        );\n\n        if (chosenSAFESaviour[collateralType][safe] != address(0) &&\n            safeSaviours[chosenSAFESaviour[collateralType][safe]] == 1) {\n          try SAFESaviourLike(chosenSAFESaviour[collateralType][safe]).saveSAFE(msg.sender, collateralType, safe)\n            returns (bool ok, uint256 collateralAdded, uint256) {\n            if (both(ok, collateralAdded > 0)) {\n              emit SaveSAFE(collateralType, safe, collateralAdded);\n            }\n          } catch (bytes memory revertReason) {\n            emit FailedSAFESave(revertReason);\n          }\n        }\n\n        // Checks that the saviour didn't take collateral or add more debt to the SAFE\n        {\n          (uint newSafeCollateral, uint newSafeDebt) = safeEngine.safes(collateralType, safe);\n          require(both(newSafeCollateral >= safeCollateral, newSafeDebt <= safeDebt), \"LiquidationEngine/invalid-safe-saviour-operation\");\n        }\n\n        (, accumulatedRate, , , , liquidationPrice) = safeEngine.collateralTypes(collateralType);\n        (safeCollateral, safeDebt) = safeEngine.safes(collateralType, safe);\n\n        if (both(liquidationPrice > 0, multiply(safeCollateral, liquidationPrice) < multiply(safeDebt, accumulatedRate))) {\n          CollateralType memory collateralData = collateralTypes[collateralType];\n\n          uint limitAdjustedDebt = minimum(\n            safeDebt,\n            multiply(minimum(collateralData.liquidationQuantity, subtract(onAuctionSystemCoinLimit, currentOnAuctionSystemCoins)), WAD) / accumulatedRate / collateralData.liquidationPenalty\n          );\n          uint collateralToSell = minimum(safeCollateral, multiply(safeCollateral, limitAdjustedDebt) / safeDebt);\n\n          require(both(limitAdjustedDebt > 0, collateralToSell > 0), \"LiquidationEngine/null-auction\");\n          require(both(collateralToSell <= 2**255, limitAdjustedDebt <= 2**255), \"LiquidationEngine/collateral-or-debt-overflow\");\n          // This can leave the SAFE with generatedDebt < debtFloor\n          safeEngine.confiscateSAFECollateralAndDebt(\n            collateralType, safe, address(this), address(accountingEngine), -int(collateralToSell), -int(limitAdjustedDebt)\n          );\n          accountingEngine.pushDebtToQueue(multiply(limitAdjustedDebt, accumulatedRate));\n\n          {\n            uint amountToRaise_         = multiply(multiply(limitAdjustedDebt, accumulatedRate), collateralData.liquidationPenalty) / WAD;\n            currentOnAuctionSystemCoins = addition(currentOnAuctionSystemCoins, amountToRaise_);\n\n            auctionId = CollateralAuctionHouseLike(collateralData.collateralAuctionHouse).startAuction(\n              { forgoneCollateralReceiver: safe\n              , initialBidder: address(accountingEngine)\n              , amountToRaise: amountToRaise_\n              , collateralToSell: collateralToSell\n              , initialBid: 0\n             });\n\n             emit UpdateCurrentOnAuctionSystemCoins(curren"
    }
  ]
}