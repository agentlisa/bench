{
  "Title": "M-2: Incorrect `tapOft` Amounts Will Be Sent to Desired Chains on Certain Conditions",
  "Content": "# Issue M-2: Incorrect `tapOft` Amounts Will Be Sent to Desired Chains on Certain Conditions \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/18 \n\n## Found by \nTendency\n## Summary\n[TOFTOptionsReceiverModule::exerciseOptionsReceiver](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L142-L209) module, is responsible for facilitating users' token exercises between `mTOFT` and `tapOFT` tokens across different chains. \nIn a `msg-type` where the user wishes to receive the `tapOFT` tokens on a different chain, the module attempts to ensure the amount sent to the user on the desired chain, aligns with the received tap amount in the current chain. However, a flaw exists where the computed amount to send is not updated in the send parameters, resulting in incorrect token transfer.\n## Vulnerability Detail\n\n[TOFTOptionsReceiverModule::exerciseOptionsReceiver](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L142-L209) module is a module that enables users to exercise their `mTOFT` tokens for a given amount of `tapOFT` option tokens.\n\nWhen the user wishes to withdraw these `tapOft` tokens on a different chain, the [withdrawOnOtherChain](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L189) param will be set to true. For this composed call type, the contract attempts to ensure the amount to send to the user on the other chain isn't more than the received `tap amount`, by doing this:\n```solidity\n           uint256 amountToSend = _send.amountLD > _options.tapAmount ? _options.tapAmount : _send.amountLD;\n                if (_send.minAmountLD > amountToSend) {\n                    _send.minAmountLD = amountToSend;\n                }\n```\nThe issue here is that, the computed amount to send, is never updated in the `lsSendParams.sendParam`, the current code still goes on to send the packet to the destination chain with the default input amount:\n```solidity\n            if (msg_.withdrawOnOtherChain) {\n                /// @dev determine the right amount to send back to source\n                uint256 amountToSend = _send.amountLD > _options.tapAmount ? _options.tapAmount : _send.amountLD;\n                if (_send.minAmountLD > amountToSend) {\n                    _send.minAmountLD = amountToSend;\n                }\n\n\n                // Sends to source and preserve source `msg.sender` (`from` in this case).\n                _sendPacket(msg_.lzSendParams, msg_.composeMsg, _options.from);\n\n\n                // Refund extra amounts\n                if (_options.tapAmount - amountToSend > 0) {\n                    IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n                }\n```\n+ To Illustrate:\n\nassuming send `amountLD` = 100\nand the user is to receive a tap amount of = 80\nsince `amountLD` is greater than tap amount, the amount to send should be 80, i.e. `msg_.lzSendParams.sendParam.amountLD` = 80\nThe current code goes on to send the default 100 to the user, when the user is only entitled to 80\n\n\n## Impact\nThe user will always receive an incorrect amount of `tapOFT` in the desired chain whenever `amountLD` is greater than `tapAmount`\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L142-L209\n## Tool used\n\nManual Review\n\n## Recommendation\nupdate the lz send param `amountLD` to the new computed `amountToSend` before sending the packet\n+ I.e :\n```solidity\nmsg_.lzSendParams.sendParam.amountLD = amountToSend;\n```\nNote that the issue should also be fixed in Tapioca-Bar as well\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/usdo/modules/UsdoOptionReceiverModule.sol#L113-L118\n\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nFixed by \nhttps://github.com/Tapioca-DAO/TapiocaZ/pull/170\nand \nhttps://github.com/Tapioca-DAO/Tapioca-bar/pull/347\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/170; https://github.com/Tapioca-DAO/Tapioca-bar/pull/347.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    LockAndParticipateData,\n    IMagnetar,\n    MagnetarCall,\n    MagnetarAction,\n    CrossChainMintFromBBAndLendOnSGLData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {\n    ITapiocaOptionBroker, IExerciseOptionsData\n} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {TOFTInitStruct, ExerciseOptionsMsg, LZSendParam} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {MagnetarMintXChainModule} from \"tapioca-periph/Magnetar/modules/MagnetarMintXChainModule.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTOptionsReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Options module\n */\ncontract TOFTOptionsReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    error TOFTOptionsReceiverModule_NotAuthorized(address invalidAddress);\n\n    event ExerciseOptionsReceived(\n        address indexed user, address indexed target, uint256 indexed oTapTokenId, uint256 paymentTokenAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice cross-chain receiver to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     * @param _data.user the user to perform the operation for\n     * @param _data.bigBang the BB address\n     * @param _data.mintData the data needed to mint on BB\n     * @param _data.lendSendParams LZ send params for lending on another layer\n     */\n    function mintLendXChainSGLXChainLockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode received message.\n        CrossChainMintFromBBAndLendOnSGLData memory msg_ =\n            TOFTMsgCodec.decodeMintLendXChainSGLXChainLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.bigBang);\n        _checkWhitelistStatus(msg_.magnetar);\n\n        if (msg_.mintData.mintAmount > 0) {\n            msg_.mintData.mintAmount = _toLD(msg_.mintData.mintAmount.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.mintBBLendXChainSGL.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: address(this),\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Execute `magnetar.lockAndParticipate`\n     * @dev Lock on tOB and/or participate on tOLP\n     * @param _data The call data containing info about the operation.\n     * @param _data.user the user to perform the operation for\n     * @param _data.singularity the SGL address\n     * @param _data.fraction the amount to lock\n     * @param _data.lockData the data needed to lock on tOB\n     * @param _data.participateData the data needed to participate on tOLP\n     */\n    function lockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode receive message\n        LockAndParticipateData memory msg_ = TOFTMsgCodec.decodeLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.magnetar);\n        _checkWhitelistStatus(msg_.singularity);\n        if (msg_.lockData.lock) {\n            _checkWhitelistStatus(msg_.lockData.target);\n        }\n        if (msg_.participateData.participate) {\n            _checkWhitelistStatus(msg_.participateData.target);\n        }\n\n        if (msg_.fraction > 0) {\n            msg_.fraction = _toLD(msg_.fraction.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.lockAndParticipate.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: msg_.magnetar,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Exercise tOB option\n     * @param _data The call data containing info about the operation.\n     *      - optionsData::address: TapiocaOptionsBroker exercise params.\n     *      - lzSendParams::struct: LZ v2 send to source params.\n     *      - composeMsg::bytes: Further compose data.\n     */\n    function exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = TOFTMsgCodec.decodeExerciseOptionsMsg(_data);\n\n        _checkWhitelistStatus(msg_.optionsData.target);\n        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to));\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            _options.tapAmount = _toLD(_options.tapAmount.toUint64());\n            _options.paymentTokenAmount = _toLD(_options.paymentTokenAmount.toUint64());\n\n            // @dev retrieve paymentToken amount\n            _internalTransferWithAllowance(_options.from, srcChainSender, _options.paymentTokenAmount);\n\n            /// Does this: _approve(address(this), _options.target, _options.paymentTokenAmount);\n            pearlmit.approve(\n                address(this), 0, _options.target, uint200(_options.paymentTokenAmount), uint48(block.timestamp + 1)\n            ); // Atomic approval\n            address(this).safeApprove(address(pearlmit), _options.paymentTokenAmount);\n\n            /// @dev call exerciseOption() with address(this) as the payment token\n            uint256 bBefore = balanceOf(address(this));\n            ITapiocaOptionBroker(_options.target).exerciseOption(\n                _options.oTAPTokenID,\n                address(this), //payment token\n                _options.tapAmount\n            );\n            address(this).safeApprove(address(pearlmit), 0); // Clear approval\n            uint256 bAfter = balanceOf(address(this));\n\n            // Refund if less was used.\n            if (bBefore > bAfter) {\n                uint256 diff = bBefore - bAfter;\n                if (diff < _options.paymentTokenAmount) {\n                    IERC20(address(this)).safeTransfer(_options.from, _options.paymentTokenAmount - diff);\n                }\n            }\n        }\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            SendParam memory _send = msg_.lzSendParams.sendParam;\n\n            address tapOft = ITapiocaOptionBroker(_options.target).tapOFT();\n            if (msg_.withdrawOnOtherChain) {\n                /// @dev determine the right amount to send back to source\n                uint256 amountToSend = _send.amountLD > _options.tapAmount ? _options.tapAmount : _send.amountLD;\n                if (_send.minAmountLD > amountToSend) {\n                    _send.minAmountLD = amountToSend;\n                }\n\n                // Sends to source and preserve source `msg.sender` (`from` in this case).\n                _sendPacket(msg_.lzSendParams, msg_.composeMsg, _options.from);\n\n                // Refund extra amounts\n                if (_options.tapAmount - amountToSend > 0) {\n                    IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n                }\n            } else {\n                //send on this chain\n                IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount);\n            }\n        }\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTOptionsReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n\n    function _sendPacket(LZSendParam memory _lzSendParam, bytes memory _composeMsg, address _srcChainSender)\n        private\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        /// @dev Applies the token transfers regarding this send() operation.\n        // - amountDebitedLD is the amount in local decimals that was ACTUALLY debited from the sender.\n        // - amountToCreditLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        (uint256 amountDebitedLD, uint256 amountToCreditLD) =\n            _debit(_lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid);\n\n        /// @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n            _lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD, _srcChainSender\n        );\n\n        /// @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        /// @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD, amountToCreditLD);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, msg.sender, amountDebitedLD);\n    }\n    /**\n     * @dev For details about this function, check `BaseTapiocaOmnichainEngine._buildOFTMsgAndOptions()`.\n     * @dev !!!! IMPORTANT !!!! The differences are:\n     *      - memory instead of calldata for parameters.\n     *      - `_msgSender` is used instead of using context `msg.sender`, to preserve context of the OFT call and use `msg.sender` of the source chain.\n     *      - Does NOT combine options, make sure to pass valid options to cover gas costs/value transfers.\n     */\n\n    function _buildOFTMsgAndOptionsMemory(\n        SendParam memory _sendParam,\n        bytes memory _extraOptions,\n        bytes memory _composeMsg,\n        uint256 _amountToCreditLD,\n        address _msgSender\n    ) private view returns (bytes memory message, bytes memory options) {\n        bool hasCompose = _composeMsg.length > 0;\n\n        message = hasCompose\n            ? abi.encodePacked(\n                _sendParam.to, _toSD(_amountToCreditLD), OFTMsgCodec.addressToBytes32(_msgSender), _composeMsg\n            )\n            : abi.encodePacked(_sendParam.to, _toSD(_amountToCreditLD));\n        options = _extraOptions;\n\n        if (msgInspector != address(0)) {\n            IOAppMsgInspector(msgInspector).inspect(message, options);\n        }\n    }\n\n    /**\n     * @dev Performs a transfer with an allowance check and consumption against the xChain msg sender.\n     * @dev Can only transfer to this address.\n     *\n     * @param _owner The account to transfer from.\n     * @param srcChainSender The address of the sender on the source chain.\n     * @param _amount The amount to transfer\n     */\n    function _internalTransferWithAllowance(address _owner, address srcChainSender, uint256 _amount) internal {\n        if (_owner != srcChainSender) {\n            _spendAllowance(_owner, srcChainSender, _amount);\n        }\n\n        _transfer(_owner, address(this), _amount);\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    LockAndParticipateData,\n    IMagnetar,\n    MagnetarCall,\n    MagnetarAction,\n    CrossChainMintFromBBAndLendOnSGLData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {\n    ITapiocaOptionBroker, IExerciseOptionsData\n} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {TOFTInitStruct, ExerciseOptionsMsg, LZSendParam} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {MagnetarMintXChainModule} from \"tapioca-periph/Magnetar/modules/MagnetarMintXChainModule.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTOptionsReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Options module\n */\ncontract TOFTOptionsReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    error TOFTOptionsReceiverModule_NotAuthorized(address invalidAddress);\n\n    event ExerciseOptionsReceived(\n        address indexed user, address indexed target, uint256 indexed oTapTokenId, uint256 paymentTokenAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice cross-chain receiver to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     * @param _data.user the user to perform the operation for\n     * @param _data.bigBang the BB address\n     * @param _data.mintData the data needed to mint on BB\n     * @param _data.lendSendParams LZ send params for lending on another layer\n     */\n    function mintLendXChainSGLXChainLockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode received message.\n        CrossChainMintFromBBAndLendOnSGLData memory msg_ =\n            TOFTMsgCodec.decodeMintLendXChainSGLXChainLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.bigBang);\n        _checkWhitelistStatus(msg_.magnetar);\n\n        if (msg_.mintData.mintAmount > 0) {\n            msg_.mintData.mintAmount = _toLD(msg_.mintData.mintAmount.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.mintBBLendXChainSGL.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: address(this),\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Execute `magnetar.lockAndParticipate`\n     * @dev Lock on tOB and/or participate on tOLP\n     * @param _data The call data containing info about the operation.\n     * @param _data.user the user to perform the operation for\n     * @param _data.singularity the SGL address\n     * @param _data.fraction the amount to lock\n     * @param _data.lockData the data needed to lock on tOB\n     * @param _data.participateData the data needed to participate on tOLP\n     */\n    function lockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode receive message\n        LockAndParticipateData memory msg_ = TOFTMsgCodec.decodeLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.magnetar);\n        _checkWhitelistStatus(msg_.singularity);\n        if (msg_.lockData.lock) {\n            _checkWhitelistStatus(msg_.lockData.target);\n        }\n        if (msg_.participateData.participate) {\n            _checkWhitelistStatus(msg_.participateData.target);\n        }\n\n        if (msg_.fraction > 0) {\n            msg_.fraction = _toLD(msg_.fraction.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.lockAndParticipate.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: msg_.magnetar,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Exercise tOB option\n     * @param _data The call data containing info about the operation.\n     *      - optionsData::address: TapiocaOptionsBroker exercise params.\n     *      - lzSendParams::struct: LZ v2 send to source params.\n     *      - composeMsg::bytes: Further compose data.\n     */\n    function exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = TOFTMsgCodec.decodeExerciseOptionsMsg(_data);\n\n        _checkWhitelistStatus(msg_.optionsData.target);\n        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to));\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            _options.tapAmount = _toLD(_options.tapAmount.toUint64());\n            _options.paymentTokenAmount = _toLD(_options.paymentTokenAmount.toUint64());\n\n            // @dev retrieve paymentToken amount\n            _internalTransferWithAllowance(_options.from, srcChainSender, _options.paymentTokenAmount);\n\n            /// Does this: _approve(address(this), _options.target, _options.paymentTokenAmount);\n            pearlmit.approve(\n                address(this), 0, _options.target, uint200(_options.paymentTokenAmount), uint48(block.timestamp + 1)\n            ); // Atomic approval\n            address(this).safeApprove(address(pearlmit), _options.paymentTokenAmount);\n\n            /// @dev call exerciseOption() with address(this) as the payment token\n            uint256 bBefore = balanceOf(address(this));\n            ITapiocaOptionBroker(_options.target).exerciseOption(\n                _options.oTAPTokenID,\n                address(this), //payment token\n                _options.tapAmount\n            );\n            address(this).safeApprove(address(pearlmit), 0); // Clear approval\n            uint256 bAfter = balanceOf(address(this));\n\n            // Refund if less was used.\n            if (bBefore > bAfter) {\n                uint256 diff = bBefore - bAfter;\n                if (diff < _options.paymentTokenAmount) {\n                    IERC20(address(this)).safeTransfer(_options.from, _options.paymentTokenAmount - diff);\n                }\n            }\n        }\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            SendParam memory _send = msg_.lzSendParams.sendParam;\n\n            address tapOft = ITapiocaOptionBroker(_options.target).tapOFT();\n            if (msg_.withdrawOnOtherChain) {\n                /// @dev determine the right amount to send back to source\n                uint256 amountToSend = _send.amountLD > _options.tapAmount ? _options.tapAmount : _send.amountLD;\n                if (_send.minAmountLD > amountToSend) {\n                    _send.minAmountLD = amountToSend;\n                }\n\n                // Sends to source and preserve source `msg.sender` (`from` in this case).\n                _sendPacket(msg_.lzSendParams, msg_.composeMsg, _options.from);\n\n                // Refund extra amounts\n                if (_options.tapAmount - amountToSend > 0) {\n                    IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n                }\n            } else {\n                //send on this chain\n                IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount);\n            }\n        }\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTOptionsReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n\n    function _sendPacket(LZSendParam memory _lzSendParam, bytes memory _composeMsg, address _srcChainSender)\n        private\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        /// @dev Applies the token transfers regarding this send() operation.\n        // - amountDebitedLD is the amount in local decimals that was ACTUALLY debited from the sender.\n        // - amountToCreditLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        (uint256 amountDebitedLD, uint256 amountToCreditLD) =\n            _debit(_lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid);\n\n        /// @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n            _lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD, _srcChainSender\n        );\n\n        /// @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        /// @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD, amountToCreditLD);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, msg.sender, amountDebitedLD);\n    }\n    /**\n     * @dev For details about this function, check `BaseTapiocaOmnichainEngine._buildOFTMsgAndOptions()`.\n     * @dev !!!! IMPORTANT !!!! The differences are:\n     *      - memory instead of calldata for parameters.\n     *      - `_msgSender` is used instead of using context `msg.sender`, to preserve context of the OFT call and use `msg.sender` of the source chain.\n     *      - Does NOT combine options, make sure to pass valid options to cover gas costs/value transfers.\n     */\n\n    function _buildOFTMsgAndOptionsMemory(\n        SendParam memory _sendParam,\n        bytes memory _extraOptions,\n        bytes memory _composeMsg,\n        uint256 _amountToCreditLD,\n        address _msgSender\n    ) private view returns (bytes memory message, bytes memory options) {\n        bool hasCompose = _composeMsg.length > 0;\n\n        message = hasCompose\n            ? abi.encodePacked(\n                _sendParam.to, _toSD(_amountToCreditLD), OFTMsgCodec.addressToBytes32(_msgSender), _composeMsg\n            )\n            : abi.encodePacked(_sendParam.to, _toSD(_amountToCreditLD));\n        options = _extraOptions;\n\n        if (msgInspector != address(0)) {\n            IOAppMsgInspector(msgInspector).inspect(message, options);\n        }\n    }\n\n    /**\n     * @dev Performs a transfer with an allowance check and consumption against the xChain msg sender.\n     * @dev Can only transfer to this address.\n     *\n     * @param _owner The account to transfer from.\n     * @param srcChainSender The address of the sender on the source chain.\n     * @param _amount The amount to transfer\n     */\n    function _internalTransferWithAllowance(address _owner, address srcChainSender, uint256 _amount) internal {\n        if (_owner != srcChainSender) {\n            _spendAllowance(_owner, srcChainSender, _amount);\n        }\n\n        _transfer(_owner, address(this), _amount);\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    LockAndParticipateData,\n    IMagnetar,\n    MagnetarCall,\n    MagnetarAction,\n    CrossChainMintFromBBAndLendOnSGLData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {\n    ITapiocaOptionBroker, IExerciseOptionsData\n} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {TOFTInitStruct, ExerciseOptionsMsg, LZSendParam} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {MagnetarMintXChainModule} from \"tapioca-periph/Magnetar/modules/MagnetarMintXChainModule.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTOptionsReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Options module\n */\ncontract TOFTOptionsReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    error TOFTOptionsReceiverModule_NotAuthorized(address invalidAddress);\n\n    event ExerciseOptionsReceived(\n        address indexed user, address indexed target, uint256 indexed oTapTokenId, uint256 paymentTokenAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice cross-chain receiver to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     * @param _data.user the user to perform the operation for\n     * @param _data.bigBang the BB address\n     * @param _data.mintData the data needed to mint on BB\n     * @param _data.lendSendParams LZ send params for lending on another layer\n     */\n    function mintLendXChainSGLXChainLockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode received message.\n        CrossChainMintFromBBAndLendOnSGLData memory msg_ =\n            TOFTMsgCodec.decodeMintLendXChainSGLXChainLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.bigBang);\n        _checkWhitelistStatus(msg_.magnetar);\n\n        if (msg_.mintData.mintAmount > 0) {\n            msg_.mintData.mintAmount = _toLD(msg_.mintData.mintAmount.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.mintBBLendXChainSGL.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: address(this),\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Execute `magnetar.lockAndParticipate`\n     * @dev Lock on tOB and/or participate on tOLP\n     * @param _data The call data containing info about the operation.\n     * @param _data.user the user to perform the operation for\n     * @param _data.singularity the SGL address\n     * @param _data.fraction the amount to lock\n     * @param _data.lockData the data needed to lock on tOB\n     * @param _data.participateData the data needed to participate on tOLP\n     */\n    function lockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode receive message\n        LockAndParticipateData memory msg_ = TOFTMsgCodec.decodeLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.magnetar);\n        _checkWhitelistStatus(msg_.singularity);\n        if (msg_.lockData.lock) {\n            _checkWhitelistStatus(msg_.lockData.target);\n        }\n        if (msg_.participateData.participate) {\n            _checkWhitelistStatus(msg_.participateData.target);\n        }\n\n        if (msg_.fraction > 0) {\n            msg_.fraction = _toLD(msg_.fraction.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.lockAndParticipate.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: msg_.magnetar,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Exercise tOB option\n     * @param _data The call data containing info about the operation.\n     *      - optionsData::address: TapiocaOptionsBroker exercise params.\n     *      - lzSendParams::struct: LZ v2 send to source params.\n     *      - composeMsg::bytes: Further compose data.\n     */\n    function exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = TOFTMsgCodec.decodeExerciseOptionsMsg(_data);\n\n        _checkWhitelistStatus(msg_.optionsData.target);\n        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to));\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            _options.tapAmount = _toLD(_options.tapAmount.toUint64());\n            _options.paymentTokenAmount = _toLD(_options.paymentTokenAmount.toUint64());\n\n            // @dev retrieve paymentToken amount\n            _internalTransferWithAllowance(_options.from, srcChainSender, _options.paymentTokenAmount);\n\n            /// Does this: _approve(address(this), _options.target, _options.paymentTokenAmount);\n            pearlmit.approve(\n                address(this), 0, _options.target, uint200(_options.paymentTokenAmount), uint48(block.timestamp + 1)\n            ); // Atomic approval\n            address(this).safeApprove(address(pearlmit), _options.paymentTokenAmount);\n\n            /// @dev call exerciseOption() with address(this) as the payment token\n            uint256 bBefore = balanceOf(address(this));\n            ITapiocaOptionBroker(_options.target).exerciseOption(\n                _options.oTAPTokenID,\n                address(this), //payment token\n                _options.tapAmount\n            );\n            address(this).safeApprove(address(pearlmit), 0); // Clear approval\n            uint256 bAfter = balanceOf(address(this));\n\n            // Refund if less was used."
    }
  ]
}