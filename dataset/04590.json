{
  "Title": "Revoking a vesting grant takes vested tokens away",
  "Content": "The [`revoke`](https://github.com/kikinteractive/kin-token/blob/3ed3a383b9304274ec22f41769716cadb854727f/contracts/VestingTrustee.sol#L90) function in `VestingTrustee` allows the owner to revoke an address’s vesting grant, in the case that it is revocable. This consists of erasing the grant and transferring the remaining tokens to the owner. The function considers “remaining tokens” to be all those that haven’t been [unlocked and transferred](https://github.com/kikinteractive/kin-token/blob/3ed3a383b9304274ec22f41769716cadb854727f/contracts/VestingTrustee.sol#L151) yet. However, it is likely that remaining tokens should be considered to be only those which have not yet vested, regardless of whether they’ve been transferred or not. Consider changing `revoke` to first transfer vested tokens to the grantee, and only the remaining as a refund to the owner.\n\n\n***Update:** The team assured us that, although they have not implemented our suggested change, the risk is mitigated by the fact that all vesting grants will be made irrevocable as soon as possible after the sale and that revocation will be only possible by getting access to the multisig owner of the contract. There is no risk for an irrevocable grant, so there would be no problem for investors after made irrevocable.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/VestingTrustee.sol",
      "content": "pragma solidity ^0.4.15;\n\nimport './SafeMath.sol';\nimport './Ownable.sol';\nimport './KinToken.sol';\n\n/// @title Vesting trustee contract for Kin token.\ncontract VestingTrustee is Ownable {\n    using SafeMath for uint256;\n\n    // Kin token contract.\n    KinToken public kin;\n\n    // Vesting grant for a speicifc holder.\n    struct Grant {\n        uint256 value;\n        uint256 start;\n        uint256 cliff;\n        uint256 end;\n        uint256 installmentLength; // In seconds.\n        uint256 transferred;\n        bool revokable;\n    }\n\n    // Holder to grant information mapping.\n    mapping (address => Grant) public grants;\n\n    // Total tokens available for vesting.\n    uint256 public totalVesting;\n\n    event NewGrant(address indexed _from, address indexed _to, uint256 _value);\n    event TokensUnlocked(address indexed _to, uint256 _value);\n    event GrantRevoked(address indexed _holder, uint256 _refund);\n\n    /// @dev Constructor that initializes the address of the Kin token contract.\n    /// @param _kin KinToken The address of the previously deployed Kin token contract.\n    function VestingTrustee(KinToken _kin) {\n        require(_kin != address(0));\n\n        kin = _kin;\n    }\n\n    /// @dev Grant tokens to a specified address.\n    /// @param _to address The holder address.\n    /// @param _value uint256 The amount of tokens to be granted.\n    /// @param _start uint256 The beginning of the vesting period.\n    /// @param _cliff uint256 Duration of the cliff period (when the first installment is made).\n    /// @param _end uint256 The end of the vesting period.\n    /// @param _installmentLength uint256 The length of each vesting installment (in seconds).\n    /// @param _revokable bool Whether the grant is revokable or not.\n    function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end,\n        uint256 _installmentLength, bool _revokable)\n        external onlyOwner {\n\n        require(_to != address(0));\n        require(_to != address(this)); // Protect this contract from receiving a grant.\n        require(_value > 0);\n\n        // Require that every holder can be granted tokens only once.\n        require(grants[_to].value == 0);\n\n        // Require for time ranges to be consistent and valid.\n        require(_start <= _cliff && _cliff <= _end);\n\n        // Require installment length to be valid and no longer than (end - start).\n        require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\n\n        // Grant must not exceed the total amount of tokens currently available for vesting.\n        require(totalVesting.add(_value) <= kin.balanceOf(address(this)));\n\n        // Assign a new grant.\n        grants[_to] = Grant({\n            value: _value,\n            start: _start,\n            cliff: _cliff,\n            end: _end,\n            installmentLength: _installmentLength,\n            transferred: 0,\n            revokable: _revokable\n        });\n\n        // Since tokens have been granted, reduce the total amount available for vesting.\n        totalVesting = totalVesting.add(_value);\n\n        NewGrant(msg.sender, _to, _value);\n    }\n\n    /// @dev Revoke the grant of tokens of a specifed address.\n    /// @param _holder The address which will have its tokens revoked.\n    function revoke(address _holder) public onlyOwner {\n        Grant memory grant = grants[_holder];\n\n        // Grant must be revokable.\n        require(grant.revokable);\n\n        // Calculate amount of remaining tokens that can still be returned.\n        uint256 refund = grant.value.sub(grant.transferred);\n\n        // Remove the grant.\n        delete grants[_holder];\n\n        // Update total vesting amount and transfer previously calculated tokens to owner.\n        totalVesting = totalVesting.sub(refund);\n        kin.transfer(msg.sender, refund);\n\n        GrantRevoked(_holder, refund);\n    }\n\n    /// @dev Calculate the total amount of vested tokens of a holder at a given time.\n    /// @param _holder address The address of the holder.\n    /// @param _time uint256 The specific time to calculate against.\n    /// @return a uint256 Representing a holder's total amount of vested tokens.\n    function vestedTokens(address _holder, uint256 _time) external constant returns (uint256) {\n        Grant memory grant = grants[_holder];\n        if (grant.value == 0) {\n            return 0;\n        }\n\n        return calculateVestedTokens(grant, _time);\n    }\n\n    /// @dev Calculate amount of vested tokens at a specifc time.\n    /// @param _grant Grant The vesting grant.\n    /// @param _time uint256 The time to be checked\n    /// @return An uint256 Representing the amount of vested tokens of a specific grant.\n    function calculateVestedTokens(Grant _grant, uint256 _time) private constant returns (uint256) {\n        // If we're before the cliff, then nothing is vested.\n        if (_time < _grant.cliff) {\n            return 0;\n        }\n\n        // If we're after the end of the vesting period - everything is vested;\n        if (_time >= _grant.end) {\n            return _grant.value;\n        }\n\n        // Calculate amount of installments past until now.\n        //\n        // NOTE result gets floored because of integer division.\n        uint256 installmentsPast = _time.sub(_grant.start).div(_grant.installmentLength);\n\n        // Calculate amount of days in entire vesting period.\n        uint256 vestingDays = _grant.end.sub(_grant.start);\n\n        // Calculate and return the number of tokens according to vesting days that have passed.\n        return _grant.value.mul(installmentsPast.mul(_grant.installmentLength)).div(vestingDays);\n    }\n\n    /// @dev Unlock vested tokens and transfer them to the grantee.\n    /// @return a uint256 Representing the amount of vested tokens transferred to their holder.\n    function unlockVestedTokens() external {\n        Grant storage grant = grants[msg.sender];\n\n        // Make sure the grant has tokens available.\n        require(grant.value != 0);\n\n        // Get the total amount of vested tokens, acccording to grant.\n        uint256 vested = calculateVestedTokens(grant, now);\n        if (vested == 0) {\n            return;\n        }\n\n        // Make sure the holder doesn't transfer more than what he already has.\n        uint256 transferable = vested.sub(grant.transferred);\n        if (transferable == 0) {\n            return;\n        }\n\n        // Update transferred and total vesting amount, then transfer remaining vested funds to holder.\n        grant.transferred = grant.transferred.add(transferable);\n        totalVesting = totalVesting.sub(transferable);\n        kin.transfer(msg.sender, transferable);\n\n        TokensUnlocked(msg.sender, transferable);\n    }\n}"
    }
  ]
}