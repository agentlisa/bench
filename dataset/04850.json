{
  "Title": "[G-18] Redundant casting of addresses in `isSystemContract()`",
  "Content": "\n**File:** `SystemContractHelper.sol`\n\n[File: code/system-contracts/contracts/libraries/SystemContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L338)\n```solidity\n338:     function isSystemContract(address _address) internal pure returns (bool) {\n339:         return uint160(_address) <= uint160(MAX_SYSTEM_CONTRACT_ADDRESS);\n340:     }\n```\n\nSolidity allows to compare two addresses without casting them to integer first. This means, that above code can be changed to:\n\n```\nreturn _address <= MAX_SYSTEM_CONTRACT_ADDRESS;\n```\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/libraries/SystemContractHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {MAX_SYSTEM_CONTRACT_ADDRESS} from \"../Constants.sol\";\n\nimport {SystemContractsCaller, CalldataForwardingMode, CALLFLAGS_CALL_ADDRESS, CODE_ADDRESS_CALL_ADDRESS, EVENT_WRITE_ADDRESS, EVENT_INITIALIZE_ADDRESS, GET_EXTRA_ABI_DATA_ADDRESS, LOAD_CALLDATA_INTO_ACTIVE_PTR_CALL_ADDRESS, META_CODE_SHARD_ID_OFFSET, META_CALLER_SHARD_ID_OFFSET, META_SHARD_ID_OFFSET, META_AUX_HEAP_SIZE_OFFSET, META_HEAP_SIZE_OFFSET, META_GAS_PER_PUBDATA_BYTE_OFFSET, MIMIC_CALL_BY_REF_CALL_ADDRESS, META_CALL_ADDRESS, MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT, PTR_CALLDATA_CALL_ADDRESS, PTR_ADD_INTO_ACTIVE_CALL_ADDRESS, PTR_SHRINK_INTO_ACTIVE_CALL_ADDRESS, PTR_PACK_INTO_ACTIVE_CALL_ADDRESS, RAW_FAR_CALL_BY_REF_CALL_ADDRESS, PRECOMPILE_CALL_ADDRESS, SET_CONTEXT_VALUE_CALL_ADDRESS, SYSTEM_CALL_BY_REF_CALL_ADDRESS, TO_L1_CALL_ADDRESS} from \"./SystemContractsCaller.sol\";\n\nuint256 constant UINT32_MASK = type(uint32).max;\nuint256 constant UINT64_MASK = type(uint64).max;\nuint256 constant UINT128_MASK = type(uint128).max;\nuint256 constant ADDRESS_MASK = type(uint160).max;\n\n/// @notice NOTE: The `getZkSyncMeta` that is used to obtain this struct will experience a breaking change in 2024.\nstruct ZkSyncMeta {\n    uint32 pubdataPublished;\n    uint32 heapSize;\n    uint32 auxHeapSize;\n    uint8 shardId;\n    uint8 callerShardId;\n    uint8 codeShardId;\n}\n\nenum Global {\n    CalldataPtr,\n    CallFlags,\n    ExtraABIData1,\n    ExtraABIData2,\n    ReturndataPtr\n}\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Library used for accessing zkEVM-specific opcodes, needed for the development\n * of system contracts.\n * @dev While this library will be eventually available to public, some of the provided\n * methods won't work for non-system contracts and also breaking changes at short notice are possilbe.\n * We do not recommend this library for external use.\n */\nlibrary SystemContractHelper {\n    /// @notice Send an L2Log to L1.\n    /// @param _isService The `isService` flag.\n    /// @param _key The `key` part of the L2Log.\n    /// @param _value The `value` part of the L2Log.\n    /// @dev The meaning of all these parameters is context-dependent, but they\n    /// have no intrinsic meaning per se.\n    function toL1(bool _isService, bytes32 _key, bytes32 _value) internal {\n        address callAddr = TO_L1_CALL_ADDRESS;\n        assembly {\n            // Ensuring that the type is bool\n            _isService := and(_isService, 1)\n            // This `success` is always 0, but the method always succeeds\n            // (except for the cases when there is not enough gas)\n            let success := call(_isService, callAddr, _key, _value, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Get address of the currently executed code.\n    /// @dev This allows differentiating between `call` and `delegatecall`.\n    /// During the former `this` and `codeAddress` are the same, while\n    /// during the latter they are not.\n    function getCodeAddress() internal view returns (address addr) {\n        address callAddr = CODE_ADDRESS_CALL_ADDRESS;\n        assembly {\n            addr := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Provide a compiler hint, by placing calldata fat pointer into virtual `ACTIVE_PTR`,\n    /// that can be manipulated by `ptr.add`/`ptr.sub`/`ptr.pack`/`ptr.shrink` later.\n    /// @dev This allows making a call by forwarding calldata pointer to the child call.\n    /// It is a much more efficient way to forward calldata, than standard EVM bytes copying.\n    function loadCalldataIntoActivePtr() internal view {\n        address callAddr = LOAD_CALLDATA_INTO_ACTIVE_PTR_CALL_ADDRESS;\n        assembly {\n            pop(staticcall(0, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Compiler simulation of the `ptr.pack` opcode for the virtual `ACTIVE_PTR` pointer.\n    /// @dev Do the concatenation between lowest part of `ACTIVE_PTR` and highest part of `_farCallAbi`\n    /// forming packed fat pointer for a far call or ret ABI when necessary.\n    /// Note: Panics if the lowest 128 bits of `_farCallAbi` are not zeroes.\n    function ptrPackIntoActivePtr(uint256 _farCallAbi) internal view {\n        address callAddr = PTR_PACK_INTO_ACTIVE_CALL_ADDRESS;\n        assembly {\n            pop(staticcall(_farCallAbi, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Compiler simulation of the `ptr.add` opcode for the virtual `ACTIVE_PTR` pointer.\n    /// @dev Transforms `ACTIVE_PTR.offset` into `ACTIVE_PTR.offset + u32(_value)`. If overflow happens then it panics.\n    function ptrAddIntoActive(uint32 _value) internal view {\n        address callAddr = PTR_ADD_INTO_ACTIVE_CALL_ADDRESS;\n        uint256 cleanupMask = UINT32_MASK;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _value := and(_value, cleanupMask)\n            pop(staticcall(_value, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Compiler simulation of the `ptr.shrink` opcode for the virtual `ACTIVE_PTR` pointer.\n    /// @dev Transforms `ACTIVE_PTR.length` into `ACTIVE_PTR.length - u32(_shrink)`. If underflow happens then it panics.\n    function ptrShrinkIntoActive(uint32 _shrink) internal view {\n        address callAddr = PTR_SHRINK_INTO_ACTIVE_CALL_ADDRESS;\n        uint256 cleanupMask = UINT32_MASK;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _shrink := and(_shrink, cleanupMask)\n            pop(staticcall(_shrink, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice packs precompile parameters into one word\n    /// @param _inputMemoryOffset The memory offset in 32-byte words for the input data for calling the precompile.\n    /// @param _inputMemoryLength The length of the input data in words.\n    /// @param _outputMemoryOffset The memory offset in 32-byte words for the output data.\n    /// @param _outputMemoryLength The length of the output data in words.\n    /// @param _perPrecompileInterpreted The constant, the meaning of which is defined separately for\n    /// each precompile. For information, please read the documentation of the precompilecall log in\n    /// the VM.\n    function packPrecompileParams(\n        uint32 _inputMemoryOffset,\n        uint32 _inputMemoryLength,\n        uint32 _outputMemoryOffset,\n        uint32 _outputMemoryLength,\n        uint64 _perPrecompileInterpreted\n    ) internal pure returns (uint256 rawParams) {\n        rawParams = _inputMemoryOffset;\n        rawParams |= uint256(_inputMemoryLength) << 32;\n        rawParams |= uint256(_outputMemoryOffset) << 64;\n        rawParams |= uint256(_outputMemoryLength) << 96;\n        rawParams |= uint256(_perPrecompileInterpreted) << 192;\n    }\n\n    /// @notice Call precompile with given parameters.\n    /// @param _rawParams The packed precompile params. They can be retrieved by\n    /// the `packPrecompileParams` method.\n    /// @param _gasToBurn The number of gas to burn during this call.\n    /// @return success Whether the call was successful.\n    /// @dev The list of currently available precompiles sha256, keccak256, ecrecover.\n    /// NOTE: The precompile type depends on `this` which calls precompile, which means that only\n    /// system contracts corresponding to the list of precompiles above can do `precompileCall`.\n    /// @dev If used not in the `sha256`, `keccak256` or `ecrecover` contracts, it will just burn the gas provided.\n    /// @dev This method is `unsafe` because it does not check whether there is enough gas to burn.\n    function unsafePrecompileCall(\n        uint256 _rawParams,\n        uint32 _gasToBurn,\n        uint32 _pubdataToSpend\n    ) internal view returns (bool success) {\n        address callAddr = PRECOMPILE_CALL_ADDRESS;\n\n        uint256 params = uint256(_gasToBurn) + (uint256(_pubdataToSpend) << 32);\n\n        uint256 cleanupMask = UINT64_MASK;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            params := and(params, cleanupMask)\n            success := staticcall(_rawParams, callAddr, params, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Set `msg.value` to next far call.\n    /// @param _value The msg.value that will be used for the *next* call.\n    /// @dev If called not in kernel mode, it will result in a revert (enforced by the VM)\n    function setValueForNextFarCall(uint128 _value) internal returns (bool success) {\n        uint256 cleanupMask = UINT128_MASK;\n        address callAddr = SET_CONTEXT_VALUE_CALL_ADDRESS;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _value := and(_value, cleanupMask)\n            success := call(0, callAddr, _value, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Initialize a new event.\n    /// @param initializer The event initializing value.\n    /// @param value1 The first topic or data chunk.\n    function eventInitialize(uint256 initializer, uint256 value1) internal {\n        address callAddr = EVENT_INITIALIZE_ADDRESS;\n        assembly {\n            pop(call(initializer, callAddr, value1, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Continue writing the previously initialized event.\n    /// @param value1 The first topic or data chunk.\n    /// @param value2 The second topic or data chunk.\n    function eventWrite(uint256 value1, uint256 value2) internal {\n        address callAddr = EVENT_WRITE_ADDRESS;\n        assembly {\n            pop(call(value1, callAddr, value2, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Get the packed representation of the `ZkSyncMeta` from the current context.\n    /// @notice NOTE: The behavior of this function will experience a breaking change in 2024.\n    /// @return meta The packed representation of the ZkSyncMeta.\n    /// @dev The fields in ZkSyncMeta are NOT tightly packed, i.e. there is a special rule on how\n    /// they are packed. For more information, please read the documentation on ZkSyncMeta.\n    function getZkSyncMetaBytes() internal view returns (uint256 meta) {\n        address callAddr = META_CALL_ADDRESS;\n        assembly {\n            meta := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Returns the bits [offset..offset+size-1] of the meta.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @param offset The offset of the bits.\n    /// @param size The size of the extracted number in bits.\n    /// @return result The extracted number.\n    function extractNumberFromMeta(uint256 meta, uint256 offset, uint256 size) internal pure returns (uint256 result) {\n        // Firstly, we delete all the bits after the field\n        uint256 shifted = (meta << (256 - size - offset));\n        // Then we shift everything back\n        result = (shifted >> (256 - size));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the number of gas\n    /// that a single byte sent to L1 as pubdata costs.\n    /// @notice NOTE: The behavior of this function will experience a breaking change in 2024.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return pubdataPublished The current price in gas per pubdata byte.\n    function getPubdataPublishedFromMeta(uint256 meta) internal pure returns (uint32 pubdataPublished) {\n        pubdataPublished = uint32(extractNumberFromMeta(meta, META_GAS_PER_PUBDATA_BYTE_OFFSET, 32));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the number of the current size\n    /// of the heap in bytes.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return heapSize The size of the memory in bytes byte.\n    /// @dev The following expression: getHeapSizeFromMeta(getZkSyncMetaBytes()) is\n    /// equivalent to the MSIZE in Solidity.\n    function getHeapSizeFromMeta(uint256 meta) internal pure returns (uint32 heapSize) {\n        heapSize = uint32(extractNumberFromMeta(meta, META_HEAP_SIZE_OFFSET, 32));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the number of the current size\n    /// of the auxilary heap in bytes.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return auxHeapSize The size of the auxilary memory in bytes byte.\n    /// @dev You can read more on auxilary memory in the VM1.2 documentation.\n    function getAuxHeapSizeFromMeta(uint256 meta) internal pure returns (uint32 auxHeapSize) {\n        auxHeapSize = uint32(extractNumberFromMeta(meta, META_AUX_HEAP_SIZE_OFFSET, 32));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the shardId of `this`.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return shardId The shardId of `this`.\n    /// @dev Currently only shard 0 (zkRollup) is supported.\n    function getShardIdFromMeta(uint256 meta) internal pure returns (uint8 shardId) {\n        shardId = uint8(extractNumberFromMeta(meta, META_SHARD_ID_OFFSET, 8));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the shardId of\n    /// the msg.sender.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return callerShardId The shardId of the msg.sender.\n    /// @dev Currently only shard 0 (zkRollup) is supported.\n    function getCallerShardIdFromMeta(uint256 meta) internal pure returns (uint8 callerShardId) {\n        callerShardId = uint8(extractNumberFromMeta(meta, META_CALLER_SHARD_ID_OFFSET, 8));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the shardId of\n    /// the currently executed code.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return codeShardId The shardId of the currently executed code.\n    /// @dev Currently only shard 0 (zkRollup) is supported.\n    function getCodeShardIdFromMeta(uint256 meta) internal pure returns (uint8 codeShardId) {\n        codeShardId = uint8(extractNumberFromMeta(meta, META_CODE_SHARD_ID_OFFSET, 8));\n    }\n\n    /// @notice Retrieves the ZkSyncMeta structure.\n    /// @notice NOTE: The behavior of this function will experience a breaking change in 2024.\n    /// @return meta The ZkSyncMeta execution context parameters.\n    function getZkSyncMeta() internal view returns (ZkSyncMeta memory meta) {\n        uint256 metaPacked = getZkSyncMetaBytes();\n        meta.pubdataPublished = getPubdataPublishedFromMeta(metaPacked);\n        meta.heapSize = getHeapSizeFromMeta(metaPacked);\n        meta.auxHeapSize = getAuxHeapSizeFromMeta(metaPacked);\n        meta.shardId = getShardIdFromMeta(metaPacked);\n        meta.callerShardId = getCallerShardIdFromMeta(metaPacked);\n        meta.codeShardId = getCodeShardIdFromMeta(metaPacked);\n    }\n\n    /// @notice Returns the call flags for the current call.\n    /// @return callFlags The bitmask of the callflags.\n    /// @dev Call flags is the value of the first register\n    /// at the start of the call.\n    /// @dev The zero bit of the callFlags indicates whether the call is\n    /// a constructor call. The first bit of the callFlags indicates whether\n    /// the call is a system one.\n    function getCallFlags() internal view returns (uint256 callFlags) {\n        address callAddr = CALLFLAGS_CALL_ADDRESS;\n        assembly {\n            callFlags := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Returns the current calldata pointer.\n    /// @return ptr The current calldata pointer.\n    /// @dev NOTE: This file is just an integer and it cannot be used\n    /// to forward the calldata to the next calls in any way.\n    function getCalldataPtr() internal view returns (uint256 ptr) {\n        address callAddr = PTR_CALLDATA_CALL_ADDRESS;\n        assembly {\n            ptr := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Returns the N-th extraAbiParam for the current call.\n    /// @return extraAbiData The value of the N-th extraAbiParam for this call.\n    /// @dev It is equal to the value of the (N+2)-th register\n    /// at the start of the call.\n    function getExtraAbiData(uint256 index) internal view returns (uint256 extraAbiData) {\n        require(index < 10, \"There are only 10 accessible registers\");\n\n        address callAddr = GET_EXTRA_ABI_DATA_ADDRESS;\n        assembly {\n            extraAbiData := staticcall(index, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Retuns whether the current call is a system call.\n    /// @return `true` or `false` based on whether the current call is a system call.\n    function isSystemCall() internal view returns (bool) {\n        uint256 callFlags = getCallFlags();\n        // When the system call is passed, the 2-bit is set to 1\n        return (callFlags & 2) != 0;\n    }\n\n    /// @notice Returns whether the address is a system contract.\n    /// @param _address The address to test\n    /// @return `true` or `false` based on whether the `_address` is a system contract.\n    function isSystemContract(address _address) internal pure returns (bool) {\n        return uint160(_address) <= uint160(MAX_SYSTEM_CONTRACT_ADDRESS);\n    }\n\n    /// @notice Method used for burning a certain amount of gas.\n    /// @param _gasToPay The number of gas to burn.\n    function burnGas(uint32 _gasToPay, uint32 _pubdataToSpend) internal view {\n        bool precompileCallSuccess = unsafePrecompileCall(\n            0, // The precompile parameters are formal ones. We only need the precompile call to burn gas.\n            _gasToPay,\n            _pubdataToSpend\n        );\n        require(precompileCallSuccess, \"Failed to charge gas\");\n    }\n}"
    }
  ]
}