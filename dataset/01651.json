{
  "Title": "M-9: D3UserQuote#getUserQuote queries incorrect token for exchangeRate leading to inaccurate quota calculations",
  "Content": "# Issue M-9: D3UserQuote#getUserQuote queries incorrect token for exchangeRate leading to inaccurate quota calculations \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/193 \n\n## Found by \n0x4db5362c, 0x52, dirk\\_y\n## Summary\n\nA small typo in the valuation loop of D3UserQuote#getUserQuote uses the wrong variable leading to and incorrect quota being returned. The purpose of a quota is to mitigate risk of positions being too large. This incorrect assumption can dramatically underestimate the quota leading to oversized (and overrisk) positions.\n\n## Vulnerability Detail\n\n[D3UserQuota.sol#L75-L84](https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Vault/periphery/D3UserQuota.sol#L75-L84)\n\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address _token = tokenList[i];\n            (address assetDToken,,,,,,,,,,) = d3Vault.getAssetInfo(_token);\n            uint256 tokenBalance = IERC20(assetDToken).balanceOf(user);\n            if (tokenBalance > 0) {\n                tokenBalance = tokenBalance.mul(d3Vault.getExchangeRate(token)); <- @audit-issue queries token instead of _token\n                (uint256 tokenPrice, uint8 priceDecimal) = ID3Oracle(d3Vault._ORACLE_()).getOriginalPrice(_token);\n                usedQuota = usedQuota + tokenBalance * tokenPrice / 10 ** (priceDecimal+tokenDecimals);\n            }\n        }\n\nD3UserQuota.sol#L80 incorrectly uses token rather than _token as it should. This returns the wrong exchange rate which can dramatically alter the perceived token balance as well as the calculated quota.\n\n## Impact\n\nQuota is calculated incorrectly leading to overly risky positions, which in turn can cause loss to the system\n\n## Code Snippet\n\n[D3UserQuota.sol#L69-L97](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/periphery/D3UserQuota.sol#L69-L97)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange variable from token to _token:\n\n    -           tokenBalance = tokenBalance.mul(d3Vault.getExchangeRate(token));\n    +           tokenBalance = tokenBalance.mul(d3Vault.getExchangeRate(_token));\n\n\n\n## Discussion\n\n**traceurl**\n\nWe redesigned D3UserQuota.\n\nIn the old version:\n1. used quota is calculated based on the USD value of the deposited token\n2. global quota is shared by all tokens\n\nIn this new version:\n1. used quota is the amount of the deposited token, so price change won't affect quota\n2. each token has its own global quota\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/periphery/D3UserQuota.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\nimport {IERC20} from \"../../../intf/IERC20.sol\";\nimport {ID3UserQuota} from \"../../intf/ID3UserQuota.sol\";\nimport {ID3Vault} from \"../../intf/ID3Vault.sol\";\nimport \"../../../intf/ID3Oracle.sol\";\nimport \"../../lib/DecimalMath.sol\";\n\n\n/// @title UserQuota\n/// @notice This contract is used to set/get user's quota, i.e., determine the amount of token user can deposit into the pool.\ncontract D3UserQuota is InitializableOwnable, ID3UserQuota {\n    using DecimalMath for uint256;\n\n    // hold token dodo or vdodo or other\n    address public _QUOTA_TOKEN_HOLD;\n    // Threshold Amount [100,200,300,400]\n    uint256[] public quotaTokenHoldAmount;\n    //threshold quota amount\n    uint256[] public quotaTokenAmount;\n    // token => bool Deposit quota limit is not enabled.\n    mapping(address => bool) public isUsingQuota;\n    // token => bool Is the global deposit quota limit enabled\n    mapping(address => bool) public isGlobalQuota;\n    // token => quota The default global deposit quota is in USD.\n    mapping(address => uint256) public gloablQuota;\n\n    ID3Vault public d3Vault;\n\n    constructor(address quotaTokenHold, address d3VaultAddress) {\n        initOwner(msg.sender);\n        _QUOTA_TOKEN_HOLD = quotaTokenHold;\n        d3Vault = ID3Vault(d3VaultAddress);\n    }\n\n    /// @notice Enable quota for a token\n    function enableQuota(address token, bool status) external onlyOwner {\n        isUsingQuota[token] = status;\n    }\n\n    /// @notice Enable global quota for a token\n    function enableGlobalQuota(address token, bool status) external onlyOwner {\n        isGlobalQuota[token] = status;\n    }\n\n    /// @notice Set global quota for a token\n    /// @notice Global quota means every user has the same quota\n    function setGlobalQuota(address token, uint256 amount) external onlyOwner {\n        gloablQuota[token] = amount;\n    }\n    // @notice Token address, holding that token is required to have a quota\n    function setQuotaTokenHold(address quotaTokenHold) external onlyOwner {\n        _QUOTA_TOKEN_HOLD = quotaTokenHold;\n    }\n\n    /// @notice Set the amount of tokens held and their corresponding quotas\n    function setQuotaTokennAmount(\n        uint256[] calldata _quotaTokenHoldAmount,\n        uint256[] calldata _quotaTokenAmount\n    ) external onlyOwner {\n        require(_quotaTokenHoldAmount.length > 0 && _quotaTokenHoldAmount.length == _quotaTokenAmount.length, \"D3UserQuota: length not match\");\n        quotaTokenHoldAmount = _quotaTokenHoldAmount;\n        quotaTokenAmount = _quotaTokenAmount;\n    }\n\n    /// @notice Get the user quota for a token\n    function getUserQuota(address user, address token) public view override returns (uint256) {\n        //Query used quota\n        //tokenlist useraddress get user usd quota\n        uint256 usedQuota = 0;\n        uint8 tokenDecimals = IERC20(token).decimals();\n        address[] memory tokenList = d3Vault.getTokenList();\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address _token = tokenList[i];\n            (address assetDToken,,,,,,,,,,) = d3Vault.getAssetInfo(_token);\n            uint256 tokenBalance = IERC20(assetDToken).balanceOf(user);\n            if (tokenBalance > 0) {\n                tokenBalance = tokenBalance.mul(d3Vault.getExchangeRate(token));\n                (uint256 tokenPrice, uint8 priceDecimal) = ID3Oracle(d3Vault._ORACLE_()).getOriginalPrice(_token);\n                usedQuota = usedQuota + tokenBalance * tokenPrice / 10 ** (priceDecimal+tokenDecimals);\n            }\n        }\n        //token price reduction\n        (uint256 _tokenPrice, uint8 _priceDecimal) = ID3Oracle(d3Vault._ORACLE_()).getOriginalPrice(token);\n        //calculate quota\n        if (isUsingQuota[token]) {\n            if (isGlobalQuota[token]) {\n                return (gloablQuota[token] - usedQuota) * 10 ** (_priceDecimal + tokenDecimals) / _tokenPrice;\n            } else {\n                return (calculateQuota(user) - usedQuota) * 10 ** (_priceDecimal + tokenDecimals) / _tokenPrice;\n            }\n        } else {\n            return type(uint256).max;\n        }\n    }\n    /// @notice Check if the quantity of tokens deposited by the user is allowed.\n    function checkQuota(address user, address token, uint256 amount) public view override returns (bool) {\n        return (amount <= getUserQuota(user, token));\n    }\n\n    /// @notice Get the user quota for a token 100[10] 200[20]\n    function calculateQuota(address user) public view returns (uint256 quota) {\n        uint256 tokenBalance = IERC20(_QUOTA_TOKEN_HOLD).balanceOf(user);\n        for (uint256 i = 0; i < quotaTokenHoldAmount.length; i++) {\n            if (tokenBalance < quotaTokenHoldAmount[i]) {\n                return quota = quotaTokenAmount[i];\n            }\n        }\n        quota = quotaTokenAmount[quotaTokenAmount.length - 1];\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/periphery/D3UserQuota.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\nimport {IERC20} from \"../../../intf/IERC20.sol\";\nimport {ID3UserQuota} from \"../../intf/ID3UserQuota.sol\";\nimport {ID3Vault} from \"../../intf/ID3Vault.sol\";\nimport \"../../../intf/ID3Oracle.sol\";\nimport \"../../lib/DecimalMath.sol\";\n\n\n/// @title UserQuota\n/// @notice This contract is used to set/get user's quota, i.e., determine the amount of token user can deposit into the pool.\ncontract D3UserQuota is InitializableOwnable, ID3UserQuota {\n    using DecimalMath for uint256;\n\n    // hold token dodo or vdodo or other\n    address public _QUOTA_TOKEN_HOLD;\n    // Threshold Amount [100,200,300,400]\n    uint256[] public quotaTokenHoldAmount;\n    //threshold quota amount\n    uint256[] public quotaTokenAmount;\n    // token => bool Deposit quota limit is not enabled.\n    mapping(address => bool) public isUsingQuota;\n    // token => bool Is the global deposit quota limit enabled\n    mapping(address => bool) public isGlobalQuota;\n    // token => quota The default global deposit quota is in USD.\n    mapping(address => uint256) public gloablQuota;\n\n    ID3Vault public d3Vault;\n\n    constructor(address quotaTokenHold, address d3VaultAddress) {\n        initOwner(msg.sender);\n        _QUOTA_TOKEN_HOLD = quotaTokenHold;\n        d3Vault = ID3Vault(d3VaultAddress);\n    }\n\n    /// @notice Enable quota for a token\n    function enableQuota(address token, bool status) external onlyOwner {\n        isUsingQuota[token] = status;\n    }\n\n    /// @notice Enable global quota for a token\n    function enableGlobalQuota(address token, bool status) external onlyOwner {\n        isGlobalQuota[token] = status;\n    }\n\n    /// @notice Set global quota for a token\n    /// @notice Global quota means every user has the same quota\n    function setGlobalQuota(address token, uint256 amount) external onlyOwner {\n        gloablQuota[token] = amount;\n    }\n    // @notice Token address, holding that token is required to have a quota\n    function setQuotaTokenHold(address quotaTokenHold) external onlyOwner {\n        _QUOTA_TOKEN_HOLD = quotaTokenHold;\n    }\n\n    /// @notice Set the amount of tokens held and their corresponding quotas\n    function setQuotaTokennAmount(\n        uint256[] calldata _quotaTokenHoldAmount,\n        uint256[] calldata _quotaTokenAmount\n    ) external onlyOwner {\n        require(_quotaTokenHoldAmount.length > 0 && _quotaTokenHoldAmount.length == _quotaTokenAmount.length, \"D3UserQuota: length not match\");\n        quotaTokenHoldAmount = _quotaTokenHoldAmount;\n        quotaTokenAmount = _quotaTokenAmount;\n    }\n\n    /// @notice Get the user quota for a token\n    function getUserQuota(address user, address token) public view override returns (uint256) {\n        //Query used quota\n        //tokenlist useraddress get user usd quota\n        uint256 usedQuota = 0;\n        uint8 tokenDecimals = IERC20(token).decimals();\n        address[] memory tokenList = d3Vault.getTokenList();\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address _token = tokenList[i];\n            (address assetDToken,,,,,,,,,,) = d3Vault.getAssetInfo(_token);\n            uint256 tokenBalance = IERC20(assetDToken).balanceOf(user);\n            if (tokenBalance > 0) {\n                tokenBalance = tokenBalance.mul(d3Vault.getExchangeRate(token));\n                (uint256 tokenPrice, uint8 priceDecimal) = ID3Oracle(d3Vault._ORACLE_()).getOriginalPrice(_token);\n                usedQuota = usedQuota + tokenBalance * tokenPrice / 10 ** (priceDecimal+tokenDecimals);\n            }\n        }\n        //token price reduction\n        (uint256 _tokenPrice, uint8 _priceDecimal) = ID3Oracle(d3Vault._ORACLE_()).getOriginalPrice(token);\n        //calculate quota\n        if (isUsingQuota[token]) {\n            if (isGlobalQuota[token]) {\n                return (gloablQuota[token] - usedQuota) * 10 ** (_priceDecimal + tokenDecimals) / _tokenPrice;\n            } else {\n                return (calculateQuota(user) - usedQuota) * 10 ** (_priceDecimal + tokenDecimals) / _tokenPrice;\n            }\n        } else {\n            return type(uint256).max;\n        }\n    }\n    /// @notice Check if the quantity of tokens deposited by the user is allowed.\n    function checkQuota(address user, address token, uint256 amount) public view override returns (bool) {\n        return (amount <= getUserQuota(user, token));\n    }\n\n    /// @notice Get the user quota for a token 100[10] 200[20]\n    function calculateQuota(address user) public view returns (uint256 quota) {\n        uint256 tokenBalance = IERC20(_QUOTA_TOKEN_HOLD).balanceOf(user);\n        for (uint256 i = 0; i < quotaTokenHoldAmount.length; i++) {\n            if (tokenBalance < quotaTokenHoldAmount[i]) {\n                return quota = quotaTokenAmount[i];\n            }\n        }\n        quota = quotaTokenAmount[quotaTokenAmount.length - 1];\n    }\n}"
    }
  ]
}