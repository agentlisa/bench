{
  "Title": "[G-02] Bytes constant are cheaper than string constants",
  "Content": "\nIf the string can fit into 32 bytes, then `bytes32` is cheaper than `string`. `string`  is a dynamically sized-type, which has current limitations in Solidity compared to a statically sized variable.\n\n### Proof of Concept\n\n2 instances:\n\n##### src/FERC1155.sol\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L15>\n\n```cpp\n15:     string public constant NAME = \"FERC1155\";\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L17>\n\n```cpp\n15:     string public constant VERSION = \"1\";\n```\n\n### Recommended Mitigation Steps\n\nReplace `string constant` with `bytes(1..32) constant`.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/FERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Clone} from \"clones-with-immutable-args/src/Clone.sol\";\nimport {ERC1155} from \"@rari-capital/solmate/src/tokens/ERC1155.sol\";\nimport {IFERC1155} from \"./interfaces/IFERC1155.sol\";\nimport {INFTReceiver} from \"./interfaces/INFTReceiver.sol\";\nimport \"./constants/Permit.sol\";\n\n/// @title FERC1155\n/// @author Fractional Art\n/// @notice An ERC-1155 implementation for Fractions\ncontract FERC1155 is Clone, ERC1155, IFERC1155 {\n    /// @notice Name of the token contract\n    string public constant NAME = \"FERC1155\";\n    /// @notice Version number of the token contract\n    string public constant VERSION = \"1\";\n    /// @notice Address that can deploy new vaults for this collection, manage metadata, etc\n    address internal _controller;\n    /// @notice URI of contract metadata\n    string public contractURI;\n    /// @notice Mapping of token type approvals owner => operator => tokenId => approved\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        public isApproved;\n    /// @notice Mapping of metadata contracts for token ID types => metadata address\n    mapping(uint256 => address) public metadata;\n    /// @notice Mapping to track account nonces for metadata txs owner => nonces\n    mapping(address => uint256) public nonces;\n    /// @notice Mapping to track total supply for token ID types => totalSupply\n    mapping(uint256 => uint256) public totalSupply;\n    /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress\n    mapping(uint256 => address) private royaltyAddress;\n    /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent\n    mapping(uint256 => uint256) private royaltyPercent;\n\n    /// @notice Modifier for restricting function calls to the controller account\n    modifier onlyController() {\n        address controller_ = controller();\n        if (msg.sender != controller_)\n            revert InvalidSender(controller_, msg.sender);\n        _;\n    }\n\n    /// @notice Modifier for restricting function calls to the VaultRegistry\n    modifier onlyRegistry() {\n        address vaultRegistry = VAULT_REGISTRY();\n        if (msg.sender != vaultRegistry)\n            revert InvalidSender(vaultRegistry, msg.sender);\n        _;\n    }\n\n    /// @notice Burns fractions for an ID\n    /// @param _from Address to burn fraction tokens from\n    /// @param _id Token ID to burn\n    /// @param _amount Number of tokens to burn\n    function burn(\n        address _from,\n        uint256 _id,\n        uint256 _amount\n    ) external onlyRegistry {\n        _burn(_from, _id, _amount);\n        totalSupply[_id] -= _amount;\n    }\n\n    /// @notice Hook to emit the URI update when setting the metadata or updating\n    /// @param _id Token ID metadata was updated for\n    /// @param _uri URI of metadata\n    function emitSetURI(uint256 _id, string memory _uri) external {\n        if (msg.sender != metadata[_id])\n            revert InvalidSender(metadata[_id], msg.sender);\n        emit URI(_uri, _id);\n    }\n\n    /// @notice Mints new fractions for an ID\n    /// @param _to Address to mint fraction tokens to\n    /// @param _id Token ID to mint\n    /// @param _amount Number of tokens to mint\n    /// @param _data Extra calldata to include in the mint\n    function mint(\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external onlyRegistry {\n        _mint(_to, _id, _amount, _data);\n        totalSupply[_id] += _amount;\n    }\n\n    /// @notice Permit function that approves an operator for token type with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permit(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitStructHash(\n                _owner,\n                _operator,\n                _id,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApproved[_owner][_operator][_id] = _approved;\n\n        emit SingleApproval(_owner, _operator, _id, _approved);\n    }\n\n    /// @notice Permit function that approves an operator for all token types with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permitAll(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitAllStructHash(\n                _owner,\n                _operator,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApprovedForAll[_owner][_operator] = _approved;\n\n        emit ApprovalForAll(_owner, _operator, _approved);\n    }\n\n    /// @notice Scoped approvals allow us to eliminate some of the risks associated with setting the approval for an entire collection\n    /// @param _operator Address of spender account\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for operator(spender) account\n    function setApprovalFor(\n        address _operator,\n        uint256 _id,\n        bool _approved\n    ) external {\n        isApproved[msg.sender][_operator][_id] = _approved;\n\n        emit SingleApproval(msg.sender, _operator, _id, _approved);\n    }\n\n    /// @notice Sets the contract metadata\n    /// @param _uri URI of metadata\n    function setContractURI(string calldata _uri) external onlyController {\n        contractURI = _uri;\n    }\n\n    /// @notice Sets the token metadata contract\n    /// @param _metadata Address for metadata contract\n    /// @param _id Token ID to set the metadata for\n    function setMetadata(address _metadata, uint256 _id)\n        external\n        onlyController\n    {\n        metadata[_id] = _metadata;\n        emit SetMetadata(_metadata, _id);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _receiver Address to receive royalties\n    /// @param _percentage Percentage of royalties on secondary sales\n    function setRoyalties(\n        uint256 _id,\n        address _receiver,\n        uint256 _percentage\n    ) external onlyController {\n        royaltyAddress[_id] = _receiver;\n        royaltyPercent[_id] = _percentage;\n        emit SetRoyalty(_receiver, _id, _percentage);\n    }\n\n    /// @notice Updates the controller address for the FERC1155 token contract\n    /// @param _newController Address of new controlling entity\n    function transferController(address _newController)\n        external\n        onlyController\n    {\n        if (_newController == address(0)) revert ZeroAddress();\n        _controller = _newController;\n        emit ControllerTransferred(_newController);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _salePrice Sale price to calculate the royalty for\n    function royaltyInfo(uint256 _id, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        receiver = royaltyAddress[_id];\n        royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n    }\n\n    /// @notice Transfer an amount of a token type between two accounts\n    /// @param _from Source address for an amount of tokens\n    /// @param _to Destination address for an amount of tokens\n    /// @param _id ID of the token type\n    /// @param _amount The amount of tokens being transferred\n    /// @param _data Additional calldata\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override(ERC1155, IFERC1155) {\n        require(\n            msg.sender == _from ||\n                isApprovedForAll[_from][msg.sender] ||\n                isApproved[_from][msg.sender][_id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        balanceOf[_from][_id] -= _amount;\n        balanceOf[_to][_id] += _amount;\n\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n\n        require(\n            _to.code.length == 0\n                ? _to != address(0)\n                : INFTReceiver(_to).onERC1155Received(\n                    msg.sender,\n                    _from,\n                    _id,\n                    _amount,\n                    _data\n                ) == INFTReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /// @notice Getter for URI of a token type\n    /// @param _id ID of the token type\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155, IFERC1155)\n        returns (string memory)\n    {\n        require(metadata[_id] != address(0), \"NO METADATA\");\n        return IFERC1155(metadata[_id]).uri(_id);\n    }\n\n    /// @notice Getter for controller account\n    function controller() public view returns (address controllerAddress) {\n        _controller == address(0)\n            ? controllerAddress = INITIAL_CONTROLLER()\n            : controllerAddress = _controller;\n    }\n\n    /// @notice Getter for initial controller account immutable argument stored in calldata\n    function INITIAL_CONTROLLER() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    /// @notice VaultRegistry address that is allowed to call mint() and burn()\n    function VAULT_REGISTRY() public pure returns (address) {\n        return _getArgAddress(20);\n    }\n\n    /// @dev Computes hash of permit struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitStructHash(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _id,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes hash of permit all struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitAllStructHash(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_ALL_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes domain separator to prevent signature collisions\n    /// @return Hash of the contract-specific fields\n    function _computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(NAME)),\n                    keccak256(bytes(VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Computes digest of domain separator and struct hash\n    /// @param _domainSeparator Hash of contract-specific fields\n    /// @param _structHash Hash of signature fields struct\n    /// @return Hash of the signature digest\n    function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash)\n            );\n    }\n}"
    },
    {
      "filename": "src/FERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Clone} from \"clones-with-immutable-args/src/Clone.sol\";\nimport {ERC1155} from \"@rari-capital/solmate/src/tokens/ERC1155.sol\";\nimport {IFERC1155} from \"./interfaces/IFERC1155.sol\";\nimport {INFTReceiver} from \"./interfaces/INFTReceiver.sol\";\nimport \"./constants/Permit.sol\";\n\n/// @title FERC1155\n/// @author Fractional Art\n/// @notice An ERC-1155 implementation for Fractions\ncontract FERC1155 is Clone, ERC1155, IFERC1155 {\n    /// @notice Name of the token contract\n    string public constant NAME = \"FERC1155\";\n    /// @notice Version number of the token contract\n    string public constant VERSION = \"1\";\n    /// @notice Address that can deploy new vaults for this collection, manage metadata, etc\n    address internal _controller;\n    /// @notice URI of contract metadata\n    string public contractURI;\n    /// @notice Mapping of token type approvals owner => operator => tokenId => approved\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        public isApproved;\n    /// @notice Mapping of metadata contracts for token ID types => metadata address\n    mapping(uint256 => address) public metadata;\n    /// @notice Mapping to track account nonces for metadata txs owner => nonces\n    mapping(address => uint256) public nonces;\n    /// @notice Mapping to track total supply for token ID types => totalSupply\n    mapping(uint256 => uint256) public totalSupply;\n    /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress\n    mapping(uint256 => address) private royaltyAddress;\n    /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent\n    mapping(uint256 => uint256) private royaltyPercent;\n\n    /// @notice Modifier for restricting function calls to the controller account\n    modifier onlyController() {\n        address controller_ = controller();\n        if (msg.sender != controller_)\n            revert InvalidSender(controller_, msg.sender);\n        _;\n    }\n\n    /// @notice Modifier for restricting function calls to the VaultRegistry\n    modifier onlyRegistry() {\n        address vaultRegistry = VAULT_REGISTRY();\n        if (msg.sender != vaultRegistry)\n            revert InvalidSender(vaultRegistry, msg.sender);\n        _;\n    }\n\n    /// @notice Burns fractions for an ID\n    /// @param _from Address to burn fraction tokens from\n    /// @param _id Token ID to burn\n    /// @param _amount Number of tokens to burn\n    function burn(\n        address _from,\n        uint256 _id,\n        uint256 _amount\n    ) external onlyRegistry {\n        _burn(_from, _id, _amount);\n        totalSupply[_id] -= _amount;\n    }\n\n    /// @notice Hook to emit the URI update when setting the metadata or updating\n    /// @param _id Token ID metadata was updated for\n    /// @param _uri URI of metadata\n    function emitSetURI(uint256 _id, string memory _uri) external {\n        if (msg.sender != metadata[_id])\n            revert InvalidSender(metadata[_id], msg.sender);\n        emit URI(_uri, _id);\n    }\n\n    /// @notice Mints new fractions for an ID\n    /// @param _to Address to mint fraction tokens to\n    /// @param _id Token ID to mint\n    /// @param _amount Number of tokens to mint\n    /// @param _data Extra calldata to include in the mint\n    function mint(\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external onlyRegistry {\n        _mint(_to, _id, _amount, _data);\n        totalSupply[_id] += _amount;\n    }\n\n    /// @notice Permit function that approves an operator for token type with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permit(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitStructHash(\n                _owner,\n                _operator,\n                _id,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApproved[_owner][_operator][_id] = _approved;\n\n        emit SingleApproval(_owner, _operator, _id, _approved);\n    }\n\n    /// @notice Permit function that approves an operator for all token types with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permitAll(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitAllStructHash(\n                _owner,\n                _operator,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApprovedForAll[_owner][_operator] = _approved;\n\n        emit ApprovalForAll(_owner, _operator, _approved);\n    }\n\n    /// @notice Scoped approvals allow us to eliminate some of the risks associated with setting the approval for an entire collection\n    /// @param _operator Address of spender account\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for operator(spender) account\n    function setApprovalFor(\n        address _operator,\n        uint256 _id,\n        bool _approved\n    ) external {\n        isApproved[msg.sender][_operator][_id] = _approved;\n\n        emit SingleApproval(msg.sender, _operator, _id, _approved);\n    }\n\n    /// @notice Sets the contract metadata\n    /// @param _uri URI of metadata\n    function setContractURI(string calldata _uri) external onlyController {\n        contractURI = _uri;\n    }\n\n    /// @notice Sets the token metadata contract\n    /// @param _metadata Address for metadata contract\n    /// @param _id Token ID to set the metadata for\n    function setMetadata(address _metadata, uint256 _id)\n        external\n        onlyController\n    {\n        metadata[_id] = _metadata;\n        emit SetMetadata(_metadata, _id);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _receiver Address to receive royalties\n    /// @param _percentage Percentage of royalties on secondary sales\n    function setRoyalties(\n        uint256 _id,\n        address _receiver,\n        uint256 _percentage\n    ) external onlyController {\n        royaltyAddress[_id] = _receiver;\n        royaltyPercent[_id] = _percentage;\n        emit SetRoyalty(_receiver, _id, _percentage);\n    }\n\n    /// @notice Updates the controller address for the FERC1155 token contract\n    /// @param _newController Address of new controlling entity\n    function transferController(address _newController)\n        external\n        onlyController\n    {\n        if (_newController == address(0)) revert ZeroAddress();\n        _controller = _newController;\n        emit ControllerTransferred(_newController);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _salePrice Sale price to calculate the royalty for\n    function royaltyInfo(uint256 _id, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        receiver = royaltyAddress[_id];\n        royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n    }\n\n    /// @notice Transfer an amount of a token type between two accounts\n    /// @param _from Source address for an amount of tokens\n    /// @param _to Destination address for an amount of tokens\n    /// @param _id ID of the token type\n    /// @param _amount The amount of tokens being transferred\n    /// @param _data Additional calldata\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override(ERC1155, IFERC1155) {\n        require(\n            msg.sender == _from ||\n                isApprovedForAll[_from][msg.sender] ||\n                isApproved[_from][msg.sender][_id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        balanceOf[_from][_id] -= _amount;\n        balanceOf[_to][_id] += _amount;\n\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n\n        require(\n            _to.code.length == 0\n                ? _to != address(0)\n                : INFTReceiver(_to).onERC1155Received(\n                    msg.sender,\n                    _from,\n                    _id,\n                    _amount,\n                    _data\n                ) == INFTReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /// @notice Getter for URI of a token type\n    /// @param _id ID of the token type\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155, IFERC1155)\n        returns (string memory)\n    {\n        require(metadata[_id] != address(0), \"NO METADATA\");\n        return IFERC1155(metadata[_id]).uri(_id);\n    }\n\n    /// @notice Getter for controller account\n    function controller() public view returns (address controllerAddress) {\n        _controller == address(0)\n            ? controllerAddress = INITIAL_CONTROLLER()\n            : controllerAddress = _controller;\n    }\n\n    /// @notice Getter for initial controller account immutable argument stored in calldata\n    function INITIAL_CONTROLLER() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    /// @notice VaultRegistry address that is allowed to call mint() and burn()\n    function VAULT_REGISTRY() public pure returns (address) {\n        return _getArgAddress(20);\n    }\n\n    /// @dev Computes hash of permit struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitStructHash(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _id,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes hash of permit all struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitAllStructHash(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_ALL_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes domain separator to prevent signature collisions\n    /// @return Hash of the contract-specific fields\n    function _computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(NAME)),\n                    keccak256(bytes(VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Computes digest of domain separator and struct hash\n    /// @param _domainSeparator Hash of contract-specific fields\n    /// @param _structHash Hash of signature fields struct\n    /// @return Hash of the signature digest\n    function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash)\n            );\n    }\n}"
    }
  ]
}