{
  "Title": "No logging of important events",
  "Content": "##### Description\nLogging important actions makes it easier to maintain the project.\nBut in this smart contract it is not done for some important events.\nAt lines https://github.com/lidofinance/1inch-rewards-manager/blob/c2cd9665666deda9452fa9e3461fbf3537413945/contracts/RewardsManager.vy#L100-L120 for the `start_next_rewards_period()` external function this event logging is lacking.\nAt lines https://github.com/lidofinance/1inch-rewards-manager/blob/c2cd9665666deda9452fa9e3461fbf3537413945/contracts/RewardsManager.vy#L124-L131 for the external function `set_rewards_period_duration()` this event is not logged.\n\n##### Recommendation\nIt is recommended to add logging of important events.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RewardsManager.vy",
      "content": "# @version 0.2.15\n# @notice A manager contract for the FarmingRewards contract.\n# @license MIT\nfrom vyper.interfaces import ERC20\n\n\nstruct TokenReward:\n    gift_token: address\n    scale: uint256\n    duration: uint256\n    reward_distribution: address\n    period_finish: uint256\n    reward_rate: uint256\n    last_update_time: uint256\n    reward_per_token_stored: uint256\n\n\ninterface FarmingRewards:\n    def tokenRewards(index: uint256) -> TokenReward: view\n    def notifyRewardAmount(index: uint256, reward: uint256): nonpayable\n    def setDuration(i: uint256, duration: uint256): nonpayable\n\n\nevent OwnershipTransferred: \n    previous_owner: indexed(address)\n    new_owner: indexed(address)\n\nevent RewardsContractSet:\n    rewards_contract: indexed(address)\n\nevent ERC20TokenRecovered:\n    token: indexed(address)\n    amount: uint256\n    recipient: indexed(address)\n\n\nowner: public(address)\nGIFT_INDEX: constant(uint256) = 1\nrewards_contract: public(address)\nldo_token: constant(address) = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32\nrewards_initializer: public(address)\n\n\n@external\ndef __init__(_rewards_contract: address, _rewards_initializer: address):\n    assert _rewards_contract != ZERO_ADDRESS, \"rewards contract: zero address\"\n    assert _rewards_initializer != ZERO_ADDRESS, \"rewards initializer: zero address\"\n    self.rewards_contract = _rewards_contract\n    log RewardsContractSet(_rewards_contract)\n\n    self.owner = msg.sender\n    log OwnershipTransferred(ZERO_ADDRESS, msg.sender)\n\n    self.rewards_initializer = _rewards_initializer\n\n\n@external\ndef transfer_ownership(_to: address):\n    \"\"\"\n    @notice\n        Changes the contract owner.\n        Can only be called by the current owner.\n    \"\"\"\n    old_owner: address = self.owner\n    assert msg.sender == old_owner, \"not permitted\"\n    self.owner = _to\n\n    log OwnershipTransferred(old_owner, _to)\n\n\n@view\n@internal\ndef _period_finish(rewards_contract: address) -> uint256:\n    reward: TokenReward = FarmingRewards(rewards_contract).tokenRewards(GIFT_INDEX)\n    return reward.period_finish\n\n\n@view\n@internal\ndef _is_rewards_period_finished(rewards_contract: address) -> bool:\n    return block.timestamp >= self._period_finish(rewards_contract)\n\n\n@view\n@external\ndef is_rewards_period_finished() -> bool:\n    \"\"\"\n    @notice Whether the current rewards period has finished.\n    \"\"\"\n    return self._is_rewards_period_finished(self.rewards_contract)\n\n\n@view\n@external\ndef period_finish() -> uint256:\n    return self._period_finish(self.rewards_contract)\n\n\n@external\ndef start_next_rewards_period():\n    \"\"\"\n    @notice\n        Starts the next rewards via calling `FarmingRewards.notifyRewardAmount()`\n        and transferring `ldo_token.balanceOf(self)` tokens to `FarmingRewards`.\n        The `FarmingRewards` contract handles all the rest on its own.\n        The current rewards period must be finished by this time.\n        First period could be started only by `self.rewards_initializer`\n    \"\"\"\n    rewards: address = self.rewards_contract\n\n    assert self._period_finish(rewards) > 0 or self.rewards_initializer == msg.sender, \"manager: not initialized\"\n    \n    amount: uint256 = ERC20(ldo_token).balanceOf(self)\n\n    assert amount != 0, \"manager: rewards disabled\"\n    assert self._is_rewards_period_finished(rewards), \"manager: rewards period not finished\"\n\n    assert ERC20(ldo_token).transfer(rewards, amount), \"manager: unable to transfer reward tokens\"\n\n    FarmingRewards(rewards).notifyRewardAmount(GIFT_INDEX, amount)\n\n\n@external\ndef set_rewards_period_duration(_duration: uint256):\n    \"\"\"\n    @notice\n        Updates period duration.  Can only be called by the owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"manager: not permitted\"\n\n    FarmingRewards(self.rewards_contract).setDuration(GIFT_INDEX, _duration)\n\n\n@external\ndef recover_erc20(_token: address, _amount: uint256, _recipient: address = msg.sender):\n    \"\"\"\n    @notice\n        Transfers the given _amount of the given ERC20 token from self\n        to the recipient. Can only be called by the owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"not permitted\"\n\n    if _amount != 0:\n        assert ERC20(_token).transfer(_recipient, _amount), \"token transfer failed\"\n        log ERC20TokenRecovered(_token, _amount, _recipient)"
    },
    {
      "filename": "contracts/RewardsManager.vy",
      "content": "# @version 0.2.15\n# @notice A manager contract for the FarmingRewards contract.\n# @license MIT\nfrom vyper.interfaces import ERC20\n\n\nstruct TokenReward:\n    gift_token: address\n    scale: uint256\n    duration: uint256\n    reward_distribution: address\n    period_finish: uint256\n    reward_rate: uint256\n    last_update_time: uint256\n    reward_per_token_stored: uint256\n\n\ninterface FarmingRewards:\n    def tokenRewards(index: uint256) -> TokenReward: view\n    def notifyRewardAmount(index: uint256, reward: uint256): nonpayable\n    def setDuration(i: uint256, duration: uint256): nonpayable\n\n\nevent OwnershipTransferred: \n    previous_owner: indexed(address)\n    new_owner: indexed(address)\n\nevent RewardsContractSet:\n    rewards_contract: indexed(address)\n\nevent ERC20TokenRecovered:\n    token: indexed(address)\n    amount: uint256\n    recipient: indexed(address)\n\n\nowner: public(address)\nGIFT_INDEX: constant(uint256) = 1\nrewards_contract: public(address)\nldo_token: constant(address) = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32\nrewards_initializer: public(address)\n\n\n@external\ndef __init__(_rewards_contract: address, _rewards_initializer: address):\n    assert _rewards_contract != ZERO_ADDRESS, \"rewards contract: zero address\"\n    assert _rewards_initializer != ZERO_ADDRESS, \"rewards initializer: zero address\"\n    self.rewards_contract = _rewards_contract\n    log RewardsContractSet(_rewards_contract)\n\n    self.owner = msg.sender\n    log OwnershipTransferred(ZERO_ADDRESS, msg.sender)\n\n    self.rewards_initializer = _rewards_initializer\n\n\n@external\ndef transfer_ownership(_to: address):\n    \"\"\"\n    @notice\n        Changes the contract owner.\n        Can only be called by the current owner.\n    \"\"\"\n    old_owner: address = self.owner\n    assert msg.sender == old_owner, \"not permitted\"\n    self.owner = _to\n\n    log OwnershipTransferred(old_owner, _to)\n\n\n@view\n@internal\ndef _period_finish(rewards_contract: address) -> uint256:\n    reward: TokenReward = FarmingRewards(rewards_contract).tokenRewards(GIFT_INDEX)\n    return reward.period_finish\n\n\n@view\n@internal\ndef _is_rewards_period_finished(rewards_contract: address) -> bool:\n    return block.timestamp >= self._period_finish(rewards_contract)\n\n\n@view\n@external\ndef is_rewards_period_finished() -> bool:\n    \"\"\"\n    @notice Whether the current rewards period has finished.\n    \"\"\"\n    return self._is_rewards_period_finished(self.rewards_contract)\n\n\n@view\n@external\ndef period_finish() -> uint256:\n    return self._period_finish(self.rewards_contract)\n\n\n@external\ndef start_next_rewards_period():\n    \"\"\"\n    @notice\n        Starts the next rewards via calling `FarmingRewards.notifyRewardAmount()`\n        and transferring `ldo_token.balanceOf(self)` tokens to `FarmingRewards`.\n        The `FarmingRewards` contract handles all the rest on its own.\n        The current rewards period must be finished by this time.\n        First period could be started only by `self.rewards_initializer`\n    \"\"\"\n    rewards: address = self.rewards_contract\n\n    assert self._period_finish(rewards) > 0 or self.rewards_initializer == msg.sender, \"manager: not initialized\"\n    \n    amount: uint256 = ERC20(ldo_token).balanceOf(self)\n\n    assert amount != 0, \"manager: rewards disabled\"\n    assert self._is_rewards_period_finished(rewards), \"manager: rewards period not finished\"\n\n    assert ERC20(ldo_token).transfer(rewards, amount), \"manager: unable to transfer reward tokens\"\n\n    FarmingRewards(rewards).notifyRewardAmount(GIFT_INDEX, amount)\n\n\n@external\ndef set_rewards_period_duration(_duration: uint256):\n    \"\"\"\n    @notice\n        Updates period duration.  Can only be called by the owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"manager: not permitted\"\n\n    FarmingRewards(self.rewards_contract).setDuration(GIFT_INDEX, _duration)\n\n\n@external\ndef recover_erc20(_token: address, _amount: uint256, _recipient: address = msg.sender):\n    \"\"\"\n    @notice\n        Transfers the given _amount of the given ERC20 token from self\n        to the recipient. Can only be called by the owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"not permitted\"\n\n    if _amount != 0:\n        assert ERC20(_token).transfer(_recipient, _amount), \"token transfer failed\"\n        log ERC20TokenRecovered(_token, _amount, _recipient)"
    }
  ]
}