{
  "Title": "H-5: Token amounts are scaled up twice causing the amounts to be inflated in two token vault",
  "Content": "# Issue H-5: Token amounts are scaled up twice causing the amounts to be inflated in two token vault \n\nSource: https://github.com/sherlock-audit/2022-12-notional-judging/issues/13 \n\n## Found by \nxiaoming90\n\n## Summary\n\nToken amounts are scaled up twice causing the amounts to be inflated in two token vault when performing computation. This in turn causes the reinvest function to break leading to a loss of assets for vault users, and the value of their strategy tokens will be struck and will not appreciate.\n\n## Vulnerability Detail\n\nIn Line 121-124, the `primaryAmount` and `secondaryAmount` are scaled up to `BALANCER_PRECISION` (1e18). The reason for doing so is that balancer math functions expect all amounts to be in `BALANCER_PRECISION` (1e18).\n\nThen, the scaled `primaryAmount` and `secondaryAmount` are passed into the `_getSpotPrice` function at Line 126.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L99\n\n```solidity\nFile: Stable2TokenOracleMath.sol\n099:     function _validateSpotPriceAndPairPrice(\n100:         StableOracleContext calldata oracleContext,\n101:         TwoTokenPoolContext calldata poolContext,\n102:         StrategyContext memory strategyContext,\n103:         uint256 oraclePrice,\n104:         uint256 primaryAmount, \n105:         uint256 secondaryAmount\n106:     ) internal view {\n107:         // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n108:         uint256 spotPrice = _getSpotPrice({\n109:             oracleContext: oracleContext,\n110:             poolContext: poolContext,\n111:             primaryBalance: poolContext.primaryBalance,\n112:             secondaryBalance: poolContext.secondaryBalance,\n113:             tokenIndex: 0\n114:         });\n115: \n116:         /// @notice Check spotPrice against oracle price to make sure that \n117:         /// the pool is not being manipulated\n118:         _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n119: \n120:         /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n121:         uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n122:         uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n123:         primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n124:         secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n125: \n126:         uint256 calculatedPairPrice = _getSpotPrice({\n127:             oracleContext: oracleContext,\n128:             poolContext: poolContext,\n129:             primaryBalance: primaryAmount,\n130:             secondaryBalance: secondaryAmount,\n131:             tokenIndex: 0\n132:         });\n```\n\nWithin the `_getSpotPrice` function, the `primaryBalance` and `secondaryBalance` are scaled up again at Line 25 - 28. As such, any token (e.g. USDC) with a decimal of less than `BALANCER_PRECISION` (1e18) will be scaled up twice. This will cause the `balanceX` or `balanceY` to be inflated.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L15\n\n```solidity\nFile: Stable2TokenOracleMath.sol\n15:     function _getSpotPrice(\n16:         StableOracleContext memory oracleContext, \n17:         TwoTokenPoolContext memory poolContext, \n18:         uint256 primaryBalance,\n19:         uint256 secondaryBalance,\n20:         uint256 tokenIndex\n21:     ) internal view returns (uint256 spotPrice) {\n22:         require(tokenIndex < 2); /// @dev invalid token index\n23: \n24:         /// Apply scale factors\n25:         uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor \n26:             / BalancerConstants.BALANCER_PRECISION;\n27:         uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor \n28:             / BalancerConstants.BALANCER_PRECISION;\n29: \n30:         /// @notice poolContext balances are always in BALANCER_PRECISION (1e18)\n31:         (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n32:             (scaledPrimaryBalance, scaledSecondaryBalance) :\n33:             (scaledSecondaryBalance, scaledPrimaryBalance);\n34: \n35:         uint256 invariant = StableMath._calculateInvariant(\n36:             oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n37:         );\n38: \n39:         spotPrice = StableMath._calcSpotPrice({\n40:             amplificationParameter: oracleContext.ampParam,\n41:             invariant: invariant,\n42:             balanceX: balanceX,\n43:             balanceY: balanceY\n44:         });\n45: \n46:         /// Apply secondary scale factor in reverse\n47:         uint256 scaleFactor = tokenIndex == 0 ?\n48:             poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor :\n49:             poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n50:         spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n51:     }\n```\n\n#### Balancer's Scaling Factors\n\nIt is important to know the underlying mechanism of scaling factors within Balancer to understand this issue.\n\nWithin Balancer, all stable math calculations within the Balancer's pools are performed in 1e18. Thus, before passing the token balances to the stable math functions, all the balances need to be normalized to 18 decimals.\n\nFor instance, assume that 100 USDC needs to be passed into the stable math functions for some computation. 100 USDC is equal to `100e6` since the decimals of USDC is `6`. To normalize it to 18 decimals, 100 USDC (`100e6`) will be multiplied by its scaling factor (1e12), and the result will be `100e18`.\n\nThe following code taken from Balancer shows that the scaling factor is comprised of the scaling factor multiplied by the token rate. The scaling factor is the value needed to normalize the token balance to 18 decimals. \n\nhttps://etherscan.io/address/0x32296969Ef14EB0c6d29669C550D4a0449130230#code\n\n```solidity\n    /**\n     * @dev Overrides scaling factor getter to introduce the tokens' price rate.\n     * Note that it may update the price rate cache if necessary.\n     */\n    function _scalingFactors() internal view virtual override returns (uint256[] memory scalingFactors) {\n        // There is no need to check the arrays length since both are based on `_getTotalTokens`\n        // Given there is no generic direction for this rounding, it simply follows the same strategy as the BasePool.\n        scalingFactors = super._scalingFactors();\n        scalingFactors[0] = scalingFactors[0].mulDown(_priceRate(_token0));\n        scalingFactors[1] = scalingFactors[1].mulDown(_priceRate(_token1));\n    }\n```\n\nAnother point to note is that Balancer's stable math functions perform calculations in fixed point format. Therefore, the scaling factor will consist of the `FixedPoint.ONE` (1e18) multiplied by the value needed to normalize the token balance to 18 decimals. If it is a USDC with 6 decimals, the scaling factor will be `1e30`:\n\n```solidity\nFixedPoint.ONE * 10**decimalsDifference\n1e18 * 1e12 = 1e30\n```\n\nhttps://etherscan.io/address/0x32296969Ef14EB0c6d29669C550D4a0449130230#code\n\n```solidity\n    /**\n     * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if\n     * it had 18 decimals.\n     */\n    function _computeScalingFactor(IERC20 token) internal view returns (uint256) {\n        // Tokens that don't implement the `decimals` method are not supported.\n        uint256 tokenDecimals = ERC20(address(token)).decimals();\n\n        // Tokens with more than 18 decimals are not supported.\n        uint256 decimalsDifference = Math.sub(18, tokenDecimals);\n        return FixedPoint.ONE * 10**decimalsDifference;\n    }\n```\n\n#### Proof-of-Concept\n\nAssume that one of the tokens in Notional's two token leverage vault has a decimal of less than 18. Let's take USDC as an example.\n\n1. 100 USDC (1e6) is passed into the `_validateSpotPriceAndPairPrice` function as the `primaryAmount`. In Line 121-124 of the `_validateSpotPriceAndPairPrice` function, the `primaryAmount`  will be scaled up to `BALANCER_PRECISION` (1e18). \n\n   ```solidity\n   primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n   primaryAmount = 100e6 * 1e18 / 1e6\n   primaryAmount = 100e18\n   ```\n\n2. Within the `_getSpotPrice` function, the `primaryBalance` is scaled up again at Line 25 - 28 of the `_getSpotPrice` function.\n\n   ```solidity\n   scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor / BalancerConstants.BALANCER_PRECISION;\n   scaledPrimaryBalance = 100e18 * 1e30 / 1e18\n   scaledPrimaryBalance = 1e30\n   scaledPrimaryBalance = 1000000000000e18\n   ```\n\n   As shown above, normalized 100 USDC (100e18) ended up becoming normalized 1000000000000 USDC (1000000000000e18). Therefore, the stable math functions are computed with an inflated balance of 1000000000000 USDC instead of 100 USDC.\n\n## Impact\n\nThe spot price computed by the `Stable2TokenOracleMath._getSpotPrice` function will deviate from the actual price because inflated balances were passed into it. The deviated spot price will then be passed to the `_checkPriceLimit` function to verify if the spot price has deviated from the oracle price. The check will fail and cause a revert. This will in turn cause the `Stable2TokenOracleMath._validateSpotPriceAndPairPrice` function to revert.\n\nTherefore, any function that relies on the `Stable2TokenOracleMath._validateSpotPriceAndPairPrice` function will be affected. It was found that the `MetaStable2TokenAuraHelper.reinvestReward` relies on the `Stable2TokenOracleMath._validateSpotPriceAndPairPrice` function. As such, reinvest feature of the vault will be broken and the vault will not be able to reinvest its rewards.\n\nThis in turn led to a loss of assets for vault users, and the value of their strategy tokens will be struck and will not appreciate.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L99\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L15\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSince the token balances are already normalized to 18 decimals within the `_getSpotPrice` function, the code to normalize the token balances in the `_validateSpotPriceAndPairPrice` function can be removed.\n\n```diff\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n-        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n-        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n-        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n-        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n-        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: primaryAmount,\n            secondaryBalance: secondaryAmount,\n            tokenIndex: 0\n        });\n\n        /// @notice Check the calculated primary/secondary price against the oracle price\n        /// to make sure that we are joining the pool proportionally\n        _checkPriceLimit(strategyContext, oraclePrice, calculatedPairPrice);\n    }\n```\n\n## Discussion\n\n**weitianjie2000**\n\nvalid, will fix\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/31",
  "Code": [
    {
      "filename": "contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 primaryBalance,\n        uint256 secondaryBalance,\n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        /// Apply scale factors\n        uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n\n        /// @notice poolContext balances are always in BALANCER_PRECISION (1e18)\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (scaledPrimaryBalance, scaledSecondaryBalance) :\n            (scaledSecondaryBalance, scaledPrimaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n\n        /// Apply secondary scale factor in reverse\n        uint256 scaleFactor = tokenIndex == 0 ?\n            poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor :\n            poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n    }\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal view {\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 oraclePrice,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: primaryAmount,\n            secondaryBalance: secondaryAmount,\n            tokenIndex: 0\n        });\n\n        /// @notice Check the calculated primary/secondary price against the oracle price\n        /// to make sure that we are joining the pool proportionally\n        _checkPriceLimit(strategyContext, oraclePrice, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 primaryBalance,\n        uint256 secondaryBalance,\n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        /// Apply scale factors\n        uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n\n        /// @notice poolContext balances are always in BALANCER_PRECISION (1e18)\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (scaledPrimaryBalance, scaledSecondaryBalance) :\n            (scaledSecondaryBalance, scaledPrimaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n\n        /// Apply secondary scale factor in reverse\n        uint256 scaleFactor = tokenIndex == 0 ?\n            poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor :\n            poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n    }\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal view {\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 oraclePrice,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: primaryAmount,\n            secondaryBalance: secondaryAmount,\n            tokenIndex: 0\n        });\n\n        /// @notice Check the calculated primary/secondary price against the oracle price\n        /// to make sure that we are joining the pool proportionally\n        _checkPriceLimit(strategyContext, oraclePrice, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 primaryBalance,\n        uint256 secondaryBalance,\n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        /// Apply scale factors\n        uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n\n        /// @notice poolContext balances are always in BALANCER_PRECISION (1e18)\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (scaledPrimaryBalance, scaledSecondaryBalance) :\n            (scaledSecondaryBalance, scaledPrimaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n\n        /// Apply secondary scale factor in reverse\n        uint256 scaleFactor = tokenIndex == 0 ?\n            poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor :\n            poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n    }\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal view {\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 oraclePrice,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: primaryAmount,\n            secondaryBalance: secondaryAmount,\n            tokenIndex: 0\n        });\n\n        /// @notice Check the calculated primary/secondary price against the oracle price\n        /// to make sure that we are joining the pool proportionally\n        _checkPriceLimit(strategyContext, oraclePrice, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 primaryBalance,\n        uint256 secondaryBalance,\n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        /// Apply scale factors\n        uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n\n        /// @notice poolContext balances are always in BALANCER_PRECISION (1e18)\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (scaledPrimaryBalance, scaledSecondaryBalance) :\n            (scaledSecondaryBalance, scaledPrimaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n\n        /// Apply secondary scale factor in reverse\n        uint256 scaleFactor = tokenIndex == 0 ?\n            poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor :\n            poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n    }\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal view {\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 oraclePrice,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: primaryAmount,\n            secondaryBalance: secondaryAmount,\n            tokenIndex: 0\n        });\n\n        /// @notice Check the calculated primary/secondary price against the oracle price\n        /// to make sure that we are joining the pool proportionally\n        _checkPriceLimit(strategyContext, oraclePrice, calculatedPairPrice);\n    }\n}"
    }
  ]
}