{
  "Title": "[H-01] Incorrect handling of `pricefeed.decimals()`",
  "Content": "\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/oracles/PegOracle.sol#L46-L83>\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L299-L300>\n\n### Impact\n\nWrong math for handling pricefeed decimals. This code will only work for pricefeeds of 8 decimals, any others give wrong/incorrect data. The maths used can be shown in three lines:\n\n```solidity\nnowPrice = (price1 * 10000) / price2;\nnowPrice = nowPrice * int256(10**(18 - priceFeed1.decimals()));\nreturn nowPrice / 1000000;\n```\n\nLine1: adds 4 decimals\nLine2: adds (18 - d) decimals, (where d = pricefeed.decimals())\nLine3:  removes 6 decimals\n\nTotal: adds (16 - d) decimals\n\nwhen d=8, the contract correctly returns an 8 decimal number. However, when d = 6, the function will return a 10 decimal number. This is further raised by (18-d = 12) decimals when checking for depeg event, leading to a 22 decimal number which is 4 orders of magnitude incorrect.\n\nif d=18, (like usd-eth pricefeeds) contract fails / returns 0.\n\nAll chainlink contracts which give price in eth, operate with 18 decimals. So this can cripple the system if added later.\n\n### Proof of Concept\n\nRunning the test  AssertTest.t.sol:testPegOracleMarketCreation and changing the line on\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/test/AssertTest.t.sol#L30>\n\nto\n\n```solidity\nPegOracle pegOracle3 = new PegOracle(\n            0xB1552C5e96B312d0Bf8b554186F846C40614a540,  //usd-eth contract address\n            btcEthOracle\n        );\n```\n\ngives this output\n\n    oracle3price1: 1085903802394919427                                                                                                                                                                               \n    oracle3price2: 13753840915281064000                                                                                                                                                                              \n    oracle3price1 / oracle3price2: 0\n\nreturning an oracle value of 0. Simulating with a mock price feed of 6 decimals gives results 4 orders of magnitude off.\n\n### Tools Used\n\nFoundry, VS-Code\n\n### Recommended Mitigation Steps\n\nSince only the price ratio is calculated, there is no point in increasing the decimal by (18-d) in the second line. Proposed solution:\n\n```solidity\nnowPrice = (price1 * 10000) / price2;\nnowPrice = nowPrice * int256(10**(priceFeed1.decimals())) * 100;\nreturn nowPrice / 1000000;\n```\n\nThis returns results in d decimals, no matter the value of d.\n\n**[MiguelBits (Y2K Finance) confirmed](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/195)** \n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-y2k-finance-contest",
  "Code": [
    {
      "filename": "src/oracles/PegOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\n\ncontract PegOracle {\n    /***\n    @dev  for example: oracle1 would be stETH / USD, while oracle2 would be ETH / USD oracle\n    ***/\n    address public oracle1;\n    address public oracle2;\n\n    uint8 public decimals;\n\n    AggregatorV3Interface internal priceFeed1;\n    AggregatorV3Interface internal priceFeed2;\n\n    /** @notice Contract constructor\n      * @param _oracle1 First oracle address\n      * @param _oracle2 Second oracle address\n      */\n    constructor(address _oracle1, address _oracle2) {\n        require(_oracle1 != address(0), \"oracle1 cannot be the zero address\");\n        require(_oracle2 != address(0), \"oracle2 cannot be the zero address\");\n        require(_oracle1 != _oracle2, \"Cannot be same Oracle\");\n        priceFeed1 = AggregatorV3Interface(_oracle1);\n        priceFeed2 = AggregatorV3Interface(_oracle2);\n        require(\n            (priceFeed1.decimals() == priceFeed2.decimals()),\n            \"Decimals must be the same\"\n        );\n\n        oracle1 = _oracle1;\n        oracle2 = _oracle2;\n\n        decimals = priceFeed1.decimals();\n    }\n\n    /** @notice Returns oracle-fed data from the latest round\n      * @return roundID Current round id \n      * @return nowPrice Current price\n      * @return startedAt Starting timestamp\n      * @return timeStamp Current timestamp\n      * @return answeredInRound Round id for which answer was computed \n      */ \n    function latestRoundData()\n        public\n        view\n        returns (\n            uint80 roundID,\n            int256 nowPrice,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        )\n    {\n        (\n            uint80 roundID1,\n            int256 price1,\n            uint256 startedAt1,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        int256 price2 = getOracle2_Price();\n\n        if (price1 > price2) {\n            nowPrice = (price2 * 10000) / price1;\n        } else {\n            nowPrice = (price1 * 10000) / price2;\n        }\n\n        int256 decimals10 = int256(10**(18 - priceFeed1.decimals()));\n        nowPrice = nowPrice * decimals10;\n\n        return (\n            roundID1,\n            nowPrice / 1000000,\n            startedAt1,\n            timeStamp1,\n            answeredInRound1\n        );\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup first oracle price\n      * @return price Current first oracle price\n      */ \n    function getOracle1_Price() public view returns (int256 price) {\n        (\n            uint80 roundID1,\n            int256 price1,\n            ,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        require(price1 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound1 >= roundID1,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp1 != 0, \"Timestamp == 0 !\");\n\n        return price1;\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup second oracle price\n      * @return price Current second oracle price\n      */ \n    function getOracle2_Price() public view returns (int256 price) {\n        (\n            uint80 roundID2,\n            int256 price2,\n            ,\n            uint256 timeStamp2,\n            uint80 answeredInRound2\n        ) = priceFeed2.latestRoundData();\n\n        require(price2 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound2 >= roundID2,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp2 != 0, \"Timestamp == 0 !\");\n\n        return price2;\n    }\n}"
    },
    {
      "filename": "src/Controller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"./VaultFactory.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract Controller {\n    address public immutable admin;\n    VaultFactory public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n    uint256 public constant VAULTS_LENGTH = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error NotZeroTVL();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error TimestampZero();\n    error AddressNotAdmin();\n    error EpochNotExist();\n    error EpochNotExpired();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Depegs insurance vault when event is emitted\n      * @param epochMarketID Current market epoch ID\n      * @param tvl Current TVL\n      * @param isDisaster Flag if event isDisaster\n      * @param epoch Current epoch \n      * @param time Current time\n      * @param depegPrice Price that triggered depeg\n      */\n    event DepegInsurance(\n        bytes32 epochMarketID,\n        VaultTVL tvl,\n        bool isDisaster,\n        uint256 epoch,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /* solhint-disable  var-name-mixedcase */\n    struct VaultTVL {\n        uint256 RISK_claimTVL;\n        uint256 RISK_finalTVL;\n        uint256 INSR_claimTVL;\n        uint256 INSR_finalTVL;\n    }\n    /* solhint-enable  var-name-mixedcase */\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Modifier to ensure market exists, current market epoch time and price are valid \n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        if(\n            vaultsAddress.length != VAULTS_LENGTH\n            )\n            revert MarketDoesNotExist(marketIndex);\n\n        address vaultAddress = vaultsAddress[0];\n        Vault vault = Vault(vaultAddress);\n\n        if(vault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        if(\n            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n            )\n            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n\n        if(\n            vault.idEpochBegin(epochEnd) > block.timestamp)\n            revert EpochNotStarted();\n\n        if(\n            block.timestamp > epochEnd\n            )\n            revert EpochExpired();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      * @param _l2Sequencer Arbitrum sequencer address\n      */ \n    constructor(\n        address _factory,\n        address _admin,\n        address _l2Sequencer\n    ) {\n        if(_admin == address(0))\n            revert ZeroAddress();\n\n        if(_factory == address(0)) \n            revert ZeroAddress();\n\n        if(_l2Sequencer == address(0))\n            revert ZeroAddress();\n        \n        admin = _admin;\n        vaultFactory = VaultFactory(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n        if(\n            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n                revert MarketDoesNotExist(marketIndex);\n        if(\n            block.timestamp < epochEnd)\n            revert EpochNotExpired();\n\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, false);\n        riskVault.endEpoch(epochEnd, false);\n\n        insrVault.setClaimTVL(epochEnd, 0);\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n        insrVault.sendTokens(epochEnd, address(riskVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            false,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN SETTINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n      * @param _token Target token address\n      * @return nowPrice Current token price\n      */\n    function getLatestPrice(address _token)\n        public\n        view\n        returns (int256 nowPrice)\n    {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        uint256 decimals = 10**(18-(priceFeed.decimals()));\n        price = price * int256(decimals);\n\n        if(price <= 0)\n            revert OraclePriceZero();\n\n        if(answeredInRound < roundID)\n            revert RoundIDOutdated();\n\n        if(timeStamp == 0)\n            revert TimestampZero();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n      * @dev need to find way to express typecasts in NatSpec\n      */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n}"
    },
    {
      "filename": "test/AssertTest.t.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport {Vault} from \"../src/Vault.sol\";\nimport {VaultFactory} from \"../src/VaultFactory.sol\";\nimport {Controller} from \"../src/Controller.sol\";\nimport {PegOracle} from \"../src/oracles/PegOracle.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport {Helper} from \"./Helper.sol\";\n\nimport {FakeOracle} from \"./oracles/FakeOracle.sol\";\nimport {DepegOracle} from \"./oracles/DepegOracle.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\n\n\ncontract AssertTest is Helper {\n\t\n\t/*///////////////////////////////////////////////////////////////\n                           CREATION functions\n    //////////////////////////////////////////////////////////////*/\n\n    function testPegOracleMarketCreation() public {\n        PegOracle pegOracle = new PegOracle(oracleSTETH, oracleETH);\n        PegOracle pegOracle2 = new PegOracle(oracleFRAX, oracleFEI);\n\n        // //Eth price feed minus something to trigger depeg\n        FakeOracle fakeOracle = new FakeOracle(oracleETH, CREATION_STRK);\n        PegOracle pegOracle3 = new PegOracle(address(fakeOracle), oracleETH);\n\n        vm.startPrank(admin);\n        vaultFactory.createNewMarket(FEE, tokenSTETH, DEPEG_AAA, beginEpoch, endEpoch, address(pegOracle), \"y2kSTETH_99*\");\n        vaultFactory.createNewMarket(FEE, tokenFEI, DEPEG_BBB, beginEpoch, endEpoch, address(pegOracle2), \"y2kSTETH_97*\");\n        vaultFactory.createNewMarket(FEE, WETH, DEPEG_CCC, beginEpoch, endEpoch, address(pegOracle3), \"y2kSTETH_95*\");\n        vm.stopPrank();\n\n        Deposit(1);\n        Deposit(2);\n        Deposit(3);\n\n        int256 oracle1price1 = pegOracle.getOracle1_Price();\n        int256 oracle1price2 = pegOracle.getOracle2_Price();\n        emit log_named_int(\"oracle1price1\", oracle1price1);\n        emit log_named_int(\"oracle1price2\", oracle1price2);\n        (\n            ,\n            int256 price,\n            ,\n            ,\n            \n        ) = pegOracle.latestRoundData();\n        emit log_named_int(\"oracle1price1 / oracle1price2\", price);\n\n        int256 oracle2price1 = pegOracle2.getOracle1_Price();\n        int256 oracle2price2 = pegOracle2.getOracle2_Price();\n        emit log_named_int(\"oracle2price1\", oracle2price1);\n        emit log_named_int(\"oracle2price2\", oracle2price2);\n        (\n            ,\n            price,\n            ,\n            ,\n            \n        ) = pegOracle2.latestRoundData();\n        emit log_named_int(\"oracle2price1 / oracle2price2\", price);\n\n        int256 oracle3price1 = pegOracle3.getOracle1_Price();\n        int256 oracle3price2 = pegOracle3.getOracle2_Price();\n        emit log_named_int(\"oracle3price1\", oracle3price1);\n        emit log_named_int(\"oracle3price2\", oracle3price2);\n        (\n            ,\n            price,\n            ,\n            ,\n            \n        ) = pegOracle3.latestRoundData();\n        emit log_named_int(\"oracle3price1 / oracle3price2\", price);\n\n        ControllerEndEpoch(tokenSTETH,1);\n        ControllerEndEpoch(tokenFEI,2);\n        ControllerEndEpoch(WETH,3);\n\n        Withdraw();\n    }\n\n    function testAllMarketsCreation() public {\n        vm.startPrank(admin);\n\n        // Create FRAX market\n        //index 1\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, oracleFRAX, \"y2kFRAX_99*\");\n        //index 2\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_BBB, beginEpoch, endEpoch, oracleFRAX, \"y2kFRAX_97*\");\n        //index 3\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_CCC, beginEpoch, endEpoch, oracleFRAX, \"y2kFRAX_95*\");\n\n        // Create MIM market\n        //index 4\n        vaultFactory.createNewMarket(FEE, tokenMIM, DEPEG_AAA, beginEpoch, endEpoch, oracleMIM, \"y2kMIM_99*\");\n        //index 5\n        vaultFactory.createNewMarket(FEE, tokenMIM, DEPEG_BBB, beginEpoch, endEpoch, oracleMIM, \"y2kMIM_97*\");\n        //index 6\n        vaultFactory.createNewMarket(FEE, tokenMIM, DEPEG_CCC, beginEpoch, endEpoch, oracleMIM, \"y2kMIM_95*\");\n\n        // Create FEI market\n        //index 7\n        vaultFactory.createNewMarket(FEE, tokenFEI, DEPEG_AAA, beginEpoch, endEpoch, oracleFEI, \"y2kFEI_99*\");\n        //index 8\n        vaultFactory.createNewMarket(FEE, tokenFEI, DEPEG_BBB, beginEpoch, endEpoch, oracleFEI, \"y2kFEI_97*\");\n        //index 9\n        vaultFactory.createNewMarket(FEE, tokenFEI, DEPEG_CCC, beginEpoch, endEpoch, oracleFEI, \"y2kFEI_95*\");\n\n        // Create USDC market\n        //index 10\n        vaultFactory.createNewMarket(FEE, tokenUSDC, DEPEG_AAA, beginEpoch, endEpoch, oracleUSDC, \"y2kUSDC_99*\");\n        //index 11\n        vaultFactory.createNewMarket(FEE, tokenUSDC, DEPEG_BBB, beginEpoch, endEpoch, oracleUSDC, \"y2kUSDC_97*\");\n        //index 12\n        vaultFactory.createNewMarket(FEE, tokenUSDC, DEPEG_CCC, beginEpoch, endEpoch, oracleUSDC, \"y2kUSDC_95*\");\n\n        // Create DAI market\n        //index 13\n        vaultFactory.createNewMarket(FEE, tokenDAI, DEPEG_AAA, beginEpoch, endEpoch, oracleDAI, \"y2kDAI_99*\");\n        //index 14\n        vaultFactory.createNewMarket(FEE, tokenDAI, DEPEG_BBB, beginEpoch, endEpoch, oracleDAI, \"y2kDAI_97*\");\n        //index 15\n        vaultFactory.createNewMarket(FEE, tokenDAI, DEPEG_CCC, beginEpoch, endEpoch, oracleDAI, \"y2kDAI_95*\");\n        \n        vm.stopPrank();\n    }\n\n    function testAllMarketsDeployMore() public {\n\n        testAllMarketsCreation();\n\n        vm.startPrank(admin);\n\n        // Deploy more FRAX market\n        vaultFactory.deployMoreAssets(SINGLE_MARKET_INDEX, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n        vaultFactory.deployMoreAssets(2, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n        vaultFactory.deployMoreAssets(3, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n\n        // Deploy more MIM market\n        vaultFactory.deployMoreAssets(4, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n        vaultFactory.deployMoreAssets(5, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n        vaultFactory.deployMoreAssets(6, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n\n        // Deploy more FEI market\n        vaultFactory.deployMoreAssets(7, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n        vaultFactory.deployMoreAssets(8, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n        vaultFactory.deployMoreAssets(9, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n\n        // Deploy more USDC market\n        vaultFactory.deployMoreAssets(10, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n        vaultFactory.deployMoreAssets(11, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n        vaultFactory.deployMoreAssets(12, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n\n        // Deploy more DAI market\n        vaultFactory.deployMoreAssets(13, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n        vaultFactory.deployMoreAssets(14, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n        vaultFactory.deployMoreAssets(ALL_MARKETS_INDEX, beginEpoch + END_DAYS, endEpoch + END_DAYS, FEE);\n\n        vm.stopPrank();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           DEPOSIT functions\n    //////////////////////////////////////////////////////////////*/\n\n    function testDeposit() public {\n        vm.deal(alice, AMOUNT);\n        vm.deal(bob, AMOUNT * BOB_MULTIPLIER);\n        vm.deal(chad, AMOUNT * CHAD_MULTIPLIER);\n        vm.deal(degen, AMOUNT * DEGEN_MULTIPLIER);\n\n        vm.prank(admin);\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, oracleFRAX, \"y2kFRAX_99*\");\n\n        address hedge = vaultFactory.getVaults(1)[0];\n        address risk = vaultFactory.getVaults(1)[1];\n        \n        Vault vHedge = Vault(hedge);\n        Vault vRisk = Vault(risk);\n\n        //ALICE hedge DEPOSIT\n        vm.startPrank(alice);\n        ERC20(WETH).approve(hedge, AMOUNT);\n        vHedge.depositETH{value: AMOUNT}(endEpoch, alice);\n        vm.stopPrank();\n\n        //BOB hedge DEPOSIT\n        vm.startPrank(bob);\n        ERC20(WETH).approve(hedge, AMOUNT * BOB_MULTIPLIER);\n        vHedge.depositETH{value: AMOUNT * BOB_MULTIPLIER}(endEpoch, bob);\n\n        assertTrue(vHedge.balanceOf(bob,endEpoch) == AMOUNT * BOB_MULTIPLIER);\n        vm.stopPrank();\n\n        //CHAD risk DEPOSIT\n        vm.startPrank(chad);\n        ERC20(WETH).approve(risk, AMOUNT * CHAD_MULTIPLIER);\n        vRisk.depositETH{value: AMOUNT * CHAD_MULTIPLIER}(endEpoch, chad);\n\n        assertTrue(vRisk.balanceOf(chad,endEpoch) == (AMOUNT * CHAD_MULTIPLIER));\n        vm.stopPrank();\n\n        //DEGEN risk DEPOSIT\n        vm.startPrank(degen);\n        ERC20(WETH).approve(risk, AMOUNT * DEGEN_MULTIPLIER);\n        vRisk.depositETH{value: AMOUNT * DEGEN_MULTIPLIER}(endEpoch, degen);\n\n        assertTrue(vRisk.balanceOf(degen,endEpoch) == (AMOUNT * DEGEN_MULTIPLIER));\n        vm.stopPrank();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           CONTROLLER functions\n    //////////////////////////////////////////////////////////////*/\n\n    function testControllerDepeg() public{\n\n        DepositDepeg();\n\n        address hedge = vaultFactory.getVaults(1)[0];\n        address risk = vaultFactory.getVaults(1)[1];\n\n        Vault vHedge = Vault(hedge);\n        Vault vRisk = Vault(risk);\n\n        vm.warp(beginEpoch + 10 days);\n\n        emit log_named_int(\"strike price\", vHedge.strikePrice());\n        emit log_named_int(\"oracle price\", controller.getLatestPrice(tokenFRAX));\n\n        controller.triggerDepeg(SINGLE_MARKET_INDEX, endEpoch);\n\n        assertTrue(vHedge.totalAssets(endEpoch) == vRisk.idClaimTVL(endEpoch), \"Claim TVL Risk not equal to Total Tvl Hedge\");\n        assertTrue(vRisk.totalAssets(endEpoch) == vHedge.idClaimTVL(endEpoch), \"Claim TVL Hedge not equal to Total Tvl Risk\");\n    }\n\n    function testControllerEndEpoch() public{\n\n        testDeposit();\n\n        address hedge = vaultFactory.getVaults(1)[0];\n        address risk = vaultFactory.getVaults(1)[1];\n\n        Vault vHedge = Vault(hedge);\n        Vault vRisk = Vault(risk);\n\n        vm.warp(endEpoch + 1 days);\n\n        emit log_named_int(\"strike price\", vHedge.strikePrice());\n        emit log_named_int(\"oracle price\", controller.getLatestPrice(tokenFRAX));\n\n        controller.triggerEndEpoch(SINGLE_MARKET_INDEX, endEpoch);\n\n        assertTrue(vHedge.totalAssets(endEpoch) == vRisk.idClaimTVL(endEpoch), \"Claim TVL not equal\");\n        //emit log_named_uint(\"claim tvl\", vHedge.idClaimTVL(endEpoch));\n        assertTrue(NULL_BALANCE == vHedge.idClaimTVL(endEpoch), \"Hedge Claim TVL not zero\");\n    }\n\n    function testCreateController() public {\n        vm.startPrank(admin);\n        Controller test_controller = new Controller(address(vaultFactory),admin, arbitrum_sequencer);\n        assertEq(address(vaultFactory), address(test_controller.vaultFactory()));\n        assertEq(admin, test_controller.admin());\n        vm.stopPrank();\n    }\n\n    \n\n    /*function testTriggerDepeg() public {\n        DepositDepeg();\n        vm.startPrank(admin);\n        DepegOracle depegOracle = new DepegOracle(address(oracleFRAX), address(admin));\n        Controller controller = new Controller(address(vaultFactory),admin, arbitrum_sequencer);\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, address(depegOracle), \"y2kFRAX_99*\");\n        vaultFactory.setController(address(controller));\n        vm.stopPrank();\n\n        vm.warp(beginEpoch + 1 days);\n        controller.triggerDepeg(vaultFactory.marketIndex(), endEpoch);\n        VaultFactory testFactory = controller.vaultFactory();\n        assertEq(vaultFactory.getVaults(vaultFactory.marketIndex()), testFactory.getVaults(testFactory.marketIndex()));\n\n    }*/\n\n    function testTriggerEndEpoch() public {\n        DepositDepeg();\n        vm.startPrank(admin);\n        Controller test_controller = new Controller(address(vaultFactory),admin, arbitrum_sequencer);\n        vaultFactory.setController(address(test_controller));\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, oracleFRAX, \"y2kFRAX_99*\");\n        vm.warp(endEpoch + 1 days);\n        controller.triggerEndEpoch(SINGLE_MARKET_INDEX, endEpoch);\n        VaultFactory testFactory = controller.vaultFactory();\n        assertEq(vaultFactory.getVaults(vaultFactory.marketIndex()), testFactory.getVaults(testFactory.marketIndex()));\n        vm.stopPrank();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           WITHDRAW functions\n    //////////////////////////////////////////////////////////////*/\n\n    function testWithdrawDepeg() public {\n        testControllerDepeg();\n\n        address hedge = vaultFactory.getVaults(1)[0];\n        address risk = vaultFactory.getVaults(1)[1];\n\n        Vault vHedge = Vault(hedge);\n        Vault vRisk = Vault(risk);\n\n        uint assets;\n\n        //ALICE hedge WITHDRAW\n        vm.startPrank(alice);\n        assets = vHedge.balanceOf(alice,endEpoch);\n        vHedge.withdraw(endEpoch, assets, alice, alice);\n\n        assertTrue(vHedge.balanceOf(alice,endEpoch) == NULL_BALANCE);\n        uint256 entitledShares = vHedge.beforeWithdraw(endEpoch, assets);\n        assertTrue(entitledShares - vHedge.calculateWithdrawalFeeValue(entitledShares,endEpoch) == ERC20(WETH).balanceOf(alice));\n\n        vm.stopPrank();\n\n        //BOB hedge WITHDRAW\n        vm.startPrank(bob);\n        assets = vHedge.balanceOf(bob,endEpoch);\n        vHedge.withdraw(endEpoch, assets, bob, bob);\n        \n        assertTrue(vHedge.balanceOf(bob,endEpoch) == NULL_BALANCE);\n        entitledShares = vHedge.beforeWithdraw(endEpoch, assets);\n        assertTrue(entitledShares - vHedge.calculateWithdrawalFeeValue(entitledShares,endEpoch) == ERC20(WETH).balanceOf(bob));\n\n        vm.stopPrank();\n\n        emit log_named_uint(\"hedge balance\", ERC20(WETH).balanceOf(address(vHedge)));\n\n        //CHAD risk WITHDRAW\n        vm.startPrank(chad);\n        assets = vRisk.balanceOf(chad,endEpoch);\n        vRisk.withdraw(endEpoch, assets, chad, chad);\n\n        assertTrue(vRisk.balanceOf(chad,endEpoch) == NULL_BALANCE);\n        entitledShares = vRisk.beforeWithdraw(endEpoch, assets);\n        assertTrue(entitledShares - vRisk.calculateWithdrawalFeeValue(entitledShares,endEpoch) == ERC20(WETH).balanceOf(chad));\n\n        vm.stopPrank();\n\n        //DEGEN risk WITHDRAW\n        vm.startPrank(degen);\n        assets = vRisk.balanceOf(degen,endEpoch);\n        vRisk.withdraw(endEpoch, assets, degen, degen);\n\n        assertTrue(vRisk.balanceOf(degen,endEpoch) == NULL_BALANCE);\n        entitledShares = vRisk.beforeWithdraw(endEpoch, assets);\n        assertTrue(entitledShares - vRisk.calculateWithdrawalFeeValue(entitledShares,endEpoch) == ERC20(WETH).balanceOf(degen));\n\n        vm.stopPrank();\n\n        emit log_named_uint(\"risk balance\", ERC20(WETH).balanceOf(address(vRisk)));\n    }\n\n\n    /*///////////////////////////////////////////////////////////////\n                           VAULTFACTORY functions\n    //////////////////////////////////////////////////////////////*/\n    \n    function testCreateVaultFactory() public {\n        vm.startPrank(admin);\n        VaultFactory testFactory = new VaultFactory(address(controller), address(tokenFRAX), address(admin));\n        assertEq(address(controller), testFactory.treasury());\n        assertEq(address(tokenFRAX), testFactory.WETH());\n        assertEq(address(admin), testFactory.Admin());\n        vm.stopPrank();\n    }\n\n\n    /*///////////////////////////////////////////////////////////////\n                           GOVTOKEN functions\n    //////////////////////////////////////////////////////////////*/\n\n    function testMintGovToken() public {\n        vm.startPrank(admin);\n        vaultFactory.createNewMarket(NULL_BALANCE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, oracleFRAX, \"y2kSTETH_99*\");\n        rewardsFactory.createStakingRewards(SINGLE_MARKET_INDEX, endEpoch, REWARDS_DURATION, REWARD_RATE);\n        govToken.moneyPrinterGoesBrr(alice);\n        uint256 aliceBalance = ERC20(address(govToken)).balanceOf(alice);\n        emit log_named_int(\"Alice Balance\", int256(aliceBalance));\n        assert(aliceBalance != NULL_BALANCE);\n        vm.stopPrank();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           REWARDSFACTORY functions\n    //////////////////////////////////////////////////////////////*/\n\n    function testStakingRewards() public {\n        //address exists\n        vm.startPrank(admin);\n        vaultFactory.createNewMarket(FEE, tokenSTETH, DEPEG_AAA, beginEpoch, endEpoch, oracleFRAX, \"y2kSTETH_99*\");\n        //to-do:expect emit CreatedStakingReward\n        rewardsFactory.createStakingRewards(SINGLE_MARKET_INDEX, endEpoch, REWARDS_DURATION, REWARD_RATE);\n        //to-do: assert if rewards exist and != 0\n        (,address firstAdd) = rewardsFactory.createStakingRewards(SINGLE_MARKET_INDEX, endEpoch, REWARDS_DURATION, REWARD_RATE);\n        (address secondAdd,) = rewardsFactory.createStakingRewards(SINGLE_MARKET_INDEX, endEpoch, REWARDS_DURATION, REWARD_RATE);\n        assert((firstAdd != address(0)) && (secondAdd != address(0)));\n        vm.stopPrank();\n\n        //works for multiple/all markets\n        vm.startPrank(admin);\n        // Create FRAX markets\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, oracleFRAX, \"y2kFRAX_99*\");\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_BBB, beginEpoch, endEpoch, oracleFRAX, \"y2kFRAX_97*\");\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_CCC, beginEpoch, endEpoch, oracleFRAX, \"y2kFRAX_95*\");\n\n        // Create MIM markets\n        vaultFactory.createNewMarket(FEE, tokenMIM, DEPEG_AAA, beginEpoch, endEpoch, oracleMIM, \"y2kMIM_99*\");\n        vaultFactory.createNewMarket(FEE, tokenMIM, DEPEG_BBB, beginEpoch, endEpoch, oracleMIM, \"y2kMIM_97*\");\n        vaultFactory.createNewMarket(FEE, tokenMIM, DEPEG_CCC, beginEpoch, endEpoch, oracleMIM, \"y2kMIM_95*\");\n\n        // Create FEI markets\n        vaultFactory.createNewMarket(FEE, tokenFEI, DEPEG_AAA, beginEpoch, endEpoch, oracleFEI, \"y2kFEI_99*\");\n        vaultFactory.createNewMarket(FEE, tokenFEI, DEPEG_BBB, beginEpoch, endEpoch, oracleFEI, \"y2kFEI_97*\");\n        vaultFactory.createNewMarket(FEE, tokenFEI, DEPEG_CCC, beginEpoch, endEpoch, oracleFEI, \"y2kFEI_95*\");\n\n        // Create USDC markets\n        vaultFactory.createNewMarket(FEE, tokenUSDC, DEPEG_AAA, beginEpoch, end"
    }
  ]
}