{
  "Title": "[L17] Excessive indirection",
  "Content": "[`LinkedList`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/LinkedList.sol), [`SortedLinkedList`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol), and [`SortedLinkedListWithMedian`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedListWithMedian.sol) are part of a group of libraries for managing double linked lists throughout the project. For instance, they are being used for saving oracles’ reports in the [`SortedOracles`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol) contract to keep them in order and therefore, be able to calculate the rates’ median.\n\n\nEvery time a `SortedLinkedListWithMedian` variable is defined, the [list structure within it](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedListWithMedian.sol#L18-L22) has to wrap a `SortedLinkedList` for saving and managing [`integer values`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol#L15) and thus maintain an order, and also the latter [has to wrap a `LinkedList`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol#L14) for being able to access the basic structure and functionality of a double linked list.\n\n\nTherefore, to access a particular element of the list from `SortedLinkedListWithMedian`, going through the `SortedLinkedList` and `LinkedList` is imperative, and this leads to confusing blocks of code such as in [line 142](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedListWithMedian.sol#L142) to pop an element, or [line 242](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedListWithMedian.sol#L242) to update the median.\n\n\nWhile this does not pose a security risk per se, it introduces a lot of complexity to an important section of the code, is error prone and difficult to maintain in the long term.\n\n\nConsider redesigning these libraries to remove excessive indirection, and consider documenting how these libraries work and what their purposes and responsibilities are.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/linkedlists/SortedLinkedListWithMedian.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./LinkedList.sol\";\nimport \"./SortedLinkedList.sol\";\n\n/**\n * @title Maintains a sorted list of unsigned ints keyed by bytes32.\n */\nlibrary SortedLinkedListWithMedian {\n  using SafeMath for uint256;\n  using SortedLinkedList for SortedLinkedList.List;\n\n  enum MedianAction { None, Lesser, Greater }\n\n  enum MedianRelation { Undefined, Lesser, Greater, Equal }\n\n  struct List {\n    SortedLinkedList.List list;\n    bytes32 median;\n    mapping(bytes32 => MedianRelation) relation;\n  }\n\n  /**\n   * @notice Inserts an element into a doubly linked list.\n   * @param key The key of the element to insert.\n   * @param value The element value.\n   * @param lesserKey The key of the element less than the element to insert.\n   * @param greaterKey The key of the element greater than the element to insert.\n   */\n  function insert(\n    List storage list,\n    bytes32 key,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) public {\n    list.list.insert(key, value, lesserKey, greaterKey);\n    LinkedList.Element storage element = list.list.list.elements[key];\n\n    MedianAction action = MedianAction.None;\n    if (list.list.list.numElements == 1) {\n      list.median = key;\n      list.relation[key] = MedianRelation.Equal;\n    } else if (list.list.list.numElements % 2 == 1) {\n      // When we have an odd number of elements, and the element that we inserted is less than\n      // the previous median, we need to slide the median down one element, since we had previously\n      // selected the greater of the two middle elements.\n      if (\n        element.previousKey == bytes32(0) ||\n        list.relation[element.previousKey] == MedianRelation.Lesser\n      ) {\n        action = MedianAction.Lesser;\n        list.relation[key] = MedianRelation.Lesser;\n      } else {\n        list.relation[key] = MedianRelation.Greater;\n      }\n    } else {\n      // When we have an even number of elements, and the element that we inserted is greater than\n      // the previous median, we need to slide the median up one element, since we always select\n      // the greater of the two middle elements.\n      if (\n        element.nextKey == bytes32(0) || list.relation[element.nextKey] == MedianRelation.Greater\n      ) {\n        action = MedianAction.Greater;\n        list.relation[key] = MedianRelation.Greater;\n      } else {\n        list.relation[key] = MedianRelation.Lesser;\n      }\n    }\n    updateMedian(list, action);\n  }\n\n  /**\n   * @notice Removes an element from the doubly linked list.\n   * @param key The key of the element to remove.\n   */\n  function remove(List storage list, bytes32 key) public {\n    MedianAction action = MedianAction.None;\n    if (list.list.list.numElements == 0) {\n      list.median = bytes32(0);\n    } else if (list.list.list.numElements % 2 == 0) {\n      // When we have an even number of elements, we always choose the higher of the two medians.\n      // Thus, if the element we're removing is greaterKey than or equal to the median we need to\n      // slide the median left by one.\n      if (\n        list.relation[key] == MedianRelation.Greater || list.relation[key] == MedianRelation.Equal\n      ) {\n        action = MedianAction.Lesser;\n      }\n    } else {\n      // When we don't have an even number of elements, we just choose the median value.\n      // Thus, if the element we're removing is less than or equal to the median, we need to slide\n      // median right by one.\n      if (\n        list.relation[key] == MedianRelation.Lesser || list.relation[key] == MedianRelation.Equal\n      ) {\n        action = MedianAction.Greater;\n      }\n    }\n    updateMedian(list, action);\n\n    list.list.remove(key);\n  }\n\n  /**\n   * @notice Updates an element in the list.\n   * @param key The element key.\n   * @param value The element value.\n   * @param lesserKey The key of the element will be just left of `key` after the update.\n   * @param greaterKey The key of the element will be just right of `key` after the update.\n   * @dev Note that only one of \"lesserKey\" or \"greaterKey\" needs to be correct to reduce friction.\n   */\n  function update(\n    List storage list,\n    bytes32 key,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) public {\n    // TODO(asa): Optimize by not making any changes other than value if lesserKey and greaterKey\n    // don't change.\n    // TODO(asa): Optimize by not updating lesserKey/greaterKey for key\n    remove(list, key);\n    insert(list, key, value, lesserKey, greaterKey);\n  }\n\n  /**\n   * @notice Inserts an element at the tail of the doubly linked list.\n   * @param key The key of the element to insert.\n   */\n  function push(List storage list, bytes32 key) public {\n    insert(list, key, 0, bytes32(0), list.list.list.tail);\n  }\n\n  /**\n   * @notice Removes N elements from the head of the list and returns their keys.\n   * @param n The number of elements to pop.\n   * @return The keys of the popped elements.\n   */\n  function popN(List storage list, uint256 n) public returns (bytes32[] memory) {\n    require(n <= list.list.list.numElements, \"not enough elements\");\n    bytes32[] memory keys = new bytes32[](n);\n    for (uint256 i = 0; i < n; i++) {\n      bytes32 key = list.list.list.head;\n      keys[i] = key;\n      remove(list, key);\n    }\n    return keys;\n  }\n\n  /**\n   * @notice Returns whether or not a particular key is present in the sorted list.\n   * @param key The element key.\n   * @return Whether or not the key is in the sorted list.\n   */\n  function contains(List storage list, bytes32 key) public view returns (bool) {\n    return list.list.contains(key);\n  }\n\n  /**\n   * @notice Returns the value for a particular key in the sorted list.\n   * @param key The element key.\n   * @return The element value.\n   */\n  function getValue(List storage list, bytes32 key) public view returns (uint256) {\n    return list.list.values[key];\n  }\n\n  /**\n   * @notice Returns the median value of the sorted list.\n   * @return The median value.\n   */\n  function getMedianValue(List storage list) public view returns (uint256) {\n    return getValue(list, list.median);\n  }\n\n  /**\n   * @notice Returns the key of the first element in the list.\n   * @return The key of the first element in the list.\n   */\n  function getHead(List storage list) external view returns (bytes32) {\n    return list.list.list.head;\n  }\n\n  /**\n   * @notice Returns the key of the median element in the list.\n   * @return The key of the median element in the list.\n   */\n  function getMedian(List storage list) external view returns (bytes32) {\n    return list.median;\n  }\n\n  /**\n   * @notice Returns the key of the last element in the list.\n   * @return The key of the last element in the list.\n   */\n  function getTail(List storage list) external view returns (bytes32) {\n    return list.list.list.tail;\n  }\n\n  /**\n   * @notice Returns the number of elements in the list.\n   * @return The number of elements in the list.\n   */\n  function getNumElements(List storage list) external view returns (uint256) {\n    return list.list.list.numElements;\n  }\n\n  /**\n   * @notice Gets all elements from the doubly linked list.\n   * @return An unpacked list of elements from largest to smallest.\n   */\n  function getElements(List storage list)\n    public\n    view\n    returns (bytes32[] memory, uint256[] memory, MedianRelation[] memory)\n  {\n    bytes32[] memory keys = getKeys(list);\n    uint256[] memory values = new uint256[](keys.length);\n    MedianRelation[] memory relations = new MedianRelation[](keys.length);\n    for (uint256 i = 0; i < keys.length; i = i.add(1)) {\n      values[i] = list.list.values[keys[i]];\n      relations[i] = list.relation[keys[i]];\n    }\n    return (keys, values, relations);\n  }\n\n  /**\n   * @notice Gets all element keys from the doubly linked list.\n   * @return All element keys from head to tail.\n   */\n  function getKeys(List storage list) public view returns (bytes32[] memory) {\n    return list.list.getKeys();\n  }\n\n  /**\n   * @notice Moves the median pointer right or left of its current value.\n   * @param action Which direction to move the median pointer.\n   */\n  function updateMedian(List storage list, MedianAction action) private {\n    LinkedList.Element storage previousMedian = list.list.list.elements[list.median];\n    if (action == MedianAction.Lesser) {\n      list.relation[list.median] = MedianRelation.Greater;\n      list.median = previousMedian.previousKey;\n    } else if (action == MedianAction.Greater) {\n      list.relation[list.median] = MedianRelation.Lesser;\n      list.median = previousMedian.nextKey;\n    }\n    list.relation[list.median] = MedianRelation.Equal;\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/linkedlists/SortedLinkedListWithMedian.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./LinkedList.sol\";\nimport \"./SortedLinkedList.sol\";\n\n/**\n * @title Maintains a sorted list of unsigned ints keyed by bytes32.\n */\nlibrary SortedLinkedListWithMedian {\n  using SafeMath for uint256;\n  using SortedLinkedList for SortedLinkedList.List;\n\n  enum MedianAction { None, Lesser, Greater }\n\n  enum MedianRelation { Undefined, Lesser, Greater, Equal }\n\n  struct List {\n    SortedLinkedList.List list;\n    bytes32 median;\n    mapping(bytes32 => MedianRelation) relation;\n  }\n\n  /**\n   * @notice Inserts an element into a doubly linked list.\n   * @param key The key of the element to insert.\n   * @param value The element value.\n   * @param lesserKey The key of the element less than the element to insert.\n   * @param greaterKey The key of the element greater than the element to insert.\n   */\n  function insert(\n    List storage list,\n    bytes32 key,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) public {\n    list.list.insert(key, value, lesserKey, greaterKey);\n    LinkedList.Element storage element = list.list.list.elements[key];\n\n    MedianAction action = MedianAction.None;\n    if (list.list.list.numElements == 1) {\n      list.median = key;\n      list.relation[key] = MedianRelation.Equal;\n    } else if (list.list.list.numElements % 2 == 1) {\n      // When we have an odd number of elements, and the element that we inserted is less than\n      // the previous median, we need to slide the median down one element, since we had previously\n      // selected the greater of the two middle elements.\n      if (\n        element.previousKey == bytes32(0) ||\n        list.relation[element.previousKey] == MedianRelation.Lesser\n      ) {\n        action = MedianAction.Lesser;\n        list.relation[key] = MedianRelation.Lesser;\n      } else {\n        list.relation[key] = MedianRelation.Greater;\n      }\n    } else {\n      // When we have an even number of elements, and the element that we inserted is greater than\n      // the previous median, we need to slide the median up one element, since we always select\n      // the greater of the two middle elements.\n      if (\n        element.nextKey == bytes32(0) || list.relation[element.nextKey] == MedianRelation.Greater\n      ) {\n        action = MedianAction.Greater;\n        list.relation[key] = MedianRelation.Greater;\n      } else {\n        list.relation[key] = MedianRelation.Lesser;\n      }\n    }\n    updateMedian(list, action);\n  }\n\n  /**\n   * @notice Removes an element from the doubly linked list.\n   * @param key The key of the element to remove.\n   */\n  function remove(List storage list, bytes32 key) public {\n    MedianAction action = MedianAction.None;\n    if (list.list.list.numElements == 0) {\n      list.median = bytes32(0);\n    } else if (list.list.list.numElements % 2 == 0) {\n      // When we have an even number of elements, we always choose the higher of the two medians.\n      // Thus, if the element we're removing is greaterKey than or equal to the median we need to\n      // slide the median left by one.\n      if (\n        list.relation[key] == MedianRelation.Greater || list.relation[key] == MedianRelation.Equal\n      ) {\n        action = MedianAction.Lesser;\n      }\n    } else {\n      // When we don't have an even number of elements, we just choose the median value.\n      // Thus, if the element we're removing is less than or equal to the median, we need to slide\n      // median right by one.\n      if (\n        list.relation[key] == MedianRelation.Lesser || list.relation[key] == MedianRelation.Equal\n      ) {\n        action = MedianAction.Greater;\n      }\n    }\n    updateMedian(list, action);\n\n    list.list.remove(key);\n  }\n\n  /**\n   * @notice Updates an element in the list.\n   * @param key The element key.\n   * @param value The element value.\n   * @param lesserKey The key of the element will be just left of `key` after the update.\n   * @param greaterKey The key of the element will be just right of `key` after the update.\n   * @dev Note that only one of \"lesserKey\" or \"greaterKey\" needs to be correct to reduce friction.\n   */\n  function update(\n    List storage list,\n    bytes32 key,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) public {\n    // TODO(asa): Optimize by not making any changes other than value if lesserKey and greaterKey\n    // don't change.\n    // TODO(asa): Optimize by not updating lesserKey/greaterKey for key\n    remove(list, key);\n    insert(list, key, value, lesserKey, greaterKey);\n  }\n\n  /**\n   * @notice Inserts an element at the tail of the doubly linked list.\n   * @param key The key of the element to insert.\n   */\n  function push(List storage list, bytes32 key) public {\n    insert(list, key, 0, bytes32(0), list.list.list.tail);\n  }\n\n  /**\n   * @notice Removes N elements from the head of the list and returns their keys.\n   * @param n The number of elements to pop.\n   * @return The keys of the popped elements.\n   */\n  function popN(List storage list, uint256 n) public returns (bytes32[] memory) {\n    require(n <= list.list.list.numElements, \"not enough elements\");\n    bytes32[] memory keys = new bytes32[](n);\n    for (uint256 i = 0; i < n; i++) {\n      bytes32 key = list.list.list.head;\n      keys[i] = key;\n      remove(list, key);\n    }\n    return keys;\n  }\n\n  /**\n   * @notice Returns whether or not a particular key is present in the sorted list.\n   * @param key The element key.\n   * @return Whether or not the key is in the sorted list.\n   */\n  function contains(List storage list, bytes32 key) public view returns (bool) {\n    return list.list.contains(key);\n  }\n\n  /**\n   * @notice Returns the value for a particular key in the sorted list.\n   * @param key The element key.\n   * @return The element value.\n   */\n  function getValue(List storage list, bytes32 key) public view returns (uint256) {\n    return list.list.values[key];\n  }\n\n  /**\n   * @notice Returns the median value of the sorted list.\n   * @return The median value.\n   */\n  function getMedianValue(List storage list) public view returns (uint256) {\n    return getValue(list, list.median);\n  }\n\n  /**\n   * @notice Returns the key of the first element in the list.\n   * @return The key of the first element in the list.\n   */\n  function getHead(List storage list) external view returns (bytes32) {\n    return list.list.list.head;\n  }\n\n  /**\n   * @notice Returns the key of the median element in the list.\n   * @return The key of the median element in the list.\n   */\n  function getMedian(List storage list) external view returns (bytes32) {\n    return list.median;\n  }\n\n  /**\n   * @notice Returns the key of the last element in the list.\n   * @return The key of the last element in the list.\n   */\n  function getTail(List storage list) external view returns (bytes32) {\n    return list.list.list.tail;\n  }\n\n  /**\n   * @notice Returns the number of elements in the list.\n   * @return The number of elements in the list.\n   */\n  function getNumElements(List storage list) external view returns (uint256) {\n    return list.list.list.numElements;\n  }\n\n  /**\n   * @notice Gets all elements from the doubly linked list.\n   * @return An unpacked list of elements from largest to smallest.\n   */\n  function getElements(List storage list)\n    public\n    view\n    returns (bytes32[] memory, uint256[] memory, MedianRelation[] memory)\n  {\n    bytes32[] memory keys = getKeys(list);\n    uint256[] memory values = new uint256[](keys.length);\n    MedianRelation[] memory relations = new MedianRelation[](keys.length);\n    for (uint256 i = 0; i < keys.length; i = i.add(1)) {\n      values[i] = list.list.values[keys[i]];\n      relations[i] = list.relation[keys[i]];\n    }\n    return (keys, values, relations);\n  }\n\n  /**\n   * @notice Gets all element keys from the doubly linked list.\n   * @return All element keys from head to tail.\n   */\n  function getKeys(List storage list) public view returns (bytes32[] memory) {\n    return list.list.getKeys();\n  }\n\n  /**\n   * @notice Moves the median pointer right or left of its current value.\n   * @param action Which direction to move the median pointer.\n   */\n  function updateMedian(List storage list, MedianAction action) private {\n    LinkedList.Element storage previousMedian = list.list.list.elements[list.median];\n    if (action == MedianAction.Lesser) {\n      list.relation[list.median] = MedianRelation.Greater;\n      list.median = previousMedian.previousKey;\n    } else if (action == MedianAction.Greater) {\n      list.relation[list.median] = MedianRelation.Lesser;\n      list.median = previousMedian.nextKey;\n    }\n    list.relation[list.median] = MedianRelation.Equal;\n  }\n}"
    }
  ]
}