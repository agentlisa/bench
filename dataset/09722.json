{
  "Title": "[H-01] Strategy Migration May Leave Tokens in the Old Strategy Impacting Share Calculations",
  "Content": "_Submitted by kirk-baird_\n\nIf a strategy does not have sufficient funds to `withdraw()` for the full amount then it is possible that tokens will be left in this yield contract during `migrate()`.\n\nIt is common for withdrawal from a strategy to withdraw less than a user's balance. The reason is that these yield protocols may lend the deposited funds to borrowers, if there is less funds in the pool than the withdrawal amount the withdrawal may succeed but only transfer the funds available rather than the full withdrawal amount.\n\nThe impact of tokens remaining in the old strategy is that when we call `StrategyController.totalValue()` this will only account for the tokens deposited in the new strategy and not those stuck in the previous strategy. Therefore `totalValue()` is undervalued.\n\nThus, when a user calls `Collateral.deposit()` the share calculations `_shares = (_amountToDeposit * totalSupply()) / (_valueBefore);` will be over stated (note: `uint256 _valueBefore = _strategyController.totalValue();`). Hence, the user will receive more shares than they should.\n\nThe old tokens may be recovered by calling `migrate()` back to the old strategy. If this is done then `totalValue()` will now include the tokens previously stuck. The recent depositer may now withdraw and will be owed `(_strategyController.totalValue() * _amount) / totalSupply()`. Since `totalValue()` is now includes the previously stuck tokens  `_owed` will be overstated and the user will receive more collateral than they should.\n\nThe remaining users who had deposited before `migrate()` will lose tokens proportional to their share of the `totalSupply()`.\n\n### Proof of Concept\n\n[SingleStrategyController.sol#L51-L72](https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72)<br>\n\n        function migrate(IStrategy _newStrategy)\n            external\n            override\n            onlyOwner\n            nonReentrant\n        {\n            uint256 _oldStrategyBalance;\n            IStrategy _oldStrategy = _strategy;\n            _strategy = _newStrategy;\n            _baseToken.approve(address(_newStrategy), type(uint256).max);\n            if (address(_oldStrategy) != address(0)) {\n                _baseToken.approve(address(_oldStrategy), 0);\n                _oldStrategyBalance = _oldStrategy.totalValue();\n                _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n                _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n            }\n            emit StrategyMigrated(\n                address(_oldStrategy),\n                address(_newStrategy),\n                _oldStrategyBalance\n            );\n        }\n\n### Recommended Mitigation Steps\n\nThe recommendation is to ensure that `require(_oldStrategy.totalValue() == 0)` after calling `_oldStrategy.withdraw()`. This ensures that no funds are left in the strategy. Consider the code example below.\n\n        function migrate(IStrategy _newStrategy)\n            external\n            override\n            onlyOwner\n            nonReentrant\n        {\n            uint256 _oldStrategyBalance;\n            IStrategy _oldStrategy = _strategy;\n            _strategy = _newStrategy;\n            _baseToken.approve(address(_newStrategy), type(uint256).max);\n            if (address(_oldStrategy) != address(0)) {\n                _baseToken.approve(address(_oldStrategy), 0);\n                _oldStrategyBalance = _oldStrategy.totalValue();\n                _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n                require(_oldStrategy.totalValue() == 0)\n                _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n            }\n            emit StrategyMigrated(\n                address(_oldStrategy),\n                address(_newStrategy),\n                _oldStrategyBalance\n            );\n        }\n\n**[ramenforbreakfast (prePO) confirmed and commented](https://github.com/code-423n4/2022-03-prepo-findings/issues/26#issuecomment-1075728097):**\n > This is a valid claim, although it is an edge case. I will maintain the severity of this issue as is. Should consider removing a fixed migration procedure altogether as this issue demonstrates one of the many problems that can occur.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-prepo-findings/issues/26#issuecomment-1086869784):**\n > Agree with sponsor.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-03-prepo-contest",
  "Code": [
    {
      "filename": "contracts/core/SingleStrategyController.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SingleStrategyController is\n    IStrategyController,\n    Ownable,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    address private _vault;\n    IStrategy private _strategy;\n    IERC20 private immutable _baseToken;\n\n    modifier onlyVault() {\n        require(msg.sender == _vault, \"Caller is not the vault\");\n        _;\n    }\n\n    constructor(IERC20 _token) {\n        require(address(_token) != address(0), \"Zero address\");\n        _baseToken = _token;\n    }\n\n    // Assumes approval to take `_amount` has already been given by vault\n    function deposit(uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _baseToken.safeTransferFrom(_vault, address(this), _amount);\n        _strategy.deposit(_baseToken.balanceOf(address(this)));\n    }\n\n    function withdraw(address _recipient, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _strategy.withdraw(_recipient, _amount);\n    }\n\n    function migrate(IStrategy _newStrategy)\n        external\n        override\n        onlyOwner\n        nonReentrant\n    {\n        uint256 _oldStrategyBalance;\n        IStrategy _oldStrategy = _strategy;\n        _strategy = _newStrategy;\n        _baseToken.approve(address(_newStrategy), type(uint256).max);\n        if (address(_oldStrategy) != address(0)) {\n            _baseToken.approve(address(_oldStrategy), 0);\n            _oldStrategyBalance = _oldStrategy.totalValue();\n            _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n            _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n        }\n        emit StrategyMigrated(\n            address(_oldStrategy),\n            address(_newStrategy),\n            _oldStrategyBalance\n        );\n    }\n\n    function setVault(address _newVault) external override onlyOwner {\n        _vault = _newVault;\n        emit VaultChanged(_newVault);\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return _baseToken.balanceOf(address(this)) + _strategy.totalValue();\n    }\n\n    function getVault() external view override returns (address) {\n        return _vault;\n    }\n\n    function getStrategy() external view override returns (IStrategy) {\n        return _strategy;\n    }\n\n    function getBaseToken() external view override returns (IERC20) {\n        return _baseToken;\n    }\n}"
    }
  ]
}