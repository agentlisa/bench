{
  "Title": "Signed Messages Can Be Replayed",
  "Content": "In both the [`verifyProof`](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/AllocationIDTracker.sol#L82-L84) and [`verifyAuthorizedSignerProof`](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/Escrow.sol#L442-L443) functions, the `messageHash` does not include the `chainId`. Since the project will be deployed on both Ethereum and Arbitrum networks, the same signed message intended for one chain can be replayed on the other chain.\n\n\nConsider adding the `chainId`, as well as the nonce or deadline to the message's content when generating proofs to ensure that signed messages are only used on the intended blockchain, and not replayable multiple times.\n\n\n***Update:** Resolved in [pull request #56](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/pull/56). The Graph's core developersÂ stated:*\n\n\n\n> *Thank you for highlighting this issue. After several discussions, we fixed this by adding a `chainID` to the `allocationID` proof (a deadline is not needed since a used `allocationID` cannot be unset). The authorized signer proof needs a `chainID` and a deadline because signers can be revoked, which could enable a possible replay attack. The associated issue can be found [here](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/issues/33).*\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/AllocationIDTracker.sol",
      "content": "// Copyright 2023-, Semiotic AI, Inc.\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title AllocationIDTracker\n * @dev This contract tracks the allocation IDs of the RAVs that have been submitted to\n *      ensure that each allocation ID is only used once. It is external to escrow\n *      contract to allow for updating the escrow contract without losing the list of\n *      used allocation IDs.\n * @notice This contract is intended to be used with the `Escrow` contract.\n */\ncontract AllocationIDTracker {\n    // senders used allocation IDs\n    mapping(address sender => mapping(address allocationId => bool isUsed))\n        private _sendersUsedAllocationIDs;\n\n    // Custom error to indicate the provided allocation ID was previously claimed and no longer valid\n    error AllocationIDPreviouslyClaimed(address sender, address allocationID);\n\n    // Custom error to indicate the provided proof is not valid\n    error InvalidProof();\n\n    /**\n     * @dev Emitted when an allocation ID is used.\n     */\n    event AllocationIDUsed(\n        address indexed sender,\n        address indexed allocationID\n    );\n\n    /**\n     * @dev Checks if an allocation ID has been used.\n     * @param allocationID The allocation ID to check.\n     * @return True if the allocation ID has been used, false otherwise.\n     */\n    function isAllocationIDUsed(\n        address sender,\n        address allocationID\n    ) external view returns (bool) {\n        return _sendersUsedAllocationIDs[sender][allocationID];\n    }\n\n    /**\n     * @dev Marks an allocation ID as used.\n     * @param sender The sender of the token to receiver.\n     * @param allocationID The allocation ID to mark as used.\n     * @param proof ECDSA Proof signed by the receiver's allocationID consisting of packed (sender address, allocationID, collateral contract address).\n     * @notice REVERT with error:\n     *               - AllocationIDPreviouslyClaimed: If the (sender, allocationID) pair was previously claimed\n     *               - InvalidProof: If the proof is not valid\n     */\n    function useAllocationID(\n        address sender,\n        address allocationID,\n        bytes calldata proof\n    ) external {\n        if (_sendersUsedAllocationIDs[sender][allocationID] == true) {\n            revert AllocationIDPreviouslyClaimed(sender, allocationID);\n        }\n        verifyProof(proof, sender, allocationID);\n\n        _sendersUsedAllocationIDs[sender][allocationID] = true;\n        emit AllocationIDUsed(sender, allocationID);\n    }\n\n    /**\n     * @dev Verifies a proof.\n     * @param proof ECDSA Proof signed by the receiver's allocationID consisting of packed (sender address, allocationID, collateral contract address).\n     * @param sender The sender of the token to receiver.\n     * @param allocationID The allocation ID to verify.\n     * @notice REVERT with error:\n     *               - InvalidProof: If the proof is not valid\n     */\n    function verifyProof(\n        bytes calldata proof,\n        address sender,\n        address allocationID\n    ) private view {\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(sender, allocationID, msg.sender)\n        );\n        bytes32 digest = ECDSA.toEthSignedMessageHash(messageHash);\n        if (ECDSA.recover(digest, proof) != allocationID) {\n            revert InvalidProof();\n        }\n    }\n}"
    }
  ]
}