{
  "Title": "M-2: Oracle tick rounding the wrong direction can lead to Swapper overpaying for swap",
  "Content": "# Issue M-2: Oracle tick rounding the wrong direction can lead to Swapper overpaying for swap \n\nSource: https://github.com/sherlock-audit/2023-04-splits-judging/issues/12 \n\n## Found by \nobront\n\n## Summary\n\nThe UniV3Oracle is intended to be used in situations where asset values can be understated, but must not be overstated. As a result, all results are rounded down to the nearest tick.\n\nHowever, in the case of the Swapper, we need the opposite. The Swapper's owner has specified the specific discount which they are willing to provide, and the caller is the user calling `flash()` to perform the swap. In this case, rounding must happen against the caller, not against the owner, to ensure the owner's criteria are being met.\n\nBecause the Oracle rounds down to the nearest tick (not the nearest decimal price), the difference can be quite dramatic, and can lead to substantial loss of funds for the Swapper owner.\n\n## Vulnerability Detail\n\nWhen the UniV3Oracle calls `OracleLibrary.consult()`, it returns the `arithmeticMeanTick`.\n\nThis value is rounded DOWN to the nearest tick. This is because, in most use cases, the price being returned by an oracle is used to determine the value of an asset to be used for something like valuing collateral,  where the caller is the one whose collateral is on the line, and it is crucial to ensure that user assets are not overvalued so as to give them an edge.\n\nHowever, in this case, the oracle is being used to determine the amount owed from the bot performing the swap (from here on \"the bot\") to the Swap owner (from here on \"the owner\"). The owner has already included a firm parameter (the scaled offer value) for the discount they are willing to provide. The bot is the caller, who is taking the action within the confines of this predetermined parameter. In this case, the value should be rounded UP to ensure this scaled offer value is protected.\n\n(As an extra data point in reasoning about this, Uniswap rounds values UP when users are buying assets through the platform. In other words, the oracle returns a slightly different price than the actual marginal price that would be received if the bot were buying their assets through the same pool.)\n\nUnfortunately, Uniswap oracle rounding can be quite severe. According to Uniswap's pricing formula, ticks represent 1 basis point (0.01%) of the price. This is true regardless of the price of the asset, the quantity being swapped, or (most importantly) the decimals in the asset.\n\nWhile in most cases, this may not seem like much, it is likely that Swappers receiving large amounts of funds will only need to offer very slim discounts to incentivize bots. As explained to me by the 0xSplits team in a DM, the slimness of this margin could get so extreme that users may even set a PREMIUM for swaps, because of the risk that the trailing 30 minutes could provide a slight discount.\n\n## Proof of Concept\n\nLet's look at an example of an LLC using a Swapper to move all their income into USDC:\n- They company earns $10mm per year on chain, which is all sent to the Swapper\n- They aren't concerned about frequency of swaps, so they do the math:  setting their `$defaultScaledOfferFactor` to 99_99_90  should work out to paying approximately $100 for the year, which seems fair. \n- When the assets are swapped, rounding comes into play. Instead of `FAIR_VALUE`, their assets are valued at `FAIR_VALUE - 0.5 basis points`, which equals `FAIR_VALUE * 0.995`. For their $10mm, that's `9,950,000`.\n- Finally, their scaled offer factor discounts the price further, down to `9_950_000 * 99_99_90 / 1e6 = 9,949,900.50`.\n\nThe result is that they end up paying $50,099.50 for their swaps, instead of $100.\n\n(Note that this same math holds whether the swaps were done all at once or in multiple separate transactions.)\n\n## Impact\n\nBecause rounding is performed in the wrong direction, Swap owners who set their `$defaultScaledOfferFactor` with a small margin may end up paying substantially more than expected for their swaps.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-splits/blob/main/splits-oracle/src/UniV3OracleImpl.sol#L274-L282\n\nSpecifically, see L35-36 of this Uniswap contract:\n\nhttps://github.com/Uniswap/v3-periphery/blob/6cce88e63e176af1ddb6cc56e029110289622317/contracts/libraries/OracleLibrary.sol#L16-L41\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement your own version of the OracleLibrary's `consult()` function, which doesn't round the `arithmeticMeanTick` down.\n\n\n\n## Discussion\n\n**zobront**\n\nFixed in https://github.com/0xSplits/splits-oracle/pull/1/ by adding 1 to the tick returned from `OracleLibrary.consult()`\n\n**jacksanford1**\n\nConfirming that Splits meant for this fix (1) to be linked to this issue (12):\nhttps://github.com/0xSplits/splits-oracle/pull/1#issue-1693202318\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/65",
  "Code": [
    {
      "filename": "splits-oracle/src/UniV3OracleImpl.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {IUniswapV3Factory} from \"v3-core/interfaces/IUniswapV3Factory.sol\";\nimport {OracleLibrary} from \"v3-periphery/libraries/OracleLibrary.sol\";\nimport {TokenUtils} from \"splits-utils/TokenUtils.sol\";\n\nimport {OracleImpl} from \"./OracleImpl.sol\";\nimport {QuotePair, ConvertedQuotePair, SortedConvertedQuotePair} from \"./utils/QuotePair.sol\";\n\n/// @title UniV3 Oracle Implementation\n/// @author 0xSplits\n/// @notice A clone-implementation of an oracle using UniswapV3 TWAP\ncontract UniV3OracleImpl is OracleImpl {\n    /// -----------------------------------------------------------------------\n    /// libraries\n    /// -----------------------------------------------------------------------\n\n    using TokenUtils for address;\n\n    /// -----------------------------------------------------------------------\n    /// errors\n    /// -----------------------------------------------------------------------\n\n    error Pool_DoesNotExist();\n\n    /// -----------------------------------------------------------------------\n    /// structs\n    /// -----------------------------------------------------------------------\n\n    struct InitParams {\n        address owner;\n        bool paused;\n        uint24 defaultFee;\n        uint32 defaultPeriod;\n        uint32 defaultScaledOfferFactor;\n        SetPairOverrideParams[] pairOverrides;\n    }\n\n    struct SetPairOverrideParams {\n        QuotePair quotePair;\n        PairOverride pairOverride;\n    }\n\n    struct PairOverride {\n        uint24 fee;\n        uint32 period;\n        uint32 scaledOfferFactor;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// events\n    /// -----------------------------------------------------------------------\n\n    event SetDefaultFee(uint24 defaultFee);\n    event SetDefaultPeriod(uint32 defaultPeriod);\n    event SetDefaultScaledOfferFactor(uint32 defaultScaledOfferFactor);\n    event SetPairOverrides(SetPairOverrideParams[] params);\n\n    /// -----------------------------------------------------------------------\n    /// storage\n    /// -----------------------------------------------------------------------\n\n    /// -----------------------------------------------------------------------\n    /// storage - constants & immutables\n    /// -----------------------------------------------------------------------\n\n    /// @dev percentages measured in hundredths of basis points\n    uint32 internal constant PERCENTAGE_SCALE = 100_00_00; // = 100%\n\n    address public immutable uniV3OracleFactory;\n    IUniswapV3Factory public immutable uniswapV3Factory;\n    address public immutable weth9;\n\n    /// -----------------------------------------------------------------------\n    /// storage - mutables\n    /// -----------------------------------------------------------------------\n\n    /// slot 0 - 0 byte free\n\n    /// OwnableImpl storage\n    /// address internal $owner;\n    /// 20 bytes\n\n    /// PausableImpl storage\n    /// bool internal $paused;\n    /// 1 byte\n\n    /// default uniswap pool fee\n    /// @dev PERCENTAGE_SCALE = 1e6 = 100_00_00 = 100%;\n    /// fee = 30_00 = 0.3% is the uniswap default\n    /// unless overriden, getQuoteAmounts will revert if a non-permitted pool fee is used\n    /// 3 bytes\n    uint24 internal $defaultFee;\n\n    /// default twap period\n    /// @dev unless overriden, getQuoteAmounts will revert if zero\n    /// 4 bytes\n    uint32 internal $defaultPeriod;\n\n    /// default price scaling factor\n    /// @dev PERCENTAGE_SCALE = 1e6 = 100_00_00 = 100% = no discount or premium\n    /// 99_00_00 = 99% = 1% discount to oracle; 101_00_00 = 101% = 1% premium to oracle\n    /// 4 bytes\n    uint32 internal $defaultScaledOfferFactor;\n\n    /// slot 1 - 0 bytes free\n\n    /// overrides for specific quote pairs\n    /// 32 bytes\n    mapping(address => mapping(address => PairOverride)) internal $_pairOverrides;\n\n    /// -----------------------------------------------------------------------\n    /// constructor & initializer\n    /// -----------------------------------------------------------------------\n\n    constructor(IUniswapV3Factory uniswapV3Factory_, address weth9_) {\n        uniV3OracleFactory = msg.sender;\n        uniswapV3Factory = uniswapV3Factory_;\n        weth9 = weth9_;\n    }\n\n    function initializer(InitParams calldata params_) external {\n        // only uniV3OracleFactory may call `initializer`\n        if (msg.sender != uniV3OracleFactory) revert Unauthorized();\n\n        __initOwnable(params_.owner);\n        $paused = params_.paused;\n        $defaultFee = params_.defaultFee;\n        $defaultPeriod = params_.defaultPeriod;\n        $defaultScaledOfferFactor = params_.defaultScaledOfferFactor;\n\n        _setPairOverrides(params_.pairOverrides);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions\n    /// -----------------------------------------------------------------------\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external\n    /// -----------------------------------------------------------------------\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - onlyOwner\n    /// -----------------------------------------------------------------------\n\n    /// set defaultFee\n    function setDefaultFee(uint24 defaultFee_) external onlyOwner {\n        $defaultFee = defaultFee_;\n        emit SetDefaultFee(defaultFee_);\n    }\n\n    /// set defaultPeriod\n    function setDefaultPeriod(uint32 defaultPeriod_) external onlyOwner {\n        $defaultPeriod = defaultPeriod_;\n        emit SetDefaultPeriod(defaultPeriod_);\n    }\n\n    /// set defaultScaledOfferFactor\n    function setDefaultScaledOfferFactor(uint32 defaultScaledOfferFactor_) external onlyOwner {\n        $defaultScaledOfferFactor = defaultScaledOfferFactor_;\n        emit SetDefaultScaledOfferFactor(defaultScaledOfferFactor_);\n    }\n\n    /// set pair overrides\n    function setPairOverrides(SetPairOverrideParams[] calldata params_) external onlyOwner {\n        _setPairOverrides(params_);\n        emit SetPairOverrides(params_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - view\n    /// -----------------------------------------------------------------------\n\n    function defaultFee() external view returns (uint24) {\n        return $defaultFee;\n    }\n\n    function defaultPeriod() external view returns (uint32) {\n        return $defaultPeriod;\n    }\n\n    function defaultScaledOfferFactor() external view returns (uint32) {\n        return $defaultScaledOfferFactor;\n    }\n\n    /// get pair override for an array of quote pairs\n    function getPairOverrides(QuotePair[] calldata quotePairs_)\n        external\n        view\n        returns (PairOverride[] memory pairOverrides)\n    {\n        uint256 length = quotePairs_.length;\n        pairOverrides = new PairOverride[](length);\n        for (uint256 i; i < length;) {\n            pairOverrides[i] = _getPairOverride(quotePairs_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// get amounts for an array of quotes\n    function getQuoteAmounts(QuoteParams[] calldata quoteParams_)\n        external\n        view\n        override\n        pausable\n        returns (uint256[] memory quoteAmounts)\n    {\n        uint256 length = quoteParams_.length;\n        quoteAmounts = new uint256[](length);\n        for (uint256 i; i < length;) {\n            quoteAmounts[i] = _getQuoteAmount(quoteParams_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - private & internal\n    /// -----------------------------------------------------------------------\n\n    /// set pair overrides\n    function _setPairOverrides(SetPairOverrideParams[] calldata params_) internal {\n        uint256 length = params_.length;\n        for (uint256 i; i < length;) {\n            _setPairOverride(params_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// set pair override\n    function _setPairOverride(SetPairOverrideParams calldata params_) internal {\n        SortedConvertedQuotePair memory scqp = _convertAndSortQuotePair(params_.quotePair);\n        $_pairOverrides[scqp.cToken0][scqp.cToken1] = params_.pairOverride;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - private & internal - views\n    /// -----------------------------------------------------------------------\n\n    /// get quote amount for a trade\n    function _getQuoteAmount(QuoteParams calldata quoteParams_) internal view returns (uint256) {\n        ConvertedQuotePair memory cqp = quoteParams_.quotePair._convert(_convertToken);\n        SortedConvertedQuotePair memory scqp = cqp._sort();\n\n        PairOverride memory po = _getPairOverride(scqp);\n        if (po.scaledOfferFactor == 0) {\n            po.scaledOfferFactor = $defaultScaledOfferFactor;\n        }\n\n        // skip oracle if converted tokens are equal\n        if (cqp.cBase == cqp.cQuote) {\n            return quoteParams_.baseAmount * po.scaledOfferFactor / PERCENTAGE_SCALE;\n        }\n\n        if (po.fee == 0) {\n            po.fee = $defaultFee;\n        }\n        if (po.period == 0) {\n            po.period = $defaultPeriod;\n        }\n\n        address pool = uniswapV3Factory.getPool(scqp.cToken0, scqp.cToken1, po.fee);\n        if (pool == address(0)) {\n            revert Pool_DoesNotExist();\n        }\n\n        // reverts if period is zero or > oldest observation\n        (int24 arithmeticMeanTick,) = OracleLibrary.consult({pool: pool, secondsAgo: po.period});\n\n        uint256 unscaledAmountToBeneficiary = OracleLibrary.getQuoteAtTick({\n            tick: arithmeticMeanTick,\n            baseAmount: quoteParams_.baseAmount,\n            baseToken: cqp.cBase,\n            quoteToken: cqp.cQuote\n        });\n\n        return unscaledAmountToBeneficiary * po.scaledOfferFactor / PERCENTAGE_SCALE;\n    }\n\n    /// get pair override\n    function _getPairOverride(QuotePair calldata quotePair_) internal view returns (PairOverride memory) {\n        return _getPairOverride(_convertAndSortQuotePair(quotePair_));\n    }\n\n    /// get pair overrides\n    function _getPairOverride(SortedConvertedQuotePair memory scqp_) internal view returns (PairOverride memory) {\n        return $_pairOverrides[scqp_.cToken0][scqp_.cToken1];\n    }\n\n    /// convert & sort tokens into canonical order\n    function _convertAndSortQuotePair(QuotePair calldata quotePair_)\n        internal\n        view\n        returns (SortedConvertedQuotePair memory)\n    {\n        return quotePair_._convert(_convertToken)._sort();\n    }\n\n    /// convert eth (0x0) to weth\n    function _convertToken(address token_) internal view returns (address) {\n        return token_._isETH() ? weth9 : token_;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/OracleLibrary.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n        internal\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) =\n            IUniswapV3Pool(pool).observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta =\n            secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) =\n            IUniswapV3Pool(pool).observations((observationIndex + 1) % observationCardinality);\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        secondsAgo = uint32(block.timestamp) - observationTimestamp;\n    }\n\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\n    /// @param pool Address of Uniswap V3 pool\n    /// @return The tick that the pool was in at the start of the current block\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n        // 2 observations are needed to reliably calculate the block starting tick\n        require(observationCardinality > 1, 'NEO');\n\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\n        // We don't need to check if this observation is initialized - it is guaranteed to be.\n        (uint32 observationTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, ) =\n            IUniswapV3Pool(pool).observations(observationIndex);\n        if (observationTimestamp != uint32(block.timestamp)) {\n            return (tick, IUniswapV3Pool(pool).liquidity());\n        }\n\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n        (\n            uint32 prevObservationTimestamp,\n            int56 prevTickCumulative,\n            uint160 prevSecondsPerLiquidityCumulativeX128,\n            bool prevInitialized\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\n\n        require(prevInitialized, 'ONI');\n\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\n        tick = int24((tickCumulative - prevTickCumulative) / delta);\n        uint128 liquidity =\n            uint128(\n                (uint192(delta) * type(uint160).max) /\n                    (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n            );\n        return (tick, liquidity);\n    }\n\n    /// @notice Information for calculating a weighted arithmetic mean tick\n    struct WeightedTickData {\n        int24 tick;\n        uint128 weight;\n    }\n\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n    /// @param weightedTickData An array of ticks and weights\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\n        internal\n        pure\n        returns (int24 weightedArithmeticMeanTick)\n    {\n        // Accumulates the sum of products between each tick and its weight\n        int256 numerator;\n\n        // Accumulates the sum of the weights\n        uint256 denominator;\n\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n        for (uint256 i; i < weightedTickData.length; i++) {\n            numerator += weightedTickData[i].tick * int256(weightedTickData[i].weight);\n            denominator += weightedTickData[i].weight;\n        }\n\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n    }\n\n    /// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n    /// @dev Useful for calculating relative prices along routes.\n    /// @dev There must be one tick for each pairwise set of tokens.\n    /// @param tokens The token contract addresses\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\n        internal\n        pure\n        returns (int256 syntheticTick)\n    {\n        require(tokens.length - 1 == ticks.length, 'DL');\n        for (uint256 i = 1; i <= ticks.length; i++) {\n            // check the tokens for address sort order, then accumulate the\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n            tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n        }\n    }\n}"
    }
  ]
}