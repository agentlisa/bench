{
  "Title": "[C02] ETH can get stuck in the GenesisGroup contract",
  "Content": "The `GenesisGroup` contract allows users to contribute ETH by using the [`purchase` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L80), which mints them `FGEN` tokens to record the size of their deposit. When enough ETH has been contributed to reach the [`maxGenesisPrice`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L37), or the genesis period has ended, the [`launch` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L105) can be called to transfer all the ETH collected to [`PCVDeposit` contracts](https://github.com/fei-protocol/fei-protocol-core/tree/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv), and launch the rest of the protocol. After `launch` has completed, users can call the [`redeem` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L89) to cash in their `FGEN` tokens for their share of `FEI` and `TRIBE` tokens.\n\n\nHowever, if the `launch` function gets called due to the `maxGenesisPrice` being reached, the contract does not prevent `purchase` from being called by users. This would likely happen when users race to contribute to the genesis before launch. This has the following negative consequences:\n\n\n* The ETH deposited by users will become locked in the `GenesisGroup` contract. This is due to the fact that `launch` is the only function that can transfer ETH out of the `GenesisGroup`, and it cannot be called a second time â€“ enforced by [`completeGenesisGroup` reverting](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/core/Core.sol#L49) if someone tries to call `launch` a second time.\n* The additional calls to `purchase` continue to mint `FGEN` to the callers. This increases the `totalSupply` of `FGEN`, and skews the calculation in [`_fgenRatio`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L157), meaning that valid contributors to the `GenesisGroup` will not receive their rightful allocation of `TRIBE` and `FEI`.\n\n\nConsider adding a condition to the [`purchase` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L80) that prevents it from being called if [`hasGenesisGroupCompleted`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/core/Core.sol#L19) is `true`.\n\n\n**Update:** *Fixed in [PR#24](https://github.com/fei-protocol/fei-protocol-core/pull/24). The Fei Team decided to remove the `isAtMaxPrice` condition that allowed the protocol to be launched before the genesis period passed. Additionally, a condition was added to check whether the genesis was launched when calling the `purchase` function.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/genesis/GenesisGroup.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IGenesisGroup.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../pool/IPool.sol\";\nimport \"../oracle/IBondingCurveOracle.sol\";\nimport \"../bondingcurve/IBondingCurve.sol\";\n\ninterface IOrchestrator {\n\tfunction launchGovernance() external;\n\tfunction pool() external returns(address);\n\tfunction bondingCurveOracle() external returns(address);\n}\n\n/// @title IGenesisGroup implementation\n/// @author Fei Protocol\ncontract GenesisGroup is IGenesisGroup, CoreRef, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOrchestrator private orchestrator;\n\n\tIBondingCurve private bondingcurve;\n\n\tIBondingCurveOracle private bondingCurveOracle;\n\n\tIPool private pool;\n\n\tIDOInterface private ido;\n\tuint private exchangeRateDiscount;\n\n\t/// @notice a cap on the genesis group purchase price\n\tDecimal.D256 public maxGenesisPrice;\n\n\t/// @notice GenesisGroup constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _bondingcurve Bonding curve address for purchase\n\t/// @param _ido IDO contract to deploy\n\t/// @param _oracle Bonding curve oracle\n\t/// @param _pool Staking Pool\n\t/// @param _duration duration of the Genesis Period\n\t/// @param _maxPriceBPs max price of FEI allowed in Genesis Group in dollar terms\n\t/// @param _exchangeRateDiscount a divisor on the FEI/TRIBE ratio at Genesis to deploy to the IDO\n\tconstructor(\n\t\taddress _core, \n\t\taddress _bondingcurve,\n\t\taddress _ido,\n\t\taddress _oracle,\n\t\taddress _pool,\n\t\tuint32 _duration,\n\t\tuint _maxPriceBPs,\n\t\tuint _exchangeRateDiscount\n\t) public\n\t\tCoreRef(_core)\n\t\tERC20(\"Fei Genesis Group\", \"FGEN\")\n\t\tTimed(_duration)\n\t{\n\t\tbondingcurve = IBondingCurve(_bondingcurve);\n\n\t\texchangeRateDiscount = _exchangeRateDiscount;\n\t\tido = IDOInterface(_ido);\n\n\t\tpool = IPool(_pool);\n\t\tbondingCurveOracle = IBondingCurveOracle(_oracle);\n\n\t\t_initTimed();\n\n\t\tmaxGenesisPrice = Decimal.ratio(_maxPriceBPs, 10000);\n\t}\n\n\tmodifier onlyGenesisPeriod() {\n\t\trequire(!isTimeEnded(), \"GenesisGroup: Not in Genesis Period\");\n\t\t_;\n\t}\n\n\tfunction purchase(address to, uint value) external override payable onlyGenesisPeriod {\n\t\trequire(msg.value == value, \"GenesisGroup: value mismatch\");\n\t\trequire(value != 0, \"GenesisGroup: no value sent\");\n\n\t\t_mint(to, value);\n\n\t\temit Purchase(to, value);\n\t}\n\n\tfunction redeem(address to) external override postGenesis {\n\t\tDecimal.D256 memory ratio = _fgenRatio(to);\n\t\trequire(!ratio.equals(Decimal.zero()), \"GensisGroup: No balance to redeem\");\n\n\t\tuint amountIn = balanceOf(to);\n\t\tburnFrom(to, amountIn);\n\n\t\tuint feiAmount = ratio.mul(feiBalance()).asUint256();\n\t\tfei().transfer(to, feiAmount);\n\n\t\tuint tribeAmount = ratio.mul(tribeBalance()).asUint256();\n\t\ttribe().transfer(to, tribeAmount);\n\n\t\temit Redeem(to, amountIn, feiAmount, tribeAmount);\n\t}\n\n\tfunction launch() external override {\n\t\trequire(isTimeEnded() || isAtMaxPrice(), \"GenesisGroup: Still in Genesis Period\");\n\n\t\tcore().completeGenesisGroup();\n\n\t\taddress genesisGroup = address(this);\n\t\tuint balance = genesisGroup.balance;\n\n\t\tbondingCurveOracle.init(bondingcurve.getAveragePrice(balance));\n\n\t\tbondingcurve.purchase{value: balance}(genesisGroup, balance);\n\t\tbondingcurve.allocate();\n\n\t\tpool.init();\n\n\t\tido.deploy(_feiTribeExchangeRate());\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit Launch(now);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn, \n\t\tbool inclusive\n\t) public view override returns (uint feiAmount, uint tribeAmount) {\n\t\tuint totalIn = totalSupply();\n\t\tif (!inclusive) {\n\t\t\ttotalIn += amountIn;\n\t\t}\n\t\trequire(amountIn <= totalIn, \"GenesisGroup: Not enough supply\");\n\n\t\tuint totalFei = bondingcurve.getAmountOut(totalIn);\n\t\tuint totalTribe = tribeBalance();\n\n\t\treturn (totalFei * amountIn / totalIn, totalTribe * amountIn / totalIn);\n\t}\n\n\tfunction isAtMaxPrice() public view override returns(bool) {\n\t\tuint balance = address(this).balance;\n\t\trequire(balance != 0, \"GenesisGroup: No balance\");\n\n\t\treturn bondingcurve.getAveragePrice(balance).greaterThanOrEqualTo(maxGenesisPrice);\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\t// Sender doesn't need approval\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _fgenRatio(address account) internal view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(balanceOf(account), totalSupply());\n\t}\n\n\tfunction _feiTribeExchangeRate() public view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(feiBalance(), tribeBalance()).div(exchangeRateDiscount);\n\t}\n}"
    },
    {
      "filename": "contracts/core/Core.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./Permissions.sol\";\nimport \"./ICore.sol\";\nimport \"../token/IFei.sol\";\nimport \"../token/Fei.sol\";\nimport \"../dao/Tribe.sol\";\n\n/// @title ICore implementation\n/// @author Fei Protocol\ncontract Core is ICore, Permissions {\n\n\tIFei public override fei;\n\tIERC20 public override tribe;\n\n\taddress public override genesisGroup;\n\tbool public override hasGenesisGroupCompleted;\n\n\tconstructor() public {\n\t\t_setupGovernor(msg.sender);\n\t\tFei _fei = new Fei(address(this));\n\t\tfei = IFei(address(_fei));\n\n\t\tTribe _tribe = new Tribe(address(this), msg.sender);\n\t\ttribe = IERC20(address(_tribe));\n\t}\n\n\tfunction setFei(address token) external override onlyGovernor {\n\t\tfei = IFei(token);\n\t\temit FeiUpdate(token);\n\t}\n\n\tfunction setGenesisGroup(address _genesisGroup) external override onlyGovernor {\n\t\tgenesisGroup = _genesisGroup;\n\t}\n\n\tfunction allocateTribe(address to, uint amount) external override onlyGovernor {\n\t\tIERC20 _tribe = tribe;\n\t\trequire(_tribe.balanceOf(address(this)) > amount, \"Core: Not enough Tribe\");\n\n\t\t_tribe.transfer(to, amount);\n\n\t\temit TribeAllocation(to, amount);\n\t}\n\n\tfunction completeGenesisGroup() external override {\n\t\trequire(!hasGenesisGroupCompleted, \"Core: Genesis Group already complete\");\n\t\trequire(msg.sender == genesisGroup, \"Core: Caller is not Genesis Group\");\n\n\t\thasGenesisGroupCompleted = true;\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit GenesisPeriodComplete(now);\n\t}\n}"
    },
    {
      "filename": "contracts/genesis/GenesisGroup.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IGenesisGroup.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../pool/IPool.sol\";\nimport \"../oracle/IBondingCurveOracle.sol\";\nimport \"../bondingcurve/IBondingCurve.sol\";\n\ninterface IOrchestrator {\n\tfunction launchGovernance() external;\n\tfunction pool() external returns(address);\n\tfunction bondingCurveOracle() external returns(address);\n}\n\n/// @title IGenesisGroup implementation\n/// @author Fei Protocol\ncontract GenesisGroup is IGenesisGroup, CoreRef, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOrchestrator private orchestrator;\n\n\tIBondingCurve private bondingcurve;\n\n\tIBondingCurveOracle private bondingCurveOracle;\n\n\tIPool private pool;\n\n\tIDOInterface private ido;\n\tuint private exchangeRateDiscount;\n\n\t/// @notice a cap on the genesis group purchase price\n\tDecimal.D256 public maxGenesisPrice;\n\n\t/// @notice GenesisGroup constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _bondingcurve Bonding curve address for purchase\n\t/// @param _ido IDO contract to deploy\n\t/// @param _oracle Bonding curve oracle\n\t/// @param _pool Staking Pool\n\t/// @param _duration duration of the Genesis Period\n\t/// @param _maxPriceBPs max price of FEI allowed in Genesis Group in dollar terms\n\t/// @param _exchangeRateDiscount a divisor on the FEI/TRIBE ratio at Genesis to deploy to the IDO\n\tconstructor(\n\t\taddress _core, \n\t\taddress _bondingcurve,\n\t\taddress _ido,\n\t\taddress _oracle,\n\t\taddress _pool,\n\t\tuint32 _duration,\n\t\tuint _maxPriceBPs,\n\t\tuint _exchangeRateDiscount\n\t) public\n\t\tCoreRef(_core)\n\t\tERC20(\"Fei Genesis Group\", \"FGEN\")\n\t\tTimed(_duration)\n\t{\n\t\tbondingcurve = IBondingCurve(_bondingcurve);\n\n\t\texchangeRateDiscount = _exchangeRateDiscount;\n\t\tido = IDOInterface(_ido);\n\n\t\tpool = IPool(_pool);\n\t\tbondingCurveOracle = IBondingCurveOracle(_oracle);\n\n\t\t_initTimed();\n\n\t\tmaxGenesisPrice = Decimal.ratio(_maxPriceBPs, 10000);\n\t}\n\n\tmodifier onlyGenesisPeriod() {\n\t\trequire(!isTimeEnded(), \"GenesisGroup: Not in Genesis Period\");\n\t\t_;\n\t}\n\n\tfunction purchase(address to, uint value) external override payable onlyGenesisPeriod {\n\t\trequire(msg.value == value, \"GenesisGroup: value mismatch\");\n\t\trequire(value != 0, \"GenesisGroup: no value sent\");\n\n\t\t_mint(to, value);\n\n\t\temit Purchase(to, value);\n\t}\n\n\tfunction redeem(address to) external override postGenesis {\n\t\tDecimal.D256 memory ratio = _fgenRatio(to);\n\t\trequire(!ratio.equals(Decimal.zero()), \"GensisGroup: No balance to redeem\");\n\n\t\tuint amountIn = balanceOf(to);\n\t\tburnFrom(to, amountIn);\n\n\t\tuint feiAmount = ratio.mul(feiBalance()).asUint256();\n\t\tfei().transfer(to, feiAmount);\n\n\t\tuint tribeAmount = ratio.mul(tribeBalance()).asUint256();\n\t\ttribe().transfer(to, tribeAmount);\n\n\t\temit Redeem(to, amountIn, feiAmount, tribeAmount);\n\t}\n\n\tfunction launch() external override {\n\t\trequire(isTimeEnded() || isAtMaxPrice(), \"GenesisGroup: Still in Genesis Period\");\n\n\t\tcore().completeGenesisGroup();\n\n\t\taddress genesisGroup = address(this);\n\t\tuint balance = genesisGroup.balance;\n\n\t\tbondingCurveOracle.init(bondingcurve.getAveragePrice(balance));\n\n\t\tbondingcurve.purchase{value: balance}(genesisGroup, balance);\n\t\tbondingcurve.allocate();\n\n\t\tpool.init();\n\n\t\tido.deploy(_feiTribeExchangeRate());\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit Launch(now);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn, \n\t\tbool inclusive\n\t) public view override returns (uint feiAmount, uint tribeAmount) {\n\t\tuint totalIn = totalSupply();\n\t\tif (!inclusive) {\n\t\t\ttotalIn += amountIn;\n\t\t}\n\t\trequire(amountIn <= totalIn, \"GenesisGroup: Not enough supply\");\n\n\t\tuint totalFei = bondingcurve.getAmountOut(totalIn);\n\t\tuint totalTribe = tribeBalance();\n\n\t\treturn (totalFei * amountIn / totalIn, totalTribe * amountIn / totalIn);\n\t}\n\n\tfunction isAtMaxPrice() public view override returns(bool) {\n\t\tuint balance = address(this).balance;\n\t\trequire(balance != 0, \"GenesisGroup: No balance\");\n\n\t\treturn bondingcurve.getAveragePrice(balance).greaterThanOrEqualTo(maxGenesisPrice);\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\t// Sender doesn't need approval\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _fgenRatio(address account) internal view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(balanceOf(account), totalSupply());\n\t}\n\n\tfunction _feiTribeExchangeRate() public view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(feiBalance(), tribeBalance()).div(exchangeRateDiscount);\n\t}\n}"
    },
    {
      "filename": "contracts/genesis/GenesisGroup.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IGenesisGroup.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../pool/IPool.sol\";\nimport \"../oracle/IBondingCurveOracle.sol\";\nimport \"../bondingcurve/IBondingCurve.sol\";\n\ninterface IOrchestrator {\n\tfunction launchGovernance() external;\n\tfunction pool() external returns(address);\n\tfunction bondingCurveOracle() external returns(address);\n}\n\n/// @title IGenesisGroup implementation\n/// @author Fei Protocol\ncontract GenesisGroup is IGenesisGroup, CoreRef, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOrchestrator private orchestrator;\n\n\tIBondingCurve private bondingcurve;\n\n\tIBondingCurveOracle private bondingCurveOracle;\n\n\tIPool private pool;\n\n\tIDOInterface private ido;\n\tuint private exchangeRateDiscount;\n\n\t/// @notice a cap on the genesis group purchase price\n\tDecimal.D256 public maxGenesisPrice;\n\n\t/// @notice GenesisGroup constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _bondingcurve Bonding curve address for purchase\n\t/// @param _ido IDO contract to deploy\n\t/// @param _oracle Bonding curve oracle\n\t/// @param _pool Staking Pool\n\t/// @param _duration duration of the Genesis Period\n\t/// @param _maxPriceBPs max price of FEI allowed in Genesis Group in dollar terms\n\t/// @param _exchangeRateDiscount a divisor on the FEI/TRIBE ratio at Genesis to deploy to the IDO\n\tconstructor(\n\t\taddress _core, \n\t\taddress _bondingcurve,\n\t\taddress _ido,\n\t\taddress _oracle,\n\t\taddress _pool,\n\t\tuint32 _duration,\n\t\tuint _maxPriceBPs,\n\t\tuint _exchangeRateDiscount\n\t) public\n\t\tCoreRef(_core)\n\t\tERC20(\"Fei Genesis Group\", \"FGEN\")\n\t\tTimed(_duration)\n\t{\n\t\tbondingcurve = IBondingCurve(_bondingcurve);\n\n\t\texchangeRateDiscount = _exchangeRateDiscount;\n\t\tido = IDOInterface(_ido);\n\n\t\tpool = IPool(_pool);\n\t\tbondingCurveOracle = IBondingCurveOracle(_oracle);\n\n\t\t_initTimed();\n\n\t\tmaxGenesisPrice = Decimal.ratio(_maxPriceBPs, 10000);\n\t}\n\n\tmodifier onlyGenesisPeriod() {\n\t\trequire(!isTimeEnded(), \"GenesisGroup: Not in Genesis Period\");\n\t\t_;\n\t}\n\n\tfunction purchase(address to, uint value) external override payable onlyGenesisPeriod {\n\t\trequire(msg.value == value, \"GenesisGroup: value mismatch\");\n\t\trequire(value != 0, \"GenesisGroup: no value sent\");\n\n\t\t_mint(to, value);\n\n\t\temit Purchase(to, value);\n\t}\n\n\tfunction redeem(address to) external override postGenesis {\n\t\tDecimal.D256 memory ratio = _fgenRatio(to);\n\t\trequire(!ratio.equals(Decimal.zero()), \"GensisGroup: No balance to redeem\");\n\n\t\tuint amountIn = balanceOf(to);\n\t\tburnFrom(to, amountIn);\n\n\t\tuint feiAmount = ratio.mul(feiBalance()).asUint256();\n\t\tfei().transfer(to, feiAmount);\n\n\t\tuint tribeAmount = ratio.mul(tribeBalance()).asUint256();\n\t\ttribe().transfer(to, tribeAmount);\n\n\t\temit Redeem(to, amountIn, feiAmount, tribeAmount);\n\t}\n\n\tfunction launch() external override {\n\t\trequire(isTimeEnded() || isAtMaxPrice(), \"GenesisGroup: Still in Genesis Period\");\n\n\t\tcore().completeGenesisGroup();\n\n\t\taddress genesisGroup = address(this);\n\t\tuint balance = genesisGroup.balance;\n\n\t\tbondingCurveOracle.init(bondingcurve.getAveragePrice(balance));\n\n\t\tbondingcurve.purchase{value: balance}(genesisGroup, balance);\n\t\tbondingcurve.allocate();\n\n\t\tpool.init();\n\n\t\tido.deploy(_feiTribeExchangeRate());\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit Launch(now);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn, \n\t\tbool inclusive\n\t) public view override returns (uint feiAmount, uint tribeAmount) {\n\t\tuint totalIn = totalSupply();\n\t\tif (!inclusive) {\n\t\t\ttotalIn += amountIn;\n\t\t}\n\t\trequire(amountIn <= totalIn, \"GenesisGroup: Not enough supply\");\n\n\t\tuint totalFei = bondingcurve.getAmountOut(totalIn);\n\t\tuint totalTribe = tribeBalance();\n\n\t\treturn (totalFei * amountIn / totalIn, totalTribe * amountIn / totalIn);\n\t}\n\n\tfunction isAtMaxPrice() public view override returns(bool) {\n\t\tuint balance = address(this).balance;\n\t\trequire(balance != 0, \"GenesisGroup: No balance\");\n\n\t\treturn bondingcurve.getAveragePrice(balance).greaterThanOrEqualTo(maxGenesisPrice);\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\t// Sender doesn't need approval\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _fgenRatio(address account) internal view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(balanceOf(account), totalSupply());\n\t}\n\n\tfunction _feiTribeExchangeRate() public view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(feiBalance(), tribeBalance()).div(exchangeRateDiscount);\n\t}\n}"
    }
  ]
}