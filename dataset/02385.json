{
  "Title": "H-11: Malicious seller forced break lockCapital()",
  "Content": "# Issue H-11: Malicious seller forced break lockCapital() \n\nSource: https://github.com/sherlock-audit/2023-02-carapace-judging/issues/31 \n\n## Found by \nclems4ever, bin2chen\n\n## Summary\n\nMalicious burn nft causes failure to lockCapital() ï¼Œseller steady earn PremiumAmount, buyer will be lost compensation\n\n## Vulnerability Detail\nWhen the status of the lendingPool changes from Active to Late, the protocol will call ProtectionPool.lockCapital() to  lock amount\nlockCapital() will loop through the active protections to calculate the ```lockedAmount```.\nThe code is as follows:\n```solidity\n  function lockCapital(address _lendingPoolAddress)\n    external\n    payable\n    override\n    onlyDefaultStateManager\n    whenNotPaused\n    returns (uint256 _lockedAmount, uint256 _snapshotId)\n  {\n....\n    uint256 _length = activeProtectionIndexes.length();\n    for (uint256 i; i < _length; ) {\n...\n      uint256 _remainingPrincipal = poolInfo\n        .referenceLendingPools\n        .calculateRemainingPrincipal(            //<----------- calculate Remaining Principal\n          _lendingPoolAddress,\n          protectionInfo.buyer,\n          protectionInfo.purchaseParams.nftLpTokenId\n        );\n```\nThe important thing inside is to calculate the _remainingPrincipal by ```referenceLendingPools.calculateRemainingPrincipal()```\n\n```solidity\n  function calculateRemainingPrincipal(\n    address _lendingPoolAddress,\n    address _lender,\n    uint256 _nftLpTokenId\n  ) public view override returns (uint256 _principalRemaining) {\n...\n\n    if (_poolTokens.ownerOf(_nftLpTokenId) == _lender) {   //<------------call ownerOf()\n      IPoolTokens.TokenInfo memory _tokenInfo = _poolTokens.getTokenInfo(\n        _nftLpTokenId\n      );\n\n....\n      if (\n        _tokenInfo.pool == _lendingPoolAddress &&\n        _isJuniorTrancheId(_tokenInfo.tranche)\n      ) {\n        _principalRemaining =\n          _tokenInfo.principalAmount -\n          _tokenInfo.principalRedeemed;\n      }\n    }\n  }\n```\nGoldfinchAdapter.calculateRemainingPrincipal()\nThe current implementation will first determine if the ownerOf the NFTID is _lender\n\nThere is a potential problem here, if the NFTID has been burned, the ownerOf() will be directly revert, which will lead to calculateRemainingPrincipal() revert,and lockCapital() revert and can't change status from active to late\n\nLet's see whether Goldfinch's implementation supports burn(NFTID), and whether ownerOf(NFTID) will revert\n\n1. PoolTokens has burn() method , if principalRedeemed==principalAmount you can burn it\n\n```solidity\ncontract PoolTokens is IPoolTokens, ERC721PresetMinterPauserAutoIdUpgradeSafe, HasAdmin, IERC2981 {\n.....\n  function burn(uint256 tokenId) external virtual override whenNotPaused {\n    TokenInfo memory token = _getTokenInfo(tokenId);\n    bool canBurn = _isApprovedOrOwner(_msgSender(), tokenId);\n    bool fromTokenPool = _validPool(_msgSender()) && token.pool == _msgSender();\n    address owner = ownerOf(tokenId);\n    require(canBurn || fromTokenPool, \"ERC721Burnable: caller cannot burn this token\");\n    require(token.principalRedeemed == token.principalAmount, \"Can only burn fully redeemed tokens\");\n    _destroyAndBurn(tokenId);\n    emit TokenBurned(owner, token.pool, tokenId);\n  }\n```\nhttps://github.com/goldfinch-eng/mono/blob/88f0e3f94f6dd23ebae429fe09e2511650df893a/packages/protocol/contracts/protocol/core/PoolTokens.sol#L199\n\n2.ownerOf() if nftid don't exists  will revert with message \"ERC721: owner query for nonexistent token\"\n\n```solidity\ncontract ERC721UpgradeSafe is\n  Initializable,\n  ContextUpgradeSafe,\n  ERC165UpgradeSafe,\n  IERC721,\n  IERC721Metadata,\n  IERC721Enumerable\n{\n...\n  function ownerOf(uint256 tokenId) public view override returns (address) {\n    return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n  }\n```\nhttps://github.com/goldfinch-eng/mono/blob/88f0e3f94f6dd23ebae429fe09e2511650df893a/packages/protocol/contracts/external/ERC721.sol#L136-L138\n\nIf it can't changes to late, Won't lock the fund, seller steady earn PremiumAmount\n\nSo there are two risks\n1. normal buyer gives NFTID to burn(), he does not know that it will affect all protection of the lendingPool\n2. Malicious seller can buy a protection first, then burn it, so as to force all protection of the lendingPool to expire and get the PremiumAmount maliciously. buyer unable to obtain compensation\n\nSuggested try catch for _poolTokens.ownerOf() If revert, it is assumed that the lender is not the owner\n\n## Impact\n\nbuyer will be lost compensation\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ProtectionPool.sol#L389-L395\n\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/adapters/GoldfinchAdapter.sol#L162-L165\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\ntry catch for _poolTokens.ownerOf() If revert, it is assumed that the lender is not the owner\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/40",
  "Code": [
    {
      "filename": "packages/protocol/contracts/protocol/core/PoolTokens.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../external/ERC721PresetMinterPauserAutoId.sol\";\nimport \"./GoldfinchConfig.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"./HasAdmin.sol\";\nimport \"./ConfigurableRoyaltyStandard.sol\";\nimport \"../../interfaces/IERC2981.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\n\n/**\n * @title PoolTokens\n * @notice PoolTokens is an ERC721 compliant contract, which can represent\n *  junior tranche or senior tranche shares of any of the borrower pools.\n * @author Goldfinch\n */\ncontract PoolTokens is IPoolTokens, ERC721PresetMinterPauserAutoIdUpgradeSafe, HasAdmin, IERC2981 {\n  bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n  bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n  bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n  bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n  GoldfinchConfig public config;\n  using ConfigHelper for GoldfinchConfig;\n\n  struct PoolInfo {\n    uint256 totalMinted;\n    uint256 totalPrincipalRedeemed;\n    bool created;\n  }\n\n  // tokenId => tokenInfo\n  mapping(uint256 => TokenInfo) public tokens;\n  // poolAddress => poolInfo\n  mapping(address => PoolInfo) public pools;\n\n  ConfigurableRoyaltyStandard.RoyaltyParams public royaltyParams;\n  using ConfigurableRoyaltyStandard for ConfigurableRoyaltyStandard.RoyaltyParams;\n\n  event TokenMinted(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 amount,\n    uint256 tranche\n  );\n\n  event TokenRedeemed(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 principalRedeemed,\n    uint256 interestRedeemed,\n    uint256 tranche\n  );\n\n  event TokenPrincipalWithdrawn(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 principalWithdrawn,\n    uint256 tranche\n  );\n\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\n\n  event GoldfinchConfigUpdated(address indexed who, address configAddress);\n\n  event RoyaltyParamsSet(address indexed sender, address newReceiver, uint256 newRoyaltyPercent);\n\n  /*\n    We are using our own initializer function so that OZ doesn't automatically\n    set owner as msg.sender. Also, it lets us set our config contract\n  */\n  // solhint-disable-next-line func-name-mixedcase\n  function __initialize__(address owner, GoldfinchConfig _config) external initializer {\n    require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n\n    __Context_init_unchained();\n    __AccessControl_init_unchained();\n    __ERC165_init_unchained();\n    // This is setting name and symbol of the NFT's\n    __ERC721_init_unchained(\"Goldfinch V2 Pool Tokens\", \"GFI-V2-PT\");\n    __Pausable_init_unchained();\n    __ERC721Pausable_init_unchained();\n\n    config = _config;\n\n    _setupRole(PAUSER_ROLE, owner);\n    _setupRole(OWNER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  /**\n   * @notice Called by pool to create a debt position in a particular tranche and amount\n   * @param params Struct containing the tranche and the amount\n   * @param to The address that should own the position\n   * @return tokenId The token ID (auto-incrementing integer across all pools)\n   */\n  function mint(MintParams calldata params, address to)\n    external\n    virtual\n    override\n    onlyPool\n    whenNotPaused\n    returns (uint256 tokenId)\n  {\n    address poolAddress = _msgSender();\n    tokenId = _createToken(params, poolAddress);\n    _mint(to, tokenId);\n    config.getBackerRewards().setPoolTokenAccRewardsPerPrincipalDollarAtMint(_msgSender(), tokenId);\n    emit TokenMinted(to, poolAddress, tokenId, params.principalAmount, params.tranche);\n    return tokenId;\n  }\n\n  /**\n   * @notice Updates a token to reflect the principal and interest amounts that have been redeemed.\n   * @param tokenId The token id to update (must be owned by the pool calling this function)\n   * @param principalRedeemed The incremental amount of principal redeemed (cannot be more than principal deposited)\n   * @param interestRedeemed The incremental amount of interest redeemed\n   */\n  function redeem(\n    uint256 tokenId,\n    uint256 principalRedeemed,\n    uint256 interestRedeemed\n  ) external virtual override onlyPool whenNotPaused {\n    TokenInfo storage token = tokens[tokenId];\n    address poolAddr = token.pool;\n    require(token.pool != address(0), \"Invalid tokenId\");\n    require(_msgSender() == poolAddr, \"Only the token's pool can redeem\");\n\n    PoolInfo storage pool = pools[poolAddr];\n    pool.totalPrincipalRedeemed = pool.totalPrincipalRedeemed.add(principalRedeemed);\n    require(pool.totalPrincipalRedeemed <= pool.totalMinted, \"Cannot redeem more than we minted\");\n\n    token.principalRedeemed = token.principalRedeemed.add(principalRedeemed);\n    require(\n      token.principalRedeemed <= token.principalAmount,\n      \"Cannot redeem more than principal-deposited amount for token\"\n    );\n    token.interestRedeemed = token.interestRedeemed.add(interestRedeemed);\n\n    emit TokenRedeemed(ownerOf(tokenId), poolAddr, tokenId, principalRedeemed, interestRedeemed, token.tranche);\n  }\n\n  /** @notice reduce a given pool token's principalAmount and principalRedeemed by a specified amount\n   *  @dev uses safemath to prevent underflow\n   *  @dev this function is only intended for use as part of the v2.6.0 upgrade\n   *    to rectify a bug that allowed users to create a PoolToken that had a\n   *    larger amount of principal than they actually made available to the\n   *    borrower.  This bug is fixed in v2.6.0 but still requires past pool tokens\n   *    to have their principal redeemed and deposited to be rectified.\n   *  @param tokenId id of token to decrease\n   *  @param amount amount to decrease by\n   */\n  function reducePrincipalAmount(uint256 tokenId, uint256 amount) external onlyAdmin {\n    TokenInfo storage tokenInfo = tokens[tokenId];\n    tokenInfo.principalAmount = tokenInfo.principalAmount.sub(amount);\n    tokenInfo.principalRedeemed = tokenInfo.principalRedeemed.sub(amount);\n  }\n\n  /**\n   * @notice Decrement a token's principal amount. This is different from `redeem`, which captures changes to\n   *   principal and/or interest that occur when a loan is in progress.\n   * @param tokenId The token id to update (must be owned by the pool calling this function)\n   * @param principalAmount The incremental amount of principal redeemed (cannot be more than principal deposited)\n   */\n  function withdrawPrincipal(uint256 tokenId, uint256 principalAmount)\n    external\n    virtual\n    override\n    onlyPool\n    whenNotPaused\n  {\n    TokenInfo storage token = tokens[tokenId];\n    address poolAddr = token.pool;\n    require(_msgSender() == poolAddr, \"Invalid sender\");\n    require(token.principalRedeemed == 0, \"Token redeemed\");\n    require(token.principalAmount >= principalAmount, \"Insufficient principal\");\n\n    PoolInfo storage pool = pools[poolAddr];\n    pool.totalMinted = pool.totalMinted.sub(principalAmount);\n    require(pool.totalPrincipalRedeemed <= pool.totalMinted, \"Cannot withdraw more than redeemed\");\n\n    token.principalAmount = token.principalAmount.sub(principalAmount);\n\n    emit TokenPrincipalWithdrawn(ownerOf(tokenId), poolAddr, tokenId, principalAmount, token.tranche);\n  }\n\n  /**\n   * @dev Burns a specific ERC721 token, and removes the data from our mappings\n   * @param tokenId uint256 id of the ERC721 token to be burned.\n   */\n  function burn(uint256 tokenId) external virtual override whenNotPaused {\n    TokenInfo memory token = _getTokenInfo(tokenId);\n    bool canBurn = _isApprovedOrOwner(_msgSender(), tokenId);\n    bool fromTokenPool = _validPool(_msgSender()) && token.pool == _msgSender();\n    address owner = ownerOf(tokenId);\n    require(canBurn || fromTokenPool, \"ERC721Burnable: caller cannot burn this token\");\n    require(token.principalRedeemed == token.principalAmount, \"Can only burn fully redeemed tokens\");\n    _destroyAndBurn(tokenId);\n    emit TokenBurned(owner, token.pool, tokenId);\n  }\n\n  function getTokenInfo(uint256 tokenId) external view virtual override returns (TokenInfo memory) {\n    return _getTokenInfo(tokenId);\n  }\n\n  /**\n   * @notice Called by the GoldfinchFactory to register the pool as a valid pool. Only valid pools can mint/redeem\n   * tokens\n   * @param newPool The address of the newly created pool\n   */\n  function onPoolCreated(address newPool) external override onlyGoldfinchFactory {\n    pools[newPool].created = true;\n  }\n\n  /**\n   * @notice Returns a boolean representing whether the spender is the owner or the approved spender of the token\n   * @param spender The address to check\n   * @param tokenId The token id to check for\n   * @return True if approved to redeem/transfer/burn the token, false if not\n   */\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view override returns (bool) {\n    return _isApprovedOrOwner(spender, tokenId);\n  }\n\n  function validPool(address sender) public view virtual override returns (bool) {\n    return _validPool(sender);\n  }\n\n  function _createToken(MintParams calldata params, address poolAddress) internal returns (uint256 tokenId) {\n    PoolInfo storage pool = pools[poolAddress];\n\n    _tokenIdTracker.increment();\n    tokenId = _tokenIdTracker.current();\n    tokens[tokenId] = TokenInfo({\n      pool: poolAddress,\n      tranche: params.tranche,\n      principalAmount: params.principalAmount,\n      principalRedeemed: 0,\n      interestRedeemed: 0\n    });\n    pool.totalMinted = pool.totalMinted.add(params.principalAmount);\n    return tokenId;\n  }\n\n  function _destroyAndBurn(uint256 tokenId) internal {\n    delete tokens[tokenId];\n    _burn(tokenId);\n  }\n\n  function _validPool(address poolAddress) internal view virtual returns (bool) {\n    return pools[poolAddress].created;\n  }\n\n  function _getTokenInfo(uint256 tokenId) internal view returns (TokenInfo memory) {\n    return tokens[tokenId];\n  }\n\n  /// @notice Called with the sale price to determine how much royalty\n  //    is owed and to whom.\n  /// @param _tokenId The NFT asset queried for royalty information\n  /// @param _salePrice The sale price of the NFT asset specified by _tokenId\n  /// @return receiver Address that should receive royalties\n  /// @return royaltyAmount The royalty payment amount for _salePrice\n  function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view override returns (address, uint256) {\n    return royaltyParams.royaltyInfo(_tokenId, _salePrice);\n  }\n\n  /// @notice Set royalty params used in `royaltyInfo`. This function is only callable by\n  ///   an address with `OWNER_ROLE`.\n  /// @param newReceiver The new address which should receive royalties. See `receiver`.\n  /// @param newRoyaltyPercent The new percent of `salePrice` that should be taken for royalties.\n  ///   See `royaltyPercent`.\n  function setRoyaltyParams(address newReceiver, uint256 newRoyaltyPercent) external onlyAdmin {\n    royaltyParams.setRoyaltyParams(newReceiver, newRoyaltyPercent);\n  }\n\n  function setBaseURI(string calldata baseURI_) external onlyAdmin {\n    _setBaseURI(baseURI_);\n  }\n\n  function supportsInterface(bytes4 id) public view override(ERC165UpgradeSafe, IERC165) returns (bool) {\n    return (id == _INTERFACE_ID_ERC721 ||\n      id == _INTERFACE_ID_ERC721_METADATA ||\n      id == _INTERFACE_ID_ERC721_ENUMERABLE ||\n      id == _INTERFACE_ID_ERC165 ||\n      id == ConfigurableRoyaltyStandard._INTERFACE_ID_ERC2981);\n  }\n\n  modifier onlyGoldfinchFactory() {\n    require(_msgSender() == config.goldfinchFactoryAddress(), \"Only Goldfinch factory is allowed\");\n    _;\n  }\n\n  modifier onlyPool() {\n    require(_validPool(_msgSender()), \"Invalid pool!\");\n    _;\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/external/ERC721.sol",
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable\n/*\n  Vendored from @openzeppelin/contracts-ethereum-package@3.0.0\n  Alterations:\n   * Use vendored ERC165 with virtual supportsInterface\n*/\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"./ERC165.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721UpgradeSafe is\n  Initializable,\n  ContextUpgradeSafe,\n  ERC165UpgradeSafe,\n  IERC721,\n  IERC721Metadata,\n  IERC721Enumerable\n{\n  using SafeMath for uint256;\n  using Address for address;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\n  using Strings for uint256;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // Mapping from holder address to their (enumerable) set of owned tokens\n  mapping(address => EnumerableSet.UintSet) private _holderTokens;\n\n  // Enumerable mapping from token ids to their owners\n  EnumerableMap.UintToAddressMap private _tokenOwners;\n\n  // Mapping from token ID to approved address\n  mapping(uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to operator approvals\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Optional mapping for token URIs\n  mapping(uint256 => string) private _tokenURIs;\n\n  // Base URI\n  string private _baseURI;\n\n  /*\n   *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n   *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n   *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n   *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n   *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n   *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n   *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n   *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n   *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n   *\n   *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n   *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n   */\n  bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n  /*\n   *     bytes4(keccak256('name()')) == 0x06fdde03\n   *     bytes4(keccak256('symbol()')) == 0x95d89b41\n   *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n   *\n   *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n   */\n  bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n  /*\n   *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n   *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n   *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n   *\n   *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n   */\n  bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n  function __ERC721_init(string memory name, string memory symbol) internal initializer {\n    __Context_init_unchained();\n    __ERC165_init_unchained();\n    __ERC721_init_unchained(name, symbol);\n  }\n\n  function __ERC721_init_unchained(string memory name, string memory symbol) internal initializer {\n    _name = name;\n    _symbol = symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(_INTERFACE_ID_ERC721);\n    _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address.\n   * @param owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address owner) public view override returns (uint256) {\n    require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n    return _holderTokens[owner].length();\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID.\n   * @param tokenId uint256 ID of the token to query the owner of\n   * @return address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 tokenId) public view override returns (address) {\n    return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n  }\n\n  /**\n   * @dev Gets the token name.\n   * @return string representing the token name\n   */\n  function name() public view override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Gets the token symbol.\n   * @return string representing the token symbol\n   */\n  function symbol() public view override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the URI for a given token ID. May return an empty string.\n   *\n   * If a base URI is set (via {_setBaseURI}), it is added as a prefix to the\n   * token's own URI (via {_setTokenURI}).\n   *\n   * If there is a base URI but no token URI, the token's ID will be used as\n   * its URI when appending it to the base URI. This pattern for autogenerated\n   * token URIs can lead to large gas savings.\n   *\n   * .Examples\n   * |===\n   * |`_setBaseURI()` |`_setTokenURI()` |`tokenURI()`\n   * | \"\"\n   * | \"\"\n   * | \"\"\n   * | \"\"\n   * | \"token.uri/123\"\n   * | \"token.uri/123\"\n   * | \"token.uri/\"\n   * | \"123\"\n   * | \"token.uri/123\"\n   * | \"token.uri/\"\n   * | \"\"\n   * | \"token.uri/<tokenId>\"\n   * |===\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\n    require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n    string memory _tokenURI = _tokenURIs[tokenId];\n\n    // If there is no base URI, return the token URI.\n    if (bytes(_baseURI).length == 0) {\n      return _tokenURI;\n    }\n    // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n    if (bytes(_tokenURI).length > 0) {\n      return string(abi.encodePacked(_baseURI, _tokenURI));\n    }\n    // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n    return string(abi.encodePacked(_baseURI, tokenId.toString()));\n  }\n\n  /**\n   * @dev Returns the base URI set via {_setBaseURI}. This will be\n   * automatically added as a prefix in {tokenURI} to each token's URI, or\n   * to the token ID if no specific URI is set for that token ID.\n   */\n  function baseURI() public view returns (string memory) {\n    return _baseURI;\n  }\n\n  /**\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n   * @param owner address owning the tokens list to be accessed\n   * @param index uint256 representing the index to be accessed of the requested tokens list\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\n   */\n  function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n    return _holderTokens[owner].at(index);\n  }\n\n  /**\n   * @dev Gets the total amount of tokens stored by the contract.\n   * @return uint256 representing the total amount of tokens\n   */\n  function totalSupply() public view override returns (uint256) {\n    // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n    return _tokenOwners.length();\n  }\n\n  /**\n   * @dev Gets the token ID at a given index of all the tokens in this contract\n   * Reverts if the index is greater or equal to the total number of tokens.\n   * @param index uint256 representing the index to be accessed of the tokens list\n   * @return uint256 token ID at the given index of the tokens list\n   */\n  function tokenByIndex(uint256 index) public view override returns (uint256) {\n    (uint256 tokenId, ) = _tokenOwners.at(index);\n    return tokenId;\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param to address to be approved for the given token ID\n   * @param tokenId uint256 ID of the token to be approved\n   */\n  function approve(address to, uint256 tokenId) public virtual override {\n    address owner = ownerOf(tokenId);\n    require(to != owner, \"ERC721: approval to current owner\");\n\n    require(\n      _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n      \"ERC721: approve caller is not owner nor approved for all\"\n    );\n\n    _approve(to, tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * Reverts if the token ID does not exist.\n   * @param tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 tokenId) public view override returns (address) {\n    require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf.\n   * @param operator operator address to set the approval\n   * @param approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address operator, bool approved) public virtual override {\n    require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n    _operatorApprovals[_msgSender()][operator] = approved;\n    emit ApprovalForAll(_msgSender(), operator, approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner.\n   * @param owner owner address which you want to query the approval of\n   * @param operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address.\n   * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * Requires the msg.sender to be the owner, approved, or operator.\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public virtual override {\n    //solhint-disable-next-line max-line-length\n    require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n    _transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg.sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public virtual override {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the _msgSender() to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) public virtual override {\n    require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n    _safeTransfer(from, to, tokenId, _data);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg.sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function _safeTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) internal virtual {\n    _transfer(from, to, tokenId);\n    require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n  }\n\n  /**\n   * @dev Returns whether the specified token exists.\n   * @param tokenId uint256 ID of the token to query the existence of\n   * @return bool whether the token exists\n   */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    return _tokenOwners.contains(tokenId);\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID.\n   * @param spender address of the spender to query\n   * @param tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   * is an operator of the owner, or is the owner of the token\n   */\n  function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n    require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n    address owner = ownerOf(tokenId);\n    return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n  }\n\n  /**\n   * @dev Internal function to safely mint a new token.\n   * Reverts if the given token ID already exists.\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted\n   */\n  function _safeMint(address to, uint256 tokenId) internal virtual {\n    _safeMint(to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Internal function to safely mint a new token.\n   * Reverts if the given token ID already exists.\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function _safeMint(\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) internal virtual {\n    _mint(to, tokenId);\n    require(\n      _checkOnERC721Received(address(0), to, tokenId, _data),\n      \"ERC721: transfer to non ERC721Receiver implementer\"\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token.\n   * Reverts if the given token ID already exists.\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted\n   */\n  function _mint(address to, uint256 tokenId) internal virtual {\n    require(to != address(0), \"ERC721: mint to the zero address\");\n    require(!_exists(tokenId), \"ERC721: token already minted\");\n\n    _beforeTokenTransfer(address(0), to, tokenId);\n\n    _holderTokens[to].add(tokenId);\n\n    _tokenOwners.set(tokenId, to);\n\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token.\n   * Reverts if the token does not exist.\n   * @param tokenId uint256 ID of the token being burned\n   */\n  function _burn(uint256 tokenId) internal virtual {\n    address owner = ownerOf(tokenId);\n\n    _beforeTokenTransfer(owner, address(0), tokenId);\n\n    // Clear approvals\n    _approve(address(0), tokenId);\n\n    // Clear metadata (if any)\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n      delete _tokenURIs[tokenId];\n    }\n\n    _holderTokens[owner].remove(tokenId);\n\n    _tokenOwners.remove(tokenId);\n\n    emit Transfer(owner, address(0), tokenId);\n  }\n\n  /**\n   * @dev Internal function to transfer ownership of a given token ID to another address.\n   * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function _transfer(\n    address from,\n    address to,\n    uint256 tokenId\n  ) internal virtual {\n    require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n    require(to != address(0), \"ERC721: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, tokenId);\n\n    // Clear approvals from the previous owner\n    _approve(address(0), tokenId);\n\n    _holderTokens[from].remove(tokenId);\n    _holderTokens[to].add(tokenId);\n\n    _tokenOwners.set(tokenId, to);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to set the token URI for a given token.\n   *\n   * Reverts if the token ID does not exist.\n   *\n   * TIP: If all token IDs share a prefix (for example, if your URIs look like\n   * `https://api.myproject.com/token/<id>`), use {_setBaseURI} to store\n   * it and save gas.\n   */\n  function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n    require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n    _tokenURIs[tokenId] = _tokenURI;\n  }\n\n  /**\n   * @dev Internal function to set the base URI for all token IDs. It is\n   * automatically added as a prefix to the value returned in {tokenURI},\n   * or to the token ID if {tokenURI} is empty.\n   */\n  function _setBaseURI(string memory baseURI_) internal virtual {\n    _baseURI = baseURI_;\n  }\n\n  /**\n   * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n   * The call is not executed if the target address is not a contract.\n   *\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return bool whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) private returns (bool) {\n    if (!to.isContract()) {\n      return true;\n    }\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes mem"
    }
  ]
}