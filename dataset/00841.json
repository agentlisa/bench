{
  "Title": "M-8: Incorrect deviation calculation in isDeviatingWithBpsCheck function",
  "Content": "# Issue M-8: Incorrect deviation calculation in isDeviatingWithBpsCheck function \n\nSource: https://github.com/sherlock-audit/2023-11-olympus-judging/issues/193 \n\n## Found by \nast3ros, coffiasd, dany.armstrong90, evilakela, hash\n## Summary\n\nThe current implementation of the `isDeviatingWithBpsCheck` function in the codebase leads to inaccurate deviation calculations, potentially allowing deviations beyond the specified limits.\n\n## Vulnerability Detail\n\nThe function `isDeviatingWithBpsCheck` checks if the deviation between two values exceeds a defined threshold. This function incorrectly calculates the deviation, considering only the deviation from the larger value to the smaller one, instead of the deviation from the mean (or TWAP).\n\n        function isDeviatingWithBpsCheck(\n            uint256 value0_,\n            uint256 value1_,\n            uint256 deviationBps_,\n            uint256 deviationMax_\n        ) internal pure returns (bool) {\n            if (deviationBps_ > deviationMax_)\n                revert Deviation_InvalidDeviationBps(deviationBps_, deviationMax_);\n\n            return isDeviating(value0_, value1_, deviationBps_, deviationMax_);\n        }\n\n        function isDeviating(\n            uint256 value0_,\n            uint256 value1_,\n            uint256 deviationBps_,\n            uint256 deviationMax_\n        ) internal pure returns (bool) {\n            return\n                (value0_ < value1_)\n                    ? _isDeviating(value1_, value0_, deviationBps_, deviationMax_)\n                    : _isDeviating(value0_, value1_, deviationBps_, deviationMax_);\n        }\n\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/libraries/Deviation.sol#L23-L52\n\nThe function then call `_isDeviating` to calculate how much the smaller value is deviated from the bigger value.\n\n        function _isDeviating(\n            uint256 value0_,\n            uint256 value1_,\n            uint256 deviationBps_,\n            uint256 deviationMax_\n        ) internal pure returns (bool) {\n            return ((value0_ - value1_) * deviationMax_) / value0_ > deviationBps_;\n        }\n\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/libraries/Deviation.sol#L63-L70\n\nThe function `isDeviatingWithBpsCheck` is usually used to check how much the current value is deviated from the TWAP value to make sure that the value is not manipulated. Such as spot price and twap price in UniswapV3.\n\n        if (\n            // `isDeviatingWithBpsCheck()` will revert if `deviationBps` is invalid.\n            Deviation.isDeviatingWithBpsCheck(\n                baseInQuotePrice,\n                baseInQuoteTWAP,\n                params.maxDeviationBps,\n                DEVIATION_BASE\n            )\n        ) {\n            revert UniswapV3_PriceMismatch(address(params.pool), baseInQuoteTWAP, baseInQuotePrice);\n        }\n\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/PRICE/submodules/feeds/UniswapV3Price.sol#L225-L235\n\nThe issue is isDeviatingWithBpsCheck is not check the deviation of current value to the TWAP but deviation from the bigger value to the smaller value. This leads to an incorrect allowance range for the price, permitting deviations that exceed the acceptable threshold.\n\nExample:\n\nTWAP price: 1000\nAllow deviation: 10%.\n\nThe correct deviation calculation will use deviation from the mean. The allow price will be from 900 to 1100 since:\n\n-   |1100 - 1000| / 1000 = 10%\n-   |900 - 1000| / 1000 = 10%\n\nHowever the current calculation will allow the price from 900 to 1111\n\n-   (1111 - 1000) / 1111 = 10%\n-   (1000 - 900) / 1000 = 10%\n\nEven though the actual deviation of 1111 to 1000 is |1111 - 1000| / 1000 = 11.11% > 10%\n\n## Impact\n\nThis miscalculation allows for greater deviations than intended, increasing the vulnerability to price manipulation and inaccuracies in Oracle price reporting.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/libraries/Deviation.sol#L63-L70\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nTo accurately measure deviation, the isDeviating function should be revised to calculate the deviation based on the mean value: `| spot value - twap value | / twap value`.\n\n\n\n## Discussion\n\n**0xrusowsky**\n\nhttps://github.com/OlympusDAO/bophades/pull/245\n\n**IAm0x52**\n\nEscalate\n\nThis is purely a design choice. Nothing here is wrong with the implementation. The deviation is purely subjective and is measured objectively the same in both directions. This should be a low severity issue in my opinion and I strongly believe it should be. At the maximum this should be a medium severity issues as impact is not large at all for any reasonable variation and only subjectively incorrect\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is purely a design choice. Nothing here is wrong with the implementation. The deviation is purely subjective and is measured objectively the same in both directions. This should be a low severity issue in my opinion and I strongly believe it should be. At the maximum this should be a medium severity issues as impact is not large at all for any reasonable variation and only subjectively incorrect\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@IAm0x52 I'm pretty sure sponsor acknowledging this with a fix indicates this is not a design choice. Let me know if there are any publicly available information at time of contests that points to that that I am missing.\n\nSince price values are CORE components of price modules, I labelled it as high as the returned price should never be allowed to have too significant of a deviation if not every use case of this prices will be impacted. I think #3 highlights the possible impact of this issues well, and as such this issues should have a minimum of medium severity if not high.\n\n**IAm0x52**\n\nThis is only used in the BUNNI library which is full range liquidity. This simply used to ensure that reserves have not been manipulated and is not the price being used. Using the example provided at a 10% deviation. Reserves can be ~1% different between methodologies. \n\nLet's do a small bit of math to figure this. Assume current invariant is 10000 and there should be 100 of each token (100 * 100 = 10000). If each token is worth $1 then the true value of the pool is 200 (1 * 100 + 1 * 100) Assume price has been manipulated up 10% so now the pool has 110 and 90.9 (10000 / 110) so the value of the pool is now 200.9 (110 * 1 + 90.9 * 1). Lets move it 1.111% more to 11.111% this means there is 111.1111 and 90 (10000 / 111.111) so the value of the pool is now 201.111 (111.111 * 1 + 90 * 1). This results in a difference of 0.211 on a value of 200.9 or 0.1%. This is entirely negligible and hence why I say the deviation check order is a design choice and either way is negligible.\n\n**nevillehuang**\n\n@IAm0x52 Agree with your analysis, but on context that core contract functionality of deviation check is broken, suggest to keep medium severity.\n\n**IAm0x52**\n\nFix looks good. Benchmark is now always the middle for comparison\n\n**Czar102**\n\nI agree that calculating deviation in log is a valid design choice. Nevertheless, I think it was clear from the comments in code that the deviation was supposed to be calculated symmetrically and linearly, I acknowledge the limitations of this bug as well.\n\nHence, planning to consider this a medium severity issue.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-11-olympus-judging/issues/193/#issuecomment-1885019022): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/128",
  "Code": [
    {
      "filename": "bophades/src/libraries/Deviation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary Deviation {\n    // ========== ERRORS ========== //\n\n    /// @notice                 The provided deviation is greater than the maximum deviation\n    /// @param deviationBps_    The accepted deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    error Deviation_InvalidDeviationBps(uint256 deviationBps_, uint256 deviationMax_);\n\n    // ========== LIBRARY LOGIC ========== //\n\n    /// @notice                 Checks if the deviation between two values is greater than the given deviation\n    /// @dev                    This function will revert if:\n    ///                         - `deviationBps_` is greater than `deviationMax_`\n    ///\n    /// @param value0_          The first value\n    /// @param value1_          The second value\n    /// @param deviationBps_    The accepted deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    /// @return                 True if the deviation is greater than the given deviation, false otherwise\n    function isDeviatingWithBpsCheck(\n        uint256 value0_,\n        uint256 value1_,\n        uint256 deviationBps_,\n        uint256 deviationMax_\n    ) internal pure returns (bool) {\n        if (deviationBps_ > deviationMax_)\n            revert Deviation_InvalidDeviationBps(deviationBps_, deviationMax_);\n\n        return isDeviating(value0_, value1_, deviationBps_, deviationMax_);\n    }\n\n    /// @notice                 Checks if the deviation between two values is greater than the given deviation\n    ///\n    /// @param value0_          The first value\n    /// @param value1_          The second value\n    /// @param deviationBps_    The accepted deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    /// @return                 True if the deviation is greater than the given deviation, false otherwise\n    function isDeviating(\n        uint256 value0_,\n        uint256 value1_,\n        uint256 deviationBps_,\n        uint256 deviationMax_\n    ) internal pure returns (bool) {\n        return\n            (value0_ < value1_)\n                ? _isDeviating(value1_, value0_, deviationBps_, deviationMax_)\n                : _isDeviating(value0_, value1_, deviationBps_, deviationMax_);\n    }\n\n    /// @notice                 Checks if the deviation between two values is greater than the given deviation\n    /// @dev                    This function will revert if:\n    ///                         - `value1_` is greater than `value0_`\n    ///\n    /// @param value0_          The biggest value\n    /// @param value1_          The smallest value\n    /// @param deviationBps_    The deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    /// @return                 True if the deviation is greater than the given deviation, false otherwise\n    function _isDeviating(\n        uint256 value0_,\n        uint256 value1_,\n        uint256 deviationBps_,\n        uint256 deviationMax_\n    ) internal pure returns (bool) {\n        return ((value0_ - value1_) * deviationMax_) / value0_ > deviationBps_;\n    }\n}"
    },
    {
      "filename": "bophades/src/libraries/Deviation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary Deviation {\n    // ========== ERRORS ========== //\n\n    /// @notice                 The provided deviation is greater than the maximum deviation\n    /// @param deviationBps_    The accepted deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    error Deviation_InvalidDeviationBps(uint256 deviationBps_, uint256 deviationMax_);\n\n    // ========== LIBRARY LOGIC ========== //\n\n    /// @notice                 Checks if the deviation between two values is greater than the given deviation\n    /// @dev                    This function will revert if:\n    ///                         - `deviationBps_` is greater than `deviationMax_`\n    ///\n    /// @param value0_          The first value\n    /// @param value1_          The second value\n    /// @param deviationBps_    The accepted deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    /// @return                 True if the deviation is greater than the given deviation, false otherwise\n    function isDeviatingWithBpsCheck(\n        uint256 value0_,\n        uint256 value1_,\n        uint256 deviationBps_,\n        uint256 deviationMax_\n    ) internal pure returns (bool) {\n        if (deviationBps_ > deviationMax_)\n            revert Deviation_InvalidDeviationBps(deviationBps_, deviationMax_);\n\n        return isDeviating(value0_, value1_, deviationBps_, deviationMax_);\n    }\n\n    /// @notice                 Checks if the deviation between two values is greater than the given deviation\n    ///\n    /// @param value0_          The first value\n    /// @param value1_          The second value\n    /// @param deviationBps_    The accepted deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    /// @return                 True if the deviation is greater than the given deviation, false otherwise\n    function isDeviating(\n        uint256 value0_,\n        uint256 value1_,\n        uint256 deviationBps_,\n        uint256 deviationMax_\n    ) internal pure returns (bool) {\n        return\n            (value0_ < value1_)\n                ? _isDeviating(value1_, value0_, deviationBps_, deviationMax_)\n                : _isDeviating(value0_, value1_, deviationBps_, deviationMax_);\n    }\n\n    /// @notice                 Checks if the deviation between two values is greater than the given deviation\n    /// @dev                    This function will revert if:\n    ///                         - `value1_` is greater than `value0_`\n    ///\n    /// @param value0_          The biggest value\n    /// @param value1_          The smallest value\n    /// @param deviationBps_    The deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    /// @return                 True if the deviation is greater than the given deviation, false otherwise\n    function _isDeviating(\n        uint256 value0_,\n        uint256 value1_,\n        uint256 deviationBps_,\n        uint256 deviationMax_\n    ) internal pure returns (bool) {\n        return ((value0_ - value1_) * deviationMax_) / value0_ > deviationBps_;\n    }\n}"
    },
    {
      "filename": "bophades/src/modules/PRICE/submodules/feeds/UniswapV3Price.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Libraries\nimport {UniswapV3OracleHelper as OracleHelper} from \"libraries/UniswapV3/Oracle.sol\";\nimport {Deviation} from \"libraries/Deviation.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n// Uniswap V3\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {OracleLibrary} from \"@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol\";\n\n// Bophades\nimport \"modules/PRICE/PRICE.v2.sol\";\n\n/// @title      UniswapV3Price\n/// @author     0xJem\n/// @notice     Provides prices derived from the TWAP of a Uniswap V3 pool\ncontract UniswapV3Price is PriceSubmodule {\n    using FullMath for uint256;\n\n    // ========== CONSTANTS ========== //\n\n    /// @notice     The maximum number of decimals allowed for a token in order to prevent overflows\n    uint8 internal constant BASE_10_MAX_EXPONENT = 30;\n\n    /// @notice     The minimum length of the TWAP observation window in seconds\n    ///             From testing, a value under 19 seconds is rejected by `OracleLibrary.getQuoteAtTick()`\n    uint32 internal constant TWAP_MINIMUM_OBSERVATION_SECONDS = 19;\n\n    /// @notice                         The parameters for a Uniswap V3 pool\n    /// @param pool                     The address of the pool\n    /// @param observationWindowSeconds The length of the TWAP observation window in seconds\n    struct UniswapV3Params {\n        IUniswapV3Pool pool;\n        uint32 observationWindowSeconds;\n        uint16 maxDeviationBps;\n    }\n\n    /// @notice     The minimum tick that can be used in a pool, as defined by UniswapV3 libraries\n    int24 internal constant MIN_TICK = -887272;\n    /// @notice     The maximum tick that can be used in a pool, as defined by UniswapV3 libraries\n    int24 internal constant MAX_TICK = -MIN_TICK;\n    /// @notice     Represents a deviation of 100% from the TWAP\n    uint16 internal constant DEVIATION_BASE = 10_000;\n\n    // ========== ERRORS ========== //\n\n    /// @notice                 The decimals of the asset are out of bounds\n    /// @param asset_           The address of the asset\n    /// @param assetDecimals_   The number of decimals of the asset\n    /// @param maxDecimals_     The maximum number of decimals allowed\n    error UniswapV3_AssetDecimalsOutOfBounds(\n        address asset_,\n        uint8 assetDecimals_,\n        uint8 maxDecimals_\n    );\n\n    /// @notice                 The lookup token was not found in the pool\n    /// @param pool_            The address of the pool\n    /// @param asset_           The address of the asset\n    error UniswapV3_LookupTokenNotFound(address pool_, address asset_);\n\n    /// @notice                 The output decimals are out of bounds\n    /// @param outputDecimals_  The number of decimals of the output\n    /// @param maxDecimals_     The maximum number of decimals allowed\n    error UniswapV3_OutputDecimalsOutOfBounds(uint8 outputDecimals_, uint8 maxDecimals_);\n\n    /// @notice                 The pool specified in the parameters is invalid\n    /// @param paramsIndex_     The index of the parameter\n    /// @param pool_            The address of the pool\n    error UniswapV3_ParamsPoolInvalid(uint8 paramsIndex_, address pool_);\n\n    /// @notice                 The pool tokens are invalid\n    /// @param pool_            The address of the pool\n    /// @param tokenIndex_      The index of the token\n    /// @param token_           The address of the token\n    error UniswapV3_PoolTokensInvalid(address pool_, uint8 tokenIndex_, address token_);\n\n    /// @notice                 The pool is invalid\n    /// @dev                    This is triggered if the pool reverted when called,\n    ///                         and indicates that the feed address is not a UniswapV3 pool.\n    ///\n    /// @param pool_            The address of the pool\n    error UniswapV3_PoolTypeInvalid(address pool_);\n\n    /// @notice         Triggered if `pool_` is locked, which indicates re-entrancy\n    ///\n    /// @param pool_    The address of the affected Uniswap V3 pool\n    error UniswapV3_PoolReentrancy(address pool_);\n\n    /// @notice                   The calculated pool price deviates from the TWAP by more than the maximum deviation.\n    ///\n    /// @param pool_              The address of the pool\n    /// @param baseInQuoteTWAP_   The calculated TWAP price in terms of the quote token\n    /// @param baseInQuotePrice_  The calculated current price in terms of the quote token\n    error UniswapV3_PriceMismatch(\n        address pool_,\n        uint256 baseInQuoteTWAP_,\n        uint256 baseInQuotePrice_\n    );\n\n    // ========== STATE VARIABLES ========== //\n\n    // ========== CONSTRUCTOR ========== //\n\n    constructor(Module parent_) Submodule(parent_) {}\n\n    // ========== SUBMODULE FUNCTIONS =========== //\n\n    /// @inheritdoc      Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"PRICE.UNIV3\");\n    }\n\n    /// @inheritdoc      Submodule\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    // ========== TOKEN PRICE FUNCTIONS ========== //\n\n    /// @notice                 Obtains the price of `lookupToken_` in USD, using the TWAP from the specified Uniswap V3 oracle.\n    /// @dev                    This function will revert if:\n    ///                         - The value of `params.observationWindowSeconds` is less than `TWAP_MINIMUM_OBSERVATION_SECONDS`\n    ///                         - Any token decimals or `outputDecimals_` are high enough to cause an overflow\n    ///                         - Any tokens in the pool are not set\n    ///                         - `lookupToken_` is not in the pool\n    ///                         - The calculated time-weighted tick is outside the bounds of int24\n    ///\n    ///                         NOTE: as a UniswapV3 pool can be manipulated using multi-block MEV, the TWAP values\n    ///                         can also be manipulated. Price feeds are a preferred source of price data. Use this function with caution.\n    ///                         See https://chainsecurity.com/oracle-manipulation-after-merge/\n    ///\n    /// @param lookupToken_     The token to determine the price of.\n    /// @param outputDecimals_  The number of decimals to return the price in\n    /// @param params_          Pool parameters of type `UniswapV3Params`\n    /// @return                 Price in the scale of `outputDecimals_`\n    function getTokenTWAP(\n        address lookupToken_,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        UniswapV3Params memory params = abi.decode(params_, (UniswapV3Params));\n        (\n            address quoteToken,\n            uint8 quoteTokenDecimals,\n            uint8 lookupTokenDecimals\n        ) = _checkPoolAndTokenParams(lookupToken_, outputDecimals_, params.pool);\n\n        uint256 baseInQuotePrice = OracleHelper.getTWAPRatio(\n            address(params.pool),\n            params.observationWindowSeconds,\n            lookupToken_,\n            quoteToken,\n            lookupTokenDecimals\n        );\n\n        // Get the price of {quoteToken} in USD\n        // Decimals: outputDecimals_\n        // PRICE will revert if the price cannot be determined or is 0.\n        (uint256 quoteInUsdPrice, ) = _PRICE().getPrice(quoteToken, PRICEv2.Variant.CURRENT);\n\n        // Calculate final price in USD\n        // Decimals: outputDecimals_\n        return baseInQuotePrice.mulDiv(quoteInUsdPrice, 10 ** quoteTokenDecimals);\n    }\n\n    /// @notice                  Obtains the price of `lookupToken_` in USD, using the current Slot0 price from the specified Uniswap V3 oracle.\n    /// @dev                     This function will revert if:\n    ///                          - The current price differs from the TWAP by more than `maxDeviationBps_`\n    ///                          - The value of `params.observationWindowSeconds` is less than `TWAP_MINIMUM_OBSERVATION_SECONDS`\n    ///                          - Any token decimals or `outputDecimals_` are high enough to cause an overflow\n    ///                          - Any tokens in the pool are not set\n    ///                          - `lookupToken_` is not in the pool\n    ///                          - The calculated time-weighted tick is outside the bounds of int24\n    ///\n    ///                          NOTE: as a UniswapV3 pool can be manipulated using multi-block MEV, the TWAP values\n    ///                          can also be manipulated. Price feeds are a preferred source of price data. Use this function with caution.\n    ///                          See https://chainsecurity.com/oracle-manipulation-after-merge/\n    ///\n    /// @param lookupToken_      The token to determine the price of.\n    /// @param outputDecimals_   The number of decimals to return the price in\n    /// @param params_           Pool parameters of type `UniswapV3Params`\n    /// @return                  Price in the scale of `outputDecimals_`\n    function getTokenPrice(\n        address lookupToken_,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        UniswapV3Params memory params = abi.decode(params_, (UniswapV3Params));\n        (\n            address quoteToken,\n            uint8 quoteTokenDecimals,\n            uint8 lookupTokenDecimals\n        ) = _checkPoolAndTokenParams(lookupToken_, outputDecimals_, params.pool);\n\n        // Get the TWAP price of the lookup token in terms of the quote token\n        uint256 baseInQuoteTWAP = OracleHelper.getTWAPRatio(\n            address(params.pool),\n            params.observationWindowSeconds,\n            lookupToken_,\n            quoteToken,\n            lookupTokenDecimals\n        );\n\n        // Get the current price of the lookup token in terms of the quote token\n        (, int24 currentTick, , , , , bool unlocked) = params.pool.slot0();\n\n        // Check for re-entrancy\n        if (unlocked == false) revert UniswapV3_PoolReentrancy(address(params.pool));\n\n        uint256 baseInQuotePrice = OracleLibrary.getQuoteAtTick(\n            currentTick,\n            uint128(10 ** lookupTokenDecimals),\n            lookupToken_,\n            quoteToken\n        );\n\n        // Check if the absolute deviation between the lookup and reserves price differs by more than reservesDeviationBps\n        // If so, the reserves may be manipulated\n        if (\n            // `isDeviatingWithBpsCheck()` will revert if `deviationBps` is invalid.\n            Deviation.isDeviatingWithBpsCheck(\n                baseInQuotePrice,\n                baseInQuoteTWAP,\n                params.maxDeviationBps,\n                DEVIATION_BASE\n            )\n        ) {\n            revert UniswapV3_PriceMismatch(address(params.pool), baseInQuoteTWAP, baseInQuotePrice);\n        }\n\n        // Get the price of {quoteToken} in USD\n        // Decimals: outputDecimals_\n        // PRICE will revert if the price cannot be determined or is 0.\n        (uint256 quoteInUsdPrice, ) = _PRICE().getPrice(quoteToken, PRICEv2.Variant.CURRENT);\n\n        // Calculate final price in USD\n        // Decimals: outputDecimals_\n        return baseInQuotePrice.mulDiv(quoteInUsdPrice, 10 ** quoteTokenDecimals);\n    }\n\n    // ========== INTERNAL FUNCTIONS ========== //\n\n    /// @notice  Performs checks to ensure that the pool, the tokens, and the decimals are valid.\n    /// @dev                    This function will revert if:\n    ///                         - Any token decimals or `outputDecimals_` are high enough to cause an overflow\n    ///                         - Any tokens in the pool are not set\n    ///                         - `lookupToken_` is not in the pool\n    ///\n    /// @param lookupToken_     The token to determine the price of\n    /// @param outputDecimals_  The decimals of `baseToken`\n    /// @param pool_            The Uniswap V3 pool to use\n    /// @return                 The `quoteToken`, its decimals, and the decimals of `lookupToken_`\n    function _checkPoolAndTokenParams(\n        address lookupToken_,\n        uint8 outputDecimals_,\n        IUniswapV3Pool pool_\n    ) internal view returns (address, uint8, uint8) {\n        if (address(pool_) == address(0)) revert UniswapV3_ParamsPoolInvalid(0, address(pool_));\n\n        try pool_.slot0() returns (uint160, int24, uint16, uint16, uint16, uint8, bool) {\n            // Do nothing\n        } catch (bytes memory) {\n            // Handle a non-UniswapV3 pool\n            revert UniswapV3_PoolTypeInvalid(address(pool_));\n        }\n\n        address quoteToken;\n        {\n            bool lookupTokenFound;\n            try pool_.token0() returns (address token) {\n                // Check if token is zero address, revert if so\n                if (token == address(0))\n                    revert UniswapV3_PoolTokensInvalid(address(pool_), 0, token);\n\n                // If token is the lookup token, set lookupTokenFound to true\n                // Otherwise, it should be the quote token\n                // If lookup token isn't found, quote token will be set twice,\n                // but this is fine since the function will revert anyway\n                if (token == lookupToken_) {\n                    lookupTokenFound = true;\n                } else {\n                    quoteToken = token;\n                }\n            } catch (bytes memory) {\n                // Handle a non-UniswapV3 pool\n                revert UniswapV3_PoolTypeInvalid(address(pool_));\n            }\n            try pool_.token1() returns (address token) {\n                // Check if token is zero address, revert if so\n                if (token == address(0))\n                    revert UniswapV3_PoolTokensInvalid(address(pool_), 1, token);\n\n                // If token is the lookup token, set lookupTokenFound to true\n                // Otherwise, it should be the quote token\n                // If lookup token isn't found, quote token will be set twice,\n                // but this is fine since the function will revert anyway\n                if (token == lookupToken_) {\n                    lookupTokenFound = true;\n                } else {\n                    quoteToken = token;\n                }\n            } catch (bytes memory) {\n                // Handle a non-UniswapV3 pool\n                revert UniswapV3_PoolTypeInvalid(address(pool_));\n            }\n\n            // If lookup token wasn't found, revert\n            if (!lookupTokenFound)\n                revert UniswapV3_LookupTokenNotFound(address(pool_), lookupToken_);\n        }\n\n        // Validate output decimals are not too high\n        if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n            revert UniswapV3_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n        uint8 quoteTokenDecimals = ERC20(quoteToken).decimals();\n        uint8 lookupTokenDecimals = ERC20(lookupToken_).decimals();\n\n        // Avoid overflows with decimal normalisation\n        if (quoteTokenDecimals > BASE_10_MAX_EXPONENT)\n            revert UniswapV3_AssetDecimalsOutOfBounds(\n                quoteToken,\n                quoteTokenDecimals,\n                BASE_10_MAX_EXPONENT\n            );\n\n        // lookupTokenDecimals must be less than 38 to avoid overflow when cast to uint128\n        // BASE_10_MAX_EXPONENT is less than 38, so this check is safe\n        if (lookupTokenDecimals > BASE_10_MAX_EXPONENT)\n            revert UniswapV3_AssetDecimalsOutOfBounds(\n                lookupToken_,\n                lookupTokenDecimals,\n                BASE_10_MAX_EXPONENT\n            );\n\n        return (quoteToken, quoteTokenDecimals, lookupTokenDecimals);\n    }\n}"
    },
    {
      "filename": "bophades/src/libraries/Deviation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary Deviation {\n    // ========== ERRORS ========== //\n\n    /// @notice                 The provided deviation is greater than the maximum deviation\n    /// @param deviationBps_    The accepted deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    error Deviation_InvalidDeviationBps(uint256 deviationBps_, uint256 deviationMax_);\n\n    // ========== LIBRARY LOGIC ========== //\n\n    /// @notice                 Checks if the deviation between two values is greater than the given deviation\n    /// @dev                    This function will revert if:\n    ///                         - `deviationBps_` is greater than `deviationMax_`\n    ///\n    /// @param value0_          The first value\n    /// @param value1_          The second value\n    /// @param deviationBps_    The accepted deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    /// @return                 True if the deviation is greater than the given deviation, false otherwise\n    function isDeviatingWithBpsCheck(\n        uint256 value0_,\n        uint256 value1_,\n        uint256 deviationBps_,\n        uint256 deviationMax_\n    ) internal pure returns (bool) {\n        if (deviationBps_ > deviationMax_)\n            revert Deviation_InvalidDeviationBps(deviationBps_, deviationMax_);\n\n        return isDeviating(value0_, value1_, deviationBps_, deviationMax_);\n    }\n\n    /// @notice                 Checks if the deviation between two values is greater than the given deviation\n    ///\n    /// @param value0_          The first value\n    /// @param value1_          The second value\n    /// @param deviationBps_    The accepted deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    /// @return                 True if the deviation is greater than the given deviation, false otherwise\n    function isDeviating(\n        uint256 value0_,\n        uint256 value1_,\n        uint256 deviationBps_,\n        uint256 deviationMax_\n    ) internal pure returns (bool) {\n        return\n            (value0_ < value1_)\n                ? _isDeviating(value1_, value0_, deviationBps_, deviationMax_)\n                : _isDeviating(value0_, value1_, deviationBps_, deviationMax_);\n    }\n\n    /// @notice                 Checks if the deviation between two values is greater than the given deviation\n    /// @dev                    This function will revert if:\n    ///                         - `value1_` is greater than `value0_`\n    ///\n    /// @param value0_          The biggest value\n    /// @param value1_          The smallest value\n    /// @param deviationBps_    The deviation in basis points (e.g. 100 = 1%)\n    /// @param deviationMax_    The maximum deviation in basis points (e.g. 10000 = 100%)\n    /// @return                 True if the deviation is greater than the given deviation, false otherwise\n    function _isDeviating(\n        uint256 value0_,\n        uint256 value1_,\n        uint256 deviationBps_,\n        uint256 deviationMax_\n    ) internal pure returns (bool) {\n        return ((value0_ - value1_) * deviationMax_) / value0_ > deviationBps_;\n    }\n}"
    }
  ]
}