{
  "Title": "[M-05] Positions that are not eligible for rewards will affect the reward income of eligible positions",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L181><br>\n<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L188><br>\n<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L48>\n\n### Impact\n\nWhen calculating reward distribution, the contract uses the current position's liquidity time weight divided by the total liquidity time weight of the pool, instead of the total liquidity time weight of the pool that meets the reward conditions.\nThis means that if there is a large amount of liquidity in the pool that is not eligible for rewards, the total weekly reward distribution will be much less than the `rewardPerWeek`, which should not be expected.\n\n### Proof of Concept\n\n```diff\ndiff --git a/canto_ambient/test_canto/TestLiquidityMining.js b/canto_ambient/test_canto/TestLiquidityMining.js\nindex bd21a32..617b070 100644\n--- a/canto_ambient/test_canto/TestLiquidityMining.js\n+++ b/canto_ambient/test_canto/TestLiquidityMining.js\n@@ -32,7 +32,7 @@ chai.use(solidity);\n \n describe(\"Liquidity Mining Tests\", function () {\n \tit(\"deploy contracts and init pool\", async function () {\n-\t\tconst [owner] = await ethers.getSigners();\n+\t\tconst [owner, others] = await ethers.getSigners();\n \n \t\t////////////////////////////////////////////////\n \t\t// DEPLOY AND MINT cNOTE and USDC\n@@ -49,6 +49,14 @@ describe(\"Liquidity Mining Tests\", function () {\n \t\t\towner.address,\n \t\t\tethers.utils.parseUnits(\"1000000\", 6)\n \t\t);\n+\t\tawait cNOTE.deposit(\n+\t\t\tothers.address,\n+\t\t\tethers.utils.parseEther(\"1000000\")\n+\t\t);\n+\t\tawait USDC.deposit(\n+\t\t\tothers.address,\n+\t\t\tethers.utils.parseUnits(\"1000000\", 6)\n+\t\t);\n \n \t\t////////////////////////////////////////////////\n \t\t// DEPLOY DEX CONTRACT AND ALL PROXIES\n@@ -145,6 +153,17 @@ describe(\"Liquidity Mining Tests\", function () {\n \t\t);\n \t\tawait approveCNOTE.wait();\n \n+\t\tapproveUSDC = await USDC.connect(others).approve(\n+\t\t\tdex.address,\n+\t\t\tBigNumber.from(10).pow(36)\n+\t\t);\n+\t\tawait approveUSDC.wait();\n+\t\tapproveCNOTE = await cNOTE.connect(others).approve(\n+\t\t\tdex.address,\n+\t\t\tBigNumber.from(10).pow(36)\n+\t\t);\n+\t\tawait approveCNOTE.wait();\n+\n \t\t/* \n         /\t2. set new pool liquidity (amount to lock up for new pool)\n         /\t   params = [code, liq]\n@@ -222,6 +241,40 @@ describe(\"Liquidity Mining Tests\", function () {\n \t\t});\n \t\tawait tx.wait();\n \n+\t\tmintConcentratedLiqCmd = abi.encode(\n+\t\t\t[\n+\t\t\t\t\"uint8\",\n+\t\t\t\t\"address\",\n+\t\t\t\t\"address\",\n+\t\t\t\t\"uint256\",\n+\t\t\t\t\"int24\",\n+\t\t\t\t\"int24\",\n+\t\t\t\t\"uint128\",\n+\t\t\t\t\"uint128\",\n+\t\t\t\t\"uint128\",\n+\t\t\t\t\"uint8\",\n+\t\t\t\t\"address\",\n+\t\t\t],\n+\t\t\t[\n+\t\t\t\t11, // code (mint concentrated liquidity in base token liq)\n+\t\t\t\tcNOTE.address, // base token\n+\t\t\t\tUSDC.address, // quote token\n+\t\t\t\t36000, // poolIDX\n+\t\t\t\tcurrentTick - 5, // tickLower\n+\t\t\t\tcurrentTick + 5, // tickUpper\n+\t\t\t\tBigNumber.from(\"100000000000000000000\"), // amount of base token to send\n+\t\t\t\tBigNumber.from(\"16602069666338596454400000\"), // min price\n+\t\t\t\tBigNumber.from(\"20291418481080506777600000\"), // max price\n+\t\t\t\t0, // reserve flag\n+\t\t\t\tZERO_ADDR, // lp conduit address (0 if not using)\n+\t\t\t]\n+\t\t);\n+\t\ttx = await dex.connect(others).userCmd(2, mintConcentratedLiqCmd, {\n+\t\t\tgasLimit: 6000000,\n+\t\t\tvalue: ethers.utils.parseUnits(\"10\", \"ether\"),\n+\t\t});\n+\t\tawait tx.wait();\n+\n \t\t////////////////////////////////////////////////\n \t\t// SAMPLE SWAP TEST (swaps 2 USDC for cNOTE)\n \t\t////////////////////////////////////////////////\n@@ -300,9 +353,9 @@ describe(\"Liquidity Mining Tests\", function () {\n \t\tconst dexBalAfter = await ethers.provider.getBalance(dex.address);\n \t\tconst ownerBalAfter = await ethers.provider.getBalance(owner.address);\n \n-\t\t// expect dex to have 2 less CANTO since we claimed for 2 weeks worth of rewards\n+\t\t// @audit Expect to have less CANTO rewards due to additional and not eligible for rewards liquidity\n \t\texpect(dexBalBefore.sub(dexBalAfter)).to.equal(\n-\t\t\tBigNumber.from(\"2000000000000000000\")\n+\t\t\tBigNumber.from(\"501412401683494542\")\n \t\t);\n \t});\n });\n```\n\nIn the pool, there is only one position that meets the reward conditions, and there is also one position that does not meet the conditions.\n\nAccording to common sense, weekly rewards should be distributed to the only position that meets the reward conditions based on `rewardPerWeek`. However, in reality, you can see that the rewards that should be distributed every week have been reduced to `1/4` due to the ineligible position.\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nSince the reward distribution of concentrated type rewards is conditionally restricted, the conditional restrictions should also be taken into account when calculating the total weight, rather than directly counting the total amount of liquidity.\n\n### Assessed type\n\nContext\n\n**[OpenCoreCH (Canto) disputed and commented via duplicate Issue #94](https://github.com/code-423n4/2023-10-canto-findings/issues/94#issuecomment-1761327402):**\n> Responding to this and [#98](https://github.com/code-423n4/2023-10-canto-findings/issues/98) here:\n> \n> The warden seems to assume that `curve.concLiq_` is influenced by the width of a position, which is not the case. If someone creates a position with range [0, 1000] and liq. 100 or [480, 520] with liq. 100, `curve.concLiq_` will be 100 in both cases when the active tick is 500 (and not 0.1 & 2.5, which seems to be the assumption of the warden). This  can be seen in `TradeMatcher`, `LevelBook`, and `LiquidityMath`. The logic is not that simple, but the high level summary is that we store for every tick the liquidity (lots) of positions that have the lower / upper tick here (`lvl.bidLots_`, `lvl.askLots_`). When a tick is then crossed, the whole liquidity is added or removed from `curve.concLiq_`.\n>\n> However, it can also be easily verified by looking at our test. If the assumption of the warden were true, the user in the test (that has a position with width 30) would not receive 100% of the rewards, but only `1/30`. Because `concLiq_` works this way, the recommendation of the warden would break the system.\n> \n> Something that is true is point 1 from [#98](https://github.com/code-423n4/2023-10-canto-findings/issues/98). If a user has a very narrow position (less than 21 ticks), it still contributes to `curve.concLiq_`.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2023-10-canto-findings/issues/177#issuecomment-1768244629):**\n > TL;DR - in some cases reward amounts may be miscalculated, resulting in lower than expected reward amounts.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-canto",
  "Code": [
    {
      "filename": "canto_ambient/contracts/mixins/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"./PositionRegistrar.sol\";\nimport \"./StorageLayout.sol\";\nimport \"./PoolRegistry.sol\";\n\n/* @title Liquidity mining mixin\n * @notice Contains the functions related to liquidity mining claiming. */\ncontract LiquidityMining is PositionRegistrar {\n    uint256 constant WEEK = 604800; // Week in seconds 604800\n\n    /// @notice Initialize the tick tracking for the first tick of a pool\n    function initTickTracking(bytes32 poolIdx, int24 tick) internal {\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][tick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the tick crossings\n    /// @dev Needs to be called whenever a tick is crossed\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the global in-range time-weighted concentrated liquidity per week\n    /// @dev Needs to be called whenever the concentrated liquidity is modified (tick crossed, positions changed)\n    function accrueConcentratedGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalConcLiquidityLastSet_[\n            poolIdx\n        ];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.concLiq_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalConcLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n    /// @dev Needs to be called whenever a position is modified\n    function accrueConcentratedPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal {\n        RangePosition72 storage pos = lookupPosition(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = pos.liquidity_;\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                uint32 origIndex = tickTrackingIndex;\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                uint32 time = lastAccrued;\n                // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                    TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                    uint32 currWeek = uint32((time / WEEK) * WEEK);\n                    uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                    uint32 dt = uint32(\n                        nextWeek < block.timestamp\n                            ? nextWeek - time\n                            : block.timestamp - time\n                    );\n                    uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                    uint32 tickActiveEnd;\n                    if (tickTracking.enterTimestamp < nextWeek) {\n                        // Tick was active before next week, need to add the liquidity\n                        if (tickTracking.enterTimestamp < time) {\n                            // Tick was already active when last claim happened, only accrue from last claim timestamp\n                            tickActiveStart = time;\n                        } else {\n                            // Tick has become active this week\n                            tickActiveStart = tickTracking.enterTimestamp;\n                        }\n                        if (tickTracking.exitTimestamp == 0) {\n                            // Tick still active, do not increase index because we need to continue from here\n                            tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                        } else {\n                            // Tick is no longer active\n                            if (tickTracking.exitTimestamp < nextWeek) {\n                                // Exit was in this week, continue with next tick\n                                tickActiveEnd = tickTracking.exitTimestamp;\n                                tickTrackingIndex++;\n                                dt = tickActiveEnd - tickActiveStart;\n                            } else {\n                                // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                tickActiveEnd = nextWeek;\n                            }\n                        }\n                        timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n                            (tickActiveEnd - tickActiveStart) * liquidity;\n                    }\n                    time += dt;\n                }\n                if (tickTrackingIndex != origIndex) {\n                    tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n                }\n            }\n        } else {\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                if (numTickTracking > 0) {\n                    if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n                        // Tick currently active\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n                    } else {\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n                    }\n                }\n            }\n        }\n        timeWeightedWeeklyPositionConcLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimConcentratedRewards(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick,\n        uint32[] memory weeksToClaim\n    ) internal {\n        accrueConcentratedPositionTimeWeightedLiquidity(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        // Need to do a global accrual in case the current tick was already in range for a long time without any modifications that triggered an accrual\n        accrueConcentratedGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !concLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallInRangeLiquidity = timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][week];\n            if (overallInRangeLiquidity > 0) {\n                uint256 inRangeLiquidityOfPosition;\n                for (int24 j = lowerTick + 10; j <= upperTick - 10; ++j) {\n                    inRangeLiquidityOfPosition += timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][week][j];\n                }\n                // Percentage of this weeks overall in range liquidity that was provided by the user times the overall weekly rewards\n                rewardsToSend += inRangeLiquidityOfPosition * concRewardPerWeek_[poolIdx][week] / overallInRangeLiquidity;\n            }\n            concLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n\n    function accrueAmbientGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.ambientSeeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalAmbLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    function accrueAmbientPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx\n    ) internal {\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint32 lastAccrued = timeWeightedWeeklyPositionAmbLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only init time on first call\n        if (lastAccrued != 0) {\n            AmbientPosition storage pos = lookupPosition(owner, poolIdx);\n            uint256 liquidity = pos.seeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyPositionAmbLiquidity_[poolIdx][posKey][\n                    currWeek\n                ] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyPositionAmbLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimAmbientRewards(\n        address owner,\n        bytes32 poolIdx,\n        uint32[] memory weeksToClaim\n    ) internal {\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        accrueAmbientPositionTimeWeightedLiquidity(payable(owner), poolIdx);\n        accrueAmbientGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !ambLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallTimeWeightedLiquidity = timeWeightedWeeklyGlobalAmbLiquidity_[\n                    poolIdx\n                ][week];\n            if (overallTimeWeightedLiquidity > 0) {\n                uint256 rewardsForWeek = (timeWeightedWeeklyPositionAmbLiquidity_[\n                    poolIdx\n                ][posKey][week] * ambRewardPerWeek_[poolIdx][week]) /\n                    overallTimeWeightedLiquidity;\n                rewardsToSend += rewardsForWeek;\n            }\n            ambLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/mixins/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"./PositionRegistrar.sol\";\nimport \"./StorageLayout.sol\";\nimport \"./PoolRegistry.sol\";\n\n/* @title Liquidity mining mixin\n * @notice Contains the functions related to liquidity mining claiming. */\ncontract LiquidityMining is PositionRegistrar {\n    uint256 constant WEEK = 604800; // Week in seconds 604800\n\n    /// @notice Initialize the tick tracking for the first tick of a pool\n    function initTickTracking(bytes32 poolIdx, int24 tick) internal {\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][tick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the tick crossings\n    /// @dev Needs to be called whenever a tick is crossed\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the global in-range time-weighted concentrated liquidity per week\n    /// @dev Needs to be called whenever the concentrated liquidity is modified (tick crossed, positions changed)\n    function accrueConcentratedGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalConcLiquidityLastSet_[\n            poolIdx\n        ];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.concLiq_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalConcLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n    /// @dev Needs to be called whenever a position is modified\n    function accrueConcentratedPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal {\n        RangePosition72 storage pos = lookupPosition(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = pos.liquidity_;\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                uint32 origIndex = tickTrackingIndex;\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                uint32 time = lastAccrued;\n                // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                    TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                    uint32 currWeek = uint32((time / WEEK) * WEEK);\n                    uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                    uint32 dt = uint32(\n                        nextWeek < block.timestamp\n                            ? nextWeek - time\n                            : block.timestamp - time\n                    );\n                    uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                    uint32 tickActiveEnd;\n                    if (tickTracking.enterTimestamp < nextWeek) {\n                        // Tick was active before next week, need to add the liquidity\n                        if (tickTracking.enterTimestamp < time) {\n                            // Tick was already active when last claim happened, only accrue from last claim timestamp\n                            tickActiveStart = time;\n                        } else {\n                            // Tick has become active this week\n                            tickActiveStart = tickTracking.enterTimestamp;\n                        }\n                        if (tickTracking.exitTimestamp == 0) {\n                            // Tick still active, do not increase index because we need to continue from here\n                            tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                        } else {\n                            // Tick is no longer active\n                            if (tickTracking.exitTimestamp < nextWeek) {\n                                // Exit was in this week, continue with next tick\n                                tickActiveEnd = tickTracking.exitTimestamp;\n                                tickTrackingIndex++;\n                                dt = tickActiveEnd - tickActiveStart;\n                            } else {\n                                // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                tickActiveEnd = nextWeek;\n                            }\n                        }\n                        timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n                            (tickActiveEnd - tickActiveStart) * liquidity;\n                    }\n                    time += dt;\n                }\n                if (tickTrackingIndex != origIndex) {\n                    tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n                }\n            }\n        } else {\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                if (numTickTracking > 0) {\n                    if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n                        // Tick currently active\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n                    } else {\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n                    }\n                }\n            }\n        }\n        timeWeightedWeeklyPositionConcLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimConcentratedRewards(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick,\n        uint32[] memory weeksToClaim\n    ) internal {\n        accrueConcentratedPositionTimeWeightedLiquidity(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        // Need to do a global accrual in case the current tick was already in range for a long time without any modifications that triggered an accrual\n        accrueConcentratedGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !concLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallInRangeLiquidity = timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][week];\n            if (overallInRangeLiquidity > 0) {\n                uint256 inRangeLiquidityOfPosition;\n                for (int24 j = lowerTick + 10; j <= upperTick - 10; ++j) {\n                    inRangeLiquidityOfPosition += timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][week][j];\n                }\n                // Percentage of this weeks overall in range liquidity that was provided by the user times the overall weekly rewards\n                rewardsToSend += inRangeLiquidityOfPosition * concRewardPerWeek_[poolIdx][week] / overallInRangeLiquidity;\n            }\n            concLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n\n    function accrueAmbientGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.ambientSeeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalAmbLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    function accrueAmbientPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx\n    ) internal {\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint32 lastAccrued = timeWeightedWeeklyPositionAmbLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only init time on first call\n        if (lastAccrued != 0) {\n            AmbientPosition storage pos = lookupPosition(owner, poolIdx);\n            uint256 liquidity = pos.seeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyPositionAmbLiquidity_[poolIdx][posKey][\n                    currWeek\n                ] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyPositionAmbLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimAmbientRewards(\n        address owner,\n        bytes32 poolIdx,\n        uint32[] memory weeksToClaim\n    ) internal {\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        accrueAmbientPositionTimeWeightedLiquidity(payable(owner), poolIdx);\n        accrueAmbientGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !ambLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallTimeWeightedLiquidity = timeWeightedWeeklyGlobalAmbLiquidity_[\n                    poolIdx\n                ][week];\n            if (overallTimeWeightedLiquidity > 0) {\n                uint256 rewardsForWeek = (timeWeightedWeeklyPositionAmbLiquidity_[\n                    poolIdx\n                ][posKey][week] * ambRewardPerWeek_[poolIdx][week]) /\n                    overallTimeWeightedLiquidity;\n                rewardsToSend += rewardsForWeek;\n            }\n            ambLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/mixins/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"./PositionRegistrar.sol\";\nimport \"./StorageLayout.sol\";\nimport \"./PoolRegistry.sol\";\n\n/* @title Liquidity mining mixin\n * @notice Contains the functions related to liquidity mining claiming. */\ncontract LiquidityMining is PositionRegistrar {\n    uint256 constant WEEK = 604800; // Week in seconds 604800\n\n    /// @notice Initialize the tick tracking for the first tick of a pool\n    function initTickTracking(bytes32 poolIdx, int24 tick) internal {\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][tick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the tick crossings\n    /// @dev Needs to be called whenever a tick is crossed\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the global in-range time-weighted concentrated liquidity per week\n    /// @dev Needs to be called whenever the concentrated liquidity is modified (tick crossed, positions changed)\n    function accrueConcentratedGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalConcLiquidityLastSet_[\n            poolIdx\n        ];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.concLiq_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalConcLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n    /// @dev Needs to be called whenever a position is modified\n    function accrueConcentratedPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal {\n        RangePosition72 storage pos = lookupPosition(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = pos.liquidity_;\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                uint32 origIndex = tickTrackingIndex;\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                uint32 time = lastAccrued;\n                // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                    TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                    uint32 currWeek = uint32((time / WEEK) * WEEK);\n                    uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                    uint32 dt = uint32(\n                        nextWeek < block.timestamp\n                            ? nextWeek - time\n                            : block.timestamp - time\n                    );\n                    uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                    uint32 tickActiveEnd;\n                    if (tickTracking.enterTimestamp < nextWeek) {\n                        // Tick was active before next week, need to add the liquidity\n                        if (tickTracking.enterTimestamp < time) {\n                            // Tick was already active when last claim happened, only accrue from last claim timestamp\n                            tickActiveStart = time;\n                        } else {\n                            // Tick has become active this week\n                            tickActiveStart = tickTracking.enterTimestamp;\n                        }\n                        if (tickTracking.exitTimestamp == 0) {\n                            // Tick still active, do not increase index because we need to continue from here\n                            tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                        } else {\n                            // Tick is no longer active\n                            if (tickTracking.exitTimestamp < nextWeek) {\n                                // Exit was in this week, continue with next tick\n                                tickActiveEnd = tickTracking.exitTimestamp;\n                                tickTrackingIndex++;\n                                dt = tickActiveEnd - tickActiveStart;\n                            } else {\n                                // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                tickActiveEnd = nextWeek;\n                            }\n                        }\n                        timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +="
    }
  ]
}