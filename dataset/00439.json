{
  "Title": "M-20: Unpausing with accrue timestamp reset can remove the accrual between last recorded accrue time and pausing time",
  "Content": "# Issue M-20: Unpausing with accrue timestamp reset can remove the accrual between last recorded accrue time and pausing time \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/91 \n\n## Found by \nhyh\n## Summary\n\nUpdating pause to `false` have an option of resetting the accrual timestamp. It can backfire if there was a substantial enough period of not updating the accrual before pausing, as it does not call accrue by itself.\n\n## Vulnerability Detail\n\nIn other words `updatePause(type, false, true)` will erase interest accrual for the unpaused period between last accrual and pausing. That period can be arbitrary long.\n\n## Impact\n\nInterest accrual is incorrectly erased for the period before pause was initiated. This is protocol-wide break of core logic via loss of yield for that period, so the impact is high. The preconditions are that `resetAccrueTimestmap == true` must be used on unpausing and that long enough period without accrual call should take place before pausing. The probability on that can be estimated as low.\n\nLikelihood: Low + Impact: High = Severity: Medium.\n\n## Code Snippet\n\nIf `resetAccrueTimestmap == true` on unpausing the accrual between `accrueInfo.lastAccrued` and pausing time is lost:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/Singularity.sol#L261-L272\n\n```solidity\n    function updatePause(PauseType _type, bool val, bool resetAccrueTimestmap) external {\n        if (msg.sender != conservator) revert NotAuthorized();\n        if (val == pauseOptions[_type]) revert SameState();\n        emit PausedUpdated(_type, pauseOptions[_type], val);\n        pauseOptions[_type] = val;\n\n        // In case of 'unpause', `lastAccrued` is set to block.timestamp\n        // Valid for all action types that has an impact on debt or supply\n        if (!val && (_type != PauseType.AddCollateral && _type != PauseType.RemoveCollateral)) {\n>>          accrueInfo.lastAccrued = resetAccrueTimestmap ? block.timestamp.toUint64() : accrueInfo.lastAccrued;\n        }\n    }\n```\n\nThat's incorrect as that was a going concern period for which lenders should have interest accounted for.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider accruing whenever pause is being triggered, so the state be updated as of pausing time:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/Singularity.sol#L261-L272\n\n```diff\n    function updatePause(PauseType _type, bool val, bool resetAccrueTimestmap) external {\n        if (msg.sender != conservator) revert NotAuthorized();\n        if (val == pauseOptions[_type]) revert SameState();\n        emit PausedUpdated(_type, pauseOptions[_type], val);\n        pauseOptions[_type] = val;\n+       // since the `lastAccrued` can be reset later the state need to be updated as of pausing time\n+       if (val) {\n+           _accrue();\n+       }\n        // In case of 'unpause', `lastAccrued` is set to block.timestamp\n        // Valid for all action types that has an impact on debt or supply\n        if (!val && (_type != PauseType.AddCollateral && _type != PauseType.RemoveCollateral)) {\n            accrueInfo.lastAccrued = resetAccrueTimestmap ? block.timestamp.toUint64() : accrueInfo.lastAccrued;\n        }\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/358.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/Singularity.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {ILeverageExecutor} from \"tapioca-periph/interfaces/bar/ILeverageExecutor.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {SGLLiquidation} from \"./SGLLiquidation.sol\";\nimport {SGLCollateral} from \"./SGLCollateral.sol\";\nimport {SGLLeverage} from \"./SGLLeverage.sol\";\nimport {SGLCommon} from \"./SGLCommon.sol\";\nimport {SGLBorrow} from \"./SGLBorrow.sol\";\n\n// solhint-disable max-line-length\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/// @title Tapioca market\ncontract Singularity is SGLCommon {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns the liquidation module\n    SGLLiquidation public liquidationModule;\n    /// @notice returns the borrow module\n    SGLBorrow public borrowModule;\n    /// @notice returns the collateral module\n    SGLCollateral public collateralModule;\n    /// @notice returns the leverage module\n    SGLLeverage public leverageModule;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BadPair();\n    error NotValid();\n    error ModuleNotSet();\n    error NotAuthorized();\n    error SameState();\n\n    struct _InitMemoryData {\n        IPenrose penrose_;\n        ITapiocaOracle _oracle;\n        uint256 _exchangeRatePrecision;\n        uint256 _collateralizationRate;\n        uint256 _liquidationCollateralizationRate;\n        ILeverageExecutor _leverageExecutor;\n    }\n\n    struct _InitMemoryModulesData {\n        address _liquidationModule;\n        address _borrowModule;\n        address _collateralModule;\n        address _leverageModule;\n    }\n\n    struct _InitMemoryTokensData {\n        IERC20 _asset;\n        uint256 _assetId;\n        IERC20 _collateral;\n        uint256 _collateralId;\n    }\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata initData) external onlyOnce {\n        (\n            _InitMemoryModulesData memory _initMemoryModulesData,\n            _InitMemoryTokensData memory _initMemoryTokensData,\n            _InitMemoryData memory _initMemoryData\n        ) = abi.decode(initData, (_InitMemoryModulesData, _InitMemoryTokensData, _InitMemoryData));\n\n        penrose = _initMemoryData.penrose_;\n        pearlmit = IPearlmit(_initMemoryData.penrose_.pearlmit());\n        yieldBox = IYieldBox(_initMemoryData.penrose_.yieldBox());\n        _transferOwnership(address(penrose));\n\n        if (address(_initMemoryTokensData._collateral) == address(0)) {\n            revert BadPair();\n        }\n        if (address(_initMemoryTokensData._asset) == address(0)) {\n            revert BadPair();\n        }\n        if (address(_initMemoryData._oracle) == address(0)) revert BadPair();\n\n        _initModules(\n            _initMemoryModulesData._liquidationModule,\n            _initMemoryModulesData._borrowModule,\n            _initMemoryModulesData._collateralModule,\n            _initMemoryModulesData._leverageModule\n        );\n        _initCoreStorage(\n            _initMemoryTokensData._asset,\n            _initMemoryTokensData._assetId,\n            _initMemoryTokensData._collateral,\n            _initMemoryTokensData._collateralId,\n            _initMemoryData._oracle,\n            _initMemoryData._leverageExecutor\n        );\n        _initDefaultValues(\n            _initMemoryData._collateralizationRate,\n            _initMemoryData._liquidationCollateralizationRate,\n            _initMemoryData._exchangeRatePrecision\n        );\n    }\n\n    function _initModules(\n        address _liquidationModule,\n        address _borrowModule,\n        address _collateralModule,\n        address _leverageModule\n    ) private {\n        if (_liquidationModule == address(0)) revert NotValid();\n        if (_collateralModule == address(0)) revert NotValid();\n        if (_borrowModule == address(0)) revert NotValid();\n        if (_leverageModule == address(0)) revert NotValid();\n        liquidationModule = SGLLiquidation(_liquidationModule);\n        collateralModule = SGLCollateral(_collateralModule);\n        borrowModule = SGLBorrow(_borrowModule);\n        leverageModule = SGLLeverage(_leverageModule);\n    }\n\n    function _initCoreStorage(\n        IERC20 _asset,\n        uint256 _assetId,\n        IERC20 _collateral,\n        uint256 _collateralId,\n        ITapiocaOracle _oracle,\n        ILeverageExecutor _leverageExecutor\n    ) private {\n        asset = _asset;\n        collateral = _collateral;\n        assetId = _assetId;\n        collateralId = _collateralId;\n        oracle = _oracle;\n        leverageExecutor = _leverageExecutor;\n    }\n\n    function _initDefaultValues(\n        uint256 _collateralizationRate,\n        uint256 _liquidationCollateralizationRate,\n        uint256 _exchangeRatePrecision\n    ) private {\n        collateralizationRate = _collateralizationRate > 0 ? _collateralizationRate : 75000;\n        liquidationCollateralizationRate =\n            _liquidationCollateralizationRate > 0 ? _liquidationCollateralizationRate : 80000;\n        require(\n            liquidationCollateralizationRate > collateralizationRate, \"SGL: liquidationCollateralizationRate not valid\"\n        );\n        minimumInterestPerSecond = 158548960; // approx 0.5% APR\n        maximumInterestPerSecond = 317097920000; // approx 1000% APR\n        interestElasticity = 28800e36; // Half or double in 28800 seconds (8 hours) if linear\n        startingInterestPerSecond = minimumInterestPerSecond;\n        accrueInfo.interestPerSecond = startingInterestPerSecond; // 1% APR, with 1e18 being 100%\n        updateExchangeRate();\n        //default fees\n        protocolFee = 10000; // 10%; used for accrual\n        borrowOpeningFee = 50; // 0.05%\n        //liquidation\n        liquidationMultiplier = 12000; //12%\n        lqCollateralizationRate = 25000;\n        EXCHANGE_RATE_PRECISION = _exchangeRatePrecision > 0 ? _exchangeRatePrecision : 1e18;\n        minLiquidatorReward = 8e4;\n        maxLiquidatorReward = 9e4;\n        liquidationBonusAmount = 1e4;\n        minimumTargetUtilization = 3e17;\n        maximumTargetUtilization = 5e17;\n        fullUtilizationMinusMax = FULL_UTILIZATION - maximumTargetUtilization;\n        rateValidDuration = 24 hours;\n\n        conservator = owner();\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Allows batched call to Singularity.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    /// @return successes count of successful operations\n    /// @return results array of revert messages\n    function execute(Module[] calldata modules, bytes[] calldata calls, bool revertOnFail)\n        external\n        nonReentrant\n        returns (bool[] memory successes, bytes[] memory results)\n    {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        if (modules.length != calls.length) revert NotValid();\n        unchecked {\n            for (uint256 i; i < calls.length; i++) {\n                (bool success, bytes memory result) = _extractModule(modules[i]).delegatecall(calls[i]);\n\n                if (!success && revertOnFail) {\n                    revert(abi.decode(_getRevertMsg(result), (string)));\n                }\n                successes[i] = success;\n                results[i] = !success ? _getRevertMsg(result) : result;\n            }\n        }\n    }\n\n    /// @notice Adds assets to the lending pair.\n    /// @param from Address to add asset from.\n    /// @param to The address of the user to receive the assets.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add.\n    /// @return fraction Total fractions added.\n    function addAsset(address from, address to, bool skim, uint256 share)\n        external\n        optionNotPaused(PauseType.AddAsset)\n        allowedLend(from, share)\n        returns (uint256 fraction)\n    {\n        _accrue();\n        fraction = _addAsset(from, to, skim, share);\n    }\n\n    /// @notice Removes an asset from `from` and transfers it to `to`.\n    /// @param from Account to debit assets from.\n    /// @param to The user that receives the removed assets.\n    /// @param fraction The amount/fraction of assets held to remove.\n    /// @return share The amount of shares transferred to `to`.\n    function removeAsset(address from, address to, uint256 fraction)\n        external\n        optionNotPaused(PauseType.RemoveAsset)\n        returns (uint256 share)\n    {\n        _accrue();\n        share = _removeAsset(from, to, fraction);\n        _allowedLend(from, share);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(PauseType _type, bool val, bool resetAccrueTimestmap) external {\n        if (msg.sender != conservator) revert NotAuthorized();\n        if (val == pauseOptions[_type]) revert SameState();\n        emit PausedUpdated(_type, pauseOptions[_type], val);\n        pauseOptions[_type] = val;\n\n        // In case of 'unpause', `lastAccrued` is set to block.timestamp\n        // Valid for all action types that has an impact on debt or supply\n        if (!val && (_type != PauseType.AddCollateral && _type != PauseType.RemoveCollateral)) {\n            accrueInfo.lastAccrued = resetAccrueTimestmap ? block.timestamp.toUint64() : accrueInfo.lastAccrued;\n        }\n    }\n\n    /// @notice rescues unused ETH from the contract\n    /// @param amount the amount to rescue\n    /// @param to the recipient\n    function rescueEth(uint256 amount, address to) external onlyOwner {\n        (bool success,) = to.call{value: amount}(\"\");\n        if (!success) revert TransferFailed();\n    }\n\n    /// @notice Transfers fees to penrose\n    /// @dev can only be called by the owner\n    /// @return feeShares the amount of fees in shares withdrawn under Penrose\n    function refreshPenroseFees() external onlyOwner returns (uint256 feeShares) {\n        address _feeTo = address(penrose);\n        // withdraw the fees accumulated in `accrueInfo.feesEarnedFraction` to the balance of `feeTo`.\n        if (accrueInfo.feesEarnedFraction > 0) {\n            _accrue();\n            uint256 _feesEarnedFraction = accrueInfo.feesEarnedFraction;\n            balanceOf[_feeTo] += _feesEarnedFraction;\n            emit Transfer(address(0), _feeTo, _feesEarnedFraction);\n            accrueInfo.feesEarnedFraction = 0;\n            emit LogWithdrawFees(_feeTo, _feesEarnedFraction);\n        }\n\n        feeShares = _removeAsset(_feeTo, msg.sender, balanceOf[_feeTo]);\n    }\n\n    /// @notice sets Singularity specific configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    ///     - borrowOpeningFee is always updated!\n    function setSingularityConfig(\n        uint256 _borrowOpeningFee,\n        uint256 _lqCollateralizationRate,\n        uint256 _liquidationMultiplier,\n        uint256 _minimumTargetUtilization,\n        uint256 _maximumTargetUtilization,\n        uint64 _minimumInterestPerSecond,\n        uint64 _maximumInterestPerSecond,\n        uint256 _interestElasticity\n    ) external onlyOwner {\n        _accrue();\n\n        if (_borrowOpeningFee > FEE_PRECISION) revert NotValid();\n        emit LogBorrowingFee(borrowOpeningFee, _borrowOpeningFee);\n        borrowOpeningFee = _borrowOpeningFee;\n\n        if (_minimumTargetUtilization > 0) {\n            emit MinimumTargetUtilizationUpdated(minimumTargetUtilization, _minimumTargetUtilization);\n            minimumTargetUtilization = _minimumTargetUtilization;\n        }\n\n        if (_maximumTargetUtilization > 0) {\n            if (_maximumTargetUtilization >= FULL_UTILIZATION) {\n                revert NotValid();\n            }\n\n            emit MaximumTargetUtilizationUpdated(maximumTargetUtilization, _maximumTargetUtilization);\n            maximumTargetUtilization = _maximumTargetUtilization;\n            fullUtilizationMinusMax = FULL_UTILIZATION - maximumTargetUtilization;\n        }\n\n        if (_minimumInterestPerSecond > 0) {\n            if (_minimumInterestPerSecond >= maximumInterestPerSecond) {\n                revert NotValid();\n            }\n            emit MinimumInterestPerSecondUpdated(minimumInterestPerSecond, _minimumInterestPerSecond);\n            minimumInterestPerSecond = _minimumInterestPerSecond;\n        }\n\n        if (_maximumInterestPerSecond > 0) {\n            if (_maximumInterestPerSecond <= minimumInterestPerSecond) {\n                revert NotValid();\n            }\n            emit MaximumInterestPerSecondUpdated(maximumInterestPerSecond, _maximumInterestPerSecond);\n            maximumInterestPerSecond = _maximumInterestPerSecond;\n        }\n\n        if (_interestElasticity > 0) {\n            emit InterestElasticityUpdated(interestElasticity, _interestElasticity);\n            interestElasticity = _interestElasticity;\n        }\n\n        if (_lqCollateralizationRate > 0) {\n            if (_lqCollateralizationRate > FEE_PRECISION) revert NotValid();\n            emit LqCollateralizationRateUpdated(lqCollateralizationRate, _lqCollateralizationRate);\n            lqCollateralizationRate = _lqCollateralizationRate;\n        }\n\n        if (_liquidationMultiplier > 0) {\n            if (_liquidationMultiplier > FEE_PRECISION) revert NotValid();\n            emit LiquidationMultiplierUpdated(liquidationMultiplier, _liquidationMultiplier);\n            liquidationMultiplier = _liquidationMultiplier;\n        }\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Base) {\n            return address(this);\n        } else if (_module == Module.Borrow) {\n            module = address(borrowModule);\n        } else if (_module == Module.Collateral) {\n            module = address(collateralModule);\n        } else if (_module == Module.Liquidation) {\n            module = address(liquidationModule);\n        } else if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        }\n        if (module == address(0)) revert ModuleNotSet();\n\n        return module;\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/Singularity.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {ILeverageExecutor} from \"tapioca-periph/interfaces/bar/ILeverageExecutor.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {SGLLiquidation} from \"./SGLLiquidation.sol\";\nimport {SGLCollateral} from \"./SGLCollateral.sol\";\nimport {SGLLeverage} from \"./SGLLeverage.sol\";\nimport {SGLCommon} from \"./SGLCommon.sol\";\nimport {SGLBorrow} from \"./SGLBorrow.sol\";\n\n// solhint-disable max-line-length\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/// @title Tapioca market\ncontract Singularity is SGLCommon {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns the liquidation module\n    SGLLiquidation public liquidationModule;\n    /// @notice returns the borrow module\n    SGLBorrow public borrowModule;\n    /// @notice returns the collateral module\n    SGLCollateral public collateralModule;\n    /// @notice returns the leverage module\n    SGLLeverage public leverageModule;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BadPair();\n    error NotValid();\n    error ModuleNotSet();\n    error NotAuthorized();\n    error SameState();\n\n    struct _InitMemoryData {\n        IPenrose penrose_;\n        ITapiocaOracle _oracle;\n        uint256 _exchangeRatePrecision;\n        uint256 _collateralizationRate;\n        uint256 _liquidationCollateralizationRate;\n        ILeverageExecutor _leverageExecutor;\n    }\n\n    struct _InitMemoryModulesData {\n        address _liquidationModule;\n        address _borrowModule;\n        address _collateralModule;\n        address _leverageModule;\n    }\n\n    struct _InitMemoryTokensData {\n        IERC20 _asset;\n        uint256 _assetId;\n        IERC20 _collateral;\n        uint256 _collateralId;\n    }\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata initData) external onlyOnce {\n        (\n            _InitMemoryModulesData memory _initMemoryModulesData,\n            _InitMemoryTokensData memory _initMemoryTokensData,\n            _InitMemoryData memory _initMemoryData\n        ) = abi.decode(initData, (_InitMemoryModulesData, _InitMemoryTokensData, _InitMemoryData));\n\n        penrose = _initMemoryData.penrose_;\n        pearlmit = IPearlmit(_initMemoryData.penrose_.pearlmit());\n        yieldBox = IYieldBox(_initMemoryData.penrose_.yieldBox());\n        _transferOwnership(address(penrose));\n\n        if (address(_initMemoryTokensData._collateral) == address(0)) {\n            revert BadPair();\n        }\n        if (address(_initMemoryTokensData._asset) == address(0)) {\n            revert BadPair();\n        }\n        if (address(_initMemoryData._oracle) == address(0)) revert BadPair();\n\n        _initModules(\n            _initMemoryModulesData._liquidationModule,\n            _initMemoryModulesData._borrowModule,\n            _initMemoryModulesData._collateralModule,\n            _initMemoryModulesData._leverageModule\n        );\n        _initCoreStorage(\n            _initMemoryTokensData._asset,\n            _initMemoryTokensData._assetId,\n            _initMemoryTokensData._collateral,\n            _initMemoryTokensData._collateralId,\n            _initMemoryData._oracle,\n            _initMemoryData._leverageExecutor\n        );\n        _initDefaultValues(\n            _initMemoryData._collateralizationRate,\n            _initMemoryData._liquidationCollateralizationRate,\n            _initMemoryData._exchangeRatePrecision\n        );\n    }\n\n    function _initModules(\n        address _liquidationModule,\n        address _borrowModule,\n        address _collateralModule,\n        address _leverageModule\n    ) private {\n        if (_liquidationModule == address(0)) revert NotValid();\n        if (_collateralModule == address(0)) revert NotValid();\n        if (_borrowModule == address(0)) revert NotValid();\n        if (_leverageModule == address(0)) revert NotValid();\n        liquidationModule = SGLLiquidation(_liquidationModule);\n        collateralModule = SGLCollateral(_collateralModule);\n        borrowModule = SGLBorrow(_borrowModule);\n        leverageModule = SGLLeverage(_leverageModule);\n    }\n\n    function _initCoreStorage(\n        IERC20 _asset,\n        uint256 _assetId,\n        IERC20 _collateral,\n        uint256 _collateralId,\n        ITapiocaOracle _oracle,\n        ILeverageExecutor _leverageExecutor\n    ) private {\n        asset = _asset;\n        collateral = _collateral;\n        assetId = _assetId;\n        collateralId = _collateralId;\n        oracle = _oracle;\n        leverageExecutor = _leverageExecutor;\n    }\n\n    function _initDefaultValues(\n        uint256 _collateralizationRate,\n        uint256 _liquidationCollateralizationRate,\n        uint256 _exchangeRatePrecision\n    ) private {\n        collateralizationRate = _collateralizationRate > 0 ? _collateralizationRate : 75000;\n        liquidationCollateralizationRate =\n            _liquidationCollateralizationRate > 0 ? _liquidationCollateralizationRate : 80000;\n        require(\n            liquidationCollateralizationRate > collateralizationRate, \"SGL: liquidationCollateralizationRate not valid\"\n        );\n        minimumInterestPerSecond = 158548960; // approx 0.5% APR\n        maximumInterestPerSecond = 317097920000; // approx 1000% APR\n        interestElasticity = 28800e36; // Half or double in 28800 seconds (8 hours) if linear\n        startingInterestPerSecond = minimumInterestPerSecond;\n        accrueInfo.interestPerSecond = startingInterestPerSecond; // 1% APR, with 1e18 being 100%\n        updateExchangeRate();\n        //default fees\n        protocolFee = 10000; // 10%; used for accrual\n        borrowOpeningFee = 50; // 0.05%\n        //liquidation\n        liquidationMultiplier = 12000; //12%\n        lqCollateralizationRate = 25000;\n        EXCHANGE_RATE_PRECISION = _exchangeRatePrecision > 0 ? _exchangeRatePrecision : 1e18;\n        minLiquidatorReward = 8e4;\n        maxLiquidatorReward = 9e4;\n        liquidationBonusAmount = 1e4;\n        minimumTargetUtilization = 3e17;\n        maximumTargetUtilization = 5e17;\n        fullUtilizationMinusMax = FULL_UTILIZATION - maximumTargetUtilization;\n        rateValidDuration = 24 hours;\n\n        conservator = owner();\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Allows batched call to Singularity.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    /// @return successes count of successful operations\n    /// @return results array of revert messages\n    function execute(Module[] calldata modules, bytes[] calldata calls, bool revertOnFail)\n        external\n        nonReentrant\n        returns (bool[] memory successes, bytes[] memory results)\n    {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        if (modules.length != calls.length) revert NotValid();\n        unchecked {\n            for (uint256 i; i < calls.length; i++) {\n                (bool success, bytes memory result) = _extractModule(modules[i]).delegatecall(calls[i]);\n\n                if (!success && revertOnFail) {\n                    revert(abi.decode(_getRevertMsg(result), (string)));\n                }\n                successes[i] = success;\n                results[i] = !success ? _getRevertMsg(result) : result;\n            }\n        }\n    }\n\n    /// @notice Adds assets to the lending pair.\n    /// @param from Address to add asset from.\n    /// @param to The address of the user to receive the assets.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add.\n    /// @return fraction Total fractions added.\n    function addAsset(address from, address to, bool skim, uint256 share)\n        external\n        optionNotPaused(PauseType.AddAsset)\n        allowedLend(from, share)\n        returns (uint256 fraction)\n    {\n        _accrue();\n        fraction = _addAsset(from, to, skim, share);\n    }\n\n    /// @notice Removes an asset from `from` and transfers it to `to`.\n    /// @param from Account to debit assets from.\n    /// @param to The user that receives the removed assets.\n    /// @param fraction The amount/fraction of assets held to remove.\n    /// @return share The amount of shares transferred to `to`.\n    function removeAsset(address from, address to, uint256 fraction)\n        external\n        optionNotPaused(PauseType.RemoveAsset)\n        returns (uint256 share)\n    {\n        _accrue();\n        share = _removeAsset(from, to, fraction);\n        _allowedLend(from, share);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(PauseType _type, bool val, bool resetAccrueTimestmap) external {\n        if (msg.sender != conservator) revert NotAuthorized();\n        if (val == pauseOptions[_type]) revert SameState();\n        emit PausedUpdated(_type, pauseOptions[_type], val);\n        pauseOptions[_type] = val;\n\n        // In case of 'unpause', `lastAccrued` is set to block.timestamp\n        // Valid for all action types that has an impact on debt or supply\n        if (!val && (_type != PauseType.AddCollateral && _type != PauseType.RemoveCollateral)) {\n            accrueInfo.lastAccrued = resetAccrueTimestmap ? block.timestamp.toUint64() : accrueInfo.lastAccrued;\n        }\n    }\n\n    /// @notice rescues unused ETH from the contract\n    /// @param amount the amount to rescue\n    /// @param to the recipient\n    function rescueEth(uint256 amount, address to) external onlyOwner {\n        (bool success,) = to.call{value: amount}(\"\");\n        if (!success) revert TransferFailed();\n    }\n\n    /// @notice Transfers fees to penrose\n    /// @dev can only be called by the owner\n    /// @return feeShares the amount of fees in shares withdrawn under Penrose\n    function refreshPenroseFees() external onlyOwner returns (uint256 feeShares) {\n        address _feeTo = address(penrose);\n        // withdraw the fees accumulated in `accrueInfo.feesEarnedFraction` to the balance of `feeTo`.\n        if (accrueInfo.feesEarnedFraction > 0) {\n            _accrue();\n            uint256 _feesEarnedFraction = accrueInfo.feesEarnedFraction;\n            balanceOf[_feeTo] += _feesEarnedFraction;\n            emit Transfer(address(0), _feeTo, _feesEarnedFraction);\n            accrueInfo.feesEarnedFraction = 0;\n            emit LogWithdrawFees(_feeTo, _feesEarnedFraction);\n        }\n\n        feeShares = _removeAsset(_feeTo, msg.sender, balanceOf[_feeTo]);\n    }\n\n    /// @notice sets Singularity specific configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    ///     - borrowOpeningFee is always updated!\n    function setSingularityConfig(\n        uint256 _borrowOpeningFee,\n        uint256 _lqCollateralizationRate,\n        uint256 _liquidationMultiplier,\n        uint256 _minimumTargetUtilization,\n        uint256 _maximumTargetUtilization,\n        uint64 _minimumInterestPerSecond,\n        uint64 _maximumInterestPerSecond,\n        uint256 _interestElasticity\n    ) external onlyOwner {\n        _accrue();\n\n        if (_borrowOpeningFee > FEE_PRECISION) revert NotValid();\n        emit LogBorrowingFee(borrowOpeningFee, _borrowOpeningFee);\n        borrowOpeningFee = _borrowOpeningFee;\n\n        if (_minimumTargetUtilization > 0) {\n            emit MinimumTargetUtilizationUpdated(minimumTargetUtilization, _minimumTargetUtilization);\n            minimumTargetUtilization = _minimumTargetUtilization;\n        }\n\n        if (_maximumTargetUtilization > 0) {\n            if (_maximumTargetUtilization >= FULL_UTILIZATION) {\n                revert NotValid();\n            }\n\n            emit MaximumTargetUtilizationUpdated(maximumTargetUtilization, _maximumTargetUtilization);\n            maximumTargetUtilization = _maximumTargetUtilization;\n            fullUtilizationMinusMax = FULL_UTILIZATION - maximumTargetUtilization;\n        }\n\n        if (_minimumInterestPerSecond > 0) {\n            if (_minimumInterestPerSecond >= maximumInterestPerSecond) {\n                revert NotValid();\n            }\n            emit MinimumInterestPerSecondUpdated(minimumInterestPerSecond, _minimumInterestPerSecond);\n            minimumInterestPerSecond = _minimumInterestPerSecond;\n        }\n\n        if (_maximumInterestPerSecond > 0) {\n            if (_maximumInterestPerSecond <= minimumInterestPerSecond) {\n                revert NotValid();\n            }\n            emit MaximumInterestPerSecondUpdated(maximumInterestPerSecond, _maximumInterestPerSecond);\n            maximumInterestPerSecond = _maximumInterestPerSecond;\n        }\n\n        if (_interestElasticity > 0) {\n            emit InterestElasticityUpdated(interestElasticity, _interestElasticity);\n            interestElasticity = _interestElasticity;\n        }\n\n        if (_lqCollateralizationRate > 0) {\n            if (_lqCollateralizationRate > FEE_PRECISION) revert NotValid();\n            emit LqCollateralizationRateUpdated(lqCollateralizationRate, _lqCollateralizationRate);\n            lqCollateralizationRate = _lqCollateralizationRate;\n        }\n\n        if (_liquidationMultiplier > 0) {\n            if (_liquidationMultiplier > FEE_PRECISION) revert NotValid();\n            emit LiquidationMultiplierUpdated(liquidationMultiplier, _liquidationMultiplier);\n            liquidationMultiplier = _liquidationMultiplier;\n        }\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Base) {\n            return address(this);\n        } else if (_module == Module.Borrow) {\n            module = address(borrowModule);\n        } else if (_module == Module.Collateral) {\n            module = address(collateralModule);\n        } else if (_module == Module.Liquidation) {\n            module = address(liquidationModule);\n        } else if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        }\n        if (module == address(0)) revert ModuleNotSet();\n\n        return module;\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}