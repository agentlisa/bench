{
  "Title": "[L-01] Very critical `onlyOwner` privileges can cause damage of the project in a possible privateKey exploit",
  "Content": "\nhttps://github.com/code-423n4/2022-11-canto/blob/main/CIP-001/src/Turnstile.sol#L148\n\nTypically, the contract’s `onlyOwner` is the account that deploys the contract. As a result, the `onlyOwner` is able to perform certain privileged activities.\n\nHowever, `onlyOwner` privileges are numerous and there is no timelock structure in the process of using these privileges.\n\nThe onlyOwner  is assumed to be an EOA, since the documents do not provide information on whether the `onlyOwner` will be a multisign structure.\n\nIn parallel with the private key thefts of the project onlyOwners, which have increased recently, this vulnerability has been stated as Medium.\n\nSimilar vulnerability;\n\nPrivate keys stolen:\n\nHackers have stolen cryptocurrency worth around €552 million from a blockchain project linked to the popular online game Axie Infinity, in one of the largest cryptocurrency heists on record. Security issue: PrivateKey of the project officer was stolen:\nhttps://www.euronews.com/next/2022/03/30/blockchain-network-ronin-hit-by-552-million-crypto-heist\n\n\n### Proof of Concept\n\n`onlyonlyOwner` powers;\n```js\n\nCanto/contracts/turnstile.sol:\n  146  \n  147:     /// @notice Distributes collected fees to the smart contract. Only callable by owner.\n  148:     /// @param _tokenId NFT that earned fees\n  149:     function distributeFees(uint256 _tokenId) public onlyOwner payable {\n  150          if (msg.value == 0) revert NothingToDistribute();\n\n```\n\n`onlyOwner` can also make this functionality unavailable by using the renounceOwnership property.\n\n### Recommended Mitigation Steps\n\n1. A timelock contract should be added to use `onlyOwner` privileges. In this way, users can be warned in case of a possible security weakness.\n2. `onlyOwner` can be a Multisign wallet and this part is specified in the documentation.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-canto",
  "Code": [
    {
      "filename": "CIP-001/src/Turnstile.sol",
      "content": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.8.17;\n\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"openzeppelin/utils/Counters.sol\";\n\n/// @notice Implementation of CIP-001 https://github.com/Canto-Improvement-Proposals/CIPs/blob/main/CIP-001.md\n/// @dev Every contract is responsible to register itself in the constructor by calling `register(address)`.\n///      If contract is using proxy pattern, it's possible to register retroactively, however past fees will be lost.\n///      Recipient withdraws fees by calling `withdraw(uint256,address,uint256)`.\ncontract Turnstile is Ownable, ERC721Enumerable {\n    using Counters for Counters.Counter;\n\n    struct NftData {\n        uint256 tokenId;\n        bool registered;\n    }\n\n    Counters.Counter private _tokenIdTracker;\n\n    /// @notice maps smart contract address to tokenId\n    mapping(address => NftData) public feeRecipient;\n\n    /// @notice maps tokenId to fees earned\n    mapping(uint256 => uint256) public balances;\n\n    event Register(address smartContract, address recipient, uint256 tokenId);\n    event Assign(address smartContract, uint256 tokenId);\n    event Withdraw(uint256 tokenId, address recipient, uint256 feeAmount);\n    event DistributeFees(uint256 tokenId, uint256 feeAmount);\n\n    error NotAnOwner();\n    error AlreadyRegistered();\n    error Unregistered();\n    error InvalidRecipient();\n    error InvalidTokenId();\n    error NothingToWithdraw();\n    error NothingToDistribute();\n\n    /// @dev only owner of _tokenId can call this function\n    modifier onlyNftOwner(uint256 _tokenId) {\n        if (ownerOf(_tokenId) != msg.sender) revert NotAnOwner();\n\n        _;\n    }\n\n    /// @dev only smart contract that is unregistered can call this function\n    modifier onlyUnregistered() {\n        address smartContract = msg.sender;\n\n        if (isRegistered(smartContract)) revert AlreadyRegistered();\n\n        _;\n    }\n\n    constructor() ERC721(\"Turnstile\", \"Turnstile\") {}\n\n    /// @notice Returns current value of counter used to tokenId of new minted NFTs\n    /// @return current counter value\n    function currentCounterId() external view returns (uint256) {\n        return _tokenIdTracker.current();\n    }\n\n    /// @notice Returns tokenId that collects fees generated by the smart contract\n    /// @param _smartContract address of the smart contract\n    /// @return tokenId that collects fees generated by the smart contract\n    function getTokenId(address _smartContract) external view returns (uint256) {\n        if (!isRegistered(_smartContract)) revert Unregistered();\n\n        return feeRecipient[_smartContract].tokenId;\n    }\n\n    /// @notice Returns true if smart contract is registered to collect fees\n    /// @param _smartContract address of the smart contract\n    /// @return true if smart contract is registered to collect fees, false otherwise\n    function isRegistered(address _smartContract) public view returns (bool) {\n        return feeRecipient[_smartContract].registered;\n    }\n\n    /// @notice Mints ownership NFT that allows the owner to collect fees earned by the smart contract.\n    ///         `msg.sender` is assumed to be a smart contract that earns fees. Only smart contract itself\n    ///         can register a fee receipient.\n    /// @param _recipient recipient of the ownership NFT\n    /// @return tokenId of the ownership NFT that collects fees\n    function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n        address smartContract = msg.sender;\n\n        if (_recipient == address(0)) revert InvalidRecipient();\n\n        tokenId = _tokenIdTracker.current();\n        _mint(_recipient, tokenId);\n        _tokenIdTracker.increment();\n\n        emit Register(smartContract, _recipient, tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: tokenId,\n            registered: true\n        });\n    }\n\n    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.\n    ///         Callable only by smart contract itself.\n    /// @param _tokenId tokenId which will collect fees\n    /// @return tokenId of the ownership NFT that collects fees\n    function assign(uint256 _tokenId) public onlyUnregistered returns (uint256) {\n        address smartContract = msg.sender;\n\n        if (!_exists(_tokenId)) revert InvalidTokenId();\n\n        emit Assign(smartContract, _tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: _tokenId,\n            registered: true\n        });\n\n        return _tokenId;\n    }\n\n    /// @notice Withdraws earned fees to `_recipient` address. Only callable by NFT owner.\n    /// @param _tokenId token Id\n    /// @param _recipient recipient of fees\n    /// @param _amount amount of fees to withdraw\n    /// @return amount of fees withdrawn\n    function withdraw(uint256 _tokenId, address payable _recipient, uint256 _amount)\n        public\n        onlyNftOwner(_tokenId)\n        returns (uint256)\n    {\n        uint256 earnedFees = balances[_tokenId];\n\n        if (earnedFees == 0 || _amount == 0) revert NothingToWithdraw();\n        if (_amount > earnedFees) _amount = earnedFees;\n\n        balances[_tokenId] = earnedFees - _amount;\n\n        emit Withdraw(_tokenId, _recipient, _amount);\n\n        Address.sendValue(_recipient, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Distributes collected fees to the smart contract. Only callable by owner.\n    /// @param _tokenId NFT that earned fees\n    function distributeFees(uint256 _tokenId) public onlyOwner payable {\n        if (msg.value == 0) revert NothingToDistribute();\n\n        balances[_tokenId] += msg.value;\n        emit DistributeFees(_tokenId, msg.value);\n    }\n}"
    }
  ]
}