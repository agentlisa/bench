{
  "Title": "[G-11] Using `storage` instead of `memory` for `structs/arrays` saves gas",
  "Content": "\nWhen fetching data from a storage location, assigning the data to a ``memory`` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (2100 gas) for each field of the struct/array. If the fields are read from the new memory variable, they incur an additional MLOAD rather than a cheap stack read. Instead of declearing the variable with the ``memory`` keyword, declaring the variable with the ``storage`` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a ``memory`` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires ``memory``, or if the array/struct is being read from another ``memory`` array/struct\n\n11 results - 2 files:\n```solidity\ncontracts\\smart-contract-wallet\\aa-4337\\core\\EntryPoint.sol:\n  171:     MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n  229:     UserOpInfo memory outOpInfo;\n\n  234:     StakeInfo memory paymasterInfo = getStakeInfo(outOpInfo.mUserOp.paymaster);\n\n  235:     StakeInfo memory senderInfo = getStakeInfo(outOpInfo.mUserOp.sender);\n\n  238:     StakeInfo memory factoryInfo = getStakeInfo(factory);\n\n  241:     AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(aggregator, getStakeInfo(aggregator));\n\n  293:     MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n  351:     MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n  389:     MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n\n  444:     MemoryUserOp memory mUserOp = opInfo.mUserOp;\n```\n[EntryPoint.sol#L171](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L171), [EntryPoint.sol#L229](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L229), [EntryPoint.sol#L234](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L234), [EntryPoint.sol#L235](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L235), [EntryPoint.sol#L238](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L238), [EntryPoint.sol#L241](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L241), [EntryPoint.sol#L293](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L293), [EntryPoint.sol#L351](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L351), [EntryPoint.sol#L389](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L389), [EntryPoint.sol#L444](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L444)\n\n```solidity\ncontracts\\smart-contract-wallet\\paymasters\\verifying\\singleton\\VerifyingSingletonPaymaster.sol:\n  126:     PaymasterContext memory data = context.decodePaymasterContext();\n```\n[VerifyingSingletonPaymaster.sol#L126](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L126)\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
  "Code": [
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol",
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable avoid-tx-origin */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IPaymaster.sol\";\n\nimport \"../interfaces/IAggregatedAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\n\ncontract EntryPoint is IEntryPoint, StakeManager {\n\n    using UserOperationLib for UserOperation;\n\n    SenderCreator private immutable senderCreator = new SenderCreator();\n\n    // internal value used during simulation: need to query aggregator.\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\n    /**\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary the address to receive the fees\n     * @param amount amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success,) = beneficiary.call{value : amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * execute a user op\n     * @param opIndex into into the opInfo array\n     * @param userOp the userOp to execute\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\n     * @return collected the total amount this userOp paid.\n     */\n    function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\n            collected = _actualGasCost;\n        } catch {\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            collected = _handlePostOp(opIndex, IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\n        }\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an \"actualAggregator\" when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {\n\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n    unchecked {\n        for (uint256 i = 0; i < opslen; i++) {\n            _validatePrepayment(i, ops[i], opInfos[i], address(0));\n        }\n\n        uint256 collected = 0;\n\n        for (uint256 i = 0; i < opslen; i++) {\n            collected += _executeUserOp(i, ops[i], opInfos[i]);\n        }\n\n        _compensate(beneficiary, collected);\n    } //unchecked\n    }\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public {\n\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            totalOps += opsPerAggregator[i].userOps.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                _validatePrepayment(opIndex, ops[i], opInfos[opIndex], address(aggregator));\n                opIndex++;\n            }\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {}\n                catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n        }\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            UserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    //a memory copy of UserOp fields (except that dynamic byte arrays: callData, initCode and signature\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     */\n    function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n\n            (bool success,bytes memory result) = address(mUserOp.sender).call{gas : mUserOp.callGasLimit}(callData);\n            if (!success) {\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n        return _handlePostOp(0, mode, opInfo, context, actualGas);\n    }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * copy general fields from userOp into the memory opInfo structure.\n     */\n    function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        mUserOp.callGasLimit = userOp.callGasLimit;\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\n            mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\n        } else {\n            mUserOp.paymaster = address(0);\n        }\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is SimulationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external {\n        uint256 preGas = gasleft();\n\n        UserOpInfo memory outOpInfo;\n\n        (address aggregator, uint256 deadline) = _validatePrepayment(0, userOp, outOpInfo, SIMULATE_FIND_AGGREGATOR);\n        uint256 prefund = outOpInfo.prefund;\n        uint256 preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n        StakeInfo memory paymasterInfo = getStakeInfo(outOpInfo.mUserOp.paymaster);\n        StakeInfo memory senderInfo = getStakeInfo(outOpInfo.mUserOp.sender);\n        bytes calldata initCode = userOp.initCode;\n        address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\n        StakeInfo memory factoryInfo = getStakeInfo(factory);\n\n        if (aggregator != address(0)) {\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(aggregator, getStakeInfo(aggregator));\n            revert SimulationResultWithAggregation(preOpGas, prefund, deadline, senderInfo, factoryInfo, paymasterInfo, aggregatorInfo);\n        }\n        revert SimulationResult(preOpGas, prefund, deadline, senderInfo, factoryInfo, paymasterInfo);\n\n    }\n\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal view returns (uint256 requiredPrefund) {\n    unchecked {\n        //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\n        // our security model might call postOp eventually twice\n        uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\n        uint256 requiredGas = mUserOp.callGasLimit + mUserOp.verificationGasLimit * mul + mUserOp.preVerificationGas;\n\n        // TODO: copy logic of gasPrice?\n        requiredPrefund = requiredGas * getUserOpGasPrice(mUserOp);\n    }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0) revert FailedOp(opIndex, address(0), \"AA10 sender already constructed\");\n            address sender1 = senderCreator.createSender{gas : opInfo.mUserOp.verificationGasLimit}(initCode);\n            if (sender1 == address(0)) revert FailedOp(opIndex, address(0), \"AA13 initCode failed or OOG\");\n            if (sender1 != sender) revert FailedOp(opIndex, address(0), \"AA14 initCode must return sender\");\n            if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");\n            address factory = address(bytes20(initCode[0 : 20]));\n            emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n        }\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes calldata initCode) public {\n        revert SenderAddressResult(senderCreator.createSender(initCode));\n    }\n\n    /**\n     * call account.validateUserOp.\n     * revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * decrement account's deposit if needed\n     */\n    function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, address aggregator, uint256 requiredPrefund)\n    internal returns (uint256 gasUsedByValidateAccountPrepayment, address actualAggregator, uint256 deadline) {\n    unchecked {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        address sender = mUserOp.sender;\n        _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n        if (aggregator == SIMULATE_FIND_AGGREGATOR) {\n            numberMarker();\n\n            if (sender.code.length == 0) {\n                // it would revert anyway. but give a meaningful message\n                revert FailedOp(0, address(0), \"AA20 account not deployed\");\n            }\n            if (mUserOp.paymaster != address(0) && mUserOp.paymaster.code.length == 0) {\n                // it would revert anyway. but give a meaningful message\n                revert FailedOp(0, address(0), \"AA30 paymaster not deployed\");\n            }\n            try IAggregatedAccount(sender).getAggregator() returns (address userOpAggregator) {\n                aggregator = actualAggregator = userOpAggregator;\n            } catch {\n                aggregator = actualAggregator = address(0);\n            }\n        }\n        uint256 missingAccountFunds = 0;\n        address paymaster = mUserOp.paymaster;\n        if (paymaster == address(0)) {\n            uint256 bal = balanceOf(sender);\n            missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n        }\n        try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, aggregator, missingAccountFunds) returns (uint256 _deadline) {\n            // solhint-disable-next-line not-rely-on-time\n            if (_deadline != 0 && _deadline < block.timestamp) {\n                revert FailedOp(opIndex, address(0), \"AA22 expired\");\n            }\n            deadline = _deadline;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, address(0), revertReason);\n        } catch {\n            revert FailedOp(opIndex, address(0), \"AA23 reverted (or OOG)\");\n        }\n        if (paymaster == address(0)) {\n            DepositInfo storage senderInfo = deposits[sender];\n            uint256 deposit = senderInfo.deposit;\n            if (requiredPrefund > deposit) {\n                revert FailedOp(opIndex, address(0), \"AA21 didn't pay prefund\");\n            }\n            senderInfo.deposit = uint112(deposit - requiredPrefund);\n        }\n        gasUsedByValidateAccountPrepayment = preGas - gasleft();\n    }\n    }\n\n    /**\n     * in case the request has a paymaster:\n     * validate paymaster is staked and has enough deposit.\n     * call paymaster.validatePaymasterUserOp.\n     * revert with proper FailedOp in case paymaster reverts.\n     * decrement paymaster's deposit\n     */\n    function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment) internal returns (bytes memory context, uint256 deadline) {\n    unchecked {\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        uint256 verificationGasLimit = mUserOp.verificationGasLimit;\n        require(verificationGasLimit > gasUsedByValidateAccountPrepayment, \"AA41 too little verificationGas\");\n        uint256 gas = verificationGasLimit - gasUsedByValidateAccountPrepayment;\n\n        address paymaster = mUserOp.paymaster;\n        DepositInfo storage paymasterInfo = deposits[paymaster];\n        uint256 deposit = paymasterInfo.deposit;\n        if (deposit < requiredPreFund) {\n            revert FailedOp(opIndex, paymaster, \"AA31 paymaster deposit too low\");\n        }\n        paymasterInfo.deposit = uint112(deposit - requiredPreFund);\n        try IPaymaster(paymaster).validatePaymasterUserOp{gas : gas}(op, opInfo.userOpHash, requiredPreFund) returns (bytes memory _context, uint256 _deadline){\n            // solhint-disable-next-line not-rely-on-time\n            if (_deadline != 0 && _deadline < block.timestamp) {\n                revert FailedOp(opIndex, paymaster, \"AA32 paymaster expired\");\n            }\n            context = _context;\n            deadline = _deadline;\n        } catch Error(string memory revertReason) {\n            revert FailedOp(opIndex, paymaster, revertReason);\n        } catch {\n            revert FailedOp(opIndex, paymaster, \"AA33 reverted (or OOG)\");\n        }\n    }\n    }\n\n    /**\n     * validate account and paymaster (if defined).\n     * also make sure total validation doesn't exceed verificationGasLimit\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\n     * @param opIndex the index of this userOp into the \"opInfos\" array\n     * @param userOp the userOp to validate\n     */\n    function _validatePrepayment(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory outOpInfo, address aggregator)\n    private returns (address actualAggregator, uint256 deadline) {\n\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n        _copyUserOpToMemory(userOp, mUserOp);\n        outOpInfo.userOpHash = getUserOpHash(userOp);\n\n        // validate all numeric values in userOp are well below 128 bit, so they can safely be added\n        // and multiplied without causing overflow\n        uint256 maxGasValues = mUserOp.preVerificationGas | mUserOp.verificationGasLimit | mUserOp.callGasLimit |\n        userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\n\n        uint256 gasUsedByValidateAccountPrepayment;\n        (uint256 requiredPreFund) = _getRequiredPrefund(mUserOp);\n        (gasUsedByValidateAccountPrepayment, actualAggregator, deadline) = _validateAccountPrepayment(opIndex, userOp, outOpInfo, aggregator, requiredPreFund);\n        //a \"marker\" where account opcode validation is done and paymaster opcode validation is about to start\n        // (used only by off-chain simulateValidation)\n        numberMarker();\n\n        bytes memory context;\n        if (mUserOp.paymaster != address(0)) {\n            uint paymasterDeadline;\n            (context, paymasterDeadline) = _validatePaymasterPrepayment(opIndex, userOp, outOpInfo, requiredPreFund, gasUsedByValidateAccountPrepayment);\n            if (paymasterDeadline != 0 && paymasterDeadline < deadline) {\n                deadline = paymasterDeadline;\n            }\n        } else {\n            context = \"\";\n\n        }\n    unchecked {\n        uint256 gasUsed = preGas - gasleft();\n\n        if (userOp.verificationGasLimit < gasUsed) {\n            revert FailedOp(opIndex, mUserOp.paymaster, \"AA40 over verificationGasLimit\");\n        }\n        outOpInfo.prefund = requiredPreFund;\n        outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n        outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n    }\n    }\n\n    /**\n     * process post-operation.\n     * called just after the callData is executed.\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\n     * the excess amount is refunded to the account (or paymaster - if it is was used in the request)\n     * @param opIndex index in the batch\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\n     * @param opInfo userOp fields and info collected during validation\n     * @param context the context returned in validatePaymasterUserOp\n     * @param actualGas the gas used so far by this user operation\n     */\n    function _handlePostOp(uint256 opIndex, IPaymaster.PostOpMode mode, UserOpInfo memory opInfo, bytes memory context, uint256 actualGas) private returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n    unchecked {\n        address refundAddress;\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n        uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n        address paymaster = mUserOp.paymaster;\n        if (paymaster == address(0)) {\n            refundAddress = mUserOp.sender;\n        } else {\n            refundAddress = paymaster;\n            if (context.length > 0) {\n                actualGasCost = actualGas * gasPrice;\n                if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                    IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost);\n                } else {\n                    // solhint-disable-next-line no-empty-blocks\n                    try IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost) {}\n                    catch Error(string memory reason) {\n                        revert FailedOp(opIndex, paymaster, reason);\n                    }\n                    catch {\n                        revert FailedOp(opIndex, paymaster, \"A50 postOp revert\");\n                    }\n                }\n            }\n        }\n        actualGas += preGas - gasleft();\n        actualGasCost = actualGas * gasPrice;\n        if (opInfo.prefund < actualGasCost) {\n            revert FailedOp(opIndex, paymaster, \"A51 prefund below actualGasCost\");\n        }\n        uint256 refund = opInfo.prefund - actualGasCost;\n        internalIncrementDeposit(refundAddress, refund);\n        bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n        emit UserOperationEvent(opInfo.userOpHash, mUserOp.sender, mUserOp.paymaster, mUserOp.nonce, success, actualGasCost, actualGas);\n    } // unchecked\n    }\n\n    /**\n     * the gas price this UserOp agrees to pay.\n     * relayer/block builder might submit the TX with higher priorityFee, but the user should not\n     */\n    function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) {\n    unchecked {\n        uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n        uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            //legacy mode (for networks that don't support basefee opcode)\n            return maxFeePerGas;\n        }\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n    }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\n        assembly {offset := data}\n    }\n\n    function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\n        assembly {data := offset}\n    }\n\n    //place the NUMBER opcode in the code.\n    // this is used as a marker during simulation, as this OP is completely banned from the simulated code of the\n    // account and paymaster.\n    function numberMarker() internal view {\n        assembly {mstore(0, number())}\n    }\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\n/* solhint-disable reason-string */\nimport \"../../BasePaymaster.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../PaymasterHelpers.sol\";\n// import \"../samples/Signatures.sol\";\n\n\n/**\n * A sample paymaster that uses external service to decide whether to pay for the UserOp.\n * The paymaster trusts an external signer to sign the transaction.\n * The calling user must pass the UserOp to that external signer first, which performs\n * whatever off-chain verification before signing the UserOp.\n * Note that this signature is NOT a replacement for wallet signature:\n * - the paymaster signs to agree to PAY for GAS.\n * - the wallet signs to prove identity and wallet ownership.\n */\ncontract VerifyingSingletonPaymaster is BasePaymaster {\n\n    using ECDSA for bytes32;\n    // possibly //  using Signatures for UserOperation;\n    using UserOperationLib for UserOperation;\n    using PaymasterHelpers for UserOperation;\n    using PaymasterHelpers for bytes;\n    using PaymasterHelpers for PaymasterData;\n\n    mapping(address => uint256) public paymasterIdBalances;\n\n    address public verifyingSigner;\n\n    constructor(IEntryPoint _entryPoint, address _verifyingSigner) BasePaymaster(_entryPoint) {\n        require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\n        require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n        verifyingSigner = _verifyingSigner;\n    }\n\n    function deposit() public virtual override payable {\n        revert(\"Deposit must be for a paymasterId. Use depositFor\");\n    }\n\n    /**\n     * add a deposit for this paymaster and given paymasterId (Dapp Depositor address), used for paying for transaction fees\n     */\n    function depositFor(address paymasterId) public payable {\n        require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n        require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n        paymasterIdBalances[paymasterId] += msg.value;\n        entryPoint.depositTo{value : msg.value}(address(this));\n    }\n\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public override {\n        uint256 currentBalance = paymasterIdBalances[msg.sender];\n        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n        paymasterIdBalances[msg.sender] -= amount;\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n    \n    /**\n    this function will let owner change signer\n    */\n    function setSigner( address _newVerifyingSigner) external onlyOwner{\n        require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n        verifyingSigner = _newVerifyingSigner;\n    }\n\n    /**\n     * return the hash we're going to sign off-chain (and validate on-chain)\n     * this method is called by the off-chain service, to sign the request.\n     * it is called on-chain from the validatePaymasterUserOp, to validate the signature.\n     * note that this signature covers all fields of the UserOperation, except the \"paymasterAndData\",\n     * which will carry the signature itself.\n     */\n    function getHash(UserOperation calldata userOp)\n    public pure returns (bytes32) {\n        //can't use userOp.hash(), since it contains also the paymasterAndData itself.\n        return keccak256(abi.encode(\n                userOp.getSender(),\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas\n            ));\n    }\n\n    /**\n     * verify our external signer signed this request.\n     * the \"paymasterAndData\" is expected to be the paymaster and a signature over the entire request params\n     */\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n    external view override returns (bytes memory context, uint256 deadline) {\n        (requiredPreFund);\n        bytes32 hash = getHash(userOp);\n\n        PaymasterData memory paymasterData = userOp.decodePaymasterData();\n        uint256 sigLength = paymasterData.signatureLength;\n\n        //ECDSA library supports both 64 and 65-byte long signatures.\n        // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n        require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n        require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n        require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n        return (userOp.paymasterContext(paymasterData), 0);\n    }\n\n    /**\n   * @dev Executes the paymaster's payment conditions\n   * @param mode tells whether the op succeeded, reverted, or if the op succeeded but cause the postOp to revert\n   * @param context payment conditions signed by the paymaster in `validatePaymasterUserOp`\n   * @param actualGasCost amount to be paid to the entry point in wei\n   */\n  function _postOp(\n    PostOpMode mode,\n    bytes calldata context,\n    uint256 actualGasCost\n  ) internal virtual override {\n    (mode);\n    // (mode,context,actualGasCost); // unused params\n    PaymasterContext memory data = context.decodePaymasterContext();\n    address extractedPaymasterId = data.paymasterId;\n    paymasterIdBalances[extractedPaymasterId] -= actualGasCost;\n  }\n\n}"
    }
  ]
}