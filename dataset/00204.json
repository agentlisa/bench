{
  "Title": "M-10: OCL_ZVE.sol::forwardYield relies on manipulable Uniswap V2 pool reserves leading to theft of funds",
  "Content": "# Issue M-10: OCL_ZVE.sol::forwardYield relies on manipulable Uniswap V2 pool reserves leading to theft of funds \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/296 \n\nThe protocol has acknowledged this issue.\n\n## Found by \n0xpiken, 0xvj, AllTooWell, Audinarey, DPS, Drynooo, JigglypuffAndPikachu, Maniacs, SilverChariot, cergyk, lemonmon, saidam017, t0x1c\n## Summary\n\n`OCL_ZVE.sol::forwardYield` is used to forward yield in excess of the basis but it relies on Uniswap V2 pools that can be manipulable by an attacker to set `basis` to a very small amount and steal funds.\n\n## Vulnerability Detail\n\n`fetchBasis` is a function which returns the amount of pairAsset (USDC) which is claimable by burning the balance of LP tokens of OCL_ZVE\n\n`fetchBasis` is called first in `forwardYield` in order to determine the yield to distribute:\n\n[OCL_ZVE.sol#L301-L303](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L301-L303)\n```solidity\n>>    (uint256 amount, uint256 lp) = fetchBasis();\n        if (amount > basis) { _forwardYield(amount, lp); }\n        (basis,) = fetchBasis();\n```\n\nIf the returned `amount` is `<= basis` (negative yield) no yield is forwarded and basis is updated to the low `amount` value \n\nBy manipulating the Uniswap V2 pool with a flashloan, an attacker can get the `uint256 amount` value to be returned by `OCL_ZVE.sol::fetchBasis` to be very small and set `basis` to this very small value:\n\n[OCL_ZVE.sol#L301-L303](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L301-L303)\n```solidity\n        if (amount > basis) { _forwardYield(amount, lp); }\n>>      (basis,) = fetchBasis();\n```\n\nThe next call (30 days later) to `OCL_ZVE.sol::forwardYield` will forward much more yield (in excess of `basis`) than it should, leading to a loss of funds for the protocol.\n\n### Scenario\n\n1. Attacker buys a very large amount of USDC in the Uniswap V2 pool `ZVE/pairAsset` (can use a flash-loan if needed)\n2. Attacker calls `OCL_ZVE.sol::forwardYield`\n  - `OCL_ZVE.sol::fetchBasis` returns an incorrect and very small value for `amount`:\n  -  No yield is forwarded since `amount < basis`\n  - `OCL_ZVE.sol::forwardYield` sets `basis` to `amount`\n3. Attacker backruns the calls to `OCL_ZVE.sol::forwardYield` with the sell of his large buy in the Uniswap V2 pool\n4. 30 days later, Attacker calls `OCL_ZVE.sol::forwardYield` and steal funds in excess of `basis`\n\n## Impact\n\nLoss of funds for the protocol.\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L302-L303\n- https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L311-L330\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider reverting during a call to `forwardYield` if `amount <= basis`\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> medium, allows to distribute almost entire principal as if it's yield, leaving the locker with almost no funds. Since `forwardYield` will usually be called by keepers, who will use flashbots thus making frontrunning out of scope, this is medium. User can still call `forwardYield` but only if keeper didn't call it in the 12 hours prior to end of period, so this requires additional conditions.\n\n\n\n**panprog**\n\nKeeping this medium, because `forwardYield` can still be called by user in some circumstances, thus making the attack possible. Even though the distribution is within the protocol, it still distributes inflated amounts to tranches and/or residual recepients, causing accounting issues for the protocol.\n\n**panprog**\n\nSponsor response:\n> it's protected by keeper calls for 12 hours prior and if not allows public accessibility, obviously mev-mitiation is implemented with front-running in mind and then allows public accessibility, intended functionality\n\n**panprog**\n\nIt is still possible that user calls this with front-running, even though the probability is very low (keeper has to be down for 12 hours, there might be high network congestion for 12+ hours with keeper being unable to submit transaction due to high gas price etc). This is Medium by Sherlock rules (possible, but very low probability of happening).\n\n**spacegliderrrr**\n\nEscalate\n\nAccording to Sherlock rules, admins (keepers in this case) are expected to behave properly and not miss their 12hrs window to call this function. Furthermore, this issue would require keepers to miss the 12hrs window 2 months in a row (as if it just happens only once, issue can be mitigated the following month). Issue should be low.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> According to Sherlock rules, admins (keepers in this case) are expected to behave properly and not miss their 12hrs window to call this function. Furthermore, this issue would require keepers to miss the 12hrs window 2 months in a row (as if it just happens only once, issue can be mitigated the following month). Issue should be low.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ZdravkoHr**\n\nWhy is it required that keepers don't call it 2 times?\n\n**spacegliderrrr**\n\nFirst time, it would simply not distribute yield (and set basis to very low value). Next month if keepers call it, they can adjust it so it distributes just the right amount. \n\nIf only 1 attack call is made, biggest impact is rolling over the yield for next month (but it is not lost in any way).\n\n**ZdravkoHr**\n\nCan't the amount be manipulated in the opposite direction instead to cause distribution on the first call?\n\n**panprog**\n\nThe keeper might be down for factors outside of admin control, so I can't consider \"calling within 12 hours\" a proper keeper behaviour.\nThe remark about 2 calls is incorrect: only 1 is enough. For example, current basis = 10. User manipulates basis to be 1. During the next distribution user doesn't have to manipulate it, normal distribution will happen with current basis = 10 (or whatever is current basis) and distribute most of the funds as if it's yield.\n\n**panprog**\n\n> Can't the amount be manipulated in the opposite direction instead to cause distribution on the first call?\n\nIt's possible, but attacker will lose a lot of funds for such manipulation, so it's very costly to do so, reduction of basis is almost free for attacker, causing the same/bigger impact just later.\n\n**WangSecurity**\n\nFirstly, I agree that keeper is indeed may be down and miss the call to `forwardYield`. The probability is low, but as I understand, only one missed call by the keeper is enough for this scenario to occur, leading to a loss of funds for the protocol. Hence, I believe medium is appropriate.\n\nPlanning to reject the escalation and leave the issue as it is. \n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [spacegliderrrr](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/296/#issuecomment-2105744997): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IFactory_OCL_ZVE {\n    /// @notice Returns the address of the pair for tokenA and tokenB, if it has been created, else address(0).\n    /// @param tokenA Address of one of pair's tokens.\n    /// @param tokenB Address of pair's other token.\n    /// @return pair The address of the pair.\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IRouter_OCL_ZVE {\n    /// @notice Adds liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param amountADesired Amount tokenA to add as liquidity if B/A <= amountBDesired/amountADesired (A depreciates).\n    /// @param amountBDesired Amount tokenB to add as liquidity if A/B <= amountADesired/amountBDesired (B depreciates).\n    /// @param amountAMin Bounds B/A price max before the transaction reverts. Must be <= amountADesired.\n    /// @param amountBMin Bounds A/B price max before the transaction reverts. Must be <= amountBDesired.\n    /// @param to Recipient of the liquidity tokens.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA sent to the pool.\n    /// @return amountB The amount of tokenB sent to the pool.\n    /// @return liquidity The amount of liquidity tokens minted.\n    function addLiquidity(\n        address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    /// @notice Removes liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param liquidity The amount of liquidity tokens to remove.\n    /// @param amountAMin The minimum amount of tokenA that must be received for the transaction not to revert.\n    /// @param amountBMin The minimum amount of tokenB that must be received for the transaction not to revert.\n    /// @param to Recipient of the underlying assets.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA received.\n    /// @return amountB The amount of tokenB received.\n    function removeLiquidity(\n        address tokenA, address tokenB, uint256 liquidity, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n\ninterface IZivoeGlobals_OCL_ZVE {\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeYDL contract.\n    function YDL() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeToken contract.\n    function ZVE() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns true if an address is whitelisted as a keeper.\n    function isKeeper(address) external view returns (bool);\n}\n\ninterface IZivoeYDL_OCL_ZVE {\n    /// @notice Returns the \"stablecoin\" that will be distributed via YDL.\n    /// @return asset The address of the \"stablecoin\" that will be distributed via YDL.\n    function distributedAsset() external view returns (address asset);\n}\n\n\n/// @notice This contract manages liquidity provisioning for a Uniswap v2 or Sushi pool.\n///         This contract has the following responsibilities:\n///           - Allocate capital to a $ZVE/pairAsset pool.\n///           - Remove capital from a $ZVE/pairAsset pool.\n///           - Forward yield (profits) every 30 days to the YDL with compounding mechanisms.\ncontract OCL_ZVE is ZivoeLocker, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    \n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;               /// @dev The ZivoeGlobals contract.\n    address public immutable factory;           /// @dev Address for the Factory (Uniswap v2 or Sushi).\n    address public immutable pairAsset;         /// @dev ERC20 that will be paired with $ZVE for Sushi pool.\n    address public immutable router;            /// @dev Address for the Router (Uniswap v2 or Sushi).\n\n    address public OCT_YDL;                     /// @dev Facilitates swaps and forwards distributedAsset() to YDL.\n    \n    uint256 public basis;                       /// @dev The basis used for forwardYield() accounting.\n    uint256 public compoundingRateBIPS = 5000;  /// @dev The % of returns to retain, in BIPS.\n    uint256 public nextYieldDistribution;       /// @dev Determines next available forwardYield() call.\n\n    uint256 private constant BIPS = 10000;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCL_ZVE contract.\n    /// @param DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param _GBL The ZivoeGlobals contract.\n    /// @param _pairAsset ERC20 that will be paired with $ZVE for pool.\n    /// @param  _OCT_YDL The contract that facilitates swaps and forwards distributedAsset() to YDL.\n    constructor(address DAO, address _GBL, address _pairAsset, address _router, address _factory, address _OCT_YDL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n        pairAsset = _pairAsset;\n        router = _router;\n        factory = _factory;\n        OCT_YDL = _OCT_YDL;\n    }\n\n\n\n    // ------------\n    //    Events   \n    // ------------\n\n    /// @notice Emitted during pullFromLocker() and pullFromLockerPartial() and _forwardYield() [via forwardYield()].\n    /// @param  amountBurned Amount of liquidity tokens burned.\n    /// @param  claimedZVE Amount of ZVE claimed.\n    /// @param  claimedPairAsset Amount of pairAsset claimed.\n    event LiquidityTokensBurned(uint256 amountBurned, uint256 claimedZVE, uint256 claimedPairAsset);\n\n    /// @notice Emitted during pushToLockerMulti().\n    /// @param  amountMinted Amount of liquidity tokens minted.\n    /// @param  depositedZVE Amount of ZVE deposited.\n    /// @param  depositedPairAsset Amount of pairAsset deposited.\n    event LiquidityTokensMinted(uint256 amountMinted, uint256 depositedZVE, uint256 depositedPairAsset);\n\n    /// @notice Emitted during updateCompoundingRateBIPS().\n    /// @param  oldValue The old value of compoundingRateBIPS.\n    /// @param  newValue The new value of compoundingRateBIPS.\n    event UpdatedCompoundingRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateOCTYDL().\n    /// @param  newOCT The new OCT_YDL contract.\n    /// @param  oldOCT The old OCT_YDL contract.\n    event UpdatedOCTYDL(address indexed newOCT, address indexed oldOCT);\n\n    /// @notice Emitted during forwardYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  amount The amount distributed.\n    event YieldForwarded(address indexed asset, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLockerMulti().\n    function canPushMulti() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice This pulls capital from the DAO and adds liquidity into a $ZVE/pairAsset pool.\n    /// @param  assets The assets to pull from the DAO.\n    /// @param  amounts The amount to pull of each asset respectively.\n    /// @param  data Accompanying transaction data.\n    function pushToLockerMulti(\n        address[] calldata assets, uint256[] calldata amounts, bytes[] calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        require(\n            assets[0] == pairAsset && assets[1] == ZVE,\n            \"OCL_ZVE::pushToLockerMulti() assets[0] != pairAsset || assets[1] != ZVE\"\n        );\n\n        for (uint256 i = 0; i < 2; i++) {\n            require(amounts[i] >= 10 * 10**6, \"OCL_ZVE::pushToLockerMulti() amounts[i] < 10 * 10**6\");\n            IERC20(assets[i]).safeTransferFrom(owner(), address(this), amounts[i]);\n        }\n\n        if (nextYieldDistribution == 0) { nextYieldDistribution = block.timestamp + 30 days; }\n\n        uint256 preBasis;\n        if (basis != 0) { (preBasis,) = fetchBasis(); }\n\n        // Router addLiquidity() endpoint.\n        uint balPairAsset = IERC20(pairAsset).balanceOf(address(this));\n        uint balZVE = IERC20(ZVE).balanceOf(address(this));\n        IERC20(pairAsset).safeIncreaseAllowance(router, balPairAsset);\n        IERC20(ZVE).safeIncreaseAllowance(router, balZVE);\n\n        // Prevent volatility of greater than 10% in pool relative to amounts present.\n        (uint256 depositedPairAsset, uint256 depositedZVE, uint256 minted) = IRouter_OCL_ZVE(router).addLiquidity(\n            pairAsset, \n            ZVE, \n            balPairAsset,\n            balZVE, \n            (balPairAsset * 9) / 10,\n            (balZVE * 9) / 10, \n            address(this), block.timestamp + 14 days\n        );\n        emit LiquidityTokensMinted(minted, depositedZVE, depositedPairAsset);\n        assert(IERC20(pairAsset).allowance(address(this), router) == 0);\n        assert(IERC20(ZVE).allowance(address(this), router) == 0);\n\n        // Increase basis by difference.\n        (uint256 postBasis,) = fetchBasis();\n        require(postBasis > preBasis, \"OCL_ZVE::pushToLockerMulti() postBasis <= preBasis\");\n        basis += postBasis - preBasis;\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLocker(address asset, bytes calldata data) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            uint256 preBalLPToken = IERC20(pair).balanceOf(address(this));\n            IERC20(pair).safeIncreaseAllowance(router, preBalLPToken);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, preBalLPToken, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(preBalLPToken, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n\n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            basis = 0;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), IERC20(asset).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  amount The amount of \"asset\" to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLockerPartial(\n        address asset, uint256 amount, bytes calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            (uint256 preBasis,) = fetchBasis();\n            IERC20(pair).safeIncreaseAllowance(router, amount);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, amount, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(amount, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n            \n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            (uint256 postBasis,) = fetchBasis();\n            require(postBasis < preBasis, \"OCL_ZVE::pullFromLockerPartial() postBasis >= preBasis\");\n            basis -= preBasis - postBasis;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), amount);\n        }\n    }\n\n    /// @notice This forwards yield in excess of the basis.\n    function forwardYield() external {\n        if (IZivoeGlobals_OCL_ZVE(GBL).isKeeper(_msgSender())) {\n            require(\n                block.timestamp > nextYieldDistribution - 12 hours, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution - 12 hours\"\n            );\n        }\n        else {\n            require(\n                block.timestamp > nextYieldDistribution, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution\"\n            );\n        }\n\n        (uint256 amount, uint256 lp) = fetchBasis();\n        if (amount > basis) { _forwardYield(amount, lp); }\n        (basis,) = fetchBasis();\n        nextYieldDistribution += 30 days;\n    }\n\n    /// @notice This forwards yield to the YDL in the form of pairAsset.\n    /// @dev    Private function, only callable via forwardYield().\n    /// @param  amount Current pairAsset harvestable.\n    /// @param  lp Current ZVE/pairAsset LP tokens.\n    function _forwardYield(uint256 amount, uint256 lp) private nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        uint256 lpBurnable = (amount - basis) * lp / amount * (BIPS - compoundingRateBIPS) / BIPS;\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        IERC20(pair).safeIncreaseAllowance(router, lpBurnable);\n        (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n            pairAsset, ZVE, lpBurnable, 0, 0, address(this), block.timestamp + 14 days\n        );\n        emit LiquidityTokensBurned(lpBurnable, claimedZVE, claimedPairAsset);\n        assert(IERC20(pair).allowance(address(this), router) == 0);\n        uint balPairAsset = IERC20(pairAsset).balanceOf(address(this));\n        emit YieldForwarded(pairAsset, balPairAsset);\n        if (pairAsset != IZivoeYDL_OCL_ZVE(IZivoeGlobals_OCL_ZVE(GBL).YDL()).distributedAsset()) {\n            IERC20(pairAsset).safeTransfer(OCT_YDL, balPairAsset);\n        }\n        else {\n            IERC20(pairAsset).safeTransfer(IZivoeGlobals_OCL_ZVE(GBL).YDL(), balPairAsset);\n        }\n        IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n    }\n\n    /// @notice Returns amount of pairAsset redeemable with current LP position.\n    /// @dev    The withdrawal mechanism is ZVE/pairAsset_LP => pairAsset.\n    /// @return amount Current pairAsset harvestable.\n    /// @return lp Current ZVE/pairAsset LP tokens.\n    function fetchBasis() public view returns (uint256 amount, uint256 lp) {\n        address pool = IFactory_OCL_ZVE(factory).getPair(pairAsset, IZivoeGlobals_OCL_ZVE(GBL).ZVE());\n        uint256 pairAssetBalance = IERC20(pairAsset).balanceOf(pool);\n        uint256 poolTotalSupply = IERC20(pool).totalSupply();\n        lp = IERC20(pool).balanceOf(address(this));\n        amount = lp * pairAssetBalance / poolTotalSupply;\n    }\n\n    /// @notice Updates the compounding rate of this contract.\n    /// @dev    A value of 2,000 represent 20% of the earnings stays in this contract, compounding.\n    /// @param  _compoundingRateBIPS The new compounding rate value.\n    function updateCompoundingRateBIPS(uint256 _compoundingRateBIPS) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCL_ZVE(GBL).TLC(), \n            \"OCL_ZVE::updateCompoundingRateBIPS() _msgSender() != IZivoeGlobals_OCL_ZVE(GBL).TLC()\"\n        );\n        require(_compoundingRateBIPS <= BIPS, \"OCL_ZVE::updateCompoundingRateBIPS() ratio > BIPS\");\n\n        emit UpdatedCompoundingRateBIPS(compoundingRateBIPS, _compoundingRateBIPS);\n        compoundingRateBIPS = _compoundingRateBIPS;\n    }\n\n    /// @notice Update the OCT_YDL endpoint.\n    /// @dev    This function MUST only be called by ZVL().\n    /// @param  _OCT_YDL The new address for OCT_YDL.\n    function updateOCTYDL(address _OCT_YDL) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCL_ZVE(GBL).ZVL(), \n            \"OCL_ZVE::updateOCTYDL() _msgSender() != IZivoeGlobals_OCL_ZVE(GBL).ZVL()\"\n        );\n        require(_OCT_YDL != address(0), \"OCL_ZVE::updateOCTYDL() _OCT_YDL == address(0)\");\n        emit UpdatedOCTYDL(_OCT_YDL, OCT_YDL);\n        OCT_YDL = _OCT_YDL;\n    }\n    \n}"
    },
    {
      "filename": "zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IFactory_OCL_ZVE {\n    /// @notice Returns the address of the pair for tokenA and tokenB, if it has been created, else address(0).\n    /// @param tokenA Address of one of pair's tokens.\n    /// @param tokenB Address of pair's other token.\n    /// @return pair The address of the pair.\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IRouter_OCL_ZVE {\n    /// @notice Adds liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param amountADesired Amount tokenA to add as liquidity if B/A <= amountBDesired/amountADesired (A depreciates).\n    /// @param amountBDesired Amount tokenB to add as liquidity if A/B <= amountADesired/amountBDesired (B depreciates).\n    /// @param amountAMin Bounds B/A price max before the transaction reverts. Must be <= amountADesired.\n    /// @param amountBMin Bounds A/B price max before the transaction reverts. Must be <= amountBDesired.\n    /// @param to Recipient of the liquidity tokens.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA sent to the pool.\n    /// @return amountB The amount of tokenB sent to the pool.\n    /// @return liquidity The amount of liquidity tokens minted.\n    function addLiquidity(\n        address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    /// @notice Removes liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param liquidity The amount of liquidity tokens to remove.\n    /// @param amountAMin The minimum amount of tokenA that must be received for the transaction not to revert.\n    /// @param amountBMin The minimum amount of tokenB that must be received for the transaction not to revert.\n    /// @param to Recipient of the underlying assets.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA received.\n    /// @return amountB The amount of tokenB received.\n    function removeLiquidity(\n        address tokenA, address tokenB, uint256 liquidity, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n\ninterface IZivoeGlobals_OCL_ZVE {\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeYDL contract.\n    function YDL() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeToken contract.\n    function ZVE() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns true if an address is whitelisted as a keeper.\n    function isKeeper(address) external view returns (bool);\n}\n\ninterface IZivoeYDL_OCL_ZVE {\n    /// @notice Returns the \"stablecoin\" that will be distributed via YDL.\n    /// @return asset The address of the \"stablecoin\" that will be distributed via YDL.\n    function distributedAsset() external view returns (address asset);\n}\n\n\n/// @notice This contract manages liquidity provisioning for a Uniswap v2 or Sushi pool.\n///         This contract has the following responsibilities:\n///           - Allocate capital to a $ZVE/pairAsset pool.\n///           - Remove capital from a $ZVE/pairAsset pool.\n///           - Forward yield (profits) every 30 days to the YDL with compounding mechanisms.\ncontract OCL_ZVE is ZivoeLocker, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    \n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;               /// @dev The ZivoeGlobals contract.\n    address public immutable factory;           /// @dev Address for the Factory (Uniswap v2 or Sushi).\n    address public immutable pairAsset;         /// @dev ERC20 that will be paired with $ZVE for Sushi pool.\n    address public immutable router;            /// @dev Address for the Router (Uniswap v2 or Sushi).\n\n    address public OCT_YDL;                     /// @dev Facilitates swaps and forwards distributedAsset() to YDL.\n    \n    uint256 public basis;                       /// @dev The basis used for forwardYield() accounting.\n    uint256 public compoundingRateBIPS = 5000;  /// @dev The % of returns to retain, in BIPS.\n    uint256 public nextYieldDistribution;       /// @dev Determines next available forwardYield() call.\n\n    uint256 private constant BIPS = 10000;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCL_ZVE contract.\n    /// @param DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param _GBL The ZivoeGlobals contract.\n    /// @param _pairAsset ERC20 that will be paired with $ZVE for pool.\n    /// @param  _OCT_YDL The contract that facilitates swaps and forwards distributedAsset() to YDL.\n    constructor(address DAO, address _GBL, address _pairAsset, address _router, address _factory, address _OCT_YDL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n        pairAsset = _pairAsset;\n        router = _router;\n        factory = _factory;\n        OCT_YDL = _OCT_YDL;\n    }\n\n\n\n    // ------------\n    //    Events   \n    // ------------\n\n    /// @notice Emitted during pullFromLocker() and pullFromLockerPartial() and _forwardYield() [via forwardYield()].\n    /// @param  amountBurned Amount of liquidity tokens burned.\n    /// @param  claimedZVE Amount of ZVE claimed.\n    /// @param  claimedPairAsset Amount of pairAsset claimed.\n    event LiquidityTokensBurned(uint256 amountBurned, uint256 claimedZVE, uint256 claimedPairAsset);\n\n    /// @notice Emitted during pushToLockerMulti().\n    /// @param  amountMinted Amount of liquidity tokens minted.\n    /// @param  depositedZVE Amount of ZVE deposited.\n    /// @param  depositedPairAsset Amount of pairAsset deposited.\n    event LiquidityTokensMinted(uint256 amountMinted, uint256 depositedZVE, uint256 depositedPairAsset);\n\n    /// @notice Emitted during updateCompoundingRateBIPS().\n    /// @param  oldValue The old value of compoundingRateBIPS.\n    /// @param  newValue The new value of compoundingRateBIPS.\n    event UpdatedCompoundingRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateOCTYDL().\n    /// @param  newOCT The new OCT_YDL contract.\n    /// @param  oldOCT The old OCT_YDL contract.\n    event UpdatedOCTYDL(address indexed newOCT, address indexed oldOCT);\n\n    /// @notice Emitted during forwardYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  amount The amount distributed.\n    event YieldForwarded(address indexed asset, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLockerMulti().\n    function canPushMulti() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice This pulls capital from the DAO and adds liquidity into a $ZVE/pairAsset pool.\n    /// @param  assets The assets to pull from the DAO.\n    /// @param  amounts The amount to pull of each asset respectively.\n    /// @param  data Accompanying transaction data.\n    function pushToLockerMulti(\n        address[] calldata assets, uint256[] calldata amounts, bytes[] calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        require(\n            assets[0] == pairAsset && assets[1] == ZVE,\n            \"OCL_ZVE::pushToLockerMulti() assets[0] != pairAsset || assets[1] != ZVE\"\n        );\n\n        for (uint256 i = 0; i < 2; i++) {\n            require(amounts[i] >= 10 * 10**6, \"OCL_ZVE::pushToLockerMulti() amounts[i] < 10 * 10**6\");\n            IERC20(assets[i]).safeTransferFrom(owner(), address(this), amounts[i]);\n        }\n\n        if (nextYieldDistribution == 0) { nextYieldDistribution = block.timestamp + 30 days; }\n\n        uint256 preBasis;\n        if (basis != 0) { (preBasis,) = fetchBasis(); }\n\n        // Router addLiquidity() endpoint.\n        uint balPairAsset = IERC20(pairAsset).balanceOf(address(this));\n        uint balZVE = IERC20(ZVE).balanceOf(address(this));\n        IERC20(pairAsset).safeIncreaseAllowance(router, balPairAsset);\n        IERC20(ZVE).safeIncreaseAllowance(router, balZVE);\n\n        // Prevent volatility of greater than 10% in pool relative to amounts present.\n        (uint256 depositedPairAsset, uint256 depositedZVE, uint256 minted) = IRouter_OCL_ZVE(router).addLiquidity(\n            pairAsset, \n            ZVE, \n            balPairAsset,\n            balZVE, \n            (balPairAsset * 9) / 10,\n            (balZVE * 9) / 10, \n            address(this), block.timestamp + 14 days\n        );\n        emit LiquidityTokensMinted(minted, depositedZVE, depositedPairAsset);\n        assert(IERC20(pairAsset).allowance(address(this), router) == 0);\n        assert(IERC20(ZVE).allowance(address(this), router) == 0);\n\n        // Increase basis by difference.\n        (uint256 postBasis,) = fetchBasis();\n        require(postBasis > preBasis, \"OCL_ZVE::pushToLockerMulti() postBasis <= preBasis\");\n        basis += postBasis - preBasis;\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLocker(address asset, bytes calldata data) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            uint256 preBalLPToken = IERC20(pair).balanceOf(address(this));\n            IERC20(pair).safeIncreaseAllowance(router, preBalLPToken);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, preBalLPToken, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(preBalLPToken, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n\n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            basis = 0;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), IERC20(asset).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  amount The amount of \"asset\" to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLockerPartial(\n        address asset, uint256 amount, bytes calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            (uint256 preBasis,) = fetchBasis();\n            IERC20(pair).safeIncreaseAllowance(router, amount);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, amount, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(amount, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n            \n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            (uint256 postBasis,) = fetchBasis();\n            require(postBasis < preBasis, \"OCL_ZVE::pullFromLockerPartial() postBasis >= preBasis\");\n            basis -= preBasis - postBasis;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), amount);\n        }\n    }\n\n    /// @notice This forwards yield in excess of the basis.\n    function forwardYield() external {\n        if (IZivoeGlobals_OCL_ZVE(GBL).isKeeper(_msgSender())) {\n            require(\n                block.timestamp > nextYieldDistribution - 12 hours, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution - 12 hours\"\n            );\n        }\n        else {\n            require(\n                block.timestamp > nextYieldDistribution, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution\"\n            );\n        }\n\n        (uint256 amount, uint256 lp) = fetchBasis();\n        if (amount > basis) { _forwardYield(amount, lp); }\n        (basis,) = fetchBasis();\n        nextYieldDistribution += 30 days;\n    }\n\n    /// @notice This forwards yield to the YDL in the form of pairAsset.\n    /// @dev    Private function, only callable via forwardYield().\n    /// @param  amount Current pairAsset harvestable.\n    /// @param  lp Current ZVE/pairAsset LP tokens.\n    function _forwardYield(uint256 amount, uint256 lp) private nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        uint256 lpBurnable = (amount - basis) * lp / amount * (BIPS - compoundingRateBIPS) / BIPS;\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        IERC20(pair).safeIncreaseAllowance(router, lpBurnable);\n        (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n            pairAsset, ZVE, lpBurnable, 0, 0, address(this), b"
    }
  ]
}