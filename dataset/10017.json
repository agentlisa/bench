{
  "Title": "[H-03] A Malicious Treasury Manager Can Burn Treasury Tokens By Setting `makerFee` To The Amount The Maker Receives",
  "Content": "_Submitted by leastwood_\n\nThe treasury manager contract holds harvested assets/`COMP` from Notional which are used to perform `NOTE` buybacks or in other areas of the protocol. The manager account is allowed to sign off-chain orders used on 0x to exchange tokens to `WETH` which can then be deposited in the Balancer LP and distributed to `sNOTE` holders.\n\nHowever, `_validateOrder` does not validate that `takerFee` and `makerFee` are set to zero, hence, it is possible for a malicious manager to receive tokens as part of a swap, but the treasury manager contract receives zero tokens as `makerFee` is set to the amount the maker receives. This can be abused to effectively burn treasury tokens at no cost to the order taker.\n\n#### Proof of Concept\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250>\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibFillResults.sol#L59-L91>\n\n<https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188>\n```solidity\nfunction _validateOrder(bytes memory order) private view {\n    (\n        address makerToken,\n        address takerToken,\n        address feeRecipient,\n        uint256 makerAmount,\n        uint256 takerAmount\n    ) = _extractOrderInfo(order);\n\n    // No fee recipient allowed\n    require(feeRecipient == address(0), \"no fee recipient allowed\");\n\n    // MakerToken should never be WETH\n    require(makerToken != address(WETH), \"maker token must not be WETH\");\n\n    // TakerToken (proceeds) should always be WETH\n    require(takerToken == address(WETH), \"taker token must be WETH\");\n\n    address priceOracle = priceOracles[makerToken];\n\n    // Price oracle not defined\n    require(priceOracle != address(0), \"price oracle not defined\");\n\n    uint256 slippageLimit = slippageLimits[makerToken];\n\n    // Slippage limit not defined\n    require(slippageLimit != 0, \"slippage limit not defined\");\n\n    uint256 oraclePrice = _toUint(\n        AggregatorV2V3Interface(priceOracle).latestAnswer()\n    );\n\n    uint256 priceFloor = (oraclePrice * slippageLimit) /\n        SLIPPAGE_LIMIT_PRECISION;\n\n    uint256 makerDecimals = 10**ERC20(makerToken).decimals();\n\n    // makerPrice = takerAmount / makerAmount\n    uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;\n\n    require(makerPrice >= priceFloor, \"slippage is too high\");\n}\n```\n\n#### Recommended Mitigation Steps\n\nConsider checking that `makerFee == 0` and `takerFee == 0` in `EIP1271Wallet._validateOrder` s.t. the treasury manager cannot sign unfair orders which severely impact the `TreasuryManager` contract.\n\n**[jeffywu (Notional) confirmed and commented](https://github.com/code-423n4/2022-01-notional-findings/issues/230#issuecomment-1030839051):**\n > Confirmed, we will fix this.\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/230#issuecomment-1041560475):**\n > Good job warden for identifying this issue with 0x integration.\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-01-notional",
  "Code": [
    {
      "filename": "contracts/exchange/contracts/src/MixinExchangeCore.sol",
      "content": "/*\n\n  Copyright 2019 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\npragma solidity ^0.5.9;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-utils/contracts/src/LibBytes.sol\";\nimport \"@0x/contracts-utils/contracts/src/LibRichErrors.sol\";\nimport \"@0x/contracts-utils/contracts/src/LibSafeMath.sol\";\nimport \"@0x/contracts-utils/contracts/src/Refundable.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibFillResults.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibMath.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibOrder.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibEIP712ExchangeDomain.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibExchangeRichErrors.sol\";\nimport \"./interfaces/IExchangeCore.sol\";\nimport \"./MixinAssetProxyDispatcher.sol\";\nimport \"./MixinProtocolFees.sol\";\nimport \"./MixinSignatureValidator.sol\";\n\n\ncontract MixinExchangeCore is\n    IExchangeCore,\n    Refundable,\n    LibEIP712ExchangeDomain,\n    MixinAssetProxyDispatcher,\n    MixinProtocolFees,\n    MixinSignatureValidator\n{\n    using LibOrder for LibOrder.Order;\n    using LibSafeMath for uint256;\n    using LibBytes for bytes;\n\n    /// @dev Mapping of orderHash => amount of takerAsset already bought by maker\n    /// @param 0 Order hash.\n    /// @return 0 The amount of taker asset filled.\n    mapping (bytes32 => uint256) public filled;\n\n    /// @dev Mapping of orderHash => cancelled\n    /// @param 0 Order hash.\n    /// @return 0 Whether the order was cancelled.\n    mapping (bytes32 => bool) public cancelled;\n\n    /// @dev Mapping of makerAddress => senderAddress => lowest salt an order can have in order to be fillable\n    ///      Orders with specified senderAddress and with a salt less than their epoch are considered cancelled\n    /// @param 0 Address of the order's maker.\n    /// @param 1 Address of the order's sender.\n    /// @return 0 Minimum valid order epoch.\n    mapping (address => mapping (address => uint256)) public orderEpoch;\n\n    /// @dev Cancels all orders created by makerAddress with a salt less than or equal to the targetOrderEpoch\n    ///      and senderAddress equal to msg.sender (or null address if msg.sender == makerAddress).\n    /// @param targetOrderEpoch Orders created with a salt less or equal to this value will be cancelled.\n    function cancelOrdersUpTo(uint256 targetOrderEpoch)\n        external\n        payable\n        refundFinalBalanceNoReentry\n    {\n        address makerAddress = _getCurrentContextAddress();\n        // If this function is called via `executeTransaction`, we only update the orderEpoch for the makerAddress/msg.sender combination.\n        // This allows external filter contracts to add rules to how orders are cancelled via this function.\n        address orderSenderAddress = makerAddress == msg.sender ? address(0) : msg.sender;\n\n        // orderEpoch is initialized to 0, so to cancelUpTo we need salt + 1\n        uint256 newOrderEpoch = targetOrderEpoch + 1;\n        uint256 oldOrderEpoch = orderEpoch[makerAddress][orderSenderAddress];\n\n        // Ensure orderEpoch is monotonically increasing\n        if (newOrderEpoch <= oldOrderEpoch) {\n            LibRichErrors.rrevert(LibExchangeRichErrors.OrderEpochError(\n                makerAddress,\n                orderSenderAddress,\n                oldOrderEpoch\n            ));\n        }\n\n        // Update orderEpoch\n        orderEpoch[makerAddress][orderSenderAddress] = newOrderEpoch;\n        emit CancelUpTo(\n            makerAddress,\n            orderSenderAddress,\n            newOrderEpoch\n        );\n    }\n\n    /// @dev Fills the input order.\n    /// @param order Order struct containing order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signature Proof that order has been created by maker.\n    /// @return fillResults Amounts filled and fees paid by maker and taker.\n    function fillOrder(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        public\n        payable\n        refundFinalBalanceNoReentry\n        returns (LibFillResults.FillResults memory fillResults)\n    {\n        fillResults = _fillOrder(\n            order,\n            takerAssetFillAmount,\n            signature\n        );\n        return fillResults;\n    }\n\n    /// @dev After calling, the order can not be filled anymore.\n    /// @param order Order struct containing order specifications.\n    function cancelOrder(LibOrder.Order memory order)\n        public\n        payable\n        refundFinalBalanceNoReentry\n    {\n        _cancelOrder(order);\n    }\n\n    /// @dev Gets information about an order: status, hash, and amount filled.\n    /// @param order Order to gather information on.\n    /// @return orderInfo Information about the order and its state.\n    ///         See LibOrder.OrderInfo for a complete description.\n    function getOrderInfo(LibOrder.Order memory order)\n        public\n        view\n        returns (LibOrder.OrderInfo memory orderInfo)\n    {\n        // Compute the order hash and fetch the amount of takerAsset that has already been filled\n        (orderInfo.orderHash, orderInfo.orderTakerAssetFilledAmount) = _getOrderHashAndFilledAmount(order);\n\n        // If order.makerAssetAmount is zero, we also reject the order.\n        // While the Exchange contract handles them correctly, they create\n        // edge cases in the supporting infrastructure because they have\n        // an 'infinite' price when computed by a simple division.\n        if (order.makerAssetAmount == 0) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.INVALID_MAKER_ASSET_AMOUNT;\n            return orderInfo;\n        }\n\n        // If order.takerAssetAmount is zero, then the order will always\n        // be considered filled because 0 == takerAssetAmount == orderTakerAssetFilledAmount\n        // Instead of distinguishing between unfilled and filled zero taker\n        // amount orders, we choose not to support them.\n        if (order.takerAssetAmount == 0) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.INVALID_TAKER_ASSET_AMOUNT;\n            return orderInfo;\n        }\n\n        // Validate order availability\n        if (orderInfo.orderTakerAssetFilledAmount >= order.takerAssetAmount) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.FULLY_FILLED;\n            return orderInfo;\n        }\n\n        // Validate order expiration\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp >= order.expirationTimeSeconds) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.EXPIRED;\n            return orderInfo;\n        }\n\n        // Check if order has been cancelled\n        if (cancelled[orderInfo.orderHash]) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.CANCELLED;\n            return orderInfo;\n        }\n        if (orderEpoch[order.makerAddress][order.senderAddress] > order.salt) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.CANCELLED;\n            return orderInfo;\n        }\n\n        // All other statuses are ruled out: order is Fillable\n        orderInfo.orderStatus = LibOrder.OrderStatus.FILLABLE;\n        return orderInfo;\n    }\n\n    /// @dev Fills the input order.\n    /// @param order Order struct containing order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signature Proof that order has been created by maker.\n    /// @return fillResults Amounts filled and fees paid by maker and taker.\n    function _fillOrder(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        internal\n        returns (LibFillResults.FillResults memory fillResults)\n    {\n        // Fetch order info\n        LibOrder.OrderInfo memory orderInfo = getOrderInfo(order);\n\n        // Fetch taker address\n        address takerAddress = _getCurrentContextAddress();\n\n        // Assert that the order is fillable by taker\n        _assertFillableOrder(\n            order,\n            orderInfo,\n            takerAddress,\n            signature\n        );\n\n        // Get amount of takerAsset to fill\n        uint256 remainingTakerAssetAmount = order.takerAssetAmount.safeSub(orderInfo.orderTakerAssetFilledAmount);\n        uint256 takerAssetFilledAmount = LibSafeMath.min256(takerAssetFillAmount, remainingTakerAssetAmount);\n\n        // Compute proportional fill amounts\n        fillResults = LibFillResults.calculateFillResults(\n            order,\n            takerAssetFilledAmount,\n            protocolFeeMultiplier,\n            tx.gasprice\n        );\n\n        bytes32 orderHash = orderInfo.orderHash;\n\n        // Update exchange internal state\n        _updateFilledState(\n            order,\n            takerAddress,\n            orderHash,\n            orderInfo.orderTakerAssetFilledAmount,\n            fillResults\n        );\n\n        // Settle order\n        _settleOrder(\n            orderHash,\n            order,\n            takerAddress,\n            fillResults\n        );\n\n        return fillResults;\n    }\n\n    /// @dev After calling, the order can not be filled anymore.\n    ///      Throws if order is invalid or sender does not have permission to cancel.\n    /// @param order Order to cancel. Order must be OrderStatus.FILLABLE.\n    function _cancelOrder(LibOrder.Order memory order)\n        internal\n    {\n        // Fetch current order status\n        LibOrder.OrderInfo memory orderInfo = getOrderInfo(order);\n\n        // Validate context\n        _assertValidCancel(order, orderInfo);\n\n        // Noop if order is already unfillable\n        if (orderInfo.orderStatus != LibOrder.OrderStatus.FILLABLE) {\n            return;\n        }\n\n        // Perform cancel\n        _updateCancelledState(order, orderInfo.orderHash);\n    }\n\n    /// @dev Updates state with results of a fill order.\n    /// @param order that was filled.\n    /// @param takerAddress Address of taker who filled the order.\n    /// @param orderTakerAssetFilledAmount Amount of order already filled.\n    function _updateFilledState(\n        LibOrder.Order memory order,\n        address takerAddress,\n        bytes32 orderHash,\n        uint256 orderTakerAssetFilledAmount,\n        LibFillResults.FillResults memory fillResults\n    )\n        internal\n    {\n        // Update state\n        filled[orderHash] = orderTakerAssetFilledAmount.safeAdd(fillResults.takerAssetFilledAmount);\n\n        emit Fill(\n            order.makerAddress,\n            order.feeRecipientAddress,\n            order.makerAssetData,\n            order.takerAssetData,\n            order.makerFeeAssetData,\n            order.takerFeeAssetData,\n            orderHash,\n            takerAddress,\n            msg.sender,\n            fillResults.makerAssetFilledAmount,\n            fillResults.takerAssetFilledAmount,\n            fillResults.makerFeePaid,\n            fillResults.takerFeePaid,\n            fillResults.protocolFeePaid\n        );\n    }\n\n    /// @dev Updates state with results of cancelling an order.\n    ///      State is only updated if the order is currently fillable.\n    ///      Otherwise, updating state would have no effect.\n    /// @param order that was cancelled.\n    /// @param orderHash Hash of order that was cancelled.\n    function _updateCancelledState(\n        LibOrder.Order memory order,\n        bytes32 orderHash\n    )\n        internal\n    {\n        // Perform cancel\n        cancelled[orderHash] = true;\n\n        // Log cancel\n        emit Cancel(\n            order.makerAddress,\n            order.feeRecipientAddress,\n            order.makerAssetData,\n            order.takerAssetData,\n            msg.sender,\n            orderHash\n        );\n    }\n\n    /// @dev Validates context for fillOrder. Succeeds or throws.\n    /// @param order to be filled.\n    /// @param orderInfo OrderStatus, orderHash, and amount already filled of order.\n    /// @param takerAddress Address of order taker.\n    /// @param signature Proof that the orders was created by its maker.\n    function _assertFillableOrder(\n        LibOrder.Order memory order,\n        LibOrder.OrderInfo memory orderInfo,\n        address takerAddress,\n        bytes memory signature\n    )\n        internal\n        view\n    {\n        // An order can only be filled if its status is FILLABLE.\n        if (orderInfo.orderStatus != LibOrder.OrderStatus.FILLABLE) {\n            LibRichErrors.rrevert(LibExchangeRichErrors.OrderStatusError(\n                orderInfo.orderHash,\n                LibOrder.OrderStatus(orderInfo.orderStatus)\n            ));\n        }\n\n        // Validate sender is allowed to fill this order\n        if (order.senderAddress != address(0)) {\n            if (order.senderAddress != msg.sender) {\n                LibRichErrors.rrevert(LibExchangeRichErrors.ExchangeInvalidContextError(\n                    LibExchangeRichErrors.ExchangeContextErrorCodes.INVALID_SENDER,\n                    orderInfo.orderHash,\n                    msg.sender\n                ));\n            }\n        }\n\n        // Validate taker is allowed to fill this order\n        if (order.takerAddress != address(0)) {\n            if (order.takerAddress != takerAddress) {\n                LibRichErrors.rrevert(LibExchangeRichErrors.ExchangeInvalidContextError(\n                    LibExchangeRichErrors.ExchangeContextErrorCodes.INVALID_TAKER,\n                    orderInfo.orderHash,\n                    takerAddress\n                ));\n            }\n        }\n\n        // Validate signature\n        if (!_isValidOrderWithHashSignature(\n                order,\n                orderInfo.orderHash,\n                signature\n            )\n        ) {\n            LibRichErrors.rrevert(LibExchangeRichErrors.SignatureError(\n                LibExchangeRichErrors.SignatureErrorCodes.BAD_ORDER_SIGNATURE,\n                orderInfo.orderHash,\n                order.makerAddress,\n                signature\n            ));\n        }\n    }\n\n    /// @dev Validates context for cancelOrder. Succeeds or throws.\n    /// @param order to be cancelled.\n    /// @param orderInfo OrderStatus, orderHash, and amount already filled of order.\n    function _assertValidCancel(\n        LibOrder.Order memory order,\n        LibOrder.OrderInfo memory orderInfo\n    )\n        internal\n        view\n    {\n        // Validate sender is allowed to cancel this order\n        if (order.senderAddress != address(0)) {\n            if (order.senderAddress != msg.sender) {\n                LibRichErrors.rrevert(LibExchangeRichErrors.ExchangeInvalidContextError(\n                    LibExchangeRichErrors.ExchangeContextErrorCodes.INVALID_SENDER,\n                    orderInfo.orderHash,\n                    msg.sender\n                ));\n            }\n        }\n\n        // Validate transaction signed by maker\n        address makerAddress = _getCurrentContextAddress();\n        if (order.makerAddress != makerAddress) {\n            LibRichErrors.rrevert(LibExchangeRichErrors.ExchangeInvalidContextError(\n                LibExchangeRichErrors.ExchangeContextErrorCodes.INVALID_MAKER,\n                orderInfo.orderHash,\n                makerAddress\n            ));\n        }\n    }\n\n    /// @dev Settles an order by transferring assets between counterparties.\n    /// @param orderHash The order hash.\n    /// @param order Order struct containing order specifications.\n    /// @param takerAddress Address selling takerAsset and buying makerAsset.\n    /// @param fillResults Amounts to be filled and fees paid by maker and taker.\n    function _settleOrder(\n        bytes32 orderHash,\n        LibOrder.Order memory order,\n        address takerAddress,\n        LibFillResults.FillResults memory fillResults\n    )\n        internal\n    {\n        // Transfer taker -> maker\n        _dispatchTransferFrom(\n            orderHash,\n            order.takerAssetData,\n            takerAddress,\n            order.makerAddress,\n            fillResults.takerAssetFilledAmount\n        );\n\n        // Transfer maker -> taker\n        _dispatchTransferFrom(\n            orderHash,\n            order.makerAssetData,\n            order.makerAddress,\n            takerAddress,\n            fillResults.makerAssetFilledAmount\n        );\n\n        // Transfer taker fee -> feeRecipient\n        _dispatchTransferFrom(\n            orderHash,\n            order.takerFeeAssetData,\n            takerAddress,\n            order.feeRecipientAddress,\n            fillResults.takerFeePaid\n        );\n\n        // Transfer maker fee -> feeRecipient\n        _dispatchTransferFrom(\n            orderHash,\n            order.makerFeeAssetData,\n            order.makerAddress,\n            order.feeRecipientAddress,\n            fillResults.makerFeePaid\n        );\n\n        // Pay protocol fee\n        bool didPayProtocolFee = _paySingleProtocolFee(\n            orderHash,\n            fillResults.protocolFeePaid,\n            order.makerAddress,\n            takerAddress\n        );\n\n        // Protocol fees are not paid if the protocolFeeCollector contract is not set\n        if (!didPayProtocolFee) {\n            fillResults.protocolFeePaid = 0;\n        }\n    }\n\n    /// @dev Gets the order's hash and amount of takerAsset that has already been filled.\n    /// @param order Order struct containing order specifications.\n    /// @return The typed data hash and amount filled of the order.\n    function _getOrderHashAndFilledAmount(LibOrder.Order memory order)\n        internal\n        view\n        returns (bytes32 orderHash, uint256 orderTakerAssetFilledAmount)\n    {\n        orderHash = order.getTypedDataHash(EIP712_EXCHANGE_DOMAIN_HASH);\n        orderTakerAssetFilledAmount = filled[orderHash];\n        return (orderHash, orderTakerAssetFilledAmount);\n    }\n}"
    },
    {
      "filename": "contracts/exchange-libs/contracts/src/LibFillResults.sol",
      "content": "/*\n\n  Copyright 2019 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.9;\n\nimport \"@0x/contracts-utils/contracts/src/LibSafeMath.sol\";\nimport \"./LibMath.sol\";\nimport \"./LibOrder.sol\";\n\n\nlibrary LibFillResults {\n\n    using LibSafeMath for uint256;\n\n    struct BatchMatchedFillResults {\n        FillResults[] left;              // Fill results for left orders\n        FillResults[] right;             // Fill results for right orders\n        uint256 profitInLeftMakerAsset;  // Profit taken from left makers\n        uint256 profitInRightMakerAsset; // Profit taken from right makers\n    }\n\n    struct FillResults {\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n        uint256 makerFeePaid;            // Total amount of fees paid by maker(s) to feeRecipient(s).\n        uint256 takerFeePaid;            // Total amount of fees paid by taker to feeRecipients(s).\n        uint256 protocolFeePaid;         // Total amount of fees paid by taker to the staking contract.\n    }\n\n    struct MatchedFillResults {\n        FillResults left;                // Amounts filled and fees paid of left order.\n        FillResults right;               // Amounts filled and fees paid of right order.\n        uint256 profitInLeftMakerAsset;  // Profit taken from the left maker\n        uint256 profitInRightMakerAsset; // Profit taken from the right maker\n    }\n\n    /// @dev Calculates amounts filled and fees paid by maker and taker.\n    /// @param order to be filled.\n    /// @param takerAssetFilledAmount Amount of takerAsset that will be filled.\n    /// @param protocolFeeMultiplier The current protocol fee of the exchange contract.\n    /// @param gasPrice The gasprice of the transaction. This is provided so that the function call can continue\n    ///        to be pure rather than view.\n    /// @return fillResults Amounts filled and fees paid by maker and taker.\n    function calculateFillResults(\n        LibOrder.Order memory order,\n        uint256 takerAssetFilledAmount,\n        uint256 protocolFeeMultiplier,\n        uint256 gasPrice\n    )\n        internal\n        pure\n        returns (FillResults memory fillResults)\n    {\n        // Compute proportional transfer amounts\n        fillResults.takerAssetFilledAmount = takerAssetFilledAmount;\n        fillResults.makerAssetFilledAmount = LibMath.safeGetPartialAmountFloor(\n            takerAssetFilledAmount,\n            order.takerAssetAmount,\n            order.makerAssetAmount\n        );\n        fillResults.makerFeePaid = LibMath.safeGetPartialAmountFloor(\n            takerAssetFilledAmount,\n            order.takerAssetAmount,\n            order.makerFee\n        );\n        fillResults.takerFeePaid = LibMath.safeGetPartialAmountFloor(\n            takerAssetFilledAmount,\n            order.takerAssetAmount,\n            order.takerFee\n        );\n\n        // Compute the protocol fee that should be paid for a single fill.\n        fillResults.protocolFeePaid = gasPrice.safeMul(protocolFeeMultiplier);\n\n        return fillResults;\n    }\n\n    /// @dev Calculates fill amounts for the matched orders.\n    ///      Each order is filled at their respective price point. However, the calculations are\n    ///      carried out as though the orders are both being filled at the right order's price point.\n    ///      The profit made by the leftOrder order goes to the taker (who matched the two orders).\n    /// @param leftOrder First order to match.\n    /// @param rightOrder Second order to match.\n    /// @param leftOrderTakerAssetFilledAmount Amount of left order already filled.\n    /// @param rightOrderTakerAssetFilledAmount Amount of right order already filled.\n    /// @param protocolFeeMultiplier The current protocol fee of the exchange contract.\n    /// @param gasPrice The gasprice of the transaction. This is provided so that the function call can continue\n    ///        to be pure rather than view.\n    /// @param shouldMaximallyFillOrders A value that indicates whether or not this calculation should use\n    ///                                  the maximal fill order matching strategy.\n    /// @param matchedFillResults Amounts to fill and fees to pay by maker and taker of matched orders.\n    function calculateMatchedFillResults(\n        LibOrder.Order memory leftOrder,\n        LibOrder.Order memory rightOrder,\n        uint256 leftOrderTakerAssetFilledAmount,\n        uint256 rightOrderTakerAssetFilledAmount,\n        uint256 protocolFeeMultiplier,\n        uint256 gasPrice,\n        bool shouldMaximallyFillOrders\n    )\n        internal\n        pure\n        returns (MatchedFillResults memory matchedFillResults)\n    {\n        // Derive maker asset amounts for left & right orders, given store taker assert amounts\n        uint256 leftTakerAssetAmountRemaining = leftOrder.takerAssetAmount.safeSub(leftOrderTakerAssetFilledAmount);\n        uint256 leftMakerAssetAmountRemaining = LibMath.safeGetPartialAmountFloor(\n            leftOrder.makerAssetAmount,\n            leftOrder.takerAssetAmount,\n            leftTakerAssetAmountRemaining\n        );\n        uint256 rightTakerAssetAmountRemaining = rightOrder.takerAssetAmount.safeSub(rightOrderTakerAssetFilledAmount);\n        uint256 rightMakerAssetAmountRemaining = LibMath.safeGetPartialAmountFloor(\n            rightOrder.makerAssetAmount,\n            rightOrder.takerAssetAmount,\n            rightTakerAssetAmountRemaining\n        );\n\n        // Maximally fill the orders and pay out profits to the matcher in one or both of the maker assets.\n        if (shouldMaximallyFillOrders) {\n            matchedFillResults = _calculateMatchedFillResultsWithMaximalFill(\n                leftOrder,\n                rightOrder,\n                leftMakerAssetAmountRemaining,\n                leftTakerAssetAmountRemaining,\n                rightMakerAssetAmountRemaining,\n                rightTakerAssetAmountRemaining\n            );\n        } else {\n            matchedFillResults = _calculateMatchedFillResults(\n                leftOrder,\n                rightOrder,\n                leftMakerAssetAmountRemaining,\n                leftTakerAssetAmountRemaining,\n                rightMakerAssetAmountRemaining,\n                rightTakerAssetAmountRemaining\n            );\n        }\n\n        // Compute fees for left order\n        matchedFillResults.left.makerFeePaid = LibMath.safeGetPartialAmountFloor(\n            matchedFillResults.left.makerAssetFilledAmount,\n            leftOrder.makerAssetAmount,\n            leftOrder.makerFee\n        );\n        matchedFillResults.left.takerFeePaid = LibMath.safeGetPartialAmountFloor(\n            matchedFillResults.left.takerAssetFilledAmount,\n            leftOrder.takerAssetAmount,\n            leftOrder.takerFee\n        );\n\n        // Compute fees for right order\n        matchedFillResults.right.makerFeePaid = LibMath.safeGetPartialAmountFloor(\n            matchedFillResults.right.makerAssetFilledAmount,\n            rightOrder.makerAssetAmount,\n            rightOrder.makerFee\n        );\n        matchedFillResults.right.takerFeePaid = LibMath.safeGetPartialAmountFloor(\n            matchedFillResults.right.takerAssetFilledAmount,\n            rightOrder.takerAssetAmount,\n            rightOrder.takerFee\n        );\n\n        // Compute the protocol fee that should be paid for a single fill. In this\n        // case this should be made the protocol fee for both the left and right orders.\n        uint256 protocolFee = gasPrice.safeMul(protocolFeeMultiplier);\n        matchedFillResults.left.protocolFeePaid = protocolFee;\n        matchedFillResults.right.protocolFeePaid = protocolFee;\n\n        // Return fill results\n        return matchedFillResults;\n    }\n\n    /// @dev Adds properties of both FillResults instances.\n    /// @param fillResults1 The first FillResults.\n    /// @param fillResults2 The second FillResults.\n    /// @return The sum of both fill results.\n    function addFillResults(\n        FillResults memory fillResults1,\n        FillResults memory fillResults2\n    )\n        internal\n        pure\n        returns (FillResults memory totalFillResults)\n    {\n        totalFillResults.makerAssetFilledAmount = fillResults1.makerAssetFilledAmount.safeAdd(fillResults2.makerAssetFilledAmount);\n        totalFillResults.takerAssetFilledAmount = fillResults1.takerAssetFilledAmount.safeAdd(fillResults2.takerAssetFilledAmount);\n        totalFillResults.makerFeePaid = fillResults1.makerFeePaid.safeAdd(fillResults2.makerFeePaid);\n        totalFillResults.takerFeePaid = fillResults1.takerFeePaid.safeAdd(fillResults2.takerFeePaid);\n        totalFillResults.protocolFeePaid = fillResults1.protocolFeePaid.safeAdd(fillResults2.protocolFeePaid);\n\n        return totalFillResults;\n    }\n\n    /// @dev Calculates part of the matched fill results for a given situation using the fill strategy that only\n    ///      awards profit denominated in the left maker asset.\n    /// @param leftOrder The left order in the order matching situation.\n    /// @param rightOrder The right order in the order matching situation.\n    /// @param leftMakerAssetAmountRemaining The amount of the left order maker asset that can still be filled.\n    /// @param leftTakerAssetAmountRemaining The amount of the left order taker asset that can still be filled.\n    /// @param rightMakerAssetAmountRemaining The amount of the right order maker asset that can still be filled.\n    /// @param rightTakerAssetAmountRemaining The amount of the right order taker asset that can still be filled.\n    /// @return MatchFillResults struct that does not include fees paid.\n    function _calculateMatchedFillResults(\n        LibOrder.Order memory leftOrder,\n        LibOrder.Order memory rightOrder,\n        uint256 leftMakerAssetAmountRemaining,\n        uint256 leftTakerAssetAmountRemaining,\n        uint256 rightMakerAssetAmountRemaining,\n        uint256 rightTakerAssetAmountRemaining\n    )\n        private\n        pure\n        returns (MatchedFillResults memory matchedFillResults)\n    {\n        // Calculate fill results for maker and taker assets: at least one order will be fully filled.\n        // The maximum amount the left maker can buy is `leftTakerAssetAmountRemaining`\n        // The maximum amount the right maker can sell is `rightMakerAssetAmountRemaining`\n        // We have two distinct cases for calculating the fill results:\n        // Case 1.\n        //   If the left maker can buy more than the right maker can sell, then only the right order is fully filled.\n        //   If the left maker can buy exactly what the right maker can sell, then both orders are fully filled.\n        // Case 2.\n        //   If the left maker cannot buy more than the right maker can sell, then only the left order is fully filled.\n        // Case 3.\n        //   If the left maker can buy exactly as much as the right maker can sell, then both orders are fully filled.\n        if (leftTakerAssetAmountRemaining > rightMakerAssetAmountRemaining) {\n            // Case 1: Right order is fully filled\n            matchedFillResults = _calculateCompleteRightFill(\n                leftOrder,\n                rightMakerAssetAmountRemaining,\n                rightTakerAssetAmountRemaining\n            );\n        } else if (leftTakerAssetAmountRemaining < rightMakerAssetAmountRemaining) {\n            // Case 2: Left order is fully filled\n            matchedFillResults.left.makerAssetFilledAmount = leftMakerAssetAmountRemaining;\n            matchedFillResults.left.takerAssetFilledAmount = leftTakerAssetAmountRemaining;\n            matchedFillResults.right.makerAssetFilledAmount = leftTakerAssetAmountRemaining;\n            // Round up to ensure the maker's exchange rate does not exceed the price specified by the order.\n            // We favor the maker when the exchange rate must be rounded.\n            matchedFillResults.right.takerAssetFilledAmount = LibMath.safeGetPartialAmountCeil(\n                rightOrder.takerAssetAmount,\n                rightOrder.makerAssetAmount,\n                leftTakerAssetAmountRemaining // matchedFillResults.right.makerAssetFilledAmount\n            );\n        } else {\n            // leftTakerAssetAmountRemaining == rightMakerAssetAmountRemaining\n            // Case 3: Both orders are fully filled. Technically, this could be captured by the above cases, but\n            //         this calculation will be more precise since it does not include rounding.\n            matchedFillResults = _calculateCompleteFillBoth(\n                leftMakerAssetAmountRemaining,\n                leftTakerAssetAmountRemaining,\n                rightMakerAssetAmountRemaining,\n                rightTakerAssetAmountRemaining\n            );\n        }\n\n        // Calculate amount given to taker\n        matchedFillResults.profitInLeftMakerAsset = matchedFillResults.left.makerAssetFilledAmount.safeSub(\n            matchedFillResults.right.takerAssetFilledAmount\n        );\n\n        return matchedFillResults;\n    }\n\n    /// @dev Calculates part of the matched fill results for a given situation using the maximal fill order matching\n    ///      strategy.\n    /// @param leftOrder The left order in the order matching situation.\n    /// @param rightOrder The right order in the order matching situation.\n    /// @param leftMakerAssetAmountRemaining The amount of the left order maker asset that can still be filled.\n    /// @param leftTakerAssetAmountRemaining The amount of the left order taker asset that can still be filled.\n    /// @param rightMakerAssetAmountRemaining The amount of the right order maker asset that can still be filled.\n    /// @param rightTakerAssetAmountRemaining The amount of the right order taker asset that can still be filled.\n    /// @return MatchFillResults struct that does not include fees paid.\n    function _calculateMatchedFillResultsWithMaximalFill(\n        LibOrder.Order memory leftOrder,\n        LibOrder"
    }
  ]
}