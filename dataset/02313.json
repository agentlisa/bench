{
  "Title": "M-8: If signer gate is deployed to safe with more than 5 existing modules, safe will be bricked",
  "Content": "# Issue M-8: If signer gate is deployed to safe with more than 5 existing modules, safe will be bricked \n\nSource: https://github.com/sherlock-audit/2023-02-hats-judging/issues/43 \n\n## Found by \nobront, juancito, roguereddwarf, cducrest-brainbot\n\n## Summary\n\n`HatsSignerGate` can be deployed with a fresh safe or connected to an existing safe. In the event that it is connected to an existing safe, it pulls the first 5 modules from that safe to count the number of connected modules. If there are more than 5 modules, it silently only takes the first five. This results in a mismatch between the real number of modules and `enabledModuleCount`, which causes all future transactions to revert.\n\n## Vulnerability Detail\n\nWhen a `HatsSignerGate` is deployed to an existing safe, it pulls the existing modules with the following code:\n```solidity\n(address[] memory modules,) = GnosisSafe(payable(_safe)).getModulesPaginated(SENTINEL_MODULES, 5);\nuint256 existingModuleCount = modules.length;\n```\nBecause the modules are requested paginated with `5` as the second argument, it will return a maximum of 5 modules. If the safe already has more than 5 modules, only the first 5 will be returned. \n\nThe result is that, while the safe has more than 5 modules, the gate will be set up with `enabledModuleCount = 5 + 1`. \n\nWhen a transaction is executed, `checkTransaction()` will get the hash of the first 6 modules:\n```solidity\n(address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n_existingModulesHash = keccak256(abi.encode(modules));\n```\n\nAfter the transaction, the first 7 modules will be checked to compare it:\n```solidity\n(address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\nif (keccak256(abi.encode(modules)) != _existingModulesHash) {\n    revert SignersCannotChangeModules();\n}\n```\n\nSince it already had more than 5 modules (now 6, with HatsSignerGate added), there will be a 7th module and the two hashes will be different. This will cause a revert.\n\nThis would be a high severity issue, except that in the comments for the function it says:\n\n> /// @dev Do not attach HatsSignerGate to a Safe with more than 5 existing modules; its signers will not be able to execute any transactions\n\nThis is the correct recommendation, but given the substantial consequences of getting it wrong, it should be enforced in code so that a safe with more modules reverts, rather than merely suggested in the comments.\n\n## Impact\n\nIf a HatsSignerGate is deployed and connected to a safe with more than 5 existing modules, all future transactions sent through that safe will revert.\n\n## Code Snippet\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateFactory.sol#L124-L141\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe `deployHatsSignerGate()` function should revert if attached to a safe with more than 5 modules:\n```diff\nfunction deployHatsSignerGate(\n    uint256 _ownerHatId,\n    uint256 _signersHatId,\n    address _safe, // existing Gnosis Safe that the signers will join\n    uint256 _minThreshold,\n    uint256 _targetThreshold,\n    uint256 _maxSigners\n) public returns (address hsg) {\n    // count up the existing modules on the safe\n    (address[] memory modules,) = GnosisSafe(payable(_safe)).getModulesPaginated(SENTINEL_MODULES, 5);\n    uint256 existingModuleCount = modules.length;\n+   (address[] memory modulesWithSix,) = GnosisSafe(payable(_safe)).getModulesPaginated(SENTINEL_MODULES, 6);\n+   if (modules.length != moduleWithSix.length) revert TooManyModules();\n\n    return _deployHatsSignerGate(\n        _ownerHatId, _signersHatId, _safe, _minThreshold, _targetThreshold, _maxSigners, existingModuleCount\n    );\n}\n```\n\n## Discussion\n\n**spengrah**\n\nBased on other findings, considering removing the ability for any other modules to exist alongside HSG. If we go that route, the fix here would likely be to revert if `modulesWith1.length > 0`.\n\ncc @zobront \n\n**zobront**\n\nGreat, I agree with that.\n\n**spengrah**\n\nhttps://github.com/Hats-Protocol/hats-zodiac/pull/10\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/48",
  "Code": [
    {
      "filename": "src/HatsSignerGateFactory.sol",
      "content": "// SPDX-License-Identifier: CC0\npragma solidity >=0.8.13;\n\nimport { console2 } from \"forge-std/Test.sol\"; // remove after testing\nimport \"./HatsSignerGate.sol\";\nimport \"./MultiHatsSignerGate.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/libraries/MultiSend.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol\";\nimport \"@gnosis.pm/zodiac/factory/ModuleProxyFactory.sol\";\n\n// import \"forge-std/Test.sol\"; // remove after testing\n\ncontract HatsSignerGateFactory {\n    address public immutable hatsAddress;\n\n    address public immutable hatsSignerGateSingleton;\n    address public immutable multiHatsSignerGateSingleton;\n\n    // address public immutable hatsSignerGatesingleton;\n    address public immutable safeSingleton;\n\n    // Library to use for EIP1271 compatability\n    address public immutable gnosisFallbackLibrary;\n\n    // Library to use for all safe transaction executions\n    address public immutable gnosisMultisendLibrary;\n\n    GnosisSafeProxyFactory public immutable gnosisSafeProxyFactory;\n\n    ModuleProxyFactory public immutable moduleProxyFactory;\n\n    string public version;\n\n    uint256 internal nonce;\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    // events\n\n    event HatsSignerGateSetup(\n        address _hatsSignerGate,\n        uint256 _ownerHatId,\n        uint256 _signersHatId,\n        address _safe,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners\n    );\n\n    event MultiHatsSignerGateSetup(\n        address _hatsSignerGate,\n        uint256 _ownerHatId,\n        uint256[] _signersHatIds,\n        address _safe,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners\n    );\n\n    constructor(\n        address _hatsSignerGateSingleton,\n        address _multiHatsSignerGateSingleton,\n        address _hatsAddress,\n        address _safeSingleton,\n        address _gnosisFallbackLibrary,\n        address _gnosisMultisendLibrary,\n        address _gnosisSafeProxyFactory,\n        address _moduleProxyFactory,\n        string memory _version\n    ) {\n        hatsSignerGateSingleton = _hatsSignerGateSingleton;\n        multiHatsSignerGateSingleton = _multiHatsSignerGateSingleton;\n        hatsAddress = _hatsAddress;\n        safeSingleton = _safeSingleton;\n        gnosisFallbackLibrary = _gnosisFallbackLibrary;\n        gnosisMultisendLibrary = _gnosisMultisendLibrary;\n        gnosisSafeProxyFactory = GnosisSafeProxyFactory(_gnosisSafeProxyFactory);\n        moduleProxyFactory = ModuleProxyFactory(_moduleProxyFactory);\n        version = _version;\n    }\n\n    // option 1: deploy a new Safe and signer gate, all wired up\n    function deployHatsSignerGateAndSafe(\n        uint256 _ownerHatId,\n        uint256 _signersHatId,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners\n    ) public returns (address hsg, address payable safe) {\n        // Deploy new safe but do not set it up yet\n        safe = payable(gnosisSafeProxyFactory.createProxy(safeSingleton, hex\"00\"));\n\n        // Deploy new hats signer gate\n        hsg = _deployHatsSignerGate(_ownerHatId, _signersHatId, safe, _minThreshold, _targetThreshold, _maxSigners, 0);\n\n        // Generate delegate call so the safe calls enableModule on itself during setup\n        bytes memory multisendAction = _generateMultisendAction(hsg, safe);\n\n        // Workaround for solidity dynamic memory array\n        address[] memory owners = new address[](1);\n        owners[0] = hsg;\n        // console2.log(address(hsg));\n        // console2.log(hsg);\n        // console2.log(owners[0]);\n\n        // Call setup on safe to enable our new module/guard and set it as the sole initial owner\n        GnosisSafe(safe).setup(\n            owners,\n            1,\n            gnosisMultisendLibrary,\n            multisendAction, // set hsg as module and guard\n            gnosisFallbackLibrary,\n            address(0),\n            0,\n            payable(address(0))\n        );\n\n        emit HatsSignerGateSetup(hsg, _ownerHatId, _signersHatId, safe, _minThreshold, _targetThreshold, _maxSigners);\n\n        return (hsg, safe);\n    }\n\n    // option 2: deploy a new signer gate and attach it to an existing Safe\n    /// @dev Do not attach HatsSignerGate to a Safe with more than 5 existing modules; its signers will not be able to execute any transactions\n    function deployHatsSignerGate(\n        uint256 _ownerHatId,\n        uint256 _signersHatId,\n        address _safe, // existing Gnosis Safe that the signers will join\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners\n    ) public returns (address hsg) {\n        // count up the existing modules on the safe\n        (address[] memory modules,) = GnosisSafe(payable(_safe)).getModulesPaginated(SENTINEL_MODULES, 5);\n        uint256 existingModuleCount = modules.length;\n\n        return _deployHatsSignerGate(\n            _ownerHatId, _signersHatId, _safe, _minThreshold, _targetThreshold, _maxSigners, existingModuleCount\n        );\n    }\n\n    function _deployHatsSignerGate(\n        uint256 _ownerHatId,\n        uint256 _signersHatId,\n        address _safe, // existing Gnosis Safe that the signers will join\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        uint256 _existingModuleCount\n    ) internal returns (address hsg) {\n        bytes memory initializeParams = abi.encode(\n            _ownerHatId,\n            _signersHatId,\n            _safe,\n            hatsAddress,\n            _minThreshold,\n            _targetThreshold,\n            _maxSigners,\n            version,\n            _existingModuleCount\n        );\n\n        hsg = moduleProxyFactory.deployModule(\n            hatsSignerGateSingleton, abi.encodeWithSignature(\"setUp(bytes)\", initializeParams), ++nonce\n        );\n\n        emit HatsSignerGateSetup(hsg, _ownerHatId, _signersHatId, _safe, _minThreshold, _targetThreshold, _maxSigners);\n    }\n\n    function _generateMultisendAction(address _hatsSignerGate, address _safe)\n        internal\n        pure\n        returns (bytes memory _action)\n    {\n        bytes memory enableHSGModule = abi.encodeWithSignature(\"enableModule(address)\", _hatsSignerGate);\n\n        // Generate delegate call so the safe calls setGuard on itself during setup\n        bytes memory setHSGGuard = abi.encodeWithSignature(\"setGuard(address)\", _hatsSignerGate);\n\n        bytes memory packedCalls = abi.encodePacked(\n            // enableHSGModule\n            uint8(0), // 0 for call; 1 for delegatecall\n            _safe, // to\n            uint256(0), // value\n            uint256(enableHSGModule.length), // data length\n            bytes(enableHSGModule), // data\n            // setHSGGuard\n            uint8(0), // 0 for call; 1 for delegatecall\n            _safe, // to\n            uint256(0), // value\n            uint256(setHSGGuard.length), // data length\n            bytes(setHSGGuard) // data\n        );\n\n        _action = abi.encodeWithSignature(\"multiSend(bytes)\", packedCalls);\n    }\n\n    // option 3: deploy a new Safe and signer gate, all wired up\n    function deployMultiHatsSignerGateAndSafe(\n        uint256 _ownerHatId,\n        uint256[] calldata _signersHatIds,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners\n    ) public returns (address mhsg, address payable safe) {\n        // Deploy new safe but do not set it up yet\n        safe = payable(gnosisSafeProxyFactory.createProxy(safeSingleton, hex\"00\"));\n\n        // Deploy new hats signer gate\n        mhsg = _deployMultiHatsSignerGate(\n            _ownerHatId, _signersHatIds, safe, _minThreshold, _targetThreshold, _maxSigners, 0\n        );\n\n        // Generate delegate call so the safe calls enableModule on itself during setup\n        bytes memory multisendAction = _generateMultisendAction(mhsg, safe);\n\n        // Workaround for solidity dynamic memory array\n        address[] memory owners = new address[](1);\n        owners[0] = mhsg;\n\n        // Call setup on safe to enable our new module/guard and set it as the sole initial owner\n        GnosisSafe(safe).setup(\n            owners,\n            1,\n            gnosisMultisendLibrary,\n            multisendAction, // set hsg as module and guard\n            gnosisFallbackLibrary,\n            address(0),\n            0,\n            payable(address(0))\n        );\n\n        emit MultiHatsSignerGateSetup(\n            mhsg, _ownerHatId, _signersHatIds, safe, _minThreshold, _targetThreshold, _maxSigners\n            );\n\n        return (mhsg, safe);\n    }\n\n    // option 2: deploy a new signer gate and attach it to an existing Safe\n    /// @dev Do not attach MultiHatsSignerGate to a Safe with existing modules; MultiHatsSignerGate will freeze all subsequent transactions\n    function deployMultiHatsSignerGate(\n        uint256 _ownerHatId,\n        uint256[] calldata _signersHatIds,\n        address _safe, // existing Gnosis Safe that the signers will join\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners\n    ) public returns (address mhsg) {\n        // count up the existing modules on the safe\n        (address[] memory modules,) = GnosisSafe(payable(_safe)).getModulesPaginated(SENTINEL_MODULES, 5);\n        uint256 existingModuleCount = modules.length;\n\n        return _deployMultiHatsSignerGate(\n            _ownerHatId, _signersHatIds, _safe, _minThreshold, _targetThreshold, _maxSigners, existingModuleCount\n        );\n    }\n\n    function _deployMultiHatsSignerGate(\n        uint256 _ownerHatId,\n        uint256[] calldata _signersHatIds,\n        address _safe, // existing Gnosis Safe that the signers will join\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        uint256 _existingModuleCount\n    ) public returns (address mhsg) {\n        bytes memory initializeParams = abi.encode(\n            _ownerHatId,\n            _signersHatIds,\n            _safe,\n            hatsAddress,\n            _minThreshold,\n            _targetThreshold,\n            _maxSigners,\n            version,\n            _existingModuleCount\n        );\n\n        mhsg = moduleProxyFactory.deployModule(\n            multiHatsSignerGateSingleton, abi.encodeWithSignature(\"setUp(bytes)\", initializeParams), ++nonce\n        );\n\n        emit MultiHatsSignerGateSetup(\n            mhsg, _ownerHatId, _signersHatIds, _safe, _minThreshold, _targetThreshold, _maxSigners\n            );\n    }\n}"
    }
  ]
}