{
  "Title": "M-2: IERC20.transfer wil fail for USDT",
  "Content": "# Issue M-2: IERC20.transfer wil fail for USDT \n\nSource: https://github.com/sherlock-audit/2024-03-amphor-judging/issues/126 \n\n## Found by \n0xKartikgiri00, 0xLogos, 0xShitgem, offside0011, rekxor\n## Summary\n\nSome tokens do not return bool on transfer, e.g. USDT on mainnet\n\n## Vulnerability Detail\n\nUSDT on mainnet do not return bool on transfer: https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L126\n\nBut but because of IERC20 interface solidity will try to parse bool from nothing thus reverting.\n\n## Impact\n\nUnable to claim requested redeem if underlying asset is USDT\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-amphor/blob/6c797025ffe296e04607abf74400ff2bb36a7de3/asynchronous-vault/src/AsyncSynthVault.sol#L771\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead transfer directly to `receiver`\n\n```diff\n_asset.safeTransferFrom(address(claimableSilo), receiver, assets);\n- _asset.transfer(receiver, assets);\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/AmphorProtocol/asynchronous-vault/pull/103.\n\n**sherlock-admin2**\n\n> Escalate\n> there is no case this will cause an issue, because the supposedly \"insecure\" transfer it predeced by safeTransfer of the same amount and the same token. Therefore if there is wrong amount of token, if will fail on first transfer attempt, so transfer() is protected anyway\n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**0xLogos**\n\nEscalate \n\nShould be high bcz `_asset.transfer(receiver, assets)` will always fail for usdt => unable to claim.\n\nAlso I think #53 is about return value not checked, but actual root case is usdt is incompatible with erc20 interface => should be info\n\n\n**sherlock-admin2**\n\n> Escalate \n> \n> Should be high bcz `_asset.transfer(receiver, assets)` will always fail for usdt => unable to claim.\n> \n> Also I think #53 is about return value not checked, but actual root case is usdt is incompatible with erc20 interface => should be info\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xCryptoSan**\n\nthis issue https://github.com/sherlock-audit/2024-03-amphor-judging/issues/35 should be also linked as duplicate of this issue\n\n**WangSecurity**\n\nWe actually wanted to make it high, but the sponsor (@blablalf scepcifically) noted that the vaults will be upgradeable, therefore, if this vulnerability were to take place, the funds would be easily retrieved. That is the reason we decided for this one to be medium instead of high.\n\n**rekxor**\n\n> We actually wanted to make it high, but the sponsor (@blablalf scepcifically) noted that the vaults will be upgradeable, therefore, if this vulnerability were to take place, the funds would be easily retrieved. That is the reason we decided for this one to be medium instead of high.\n\nI don't think so it was mentioned in the Readme of the protocol at time of contest. So, shouldn't it be remained high! @WangSecurity \n\n**WangSecurity**\n\nDon't think so, to me it looks like this: if it happened in real life, then there would be no permanent lock of funds and they could be easily retrieved. Plus, we can add that they're not planning to make USDT vault straight away (I know it's not mentioned in the README and they shared it on discord, therefore, under Sherlock's hierarchy of truth it doesn't count, I know, I'm just elaborating on it, so it's easier for the head of judging to make the decision).\n\n**Evert0x**\n\nWill revisit this issue, but tentatively planning to reject escalation and keep issue state as is because of the argument put forward by Wang.  \n\n**0xLogos**\n\nAgree with rekxor\n\n> We actually wanted to make it high, but the sponsor noted...\n\nJudgement should be done based only on available information\n\nAlso I don't think that upgradeability was a reason to downgrade similar issues in the past\n\n\n\n\n\n**rekxor**\n\n> Don't think so, to me it looks like this: if it happened in real life, then there would be no permanent lock of funds and they could be easily retrieved. Plus, we can add that they're not planning to make USDT vault straight away (I know it's not mentioned in the README and they shared it on discord, therefore, under Sherlock's hierarchy of truth it doesn't count, I know, I'm just elaborating on it, so it's easier for the head of judging to make the decision).\n\nIt is mentioned in the readme that the protocol has decided to use the tokens - weth, usdc, **usdt** and wbtc. \n![Screenshot_20240402_230235_Chrome](https://github.com/sherlock-audit/2024-03-amphor-judging/assets/156965796/71d97b22-0c49-425c-aeea-b8e965e762ca)\n\n\n**WangSecurity**\n\nThe decision was made based on README, as you see I've said that it's only an add-on on top, but it wasn't the decider. Otherwise, this issue would remain low/info. It was mentioned to give the additional insight, but it doesn't change anything\n\nThe only reason for this issue to be downgraded to med is that the vaults are upgradeable. And this note about the upgradeability was added cause LSW asked specifically about it (I'm unsure it changes anything, but it feels like my previous message meant that the sponsor just said it themselves, but they were asked specifically if the vault is upgradeable and it would be able to retrieve funds in such situation if it happened irl).\n\n**rekxor**\n\nThe fact that it wasn't stated publicly in the readme file that the vaults are meant to be upgradeable doesn't makes it valid point to downgrade imo.\n\n**WangSecurity**\n\nBut as I remember protocols rarely say in the README file that their contracts are upgradeable. And if it happens it's rather an exception than the rule + sherlocks readme doesn't have any question specifically related to upgradeability of the contracts.\nMoreover, if upgradeability is not mentioned in the README, then all the reports about upgradeability vulns should be invalid by default (not talking about this contest specifically, but about mentioning upgradeability in README in general)?\n\nTherefore, I don't think this is a valid argument that the upgradeability is not mentioned in the README file.\n\nPlus contracts use upgradeable contracts by OpenZeppelin (for example, OwnableUnpgradeable, not talking about ERC20Upgradeable here) therefore, it's reasonable to assume the vault is upgradeable.\n\nBut of course I can be wrong, I don't say I'm 100% right, just expressing my point and maybe indeed you're right and I'll accept it with no remorse (also sorry if I'm harsh, don't mean to do that, thank you bringing up all these arguments).\n\n**Odhiambo526**\n\n@WangSecurity I think issue #55 is a duplicate of the same issue\n\n**Evert0x**\n\nBased on the contracts in scope, upgradeability is possible.\n\nAs it's possible, I would judge this as Medium. It breaks core functionality but funds are recoverable. \n\n\n\n**WangSecurity**\n\n@Odhiambo526 unfotunately, it's not a duplicate, it talks about `transfer` in general, when this issue is about USDT sepcifically.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xLogos](https://github.com/sherlock-audit/2024-03-amphor-judging/issues/126/#issuecomment-2025503667): rejected\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/244",
  "Code": [
    {
      "filename": "asynchronous-vault/src/AsyncSynthVault.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {\n    IERC7540,\n    IERC165,\n    IERC7540Redeem,\n    IERC7540Deposit\n} from \"./interfaces/IERC7540.sol\";\nimport { ERC7540Receiver } from \"./interfaces/ERC7540Receiver.sol\";\nimport { IERC20, SafeERC20, Math, PermitParams } from \"./SyncSynthVault.sol\";\n\nimport { SyncSynthVault } from \"./SyncSynthVault.sol\";\n\n/**\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%=::::::=%@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*=#=--=*=*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:*=    =#:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*-.    .-*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*        *@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@.         .@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*  Amphor  *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*==========#@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@+==========*@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@*   ASync   *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@%  Vault  %@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@=        +@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%       %@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@=      =@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@%     .@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@=    =@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@%----%@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%+:::::+%@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@########@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *\n *            d8888                        888\n *           d88888                        888\n *          d88P888                        888\n *         d88P 888 88888b.d88b.  88888b.  88888b.   .d88b.  888d888\n *        d88P  888 888 \"888 \"88b 888 \"88b 888 \"88b d88\"\"88b 888P\"\n *       d88P   888 888  888  888 888  888 888  888 888  888 888\n *      d8888888888 888  888  888 888 d88P 888  888 Y88..88P 888\n *     d88P     888 888  888  888 88888P\"  888  888  \"Y88P\"  888.io\n *                                888\n *                                888\n *                                888\n */\n\n/*\n * ########\n * # LIBS #\n * ########\n*/\nusing Math for uint256; // only used for `mulDiv` operations.\nusing SafeERC20 for IERC20; // `safeTransfer` and `safeTransferFrom`\n\n/*\n    This structure contains all the informations needed to let user claim their\n    request after we processed those. To avoid rounding errors we store the\ntotalSupply and totalAssets at the time of the deposit/redeem for the deposit\nand\n    the redeem. We also store the amount of assets and shares given by the user.*/\nstruct EpochData {\n    uint256 totalSupplySnapshotForRedeem;\n    uint256 totalAssetsSnapshotForRedeem;\n    uint256 totalSupplySnapshotForDeposit;\n    uint256 totalAssetsSnapshotForDeposit;\n    mapping(address => uint256) depositRequestBalance;\n    mapping(address => uint256) redeemRequestBalance;\n}\n\nstruct SettleValues {\n    uint256 lastSavedBalance;\n    uint256 fees;\n    uint256 pendingRedeem;\n    uint256 sharesToMint;\n    uint256 pendingDeposit;\n    uint256 assetsToWithdraw;\n    uint256 totalAssetsSnapshotForDeposit;\n    uint256 totalSupplySnapshotForDeposit;\n    uint256 totalAssetsSnapshotForRedeem;\n    uint256 totalSupplySnapshotForRedeem;\n}\n\nuint256 constant BPS_DIVIDER = 10_000;\nuint16 constant MAX_FEES = 3000; // 30%\n\ncontract Silo {\n    constructor(IERC20 underlying) {\n        underlying.forceApprove(msg.sender, type(uint256).max);\n    }\n}\n\ncontract AsyncSynthVault is IERC7540, SyncSynthVault {\n    /*\n     * ####################################\n     * # AMPHOR SYNTHETIC RELATED STORAGE #\n     * ####################################\n    */\n\n    // @return Amount of the perf fees applied on the positive yield.\n    uint256 public epochId;\n    Silo public pendingSilo; // to manage the pending deposits and redeems we\n        // store them in a contract whose function is to hold the assets/shares.\n    Silo public claimableSilo; // to manage the claimable deposits and redeems\n        // we\n        // store them in a contract whose function is to hold the assets/shares.\n    mapping(uint256 epochId => EpochData epoch) public epochs;\n    mapping(address user => uint256 epochId) public lastDepositRequestId;\n    mapping(address user => uint256 epochId) public lastRedeemRequestId;\n\n    /*\n     * ##########\n     * # EVENTS #\n     * ##########\n    */\n\n    event DecreaseDepositRequest(\n        uint256 indexed requestId,\n        address indexed owner,\n        uint256 indexed previousRequestedAssets,\n        uint256 newRequestedAssets\n    );\n\n    event DecreaseRedeemRequest(\n        uint256 indexed requestId,\n        address indexed owner,\n        uint256 indexed previousRequestedShares,\n        uint256 newRequestedShares\n    );\n\n    event ClaimDeposit(\n        uint256 indexed requestId,\n        address indexed owner,\n        address indexed receiver,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event ClaimRedeem(\n        uint256 indexed requestId,\n        address indexed owner,\n        address indexed receiver,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*\n     * ##########\n     * # ERRORS #\n     * ##########\n     */\n    error ExceededMaxRedeemRequest(\n        address receiver, uint256 shares, uint256 maxShares\n    );\n    error ExceededMaxDepositRequest(\n        address receiver, uint256 assets, uint256 maxDeposit\n    );\n    error MustClaimFirst(address owner);\n\n    error ReceiverFailed();\n    error NotOwner();\n    error NullRequest();\n    error ERC7540CantRequestDepositOnBehalfOf();\n    /*\n     * ##############################\n     * # AMPHOR SYNTHETIC FUNCTIONS #\n     * ##############################\n     */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() SyncSynthVault() {\n        //_disableInitializers();\n    }\n\n    function initialize(\n        uint16 fees,\n        address owner,\n        IERC20 underlying,\n        string memory name,\n        string memory symbol\n    )\n        public\n        virtual\n        override\n        initializer\n    {\n        super.initialize(fees, owner, underlying, name, symbol);\n        epochId = 1;\n        pendingSilo = new Silo(underlying);\n        claimableSilo = new Silo(underlying);\n    }\n\n    /*\n    Since we only allow one claimable request at a time, users must claim\n        their request before making a new one. This function let users claim\n        and request a deposit in one transaction.\n    */\n    function claimAndRequestDeposit(\n        uint256 assets,\n        address receiver,\n        bytes memory data\n    )\n        external\n    {\n        _claimDeposit(receiver, receiver);\n        requestDeposit(assets, receiver, _msgSender(), data);\n    }\n\n    /*\n        Same logic as `claimAndRequestDeposit` but for redeem requests.\n    */\n    function claimAndRequestRedeem(\n        uint256 shares,\n        bytes memory data\n    )\n        external\n    {\n        address owner = _msgSender();\n        _claimRedeem(owner, owner);\n        requestRedeem(shares, owner, owner, data);\n    }\n\n    /*\n    This function is used to decrease the amount of assets requested to deposit\n    by the\n        user. It can only be called by the user who made the request.\n    */\n    function decreaseDepositRequest(uint256 assets)\n        external\n        whenClosed\n        whenNotPaused\n    {\n        address owner = _msgSender();\n        uint256 oldBalance = epochs[epochId].depositRequestBalance[owner];\n        epochs[epochId].depositRequestBalance[owner] -= assets;\n        _asset.safeTransferFrom(address(pendingSilo), owner, assets);\n\n        emit DecreaseDepositRequest(\n            epochId,\n            owner,\n            oldBalance,\n            epochs[epochId].depositRequestBalance[owner]\n        );\n    }\n\n    /*\n    This function is used to decrease the amount of shares requested to redeem\n    by the\n        user. It can only be called by the user who made the request.\n    */\n    function decreaseRedeemRequest(uint256 shares)\n        external\n        whenClosed\n        whenNotPaused\n    {\n        address owner = _msgSender();\n        uint256 oldBalance = epochs[epochId].redeemRequestBalance[owner];\n        epochs[epochId].redeemRequestBalance[owner] -= shares;\n        _update(address(pendingSilo), owner, shares);\n\n        emit DecreaseRedeemRequest(\n            epochId,\n            owner,\n            oldBalance,\n            epochs[epochId].redeemRequestBalance[owner]\n        );\n    }\n\n    /*\n     * ######################################\n     * # AMPHOR SYNTHETIC RELATED FUNCTIONS #\n     * ######################################\n    */\n\n    /**\n     * @dev The `close` function is used to close the vault.\n     * It can only be called by the owner of the contract (`onlyOwner`\n     * modifier).\n     */\n    function close() external override onlyOwner {\n        if (!vaultIsOpen) revert VaultIsClosed();\n\n        if (totalAssets() == 0) revert VaultIsEmpty();\n\n        lastSavedBalance = totalAssets();\n        vaultIsOpen = false;\n        _asset.safeTransfer(owner(), lastSavedBalance);\n        emit EpochStart(block.timestamp, lastSavedBalance, totalSupply());\n    }\n\n    /**\n     * @dev The `open` function is used to open the vault.\n     * @notice The `open` function is used to end the lock period of the vault.\n     * It can only be called by the owner of the contract (`onlyOwner` modifier)\n     * and only when the vault is locked.\n     * If there are profits, the performance fees are taken and sent to the\n     * owner of the contract.\n     * @param assetReturned The underlying assets amount to be deposited into\n     * the vault.\n     */\n    function open(uint256 assetReturned)\n        external\n        override\n        onlyOwner\n        whenNotPaused\n        whenClosed\n    {\n        (uint256 newBalance,) = _settle(assetReturned);\n        vaultIsOpen = true;\n        _asset.safeTransferFrom(owner(), address(this), newBalance);\n    }\n\n    /*\n     * #################################\n     * #   Permit RELATED FUNCTIONS    #\n     * #################################\n    */\n\n    /* This function is used to claim the pending deposit and request a new one\n    in one transaction using permit signatures */\n    function claimAndRequestDepositWithPermit(\n        uint256 assets,\n        bytes memory data,\n        PermitParams calldata permitParams\n    )\n        external\n    {\n        address msgSender = _msgSender();\n        _claimDeposit(msgSender, msgSender);\n        requestDepositWithPermit(assets, msgSender, data, permitParams);\n    }\n\n    /*\n    Since amphor strategies can be time sensitive, we must be able to switch\n    epoch without needing\n    to put all the funds back. Using _settle we can virtually put back the\n    funds, check how much we owe\n    to users that want to redeem and maybe take the extra funds from the deposit\n    requests.\n    \n    */\n    function settle(uint256 newSavedBalance) external {\n        (uint256 lastSavedBalance, uint256 totalSupply) =\n            _settle(newSavedBalance);\n        lastSavedBalance = 0;\n        emit EpochStart(block.timestamp, lastSavedBalance, totalSupply);\n    }\n\n    /**\n     * @dev How many shares a users currently has waiting to be redeem.\n     *\n     */\n    function pendingRedeemRequest(address owner)\n        external\n        view\n        returns (uint256)\n    {\n        return epochs[epochId].redeemRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many shares are  virtually waiting for the user to be redeemed\n     * via\n     * the `claimRedeem` function.\n     */\n    function claimableRedeemRequest(address owner)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        return isCurrentEpoch(lastRequestId)\n            ? 0\n            : epochs[lastRequestId].redeemRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are currently waiting to be deposited for the user.\n     */\n    function pendingDepositRequest(address owner)\n        external\n        view\n        returns (uint256 assets)\n    {\n        return epochs[epochId].depositRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are virtually waiting for the user to be deposit\n     * via the `claimDeposit` function.\n     */\n    function claimableDepositRequest(address owner)\n        external\n        view\n        returns (uint256 assets)\n    {\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        return isCurrentEpoch(lastRequestId)\n            ? 0\n            : epochs[lastRequestId].depositRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are currently waiting to be deposited for all users.\n     */\n    function totalPendingDeposits() external view returns (uint256) {\n        return vaultIsOpen ? 0 : _asset.balanceOf(address(pendingSilo));\n    }\n\n    /**\n     * @dev How many shares are  waiting to be redeemed for all users.\n     */\n    function totalPendingRedeems() external view returns (uint256) {\n        return vaultIsOpen ? 0 : balanceOf(address(pendingSilo));\n    }\n\n    function totalClaimableShares() external view returns (uint256) {\n        return balanceOf(address(claimableSilo));\n    }\n\n    function totalClaimableAssets() external view returns (uint256) {\n        return _asset.balanceOf(address(claimableSilo));\n    }\n\n    /**\n     * @dev when the vault is closed, users can only request to deposit.\n     * By doing this funds will be sent and wait in the pendingSilo.\n     * When the owner will call the `open` or `settle` function, the funds will\n     * be\n     * deposited and the minted shares will be sent to the claimableSilo. Waiting\n     * for the users to claim them.\n     */\n    function requestDeposit(\n        uint256 assets,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        public\n        whenNotPaused\n        whenClosed\n    {\n        // vault\n        if (_msgSender() != owner) {\n            revert ERC7540CantRequestDepositOnBehalfOf();\n        }\n        if (previewClaimDeposit(receiver) > 0) {\n            revert MustClaimFirst(receiver);\n        }\n\n        if (assets > maxDepositRequest(owner)) {\n            revert ExceededMaxDepositRequest(\n                receiver, assets, maxDepositRequest(owner)\n            );\n        }\n\n        _asset.safeTransferFrom(owner, address(pendingSilo), assets);\n\n        _createDepositRequest(assets, receiver, owner, data);\n    }\n\n    /**\n     * @dev when the vault is closed, users can only request to redeem.\n     * By doing this shares will be sent and wait in the pendingSilo.\n     * When the owner will call the `open` or `settle` function, the shares will\n     * be\n     * redeemed and the assets will be sent to the claimableSilo. Waiting for\n     * the\n     * users to claim them.\n     */\n    function requestRedeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        public\n        whenNotPaused\n        whenClosed\n    {\n        if (_msgSender() != owner) {\n            _spendAllowance(owner, _msgSender(), shares);\n        }\n        if (previewClaimRedeem(receiver) > 0) {\n            revert MustClaimFirst(receiver);\n        }\n        if (shares > maxRedeemRequest(owner)) {\n            revert ExceededMaxRedeemRequest(\n                receiver, shares, maxRedeemRequest(owner)\n            );\n        }\n\n        _update(owner, address(pendingSilo), shares);\n        // Create a new request\n        _createRedeemRequest(shares, receiver, owner, data);\n    }\n\n    /**\n     * @dev This function let users claim the shares we owe them after we\n     * processed their deposit request, in the _settle function.\n     */\n    function claimDeposit(address receiver)\n        public\n        whenNotPaused\n        returns (uint256 shares)\n    {\n        return _claimDeposit(_msgSender(), receiver);\n    }\n\n    /**\n     *\n     * @dev This function let users claim the assets we owe them after we\n     * processed their redeem request, in the _settle function.\n     */\n    function claimRedeem(address receiver)\n        public\n        whenNotPaused\n        returns (uint256 assets)\n    {\n        return _claimRedeem(_msgSender(), receiver);\n    }\n\n    /**\n     * @dev This funciton let user request a deposit using permit signatures.\n     */\n    function requestDepositWithPermit(\n        uint256 assets,\n        address receiver,\n        bytes memory data,\n        PermitParams calldata permitParams\n    )\n        public\n    {\n        address msgSender = _msgSender();\n        if (_asset.allowance(msgSender, address(this)) < assets) {\n            execPermit(msgSender, address(this), permitParams);\n        }\n        return requestDeposit(assets, receiver, msgSender, data);\n    }\n\n    /**\n     * @dev users can request deposit only when the vault is closed and not\n     * paused.\n     */\n    function maxDepositRequest(address) public view returns (uint256) {\n        return vaultIsOpen || paused() ? 0 : type(uint256).max;\n    }\n\n    /**\n     * @dev users can request redeem only when the vault is closed and not\n     * paused.\n     */\n    function maxRedeemRequest(address owner) public view returns (uint256) {\n        return vaultIsOpen || paused() ? 0 : balanceOf(owner);\n    }\n\n    /**\n     * @dev This function let users preview how many shares they will get if\n     * they claim their deposit request.\n     */\n    function previewClaimDeposit(address owner) public view returns (uint256) {\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n        return _convertToShares(assets, lastRequestId, Math.Rounding.Floor);\n    }\n\n    /**\n     * @dev This function let users preview how many assets they will get if\n     * they claim their redeem request.\n     */\n    function previewClaimRedeem(address owner) public view returns (uint256) {\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n        return _convertToAssets(shares, lastRequestId, Math.Rounding.Floor);\n    }\n\n    /**\n     */\n    function convertToShares(\n        uint256 assets,\n        uint256 _epochId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _convertToShares(assets, _epochId, Math.Rounding.Floor);\n    }\n\n    function convertToAssets(\n        uint256 shares,\n        uint256 _epochId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _convertToAssets(shares, _epochId, Math.Rounding.Floor);\n    }\n\n    /**\n     *\n     * Utils function to convert the shares claimable into assets. It can\n     * be used in the front end to save an rpc call.\n     */\n    function claimableDepositBalanceInAsset(address owner)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 shares = previewClaimDeposit(owner);\n        return convertToAssets(shares);\n    }\n\n    /**\n     * Using this the owner can know if he will have to send money to the\n     * claimableSilo (for users who want to leave the vault) or if he will\n     * receive money from it.\n     */\n    function previewSettle(uint256 newSavedBalance)\n        public\n        view\n        returns (\n            uint256 assetsToOwner,\n            uint256 assetsToVault,\n            SettleValues memory settleValues\n        )\n    {\n        uint256 _lastSavedBalance = lastSavedBalance;\n        _checkMaxDrawdown(_lastSavedBalance, newSavedBalance);\n\n        // calculate the fees between lastSavedBalance and newSavedBalance\n        uint256 fees = _computeFees(_lastSavedBalance, newSavedBalance);\n        uint256 totalSupply = totalSupply();\n\n        // taking fees if positive yield\n        _lastSavedBalance = newSavedBalance - fees;\n\n        address pendingSiloAddr = address(pendingSilo);\n        uint256 pendingRedeem = balanceOf(pendingSiloAddr);\n        uint256 pendingDeposit = _asset.balanceOf(pendingSiloAddr);\n\n        uint256 sharesToMint = pendingDeposit.mulDiv(\n            totalSupply + 1, _lastSavedBalance + 1, Math.Rounding.Floor\n        );\n\n        uint256 totalAssetsSnapshotForDeposit = _lastSavedBalance + 1;\n        uint256 totalSupplySnapshotForDeposit = totalSupply + 1;\n\n        uint256 assetsToWithdraw = pendingRedeem.mulDiv(\n            _lastSavedBalance + pendingDeposit + 1,\n            totalSupply + sharesToMint + 1,\n            Math.Rounding.Floor\n        );\n\n        uint256 totalAssetsSnapshotForRedeem =\n            _lastSavedBalance + pendingDeposit + 1;\n        uint256 totalSupplySnapshotForRedeem = totalSupply + sharesToMint + 1;\n\n        settleValues = SettleValues({\n            lastSavedBalance: _lastSavedBalance + fees,\n            fees: fees,\n            pendingRedeem: pendingRedeem,\n            sharesToMint: sharesToMint,\n            pendingDeposit: pendingDeposit,\n            assetsToWithdraw: assetsToWithdraw,\n            totalAssetsSnapshotForDeposit: totalAssetsSnapshotForDeposit,\n            totalSupplySnapshotForDeposit: totalSupplySnapshotForDeposit,\n            totalAssetsSnapshotForRedeem: totalAssetsSnapshotForRedeem,\n            totalSupplySnapshotForRedeem: totalSupplySnapshotForRedeem\n        });\n\n        if (pendingDeposit > assetsToWithdraw) {\n            assetsToOwner = pendingDeposit - assetsToWithdraw;\n        } else if (pendingDeposit < assetsToWithdraw) {\n            assetsToVault = assetsToWithdraw - pendingDeposit;\n        }\n    }\n\n    /**\n     * @dev see EIP\n     * @param interfaceId The interface id to check for.\n     * @return True if the contract implements the interface.\n     */\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return interfaceId == type(IERC165).interfaceId\n            || interfaceId == type(IERC7540Redeem).interfaceId\n            || interfaceId == type(IERC7540Deposit).interfaceId;\n    }\n\n    // transfer must happen before this function is called\n    function _createDepositRequest(\n        uint256 assets,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        internal\n    {\n        epochs[epochId].depositRequestBalance[receiver] += assets;\n        if (lastDepositRequestId[receiver] != epochId) {\n            lastDepositRequestId[receiver] = epochId;\n        }\n\n        if (\n            data.length > 0\n                && ERC7540Receiver(receiver).onERC7540DepositReceived(\n                    _msgSender(), owner, epochId, data\n                ) != ERC7540Receiver.onERC7540DepositReceived.selector\n        ) revert ReceiverFailed();\n\n        emit DepositRequest(receiver, owner, epochId, _msgSender(), assets);\n    }\n\n    function _createRedeemRequest(\n        uint256 shares,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        internal\n    {\n        epochs[epochId].redeemRequestBalance[receiver] += shares;\n        lastRedeemRequestId[owner] = epochId;\n\n        if (\n            data.length > 0\n                && ERC7540Receiver(receiver).onERC7540RedeemReceived(\n                    _msgSender(), owner, epochId, data\n                ) != ERC7540Receiver.onERC7540RedeemReceived.selector\n        ) revert ReceiverFailed();\n\n        emit RedeemRequest(receiver, owner, epochId, _msgSender(), shares);\n    }\n\n    function _claimDeposit(\n        address owner,\n        address receiver\n    )\n        internal\n        returns (uint256 shares)\n    {\n        shares = previewClaimDeposit(owner);\n\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n        epochs[lastRequestId].depositRequestBalance[owner] = 0;\n        _update(address(claimableSilo), receiver, shares);\n        emit ClaimDeposit(lastRequestId, owner, receiver, assets, shares);\n    }\n\n    function _claimRedeem(\n        address owner,\n        address receiver\n    )\n        internal\n        whenNotPaused\n        returns (uint256 assets)\n    {\n        assets = previewClaimRedeem(owner);\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n        epochs[lastRequestId].redeemRequestBalance[owner] = 0;\n        _asset.safeTransferFrom(address(claimableSilo), address(this), assets);\n        _asset.transfer(receiver, assets);\n        emit ClaimRedeem(lastRequestId, owner, receiver, assets, shares);\n    }\n\n    function _settle(uint256 newSavedBalance)\n        internal\n        onlyOwner\n        whenNotPaused\n        whenClosed\n        returns (uint256, uint256)\n    {\n        (\n            uint256 assetsToOwner,\n            uint256 assetsToVault,\n            SettleValues memory settleValues\n        ) = previewSettle(newSavedBalance);\n\n        emit EpochEnd(\n            block.timestamp,\n            lastSavedBalance,\n            newSavedBalance,\n            settleValues.fees,\n            totalSupply()\n        );\n\n        // Settle the shares balance\n        _burn(address(pendingSilo), settleValues.pendingRedeem);\n        _mint(address(claimableSilo), settleValues.sharesToMint);\n\n        ///////////////////////////\n        // Settle assets balance //\n        ///////////////////////////\n        // either there are more deposits than withdrawals\n        if (settleValues.pendingDeposit > settleValues.assetsToWithdraw) {\n            _asset.safeTransferFrom(\n                address(pendingSilo), owner(), assetsToOwner\n            );\n            if (settleValues.assetsToWithdraw > 0) {\n                _asset.safeTransferFrom(\n                    address(pendingSilo),\n                    address(claimableSilo),\n                    settleValues.assetsToWithdraw\n                );\n            }\n        } else if (settleValues.pendingDeposit < settleValues.assetsToWithdraw)\n        {\n            _asset.safeTransferFrom(\n                owner(), address(claimableSilo), assetsToVault\n            );\n            if (settleValues.pendingDeposit > 0) {\n                _asset.safeTransferFrom(\n                    address(pendingSilo),\n                    address(claimableSilo),\n                    settleValues.pendingDeposit\n                );\n            }\n        } else if (settleValues.pendingDeposit > 0) {\n            // if _pendingDeposit == assetsToWithdraw AND _pendingDeposit > 0\n            // (and assetsToWithdraw > 0)\n            _asset.safeTransferFrom(\n                address(pendingSilo),\n                address(claimableSilo),\n                settleValues.assetsToWithdraw\n            );\n        }\n\n        emit Deposit(\n            address(pendingSilo),\n            address(claimableSilo),\n            settleValues.pendingDeposit,\n            settleValues.sharesToMint\n        );\n\n        emit Withdraw(\n            address(pendingSilo),\n            address(claimableSilo),\n            address(pendingSilo),\n            settleValues.assetsToWithdraw,\n            settleValues.pendingRedeem\n        );\n\n        settleValues.lastSavedBalance = settleValues.lastSavedBalance\n            - settleValues.fees + settleValues.pendingDeposit\n            - settleValues.assetsToWithdraw;\n        lastSavedBalance = settleValues.lastSavedBalance;\n\n        epochs[epochId].totalSupplySnapshotForDeposit =\n            settleValues.totalSupplySnapshotForDeposit;\n        epochs[epochId].totalAssetsSnapshotForDeposit =\n            settleValues.totalAssetsSnapshotForDeposit;\n        epochs[epochId].totalSupplySnapshotForRedeem =\n            settleValues.totalSupplySnapshotForRedeem;\n        epochs[epochId].totalAssetsSnapshotForRedeem =\n            settleValues.totalAssetsSnapshotForRedeem;\n\n        epochId++;\n\n        return (settleValues.lastSavedBalance, totalSupply());\n    }\n\n    function isCurrentEpoch(uint256 requestId) internal view returns (bool) {\n        return requestId == epochId;\n    }\n\n    function _convertToShares(\n        uint256 assets,\n        uint256 requestId,\n        Math.Rounding rounding\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        if (isCurrentEpoch(requestId)) {\n            return 0;\n        }\n        uint256 totalAssets =\n            epochs[requestId].totalAssetsSnapshotForDeposit + 1;\n        uint256 totalSupply =\n            epochs[requestId].totalSupplySnapshotForDeposit + 1;\n\n        return assets.mulDiv(totalSupply, totalAssets, rounding);\n    }\n\n    function _convertToAssets(\n        uint256 shares,\n        uint256 requestId,\n        Math.Rounding rounding\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        if (isCurrentEpoch(requestId)) {\n            return 0;\n        }\n        uint256 totalAssets = epochs[requestId].totalAssetsSnapshotForRedeem + 1;\n        uint256 totalSupply = epochs[requestId].totalSupplySnapshotForRedeem + 1;\n\n        return shares.mulDiv(totalAssets, totalSupply, rounding);\n    }\n\n    function _checkMaxDrawdown(\n        uint256 _lastSavedBalance,\n        uint256 newSavedBalance\n    )\n        internal\n        view\n    {\n        if (\n            newSavedBalance\n                < _lastSavedBalance.mulDiv(\n                    BPS_DIVIDER - _maxDrawdown, BPS_DIVIDER, Math.Rounding.Ceil\n                )\n        ) revert MaxDrawdownReached();\n    }\n\n    function _computeFees(\n        uint256 _lastSavedBalance,\n        uint256 newSavedBalance\n    )\n        internal\n        view\n        returns (uint256 fees)\n    {\n        if (newSavedBalance > _lastSavedBalance && feesInBps > 0) {\n            uint256 profits;\n            unchecked {\n                profits = newSavedBalance - _lastSavedBalance;\n            }\n            fees = (profits).mulDiv(feesInBps, BPS_DIVIDER, Math.Rounding.Floor);\n        }\n    }\n}"
    }
  ]
}