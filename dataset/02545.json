{
  "Title": "H-2: Malicious user can use an excessively large _toAddress in OFTCore#sendFrom to break layerZero communication",
  "Content": "# Issue H-2: Malicious user can use an excessively large _toAddress in OFTCore#sendFrom to break layerZero communication \n\nSource: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/270 \n\n## Found by \n0x52\n\n## Summary\n\nBy default layerZero implements a blocking behavior, that is, that each message must be processed and succeed in the order that it was sent. In order to circumvent this behavior the receiver must implement their own try-catch pattern. If the try-catch pattern in the receiving app ever fails then it will revert to its blocking behavior. The _toAddress input to OFTCore#sendFrom is calldata of any arbitrary length. An attacker can abuse this and submit a send request with an excessively large _toAddress to break communication between network with different gas limits.\n\n## Vulnerability Detail\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\nThe _toAddress input to OFTCore#sendFrom is a bytes calldata of any arbitrary size. This can be used as follows to break communication between chains that have different block gas limits.\n\nExample:\nLet's say that an attacker wishes to permanently block the channel Arbitrum -> Optimism. Arbitrum has a massive gas block limit, much higher than Optimism's 20M block gas limit. The attacker would call sendFrom on the Arbitrum chain with the Optimism chain as the destination. For the _toAddress input they would use an absolutely massive amount of bytes. This would be packed into the payload which would be called on Optimism. Since Arbitrum has a huge gas limit the transaction would send from the Arbitrum side but it would be so big that the transaction could never succeed on the Optimism side due to gas constraints. Since that nonce can never succeed the communication channel will be permanently blocked at the Optimism endpoint, bypassing the nonblocking behavior implemented in the OFT design and reverting to the default blocking behavior of layerZero.\n\nUsers can still send messages and burn their tokens from Arbitrum -> Optimism but the messages can never be received. This could be done between any two chain in which one has a higher block gas limit. This would cause massive loss of funds and completely cripple the entire protocol.\n\n## Impact\n\nMassive loss of user funds and protocol completely crippled\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/external/layer-zero/token/oft/OFTCore.sol#L31-L33\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nLimit the length of _toAddress to some amount (i.e. 256 bytes) as of right now EVM uses 20 bytes address and Sol/Aptos use 32 bytes address, so for right now it could be limited to 32 bytes.\n\n        function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n    +       require(_toAddress.length <= maxAddressLength);       \n            _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n        }\n\n## Discussion\n\n**WarTech9**\n\nWe are using  a non blocking receiver with both UXP and UXD tokens inheriting from the `OFTV2Core` base contract. Thus when a message is received `nonBlockingLzReceive` function is called which does not block the channel between 2 chains if an error occurs. \n\nPlease provide more details if you feel otherwise.\n\n**0x00052**\n\nCorrect you do use a non-blocking but using a huge _toAddress will cause the function to revert before the non-blocking error handling. \n\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external override receiveNonReentrant {\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n        LibraryConfig storage uaConfig = uaConfigLookup[_dstAddress];\n\n        // authentication to prevent cross-version message validation\n        // protects against a malicious library from passing arbitrary data\n        if (uaConfig.receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveLibraryAddress == msg.sender, \"LayerZero: invalid default library\");\n        } else {\n            require(uaConfig.receiveLibraryAddress == msg.sender, \"LayerZero: invalid library\");\n        }\n\n        // block if any message blocking\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash == bytes32(0), \"LayerZero: in message blocking\");\n\n        try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload) {\n            // success, do nothing, end of the message delivery\n        } catch (bytes memory reason) {\n            // revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);\n        }\n    }\n\nAbove is the code run on the endpoint. It will use the try statement to call the lzReceive on the non-blocking app. Due to the huge amount of calldata the try function will immediately revert because it will run out of gas. This bypasses all the logic of the app and causes the checkpoint to store the payload, blocking the channel\n\n**hrishibhat**\n\n@WarTech9 \n\n**WarTech9**\n\nThe message is only stored if the `catch` block is executed. In your example, if a huge amount of data is passed in the receive function would run out of gas before that gets executed. Secondly, the transaction would revert within the `catch` block itself if the payload is too huge as a result of a huge `_dstAddress` being passed in, thus, message would not be stored and channel would not be blocked. \n\n**WarTech9**\n\nThere could be some value in adding input size validation at source as recommended, since the size could be arbitrary. But this issue is medium/low risk\n\n**0x00052**\n\n    // assert and increment the nonce. no message shuffling    \n    require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n    \nThis line in endpoint requires that the nonce is sequential so if the message is too big to be executed at all then it will also block the channel even without being stored. As an example if the message with nonce == 1 cannot be executed at all due to gas limits then the channel would also be blocked because trying to execute nonce == 2 would always revert at that statement.\n\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable override sendNonReentrant {\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uint64 nonce = ++outboundNonce[_dstChainId][msg.sender];\n        _getSendLibrary(uaConfig).send{value: msg.value}(msg.sender, nonce, _dstChainId, _destination, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\nThe nonce of the message is set on the sending end of the endpoint so it's impossible to work around a nonce that can't execute.\n\n`Secondly, the transaction would revert within the catch block itself if the payload is too huge as a result of a huge _dstAddress being passed in, thus, message would not be stored and channel would not be blocked.`\n\nThis is not true either because the _dstAddress is not the same as _toAddress passed into the OFTCore#sendFrom. _toAddress is packed into the payload of the message and the dstAddress is set by [_lzSend](https://github.com/sherlock-audit/2023-01-uxd-0x00052/blob/main/contracts/external/layer-zero/lzApp/LzApp.sol#L45-L49):\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote //@audit _dstAddress, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\nThe destination address would be the address of the receiving contract (normal sized). Additionally when the message is stored, it only stores the hash of the message so it doesn't require a huge amount of gas to store.\n\n**hrishibhat**\n\nConsidering this a valid high issue based on the above comments. \n\n**0xIryna**\n\nLayerZero team is here. Thank you for digging into this!\nWe have a max payload size (10000) set in our `RelayerV2` contract which prevents the described situation (the contract isn’t verified, but you can fork a chain and test). If a payload exceeds the specified limit the transaction will revert on the source.\nIf a client application is configured to use a non-default Relayer it must set the payload limit itself.  Generally, we believe it’s a protocol’s responsibility to enforce the max payload size.\n\n**berndartmueller**\n\nEscalate for 10 USDC\n\nConsider the response from the LayerZero team above to reconsider the severity and validity of this issue. If UXD uses the `RelayerV2` contract provided by LayerZero, this is a non-issue.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Consider the response from the LayerZero team above to reconsider the severity and validity of this issue. If UXD uses the `RelayerV2` contract provided by LayerZero, this is a non-issue.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**rvierdiyev**\n\nEscalate for 15 usdc. \nIncreased amount just to make sure this will be rechecked.\n\n**sherlock-admin**\n\n > Escalate for 15 usdc. \n> Increased amount just to make sure this will be rechecked.\n\nYou've created a valid escalation for 15 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nComment from Layer Zero shows that there is a valid risk from payload which is now fixed:\nhttps://github.com/LayerZero-Labs/LayerZero/pull/24/commits\nThe relayer did not seem have a check for max payload size previously. \n\nAdditionally as suggested by the LZ  \n> we believe it’s a protocol’s responsibility to enforce the max payload size.\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Comment from Layer Zero shows that there is a valid risk from payload which is now fixed:\n> https://github.com/LayerZero-Labs/LayerZero/pull/24/commits\n> The relayer did not seem have a check for max payload size previously. \n> \n> Additionally as suggested by the LZ  \n> > we believe it’s a protocol’s responsibility to enforce the max payload size.\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/33",
  "Code": [
    {
      "filename": "contracts/external/layer-zero/token/oft/OFTCore.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../lzApp/NonblockingLzApp.sol\";\nimport \"./IOFTCore.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract OFTCore is NonblockingLzApp, ERC165, IOFTCore {\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert(\"OFTCore: unknown packet type\");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, \"OFTCore: _adapterParams must be empty.\");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}"
    }
  ]
}