{
  "Title": "[M10] Some state variables are not set during initialize",
  "Content": "The Audius contracts can be upgraded using the [unstructured storage proxy pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies). This pattern requires the use of an initializer instead of the constructor to set the initial values of the state variables. In some of the contracts, the initializer is not initializing all of the state variables.\n\n\nFor example, in the [`initializer` function of the `ClaimsManager` contract](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L78) the [`stakingAddress` state variable](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L17) is not set. It can be set later by calling [`setStakingAddress`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L163). However, this means that it is possible to call the [`processClaim` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L227) and some others without any staking address set, because they only [check that the contract has been initialized](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L232).\n\n\nThe same happens in the [`initializer` function of the `Governance` contract](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/Governance.sol#L122), which does not set the [`stakingAddress`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/Governance.sol#L20) either.\n\n\nConsider setting all the required variables in the initializer. If there is a reason for leaving them uninitialized consider documenting it, and adding checks on the functions that use those variables to ensure that they are not called before initialization.\n\n\n***Update**: Fixed in [pull request #589](https://github.com/AudiusProject/audius-protocol/pull/589).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/ClaimsManager.sol",
      "content": "pragma solidity ^0.5.0;\nimport \"./Staking.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\nimport \"./ServiceProviderFactory.sol\";\n/// @notice SafeMath imported via ServiceProviderFactory.sol\n\n\n/**\n * Designed to automate claim funding, minting tokens as necessary\n * @notice - will call InitializableV2 constructor\n */\ncontract ClaimsManager is InitializableV2 {\n    using SafeMath for uint256;\n    address private tokenAddress;\n    address private governanceAddress;\n    address private stakingAddress;\n    address private serviceProviderFactoryAddress;\n    address private delegateManagerAddress;\n\n    // Claim related configurations\n    /**\n      * @notice - Minimum number of blocks between funding rounds\n      *       604800 seconds / week\n      *       Avg block time - 13s\n      *       604800 / 13 = 46523.0769231 blocks\n      */\n    uint private fundingRoundBlockDiff;\n\n    /**\n      * @notice - Configures the current funding amount per round\n      *  Weekly rounds, 7% PA inflation = 70,000,000 new tokens in first year\n      *                                 = 70,000,000/365*7 (year is slightly more than a week)\n      *                                 = 1342465.75342 new AUDS per week\n      *                                 = 1342465753420000000000000 new wei units per week\n      * @dev - Past a certain block height, this schedule will be updated\n      *      - Logic determining schedule will be sourced from an external contract\n      */\n    uint private fundingAmount;\n\n    // Denotes current round\n    uint private roundNumber;\n\n    // Staking contract ref\n    ERC20Mintable private audiusToken;\n\n    // Struct representing round state\n    // 1) Block at which round was funded\n    // 2) Total funded for this round\n    // 3) Total claimed in round\n    struct Round {\n        uint fundBlock;\n        uint fundingAmount;\n        uint totalClaimedInRound;\n    }\n\n    // Current round information\n    Round currentRound;\n\n    event RoundInitiated(\n      uint _blockNumber,\n      uint _roundNumber,\n      uint _fundAmount\n    );\n\n    event ClaimProcessed(\n      address _claimer,\n      uint _rewards,\n      uint _oldTotal,\n      uint _newTotal\n    );\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _tokenAddress - address of ERC20 token that will be claimed\n     * @param _governanceAddress - address for Governance proxy contract\n     */\n    function initialize(\n        address _tokenAddress,\n        address _governanceAddress\n    ) public initializer\n    {\n        tokenAddress = _tokenAddress;\n        governanceAddress = _governanceAddress;\n\n        audiusToken = ERC20Mintable(tokenAddress);\n\n        fundingRoundBlockDiff = 46523;\n        fundingAmount = 1342465753420000000000000; // 1342465.75342 AUDS\n        roundNumber = 0;\n\n        currentRound = Round({\n            fundBlock: 0,\n            fundingAmount: 0,\n            totalClaimedInRound: 0\n        });\n\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the duration of a funding round in blocks\n    function getFundingRoundBlockDiff() external view returns (uint blockDiff)\n    {\n        return fundingRoundBlockDiff;\n    }\n\n    /// @notice Get the last block where a funding round was initiated\n    function getLastFundBlock() external view returns (uint lastFundBlock)\n    {\n        return currentRound.fundBlock;\n    }\n\n    /// @notice Get the amount funded per round in wei\n    function getFundsPerRound() external view returns (uint amount)\n    {\n        return fundingAmount;\n    }\n\n    /// @notice Get the total amount claimed in the current round\n    function getTotalClaimedInRound() external view returns (uint claimedAmount)\n    {\n        return currentRound.totalClaimedInRound;\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /// @notice Get the ServiceProviderFactory address\n    function getServiceProviderFactoryAddress() external view returns (address addr) {\n        return serviceProviderFactoryAddress;\n    }\n\n    /// @notice Get the DelegateManager address\n    function getDelegateManagerAddress() external view returns (address addr) {\n        return delegateManagerAddress;\n    }\n\n    /**\n     * @notice Get the Staking address\n     */\n    function getStakingAddress() external view returns (address addr)\n    {\n        return stakingAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        governanceAddress = _governanceAddress;\n    }\n\n    /**\n     * @notice Set the Staking address\n     * @dev Only callable by Governance address\n     * @param _address - address for new Staking contract\n     */\n    function setStakingAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        stakingAddress = _address;\n    }\n\n    /**\n     * @notice Set the ServiceProviderFactory address\n     * @dev Only callable by Governance address\n     * @param _spFactory - address for new ServiceProviderFactory contract\n     */\n    function setServiceProviderFactoryAddress(address _spFactory) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        serviceProviderFactoryAddress = _spFactory;\n    }\n\n    /**\n     * @notice Set the DelegateManager address\n     * @dev Only callable by Governance address\n     * @param _delegateManager - address for new DelegateManager contract\n     */\n    function setDelegateManagerAddress(address _delegateManager) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        delegateManagerAddress = _delegateManager;\n    }\n\n    /**\n     * @notice Start a new funding round\n     * @dev Permissioned to be callable by stakers or governance contract\n     */\n    function initiateRound() external {\n        _requireIsInitialized();\n\n        bool senderStaked = Staking(stakingAddress).totalStakedFor(msg.sender) > 0;\n        require(\n            senderStaked || (msg.sender == governanceAddress),\n            \"Only callable by staked account or Governance contract\"\n        );\n\n        require(\n            block.number.sub(currentRound.fundBlock) > fundingRoundBlockDiff,\n            \"Required block difference not met\"\n        );\n\n        currentRound = Round({\n            fundBlock: block.number,\n            fundingAmount: fundingAmount,\n            totalClaimedInRound: 0\n        });\n\n        roundNumber = roundNumber.add(1);\n\n        emit RoundInitiated(\n            currentRound.fundBlock,\n            roundNumber,\n            currentRound.fundingAmount\n        );\n    }\n\n    /**\n     * @notice Mints and stakes tokens on behalf of ServiceProvider + delegators\n     * @dev Callable through DelegateManager by Service Provider\n     * @param _claimer  - service provider address\n     * @param _totalLockedForSP - amount of tokens locked up across DelegateManager + ServiceProvider\n     */\n    function processClaim(\n        address _claimer,\n        uint _totalLockedForSP\n    ) external\n    {\n        _requireIsInitialized();\n        require(\n            msg.sender == delegateManagerAddress,\n            \"ProcessClaim only accessible to DelegateManager\"\n        );\n\n        Staking stakingContract = Staking(stakingAddress);\n        // Prevent duplicate claim\n        uint lastUserClaimBlock = stakingContract.lastClaimedFor(_claimer);\n        require(lastUserClaimBlock <= currentRound.fundBlock, \"Claim already processed for user\");\n        uint totalStakedAtFundBlockForClaimer = stakingContract.totalStakedForAt(\n            _claimer,\n            currentRound.fundBlock);\n\n        (,,bool withinBounds,,,) = (\n            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_claimer)\n        );\n\n        // Once they claim the zero reward amount, stake can be modified once again\n        // Subtract total locked amount for SP from stake at fund block\n        uint claimerTotalStake = totalStakedAtFundBlockForClaimer.sub(_totalLockedForSP);\n        uint totalStakedAtFundBlock = stakingContract.totalStakedAt(currentRound.fundBlock);\n\n        // Calculate claimer rewards\n        uint rewardsForClaimer = (\n          claimerTotalStake.mul(fundingAmount)\n        ).div(totalStakedAtFundBlock);\n\n        // For a claimer violating bounds, no new tokens are minted\n        // Claim history is marked to zero and function is short-circuited\n        // Total rewards can be zero if all stake is currently locked up\n        if (!withinBounds || rewardsForClaimer == 0) {\n            stakingContract.updateClaimHistory(0, _claimer);\n            return;\n        }\n\n        // ERC20Mintable always returns true\n        audiusToken.mint(address(this), rewardsForClaimer);\n\n        // ERC20 always returns true\n        audiusToken.approve(stakingAddress, rewardsForClaimer);\n\n        // Transfer rewards\n        stakingContract.stakeRewards(rewardsForClaimer, _claimer);\n\n        // Update round claim value\n        currentRound.totalClaimedInRound = currentRound.totalClaimedInRound.add(rewardsForClaimer);\n\n        // Update round claim value\n        uint newTotal = stakingContract.totalStakedFor(_claimer);\n\n        emit ClaimProcessed(\n            _claimer,\n            rewardsForClaimer,\n            totalStakedAtFundBlockForClaimer,\n            newTotal\n        );\n    }\n\n    /**\n     * @notice Modify funding amount per round\n     * @param _newAmount - new amount to fund per round in wei\n     */\n    function updateFundingAmount(uint _newAmount)\n    external returns (uint newAmount)\n    {\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n        fundingAmount = _newAmount;\n        return _newAmount;\n    }\n\n    /**\n     * @notice Returns boolean indicating whether a claim is considered pending\n     * @dev Note that an address with no endpoints can never have a pending claim\n     * @param _sp - address of the service provider to check\n     * @return boolean - true if eligible for claim, false if not\n     */\n    function claimPending(address _sp) external view returns (bool pending) {\n        uint lastClaimedForSP = Staking(stakingAddress).lastClaimedFor(_sp);\n        (,,,uint numEndpoints,,) = (\n            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_sp)\n        );\n        return (lastClaimedForSP < currentRound.fundBlock && numEndpoints > 0);\n    }\n\n    /**\n     * @notice Modify minimum block difference between funding rounds\n     * @param _newFundingRoundBlockDiff - new min block difference to set\n     */\n    function updateFundingRoundBlockDiff(uint _newFundingRoundBlockDiff) external {\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n        fundingRoundBlockDiff = _newFundingRoundBlockDiff;\n    }\n}"
    },
    {
      "filename": "eth-contracts/contracts/Governance.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"./Staking.sol\";\nimport \"./registry/Registry.sol\";\nimport \"./InitializableV2.sol\";\n\n\ncontract Governance is InitializableV2 {\n    using SafeMath for uint;\n\n    /**\n     * @notice Address and contract instance of Audius Registry. Used to ensure this contract\n     *      can only govern contracts that are registered in the Audius Registry.\n     */\n    Registry private registry;\n    address private registryAddress;\n\n    /// @notice Address of Audius staking contract, used to permission Governance method calls\n    address private stakingAddress;\n\n    /// @notice Period in blocks for which a governance proposal is open for voting\n    uint256 private votingPeriod;\n\n    /// @notice Required miniumum number of votes to consider a proposal valid\n    uint256 private votingQuorum;\n\n    /**\n     * @notice Address of account that has special Governance permissions. Can veto proposals\n     *      and execute transactions directly on contracts.\n     */\n    address private guardianAddress;\n\n    /***** Enums *****/\n\n    /**\n     * @notice All Proposal Outcome states.\n     *      InProgress - Proposal is active and can be voted on\n     *      No - Proposal votingPeriod has closed and decision is No. Proposal will not be executed.\n     *      Yes - Proposal votingPeriod has closed and decision is Yes. Proposal will be executed.\n     *      Invalid - Proposal votingPeriod has closed and votingQuorum was not met. Proposal will not be executed.\n     *      TxFailed - Proposal voting decision was Yes, but transaction execution failed.\n     *      Evaluating - Proposal voting decision was Yes, and evaluateProposalOutcome function is currently running.\n     *          This status is transiently used inside that function to prevent re-entrancy.\n     */\n    enum Outcome {InProgress, No, Yes, Invalid, TxFailed, Evaluating}\n\n    /**\n     * @notice All Proposal Vote states for a voter.\n     *      None - The default state, for any account that has not previously voted on this Proposal.\n     *      No - The account voted No on this Proposal.\n     *      Yes - The account voted Yes on this Proposal.\n     *\n     * @dev Enum values map to uints, so first value in Enum always is 0.\n     */\n    enum Vote {None, No, Yes}\n\n    struct Proposal {\n        uint256 proposalId;\n        address proposer;\n        uint256 startBlockNumber;\n        bytes32 targetContractRegistryKey;\n        address targetContractAddress;\n        uint callValue;\n        string signature;\n        bytes callData;\n        Outcome outcome;\n        uint256 voteMagnitudeYes;\n        uint256 voteMagnitudeNo;\n        uint256 numVotes;\n        mapping(address => Vote) votes;\n    }\n\n    /***** Proposal storage *****/\n    uint256 lastProposalId = 0;\n    mapping(uint256 => Proposal) proposals;\n\n    /***** Events *****/\n    event ProposalSubmitted(\n        uint256 indexed proposalId,\n        address indexed proposer,\n        uint256 startBlockNumber,\n        string description\n    );\n    event ProposalVoteSubmitted(\n        uint256 indexed proposalId,\n        address indexed voter,\n        Vote indexed vote,\n        uint256 voterStake,\n        Vote previousVote\n    );\n    event ProposalOutcomeEvaluated(\n        uint256 indexed proposalId,\n        Outcome indexed outcome,\n        uint256 voteMagnitudeYes,\n        uint256 voteMagnitudeNo,\n        uint256 numVotes\n    );\n    event ProposalTransactionExecuted(\n        uint256 indexed proposalId,\n        bool indexed success,\n        bytes returnData\n    );\n    event GuardianTransactionExecuted(\n        address indexed targetContractAddress,\n        uint256 callValue,\n        string indexed signature,\n        bytes indexed callData,\n        bytes returnData\n    );\n    event ProposalVetoed(uint256 indexed proposalId);\n\n    /**\n     * @notice Initialize the Governance contract\n     * @dev _votingPeriod <= DelegateManager.undelegateLockupDuration\n     * @param _registryAddress - address of the registry proxy contract\n     * @param _votingPeriod - period in blocks for which a governance proposal is open for voting\n     * @param _votingQuorum - required minimum number of votes to consider a proposal valid\n     * @param _guardianAddress - address of account that has special Governance permissions\n\n     */\n    function initialize(\n        address _registryAddress,\n        uint256 _votingPeriod,\n        uint256 _votingQuorum,\n        address _guardianAddress\n    ) public initializer {\n        require(_registryAddress != address(0x00), \"Requires non-zero _registryAddress\");\n        registryAddress = _registryAddress;\n        registry = Registry(_registryAddress);\n\n        require(_votingPeriod > 0, \"Requires non-zero _votingPeriod\");\n        votingPeriod = _votingPeriod;\n\n        require(_votingQuorum > 0, \"Requires non-zero _votingQuorum\");\n        votingQuorum = _votingQuorum;\n\n        require(_guardianAddress != address(0x00), \"Requires non-zero _guardianAddress\");\n        guardianAddress = _guardianAddress;  //Guardian address becomes the only party\n\n        InitializableV2.initialize();\n    }\n\n    // ========================================= Governance Actions =========================================\n\n    /**\n     * @notice Submit a proposal for vote. Only callable by stakers with non-zero stake.\n     * @param _targetContractRegistryKey - Registry key for the contract concerning this proposal\n     * @param _callValue - amount of wei to pass with function call if a token transfer is involved\n     * @param _signature - function signature of the function to be executed if proposal is successful\n     * @param _callData - encoded value(s) to call function with if proposal is successful\n     * @param _description - Text description of proposal to be emitted in event\n     */\n    function submitProposal(\n        bytes32 _targetContractRegistryKey,\n        uint256 _callValue,\n        string calldata _signature,\n        bytes calldata _callData,\n        string calldata _description\n    ) external returns (uint256 proposalId)\n    {\n        _requireIsInitialized();\n\n        address proposer = msg.sender;\n\n        // Require proposer is active Staker\n        Staking stakingContract = Staking(stakingAddress);\n        require(\n            stakingContract.totalStakedFor(proposer) > 0,\n            \"Proposer must be active staker with non-zero stake.\"\n        );\n\n        // Require _targetContractRegistryKey points to a valid registered contract\n        address targetContractAddress = registry.getContract(_targetContractRegistryKey);\n        require(\n            targetContractAddress != address(0x00),\n            \"_targetContractRegistryKey must point to valid registered contract\"\n        );\n\n        // Signature cannot be empty\n        require(\n            bytes(_signature).length != 0,\n            \"Governance::submitProposal: _signature cannot be empty.\"\n        );\n\n        // set proposalId\n        uint256 newProposalId = lastProposalId.add(1);\n\n        // Store new Proposal obj in proposals mapping\n        proposals[newProposalId] = Proposal({\n            proposalId: newProposalId,\n            proposer: proposer,\n            startBlockNumber: block.number,\n            targetContractRegistryKey: _targetContractRegistryKey,\n            targetContractAddress: targetContractAddress,\n            callValue: _callValue,\n            signature: _signature,\n            callData: _callData,\n            outcome: Outcome.InProgress,\n            voteMagnitudeYes: 0,\n            voteMagnitudeNo: 0,\n            numVotes: 0\n            /* votes: mappings are auto-initialized to default state */\n        });\n\n        emit ProposalSubmitted(\n            newProposalId,\n            proposer,\n            block.number,\n            _description\n        );\n\n        lastProposalId = lastProposalId.add(1);\n\n        return newProposalId;\n    }\n\n    /**\n     * @notice Vote on an active Proposal. Only callable by stakers with non-zero stake.\n     * @param _proposalId - id of the proposal this vote is for\n     * @param _vote - can be either {Yes, No} from Vote enum. No other values allowed\n     */\n    function submitProposalVote(uint256 _proposalId, Vote _vote) external {\n        _requireIsInitialized();\n\n        address voter = msg.sender;\n\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Must provide valid non-zero _proposalId\"\n        );\n\n        // Require voter is active Staker + get voterStake.\n        Staking stakingContract = Staking(stakingAddress);\n\n        uint256 voterStake = stakingContract.totalStakedForAt(\n            voter,\n            proposals[_proposalId].startBlockNumber\n        );\n        require(voterStake > 0, \"Voter must be active staker with non-zero stake.\");\n\n        // Require proposal is still active\n        require(\n            proposals[_proposalId].outcome == Outcome.InProgress,\n            \"Governance::submitProposalVote: Cannot vote on inactive proposal.\"\n        );\n\n        // Require proposal votingPeriod is still active.\n        uint256 startBlockNumber = proposals[_proposalId].startBlockNumber;\n        uint256 endBlockNumber = startBlockNumber.add(votingPeriod);\n        require(\n            block.number > startBlockNumber && block.number <= endBlockNumber,\n            \"Governance::submitProposalVote: Proposal votingPeriod has ended\"\n        );\n\n        // Require vote is either Yes or No\n        require(\n            _vote == Vote.Yes || _vote == Vote.No,\n            \"Governance::submitProposalVote: Can only submit a Yes or No vote\"\n        );\n\n        // Record previous vote.\n        Vote previousVote = proposals[_proposalId].votes[voter];\n\n        // Will override staker's previous vote if present.\n        proposals[_proposalId].votes[voter] = _vote;\n\n        /* Update voteMagnitudes accordingly */\n\n        // New voter (Vote enum defaults to 0)\n        if (previousVote == Vote.None) {\n            if (_vote == Vote.Yes) {\n                proposals[_proposalId].voteMagnitudeYes = (\n                    proposals[_proposalId].voteMagnitudeYes.add(voterStake)\n                );\n            } else {\n                proposals[_proposalId].voteMagnitudeNo = (\n                    proposals[_proposalId].voteMagnitudeNo.add(voterStake)\n                );\n            }\n            proposals[_proposalId].numVotes = proposals[_proposalId].numVotes.add(1);\n        } else { // Repeat voter\n            if (previousVote == Vote.Yes && _vote == Vote.No) {\n                proposals[_proposalId].voteMagnitudeYes = (\n                    proposals[_proposalId].voteMagnitudeYes.sub(voterStake)\n                );\n                proposals[_proposalId].voteMagnitudeNo = (\n                    proposals[_proposalId].voteMagnitudeNo.add(voterStake)\n                );\n            } else if (previousVote == Vote.No && _vote == Vote.Yes) {\n                proposals[_proposalId].voteMagnitudeYes = (\n                    proposals[_proposalId].voteMagnitudeYes.add(voterStake)\n                );\n                proposals[_proposalId].voteMagnitudeNo = (\n                    proposals[_proposalId].voteMagnitudeNo.sub(voterStake)\n                );\n            }\n            // If _vote == previousVote, no changes needed to vote magnitudes.\n        }\n\n        emit ProposalVoteSubmitted(\n            _proposalId,\n            voter,\n            _vote,\n            voterStake,\n            previousVote\n        );\n    }\n\n    /**\n     * @notice Once the voting period for a proposal has ended, evaluate the outcome and\n     *      execute the proposal if stake-weighted vote is >= 50% Yes and voting quorum met.\n     * @dev Requires that caller is an active staker at the time the proposal is created\n     * @param _proposalId - id of the proposal\n     */\n    function evaluateProposalOutcome(uint256 _proposalId)\n    external returns (Outcome proposalOutcome)\n    {\n        _requireIsInitialized();\n\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Governance::evaluateProposalOutcome: Must provide valid non-zero _proposalId.\"\n        );\n\n        // Require proposal has not already been evaluated.\n        require(\n            proposals[_proposalId].outcome == Outcome.InProgress,\n            \"Governance::evaluateProposalOutcome: Cannot evaluate inactive proposal.\"\n        );\n\n        /// Re-entrancy should not be possible here since this switches the status of the\n        /// proposal to 'Evaluating' so it should fail the status is 'InProgress' check\n        proposals[_proposalId].outcome = Outcome.Evaluating;\n\n        // Require msg.sender is active Staker.\n        Staking stakingContract = Staking(stakingAddress);\n\n        require(\n            stakingContract.totalStakedForAt(\n                msg.sender, proposals[_proposalId].startBlockNumber\n            ) > 0,\n            \"Governance::evaluateProposalOutcome: Caller must be active staker with non-zero stake.\"\n        );\n\n        // Require proposal votingPeriod has ended.\n        uint256 startBlockNumber = proposals[_proposalId].startBlockNumber;\n        uint256 endBlockNumber = startBlockNumber.add(votingPeriod);\n        require(\n            block.number > endBlockNumber,\n            \"Governance::evaluateProposalOutcome: Proposal votingPeriod must end before evaluation.\"\n        );\n\n        // Require registered contract address for provided registryKey has not changed.\n        address targetContractAddress = registry.getContract(\n            proposals[_proposalId].targetContractRegistryKey\n        );\n        require(\n            targetContractAddress == proposals[_proposalId].targetContractAddress,\n            \"Governance::evaluateProposalOutcome: Registered contract address for targetContractRegistryKey has changed\"\n        );\n\n        // Calculate outcome\n        Outcome outcome;\n        // votingQuorum not met -> proposal is invalid.\n        if (proposals[_proposalId].numVotes < votingQuorum) {\n            outcome = Outcome.Invalid;\n        }\n        // votingQuorum met & vote is Yes -> execute proposed transaction & close proposal.\n        else if (\n            proposals[_proposalId].voteMagnitudeYes >= proposals[_proposalId].voteMagnitudeNo\n        ) {\n            (bool success, bytes memory returnData) = _executeTransaction(\n                targetContractAddress,\n                proposals[_proposalId].callValue,\n                proposals[_proposalId].signature,\n                proposals[_proposalId].callData\n            );\n\n            emit ProposalTransactionExecuted(\n                _proposalId,\n                success,\n                returnData\n            );\n\n            // Proposal outcome depends on success of transaction execution.\n            if (success) {\n                outcome = Outcome.Yes;\n            } else {\n                outcome = Outcome.TxFailed;\n            }\n        }\n        // votingQuorum met & vote is No -> close proposal without transaction execution.\n        else {\n            outcome = Outcome.No;\n        }\n\n        /// This records the final outcome in the proposals mapping\n        proposals[_proposalId].outcome = outcome;\n\n        emit ProposalOutcomeEvaluated(\n            _proposalId,\n            outcome,\n            proposals[_proposalId].voteMagnitudeYes,\n            proposals[_proposalId].voteMagnitudeNo,\n            proposals[_proposalId].numVotes\n        );\n\n        return outcome;\n    }\n\n    /**\n     * @notice Action limited to the guardian address that can veto a proposal\n     * @param _proposalId - id of the proposal\n     */\n    function vetoProposal(uint256 _proposalId) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == guardianAddress,\n            \"Governance::vetoProposal: Only guardian can veto proposals.\"\n        );\n\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Governance::vetoProposal: Must provide valid non-zero _proposalId.\"\n        );\n\n        require(\n            proposals[_proposalId].outcome == Outcome.InProgress,\n            \"Governance::vetoProposal: Cannot veto inactive proposal.\"\n        );\n\n        proposals[_proposalId].outcome = Outcome.No;\n\n        emit ProposalVetoed(_proposalId);\n    }\n\n    // ========================================= Config Setters =========================================\n\n    /**\n     * @notice Set the Staking address\n     * @dev Only callable by self via _executeTransaction\n     * @param _stakingAddress - address for new Staking contract\n     */\n    function setStakingAddress(address _stakingAddress) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        require(_stakingAddress != address(0x00), \"Requires non-zero _stakingAddress\");\n        stakingAddress = _stakingAddress;\n    }\n\n    /**\n     * @notice Set the voting period for a Governance proposal\n     * @dev Only callable by self via _executeTransaction\n     * @param _votingPeriod - new voting period\n     */\n    function setVotingPeriod(uint256 _votingPeriod) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        votingPeriod = _votingPeriod;\n    }\n\n    /**\n     * @notice Set the voting quorum for a Governance proposal\n     * @dev Only callable by self via _executeTransaction\n     * @param _votingQuorum - new voting period\n     */\n    function setVotingQuorum(uint256 _votingQuorum) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        votingQuorum = _votingQuorum;\n    }\n\n    /**\n     * @notice Set the Registry address\n     * @dev Only callable by self via _executeTransaction\n     * @param _registryAddress - address for new Registry contract\n     */\n    function setRegistryAddress(address _registryAddress) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        require(_registryAddress != address(0x00), \"Requires non-zero _registryAddress\");\n        registryAddress = _registryAddress;\n        registry = Registry(_registryAddress);\n    }\n\n    // ========================================= Guardian Actions =========================================\n\n    /**\n     * @notice Allows the guardianAddress to execute protocol actions\n     * @param _targetContractRegistryKey - key in registry of target contraact\n     * @param _callValue - amount of wei if a token transfer is involved\n     * @param _signature - function signature of the function to be executed if proposal is successful\n     * @param _callData - encoded value(s) to call function with if proposal is successful\n     */\n    function guardianExecuteTransaction(\n        bytes32 _targetContractRegistryKey,\n        uint256 _callValue,\n        string calldata _signature,\n        bytes calldata _callData\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == guardianAddress,\n            \"Governance::guardianExecuteTransaction: Only guardian.\"\n        );\n\n        // _targetContractRegistryKey must point to a valid registered contract\n        address targetContractAddress = registry.getContract(_targetContractRegistryKey);\n        require(\n            targetContractAddress != address(0x00),\n            \"Governance::guardianExecuteTransaction: _targetContractRegistryKey must point to valid registered contract\"\n        );\n\n        // Signature cannot be empty\n        require(\n            bytes(_signature).length != 0,\n            \"Governance::guardianExecuteTransaction: _signature cannot be empty.\"\n        );\n\n        (bool success, bytes memory returnData) = _executeTransaction(\n            targetContractAddress,\n            _callValue,\n            _signature,\n            _callData\n        );\n\n        require(success, \"Governance::guardianExecuteTransaction: Transaction failed.\");\n\n        emit GuardianTransactionExecuted(\n            targetContractAddress,\n            _callValue,\n            _signature,\n            _callData,\n            returnData\n        );\n    }\n\n    /**\n     * @notice Change the guardian address\n     * @dev Only callable by current guardian\n     * @param _newGuardianAddress - new guardian address\n     */\n    function transferGuardianship(address _newGuardianAddress) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == guardianAddress,\n            \"Governance::guardianExecuteTransaction: Only guardian.\"\n        );\n\n        guardianAddress = _newGuardianAddress;\n    }\n\n    // ========================================= Getter Functions =========================================\n\n    /**\n     * @notice Get proposal information by proposal Id\n     * @param _proposalId - id of proposal\n     */\n    function getProposalById(uint256 _proposalId)\n    external view returns (\n        uint256 proposalId,\n        address proposer,\n        uint256 startBlockNumber,\n        bytes32 targetContractRegistryKey,\n        address targetContractAddress,\n        uint callValue,\n        string memory signature,\n        bytes memory callData,\n        Outcome outcome,\n        uint256 voteMagnitudeYes,\n        uint256 voteMagnitudeNo,\n        uint256 numVotes\n    )\n    {\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Must provide valid n"
    }
  ]
}