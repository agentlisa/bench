{
  "Title": "Silent failure can occur when delegating to a Diamond Proxy facet with no code",
  "Content": "**Description:** If the [Diamond proxy delegates](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/Diamond.sol#L35-L55) to an incorrect address or an implementation that has been self-destructed, the call to the \"implementation\" will return a success boolean despite no code being executed.\n\n**Impact:** In the case of a payable function call with ETH attached, silent failure of the delegatecall to a non-existent implementation can result in this value being permanently lost.\n\n**Proof of Concept:** The *No contract existence check* section of the article [*Good idea, bad design: How the Diamond standard falls short*](https://blog.trailofbits.com/2020/10/30/good-idea-bad-design-how-the-diamond-standard-falls-short/) by [Trail of Bits](https://www.trailofbits.com/) further details this issue.\n\n**Recommended Mitigation:** Consider checking for contract existence when calling an arbitrary contract. Alternatively, in the interest of gas efficiency, only perform this check if the return data size of the call is zero since the opposite result means that some code was executed.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/Diamond.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Authors: Nick Mudge (https://twitter.com/mudgen)\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {DiamondCutFacet} from \"./diamond/DiamondCutFacet.sol\";\nimport {DiamondLoupeFacet} from \"./diamond/DiamondLoupeFacet.sol\";\nimport {OwnershipFacet} from \"./diamond/OwnershipFacet.sol\";\nimport {AppStorage} from \"./AppStorage.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\n\ncontract Diamond {\n    AppStorage internal s;\n\n    receive() external payable {}\n\n    constructor(address _contractOwner) {\n        LibDiamond.setContractOwner(_contractOwner);\n        LibDiamond.addDiamondFunctions(\n            address(new DiamondCutFacet()),\n            address(new DiamondLoupeFacet())\n        );\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n}"
    }
  ]
}