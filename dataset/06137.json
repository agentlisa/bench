{
  "Title": "[L-05] Delegated executor configs are not cleared on transfer",
  "Content": "\nWhen profiles are transferred, its delegated executor config is not cleared. Instead, the function switches its config to a new config:\n\n[LensProfiles.sol#L165-L177](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/base/LensProfiles.sol#L165-L177)\n\n```solidity\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override whenNotPaused {\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\n            // Cannot transfer profile if the guardian is enabled, except at minting time.\n            revert Errors.GuardianEnabled();\n        }\n        // Switches to new fresh delegated executors configuration (except on minting, as it already has a fresh setup).\n        if (from != address(0)) {\n            ProfileLib.switchToNewFreshDelegatedExecutorsConfig(tokenId);\n        }\n```\n\nThis could potentially be dangerous as users are able to switch back to previous configs using [`changeDelegatedExecutorsConfig()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L149-L163). If a previous owner had added himself to previous configs, switching back to a previous config might potentially give the previous owner the ability to steal the profile, or execute malicious functions as a delegated executor.\n\n### Recommendation\n\nConsider warning users about the danger of switching to previous configs in the documentation.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/base/LensProfiles.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\nimport {ILensProfiles} from 'contracts/interfaces/ILensProfiles.sol';\nimport {IERC721Burnable} from 'contracts/interfaces/IERC721Burnable.sol';\nimport {IModuleGlobals} from 'contracts/interfaces/IModuleGlobals.sol';\n\nimport {LensBaseERC721} from 'contracts/base/LensBaseERC721.sol';\nimport {ProfileLib} from 'contracts/libraries/ProfileLib.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {ProfileTokenURILib} from 'contracts/libraries/token-uris/ProfileTokenURILib.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\n\nimport {ERC2981CollectionRoyalties} from 'contracts/base/ERC2981CollectionRoyalties.sol';\n\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Events} from 'contracts/libraries/constants/Events.sol';\n\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\nabstract contract LensProfiles is LensBaseERC721, ERC2981CollectionRoyalties, ILensProfiles {\n    using Address for address;\n\n    IModuleGlobals immutable MODULE_GLOBALS;\n\n    uint256 internal immutable TOKEN_GUARDIAN_COOLDOWN;\n\n    constructor(address moduleGlobals, uint256 tokenGuardianCooldown) {\n        MODULE_GLOBALS = IModuleGlobals(moduleGlobals);\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\n    }\n\n    modifier whenNotPaused() {\n        if (StorageLib.getState() == Types.ProtocolState.Paused) {\n            revert Errors.Paused();\n        }\n        _;\n    }\n\n    modifier onlyProfileOwner(address expectedOwner, uint256 profileId) {\n        ValidationLib.validateAddressIsProfileOwner(expectedOwner, profileId);\n        _;\n    }\n\n    modifier onlyEOA() {\n        if (msg.sender.isContract()) {\n            revert Errors.NotEOA();\n        }\n        _;\n    }\n\n    /// @inheritdoc ILensProfiles\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256) {\n        return StorageLib.tokenGuardianDisablingTimestamp()[wallet];\n    }\n\n    /// @inheritdoc ILensProfiles\n    function DANGER__disableTokenGuardian() external onlyEOA {\n        if (StorageLib.tokenGuardianDisablingTimestamp()[msg.sender] != 0) {\n            revert Errors.DisablingAlreadyTriggered();\n        }\n        StorageLib.tokenGuardianDisablingTimestamp()[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\n        emit Events.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: false,\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\n            timestamp: block.timestamp\n        });\n    }\n\n    /// @inheritdoc ILensProfiles\n    function enableTokenGuardian() external onlyEOA {\n        if (StorageLib.tokenGuardianDisablingTimestamp()[msg.sender] == 0) {\n            revert Errors.AlreadyEnabled();\n        }\n        StorageLib.tokenGuardianDisablingTimestamp()[msg.sender] = 0;\n        emit Events.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: true,\n            tokenGuardianDisablingTimestamp: 0,\n            timestamp: block.timestamp\n        });\n    }\n\n    /**\n     * @notice Burns a profile, this maintains the profile data struct.\n     */\n    function burn(uint256 tokenId)\n        public\n        override(LensBaseERC721, IERC721Burnable)\n        whenNotPaused\n        onlyProfileOwner(msg.sender, tokenId)\n    {\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev Overrides the ERC721 tokenURI function to return the associated URI with a given profile.\n     */\n    function tokenURI(uint256 tokenId) public view override(LensBaseERC721, IERC721Metadata) returns (string memory) {\n        if (!_exists(tokenId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return ProfileTokenURILib.getTokenURI(tokenId);\n    }\n\n    function approve(address to, uint256 tokenId) public override(LensBaseERC721, IERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(msg.sender)) {\n            revert Errors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(LensBaseERC721, IERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\n            revert Errors.GuardianEnabled();\n        }\n        super.setApprovalForAll(operator, approved);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(LensBaseERC721, ERC2981CollectionRoyalties, IERC165)\n        returns (bool)\n    {\n        return\n            LensBaseERC721.supportsInterface(interfaceId) || ERC2981CollectionRoyalties.supportsInterface(interfaceId);\n    }\n\n    function _hasTokenGuardianEnabled(address wallet) internal view returns (bool) {\n        return\n            !wallet.isContract() &&\n            (StorageLib.tokenGuardianDisablingTimestamp()[wallet] == 0 ||\n                block.timestamp < StorageLib.tokenGuardianDisablingTimestamp()[wallet]);\n    }\n\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256) {\n        return StorageLib.PROFILE_ROYALTIES_BPS_SLOT;\n    }\n\n    function _getReceiver(\n        uint256 /* tokenId */\n    ) internal view override returns (address) {\n        return MODULE_GLOBALS.getTreasury();\n    }\n\n    function _beforeRoyaltiesSet(\n        uint256 /* royaltiesInBasisPoints */\n    ) internal view override {\n        ValidationLib.validateCallerIsGovernance();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override whenNotPaused {\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\n            // Cannot transfer profile if the guardian is enabled, except at minting time.\n            revert Errors.GuardianEnabled();\n        }\n        // Switches to new fresh delegated executors configuration (except on minting, as it already has a fresh setup).\n        if (from != address(0)) {\n            ProfileLib.switchToNewFreshDelegatedExecutorsConfig(tokenId);\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}"
    },
    {
      "filename": "contracts/LensHub.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n// Interfaces\nimport {ILensProtocol} from 'contracts/interfaces/ILensProtocol.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\n\n// Constants\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\n\n// Lens Hub Components\nimport {LensHubStorage} from 'contracts/base/LensHubStorage.sol';\nimport {LensImplGetters} from 'contracts/base/LensImplGetters.sol';\nimport {LensGovernable} from 'contracts/base/LensGovernable.sol';\nimport {LensProfiles} from 'contracts/base/LensProfiles.sol';\nimport {LensHubEventHooks} from 'contracts/base/LensHubEventHooks.sol';\n\n// Libraries\nimport {ActionLib} from 'contracts/libraries/ActionLib.sol';\nimport {LegacyCollectLib} from 'contracts/libraries/LegacyCollectLib.sol';\nimport {FollowLib} from 'contracts/libraries/FollowLib.sol';\nimport {MetaTxLib} from 'contracts/libraries/MetaTxLib.sol';\nimport {ProfileLib} from 'contracts/libraries/ProfileLib.sol';\nimport {PublicationLib} from 'contracts/libraries/PublicationLib.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\n\n// Lens Migrations V1 to V2\nimport {LensV2Migration} from 'contracts/misc/LensV2Migration.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entry point of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke a LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is\n    LensProfiles,\n    LensGovernable,\n    LensV2Migration,\n    LensImplGetters,\n    LensHubEventHooks,\n    LensHubStorage,\n    ILensProtocol\n{\n    modifier onlyProfileOwnerOrDelegatedExecutor(address expectedOwnerOrDelegatedExecutor, uint256 profileId) {\n        ValidationLib.validateAddressIsProfileOwnerOrDelegatedExecutor(expectedOwnerOrDelegatedExecutor, profileId);\n        _;\n    }\n\n    modifier whenPublishingEnabled() {\n        if (StorageLib.getState() != Types.ProtocolState.Unpaused) {\n            revert Errors.PublishingPaused();\n        }\n        _;\n    }\n\n    constructor(\n        address moduleGlobals,\n        address followNFTImpl,\n        address collectNFTImpl, // We still pass the deprecated CollectNFTImpl for legacy Collects to work\n        address lensHandlesAddress,\n        address tokenHandleRegistryAddress,\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule,\n        uint256 tokenGuardianCooldown\n    )\n        LensProfiles(moduleGlobals, tokenGuardianCooldown)\n        LensV2Migration(\n            legacyFeeFollowModule,\n            legacyProfileFollowModule,\n            newFeeFollowModule,\n            lensHandlesAddress,\n            tokenHandleRegistryAddress\n        )\n        LensImplGetters(followNFTImpl, collectNFTImpl)\n    {}\n\n    /// @inheritdoc ILensProtocol\n    function createProfile(Types.CreateProfileParams calldata createProfileParams)\n        external\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        ValidationLib.validateProfileCreatorWhitelisted(msg.sender);\n        unchecked {\n            uint256 profileId = ++_profileCounter;\n            _mint(createProfileParams.to, profileId);\n            ProfileLib.createProfile(createProfileParams, profileId);\n            return profileId;\n        }\n    }\n\n    ///////////////////////////////////////////\n    ///        PROFILE OWNER FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURI(uint256 profileId, string calldata metadataURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileMetadataURISignature(signature, profileId, metadataURI);\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId) {\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModuleWithSig(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetFollowModuleSignature(signature, profileId, followModule, followModuleInitData);\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeDelegatedExecutorsConfig(delegatorProfileId, delegatedExecutors, approvals);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfigWithSig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwner(signature.signer, delegatorProfileId) {\n        MetaTxLib.validateChangeDelegatedExecutorsConfigSignature(\n            signature,\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURIWithSig(\n        uint256 profileId,\n        string calldata imageURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileImageURISignature(signature, profileId, imageURI);\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    ////////////////////////////////////////\n    ///        PUBLISHING FUNCTIONS      ///\n    ////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function post(Types.PostParams calldata postParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, postParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.post({postParams: postParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function postWithSig(Types.PostParams calldata postParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, postParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validatePostSignature(signature, postParams);\n        return PublicationLib.post({postParams: postParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function comment(Types.CommentParams calldata commentParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, commentParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function commentWithSig(Types.CommentParams calldata commentParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, commentParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateCommentSignature(signature, commentParams);\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirror(Types.MirrorParams calldata mirrorParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, mirrorParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirrorWithSig(Types.MirrorParams calldata mirrorParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, mirrorParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateMirrorSignature(signature, mirrorParams);\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quote(Types.QuoteParams calldata quoteParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, quoteParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quoteWithSig(Types.QuoteParams calldata quoteParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, quoteParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateQuoteSignature(signature, quoteParams);\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: signature.signer});\n    }\n\n    /////////////////////////////////////////////////\n    ///        PROFILE INTERACTION FUNCTIONS      ///\n    /////////////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function follow(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, followerProfileId)\n        returns (uint256[] memory)\n    {\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: msg.sender\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function followWithSig(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, followerProfileId)\n        returns (uint256[] memory)\n    {\n        MetaTxLib.validateFollowSignature(signature, followerProfileId, idsOfProfilesToFollow, followTokenIds, datas);\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: signature.signer\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollow(uint256 unfollowerProfileId, uint256[] calldata idsOfProfilesToUnfollow)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, unfollowerProfileId)\n    {\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: msg.sender\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollowWithSig(\n        uint256 unfollowerProfileId,\n        uint256[] calldata idsOfProfilesToUnfollow,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, unfollowerProfileId) {\n        MetaTxLib.validateUnfollowSignature(signature, unfollowerProfileId, idsOfProfilesToUnfollow);\n\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: signature.signer\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatus(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, byProfileId) {\n        return ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatusWithSig(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, byProfileId) {\n        MetaTxLib.validateSetBlockStatusSignature(signature, byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n        return ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collect(Types.CollectParams calldata collectParams)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: msg.sender,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collectWithSig(Types.CollectParams calldata collectParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateLegacyCollectSignature(signature, collectParams);\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: signature.signer,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function act(Types.PublicationActionParams calldata publicationActionParams)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: msg.sender,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function actWithSig(\n        Types.PublicationActionParams calldata publicationActionParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        MetaTxLib.validateActSignature(signature, publicationActionParams);\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: signature.signer,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    ///////////////////////////////////////////\n    ///        EXTERNAL VIEW FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function isFollowing(uint256 followerProfileId, uint256 followedProfileId) external view returns (bool) {\n        address followNFT = _profiles[followedProfileId].followNFT;\n        return followNFT != address(0) && IFollowNFT(followNFT).isFollowing(followerProfileId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(\n        uint256 delegatorProfileId,\n        address delegatedExecutor,\n        uint64 configNumber\n    ) external view returns (bool) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).isApproved[configNumber][delegatedExecutor];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(uint256 delegatorProfileId, address delegatedExecutor)\n        external\n        view\n        returns (bool)\n    {\n        return ProfileLib.isExecutorApproved(delegatorProfileId, delegatedExecutor);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).configNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsPrevConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).prevConfigNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsMaxConfigNumberSet(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).maxConfigNumberSet;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isBlocked(uint256 profileId, uint256 byProfileId) external view returns (bool) {\n        return _blockedStatus[byProfileId][profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getContentURI(uint256 profileId, uint256 pubId) external view override returns (string memory) {\n        // This function is used by the Collect NFTs' tokenURI function.\n        return PublicationLib.getContentURI(profileId, pubId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getProfile(uint256 profileId) external view override returns (Types.Profile memory) {\n        return _profiles[profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublication(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (Types.Publication memory)\n    {\n        return _publications[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublicationType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (Types.PublicationType)\n    {\n        return PublicationLib.getPublicationType(profileId, pubId);\n    }\n\n    function getActionModuleById(uint256 id) external view override returns (address) {\n        return _actionModules[id];\n    }\n}"
    }
  ]
}