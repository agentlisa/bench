{
  "Title": "M-4: Logic Error due to different representation of Native ETH (0x0 & 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)",
  "Content": "# Issue M-4: Logic Error due to different representation of Native ETH (0x0 & 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) \n\nSource: https://github.com/sherlock-audit/2023-02-notional-judging/issues/15 \n\n## Found by \nxiaoming90\n\n## Summary\n\nUnexpected results might occur during vault initialization if either of the pool's tokens is a Native ETH due to the confusion between `Deployments.ETH_ADDRESS (address(0))` and `Deployments.ALT_ETH_ADDRESS (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)`.\n\n## Vulnerability Detail\n\nThe `PRIMARY_TOKEN` or `SECONDARY_TOKEN` is explicitly converted to `Deployments.ETH_ADDRESS (address(0)` during deployment.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/mixins/Curve2TokenPoolMixin.sol#L24\n\n```solidity\nFile: Curve2TokenPoolMixin.sol\nabstract contract Curve2TokenPoolMixin is CurvePoolMixin {\n..SNIP..\n24:     constructor(\n25:         NotionalProxy notional_,\n26:         ConvexVaultDeploymentParams memory params\n27:     ) CurvePoolMixin(notional_, params) {\n28:         address primaryToken = _getNotionalUnderlyingToken(params.baseParams.primaryBorrowCurrencyId);\n29: \n30:         PRIMARY_TOKEN = primaryToken;\n31: \n32:         // Curve uses ALT_ETH_ADDRESS\n33:         if (primaryToken == Deployments.ETH_ADDRESS) {\n34:             primaryToken = Deployments.ALT_ETH_ADDRESS;\n35:         }\n36: \n37:         address token0 = CURVE_POOL.coins(0);\n38:         address token1 = CURVE_POOL.coins(1);\n39:         \n40:         uint8 primaryIndex;\n41:         address secondaryToken;\n42:         if (token0 == primaryToken) {\n43:             primaryIndex = 0;\n44:             secondaryToken = token1;\n45:         } else {\n46:             primaryIndex = 1;\n47:             secondaryToken = token0;\n48:         }\n49: \n50:         if (secondaryToken == Deployments.ALT_ETH_ADDRESS) {\n51:             secondaryToken = Deployments.ETH_ADDRESS;\n52:         }\n53: \n54:         PRIMARY_INDEX = primaryIndex;\n55:         SECONDARY_TOKEN = secondaryToken;\n```\n\nIt was observed that there is a logic error within the `Curve2TokenConvexVault.initialize` function. Based on Lines 56 and 59 within the `Curve2TokenConvexVault.initialize` function, it assumes that if either the primary or secondary token is ETH, then the  `PRIMARY_TOKEN` or `SECONDARY_TOKEN` will be set to `Deployments.ALT_ETH_ADDRESS`, which point to `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`.\n\nHowever, this is incorrect as the `PRIMARY_TOKEN` or `SECONDARY_TOKEN` has already been converted to `Deployments.ETH_ADDRESS (address(0))` during deployment. Refer to the constructor of `Curve2TokenPoolMixin`.\n\nThus, the `PRIMARY_TOKEN` or `SECONDARY_TOKEN` will never be equal to `Deployments.ALT_ETH_ADDRESS`, and the condition at Lines 56 and 59 will always evaluate to True.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol#L48\n\n```solidity\nFile: Curve2TokenConvexVault.sol\ncontract Curve2TokenConvexVault is Curve2TokenVaultMixin {\n..SNIP..\n48:     function initialize(InitParams calldata params)\n49:         external\n50:         initializer\n51:         onlyNotionalOwner\n52:     {\n53:         __INIT_VAULT(params.name, params.borrowCurrencyId);\n54:         CurveVaultStorage.setStrategyVaultSettings(params.settings);\n55: \n56:         if (PRIMARY_TOKEN != Deployments.ALT_ETH_ADDRESS) {\n57:             IERC20(PRIMARY_TOKEN).checkApprove(address(CURVE_POOL), type(uint256).max);\n58:         }\n59:         if (SECONDARY_TOKEN != Deployments.ALT_ETH_ADDRESS) {\n60:             IERC20(SECONDARY_TOKEN).checkApprove(address(CURVE_POOL), type(uint256).max);\n61:         }\n62: \n63:         CURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n64:     }\n```\n\nAs a result, if the `PRIMARY_TOKEN` or `SECONDARY_TOKEN` is `Deployments.ETH_ADDRESS (address(0))`, the code will go ahead to call the `checkApprove` function, which might cause unexpected results during vault initialization.\n\n## Impact\n\nUnexpected results during vault initialization if either of the pool's tokens is a Native ETH.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol#L48\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf the `PRIMARY_TOKEN` or `SECONDARY_TOKEN` is equal to `Deployments.ALT_ETH_ADDRESS` or `Deployments.ETH_ADDRESS`, this means that it points to native ETH and the `checkApprove` can be safely skipped.\n\n```diff\nfunction initialize(InitParams calldata params)\n\texternal\n\tinitializer\n\tonlyNotionalOwner\n{\n\t__INIT_VAULT(params.name, params.borrowCurrencyId);\n\tCurveVaultStorage.setStrategyVaultSettings(params.settings);\n\n-\tif (PRIMARY_TOKEN != Deployments.ALT_ETH_ADDRESS) {\n+\tif (PRIMARY_TOKEN != Deployments.ALT_ETH_ADDRESS || PRIMARY_TOKEN != Deployments.ETH_ADDRESS) {\n\t\tIERC20(PRIMARY_TOKEN).checkApprove(address(CURVE_POOL), type(uint256).max);\n\t}\n-\tif (SECONDARY_TOKEN != Deployments.ALT_ETH_ADDRESS) {\n+\tif (SECONDARY_TOKEN != Deployments.ALT_ETH_ADDRESS || SECONDARY_TOKEN != Deployments.ETH_ADDRESS) {\n\t\tIERC20(SECONDARY_TOKEN).checkApprove(address(CURVE_POOL), type(uint256).max);\n\t}\n\n\tCURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n}\n```\n\n## Discussion\n\n**jeffywu**\n\nThis issue appears valid, however, it's curious that this was not caught in unit tests since we tested against the wstETH/ETH pool which should have tripped this issue.\n\nWe can mark it as valid, @weitianjie2000 will investigate more on why the unit tests worked.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/52",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/mixins/Curve2TokenPoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {TwoTokenPoolContext} from \"../../common/VaultTypes.sol\";\nimport {Curve2TokenPoolContext, ConvexVaultDeploymentParams} from \"../CurveVaultTypes.sol\";\nimport {CurveConstants} from \"../internal/CurveConstants.sol\";\nimport {CurvePoolMixin} from \"./CurvePoolMixin.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {IBalancerPool} from \"../../../../interfaces/balancer/IBalancerPool.sol\";\n\nabstract contract Curve2TokenPoolMixin is CurvePoolMixin {\n    error InvalidPrimaryToken(address token);\n    error InvalidSecondaryToken(address token);\n\n    address internal immutable PRIMARY_TOKEN;\n    address internal immutable SECONDARY_TOKEN;\n    uint8 internal immutable PRIMARY_INDEX;\n    uint8 internal immutable SECONDARY_INDEX;\n    uint8 internal immutable PRIMARY_DECIMALS;\n    uint8 internal immutable SECONDARY_DECIMALS;\n\n    constructor(\n        NotionalProxy notional_,\n        ConvexVaultDeploymentParams memory params\n    ) CurvePoolMixin(notional_, params) {\n        address primaryToken = _getNotionalUnderlyingToken(params.baseParams.primaryBorrowCurrencyId);\n\n        PRIMARY_TOKEN = primaryToken;\n\n        // Curve uses ALT_ETH_ADDRESS\n        if (primaryToken == Deployments.ETH_ADDRESS) {\n            primaryToken = Deployments.ALT_ETH_ADDRESS;\n        }\n\n        address token0 = CURVE_POOL.coins(0);\n        address token1 = CURVE_POOL.coins(1);\n        \n        uint8 primaryIndex;\n        address secondaryToken;\n        if (token0 == primaryToken) {\n            primaryIndex = 0;\n            secondaryToken = token1;\n        } else {\n            primaryIndex = 1;\n            secondaryToken = token0;\n        }\n\n        if (secondaryToken == Deployments.ALT_ETH_ADDRESS) {\n            secondaryToken = Deployments.ETH_ADDRESS;\n        }\n\n        PRIMARY_INDEX = primaryIndex;\n        SECONDARY_TOKEN = secondaryToken;\n\n        unchecked {\n            SECONDARY_INDEX = 1 - PRIMARY_INDEX;\n        }\n\n        uint256 primaryDecimals = PRIMARY_TOKEN ==\n            Deployments.ETH_ADDRESS\n            ? 18\n            : IERC20(PRIMARY_TOKEN).decimals();\n        // Do not allow decimal places greater than 18\n        require(primaryDecimals <= 18);\n        PRIMARY_DECIMALS = uint8(primaryDecimals);\n\n        uint256 secondaryDecimals = SECONDARY_TOKEN ==\n            Deployments.ETH_ADDRESS\n            ? 18\n            : IERC20(SECONDARY_TOKEN).decimals();\n        require(secondaryDecimals <= 18);\n        SECONDARY_DECIMALS = uint8(secondaryDecimals);\n    }\n\n    function _twoTokenPoolContext() internal view returns (Curve2TokenPoolContext memory) {\n        return Curve2TokenPoolContext({\n            basePool: TwoTokenPoolContext({\n                primaryToken: PRIMARY_TOKEN,\n                secondaryToken: SECONDARY_TOKEN,\n                primaryIndex: PRIMARY_INDEX,\n                secondaryIndex: SECONDARY_INDEX,\n                primaryDecimals: PRIMARY_DECIMALS,\n                secondaryDecimals: SECONDARY_DECIMALS,\n                primaryBalance: CURVE_POOL.balances(PRIMARY_INDEX),\n                secondaryBalance: CURVE_POOL.balances(SECONDARY_INDEX),\n                poolToken: CURVE_POOL_TOKEN      \n            }),\n            curvePool: CURVE_POOL\n        });   \n    }\n\n    uint256[40] private __gap; // Storage gap for future potential upgrades\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    ConvexVaultDeploymentParams, \n    InitParams, \n    Curve2TokenPoolContext,\n    Curve2TokenConvexStrategyContext\n} from \"./curve/CurveVaultTypes.sol\";\nimport {\n    StrategyContext,\n    StrategyVaultState,\n    StrategyVaultSettings,\n    RedeemParams,\n    DepositParams,\n    ReinvestRewardParams\n} from \"./common/VaultTypes.sol\";\nimport {VaultStorage} from \"./common/VaultStorage.sol\";\nimport {Errors} from \"../global/Errors.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {TypeConvert} from \"../global/TypeConvert.sol\";\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {TokenUtils, IERC20} from \"../utils/TokenUtils.sol\";\nimport {Curve2TokenVaultMixin} from \"./curve/mixins/Curve2TokenVaultMixin.sol\";\nimport {CurveVaultStorage} from \"./curve/internal/CurveVaultStorage.sol\";\nimport {Curve2TokenPoolUtils} from \"./curve/internal/pool/Curve2TokenPoolUtils.sol\";\nimport {Curve2TokenConvexHelper} from \"./curve/external/Curve2TokenConvexHelper.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {SettlementUtils} from \"./common/internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"./common/internal/strategy/StrategyUtils.sol\";\n\ncontract Curve2TokenConvexVault is Curve2TokenVaultMixin {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using SettlementUtils for StrategyContext;\n    using CurveVaultStorage for StrategyVaultState;\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using Curve2TokenConvexHelper for Curve2TokenConvexStrategyContext;\n\n    constructor(NotionalProxy notional_, ConvexVaultDeploymentParams memory params) \n        Curve2TokenVaultMixin(notional_, params) {}\n\n    function strategy() external override view returns (bytes4) {\n        return bytes4(keccak256(\"Curve2TokenConvexVault\"));\n    }\n\n    function initialize(InitParams calldata params)\n        external\n        initializer\n        onlyNotionalOwner\n    {\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n        CurveVaultStorage.setStrategyVaultSettings(params.settings);\n\n        if (PRIMARY_TOKEN != Deployments.ALT_ETH_ADDRESS) {\n            IERC20(PRIMARY_TOKEN).checkApprove(address(CURVE_POOL), type(uint256).max);\n        }\n        if (SECONDARY_TOKEN != Deployments.ALT_ETH_ADDRESS) {\n            IERC20(SECONDARY_TOKEN).checkApprove(address(CURVE_POOL), type(uint256).max);\n        }\n\n        CURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n    }\n\n    function _depositFromNotional(\n        address /* account */,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 strategyTokensMinted) {\n        strategyTokensMinted = _strategyContext().deposit(deposit, data);\n    }\n\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 finalPrimaryBalance) {\n        finalPrimaryBalance = _strategyContext().redeem(strategyTokens, data);\n    }   \n\n    function settleVaultNormal(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external onlyRole(NORMAL_SETTLEMENT_ROLE) {\n        if (maturity <= block.timestamp) {\n            revert Errors.PostMaturitySettlement();\n        }\n        if (block.timestamp < maturity - SETTLEMENT_PERIOD_IN_SECONDS) {\n            revert Errors.NotInSettlementWindow();\n        }\n        Curve2TokenConvexStrategyContext memory context = _strategyContext();\n\n        SettlementUtils._validateCoolDown(\n            context.baseStrategy.vaultState.lastSettlementTimestamp,\n            context.baseStrategy.vaultSettings.settlementCoolDownInMinutes\n        );\n\n        context.baseStrategy.vaultState.lastSettlementTimestamp = uint32(block.timestamp);\n        context.baseStrategy.vaultState.setStrategyVaultState();\n\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.settlementSlippageLimitPercent,\n            data\n        );\n        Curve2TokenConvexHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n    }\n\n    function settleVaultPostMaturity(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external onlyRole(POST_MATURITY_SETTLEMENT_ROLE) {\n        if (block.timestamp < maturity) {\n            revert Errors.HasNotMatured();\n        }\n        Curve2TokenConvexStrategyContext memory context = _strategyContext();\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.postMaturitySettlementSlippageLimitPercent,\n            data\n        );\n        Curve2TokenConvexHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n    }\n\n    function settleVaultEmergency(uint256 maturity, bytes calldata data) \n        external onlyRole(EMERGENCY_SETTLEMENT_ROLE) {\n        // No need for emergency settlement during the settlement window\n        _revertInSettlementWindow(maturity);\n        Curve2TokenConvexHelper.settleVaultEmergency(\n            _strategyContext(), maturity, data\n        );\n    }\n\n    function getEmergencySettlementPoolClaimAmount(uint256 maturity) external view returns (uint256 poolClaimToSettle) {\n        Curve2TokenConvexStrategyContext memory context = _strategyContext();\n        poolClaimToSettle = context.baseStrategy._getEmergencySettlementParams({\n            maturity: maturity, \n            totalPoolSupply: context.poolContext.basePool.poolToken.totalSupply()\n        });\n    }\n\n    function reinvestReward(ReinvestRewardParams calldata params) \n        external onlyRole(REWARD_REINVESTMENT_ROLE) {\n        Curve2TokenConvexHelper.reinvestReward(_strategyContext(), params);        \n    }\n\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 strategyTokenAmount,\n        uint256 maturity\n    ) public view virtual override returns (int256 underlyingValue) {\n        Curve2TokenConvexStrategyContext memory context = _strategyContext();\n        (uint256 spotPrice, uint256 oraclePrice) = context.poolContext._getSpotPriceAndOraclePrice(context.baseStrategy);\n        underlyingValue = context.poolContext._convertStrategyToUnderlying({\n            strategyContext: context.baseStrategy,\n            strategyTokenAmount: strategyTokenAmount,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice\n        });\n    } \n\n    function getSpotPrice(uint256 tokenIndex) external view returns (uint256 spotPrice) {\n        spotPrice = _strategyContext().poolContext._getSpotPrice(tokenIndex);\n    }\n\n    function getStrategyContext() external view returns (Curve2TokenConvexStrategyContext memory) {\n        return _strategyContext();\n    }\n\n    /// @notice Updates the vault settings\n    /// @param settings vault settings\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings)\n        external\n        onlyNotionalOwner\n    {\n        VaultStorage.setStrategyVaultSettings(settings);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    ConvexVaultDeploymentParams, \n    InitParams, \n    Curve2TokenPoolContext,\n    Curve2TokenConvexStrategyContext\n} from \"./curve/CurveVaultTypes.sol\";\nimport {\n    StrategyContext,\n    StrategyVaultState,\n    StrategyVaultSettings,\n    RedeemParams,\n    DepositParams,\n    ReinvestRewardParams\n} from \"./common/VaultTypes.sol\";\nimport {VaultStorage} from \"./common/VaultStorage.sol\";\nimport {Errors} from \"../global/Errors.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {TypeConvert} from \"../global/TypeConvert.sol\";\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {TokenUtils, IERC20} from \"../utils/TokenUtils.sol\";\nimport {Curve2TokenVaultMixin} from \"./curve/mixins/Curve2TokenVaultMixin.sol\";\nimport {CurveVaultStorage} from \"./curve/internal/CurveVaultStorage.sol\";\nimport {Curve2TokenPoolUtils} from \"./curve/internal/pool/Curve2TokenPoolUtils.sol\";\nimport {Curve2TokenConvexHelper} from \"./curve/external/Curve2TokenConvexHelper.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {SettlementUtils} from \"./common/internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"./common/internal/strategy/StrategyUtils.sol\";\n\ncontract Curve2TokenConvexVault is Curve2TokenVaultMixin {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using SettlementUtils for StrategyContext;\n    using CurveVaultStorage for StrategyVaultState;\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using Curve2TokenConvexHelper for Curve2TokenConvexStrategyContext;\n\n    constructor(NotionalProxy notional_, ConvexVaultDeploymentParams memory params) \n        Curve2TokenVaultMixin(notional_, params) {}\n\n    function strategy() external override view returns (bytes4) {\n        return bytes4(keccak256(\"Curve2TokenConvexVault\"));\n    }\n\n    function initialize(InitParams calldata params)\n        external\n        initializer\n        onlyNotionalOwner\n    {\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n        CurveVaultStorage.setStrategyVaultSettings(params.settings);\n\n        if (PRIMARY_TOKEN != Deployments.ALT_ETH_ADDRESS) {\n            IERC20(PRIMARY_TOKEN).checkApprove(address(CURVE_POOL), type(uint256).max);\n        }\n        if (SECONDARY_TOKEN != Deployments.ALT_ETH_ADDRESS) {\n            IERC20(SECONDARY_TOKEN).checkApprove(address(CURVE_POOL), type(uint256).max);\n        }\n\n        CURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n    }\n\n    function _depositFromNotional(\n        address /* account */,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 strategyTokensMinted) {\n        strategyTokensMinted = _strategyContext().deposit(deposit, data);\n    }\n\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 finalPrimaryBalance) {\n        finalPrimaryBalance = _strategyContext().redeem(strategyTokens, data);\n    }   \n\n    function settleVaultNormal(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external onlyRole(NORMAL_SETTLEMENT_ROLE) {\n        if (maturity <= block.timestamp) {\n            revert Errors.PostMaturitySettlement();\n        }\n        if (block.timestamp < maturity - SETTLEMENT_PERIOD_IN_SECONDS) {\n            revert Errors.NotInSettlementWindow();\n        }\n        Curve2TokenConvexStrategyContext memory context = _strategyContext();\n\n        SettlementUtils._validateCoolDown(\n            context.baseStrategy.vaultState.lastSettlementTimestamp,\n            context.baseStrategy.vaultSettings.settlementCoolDownInMinutes\n        );\n\n        context.baseStrategy.vaultState.lastSettlementTimestamp = uint32(block.timestamp);\n        context.baseStrategy.vaultState.setStrategyVaultState();\n\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.settlementSlippageLimitPercent,\n            data\n        );\n        Curve2TokenConvexHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n    }\n\n    function settleVaultPostMaturity(\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        bytes calldata data\n    ) external onlyRole(POST_MATURITY_SETTLEMENT_ROLE) {\n        if (block.timestamp < maturity) {\n            revert Errors.HasNotMatured();\n        }\n        Curve2TokenConvexStrategyContext memory context = _strategyContext();\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.postMaturitySettlementSlippageLimitPercent,\n            data\n        );\n        Curve2TokenConvexHelper.settleVault(\n            context, maturity, strategyTokensToRedeem, params\n        );\n    }\n\n    function settleVaultEmergency(uint256 maturity, bytes calldata data) \n        external onlyRole(EMERGENCY_SETTLEMENT_ROLE) {\n        // No need for emergency settlement during the settlement window\n        _revertInSettlementWindow(maturity);\n        Curve2TokenConvexHelper.settleVaultEmergency(\n            _strategyContext(), maturity, data\n        );\n    }\n\n    function getEmergencySettlementPoolClaimAmount(uint256 maturity) external view returns (uint256 poolClaimToSettle) {\n        Curve2TokenConvexStrategyContext memory context = _strategyContext();\n        poolClaimToSettle = context.baseStrategy._getEmergencySettlementParams({\n            maturity: maturity, \n            totalPoolSupply: context.poolContext.basePool.poolToken.totalSupply()\n        });\n    }\n\n    function reinvestReward(ReinvestRewardParams calldata params) \n        external onlyRole(REWARD_REINVESTMENT_ROLE) {\n        Curve2TokenConvexHelper.reinvestReward(_strategyContext(), params);        \n    }\n\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 strategyTokenAmount,\n        uint256 maturity\n    ) public view virtual override returns (int256 underlyingValue) {\n        Curve2TokenConvexStrategyContext memory context = _strategyContext();\n        (uint256 spotPrice, uint256 oraclePrice) = context.poolContext._getSpotPriceAndOraclePrice(context.baseStrategy);\n        underlyingValue = context.poolContext._convertStrategyToUnderlying({\n            strategyContext: context.baseStrategy,\n            strategyTokenAmount: strategyTokenAmount,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice\n        });\n    } \n\n    function getSpotPrice(uint256 tokenIndex) external view returns (uint256 spotPrice) {\n        spotPrice = _strategyContext().poolContext._getSpotPrice(tokenIndex);\n    }\n\n    function getStrategyContext() external view returns (Curve2TokenConvexStrategyContext memory) {\n        return _strategyContext();\n    }\n\n    /// @notice Updates the vault settings\n    /// @param settings vault settings\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings)\n        external\n        onlyNotionalOwner\n    {\n        VaultStorage.setStrategyVaultSettings(settings);\n    }\n}"
    }
  ]
}