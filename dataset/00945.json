{
  "Title": "Rebalance may occur due to wrong requirements check",
  "Content": "# Rebalance may occur due to wrong requirements check\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L268-L293\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L268-L293</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L312-L332\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L312-L332</a>\n\n\n## Summary\n\nBefore a rebalance can occur, checks are implemented to ensure that **`delta`** and **`debtRatio`** remain within their specified limits. However, it's important to note that the check in **`GMXChecks::beforeRebalanceChecks`** ignores the scenario where these values are equal to any of their limits.\n\n## Vulnerability Details\n\nIn the current implementation of the **`GMXRebalance::rebalanceAdd`** function, it first calculates the current values of **`debtRatio`** and **`delta`** before making any changes. Subsequently, the **`beforeRebalanceChecks`** function, checks if these values meet the requirements for a rebalance to occur. These requirements now dictate that both **`debtRatio`** and **`delta`** must be either ≥ to the **`UpperLimit`**, or ≤ to the **`LowerLimit`** for a rebalance to take place.\n\n```js\nfunction beforeRebalanceChecks(\n  GMXTypes.Store storage self,\n  GMXTypes.RebalanceType rebalanceType\n) external view {\n  if (\n    self.status != GMXTypes.Status.Open &&\n    self.status != GMXTypes.Status.Rebalance_Open\n  ) revert Errors.NotAllowedInCurrentVaultStatus();\n\n  // Check that rebalance type is Delta or Debt\n  // And then check that rebalance conditions are met\n  // Note that Delta rebalancing requires vault's delta strategy to be Neutral as well\n  if (rebalanceType == GMXTypes.RebalanceType.Delta && self.delta == GMXTypes.Delta.Neutral) {\n    if (\n      self.rebalanceCache.healthParams.deltaBefore < self.deltaUpperLimit &&\n      self.rebalanceCache.healthParams.deltaBefore > self.deltaLowerLimit\n    ) revert Errors.InvalidRebalancePreConditions();\n  } else if (rebalanceType == GMXTypes.RebalanceType.Debt) {\n    if (\n      self.rebalanceCache.healthParams.debtRatioBefore < self.debtRatioUpperLimit &&\n      self.rebalanceCache.healthParams.debtRatioBefore > self.debtRatioLowerLimit\n    ) revert Errors.InvalidRebalancePreConditions();\n  } else {\n     revert Errors.InvalidRebalanceParameters();\n  }\n}\n```\n\nSuppose a rebalance is successful. In the **`afterRebalanceChecks`** section, the code verifies whether both **`delta`** and **`debtRatio`** are greater than the **`UpperLimit`** or less than the **`LowerLimit`**. This confirmation implies that these limits are indeed inclusive, meaning that the correct interpretation of these limits should be that **`LowerLimit ≤ actualValue ≤ UpperLimit`**. On the other hand, this also indicates that for a rebalancing to occur, the values of **`deltaBefore`** and **`debtRatioBefore`** need to be outside their limits, i.e., **`delta`** should be greater than **`Upper`** or less than **`Lower`**. However, in the current implementation, if these values are equal to the limit, a rebalance may still occur, which violates the consistency of the **`afterRebalanceChecks`** function, thus indicating that these limits are inclusive. Consequently, a value equal to the limit needs to be treated as valid and not be able to trigger a rebalance.\n\n```js\nfunction afterRebalanceChecks(\n  GMXTypes.Store storage self\n) external view {\n  // Guards: check that delta is within limits for Neutral strategy\n  if (self.delta == GMXTypes.Delta.Neutral) {\n    int256 _delta = GMXReader.delta(self);\n\n    if (\n      _delta > self.deltaUpperLimit ||\n      _delta < self.deltaLowerLimit\n    ) revert Errors.InvalidDelta();\n  }\n\n  // Guards: check that debt is within limits for Long/Neutral strategy\n  uint256 _debtRatio = GMXReader.debtRatio(self);\n\n  if (\n    _debtRatio > self.debtRatioUpperLimit ||\n    _debtRatio < self.debtRatioLowerLimit\n  ) revert Errors.InvalidDebtRatio();\n}\n```\n\nImagine the case when **`delta`** or **`debtRatio`** is equal to any of its limits; a rebalance will occur. However, on the other hand, these values are valid because they are inclusively within the limits.\n\n## Impact\n\nIn such a scenario, the system might incorrectly trigger a rebalance of the vault, even when **`delta`** or **`debtRatio`** is precisely within the established limits, thus potentially causing unintended rebalancing actions.\n\n## Tools Used\n\nManual\n\n## Recommendations\n\nConsider a strict check to determine if **`delta`** or **`debtRatio`** is strictly within its limits, including scenarios where they are equal to any of its limits. In such cases, the code should ensure that a rebalance does not occur when these values are precisely at the limit.\n\n```diff\nfunction beforeRebalanceChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.RebalanceType rebalanceType\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Open &&\n      self.status != GMXTypes.Status.Rebalance_Open\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n\n    // Check that rebalance type is Delta or Debt\n    // And then check that rebalance conditions are met\n    // Note that Delta rebalancing requires vault's delta strategy to be Neutral as well\n    if (rebalanceType == GMXTypes.RebalanceType.Delta && self.delta == GMXTypes.Delta.Neutral) {\n      if (\n-       self.rebalanceCache.healthParams.deltaBefore < self.deltaUpperLimit &&\n-       self.rebalanceCache.healthParams.deltaBefore > self.deltaLowerLimit\n+       self.rebalanceCache.healthParams.deltaBefore <= self.deltaUpperLimit &&\n+       self.rebalanceCache.healthParams.deltaBefore >= self.deltaLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else if (rebalanceType == GMXTypes.RebalanceType.Debt) {\n      if (\n-       self.rebalanceCache.healthParams.debtRatioBefore < self.debtRatioUpperLimit &&\n-       self.rebalanceCache.healthParams.debtRatioBefore > self.debtRatioLowerLimit\n+       self.rebalanceCache.healthParams.debtRatioBefore <= self.debtRatioUpperLimit &&\n+       self.rebalanceCache.healthParams.debtRatioBefore >= self.debtRatioLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else {\n       revert Errors.InvalidRebalanceParameters();\n    }\n  }\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXChecks.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { Errors } from \"../../utils/Errors.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXChecks\n  * @author Steadefi\n  * @notice Re-usable library functions for require function checks for Steadefi leveraged vaults\n*/\nlibrary GMXChecks {\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant MINIMUM_VALUE = 9e16;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Checks before native token deposit\n    * @param self GMXTypes.Store\n    * @param dp GMXTypes.DepositParams\n  */\n  function beforeNativeDepositChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp\n  ) external view {\n    if (dp.token != address(self.WNT))\n      revert Errors.InvalidNativeTokenAddress();\n\n    if (\n      address(self.tokenA) != address(self.WNT) &&\n      address(self.tokenB) != address(self.WNT)\n    ) revert Errors.OnlyNonNativeDepositToken();\n\n    if (dp.amt == 0) revert Errors.EmptyDepositAmount();\n\n    if (dp.amt + dp.executionFee != msg.value)\n      revert Errors.DepositAndExecutionFeeDoesNotMatchMsgValue();\n  }\n\n  /**\n    * @notice Checks before token deposit\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function beforeDepositChecks(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (self.depositCache.depositParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (!self.vault.isTokenWhitelisted(self.depositCache.depositParams.token))\n      revert Errors.InvalidDepositToken();\n\n    if (self.depositCache.depositParams.amt == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (self.depositCache.depositParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (depositValue == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue < MINIMUM_VALUE)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue > GMXReader.additionalCapacity(self))\n      revert Errors.InsufficientLendingLiquidity();\n  }\n\n  /**\n    * @notice Checks before processing deposit\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after deposit\n    * @param self GMXTypes.Store\n  */\n  function afterDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not increase at all\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensMinted();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.depositCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Slippage: Check whether user received enough shares as expected\n    if (\n      self.depositCache.sharesToUser <\n      self.depositCache.depositParams.minSharesAmt\n    ) revert Errors.InsufficientSharesMinted();\n  }\n\n  /**\n    * @notice Checks before processing deposit cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit check failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit failure's liquidity withdrawn\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before vault withdrawal\n    * @param self GMXTypes.Store\n\n  */\n  function beforeWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (!self.vault.isTokenWhitelisted(self.withdrawCache.withdrawParams.token))\n      revert Errors.InvalidWithdrawToken();\n\n    if (self.withdrawCache.withdrawParams.shareAmt == 0)\n      revert Errors.EmptyWithdrawAmount();\n\n    if (\n      self.withdrawCache.withdrawParams.shareAmt >\n      IERC20(address(self.vault)).balanceOf(self.withdrawCache.user)\n    ) revert Errors.InsufficientWithdrawBalance();\n\n    if (self.withdrawCache.withdrawValue < MINIMUM_VALUE)\n      revert Errors.InsufficientWithdrawAmount();\n\n    if (self.withdrawCache.withdrawParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee != msg.value)\n      revert Errors.InvalidExecutionFeeAmount();\n  }\n\n  /**\n    * @notice Checks before processing vault withdrawal\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after token withdrawal\n    * @param self GMXTypes.Store\n  */\n  function afterWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not decrease at all\n    if (GMXReader.lpAmt(self) >= self.withdrawCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensBurned();\n\n    // Guards: revert if equity did not decrease at all\n    if (\n      self.withdrawCache.healthParams.equityAfter >=\n      self.withdrawCache.healthParams.equityBefore\n    ) revert Errors.InvalidEquityAfterWithdraw();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.withdrawCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Check that user received enough assets as expected\n    if (\n      self.withdrawCache.tokensToUser <\n      self.withdrawCache.withdrawParams.minWithdrawTokenAmt\n    ) revert Errors.InsufficientAssetsReceived();\n  }\n\n  /**\n    * @notice Checks before processing withdrawal cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdrawal failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdraw failure's liquidity added\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before rebalancing\n    * @param self GMXTypes.Store\n    * @param rebalanceType GMXTypes.RebalanceType\n  */\n  function beforeRebalanceChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.RebalanceType rebalanceType\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Open &&\n      self.status != GMXTypes.Status.Rebalance_Open\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n\n    // Check that rebalance type is Delta or Debt\n    // And then check that rebalance conditions are met\n    // Note that Delta rebalancing requires vault's delta strategy to be Neutral as well\n    if (rebalanceType == GMXTypes.RebalanceType.Delta && self.delta == GMXTypes.Delta.Neutral) {\n      if (\n        self.rebalanceCache.healthParams.deltaBefore < self.deltaUpperLimit &&\n        self.rebalanceCache.healthParams.deltaBefore > self.deltaLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else if (rebalanceType == GMXTypes.RebalanceType.Debt) {\n      if (\n        self.rebalanceCache.healthParams.debtRatioBefore < self.debtRatioUpperLimit &&\n        self.rebalanceCache.healthParams.debtRatioBefore > self.debtRatioLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else {\n       revert Errors.InvalidRebalanceParameters();\n    }\n  }\n\n  /**\n    * @notice Checks before processing of rebalancing add or remove\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessRebalanceChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Rebalance_Add &&\n      self.status != GMXTypes.Status.Rebalance_Remove\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after rebalancing add or remove\n    * @param self GMXTypes.Store\n  */\n  function afterRebalanceChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: check that delta is within limits for Neutral strategy\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      int256 _delta = GMXReader.delta(self);\n\n      if (\n        _delta > self.deltaUpperLimit ||\n        _delta < self.deltaLowerLimit\n      ) revert Errors.InvalidDelta();\n    }\n\n    // Guards: check that debt is within limits for Long/Neutral strategy\n    uint256 _debtRatio = GMXReader.debtRatio(self);\n\n    if (\n      _debtRatio > self.debtRatioUpperLimit ||\n      _debtRatio < self.debtRatioLowerLimit\n    ) revert Errors.InvalidDebtRatio();\n  }\n\n  /**\n    * @notice Checks before compound\n    * @param self GMXTypes.Store\n  */\n  function beforeCompoundChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Open &&\n      self.status != GMXTypes.Status.Compound_Failed\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (\n      self.compoundCache.compoundParams.executionFee <\n      self.minExecutionFee\n    ) revert Errors.InsufficientExecutionFeeAmount();\n\n    if (self.compoundCache.depositValue == 0)\n      revert Errors.InsufficientDepositAmount();\n  }\n\n  /**\n    * @notice Checks before processing compound\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessCompoundChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Compound)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing compound cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessCompoundCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Compound)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before emergency closure of vault\n    * @param self GMXTypes.Store\n  */\n  function beforeEmergencyCloseChecks (\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Paused)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before resuming vault\n    * @param self GMXTypes.Store\n  */\n  function beforeEmergencyResumeChecks (\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Paused)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing resuming of vault\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessEmergencyResumeChecks (\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Resume)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before a withdrawal during emergency closure\n    * @param self GMXTypes.Store\n    * @param shareAmt Amount of shares to burn\n  */\n  function beforeEmergencyWithdrawChecks(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external view {\n    if (self.status != GMXTypes.Status.Closed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (shareAmt == 0)\n      revert Errors.EmptyWithdrawAmount();\n\n    if (shareAmt > IERC20(address(self.vault)).balanceOf(msg.sender))\n      revert Errors.InsufficientWithdrawBalance();\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Check if values are within threshold range\n    * @param valueBefore Previous value\n    * @param valueAfter New value\n    * @param threshold Tolerance threshold; 100 = 1%\n    * @return boolean Whether value after is within threshold range\n  */\n  function _isWithinStepChange(\n    uint256 valueBefore,\n    uint256 valueAfter,\n    uint256 threshold\n  ) internal pure returns (bool) {\n    // To bypass initial vault deposit\n    if (valueBefore == 0)\n      return true;\n\n    return (\n      valueAfter >= valueBefore * (10000 - threshold) / 10000 &&\n      valueAfter <= valueBefore * (10000 + threshold) / 10000\n    );\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXChecks.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { Errors } from \"../../utils/Errors.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXChecks\n  * @author Steadefi\n  * @notice Re-usable library functions for require function checks for Steadefi leveraged vaults\n*/\nlibrary GMXChecks {\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant MINIMUM_VALUE = 9e16;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Checks before native token deposit\n    * @param self GMXTypes.Store\n    * @param dp GMXTypes.DepositParams\n  */\n  function beforeNativeDepositChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp\n  ) external view {\n    if (dp.token != address(self.WNT))\n      revert Errors.InvalidNativeTokenAddress();\n\n    if (\n      address(self.tokenA) != address(self.WNT) &&\n      address(self.tokenB) != address(self.WNT)\n    ) revert Errors.OnlyNonNativeDepositToken();\n\n    if (dp.amt == 0) revert Errors.EmptyDepositAmount();\n\n    if (dp.amt + dp.executionFee != msg.value)\n      revert Errors.DepositAndExecutionFeeDoesNotMatchMsgValue();\n  }\n\n  /**\n    * @notice Checks before token deposit\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function beforeDepositChecks(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (self.depositCache.depositParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (!self.vault.isTokenWhitelisted(self.depositCache.depositParams.token))\n      revert Errors.InvalidDepositToken();\n\n    if (self.depositCache.depositParams.amt == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (self.depositCache.depositParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (depositValue == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue < MINIMUM_VALUE)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue > GMXReader.additionalCapacity(self))\n      revert Errors.InsufficientLendingLiquidity();\n  }\n\n  /**\n    * @notice Checks before processing deposit\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after deposit\n    * @param self GMXTypes.Store\n  */\n  function afterDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not increase at all\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensMinted();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.depositCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Slippage: Check whether user received enough shares as expected\n    if (\n      self.depositCache.sharesToUser <\n      self.depositCache.depositParams.minSharesAmt\n    ) revert Errors.InsufficientSharesMinted();\n  }\n\n  /**\n    * @notice Checks before processing deposit cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit check failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit failure's liquidity withdrawn\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before vault withdrawal\n    * @param self GMXTypes.Store\n\n  */\n  function beforeWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (!self.vault.isTokenWhitelisted(self.withdrawCache.withdrawParams.token))\n      revert Errors.InvalidWithdrawToken();\n\n    if (self.withdrawCache.withdrawParams.shareAmt == 0)\n      revert Errors.EmptyWithdrawAmount();\n\n    if (\n      self.withdrawCache.withdrawParams.shareAmt >\n      IERC20(address(self.vault)).balanceOf(self.withdrawCache.user)\n    ) revert Errors.InsufficientWithdrawBalance();\n\n    if (self.withdrawCache.withdrawValue < MINIMUM_VALUE)\n      revert Errors.InsufficientWithdrawAmount();\n\n    if (self.withdrawCache.withdrawParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee != msg.value)\n      revert Errors.InvalidExecutionFeeAmount();\n  }\n\n  /**\n    * @notice Checks before processing vault withdrawal\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after token withdrawal\n    * @param self GMXTypes.Store\n  */\n  function afterWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not decrease at all\n    if (GMXReader.lpAmt(self) >= self.withdrawCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensBurned();\n\n    // Guards: revert if equity did not decrease at all\n    if (\n      self.withdrawCache.healthParams.equityAfter >=\n      self.withdrawCache.healthParams.equityBefore\n    ) revert Errors.InvalidEquityAfterWithdraw();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.withdrawCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Check that user received enough assets as expected\n    if (\n      self.withdrawCache.tokensToUser <\n      self.withdrawCache.withdrawParams.minWithdrawTokenAmt\n    ) revert Errors.InsufficientAssetsReceived();\n  }\n\n  /**\n    * @notice Checks before processing withdrawal cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdrawal failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdraw failure's liquidity added\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before rebalancing\n    * @param self GMXTypes.Store\n    * @param rebalanceType GMXTypes.RebalanceType\n  */\n  function beforeRebalanceChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.RebalanceType rebalanceType\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Open &&\n      self.status != GMXTypes.Status.Rebalance_Open\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n\n    // Check that rebalance type is Delta or Debt\n    // And then check that rebalance conditions are met\n    // Note that Delta rebalancing requires vault's delta strategy to be Neutral as well\n    if (rebalanceType == GMXTypes.RebalanceType.Delta && self.delta == GMXTypes.Delta.Neutral) {\n      if (\n        self.rebalanceCache.healthParams.deltaBefore < self.deltaUpperLimit &&\n        self.rebalanceCache.healthParams.deltaBefore > self.deltaLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else if (rebalanceType == GMXTypes.RebalanceType.Debt) {\n      if (\n        self.rebalanceCache.healthParams.debtRatioBefore < self.debtRatioUpperLimit &&\n        self.rebalanceCache.healthParams.debtRatioBefore > self.debtRatioLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else {\n       revert Errors.InvalidRebalanceParameters();\n    }\n  }\n\n  /**\n    * @notice Checks before processing of rebalancing add or remove\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessRebalanceChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Rebalance_Add &&\n      self.status != GMXTypes.Status.Rebalance_Remove\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after rebalancing add or remove\n    * @param self GMXTypes.Store\n  */\n  function afterRebalanceChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: check that delta is within limits for Neutral strategy\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      int256 _delta = GMXReader.delta(self);\n\n      if (\n        _delta > self.deltaUpperLimit ||\n        _delta < self.deltaLowerLimit\n      ) revert Errors.InvalidDelta();\n    }\n\n    // Guards: check that debt is within limits for Long/Neutral strategy\n    uint256 _debtRatio = GMXReader.debtRatio(self);\n\n    if (\n      _debtRatio > self.debtRatioUpperLimit ||\n      _debtRatio < self.debtRatioLowerLimit\n    ) revert Errors.InvalidDebtRatio();\n  }\n\n  /**\n    * @notice Checks before compound\n    * @param self GMXTypes.Store\n  */\n  function beforeCompoundChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Open &&\n      self.status != GMXTypes.Status.Compound_Failed\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (\n      self.compoundCache.compoundParams.executionFee <\n      self.minExecutionFee\n    ) revert Errors.InsufficientExecutionFeeAmount();\n\n    if (self.compoundCache.depositValue == 0)\n      revert Errors.InsufficientDepositAmount();\n  }\n\n  /**\n    * @notice Checks before processing compound\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessCompoundChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Compound)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing compound cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessCompoundCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Compound)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before emergency closure of vault\n    * @param self GMXTypes.Store\n  */\n  function beforeEmergencyCloseChecks (\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Paused)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before resuming vault\n    * @param self GMXTypes.Store\n  */\n  function beforeEmergencyResumeChecks (\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Paused)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing resuming of vault\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessEmergencyResumeChecks (\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Resume)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before a withdrawal during emergency closure\n    * @param self GMXTypes.Store\n    * @param shareAmt Amount of shares to burn\n  */\n  function beforeEmergencyWithdrawChecks(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external view {\n    if (self.status != GMXTypes.Status.Closed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (shareAmt == 0)\n      revert Errors.EmptyWithdrawAmount();\n\n    if (shareAmt > IERC20(address(self.vault)).balanceOf(msg.sender))\n      revert Errors.InsufficientWithdrawBalance();\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Check if values are within threshold range\n    * @param valueBefore Previous value\n    * @param valueAfter New value\n    * @param threshold Tolerance threshold; 100 = 1%\n    * @return boolean Whether value after is within threshold range\n  */\n  function _isWithinStepChange(\n    uint256 valueBefore,\n    uint256 valueAfter,\n    uint256 threshold\n  ) internal pure returns (bool) {\n    // To bypass initial vault deposit\n    if (valueBefore == 0)\n      return true;\n\n    return (\n      valueAfter >= valueBefore * (10000 - threshold) / 10000 &&\n      valueAfter <= valueBefore * (10000 + threshold) / 10000\n    );\n  }\n}"
    }
  ]
}