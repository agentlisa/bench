{
  "Title": "H-7: Adversary manipulate the middle path when calling `execute_dca_order`, resulting user loss, benefiting the attacker",
  "Content": "# Issue H-7: Adversary manipulate the middle path when calling `execute_dca_order`, resulting user loss, benefiting the attacker \n\nSource: https://github.com/sherlock-audit/2023-06-unstoppable-judging/issues/182 \n\n## Found by \n0xDjango, 0xyPhilic, BugBusters, Lalanda, chainNue, pengun\n## Summary\n\nAdversary manipulate the middle path when calling `execute_dca_order`, resulting user loss, benefiting the attacker\n\n## Vulnerability Detail\n\nAllowing anyone to call the `execute_dca_order` function with a custom `_uni_hop_path` introduce security issue. If an attacker constructs a malicious path with their own token in the middle, they could manipulate the liquidity and perform an exploit. The `_uni_hop_path` parameter in `execute_dca_order` is really dangerous input which can be manipulated by attacker.\n\nFor example a user want to Dca `USDC -> WETH` by posting `post_dca_order` with `_token_in` is USDC, and `_token_out` is WETH, and with the `min_amount_out` generated from `_calc_min_amount_out` which is based on twap and slippage percentage (in contrary, `LimitOrders.vy` use input `min_amount_out` for token out from the `post_limit_order` function, thus will not facing same effect like this issue)\n\nWhen attacker see this Dca order, they can create a new ERC20 `MYTOKEN` (and will provide liquidity in uniswap) and plan to attack the Dca by selecting his own token as the middle path, so `execute_dca_order` will be executed using `USDC -> MYTOKEN -> WETH` path.\n\nSince attacker can manipulate the liquidity of `MYTOKEN` in Uniswap, resulting user will get bad swap amount due to the custom path provided by attacker.\n\nSlippage and twap length as protection are not enough, because the middle token path is the problem here. Moreover, using twap with twap_length can also be manipulated by preparing / pre-attack pool since the `last_execution` and `seconds_between_executions` is known, also the order's twap_length is visible, so attack scenario can prepared beforehand.\n\n```python\nFile: Dca.vy\n163: @external\n164: @nonreentrant('lock')\n165: def execute_dca_order(_uid: bytes32, _uni_hop_path: DynArray[address, 3], _uni_pool_fees: DynArray[uint24, 2], _share_profit: bool):\n...\n174:     # ensure path is valid\n175:     assert len(_uni_hop_path) in [2, 3], \"[path] invlid path\"\n176:     assert len(_uni_pool_fees) == len(_uni_hop_path)-1, \"[path] invalid fees\"\n177:     assert _uni_hop_path[0] == order.token_in, \"[path] invalid token_in\"\n178:     assert _uni_hop_path[len(_uni_hop_path)-1] == order.token_out, \"[path] invalid token_out\"\n...\n206:     # Vyper way to accommodate abi.encode_packed\n207:     path: Bytes[66] = empty(Bytes[66])\n208:     if(len(_uni_hop_path) == 2):\n209:         path = concat(convert(_uni_hop_path[0], bytes20), convert(_uni_pool_fees[0], bytes3), convert(_uni_hop_path[1], bytes20))\n210:     elif(len(_uni_hop_path) == 3):\n211:         path = concat(convert(_uni_hop_path[0], bytes20), convert(_uni_pool_fees[0], bytes3), convert(_uni_hop_path[1], bytes20), convert(_uni_pool_fees[1], bytes3), convert(_uni_hop_path[2], bytes20))\n212:\n213:     min_amount_out: uint256 = self._calc_min_amount_out(order.amount_in_per_execution, _uni_hop_path, _uni_pool_fees, order.twap_length, order.max_slippage)\n214:\n215:     uni_params: ExactInputParams = ExactInputParams({\n216:         path: path,\n217:         recipient: self,\n218:         deadline: block.timestamp,\n219:         amountIn: order.amount_in_per_execution,\n220:         amountOutMinimum: min_amount_out\n221:     })\n222:     amount_out: uint256 = UniswapV3SwapRouter(UNISWAP_ROUTER).exactInput(uni_params)\n...\n238:\n```\n\nSteps:\n\n1. A malicious user creates a custom token called \"MYTOKEN\" and provides liquidity for it on Uniswap v3. They allocate liquidity to create extreme price ranges for MYTOKEN.\n\n2. A regular user intends to swap USDC to WETH.\n\n3. The malicious user intercepts the transaction and modifies the path by adding intermediate token with MYTOKEN. The new path becomes USDC -> MYTOKEN -> WETH.\n\n4. Uniswap v3 receives the modified path and attempts to execute the swap based on the provided path.\n\n5. Uniswap v3 calculates the best available price based on the modified path, which includes MYTOKEN.\n\n6. Due to the manipulated liquidity pool of MYTOKEN, the price of MYTOKEN is significantly skewed, leading to an unfair price for the regular user executing the multi-hop swap.\n\n7. The malicious user takes advantage of the distorted liquidity pool by executing multi-hop swaps involving MYTOKEN at highly advantageous prices.\n\n8. Innocent users who unknowingly interact with the manipulated liquidity pool may receive unfavorable prices for their USDC to WETH swaps, leading to financial losses.\n\nIn this scenario, the malicious user modifies the path of the multi-hop swap by replacing the intended intermediate token with MYTOKEN. As a result, the malicious user exploits the manipulated liquidity pool and executes trades at favorable prices, while causing losses for other traders and disrupting the market equilibrium\n\n## Impact\n\nUser will get a bad rate (far from the normal rate) due to middle token rate is manipulated, thus losing his asset.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-unstoppable/blob/main/unstoppable-dex-audit/contracts/spot-dex/Dca.vy#L163-L237\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMight need to have a minimal desired output amount of range (for the output token), or remove the option to input manual path with anyone can call the `execute_dca_order` then replace it with the Oracle price rate. Other way, consider implement a whitelist token for swap path.\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/95",
  "Code": [
    {
      "filename": "unstoppable-dex-audit/contracts/spot-dex/Dca.vy",
      "content": "# @version ^0.3.7\n\n###################################################################\n#\n# @title Unstoppable Spot DEX - DCA (Dollar-Cost-Average)\n# @license GNU AGPLv3\n# @author unstoppable.ooo\n#\n# @custom:security-contact team@unstoppable.ooo\n#\n# @notice\n#    This contract is part of the Unstoppable Spot DEX.\n#    It provides the infrastructure for placing permissionless,\n#    self-custodial DCA orders for Uni v3 pairs.\n#\n#    This is an early ALPHA release, use at your own risk!\n#\n###################################################################\n\nfrom vyper.interfaces import ERC20\nfrom vyper.interfaces import ERC20Detailed\n\n# struct ExactInputParams {\n#     bytes path;\n#     address recipient;\n#     uint256 deadline;\n#     uint256 amountIn;\n#     uint256 amountOutMinimum;\n# }\nstruct ExactInputParams:\n    path: Bytes[66]\n    recipient: address\n    deadline: uint256\n    amountIn: uint256\n    amountOutMinimum: uint256\n\n\n# function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\ninterface UniswapV3SwapRouter:\n    def exactInput(_params: ExactInputParams) -> uint256: payable\n\ninterface Univ3Twap:\n    def getTwap(_path: DynArray[address, 3], _fees: DynArray[uint24, 2], _twapLength: uint32) -> uint256: view\n\nPRECISISON: constant(uint256) = 10**18\n\nUNISWAP_ROUTER: constant(address) = 0xE592427A0AEce92De3Edee1F18E0157C05861564\n\nTWAP: constant(address) = 0xFa64f316e627aD8360de2476aF0dD9250018CFc5 \n\nFEE_BASE: constant(uint256) = 1000000 # 100 percent\nfee: public(uint256) # = 1000 # 0.1%\n\nMAX_SLIPPAGE: constant(uint256) = 10000 # 1 percent\n\n# owner\nowner: public(address)\nsuggested_owner: public(address)\n\n# DCA Orders\nstruct DcaOrder:\n    uid: bytes32\n    account: address\n    token_in: address\n    token_out: address\n    amount_in_per_execution: uint256\n    seconds_between_executions: uint256\n    max_number_of_executions: uint8\n    max_slippage: uint256\n    twap_length: uint32\n    number_of_executions: uint8\n    last_execution: uint256\n    \n\n# user address -> DcaOrder UID\ndca_order_uids: public(HashMap[address, DynArray[bytes32, 1024]])\n# UID -> DcaOrder\ndca_orders: public(HashMap[bytes32, DcaOrder])\nposition_nonce: uint256\n\nis_paused: public(bool)\nis_accepting_new_orders: public(bool)\n\n@external\ndef __init__():\n    self.owner = msg.sender\n    self.fee = 1000 # 0.1%\n\n\nevent DcaOrderPosted:\n    uid: bytes32\n    account: indexed(address)\n    token_in: indexed(address)\n    token_out: indexed(address)\n    amount_in_per_execution: uint256\n    seconds_between_executions: uint256\n    max_number_of_executions: uint8\n    twap_length: uint32\n    \n@external\ndef post_dca_order(\n        _token_in: address,\n        _token_out: address,\n        _amount_in_per_execution: uint256,\n        _seconds_between_executions: uint256,\n        _max_number_of_executions: uint8,\n        _max_slippage: uint256,\n        _twap_length: uint32\n    ):\n\n    assert not self.is_paused, \"paused\"\n    assert self.is_accepting_new_orders, \"not accepting new orders\"\n\n    # check msg.sender approved contract to spend amount token_in\n    total: uint256 = convert(_max_number_of_executions, uint256) * _amount_in_per_execution\n    allowance: uint256 = ERC20(_token_in).allowance(msg.sender, self)\n    assert allowance >= total, \"insufficient allowance\"\n\n    max_slippage: uint256 = _max_slippage\n    if max_slippage == 0:\n        max_slippage = MAX_SLIPPAGE\n    \n    order: DcaOrder = DcaOrder({\n        uid: empty(bytes32),\n        account: msg.sender,\n        token_in: _token_in,\n        token_out: _token_out,\n        amount_in_per_execution: _amount_in_per_execution,\n        seconds_between_executions: _seconds_between_executions,\n        max_number_of_executions: _max_number_of_executions,\n        max_slippage: _max_slippage,\n        twap_length: _twap_length,\n        number_of_executions: 0,\n        last_execution: 0\n    })\n\n    uid: bytes32 = self._generate_uid()\n    order.uid = uid\n\n    self.dca_orders[uid] = order\n    self.dca_order_uids[msg.sender].append(uid)\n\n    log DcaOrderPosted(uid, msg.sender, _token_in, _token_out, _amount_in_per_execution, _seconds_between_executions, _max_number_of_executions, _twap_length)\n\n\n\nevent DcaOrderExecuted:\n    uid: bytes32\n    account: indexed(address)\n    execution_number: uint8\n    amount_in: uint256\n    amount_out: uint256\n\nevent DcaOrderFailed:\n    uid: bytes32\n    account: indexed(address)\n    reason: String[32]\n\nevent DcaCompleted:\n    uid: bytes32\n    account: indexed(address)\n\n@external\n@nonreentrant('lock')\ndef execute_dca_order(_uid: bytes32, _uni_hop_path: DynArray[address, 3], _uni_pool_fees: DynArray[uint24, 2], _share_profit: bool):\n    assert not self.is_paused, \"paused\"\n\n    order: DcaOrder = self.dca_orders[_uid]\n    \n    # validate\n    assert order.number_of_executions < order.max_number_of_executions, \"max executions completed\"\n    assert order.last_execution + order.seconds_between_executions < block.timestamp, \"too soon\"\n\n    # ensure path is valid\n    assert len(_uni_hop_path) in [2, 3], \"[path] invlid path\"\n    assert len(_uni_pool_fees) == len(_uni_hop_path)-1, \"[path] invalid fees\"\n    assert _uni_hop_path[0] == order.token_in, \"[path] invalid token_in\"\n    assert _uni_hop_path[len(_uni_hop_path)-1] == order.token_out, \"[path] invalid token_out\"\n\n    # effects\n    order.last_execution = block.timestamp\n    order.number_of_executions += 1\n\n    self.dca_orders[_uid] = order\n\n    # ensure user has enough token_in\n    account_balance: uint256 = ERC20(order.token_in).balanceOf(order.account)\n    if account_balance < order.amount_in_per_execution:\n        log DcaOrderFailed(_uid, order.account, \"insufficient balance\")\n        self._cancel_dca_order(_uid, \"insufficient balance\")\n        return\n\n    # ensure self has enough allowance to spend amount token_in\n    account_allowance: uint256 = ERC20(order.token_in).allowance(order.account, self)\n    if account_allowance < order.amount_in_per_execution:\n        log DcaOrderFailed(_uid, order.account, \"insufficient allowance\")\n        self._cancel_dca_order(_uid, \"insufficient allowance\")\n        return\n\n    # transfer token_in from user to self\n    self._safe_transfer_from(order.token_in, order.account, self, order.amount_in_per_execution)\n\n    # approve UNISWAP_ROUTER to spend amount token_in\n    ERC20(order.token_in).approve(UNISWAP_ROUTER, order.amount_in_per_execution)\n\n    # Vyper way to accommodate abi.encode_packed\n    path: Bytes[66] = empty(Bytes[66])\n    if(len(_uni_hop_path) == 2):\n        path = concat(convert(_uni_hop_path[0], bytes20), convert(_uni_pool_fees[0], bytes3), convert(_uni_hop_path[1], bytes20))\n    elif(len(_uni_hop_path) == 3):\n        path = concat(convert(_uni_hop_path[0], bytes20), convert(_uni_pool_fees[0], bytes3), convert(_uni_hop_path[1], bytes20), convert(_uni_pool_fees[1], bytes3), convert(_uni_hop_path[2], bytes20))\n    \n    min_amount_out: uint256 = self._calc_min_amount_out(order.amount_in_per_execution, _uni_hop_path, _uni_pool_fees, order.twap_length, order.max_slippage)\n\n    uni_params: ExactInputParams = ExactInputParams({\n        path: path,\n        recipient: self,\n        deadline: block.timestamp,\n        amountIn: order.amount_in_per_execution,\n        amountOutMinimum: min_amount_out\n    })\n    amount_out: uint256 = UniswapV3SwapRouter(UNISWAP_ROUTER).exactInput(uni_params)\n\n    # transfer amount_out - fee to user \n    amount_minus_fee: uint256 = amount_out * (FEE_BASE - self.fee) / FEE_BASE\n    self._safe_transfer(order.token_out, order.account, amount_minus_fee)\n\n    # allows searchers to execute for 50% of profits\n    if _share_profit:\n        profit: uint256 = amount_out - amount_minus_fee\n        self._safe_transfer(order.token_out, msg.sender, profit/2)\n    \n    log DcaOrderExecuted(_uid, order.account, order.number_of_executions, order.amount_in_per_execution, amount_minus_fee)\n\n    if order.number_of_executions == order.max_number_of_executions:\n        self._cleanup_order(_uid)\n        log DcaCompleted(_uid, order.account)\n\n\n@view\n@external\ndef calc_min_amount_out(\n    _amount_in: uint256, \n    _path: DynArray[address, 3], \n    _fees: DynArray[uint24, 2], \n    _twap_length: uint32, \n    _max_slippage: uint256\n    ) -> uint256:\n    \n    return self._calc_min_amount_out(_amount_in, _path, _fees, _twap_length, _max_slippage)\n\n\n@view\n@internal\ndef _calc_min_amount_out(\n    _amount_in: uint256, \n    _path: DynArray[address, 3], \n    _fees: DynArray[uint24, 2], \n    _twap_length: uint32, \n    _max_slippage: uint256\n    ) -> uint256:\n\n    uni_fees_total: uint256 = 0\n    for fee in _fees:\n        uni_fees_total += convert(fee, uint256)\n\n    token_in_decimals: uint256 = convert(ERC20Detailed(_path[0]).decimals(), uint256)\n    twap_value: uint256 = Univ3Twap(TWAP).getTwap(_path, _fees, _twap_length)\n\n    min_amount_out: uint256 = _amount_in * PRECISISON \n    min_amount_out = min_amount_out * twap_value\n    min_amount_out = (min_amount_out * (FEE_BASE - uni_fees_total - _max_slippage)) / FEE_BASE\n    min_amount_out = min_amount_out / 10**token_in_decimals\n    min_amount_out = min_amount_out / PRECISISON\n\n    return min_amount_out\n\n\nevent DcaOrderCanceled:\n    uid: bytes32\n    reason: String[32]\n\n@external\ndef cancel_dca_order(_uid: bytes32):\n    order: DcaOrder = self.dca_orders[_uid]\n    assert order.account == msg.sender, \"unauthorized\"\n    self._cancel_dca_order(_uid, \"user canceled\")\n\n@internal\ndef _cancel_dca_order(_uid: bytes32, _reason: String[32]):\n    self._cleanup_order(_uid)\n    log DcaOrderCanceled(_uid, _reason)\n\n\nevent OrderCleanedUp:\n    uid: bytes32\n    account: indexed(address)\n\n@internal\ndef _cleanup_order(_uid: bytes32):\n    order: DcaOrder = self.dca_orders[_uid]\n    self.dca_orders[_uid] = empty(DcaOrder)\n\n    uids: DynArray[bytes32, 1024] = self.dca_order_uids[order.account]\n    for i in range(1024):\n        if uids[i] == _uid:\n            uids[i] = uids[len(uids) - 1]\n            uids.pop()\n            break\n        if i == len(uids)-1:\n            raise\n    self.dca_order_uids[order.account] = uids\n    \n    log OrderCleanedUp(_uid, order.account)\n\n\n@view\n@external\ndef get_all_open_positions(_account: address) -> DynArray[DcaOrder, 1024]:\n    uids: DynArray[bytes32, 1024] = self.dca_order_uids[_account]\n    orders: DynArray[DcaOrder, 1024] = empty(DynArray[DcaOrder, 1024])\n\n    for uid in uids:\n        orders.append(self.dca_orders[uid])\n\n    return orders\n\n\n@external\ndef withdraw_fees(_token: address):\n    amount: uint256 = ERC20(_token).balanceOf(self)\n    assert amount > 0, \"zero balance\"\n\n    ERC20(_token).transfer(self.owner, amount)\n\n\n@internal\ndef _generate_uid() -> bytes32:\n    uid: bytes32 = keccak256(_abi_encode(chain.id, self.position_nonce, block.timestamp))\n    self.position_nonce += 1\n    return uid\n\n\n\n@internal\ndef _safe_transfer(_token: address, _to: address, _amount: uint256) -> bool:\n    res: Bytes[32] = raw_call(\n        _token,\n        concat(\n            method_id(\"transfer(address,uint256)\"),\n            convert(_to, bytes32),\n            convert(_amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(res) > 0:\n        assert convert(res, bool), \"transfer failed\"\n\n    return True\n\n\n@internal\ndef _safe_transfer_from(\n    _token: address, _from: address, _to: address, _amount: uint256\n):\n    res: Bytes[32] = raw_call(\n        _token,\n        concat(\n            method_id(\"transferFrom(address,address,uint256)\"),\n            convert(_from, bytes32),\n            convert(_to, bytes32),\n            convert(_amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(res) > 0:\n        assert convert(res, bool), \"transfer failed\"\n\n\n#############################\n#\n#           ADMIN\n#\n#############################\n\nevent Paused: \n    is_paused: bool\n\n@external\ndef pause(_is_paused: bool):\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _is_paused != self.is_paused, \"already in state\"\n\n    self.is_paused = _is_paused\n    log Paused(_is_paused)\n\n\nevent AcceptingNewOrders: \n    is_accepting_new_orders: bool\n\n@external\ndef set_is_accepting_new_orders(_is_accepting_new_orders: bool):\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _is_accepting_new_orders != self.is_accepting_new_orders, \"already in state\"\n\n    self.is_accepting_new_orders = _is_accepting_new_orders\n    log AcceptingNewOrders(_is_accepting_new_orders)\n\n\nevent NewOwnerSuggested:\n    new_owner: indexed(address)\n    suggested_by: indexed(address)\n\n@external\ndef suggest_owner(_new_owner: address):\n    \"\"\"\n    @notice\n        Step 1 of the 2 step process to transfer ownership.\n        Current owner suggests a new owner.\n        Requires the new owner to accept ownership in step 2.\n    @param _new_owner\n        The address of the new owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _new_owner != empty(address), \"cannot set owner to zero address\"\n    self.suggested_owner = _new_owner\n    log NewOwnerSuggested(_new_owner, msg.sender)\n\n\nevent OwnershipTransferred:\n    new_owner: indexed(address)\n    promoted_by: indexed(address)\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @notice\n        Step 2 of the 2 step process to transfer ownership.\n        The suggested owner accepts the transfer and becomes the\n        new owner.\n    \"\"\"\n    assert msg.sender == self.suggested_owner, \"unauthorized\"\n    prev_owner: address = self.owner\n    self.owner = self.suggested_owner\n    log OwnershipTransferred(self.owner, prev_owner)\n\n\nevent FeeUpdated:\n    new_fee: uint256\n\n@external\ndef set_fee(_fee: uint256):\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _fee < FEE_BASE, \"invalid fee\"\n    assert _fee != self.fee, \"new fee cannot be same as old fee\"\n    self.fee = _fee\n    log FeeUpdated(_fee)"
    }
  ]
}