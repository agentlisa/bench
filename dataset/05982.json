{
  "Title": "[M-11] `VaultBooster`: users tokens will be stuck if they deposited with unsupported boost tokens",
  "Content": "\n### Impact\n\n*   In `VaultBooster` contract : users can deposite their tokens to participate in boosting the chances of a vault winning.\n\n*   But in `deposit` function: users can deposit **any** ERC20 tokens without verifying if the token is supported or not (has a boost set to it; registered in `_boosts[_token]`).\n\n*   As there's no mechanism implemented in the contract for users to retreive their deposited tokens if these tokens are not supported; then they will lose them unless withdrawn by the `VaultBooster` owner; and then the owner transfers these tokens back to the users.\n\n*   If this behaviour is intended by design; then there must be a machanism to save unsupported deposited tokens with user address and amount; and another withdraw function accessible by the owner that enables transferring stuck tokens to their owners; or simply make `deposit` function reverts if the token is unsupported.\n\n### Proof of Concept\n\nCode: [Line 171-176](https://github.com/GenerationSoftware/pt-v5-vault-boost/blob/9d640051ab61a0fdbcc9500814b7f8242db9aec2/src/VaultBooster.sol#L171-L176)\n\n```solidity\nFile: pt-v5-vault-boost/src/VaultBooster.sol\nLine 171-176:\n  function deposit(IERC20 _token, uint256 _amount) external {\n    _accrue(_token);\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Deposited(_token, msg.sender, _amount);\n  }\n```\n\n* Foundry PoC:\n\n 1. A `MockERC20.t.sol` contract is added to the test folder to simulate the user experience (miting/approving..),\n\n```solidity\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n  constructor() ERC20(\"MockToken\", \"MT\") {}\n\n  function mint(address account, uint256 amount) public returns (bool) {\n    _mint(account, amount);\n    return true;\n  }\n}\n```\n\n add remappings to the `foundry.toml`:\\\n remappings = \\[\"@openzeppelin/=lib/openzeppelin-contracts/\"]\n\n 2. This test is set in `VaultBooster.t.sol` file, where a user deposits unsuppotred token (basically no boosts were set),tries to liquidate but the call will revert, then the unsupported tokens can be withdrawn by the owner only (and not transferred to the original depositor):<br>\n    Add this import line at the top of the test file:\n\n```solidity\nimport \"./MockERC20.t.sol\";\n```\n\nAdd this test `testDepositWithUnsupportedToken()` to the `VaultBooster.t.sol` file:\n\n```solidity\n  function testDepositWithUnsupportedToken() public {\n    //0- minting unsupportedToken to the user\n    address user = address(0x2);\n    uint256 userBalance = 1e18;\n    MockERC20 unsupportedToken = new MockERC20();\n    vm.startPrank(user);\n    unsupportedToken.mint(user, userBalance);\n    assertEq(unsupportedToken.balanceOf(user), userBalance);\n\n    //1.the user deposits unsupported token (mainly there's no boosts set for any tokens):\n    unsupportedToken.approve(address(booster), userBalance);\n\n    vm.expectEmit(true, true, true, true);\n    emit Deposited(unsupportedToken, user, userBalance);\n    booster.deposit(unsupportedToken, userBalance);\n    assertEq(unsupportedToken.balanceOf(user), 0);\n    assertEq(unsupportedToken.balanceOf(address(booster)), userBalance);\n\n    //2. assertions that the deposited unsupportedToken doesn't have a boost set for it:\n    Boost memory boost = booster.getBoost(unsupportedToken);\n    assertEq(boost.liquidationPair, address(0));\n    assertEq(boost.multiplierOfTotalSupplyPerSecond.unwrap(), 0, \"multiplier\");\n    assertEq(boost.tokensPerSecond, 0, \"tokensPerSecond\");\n    assertEq(boost.lastAccruedAt, block.timestamp); //as the deposit function accrues rewards for the deposited token boost\n\n    //3. the user tries to call liquidate to get back his tokens,but the call will revert as there's no boost set for this token (it's unsupported):\n    vm.expectRevert(abi.encodeWithSelector(OnlyLiquidationPair.selector));\n    booster.liquidate(user, address(prizeToken), 0, address(unsupportedToken), userBalance);\n    vm.stopPrank();\n\n    //4. unless the owner tries  withdraws the user stuck tokens,(these tokens will be transferred to the owner address not to the original depositor address) :\n    assertEq(unsupportedToken.balanceOf(address(this)), 0);\n    assertEq(unsupportedToken.balanceOf(address(booster)), userBalance);\n    booster.withdraw(unsupportedToken, userBalance);\n    assertEq(unsupportedToken.balanceOf(address(this)), userBalance);\n    assertEq(unsupportedToken.balanceOf(address(booster)), 0);\n  }\n```\n\n 3. Test result:\n\n```bash\n$ forge test --match-test testDepositWithUnsupportedToken\nRunning 1 test for test/VaultBooster.t.sol:VaultBoosterTest\n[PASS] testDepositWithUnsupportedToken() (gas: 636179)\nTest result: ok. 1 passed; 0 failed; finished in 3.36ms\n```\n\n### Tools Used\n\nManual Testing & Foundry.\n\n### Recommended Mitigation Steps\n\nUpdate `deposit` function to revert if the user tries to deposit unsuppoerted tokens (that doesn't have a boost set):\n\n```diff\n  function deposit(IERC20 _token, uint256 _amount) external {\n+    if(_boosts[_token].liquidationPair==address(0)) revert();\n    _accrue(_token);\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Deposited(_token, msg.sender, _amount);\n  }\n```\n\n### Assessed type\n\nToken-Transfer\n\n**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/22#issuecomment-1671997599)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/VaultBooster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"forge-std/console2.sol\";\n\nimport { ILiquidationSource } from \"pt-v5-liquidator-interfaces/interfaces/ILiquidationSource.sol\";\nimport { PrizePool, IERC20, TwabController } from \"pt-v5-prize-pool/PrizePool.sol\";\nimport { UD60x18, convert } from \"prb-math/UD60x18.sol\";\nimport { UD2x18, intoUD60x18 } from \"prb-math/UD2x18.sol\";\nimport { Ownable } from \"openzeppelin/access/Ownable.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"openzeppelin/utils/math/SafeCast.sol\";\n\n/// @notice Emitted when someone tries to call liquidate and isn't the liquidation pair\nerror OnlyLiquidationPair();\n\n/// @notice Emitted when the initial available exceeds the balance\n/// @param initialAvailable The initial available\n/// @param balance The actual token balance\nerror InitialAvailableExceedsBalance(uint144 initialAvailable, uint256 balance);\n\n/// @notice Emitted when the liquidator attempts to liquidate more than the available balance\nerror InsufficientAvailableBalance(uint256 amountOut, uint256 available);\n\n/// @notice Emitted when the liquidator attempts to liquidate for a token other than the prize token \nerror UnsupportedTokenIn();\n\n/// @notice Struct that holds the boost data\nstruct Boost {\n  address liquidationPair;\n  UD2x18 multiplierOfTotalSupplyPerSecond;\n  uint96 tokensPerSecond;\n  uint144 available;\n  uint48 lastAccruedAt;\n}\n\n/// @title VaultBooster\n/// @author G9 Software Inc.\n/// @notice Allows someone to liquidate arbitrary tokens for a vault and improve the vault's chance of winning\ncontract VaultBooster is Ownable, ILiquidationSource {\n  using SafeERC20 for IERC20;\n  using SafeCast for uint256;\n\n  /// @notice Emitted when a boost is set\n  /// @param token The token to liquidate to boost the Vault's chances\n  /// @param liquidationPair The pair that will act as the liquidator\n  /// @param multiplierOfTotalSupplyPerSecond The multiplier of the total supply per second. Can be used to simulate APR. Can be combined with tokensPerSecond\n  /// @param tokensPerSecond The number of tokens to accrue per second. Is a simple straight time*amount allocation. Can be combiend with the multiplier.\n  /// @param initialAvailable The initial available balance\n  /// @param lastAccruedAt The timestamp at which the boost was set\n  event SetBoost(\n    IERC20 indexed token,\n    address liquidationPair,\n    UD2x18 multiplierOfTotalSupplyPerSecond,\n    uint96 tokensPerSecond,\n    uint144 initialAvailable,\n    uint48 lastAccruedAt\n  );\n\n  /// @notice Emitted when someone deposits tokens\n  /// @param token The token that they deposited\n  /// @param from The account that deposited the tokens\n  /// @param amount The amount that was deposited.\n  event Deposited(\n    IERC20 indexed token,\n    address indexed from,\n    uint256 amount\n  );\n\n  /// @notice Emitted when tokens are withdrawn by the owner\n  /// @param token The token that was withdrawn\n  /// @param from The account that withdraw the tokens\n  /// @param amount The amount of tokens that were withdrawn\n  event Withdrawn(\n    IERC20 indexed token,\n    address indexed from,\n    uint256 amount\n  );\n\n  /// @notice Emitted when tokens are liquidated\n  /// @param token The token that was sold\n  /// @param from The account that is receiving the tokens\n  /// @param amountIn The amount of tokens that were contributed to the prize pool\n  /// @param amountOut The amount of tokens that were sold\n  /// @param availableBoostBalance The remaining available boost balance for the token\n  event Liquidated(\n    IERC20 indexed token,\n    address indexed from,\n    uint256 amountIn,\n    uint256 amountOut,\n    uint256 availableBoostBalance\n  );\n\n  /// @notice Emitted when boost tokens are accrued\n  /// @param token The token that accrued\n  /// @param availableBoostBalance The new available balance\n  event BoostAccrued(\n    IERC20 indexed token,\n    uint256 availableBoostBalance\n  );\n\n  /// @notice The prize pool that this booster will contribute to\n  PrizePool public immutable prizePool;\n\n  /// @notice The prize pool's twab controller; copied here to save gas\n  TwabController public immutable twabController;\n  \n  /// @notice The vault that the VaultBooster is boosting\n  address public immutable vault;\n\n  /// @notice The boosts that have been set\n  mapping(IERC20 => Boost) internal _boosts;\n\n  /// @notice Constructs a new VaultBooster\n  /// @param _prizePool The prize pool to contribute to\n  /// @param _vault The vault to boost\n  /// @param _owner The owner of the VaultBooster contract\n  constructor(\n    PrizePool _prizePool,\n    address _vault,\n    address _owner\n  ) Ownable(_owner) {\n    prizePool = _prizePool;\n    twabController = prizePool.twabController();\n    vault = _vault;\n  }\n\n  /// @notice Retrieves boost details for a token\n  /// @param _token The token whose boost details to retrieve\n  /// @return The boost details\n  function getBoost(IERC20 _token) external returns (Boost memory) {\n    _accrue(_token);\n    return _boosts[_token];\n  }\n\n  /// @notice Allows the owner to configure a boost for a token\n  /// @param _token The token that will be liquidated to boost the chances of the vault\n  /// @param _liquidationPair The liquidation pair that will facilitate liquidations\n  /// @param _multiplierOfTotalSupplyPerSecond The multiplier of the total supply per second, useful for simulating APR. Can be combined with tokensPerSecond.\n  /// @param _tokensPerSecond A simple tokensPerSecond*deltaTime accumulator. Can be combined with the multiplier.\n  /// @param _initialAvailable The initial available balance. Must be less than or equal to the current balance of the VaultBooster of the given token.\n  function setBoost(IERC20 _token, address _liquidationPair, UD2x18 _multiplierOfTotalSupplyPerSecond, uint96 _tokensPerSecond, uint144 _initialAvailable) external onlyOwner {\n    if (_initialAvailable > 0) {\n      uint256 balance = _token.balanceOf(address(this));\n      if (balance < _initialAvailable) {\n        revert InitialAvailableExceedsBalance(_initialAvailable, balance);\n      }\n    }\n    _boosts[_token] = Boost({\n      liquidationPair: _liquidationPair,\n      multiplierOfTotalSupplyPerSecond: _multiplierOfTotalSupplyPerSecond,\n      tokensPerSecond: _tokensPerSecond,\n      available: _initialAvailable,\n      lastAccruedAt: uint48(block.timestamp)\n    });\n\n    emit SetBoost(\n      _token,\n      _liquidationPair,\n      _multiplierOfTotalSupplyPerSecond,\n      _tokensPerSecond,\n      _initialAvailable,\n      uint48(block.timestamp)\n    );\n  }\n\n  /// @notice Deposits tokens into this contract. \n  /// @dev Useful because it ensures `accrue` is called before depositing\n  /// @param _token The token to deposit\n  /// @param _amount The amount to deposit\n  function deposit(IERC20 _token, uint256 _amount) external {\n    _accrue(_token);\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Deposited(_token, msg.sender, _amount);\n  }\n\n  /// @notice Accrues the boost for the given token\n  /// @param _token The token whose boost should be updated\n  /// @return The new available balance of the boost\n  function accrue(IERC20 _token) external returns (uint256) {\n    return _accrue(_token);\n  }\n\n  /// @notice allows the owner to withdraw tokens\n  /// @param _token The token to withdraw\n  /// @param _amount The amount of tokens to withdraw\n  function withdraw(IERC20 _token, uint256 _amount) external onlyOwner {\n    uint256 availableBoost = _accrue(_token);\n    uint256 availableBalance = _token.balanceOf(address(this));\n    uint256 remainingBalance = availableBalance - _amount;\n    _boosts[IERC20(_token)].available = (availableBoost > remainingBalance ? remainingBalance : availableBoost).toUint144();\n    _token.transfer(msg.sender, _amount);\n\n    emit Withdrawn(_token, msg.sender, _amount);\n  }\n\n  /// @notice Returns the available amount of tokens for a boost\n  /// @param _tokenOut The token whose boost should be checked\n  /// @return The available amount boost tokens\n  function liquidatableBalanceOf(address _tokenOut) external override returns (uint256) {\n    return _accrue(IERC20(_tokenOut));\n  }\n\n  /// @notice Allows the liquidation pair to liquidate tokens\n  /// @param _account The account that will receive the liquidated tokens\n  /// @param _tokenIn The tokens that will be contributed to the prize pool. Must be the prize token\n  /// @param _amountIn The amount of tokens to contribute to the prize pool\n  /// @param _tokenOut The tokens that are being liquidated\n  /// @param _amountOut The amount of tokens to liquidate\n  function liquidate(\n    address _account,\n    address _tokenIn,\n    uint256 _amountIn,\n    address _tokenOut,\n    uint256 _amountOut\n  ) external override onlyPrizeToken(_tokenIn) onlyLiquidationPair(_tokenOut) returns (bool) {\n    uint256 amountAvailable = _computeAvailable(IERC20(_tokenOut));\n    if (_amountOut > amountAvailable) {\n      revert InsufficientAvailableBalance(_amountOut, amountAvailable);\n    }\n    amountAvailable = (amountAvailable - _amountOut);\n    _boosts[IERC20(_tokenOut)].available = amountAvailable.toUint144();\n    _boosts[IERC20(_tokenOut)].lastAccruedAt = uint48(block.timestamp);\n    prizePool.contributePrizeTokens(vault, _amountIn);\n    IERC20(_tokenOut).safeTransfer(_account, _amountOut);\n\n    emit Liquidated(\n      IERC20(_tokenOut),\n      _account,\n      _amountIn,\n      _amountOut,\n      amountAvailable\n    );\n\n    return true;\n  }\n\n  /// @notice Returns the liquidation target for the given input tokens. Input must be the prize token, and it always returns the prize pool.\n  /// @param _tokenIn The token that will be received. Revert if it isn't the prize token.\n  /// @return The address of the prize pool\n  function targetOf(address _tokenIn) external view override onlyPrizeToken(_tokenIn) returns (address) {\n    return address(prizePool);\n  }\n\n  /// @notice Accrues boost tokens\n  /// @param _tokenOut The token whose boost should be accrued\n  /// @return The new available balance of the boost\n  function _accrue(IERC20 _tokenOut) internal returns (uint256) {\n    uint256 available = _computeAvailable(_tokenOut);\n    _boosts[_tokenOut].available = available.toUint144();\n    _boosts[_tokenOut].lastAccruedAt = uint48(block.timestamp);\n\n    emit BoostAccrued(_tokenOut, available);\n\n    return available;\n  }\n\n  /// @notice Computes the available balance of the boost\n  /// @param _tokenOut The token whose boost should be computed\n  /// @return The new available balance\n  function _computeAvailable(IERC20 _tokenOut) internal view returns (uint256) {\n    Boost memory boost = _boosts[_tokenOut];\n    uint256 deltaTime = block.timestamp - boost.lastAccruedAt;\n    uint256 deltaAmount;\n    if (deltaTime == 0) {\n      return boost.available;\n    }\n    if (boost.tokensPerSecond > 0) {\n      deltaAmount = boost.tokensPerSecond * deltaTime;\n    }\n    if (boost.multiplierOfTotalSupplyPerSecond.unwrap() > 0) {\n      uint256 totalSupply = twabController.getTotalSupplyTwabBetween(address(vault), uint32(boost.lastAccruedAt), uint32(block.timestamp));\n      deltaAmount += convert(boost.multiplierOfTotalSupplyPerSecond.intoUD60x18().mul(convert(deltaTime)).mul(convert(totalSupply)));\n    }\n    uint256 availableBalance = _tokenOut.balanceOf(address(this));\n    deltaAmount = availableBalance > deltaAmount ? deltaAmount : availableBalance;\n    return boost.available + deltaAmount;\n  }\n\n  /// @notice Requires the given token to be the prize token\n  /// @param _tokenIn The token to be checked as the prize token\n  modifier onlyPrizeToken(address _tokenIn) {\n    if (IERC20(_tokenIn) != prizePool.prizeToken()) {\n      revert UnsupportedTokenIn();\n    }\n    _;\n  }\n\n  /// @notice Ensures that the caller is the liquidation pair for the given token\n  /// @param _token The token whose boost's liquidation pair must be the caller\n  modifier onlyLiquidationPair(address _token) {\n    if (_boosts[IERC20(_token)].liquidationPair != msg.sender) {\n      revert OnlyLiquidationPair();\n    }\n    _;\n  }\n\n}"
    }
  ]
}