{
  "Title": "[M-02] `UNISWAP_FEE` is hardcoded which will lead to significant losses compared to optimal routing",
  "Content": "_Submitted by Picodes, also found by hickuphh3_\n\nIn [`YieldManager`](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L48), `UNISWAP_FEE` is hardcoded, which reduce significantly the possibilities and will lead to non optimal routes. In particular, all swaps using ETH path will use the wrong pool as it will use the ETH / USDC 1% one due to this [line](https://github.com/sturdyfi/code4rena-may-2022/blob/d53f4f5f0b7b33a66e0081294be6117f6d6e17b4/contracts/protocol/libraries/swap/UniswapAdapter.sol#L50).\n\n### Proof of Concept\n\nFor example for CRV / USDC, the optimal route is currently CRV -> ETH and ETH -> USDC, and the pool ETH / USDC with 1% fees is tiny compared to the ones with 0.3 or 0.1%. Therefore using the current implementation would create a significant loss of revenue.\n\n### Recommended Mitigation Steps\n\nBasic mitigation would be to hardcode in advance the best Uniswap paths in a mapping like itâ€™s done for Curve pools, then pass this path already computed to the swapping library. This would allow for complex route and save gas costs as you would avoid computing them in `swapExactTokensForTokens`.\n\nThen, speaking from experience, as `distributeYield` is `onlyAdmin`, you may want to add the possibility to do the swaps through an efficient aggregator like 1Inch or Paraswap, it will be way more optimal.\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/48)**\n\n**[atozICT20 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/48):**\n > [Fix the issue of hardcoded UNISWAP_FEE sturdyfi/code4rena-may-2022#12](https://github.com/sturdyfi/code4rena-may-2022/pull/12)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-sturdy-contest",
  "Code": [
    {
      "filename": "smart-contracts/YieldManager.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {ISwapRouter} from '../../interfaces/ISwapRouter.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {TransferHelper} from '../libraries/helpers/TransferHelper.sol';\nimport {UniswapAdapter} from '../libraries/swap/UniswapAdapter.sol';\nimport {CurveswapAdapter} from '../libraries/swap/CurveswapAdapter.sol';\n\n/**\n * @title YieldManager\n * @notice yield distributor by swapping from assets to stable coin\n * @author Sturdy\n **/\n\ncontract YieldManager is VersionedInitializable, Ownable {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  struct AssetYield {\n    address asset;\n    uint256 amount;\n  }\n\n  // the list of the available reserves, structured as a mapping for gas savings reasons\n  mapping(uint256 => address) internal _assetsList;\n  uint256 internal _assetsCount;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  uint256 public constant VAULT_REVISION = 0x1;\n\n  address public _exchangeToken;\n\n  // tokenIn -> tokenOut -> Curve Pool Address\n  mapping(address => mapping(address => address)) internal _curvePools;\n\n  uint256 public constant UNISWAP_FEE = 10000; // 1%\n  uint256 public constant SLIPPAGE = 500; // 5%\n\n  modifier onlyAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.\n   * @param _provider The address of the provider\n   **/\n  function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n    _addressesProvider = _provider;\n  }\n\n  function setExchangeToken(address _token) external onlyAdmin {\n    require(_token != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _exchangeToken = _token;\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return VAULT_REVISION;\n  }\n\n  function registerAsset(address _asset) external onlyAdmin {\n    _assetsList[_assetsCount] = _asset;\n    _assetsCount = _assetsCount + 1;\n  }\n\n  function getAssetCount() external view returns (uint256) {\n    return _assetsCount;\n  }\n\n  function getAssetInfo(uint256 _index) external view returns (address) {\n    return _assetsList[_index];\n  }\n\n  /**\n   * @dev Function to set Curve Pool address for the swap\n   * @param _tokenIn The address of token being exchanged\n   * @param _tokenOut The address of token being received\n   * @param _pool The address of the Curve pool to use for the swap\n   */\n  function setCurvePool(\n    address _tokenIn,\n    address _tokenOut,\n    address _pool\n  ) external onlyAdmin {\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _curvePools[_tokenIn][_tokenOut] = _pool;\n  }\n\n  /**\n   * @dev Function to get Curve Pool address for the swap\n   * @param _tokenIn The address of token being sent\n   * @param _tokenOut The address of token being received\n   */\n  function getCurvePool(address _tokenIn, address _tokenOut) external view returns (address) {\n    return _curvePools[_tokenIn][_tokenOut];\n  }\n\n  /**\n   * @dev Distribute the yield of assets to suppliers.\n   *      1. convert asset to exchange token(for now it's USDC) via Uniswap\n   *      2. convert exchange token to other stables via Curve\n   *      3. deposit to pool for suppliers\n   * @param _offset assets array's start offset.\n   * @param _count assets array's count when perform distribution.\n   **/\n  function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\n    // 1. convert from asset to exchange token via uniswap\n    for (uint256 i = 0; i < _count; i++) {\n      address asset = _assetsList[_offset + i];\n      require(asset != address(0), Errors.UL_INVALID_INDEX);\n      uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));\n      _convertAssetToExchangeToken(asset, _amount);\n    }\n    uint256 exchangedAmount = IERC20Detailed(_exchangeToken).balanceOf(address(this));\n\n    // 2. convert from exchange token to other stable assets via curve swap\n    AssetYield[] memory assetYields = _getAssetYields(exchangedAmount);\n    for (uint256 i = 0; i < assetYields.length; i++) {\n      if (assetYields[i].amount > 0) {\n        uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount);\n        // 3. deposit Yield to pool for suppliers\n        _depositYield(assetYields[i].asset, _amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Get the list of asset and asset's yield amount\n   **/\n  function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {\n    // Get total borrowing asset volume and volumes and assets\n    (\n      uint256 totalVolume,\n      uint256[] memory volumes,\n      address[] memory assets,\n      uint256 length\n    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();\n\n    if (totalVolume == 0) return new AssetYield[](0);\n\n    AssetYield[] memory assetYields = new AssetYield[](length);\n    uint256 extraYieldAmount = _totalYieldAmount;\n\n    for (uint256 i = 0; i < length; i++) {\n      assetYields[i].asset = assets[i];\n      if (i != length - 1) {\n        // Distribute yieldAmount based on percent of asset volume\n        assetYields[i].amount = _totalYieldAmount.percentMul(\n          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)\n        );\n        extraYieldAmount = extraYieldAmount.sub(assetYields[i].amount);\n      } else {\n        // without calculation, set remained extra amount\n        assetYields[i].amount = extraYieldAmount;\n      }\n    }\n\n    return assetYields;\n  }\n\n  /**\n   * @dev Convert asset to exchange token via Uniswap\n   * @param asset The address of asset being exchanged\n   * @param amount The amount of asset being exchanged\n   */\n  function _convertAssetToExchangeToken(address asset, uint256 amount) internal {\n    UniswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      asset,\n      _exchangeToken,\n      amount,\n      UNISWAP_FEE,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to convert from exchange token to stable coin via Curve\n   * @param _tokenOut The address of stable coin\n   * @param _amount The amount of exchange token being sent\n   * @return receivedAmount The amount of stable coin converted\n   */\n  function _convertToStableCoin(address _tokenOut, uint256 _amount)\n    internal\n    returns (uint256 receivedAmount)\n  {\n    if (_tokenOut == _exchangeToken) {\n      return _amount;\n    }\n    address _pool = _curvePools[_exchangeToken][_tokenOut];\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    receivedAmount = CurveswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      _pool,\n      _exchangeToken,\n      _tokenOut,\n      _amount,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to deposit yield to pool for suppliers\n   * @param _asset The address of yield asset\n   * @param _amount The mount of asset\n   */\n  function _depositYield(address _asset, uint256 _amount) internal {\n    address _lendingPool = _addressesProvider.getLendingPool();\n    IERC20(_asset).approve(_lendingPool, _amount);\n    ILendingPool(_lendingPool).depositYield(_asset, _amount);\n  }\n}"
    }
  ]
}