{
  "Title": "Insufficient Gas Limit Specification for Cross-Chain Transfers in _buildCCIPMessage() method. WrappedTokenBridge.sol #210",
  "Content": "# Insufficient Gas Limit Specification for Cross-Chain Transfers in _buildCCIPMessage() method. WrappedTokenBridge.sol #210\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/WrappedTokenBridge.sol#L157\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/WrappedTokenBridge.sol#L157</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/WrappedTokenBridge.sol#L210\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/WrappedTokenBridge.sol#L210</a>\n\n\n## Summary\nThe _buildCCIPMessage() function in the WrappedTokenBridge contract does not specify a gasLimit for the execution of the ccipReceive() function on the destination blockchain. This omission can lead to unpredictable gas costs and potential failure of the message processing due to out-of-gas errors.\n\n## Vulnerability Details\nThe Client.EVM2AnyMessage struct created by _buildCCIPMessage() is used to define the details of a cross-chain message, including the tokens to be transferred and the receiver's address. However, the struct lacks a gasLimit field in the extraArgs, which is crucial for determining the maximum amount of gas that can be consumed when the ccipReceive() function is called on the destination chain.\n\nWithout a specified gasLimit, the default gas limit set by the CCIP router or the destination chain's infrastructure is used. This default may not align with the actual gas requirements of the ccipReceive() function, potentially leading to failed transactions or higher-than-expected fees.\n\n`\nfunction _buildCCIPMessage(\n        address _receiver,\n        uint256 _amount,\n        address _feeTokenAddress\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({token: address(wrappedToken), amount: _amount});\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_receiver),\n            data: \"\",\n            tokenAmounts: tokenAmounts,\n            extraArgs: \"0x\",\n            feeToken: _feeTokenAddress\n        });\n\n        return evm2AnyMessage;\n    }\n`\n\n## Impact\nIf the default gas limit is too low, the ccipReceive() function may run out of gas, causing the transaction to fail on the destination chain.\n\nWithout a specified gasLimit, the cost of sending a message can vary, making it difficult for users to predict the required fees.\n\n If the default gas limit is higher than necessary, users may overpay for gas that is not used, as unspent gas is not refunded.\n\n## Tools Used\nManual inspection.\n\nhttps://docs.chain.link/ccip/best-practices\n..Gas Limit\n\nCCIP Lending example. sendMessage()\nhttps://github.com/smartcontractkit/ccip-defi-lending/blob/main/contracts/Protocol.sol#170\n\n## Recommendations\n\nTo address the issue of not including a gasLimit in the _transferTokens method, we can take inspiration from the sendMessage() example and modify the _buildCCIPMessage function within the WrappedTokenBridge contract to include a gasLimit in the extraArgs field of the EVM2AnyMessage struct. This will ensure that the CCIP message sent to the destination blockchain includes a specified maximum amount of gas that can be consumed during the execution of the ccipReceive() function.\n\nfunction _buildCCIPMessage(\n    address _receiver,\n    uint256 _amount,\n    address _feeTokenAddress\n) internal view returns (Client.EVM2AnyMessage memory) {\n    Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n    Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\n        token: address(wrappedToken),\n        amount: _amount\n    });\n    tokenAmounts[0] = tokenAmount;\n\n    \n    \n//  // Include a gasLimit in the extraArgs \n    Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n        receiver: abi.encode(_receiver),\n        data: \"\",\n        tokenAmounts: tokenAmounts,\n        extraArgs:  Client._argsToBytes(\n        Client.EVMExtraArgsV1({gasLimit: 200_000, strict: false}) // Additional arguments, setting gas limit and non-strict sequency mode\n      ),\n        feeToken: _feeTokenAddress\n    });\n\n    return evm2AnyMessage;\n}\n\n\n\nIncludes a gasLimit field, which is set to 200,000 in this example. This value should be adjusted based on the expected gas consumption of the ccipReceive() function on the destination chain.\nBy including the gasLimit in the extraArgs, you ensure that the CCIP message has a specified maximum gas limit for execution, which can prevent out-of-gas errors and control the cost of the cross-chain transfer.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/ccip/WrappedTokenBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IWrappedLST.sol\";\n\n/**\n * @title Wrapped token bridge\n * @notice Handles CCIP transfers with a wrapped token\n * @dev This contract can perform 2 functions:\n * - can wrap tokens and initiate a CCIP transfer of the wrapped tokens to a destination chain\n * - can receive a CCIP transfer of wrapped tokens, unwrap them, and send them to the receiver\n */\ncontract WrappedTokenBridge is Ownable, CCIPReceiver {\n    using SafeERC20 for IERC20;\n\n    IERC20 linkToken;\n\n    IERC20 token;\n    IWrappedLST wrappedToken;\n\n    event TokensTransferred(\n        bytes32 indexed messageId,\n        uint64 indexed destinationChainSelector,\n        address indexed sender,\n        address receiver,\n        uint256 tokenAmount,\n        address feeToken,\n        uint256 fees\n    );\n    event TokensReceived(\n        bytes32 indexed messageId,\n        uint64 indexed sourceChainSelector,\n        address indexed sender,\n        address receiver,\n        uint256 tokenAmount\n    );\n\n    error InvalidSender();\n    error InvalidValue();\n    error InsufficientFee();\n    error TransferFailed();\n    error FeeExceedsLimit();\n    error InvalidMessage();\n    error InvalidMsgValue();\n    error InvalidReceiver();\n\n    /**\n     * @notice Initializes the contract\n     * @param _router address of the CCIP router\n     * @param _linkToken address of the LINK token\n     * @param _token address of the unwrapped token\n     * @param _wrappedToken address of the wrapped token\n     **/\n    constructor(\n        address _router,\n        address _linkToken,\n        address _token,\n        address _wrappedToken\n    ) CCIPReceiver(_router) {\n        linkToken = IERC20(_linkToken);\n\n        token = IERC20(_token);\n        wrappedToken = IWrappedLST(_wrappedToken);\n\n        linkToken.approve(_router, type(uint256).max);\n        token.approve(_wrappedToken, type(uint256).max);\n        wrappedToken.approve(_router, type(uint256).max);\n    }\n\n    /**\n     * @notice ERC677 implementation to receive a token transfer to be wrapped and sent to a destination chain\n     * @param _sender address of sender\n     * @param _value amount of tokens transferred\n     * @param _calldata encoded calldata consisting of destinationChainSelector (uint64), receiver (address),\n     * maxLINKFee (uint256)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external {\n        if (msg.sender != address(token)) revert InvalidSender();\n        if (_value == 0) revert InvalidValue();\n\n        (uint64 destinationChainSelector, address receiver, uint256 maxLINKFee) = abi.decode(\n            _calldata,\n            (uint64, address, uint256)\n        );\n        _transferTokens(destinationChainSelector, _sender, receiver, _value, false, maxLINKFee);\n    }\n\n    /**\n     * @notice Wraps and transfers tokens to a destination chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _receiver address to receive tokens on destination chain\n     * @param _amount amount of tokens to transfer\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @param _maxLINKFee call will revert if LINK fee exceeds this value\n     **/\n    function transferTokens(\n        uint64 _destinationChainSelector,\n        address _receiver,\n        uint256 _amount,\n        bool _payNative,\n        uint256 _maxLINKFee\n    ) external payable onlyOwner returns (bytes32 messageId) {\n        if (_payNative == false && msg.value != 0) revert InvalidMsgValue();\n\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        return _transferTokens(_destinationChainSelector, msg.sender, _receiver, _amount, _payNative, _maxLINKFee);\n    }\n\n    /**\n     * @notice Returns the current fee for a token transfer\n     * @param _destinationChainSelector id of destination chain\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @return fee current fee\n     **/\n    function getFee(uint64 _destinationChainSelector, bool _payNative) external view returns (uint256) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            address(this),\n            1000 ether,\n            _payNative ? address(0) : address(linkToken)\n        );\n\n        return IRouterClient(this.getRouter()).getFee(_destinationChainSelector, evm2AnyMessage);\n    }\n\n    /**\n     * @notice Recovers tokens that were accidentally sent to this contract\n     * @param _tokens list of tokens to recover\n     * @param _receiver address to receive recovered tokens\n     **/\n    function recoverTokens(address[] calldata _tokens, address _receiver) external onlyOwner {\n        if (_receiver == address(0)) revert InvalidReceiver();\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            IERC20 tokenToTransfer = IERC20(_tokens[i]);\n            tokenToTransfer.safeTransfer(_receiver, tokenToTransfer.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @notice Wraps and transfers tokens to a destination chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _sender address of token sender\n     * @param _receiver address to receive tokens on destination chain\n     * @param _amount amount of tokens to transfer\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @param _maxLINKFee call will revert if LINK fee exceeds this value\n     **/\n    function _transferTokens(\n        uint64 _destinationChainSelector,\n        address _sender,\n        address _receiver,\n        uint256 _amount,\n        bool _payNative,\n        uint256 _maxLINKFee\n    ) internal returns (bytes32 messageId) {\n        uint256 preWrapBalance = wrappedToken.balanceOf(address(this));\n        wrappedToken.wrap(_amount);\n        uint256 amountToTransfer = wrappedToken.balanceOf(address(this)) - preWrapBalance;\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _receiver,\n            amountToTransfer,\n            _payNative ? address(0) : address(linkToken)\n        );\n\n        IRouterClient router = IRouterClient(this.getRouter());\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (_payNative) {\n            if (fees > msg.value) revert InsufficientFee();\n            messageId = router.ccipSend{value: fees}(_destinationChainSelector, evm2AnyMessage);\n            if (fees < msg.value) {\n                (bool success, ) = _sender.call{value: msg.value - fees}(\"\");\n                if (!success) revert TransferFailed();\n            }\n        } else {\n            if (fees > _maxLINKFee) revert FeeExceedsLimit();\n            linkToken.safeTransferFrom(_sender, address(this), fees);\n            messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\n        }\n\n        emit TokensTransferred(\n            messageId,\n            _destinationChainSelector,\n            _sender,\n            _receiver,\n            amountToTransfer,\n            _payNative ? address(0) : address(linkToken),\n            fees\n        );\n        return messageId;\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @param _receiver address to receive tokens on destination chain\n     * @param _amount amount of tokens to transfer\n     * @param _feeTokenAddress address of token that fees will be paid in\n     **/\n    function _buildCCIPMessage(\n        address _receiver,\n        uint256 _amount,\n        address _feeTokenAddress\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({token: address(wrappedToken), amount: _amount});\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_receiver),\n            data: \"\",\n            tokenAmounts: tokenAmounts,\n            extraArgs: \"0x\",\n            feeToken: _feeTokenAddress\n        });\n\n        return evm2AnyMessage;\n    }\n\n    /**\n     * @notice Processes a received message\n     * @param _message CCIP message\n     **/\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        if (_message.destTokenAmounts.length != 1) revert InvalidMessage();\n\n        address tokenAddress = _message.destTokenAmounts[0].token;\n        uint256 tokenAmount = _message.destTokenAmounts[0].amount;\n        address receiver = abi.decode(_message.data, (address));\n\n        if (tokenAddress != address(wrappedToken) || receiver == address(0)) revert InvalidMessage();\n\n        uint256 preUnwrapBalance = token.balanceOf(address(this));\n        wrappedToken.unwrap(tokenAmount);\n        uint256 amountToTransfer = token.balanceOf(address(this)) - preUnwrapBalance;\n        token.safeTransfer(receiver, amountToTransfer);\n\n        emit TokensReceived(\n            _message.messageId,\n            _message.sourceChainSelector,\n            abi.decode(_message.sender, (address)),\n            receiver,\n            tokenAmount\n        );\n    }\n}"
    },
    {
      "filename": "contracts/core/ccip/WrappedTokenBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IWrappedLST.sol\";\n\n/**\n * @title Wrapped token bridge\n * @notice Handles CCIP transfers with a wrapped token\n * @dev This contract can perform 2 functions:\n * - can wrap tokens and initiate a CCIP transfer of the wrapped tokens to a destination chain\n * - can receive a CCIP transfer of wrapped tokens, unwrap them, and send them to the receiver\n */\ncontract WrappedTokenBridge is Ownable, CCIPReceiver {\n    using SafeERC20 for IERC20;\n\n    IERC20 linkToken;\n\n    IERC20 token;\n    IWrappedLST wrappedToken;\n\n    event TokensTransferred(\n        bytes32 indexed messageId,\n        uint64 indexed destinationChainSelector,\n        address indexed sender,\n        address receiver,\n        uint256 tokenAmount,\n        address feeToken,\n        uint256 fees\n    );\n    event TokensReceived(\n        bytes32 indexed messageId,\n        uint64 indexed sourceChainSelector,\n        address indexed sender,\n        address receiver,\n        uint256 tokenAmount\n    );\n\n    error InvalidSender();\n    error InvalidValue();\n    error InsufficientFee();\n    error TransferFailed();\n    error FeeExceedsLimit();\n    error InvalidMessage();\n    error InvalidMsgValue();\n    error InvalidReceiver();\n\n    /**\n     * @notice Initializes the contract\n     * @param _router address of the CCIP router\n     * @param _linkToken address of the LINK token\n     * @param _token address of the unwrapped token\n     * @param _wrappedToken address of the wrapped token\n     **/\n    constructor(\n        address _router,\n        address _linkToken,\n        address _token,\n        address _wrappedToken\n    ) CCIPReceiver(_router) {\n        linkToken = IERC20(_linkToken);\n\n        token = IERC20(_token);\n        wrappedToken = IWrappedLST(_wrappedToken);\n\n        linkToken.approve(_router, type(uint256).max);\n        token.approve(_wrappedToken, type(uint256).max);\n        wrappedToken.approve(_router, type(uint256).max);\n    }\n\n    /**\n     * @notice ERC677 implementation to receive a token transfer to be wrapped and sent to a destination chain\n     * @param _sender address of sender\n     * @param _value amount of tokens transferred\n     * @param _calldata encoded calldata consisting of destinationChainSelector (uint64), receiver (address),\n     * maxLINKFee (uint256)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external {\n        if (msg.sender != address(token)) revert InvalidSender();\n        if (_value == 0) revert InvalidValue();\n\n        (uint64 destinationChainSelector, address receiver, uint256 maxLINKFee) = abi.decode(\n            _calldata,\n            (uint64, address, uint256)\n        );\n        _transferTokens(destinationChainSelector, _sender, receiver, _value, false, maxLINKFee);\n    }\n\n    /**\n     * @notice Wraps and transfers tokens to a destination chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _receiver address to receive tokens on destination chain\n     * @param _amount amount of tokens to transfer\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @param _maxLINKFee call will revert if LINK fee exceeds this value\n     **/\n    function transferTokens(\n        uint64 _destinationChainSelector,\n        address _receiver,\n        uint256 _amount,\n        bool _payNative,\n        uint256 _maxLINKFee\n    ) external payable onlyOwner returns (bytes32 messageId) {\n        if (_payNative == false && msg.value != 0) revert InvalidMsgValue();\n\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        return _transferTokens(_destinationChainSelector, msg.sender, _receiver, _amount, _payNative, _maxLINKFee);\n    }\n\n    /**\n     * @notice Returns the current fee for a token transfer\n     * @param _destinationChainSelector id of destination chain\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @return fee current fee\n     **/\n    function getFee(uint64 _destinationChainSelector, bool _payNative) external view returns (uint256) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            address(this),\n            1000 ether,\n            _payNative ? address(0) : address(linkToken)\n        );\n\n        return IRouterClient(this.getRouter()).getFee(_destinationChainSelector, evm2AnyMessage);\n    }\n\n    /**\n     * @notice Recovers tokens that were accidentally sent to this contract\n     * @param _tokens list of tokens to recover\n     * @param _receiver address to receive recovered tokens\n     **/\n    function recoverTokens(address[] calldata _tokens, address _receiver) external onlyOwner {\n        if (_receiver == address(0)) revert InvalidReceiver();\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            IERC20 tokenToTransfer = IERC20(_tokens[i]);\n            tokenToTransfer.safeTransfer(_receiver, tokenToTransfer.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @notice Wraps and transfers tokens to a destination chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _sender address of token sender\n     * @param _receiver address to receive tokens on destination chain\n     * @param _amount amount of tokens to transfer\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @param _maxLINKFee call will revert if LINK fee exceeds this value\n     **/\n    function _transferTokens(\n        uint64 _destinationChainSelector,\n        address _sender,\n        address _receiver,\n        uint256 _amount,\n        bool _payNative,\n        uint256 _maxLINKFee\n    ) internal returns (bytes32 messageId) {\n        uint256 preWrapBalance = wrappedToken.balanceOf(address(this));\n        wrappedToken.wrap(_amount);\n        uint256 amountToTransfer = wrappedToken.balanceOf(address(this)) - preWrapBalance;\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _receiver,\n            amountToTransfer,\n            _payNative ? address(0) : address(linkToken)\n        );\n\n        IRouterClient router = IRouterClient(this.getRouter());\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (_payNative) {\n            if (fees > msg.value) revert InsufficientFee();\n            messageId = router.ccipSend{value: fees}(_destinationChainSelector, evm2AnyMessage);\n            if (fees < msg.value) {\n                (bool success, ) = _sender.call{value: msg.value - fees}(\"\");\n                if (!success) revert TransferFailed();\n            }\n        } else {\n            if (fees > _maxLINKFee) revert FeeExceedsLimit();\n            linkToken.safeTransferFrom(_sender, address(this), fees);\n            messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\n        }\n\n        emit TokensTransferred(\n            messageId,\n            _destinationChainSelector,\n            _sender,\n            _receiver,\n            amountToTransfer,\n            _payNative ? address(0) : address(linkToken),\n            fees\n        );\n        return messageId;\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @param _receiver address to receive tokens on destination chain\n     * @param _amount amount of tokens to transfer\n     * @param _feeTokenAddress address of token that fees will be paid in\n     **/\n    function _buildCCIPMessage(\n        address _receiver,\n        uint256 _amount,\n        address _feeTokenAddress\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({token: address(wrappedToken), amount: _amount});\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_receiver),\n            data: \"\",\n            tokenAmounts: tokenAmounts,\n            extraArgs: \"0x\",\n            feeToken: _feeTokenAddress\n        });\n\n        return evm2AnyMessage;\n    }\n\n    /**\n     * @notice Processes a received message\n     * @param _message CCIP message\n     **/\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        if (_message.destTokenAmounts.length != 1) revert InvalidMessage();\n\n        address tokenAddress = _message.destTokenAmounts[0].token;\n        uint256 tokenAmount = _message.destTokenAmounts[0].amount;\n        address receiver = abi.decode(_message.data, (address));\n\n        if (tokenAddress != address(wrappedToken) || receiver == address(0)) revert InvalidMessage();\n\n        uint256 preUnwrapBalance = token.balanceOf(address(this));\n        wrappedToken.unwrap(tokenAmount);\n        uint256 amountToTransfer = token.balanceOf(address(this)) - preUnwrapBalance;\n        token.safeTransfer(receiver, amountToTransfer);\n\n        emit TokensReceived(\n            _message.messageId,\n            _message.sourceChainSelector,\n            abi.decode(_message.sender, (address)),\n            receiver,\n            tokenAmount\n        );\n    }\n}"
    },
    {
      "filename": "contracts/Protocol.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {OwnerIsCreator} from \"@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol\";\nimport {LinkTokenInterface} from \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/token/ERC20/IERC20.sol\";\nimport {IERC165} from \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/utils/introspection/IERC165.sol\";\n\nimport {IAny2EVMMessageReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol\";\nimport {MockUSDC} from \"./MockUSDC.sol\";\n\n/**\n * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.\n * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.\n * DO NOT USE THIS CODE IN PRODUCTION.\n */\n\n/// @title - A simple messenger contract for sending/receiving messages and tokens across chains.\n/// Pay using LINK tokens\ncontract Protocol is CCIPReceiver, OwnerIsCreator {\n  // Custom errors to provide more descriptive revert messages.\n  error NoMessageReceived(); // Used when trying to access a message but no messages have been received.\n  error IndexOutOfBound(uint256 providedIndex, uint256 maxIndex); // Used when the provided index is out of bounds.\n  error MessageIdNotExist(bytes32 messageId); // Used when the provided message ID does not exist.\n  error NotEnoughBalance(uint256, uint256);\n  error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.\n  error FailedToWithdrawEth(address owner, uint256 value); // Used when the withdrawal of Ether fails.\n\n  // Event emitted when a message is sent to another chain.\n  event MessageSent(\n    bytes32 indexed messageId, // The unique ID of the message.\n    uint64 indexed destinationChainSelector, // The chain selector of the destination chain.\n    address receiver, // The address of the receiver on the destination chain.\n    address borrower, // The borrower's EOA - would map to a depositor on the source chain.\n    Client.EVMTokenAmount tokenAmount, // The token amount that was sent.\n    uint256 fees // The fees paid for sending the message.\n  );\n\n  // Event emitted when a message is received from another chain.\n  event MessageReceived(\n    bytes32 indexed messageId, // The unique ID of the message.\n    uint64 indexed sourceChainSelector, // The chain selector of the source chain.\n    address sender, // The address of the sender from the source chain.\n    address depositor, // The EOA of the depositor on the source chain\n    Client.EVMTokenAmount tokenAmount // The token amount that was received.\n  );\n\n  // Struct to hold details of a message.\n  struct MessageIn {\n    uint64 sourceChainSelector; // The chain selector of the source chain.\n    address sender; // The address of the sender.\n    address depositor; // The content of the message.\n    address token; // received token.\n    uint256 amount; // received amount.\n  }\n\n  // Storage variables.\n  bytes32[] public receivedMessages; // Array to keep track of the IDs of received messages.\n  mapping(bytes32 => MessageIn) public messageDetail; // Mapping from message ID to MessageIn struct, storing details of each received message.\n  mapping(address => mapping(address => uint256)) public deposits; // Depsitor Address => Deposited Token Address ==> amount\n  mapping(address => mapping(address => uint256)) public borrowings; // Depsitor Address => Borrowed Token Address ==> amount\n\n  MockUSDC public usdcToken;\n  LinkTokenInterface linkToken;\n\n  constructor(address _router, address link) CCIPReceiver(_router) {\n    linkToken = LinkTokenInterface(link);\n    usdcToken = new MockUSDC();\n  }\n\n  /// handle a received message\n  function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n    bytes32 messageId = any2EvmMessage.messageId; // fetch the messageId\n    uint64 sourceChainSelector = any2EvmMessage.sourceChainSelector; // fetch the source chain identifier (aka selector)\n    address sender = abi.decode(any2EvmMessage.sender, (address)); // abi-decoding of the sender address\n    address depositor = abi.decode(any2EvmMessage.data, (address)); // abi-decoding of the depositor's address\n\n    // Collect tokens transferred. This increases this contract's balance for that Token.\n    Client.EVMTokenAmount[] memory tokenAmounts = any2EvmMessage.destTokenAmounts;\n    address token = tokenAmounts[0].token;\n    uint256 amount = tokenAmounts[0].amount;\n\n    receivedMessages.push(messageId);\n    MessageIn memory detail = MessageIn(sourceChainSelector, sender, depositor, token, amount);\n    messageDetail[messageId] = detail;\n\n    emit MessageReceived(messageId, sourceChainSelector, sender, depositor, tokenAmounts[0]);\n\n    // Store depositor data.\n    deposits[depositor][token] += amount;\n  }\n\n  function borrowUSDC(bytes32 msgId) public returns (uint256) {\n    uint256 borrowed = borrowings[msg.sender][address(usdcToken)];\n    require(borrowed == 0, \"Caller has already borrowed USDC\");\n\n    address transferredToken = messageDetail[msgId].token;\n    require(transferredToken != address(0), \"Caller has not transferred this token\");\n\n    uint256 deposited = deposits[msg.sender][transferredToken];\n    uint256 borrowable = (deposited * 70) / 100; // 70% collaterization ratio.\n\n    // In this example we treat BnM as though it has the same value SNX. This is because BnM tokens are dummy tokens that are not on Chainlink Pricefeeds.\n    // And that the USD/USDC peg is a perfect 1:1\n    // SNX/USD on Sepolia (https://sepolia.etherscan.io/address/0xc0F82A46033b8BdBA4Bb0B0e28Bc2006F64355bC)\n    // Docs: https://docs.chain.link/data-feeds/price-feeds/addresses#Sepolia%20Testnet\n    AggregatorV3Interface priceFeed = AggregatorV3Interface(0xc0F82A46033b8BdBA4Bb0B0e28Bc2006F64355bC);\n\n    (, int256 price, , , ) = priceFeed.latestRoundData();\n    uint256 price18decimals = uint256(price * (10 ** 10)); // make USD price 18 decimal places from 8 decimal places.\n\n    uint256 borrowableInUSDC = borrowable * price18decimals;\n\n    // MintUSDC\n    usdcToken.mint(msg.sender, borrowableInUSDC);\n\n    // Update state.\n    borrowings[msg.sender][address(usdcToken)] = borrowableInUSDC;\n\n    assert(borrowings[msg.sender][address(usdcToken)] == borrowableInUSDC);\n    return borrowableInUSDC;\n  }\n\n  // Repay the Protocol. Transfer tokens back to source chain.\n  // Assumes borrower has approved this contract to burn their borrowed token.\n  // Assumes borrower has approved this contract to \"spend\" the transferred token so it can be transferred.\n  function repayAndSendMessage(uint256 amount, uint64 destinationChain, address receiver, bytes32 msgId) public {\n    require(amount >= borrowings[msg.sender][address(usdcToken)], \"Repayment amount is less than amount borrowed\");\n\n    // Get the deposit details, so it can be transferred back.\n    address transferredToken = messageDetail[msgId].token;\n    uint256 deposited = deposits[msg.sender][transferredToken];\n\n    uint256 mockUSDCBal = usdcToken.balanceOf(msg.sender);\n    require(mockUSDCBal >= amount, \"Caller's USDC token balance insufficient for repayment\");\n\n    if (usdcToken.allowance(msg.sender, address(this)) < borrowings[msg.sender][address(usdcToken)]) {\n      revert(\"Protocol allowance is less than amount borrowed\");\n    }\n\n    usdcToken.burnFrom(msg.sender, mockUSDCBal);\n\n    borrowings[msg.sender][address(usdcToken)] = 0;\n    // send transferred token and message back to Sepolia Sender contract\n    sendMessage(destinationChain, receiver, transferredToken, deposited);\n  }\n\n  function sendMessage(\n    uint64 destinationChainSelector,\n    address receiver,\n    address tokenToTransfer,\n    uint256 transferAmount\n  ) internal returns (bytes32 messageId) {\n    address borrower = msg.sender;\n\n    // Compose the EVMTokenAmountStruct. This struct describes the tokens being transferred using CCIP.\n    Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n\n    Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({token: tokenToTransfer, amount: transferAmount});\n    tokenAmounts[0] = tokenAmount;\n\n    Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n      receiver: abi.encode(receiver), // ABI-encoded receiver address\n      data: abi.encode(borrower), // ABI-encoded string message\n      tokenAmounts: tokenAmounts,\n      extraArgs: Client._argsToBytes(\n        Client.EVMExtraArgsV1({gasLimit: 200_000, strict: false}) // Additional arguments, setting gas limit and non-strict sequency mode\n      ),\n      feeToken: address(linkToken) // Setting feeToken to LinkToken address, indicating LINK will be used for fees\n    });\n\n    // Initialize a router client instance to interact with cross-chain\n    IRouterClient router = IRouterClient(this.getRouter());\n\n    // Get the fee required to send the message\n    uint256 fees = router.getFee(destinationChainSelector, evm2AnyMessage);\n\n    // approve the Router to send LINK tokens on contract's behalf. I will spend the fees in LINK\n    linkToken.approve(address(router), fees);\n\n    require(IERC20(tokenToTransfer).approve(address(router), transferAmount), \"Failed to approve router\");\n\n    // Send the message through the router and store the returned message ID\n    messageId = router.ccipSend(destinationChainSelector, evm2AnyMessage);\n\n    // Emit an event with message details\n    emit MessageSent(messageId, destinationChainSelector, receiver, borrower, tokenAmount, fees);\n\n    deposits[borrower][tokenToTransfer] -= transferAmount;\n\n    // Return the message ID\n    return messageId;\n  }\n\n  function getNumberOfReceivedMessages() external view returns (uint256 number) {\n    return receivedMessages.length;\n  }\n\n  function getReceivedMessageDetails(\n    bytes32 messageId\n  ) external view returns (uint64, address, address, address token, uint256 amount) {\n    MessageIn memory detail = messageDetail[messageId];\n    if (detail.sender == address(0)) revert MessageIdNotExist(messageId);\n    return (detail.sourceChainSelector, detail.sender, detail.depositor, detail.token, detail.amount);\n  }\n\n  function getLastReceivedMessageDetails()\n    external\n    view\n    returns (bytes32 messageId, uint64, address, address, address, uint256)\n  {\n    // Revert if no messages have been received\n    if (receivedMessages.length == 0) revert NoMessageReceived();\n\n    // Fetch the last received message ID\n    messageId = receivedMessages[receivedMessages.length - 1];\n\n    // Fetch the details of the last received message\n    MessageIn memory detail = messageDetail[messageId];\n\n    return (messageId, detail.sourceChainSelector, detail.sender, detail.depositor, detail.token, detail.amount);\n  }\n\n  function isChainSupported(uint64 destChainSelector) external view returns (bool supported) {\n    return IRouterClient(this.getRouter()).isChainSupported(destChainSelector);\n  }\n\n  /// @notice Fallback function to allow the contract to receive Ether.\n  /// @dev This function has no function body, making it a default function for receiving Ether.\n  /// It is automatically called when Ether is sent to the contract without any data.\n  receive() external payable {}\n\n  /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.\n  /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.\n  /// It should only be callable by the owner of the contract.\n  function withdraw() public onlyOwner {\n    // Retrieve the balance of this contract\n    uint256 amount = address(this).balance;\n\n    // Attempt to send the funds, capturing the success status and discarding any return data\n    (bool sent, ) = msg.sender.call{value: amount}(\"\");\n\n    // Revert if the send failed, with information about the attempted transfer\n    if (!sent) revert FailedToWithdrawEth(msg.sender, amount);\n  }\n\n  /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.\n  /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.\n  /// @param token The contract address of the ERC20 token to be withdrawn.\n  function withdrawToken(address token) public onlyOwner {\n    // Retrieve the balance of this contract\n    uint256 amount = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(msg.sender, amount);\n  }\n}"
    }
  ]
}