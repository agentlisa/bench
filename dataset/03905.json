{
  "Title": "Gas overflow during iteration (DoS)",
  "Content": "##### Description\nEach iteration of the cycle requires a gas flow.\nA moment may come when more gas is required than it is allocated to record one block. In this case, all iterations of the loop will fail.\nAffected lines:\nhttps://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/Strategy.sol#L413\n\n##### Recommendation\nIt is recommended adding a check for the maximum possible number of elements of the arrays.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Strategy.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./GenericLender/IGenericLender.sol\";\nimport \"./WantToEthOracle/IWantToEth.sol\";\n\nimport \"@yearnvaults/contracts/BaseStrategy.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ninterface IUni {\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n\n/********************\n *\n *   A lender optimisation strategy for any erc20 asset\n *   https://github.com/Grandthrax/yearnV2-generic-lender-strat\n *   v0.2.2\n *\n *   This strategy works by taking plugins designed for standard lending platforms\n *   It automatically chooses the best yield generating platform and adjusts accordingly\n *   The adjustment is sub optimal so there is an additional option to manually set position\n *\n ********************* */\n\ncontract Strategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public constant uniswapRouter = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address public constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    IGenericLender[] public lenders;\n    bool public externalOracle = false;\n    address public wantToEthOracle;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        debtThreshold = 1000;\n\n        //we do this horrible thing because you can't compare strings in solidity\n        require(keccak256(bytes(apiVersion())) == keccak256(bytes(VaultAPI(_vault).apiVersion())), \"WRONG VERSION\");\n    }\n\n    function setPriceOracle(address _oracle) external onlyAuthorized {\n        wantToEthOracle = _oracle;\n    }\n\n    function name() external view override returns (string memory) {\n        return \"StrategyLenderYieldOptimiser\";\n    }\n\n    //management functions\n    //add lenders for the strategy to choose between\n    // only governance to stop strategist adding dodgy lender\n    function addLender(address a) public onlyGovernance {\n        IGenericLender n = IGenericLender(a);\n        require(n.strategy() == address(this), \"Undocked Lender\");\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            require(a != address(lenders[i]), \"Already Added\");\n        }\n        lenders.push(n);\n    }\n\n    //but strategist can remove for safety\n    function safeRemoveLender(address a) public onlyAuthorized {\n        _removeLender(a, false);\n    }\n\n    function forceRemoveLender(address a) public onlyAuthorized {\n        _removeLender(a, true);\n    }\n\n    //force removes the lender even if it still has a balance\n    function _removeLender(address a, bool force) internal {\n        for (uint256 i = 0; i < lenders.length; i++) {\n            if (a == address(lenders[i])) {\n                bool allWithdrawn = lenders[i].withdrawAll();\n\n                if (!force) {\n                    require(allWithdrawn, \"WITHDRAW FAILED\");\n                }\n\n                //put the last index here\n                //remove last index\n                if (i != lenders.length - 1) {\n                    lenders[i] = lenders[lenders.length - 1];\n                }\n\n                //pop shortens array by 1 thereby deleting the last index\n                lenders.pop();\n\n                //if balance to spend we might as well put it into the best lender\n                if (want.balanceOf(address(this)) > 0) {\n                    adjustPosition(0);\n                }\n                return;\n            }\n        }\n        require(false, \"NOT LENDER\");\n    }\n\n    //we could make this more gas efficient but it is only used by a view function\n    struct lendStatus {\n        string name;\n        uint256 assets;\n        uint256 rate;\n        address add;\n    }\n\n    //Returns the status of all lenders attached the strategy\n    function lendStatuses() public view returns (lendStatus[] memory) {\n        lendStatus[] memory statuses = new lendStatus[](lenders.length);\n        for (uint256 i = 0; i < lenders.length; i++) {\n            lendStatus memory s;\n            s.name = lenders[i].lenderName();\n            s.add = address(lenders[i]);\n            s.assets = lenders[i].nav();\n            s.rate = lenders[i].apr();\n            statuses[i] = s;\n        }\n\n        return statuses;\n    }\n\n    // lent assets plus loose assets\n    function estimatedTotalAssets() public view override returns (uint256) {\n        uint256 nav = lentTotalAssets();\n        nav += want.balanceOf(address(this));\n\n        return nav;\n    }\n\n    function numLenders() public view returns (uint256) {\n        return lenders.length;\n    }\n\n    //the weighted apr of all lenders. sum(nav * apr)/totalNav\n    function estimatedAPR() public view returns (uint256) {\n        uint256 bal = estimatedTotalAssets();\n        if (bal == 0) {\n            return 0;\n        }\n\n        uint256 weightedAPR = 0;\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            weightedAPR += lenders[i].weightedApr();\n        }\n\n        return weightedAPR.div(bal);\n    }\n\n    //Estimates the impact on APR if we add more money. It does not take into account adjusting position\n    function _estimateDebtLimitIncrease(uint256 change) internal view returns (uint256) {\n        uint256 highestAPR = 0;\n        uint256 aprChoice = 0;\n        uint256 assets = 0;\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            uint256 apr = lenders[i].aprAfterDeposit(change);\n            if (apr > highestAPR) {\n                aprChoice = i;\n                highestAPR = apr;\n                assets = lenders[i].nav();\n            }\n        }\n\n        uint256 weightedAPR = highestAPR.mul(assets.add(change));\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            if (i != aprChoice) {\n                weightedAPR += lenders[i].weightedApr();\n            }\n        }\n\n        uint256 bal = estimatedTotalAssets().add(change);\n\n        return weightedAPR.div(bal);\n    }\n\n    //Estimates debt limit decrease. It is not accurate and should only be used for very broad decision making\n    function _estimateDebtLimitDecrease(uint256 change) internal view returns (uint256) {\n        uint256 lowestApr = uint256(-1);\n        uint256 aprChoice = 0;\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            uint256 apr = lenders[i].aprAfterDeposit(change);\n            if (apr < lowestApr) {\n                aprChoice = i;\n                lowestApr = apr;\n            }\n        }\n\n        uint256 weightedAPR = 0;\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            if (i != aprChoice) {\n                weightedAPR += lenders[i].weightedApr();\n            } else {\n                uint256 asset = lenders[i].nav();\n                if (asset < change) {\n                    //simplistic. not accurate\n                    change = asset;\n                }\n                weightedAPR += lowestApr.mul(change);\n            }\n        }\n        uint256 bal = estimatedTotalAssets().add(change);\n        return weightedAPR.div(bal);\n    }\n\n    //estimates highest and lowest apr lenders. Public for debugging purposes but not much use to general public\n    function estimateAdjustPosition()\n        public\n        view\n        returns (\n            uint256 _lowest,\n            uint256 _lowestApr,\n            uint256 _highest,\n            uint256 _potential\n        )\n    {\n        //all loose assets are to be invested\n        uint256 looseAssets = want.balanceOf(address(this));\n\n        // our simple algo\n        // get the lowest apr strat\n        // cycle through and see who could take its funds plus want for the highest apr\n        _lowestApr = uint256(-1);\n        _lowest = 0;\n        uint256 lowestNav = 0;\n        for (uint256 i = 0; i < lenders.length; i++) {\n            if (lenders[i].hasAssets()) {\n                uint256 apr = lenders[i].apr();\n                if (apr < _lowestApr) {\n                    _lowestApr = apr;\n                    _lowest = i;\n                    lowestNav = lenders[i].nav();\n                }\n            }\n        }\n\n        uint256 toAdd = lowestNav.add(looseAssets);\n\n        uint256 highestApr = 0;\n        _highest = 0;\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            uint256 apr;\n            apr = lenders[i].aprAfterDeposit(looseAssets);\n\n            if (apr > highestApr) {\n                highestApr = apr;\n                _highest = i;\n            }\n        }\n\n        //if we can improve apr by withdrawing we do so\n        _potential = lenders[_highest].aprAfterDeposit(toAdd);\n    }\n\n    //gives estiomate of future APR with a change of debt limit. Useful for governance to decide debt limits\n    function estimatedFutureAPR(uint256 newDebtLimit) public view returns (uint256) {\n        uint256 oldDebtLimit = vault.strategies(address(this)).totalDebt;\n        uint256 change;\n        if (oldDebtLimit < newDebtLimit) {\n            change = newDebtLimit - oldDebtLimit;\n            return _estimateDebtLimitIncrease(change);\n        } else {\n            change = oldDebtLimit - newDebtLimit;\n            return _estimateDebtLimitDecrease(change);\n        }\n    }\n\n    //cycle all lenders and collect balances\n    function lentTotalAssets() public view returns (uint256) {\n        uint256 nav = 0;\n        for (uint256 i = 0; i < lenders.length; i++) {\n            nav += lenders[i].nav();\n        }\n        return nav;\n    }\n\n    //we need to free up profit plus _debtOutstanding.\n    //If _debtOutstanding is more than we can free we get as much as possible\n    // should be no way for there to be a loss. we hope...\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _profit = 0;\n        _loss = 0; //for clarity\n        _debtPayment = _debtOutstanding;\n\n        uint256 lentAssets = lentTotalAssets();\n\n        uint256 looseAssets = want.balanceOf(address(this));\n\n        uint256 total = looseAssets.add(lentAssets);\n\n        if (lentAssets == 0) {\n            //no position to harvest or profit to report\n            if (_debtPayment > looseAssets) {\n                //we can only return looseAssets\n                _debtPayment = looseAssets;\n            }\n\n            return (_profit, _loss, _debtPayment);\n        }\n\n        uint256 debt = vault.strategies(address(this)).totalDebt;\n\n        if (total > debt) {\n            _profit = total - debt;\n            uint256 amountToFree = _profit.add(_debtPayment);\n\n            //we need to add outstanding to our profit\n            //dont need to do logic if there is nothiing to free\n            if (amountToFree > 0 && looseAssets < amountToFree) {\n                //withdraw what we can withdraw\n                _withdrawSome(amountToFree.sub(looseAssets));\n                uint256 newLoose = want.balanceOf(address(this));\n\n                //if we dont have enough money adjust _debtOutstanding and only change profit if needed\n                if (newLoose < amountToFree) {\n                    if (_profit > newLoose) {\n                        _profit = newLoose;\n                        _debtPayment = 0;\n                    } else {\n                        _debtPayment = Math.min(newLoose - _profit, _debtPayment);\n                    }\n                }\n            }\n        } else {\n            //serious loss should never happen but if it does lets record it accurately\n            _loss = debt - total;\n            uint256 amountToFree = _loss.add(_debtPayment);\n\n            if (amountToFree > 0 && looseAssets < amountToFree) {\n                //withdraw what we can withdraw\n\n                _withdrawSome(amountToFree.sub(looseAssets));\n                uint256 newLoose = want.balanceOf(address(this));\n\n                //if we dont have enough money adjust _debtOutstanding and only change profit if needed\n                if (newLoose < amountToFree) {\n                    if (_loss > newLoose) {\n                        _loss = newLoose;\n                        _debtPayment = 0;\n                    } else {\n                        _debtPayment = Math.min(newLoose - _loss, _debtPayment);\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Key logic.\n     *   The algorithm moves assets from lowest return to highest\n     *   like a very slow idiots bubble sort\n     *   we ignore debt outstanding for an easy life\n     */\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        //we just keep all money in want if we dont have any lenders\n        if (lenders.length == 0) {\n            return;\n        }\n\n        _debtOutstanding; //ignored. we handle it in prepare return\n        //emergency exit is dealt with at beginning of harvest\n        if (emergencyExit) {\n            return;\n        }\n\n        (uint256 lowest, uint256 lowestApr, uint256 highest, uint256 potential) = estimateAdjustPosition();\n\n        if (potential > lowestApr) {\n            //apr should go down after deposit so wont be withdrawing from self\n            lenders[lowest].withdrawAll();\n        }\n\n        uint256 bal = want.balanceOf(address(this));\n        if (bal > 0) {\n            want.safeTransfer(address(lenders[highest]), bal);\n            lenders[highest].deposit();\n        }\n    }\n\n    struct lenderRatio {\n        address lender;\n        //share x 1000\n        uint16 share;\n    }\n\n    //share must add up to 1000.\n    function manualAllocation(lenderRatio[] memory _newPositions) public onlyAuthorized {\n        uint256 share = 0;\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            lenders[i].withdrawAll();\n        }\n\n        uint256 assets = want.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _newPositions.length; i++) {\n            bool found = false;\n\n            //might be annoying and expensive to do this second loop but worth it for safety\n            for (uint256 j = 0; j < lenders.length; j++) {\n                if (address(lenders[j]) == _newPositions[j].lender) {\n                    found = true;\n                }\n            }\n            require(found, \"NOT LENDER\");\n\n            share += _newPositions[i].share;\n            uint256 toSend = assets.mul(_newPositions[i].share).div(1000);\n            want.safeTransfer(_newPositions[i].lender, toSend);\n            IGenericLender(_newPositions[i].lender).deposit();\n        }\n\n        require(share == 1000, \"SHARE!=1000\");\n    }\n\n    //cycle through withdrawing from worst rate first\n    function _withdrawSome(uint256 _amount) internal returns (uint256 amountWithdrawn) {\n        //dont withdraw dust\n        if (_amount < debtThreshold) {\n            return 0;\n        }\n\n        amountWithdrawn = 0;\n        //most situations this will only run once. Only big withdrawals will be a gas guzzler\n        uint256 j = 0;\n        while (amountWithdrawn < _amount) {\n            uint256 lowestApr = uint256(-1);\n            uint256 lowest = 0;\n            for (uint256 i = 0; i < lenders.length; i++) {\n                if (lenders[i].hasAssets()) {\n                    uint256 apr = lenders[i].apr();\n                    if (apr < lowestApr) {\n                        lowestApr = apr;\n                        lowest = i;\n                    }\n                }\n            }\n            if (!lenders[lowest].hasAssets()) {\n                return amountWithdrawn;\n            }\n            amountWithdrawn += lenders[lowest].withdraw(_amount - amountWithdrawn);\n            j++;\n            //dont want infinite loop\n            if (j >= 6) {\n                return amountWithdrawn;\n            }\n        }\n    }\n\n    /*\n     * Liquidate as many assets as possible to `want`, irregardless of slippage,\n     * up to `_amountNeeded`. Any excess should be re-invested here as well.\n     */\n    function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _amountFreed, uint256 _loss) {\n        uint256 _balance = want.balanceOf(address(this));\n\n        if (_balance >= _amountNeeded) {\n            //if we don't set reserve here withdrawer will be sent our full balance\n            return (_amountNeeded, 0);\n        } else {\n            uint256 received = _withdrawSome(_amountNeeded - _balance).add(_balance);\n            if (received >= _amountNeeded) {\n                return (_amountNeeded, 0);\n            } else {\n                return (received, 0);\n            }\n        }\n    }\n\n    function harvestTrigger(uint256 callCost) public view override returns (bool) {\n        uint256 wantCallCost = _callCostToWant(callCost);\n\n        return super.harvestTrigger(wantCallCost);\n    }\n\n    function ethToWant(uint256 _amount) internal view returns (uint256) {\n        address[] memory path = new address[](2);\n        path = new address[](2);\n        path[0] = weth;\n        path[1] = address(want);\n\n        uint256[] memory amounts = IUni(uniswapRouter).getAmountsOut(_amount, path);\n\n        return amounts[amounts.length - 1];\n    }\n\n    function _callCostToWant(uint256 callCost) internal view returns (uint256) {\n        uint256 wantCallCost;\n\n        //three situations\n        //1 currency is eth so no change.\n        //2 we use uniswap swap price\n        //3 we use external oracle\n        if (address(want) == weth) {\n            wantCallCost = callCost;\n        } else if (wantToEthOracle == address(0)) {\n            wantCallCost = ethToWant(callCost);\n        } else {\n            wantCallCost = IWantToEth(wantToEthOracle).ethToWant(callCost);\n        }\n\n        return wantCallCost;\n    }\n\n    function tendTrigger(uint256 callCost) public view override returns (bool) {\n        // make sure to call tendtrigger with same callcost as harvestTrigger\n        if (harvestTrigger(callCost)) {\n            return false;\n        }\n\n        //now let's check if there is better apr somewhere else.\n        //If there is and profit potential is worth changing then lets do it\n        (uint256 lowest, uint256 lowestApr, , uint256 potential) = estimateAdjustPosition();\n\n        //if protential > lowestApr it means we are changing horses\n        if (potential > lowestApr) {\n            uint256 nav = lenders[lowest].nav();\n\n            //profit increase is 1 days profit with new apr\n            uint256 profitIncrease = (nav.mul(potential) - nav.mul(lowestApr)).div(1e18).div(365);\n\n            uint256 wantCallCost = _callCostToWant(callCost);\n\n            return (wantCallCost * callCost < profitIncrease);\n        }\n    }\n\n    /*\n     * revert if we can't withdraw full balance\n     */\n    function prepareMigration(address _newStrategy) internal override {\n        uint256 outstanding = vault.strategies(address(this)).totalDebt;\n        (, uint256 loss, uint256 wantBalance) = prepareReturn(outstanding);\n\n        require(wantBalance.add(loss) >= outstanding, \"LIQUIDITY LOCKED\");\n        want.safeTransfer(_newStrategy, want.balanceOf(address(this)));\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = address(want);\n        return protected;\n    }\n}"
    }
  ]
}