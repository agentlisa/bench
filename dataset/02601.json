{
  "Title": "Share price calculations should never result in a zero value",
  "Content": "The share price represents the amount of stETH needed to mint one vault share. When the number of vault shares that has been minted thus far is zero, the share price should simply be the ratio of the underlying asset’s decimals to the vault’s decimals. There were multiple share price calculations in the [`STETHVault`](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/STETHVault.sol) contract that incorrectly returned zero in this scenario:\n\n\n* the [`lastSharePrice` instantiation](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/STETHVault.sol#L79) in the `_afterRoundStart` function\n* the [`currentSharePrice` calculation](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/STETHVault.sol#L81-L83) in the `_afterRoundStart` function\n* the lack of [`endSharePrice` calculation](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/STETHVault.sol#L92-L111) when `supply` is zero in the `_afterRoundEnd` function\n* the [`startSharePrice` calculation](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/STETHVault.sol#L113-L115) in the `_afterRoundEnd` function\n\n\nConsider using the [`convertToAssets`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.7.3/contracts/token/ERC20/extensions/ERC4626.sol#L54) function that is inherited from OpenZeppelin’s [`ERC-4626`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.7.3/contracts/token/ERC20/extensions/ERC4626.sol) contract instead of the manual calculations, as it contains logic to handle this edge case. Additionally, when instantiating `lastSharePrice` in the `_afterRoundStart` function, consider setting the numerator to `10 ** underlying asset decimals` and the denominator to `10 ** sharePriceDecimals` when the number of vault shares is zero.\n\n\n**Update:** *Resolved in [PR#109](https://github.com/pods-finance/yield-contracts/pull/109), with commit `88e0b18fa497ce86194ab5ac8b9cc346ecfb3b75` being the last one added.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/STETHVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { BaseVault } from \"./BaseVault.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\n\n/**\n * @title STETHVault\n * @notice A Vault that use variable weekly yields to buy strangles\n * @author Pods Finance\n */\ncontract STETHVault is BaseVault {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n\n    /**\n     * @dev INVESTOR_RATIO is the proportion that the weekly yield will be split\n     * The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n     */\n    uint256 public constant INVESTOR_RATIO = 5000;\n    address public immutable investor;\n    uint8 public immutable sharePriceDecimals;\n    uint256 public lastRoundAssets;\n    Fractional public lastSharePrice;\n\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n    event EndRoundData(\n        uint256 indexed roundId,\n        uint256 roundAccruedInterest,\n        uint256 investmentYield,\n        uint256 idleAssets\n    );\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n    constructor(\n        IConfigurationManager _configuration,\n        IERC20Metadata _asset,\n        address _investor\n    )\n        BaseVault(\n            _configuration,\n            _asset,\n            string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\")),\n            string(abi.encodePacked(_asset.symbol(), \"vv\"))\n        )\n    {\n        investor = _investor;\n        sharePriceDecimals = _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view override(ERC4626, IERC4626) returns (uint256) {\n        return IERC20Metadata(asset()).balanceOf(address(this)) - totalIdleAssets();\n    }\n\n    /**\n     * @notice Return the stETH price per share\n     * @dev Each share is considered to be 10^(assets.decimals())\n     */\n    function sharePrice() external view returns (uint256) {\n        return totalAssets().mulDiv(10**sharePriceDecimals, totalSupply(), Math.Rounding.Down);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundStart() internal override {\n        uint256 supply = totalSupply();\n\n        lastRoundAssets = totalAssets();\n        lastSharePrice = Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n        uint256 currentSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n        emit StartRoundData(vaultState.currentRoundId, lastRoundAssets, currentSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundEnd() internal override {\n        uint256 roundAccruedInterest = 0;\n        uint256 endSharePrice = 0;\n        uint256 investmentYield = IERC20Metadata(asset()).balanceOf(investor);\n        uint256 supply = totalSupply();\n\n        if (supply != 0) {\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\n            uint256 investmentAmount = (roundAccruedInterest * INVESTOR_RATIO) / DENOMINATOR;\n\n            // Pulls the yields from investor\n            if (investmentYield > 0) {\n                IERC20Metadata(asset()).safeTransferFrom(investor, address(this), investmentYield);\n            }\n\n            if (investmentAmount > 0) {\n                IERC20Metadata(asset()).safeTransfer(investor, investmentAmount);\n            }\n\n            // End Share price needs to be calculated after the transfers between investor and vault\n            endSharePrice = (totalAssets()).mulDiv(10**sharePriceDecimals, supply, Math.Rounding.Down);\n        }\n\n        uint256 startSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n\n        emit EndRoundData(vaultState.currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n        emit SharePrice(vaultState.currentRoundId, startSharePrice, endSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        assets = _stETHTransferFrom(caller, address(this), assets);\n        shares = previewDeposit(assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        lastRoundAssets -= shares.mulDiv(lastSharePrice.numerator, lastSharePrice.denominator, Math.Rounding.Down);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        receiverAssets = _stETHTransferFrom(address(this), receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _stETHTransferFrom(address(this), controller(), fee);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` of stETH from `from` to `to` using the\n     * allowance mechanism.\n     *\n     * Note that due to division rounding, not always is not possible to move\n     * the entire amount, hence transfer is attempted, returning the\n     * `effectiveAmount` transferred.\n     *\n     * For more information refer to: https://docs.lido.fi/guides/steth-integration-guide#1-wei-corner-case\n     */\n    function _stETHTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = IERC20Metadata(asset()).balanceOf(to);\n        if (from == address(this)) {\n            IERC20Metadata(asset()).safeTransfer(to, amount);\n        } else {\n            IERC20Metadata(asset()).safeTransferFrom(from, to, amount);\n        }\n        return IERC20Metadata(asset()).balanceOf(to) - balanceBefore;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/STETHVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { BaseVault } from \"./BaseVault.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\n\n/**\n * @title STETHVault\n * @notice A Vault that use variable weekly yields to buy strangles\n * @author Pods Finance\n */\ncontract STETHVault is BaseVault {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n\n    /**\n     * @dev INVESTOR_RATIO is the proportion that the weekly yield will be split\n     * The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n     */\n    uint256 public constant INVESTOR_RATIO = 5000;\n    address public immutable investor;\n    uint8 public immutable sharePriceDecimals;\n    uint256 public lastRoundAssets;\n    Fractional public lastSharePrice;\n\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n    event EndRoundData(\n        uint256 indexed roundId,\n        uint256 roundAccruedInterest,\n        uint256 investmentYield,\n        uint256 idleAssets\n    );\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n    constructor(\n        IConfigurationManager _configuration,\n        IERC20Metadata _asset,\n        address _investor\n    )\n        BaseVault(\n            _configuration,\n            _asset,\n            string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\")),\n            string(abi.encodePacked(_asset.symbol(), \"vv\"))\n        )\n    {\n        investor = _investor;\n        sharePriceDecimals = _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view override(ERC4626, IERC4626) returns (uint256) {\n        return IERC20Metadata(asset()).balanceOf(address(this)) - totalIdleAssets();\n    }\n\n    /**\n     * @notice Return the stETH price per share\n     * @dev Each share is considered to be 10^(assets.decimals())\n     */\n    function sharePrice() external view returns (uint256) {\n        return totalAssets().mulDiv(10**sharePriceDecimals, totalSupply(), Math.Rounding.Down);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundStart() internal override {\n        uint256 supply = totalSupply();\n\n        lastRoundAssets = totalAssets();\n        lastSharePrice = Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n        uint256 currentSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n        emit StartRoundData(vaultState.currentRoundId, lastRoundAssets, currentSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundEnd() internal override {\n        uint256 roundAccruedInterest = 0;\n        uint256 endSharePrice = 0;\n        uint256 investmentYield = IERC20Metadata(asset()).balanceOf(investor);\n        uint256 supply = totalSupply();\n\n        if (supply != 0) {\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\n            uint256 investmentAmount = (roundAccruedInterest * INVESTOR_RATIO) / DENOMINATOR;\n\n            // Pulls the yields from investor\n            if (investmentYield > 0) {\n                IERC20Metadata(asset()).safeTransferFrom(investor, address(this), investmentYield);\n            }\n\n            if (investmentAmount > 0) {\n                IERC20Metadata(asset()).safeTransfer(investor, investmentAmount);\n            }\n\n            // End Share price needs to be calculated after the transfers between investor and vault\n            endSharePrice = (totalAssets()).mulDiv(10**sharePriceDecimals, supply, Math.Rounding.Down);\n        }\n\n        uint256 startSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n\n        emit EndRoundData(vaultState.currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n        emit SharePrice(vaultState.currentRoundId, startSharePrice, endSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        assets = _stETHTransferFrom(caller, address(this), assets);\n        shares = previewDeposit(assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        lastRoundAssets -= shares.mulDiv(lastSharePrice.numerator, lastSharePrice.denominator, Math.Rounding.Down);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        receiverAssets = _stETHTransferFrom(address(this), receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _stETHTransferFrom(address(this), controller(), fee);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` of stETH from `from` to `to` using the\n     * allowance mechanism.\n     *\n     * Note that due to division rounding, not always is not possible to move\n     * the entire amount, hence transfer is attempted, returning the\n     * `effectiveAmount` transferred.\n     *\n     * For more information refer to: https://docs.lido.fi/guides/steth-integration-guide#1-wei-corner-case\n     */\n    function _stETHTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = IERC20Metadata(asset()).balanceOf(to);\n        if (from == address(this)) {\n            IERC20Metadata(asset()).safeTransfer(to, amount);\n        } else {\n            IERC20Metadata(asset()).safeTransferFrom(from, to, amount);\n        }\n        return IERC20Metadata(asset()).balanceOf(to) - balanceBefore;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/STETHVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { BaseVault } from \"./BaseVault.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\n\n/**\n * @title STETHVault\n * @notice A Vault that use variable weekly yields to buy strangles\n * @author Pods Finance\n */\ncontract STETHVault is BaseVault {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n\n    /**\n     * @dev INVESTOR_RATIO is the proportion that the weekly yield will be split\n     * The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n     */\n    uint256 public constant INVESTOR_RATIO = 5000;\n    address public immutable investor;\n    uint8 public immutable sharePriceDecimals;\n    uint256 public lastRoundAssets;\n    Fractional public lastSharePrice;\n\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n    event EndRoundData(\n        uint256 indexed roundId,\n        uint256 roundAccruedInterest,\n        uint256 investmentYield,\n        uint256 idleAssets\n    );\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n    constructor(\n        IConfigurationManager _configuration,\n        IERC20Metadata _asset,\n        address _investor\n    )\n        BaseVault(\n            _configuration,\n            _asset,\n            string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\")),\n            string(abi.encodePacked(_asset.symbol(), \"vv\"))\n        )\n    {\n        investor = _investor;\n        sharePriceDecimals = _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view override(ERC4626, IERC4626) returns (uint256) {\n        return IERC20Metadata(asset()).balanceOf(address(this)) - totalIdleAssets();\n    }\n\n    /**\n     * @notice Return the stETH price per share\n     * @dev Each share is considered to be 10^(assets.decimals())\n     */\n    function sharePrice() external view returns (uint256) {\n        return totalAssets().mulDiv(10**sharePriceDecimals, totalSupply(), Math.Rounding.Down);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundStart() internal override {\n        uint256 supply = totalSupply();\n\n        lastRoundAssets = totalAssets();\n        lastSharePrice = Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n        uint256 currentSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n        emit StartRoundData(vaultState.currentRoundId, lastRoundAssets, currentSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundEnd() internal override {\n        uint256 roundAccruedInterest = 0;\n        uint256 endSharePrice = 0;\n        uint256 investmentYield = IERC20Metadata(asset()).balanceOf(investor);\n        uint256 supply = totalSupply();\n\n        if (supply != 0) {\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\n            uint256 investmentAmount = (roundAccruedInterest * INVESTOR_RATIO) / DENOMINATOR;\n\n            // Pulls the yields from investor\n            if (investmentYield > 0) {\n                IERC20Metadata(asset()).safeTransferFrom(investor, address(this), investmentYield);\n            }\n\n            if (investmentAmount > 0) {\n                IERC20Metadata(asset()).safeTransfer(investor, investmentAmount);\n            }\n\n            // End Share price needs to be calculated after the transfers between investor and vault\n            endSharePrice = (totalAssets()).mulDiv(10**sharePriceDecimals, supply, Math.Rounding.Down);\n        }\n\n        uint256 startSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n\n        emit EndRoundData(vaultState.currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n        emit SharePrice(vaultState.currentRoundId, startSharePrice, endSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        assets = _stETHTransferFrom(caller, address(this), assets);\n        shares = previewDeposit(assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        lastRoundAssets -= shares.mulDiv(lastSharePrice.numerator, lastSharePrice.denominator, Math.Rounding.Down);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        receiverAssets = _stETHTransferFrom(address(this), receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _stETHTransferFrom(address(this), controller(), fee);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` of stETH from `from` to `to` using the\n     * allowance mechanism.\n     *\n     * Note that due to division rounding, not always is not possible to move\n     * the entire amount, hence transfer is attempted, returning the\n     * `effectiveAmount` transferred.\n     *\n     * For more information refer to: https://docs.lido.fi/guides/steth-integration-guide#1-wei-corner-case\n     */\n    function _stETHTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = IERC20Metadata(asset()).balanceOf(to);\n        if (from == address(this)) {\n            IERC20Metadata(asset()).safeTransfer(to, amount);\n        } else {\n            IERC20Metadata(asset()).safeTransferFrom(from, to, amount);\n        }\n        return IERC20Metadata(asset()).balanceOf(to) - balanceBefore;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/STETHVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { BaseVault } from \"./BaseVault.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\n\n/**\n * @title STETHVault\n * @notice A Vault that use variable weekly yields to buy strangles\n * @author Pods Finance\n */\ncontract STETHVault is BaseVault {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n\n    /**\n     * @dev INVESTOR_RATIO is the proportion that the weekly yield will be split\n     * The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n     */\n    uint256 public constant INVESTOR_RATIO = 5000;\n    address public immutable investor;\n    uint8 public immutable sharePriceDecimals;\n    uint256 public lastRoundAssets;\n    Fractional public lastSharePrice;\n\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n    event EndRoundData(\n        uint256 indexed roundId,\n        uint256 roundAccruedInterest,\n        uint256 investmentYield,\n        uint256 idleAssets\n    );\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n    constructor(\n        IConfigurationManager _configuration,\n        IERC20Metadata _asset,\n        address _investor\n    )\n        BaseVault(\n            _configuration,\n            _asset,\n            string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\")),\n            string(abi.encodePacked(_asset.symbol(), \"vv\"))\n        )\n    {\n        investor = _investor;\n        sharePriceDecimals = _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view override(ERC4626, IERC4626) returns (uint256) {\n        return IERC20Metadata(asset()).balanceOf(address(this)) - totalIdleAssets();\n    }\n\n    /**\n     * @notice Return the stETH price per share\n     * @dev Each share is considered to be 10^(assets.decimals())\n     */\n    function sharePrice() external view returns (uint256) {\n        return totalAssets().mulDiv(10**sharePriceDecimals, totalSupply(), Math.Rounding.Down);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundStart() internal override {\n        uint256 supply = totalSupply();\n\n        lastRoundAssets = totalAssets();\n        lastSharePrice = Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n        uint256 currentSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n        emit StartRoundData(vaultState.currentRoundId, lastRoundAssets, currentSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundEnd() internal override {\n        uint256 roundAccruedInterest = 0;\n        uint256 endSharePrice = 0;\n        uint256 investmentYield = IERC20Metadata(asset()).balanceOf(investor);\n        uint256 supply = totalSupply();\n\n        if (supply != 0) {\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\n            uint256 investmentAmount = (roundAccruedInterest * INVESTOR_RATIO) / DENOMINATOR;\n\n            // Pulls the yields from investor\n            if (investmentYield > 0) {\n                IERC20Metadata(asset()).safeTransferFrom(investor, address(this), investmentYield);\n            }\n\n            if (investmentAmount > 0) {\n                IERC20Metadata(asset()).safeTransfer(investor, investmentAmount);\n            }\n\n            // End Share price needs to be calculated after the transfers between investor and vault\n            endSharePrice = (totalAssets()).mulDiv(10**sharePriceDecimals, supply, Math.Rounding.Down);\n        }\n\n        uint256 startSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n\n        emit EndRoundData(vaultState.currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n        emit SharePrice(vaultState.currentRoundId, startSharePrice, endSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        assets = _stETHTransferFrom(caller, address(this), assets);\n        shares = previewDeposit(assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        lastRoundAssets -= shares.mulDiv(lastSharePrice.numerator, lastSharePrice.denominator, Math.Rounding.Down);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        receiverAssets = _stETHTransferFrom(address(this), receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _stETHTransferFrom(address(this), controller(), fee);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` of stETH from `from` to `to` using the\n     * allowance mechanism.\n     *\n     * Note that due to division rounding, not always is not possible to move\n     * the entire amount, hence transfer is attempted, returning the\n     * `effectiveAmount` transferred.\n     *\n     * For more information refer to: https://docs.lido.fi/guides/steth-integration-guide#1-wei-corner-case\n     */\n    function _stETHTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = IERC20Metadata(asset()).balanceOf(to);\n        if (from == address(this)) {\n            IERC20Metadata(asset()).safeTransfer(to, amount);\n        } else {\n            IERC20Metadata(asset()).safeTransferFrom(from, to, amount);\n        }\n        return IERC20Metadata(asset()).balanceOf(to) - balanceBefore;\n    }\n}"
    },
    {
      "filename": "contracts/token/ERC20/extensions/ERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../../../interfaces/IERC4626.sol\";\nimport \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * CAUTION: Deposits and withdrawals may incur unexpected slippage. Users should verify that the amount received of\n * shares or assets is as expected. EOAs should operate through a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * _Available since v4.7._\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20Metadata private immutable _asset;\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    constructor(IERC20Metadata asset_) {\n        _asset = asset_;\n    }\n\n    /** @dev See {IERC4262-asset}. */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4262-totalAssets}. */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4262-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-maxDeposit}. */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return _isVaultCollateralized() ? type(uint256).max : 0;\n    }\n\n    /** @dev See {IERC4262-maxMint}. */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4262-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-previewMint}. */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4262-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4262-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-mint}. */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4262-withdraw}. */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-redeem}. */"
    }
  ]
}