{
  "Title": "M-10: mTOFTReceiver MSG_XCHAIN_LEND_XCHAIN_LOCK unable to execute",
  "Content": "# Issue M-10: mTOFTReceiver MSG_XCHAIN_LEND_XCHAIN_LOCK unable to execute \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/63 \n\n## Found by \n0xadrii, bin2chen\n## Summary\nIn `mTOFTReceiver._toftCustomComposeReceiver(uint16 _msgType)`\nIf `_msgType` is processed normally, the method must return `true`, if it returns `false`, it will trigger `revert InvalidMsgType()`\nBut when `_msgType == MSG_XCHAIN_LEND_XCHAIN_LOCK` is executed normally, it does not correctly return true\nThis causes this type of execution to always fail\n## Vulnerability Detail\nThe main execution order of `_lzCompose()` is as follows:\n1. If msgType_ == MSG_REMOTE_TRANSFER, execute `_remoteTransferReceiver()`\n2. Otherwise, execute `_extExec(msgType_, tapComposeMsg_)`\n3. Otherwise, execute `tapiocaOmnichainReceiveExtender`\n4. Otherwise, execute `_toeComposeReceiver()`\n5. If the 4th step `_toeComposeReceiver()` returns false, it is considered that the type cannot be found, and `revert InvalidMsgType(msgType_);` is triggered\n\nthe code as follows：\n```solidity\n    function _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n        // Decode OFT compose message.\n        (uint16 msgType_,,, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n        // Call Permits/approvals if the msg type is a permit/approval.\n        // If the msg type is not a permit/approval, it will call the other receivers.\n        if (msgType_ == MSG_REMOTE_TRANSFER) {\n            _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);\n        } else if (!_extExec(msgType_, tapComposeMsg_)) {\n            // Check if the TOE extender is set and the msg type is valid. If so, call the TOE extender to handle msg.\n            if (\n                address(tapiocaOmnichainReceiveExtender) != address(0)\n                    && tapiocaOmnichainReceiveExtender.isMsgTypeValid(msgType_)\n            ) {\n                bytes memory callData = abi.encodeWithSelector(\n                    ITapiocaOmnichainReceiveExtender.toeComposeReceiver.selector,\n                    msgType_,\n                    srcChainSender_,\n                    tapComposeMsg_\n                );\n                (bool success, bytes memory returnData) =\n                    address(tapiocaOmnichainReceiveExtender).delegatecall(callData);\n                if (!success) {\n                    revert(_getTOEExtenderRevertMsg(returnData));\n                }\n            } else {\n                // If no TOE extender is set or msg type doesn't match extender, try to call the internal receiver.\n                if (!_toeComposeReceiver(msgType_, srcChainSender_, tapComposeMsg_)) {\n@>                  revert InvalidMsgType(msgType_);\n                }\n            }\n        }\n```\n\nThe implementation of `mTOFTReceiver._toeComposeReceiver()` is as follows:\n\n```solidity\ncontract mTOFTReceiver is BaseTOFTReceiver {\n    constructor(TOFTInitStruct memory _data) BaseTOFTReceiver(_data) {}\n\n    function _toftCustomComposeReceiver(uint16 _msgType, address, bytes memory _toeComposeMsg)\n        internal\n        override\n        returns (bool success)\n    {\n        if (_msgType == MSG_LEVERAGE_UP) { //@check\n            _executeModule(\n                uint8(ITOFT.Module.TOFTMarketReceiver),\n                abi.encodeWithSelector(TOFTMarketReceiverModule.leverageUpReceiver.selector, _toeComposeMsg),\n                false\n            );\n            return true;\n        } else if (_msgType == MSG_XCHAIN_LEND_XCHAIN_LOCK) { //@check\n            _executeModule(\n                uint8(ITOFT.Module.TOFTOptionsReceiver),\n                abi.encodeWithSelector(\n                    TOFTOptionsReceiverModule.mintLendXChainSGLXChainLockAndParticipateReceiver.selector, _toeComposeMsg\n                ),\n                false\n            );\n@>      //@audit miss return true\n        } else {\n            return false;\n        }\n    }\n}\n```\n\nAs mentioned above, because `_msgType == MSG_XCHAIN_LEND_XCHAIN_LOCK` does not return `true`, it always triggers `revert InvalidMsgType(msgType_);`\n\n\n## Impact\n`_msgType == MSG_XCHAIN_LEND_XCHAIN_LOCK`\n`TOFTOptionsReceiver.mintLendXChainSGLXChainLockAndParticipateReceiver()` unable to execute successfully\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/mTOFTReceiver.sol#L36-L43\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\ncontract mTOFTReceiver is BaseTOFTReceiver {\n    constructor(TOFTInitStruct memory _data) BaseTOFTReceiver(_data) {}\n\n    function _toftCustomComposeReceiver(uint16 _msgType, address, bytes memory _toeComposeMsg)\n        internal\n        override\n        returns (bool success)\n    {\n        if (_msgType == MSG_LEVERAGE_UP) { //@check\n            _executeModule(\n                uint8(ITOFT.Module.TOFTMarketReceiver),\n                abi.encodeWithSelector(TOFTMarketReceiverModule.leverageUpReceiver.selector, _toeComposeMsg),\n                false\n            );\n            return true;\n        } else if (_msgType == MSG_XCHAIN_LEND_XCHAIN_LOCK) { //@check\n            _executeModule(\n                uint8(ITOFT.Module.TOFTOptionsReceiver),\n                abi.encodeWithSelector(\n                    TOFTOptionsReceiverModule.mintLendXChainSGLXChainLockAndParticipateReceiver.selector, _toeComposeMsg\n                ),\n                false\n            );\n+           return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/173.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/mTOFTReceiver.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// Tapioca\nimport {TOFTInitStruct, LeverageUpActionMsg, ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {TOFTOptionsReceiverModule} from \"./TOFTOptionsReceiverModule.sol\";\nimport {TOFTMarketReceiverModule} from \"./TOFTMarketReceiverModule.sol\";\nimport {BaseTOFTReceiver} from \"./BaseTOFTReceiver.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract mTOFTReceiver is BaseTOFTReceiver {\n    constructor(TOFTInitStruct memory _data) BaseTOFTReceiver(_data) {}\n\n    function _toftCustomComposeReceiver(uint16 _msgType, address, bytes memory _toeComposeMsg)\n        internal\n        override\n        returns (bool success)\n    {\n        if (_msgType == MSG_LEVERAGE_UP) {\n            _executeModule(\n                uint8(ITOFT.Module.TOFTMarketReceiver),\n                abi.encodeWithSelector(TOFTMarketReceiverModule.leverageUpReceiver.selector, _toeComposeMsg),\n                false\n            );\n            return true;\n        } else if (_msgType == MSG_XCHAIN_LEND_XCHAIN_LOCK) {\n            _executeModule(\n                uint8(ITOFT.Module.TOFTOptionsReceiver),\n                abi.encodeWithSelector(\n                    TOFTOptionsReceiverModule.mintLendXChainSGLXChainLockAndParticipateReceiver.selector, _toeComposeMsg\n                ),\n                false\n            );\n        } else {\n            return false;\n        }\n    }\n}"
    }
  ]
}