{
  "Title": "H-4: CVX/AURA distribution calculation is incorrect and will lead to loss of rewards at the end of each cliff",
  "Content": "# Issue H-4: CVX/AURA distribution calculation is incorrect and will lead to loss of rewards at the end of each cliff \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/109 \n\n## Found by \n0x52\n\nWhen calculating the amount of pending AURA owed to a user _getAuraPendingReward uses the current values for supply. This leads to incorrect calculation across cliffs which leads to loss of rewards for users.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L233-L248](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L233-L248)\n\n        if (cliff < totalCliffs) {\n            /// e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;\n            /// e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;\n            /// e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;\n            uint256 reduction = ((totalCliffs - cliff) * 5) / 2 + 700;\n            /// e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;\n            /// e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;\n            /// e.g. (new) amount = 1e19 * 950 / 500  =  19e17;\n            mintAmount = (mintRequestAmount * reduction) / totalCliffs;\n\n            /// e.g. amtTillMax = 5e25 - 1e25 = 4e25\n            uint256 amtTillMax = emissionMaxSupply - emissionsMinted;\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n\nThe above code is used to calculate the amount of AURA owed to the user. This calculation is perfectly accurate if the AURA hasn't been minted yet. The problem is that each time a user withdraws, AURA is claimed for ALL vault participants. This means that the rewards will be realized for a majority of users before they themselves withdraw. Since the emissions decrease with each cliff, there will be loss of funds at the end of each cliff.\n\nExample:\nAssume for simplicity there are only 2 cliffs. User A deposits LP to WAuraPools. After some time User B deposits as well. Before the end of the first cliff User A withdraw. This claims all tokens owed to both users A and B which is now sitting in the contract. Assume both users are owed 10 tokens. Now User B waits for the second cliff to end before withdrawing. When calculating his rewards it will give him no rewards since all cliffs have ended. The issue is that the 10 tokens they are owed is already sitting in the contract waiting to be claimed.\n\n## Impact\n\nAll users will lose rewards at the end of each cliff due to miscalculation\n\n## Code Snippet\n\n[WAuraPools.sol#L209-L249](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L209-L249)\n\n[WConvexPools.sol#L149-L172](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L149-L172)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI would recommend a hybrid approach. When rewards are claimed upon withdrawal, the reward per token should be cached to prevent loss of tokens that have already been received by the contract. Only unminted AURA should be handled this way.\n\n\n\n## Discussion\n\n**IAm0x52**\n\nEscalate\n\nThis was wrongly excluded and causes a significant problem. Whenever a position is burned it calls the following line:\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WAuraPools.sol#L379\n\n        IAuraRewarder(auraRewarder).withdraw(amount, true);\n\nWhich withdraws the LP and claims rewards because of the `true` input. Digging into the rewarder contract:\n\nhttps://etherscan.io/address/0x1204f5060be8b716f5a62b4df4ce32acd01a69f5#code#F18#L229\n\n    function withdraw(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(amount > 0, 'RewardPool : Cannot withdraw 0');\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n     \n        if(claim){\n            getReward(msg.sender,true);\n        }\n\n        emit Transfer(msg.sender, address(0), amount);\n\n        return true;\n    }\n\nHere we see that if claim == true then we call `getReward`\n\nhttps://etherscan.io/address/0x1204f5060be8b716f5a62b4df4ce32acd01a69f5#code#F18#L296\n\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\nHere we see that the ENTIRE reward balance is claimed for the vault. This presents the problem as outlined in my issue above. Let's assume that the reward for the current round is 1:1 (i.e. that each claimed BAL gives 1 AURA). Assume we have 2 users, each with half the pool. Now 100 tokens are claimed in this round, which means each user is owed 50 AURA. After some amount of rounds, the reward is now 1:0.5 (i.e. that each claimed BAL gives 1 AURA). Now when user A withdraws instead of being paid 100 AURA for that round they will instead only be paid 50 AURA and they will lose the other 50 since it won't be claimable. This is because it always uses the most recent exchange rate instead of the rate at which it was claimed.\n\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This was wrongly excluded and causes a significant problem. Whenever a position is burned it calls the following line:\n> \n> https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WAuraPools.sol#L379\n> \n>         IAuraRewarder(auraRewarder).withdraw(amount, true);\n> \n> Which withdraws the LP and claims rewards because of the `true` input. Digging into the rewarder contract:\n> \n> https://etherscan.io/address/0x1204f5060be8b716f5a62b4df4ce32acd01a69f5#code#F18#L229\n> \n>     function withdraw(uint256 amount, bool claim)\n>         public\n>         updateReward(msg.sender)\n>         returns(bool)\n>     {\n>         require(amount > 0, 'RewardPool : Cannot withdraw 0');\n> \n>         //also withdraw from linked rewards\n>         for(uint i=0; i < extraRewards.length; i++){\n>             IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n>         }\n> \n>         _totalSupply = _totalSupply.sub(amount);\n>         _balances[msg.sender] = _balances[msg.sender].sub(amount);\n> \n>         stakingToken.safeTransfer(msg.sender, amount);\n>         emit Withdrawn(msg.sender, amount);\n>      \n>         if(claim){\n>             getReward(msg.sender,true);\n>         }\n> \n>         emit Transfer(msg.sender, address(0), amount);\n> \n>         return true;\n>     }\n> \n> Here we see that if claim == true then we call `getReward`\n> \n> https://etherscan.io/address/0x1204f5060be8b716f5a62b4df4ce32acd01a69f5#code#F18#L296\n> \n>     function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n>         uint256 reward = earned(_account);\n>         if (reward > 0) {\n>             rewards[_account] = 0;\n>             rewardToken.safeTransfer(_account, reward);\n>             IDeposit(operator).rewardClaimed(pid, _account, reward);\n>             emit RewardPaid(_account, reward);\n>         }\n> \n>         //also get rewards from linked rewards\n>         if(_claimExtras){\n>             for(uint i=0; i < extraRewards.length; i++){\n>                 IRewards(extraRewards[i]).getReward(_account);\n>             }\n>         }\n>         return true;\n>     }\n> \n> Here we see that the ENTIRE reward balance is claimed for the vault. This presents the problem as outlined in my issue above. Let's assume that the reward for the current round is 1:1 (i.e. that each claimed BAL gives 1 AURA). Assume we have 2 users, each with half the pool. Now 100 tokens are claimed in this round, which means each user is owed 50 AURA. After some amount of rounds, the reward is now 1:0.5 (i.e. that each claimed BAL gives 1 AURA). Now when user A withdraws instead of being paid 100 AURA for that round they will instead only be paid 50 AURA and they will lose the other 50 since it won't be claimable. This is because it always uses the most recent exchange rate instead of the rate at which it was claimed.\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n@Gornutz What do you think about it? \nI think it is a valid Medium.\n\n**Gornutz**\n\nSeems directionally correct and valid from the parts of the POC provided. \n\n**IAm0x52**\n\nThe current AURA APR for pools are high double digit to triple digit returns. Additionally AURA is distributed over [~8 years](https://docs.aura.finance/aura/usdaura/distribution) and there are [500 cliffs](https://etherscan.io/address/0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF#code#F1#L25) over that period. This makes the average cliff ~6 days. Unless every single user withdraws and redeposits each 6 day period (which is prohibitively expensive due to gas costs) this loss cannot be avoided. Given the almost certainty of the loss and the substantial amount these users stand to lose due to the high APRs and leveraged nature of the system, I believe this should be high risk rather than medium.\n\n**hrishibhat**\n\nResult:\nHigh\nUnique \nAfter further review considering this to be a high based on the comments above \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/109/#issuecomment-1694743790): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/wrapper/WAuraPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/aura/IAuraRewarder.sol\";\nimport \"../interfaces/aura/IAuraExtraRewarder.sol\";\nimport \"../interfaces/aura/IAura.sol\";\n\n/**\n * @title WAuraPools\n * @author BlueberryProtocol\n * @notice Wrapped Aura Pools is the wrapper of LP positions\n * @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank\n *      and do not generate yields. LP Tokens are identified by tokenIds\n *      encoded from lp token address.\n */\ncontract WAuraPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWAuraPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Aura Pools contract\n    IAuraPools public auraPools;\n    /// @dev Address to AURA token\n    IAura public AURA;\n    /// @dev Address to STASH_AURA token\n    address public STASH_AURA;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => mapping(address => uint256)) public accExtPerShare;\n    /// @dev Aura extra rewards addresses\n    address[] public extraRewards;\n    /// @dev The index of extra rewards\n    mapping(address => uint256) public extraRewardsIdx;\n\n    uint public REWARD_MULTIPLIER_DENOMINATOR;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes contract with dependencies\n    /// @param aura_ The AURA token address\n    /// @param auraPools_ The auraPools contract address\n    /// @param stash_aura_ The stash for AURA\n    function initialize(\n        address aura_,\n        address auraPools_,\n        address stash_aura_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WAuraPools\");\n        AURA = IAura(aura_);\n        STASH_AURA = stash_aura_;\n        auraPools = IAuraPools(auraPools_);\n        REWARD_MULTIPLIER_DENOMINATOR = auraPools\n            .REWARD_MULTIPLIER_DENOMINATOR();\n    }\n\n    /// @notice Encodes pool id and AURA per share into an ERC1155 token id\n    /// @param pid The pool id (The first 16-bits)\n    /// @param auraPerShare Amount of AURA per share, multiplied by 1e18 (The last 240-bits)\n    /// @return id The resulting ERC1155 token id\n\n    function encodeId(\n        uint256 pid,\n        uint256 auraPerShare\n    ) public pure returns (uint256 id) {\n        // Ensure the pool id and auraPerShare are within expected bounds\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (auraPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(auraPerShare);\n        return (pid << 240) | auraPerShare;\n    }\n\n    /// @notice Decodes ERC1155 token id to pool id and AURA per share\n    /// @param id The ERC1155 token id\n    /// @return gid The decoded pool id\n    /// @return auraPerShare The decoded amount of AURA per share\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 auraPerShare) {\n        gid = id >> 240; // Extracting the first 16 bits\n        auraPerShare = id & ((1 << 240) - 1); // Extracting the last 240 bits\n    }\n\n    /// @notice Retrieves the underlying ERC20 token of the specified ERC1155 token id\n    /// @param id The ERC1155 token id\n    /// @return uToken Address of the underlying ERC20 token\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    /// @notice Gets the Balancer vault for a given BPT token\n    /// @param bpt Address of the BPT token\n    /// @return Vault associated with the provided BPT token\n    function getVault(address bpt) public view returns (IBalancerVault) {\n        return IBalancerVault(IBalancerPool(bpt).getVault());\n    }\n\n    /// @notice Retrieves pool tokens from a given BPT address\n    /// @param bpt Address of the BPT token\n    /// @return tokens Array of token addresses in the pool\n    /// @return balances Corresponding balances of the tokens in the pool\n    /// @return lastChangedBlock The last block when the pool composition changed\n    function getPoolTokens(\n        address bpt\n    )\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangedBlock\n        )\n    {\n        return getVault(bpt).getPoolTokens(IBalancerPool(bpt).getPoolId());\n    }\n\n    /// @notice Retrieves pool id from a BPT token\n    /// @param bpt Address of the BPT token\n    /// @return Pool id associated with the BPT token\n    function getBPTPoolId(address bpt) public view returns (bytes32) {\n        return IBalancerPool(bpt).getPoolId();\n    }\n\n    /// @notice Fetches pool information using a provided aura finance pool id\n    /// @param pid The aura finance pool id\n    /// @return lptoken Address of the LP token\n    /// @return token Address of the associated token\n    /// @return gauge Address of the gauge\n    /// @return auraRewards Address for AURA rewards\n    /// @return stash Address of the stash\n    /// @return shutdown Boolean indicating if the pool is shut down\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address auraRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return auraPools.poolInfo(pid);\n    }\n\n    /// @notice Calculate the amount of pending reward for a given LP amount.\n    /// @param stRewardPerShare The stored reward per share value.\n    /// @param rewarder The address of the rewarder contract.\n    /// @param amount The amount of LP for which reward is being calculated.\n    /// @param lpDecimals The number of decimals of the LP token.\n    /// @return rewards The calculated reward amount.\n    function _getPendingReward(\n        uint256 stRewardPerShare,\n        address rewarder,\n        uint256 amount,\n        uint256 lpDecimals\n    ) internal view returns (uint256 rewards) {\n        /// Retrieve current reward per token from rewarder\n        uint256 enRewardPerShare = IAuraRewarder(rewarder).rewardPerToken();\n        /// Calculatethe difference in reward per share\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        /// Calculate the total rewards base on share and amount.\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// @notice  Calculate the pending AURA reward amount.\n    /// @dev AuraMinter can mint additional tokens after `inflationProtectionTime` has passed\n    /// And its value is `1749120350`  ==> Thursday 5 June 2025 12:32:30 PM GMT+07:00\n    /// @param auraRewarder Address of Aura rewarder contract\n    /// @param balAmount The amount of BAL reward for AURA calculation.\n    /// @dev AURA token is minted in booster contract following the mint logic in the below\n    function _getAuraPendingReward(\n        address auraRewarder,\n        uint256 balAmount\n    ) internal view returns (uint256 mintAmount) {\n        /// AURA mint request amount = amount * reward_multiplier / reward_multiplier_denominator\n        uint256 mintRequestAmount = (balAmount *\n            auraPools.getRewardMultipliers(auraRewarder)) /\n            REWARD_MULTIPLIER_DENOMINATOR;\n\n        /// AURA token mint logic\n        /// e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;\n        uint256 totalSupply = AURA.totalSupply();\n        uint256 initAmount = AURA.INIT_MINT_AMOUNT();\n        uint256 minterMinted;\n        uint256 reductionPerCliff = AURA.reductionPerCliff();\n        uint256 totalCliffs = AURA.totalCliffs();\n        uint256 emissionMaxSupply = AURA.EMISSIONS_MAX_SUPPLY();\n\n        uint256 emissionsMinted = totalSupply - initAmount - minterMinted;\n        /// e.g. reductionPerCliff = 5e25 / 500 = 1e23\n        /// e.g. cliff = 1e25 / 1e23 = 100\n        uint256 cliff = emissionsMinted / reductionPerCliff;\n\n        /// e.g. 100 < 500\n        if (cliff < totalCliffs) {\n            /// e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;\n            /// e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;\n            /// e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;\n            uint256 reduction = ((totalCliffs - cliff) * 5) / 2 + 700;\n            /// e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;\n            /// e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;\n            /// e.g. (new) amount = 1e19 * 950 / 500  =  19e17;\n            mintAmount = (mintRequestAmount * reduction) / totalCliffs;\n\n            /// e.g. amtTillMax = 5e25 - 1e25 = 4e25\n            uint256 amtTillMax = emissionMaxSupply - emissionsMinted;\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n    }\n\n    /// @notice Retrieve pending rewards for a given tokenId and amount.\n    /// @dev The rewards can be split among multiple tokens.\n    /// @param tokenId The ID of the token.\n    /// @param amount The amount of the token.\n    /// @return tokens Array of token addresses.\n    /// @return rewards Array of corresponding reward amounts.\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stAuraPerShare) = decodeId(tokenId);\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint256 extraRewardsCount = extraRewards.length;\n        tokens = new address[](extraRewardsCount + 2);\n        rewards = new uint256[](extraRewardsCount + 2);\n\n        /// BAL reward\n        tokens[0] = IAuraRewarder(auraRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stAuraPerShare,\n            auraRewarder,\n            amount,\n            lpDecimals\n        );\n\n        /// AURA reward\n        tokens[1] = address(AURA);\n        rewards[1] = _getAuraPendingReward(auraRewarder, rewards[0]);\n\n        /// Additional rewards\n        for (uint256 i; i != extraRewardsCount; ) {\n            address rewarder = extraRewards[i];\n            uint256 stRewardPerShare = accExtPerShare[tokenId][rewarder];\n            tokens[i + 2] = IAuraRewarder(rewarder).rewardToken();\n            if (stRewardPerShare == 0) {\n                rewards[i + 2] = 0;\n            } else {\n                rewards[i + 2] = _getPendingReward(\n                    stRewardPerShare == type(uint).max ? 0 : stRewardPerShare,\n                    rewarder,\n                    amount,\n                    lpDecimals\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Mint an ERC1155 token corresponding to the provided LP token amount.\n    /// @param pid The ID of the AURA pool.\n    /// @param amount The amount of the LP token to be wrapped.\n    /// @return id The minted ERC1155 token's ID.\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(auraPools), amount);\n        auraPools.deposit(pid, amount, true);\n\n        /// BAL reward handle logic\n        uint256 balRewardPerToken = IAuraRewarder(auraRewarder)\n            .rewardPerToken();\n        id = encodeId(pid, balRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n\n        /// Store extra rewards info\n        uint256 extraRewardsCount = IAuraRewarder(auraRewarder)\n            .extraRewardsLength();\n        for (uint256 i; i != extraRewardsCount; ) {\n            address extraRewarder = IAuraRewarder(auraRewarder).extraRewards(i);\n            uint256 rewardPerToken = IAuraRewarder(extraRewarder)\n                .rewardPerToken();\n            accExtPerShare[id][extraRewarder] = rewardPerToken == 0\n                ? type(uint).max\n                : rewardPerToken;\n\n            _syncExtraReward(extraRewarder);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Burn the provided ERC1155 token and redeem its underlying ERC20 token.\n    /// @param id The ID of the ERC1155 token to burn.\n    /// @param amount The amount of the ERC1155 token to burn.\n    /// @return rewardTokens An array of reward tokens that the user is eligible to receive.\n    /// @return rewards The corresponding amounts of reward tokens.\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n\n        /// Claim Rewards\n        IAuraRewarder(auraRewarder).withdraw(amount, true);\n        /// Withdraw LP\n        auraPools.withdraw(pid, amount);\n\n        /// Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        uint256 extraRewardsCount = IAuraRewarder(auraRewarder)\n            .extraRewardsLength();\n\n        for (uint256 i; i != extraRewardsCount; ) {\n            _syncExtraReward(IAuraRewarder(auraRewarder).extraRewards(i));\n\n            unchecked {\n                ++i;\n            }\n        }\n        uint256 storedExtraRewardLength = extraRewards.length;\n        bool hasDiffExtraRewards = extraRewardsCount != storedExtraRewardLength;\n\n        /// Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        /// Withdraw manually\n        if (hasDiffExtraRewards) {\n            for (uint256 i; i != storedExtraRewardLength; ) {\n                IAuraExtraRewarder(extraRewards[i]).getReward();\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Get the full set of extra rewards.\n    /// @return An array containing the addresses of extra reward tokens.\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    /// @notice Internal function to sync any extra rewards with the contract.\n    /// @param extraReward The address of the extra reward token.\n    /// @dev Adds the extra reward to the internal list if not already present.\n    function _syncExtraReward(address extraReward) private {\n        if (extraRewardsIdx[extraReward] == 0) {\n            extraRewards.push(extraReward);\n            extraRewardsIdx[extraReward] = extraRewards.length;\n        }\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/wrapper/WAuraPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/aura/IAuraRewarder.sol\";\nimport \"../interfaces/aura/IAuraExtraRewarder.sol\";\nimport \"../interfaces/aura/IAura.sol\";\n\n/**\n * @title WAuraPools\n * @author BlueberryProtocol\n * @notice Wrapped Aura Pools is the wrapper of LP positions\n * @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank\n *      and do not generate yields. LP Tokens are identified by tokenIds\n *      encoded from lp token address.\n */\ncontract WAuraPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWAuraPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Aura Pools contract\n    IAuraPools public auraPools;\n    /// @dev Address to AURA token\n    IAura public AURA;\n    /// @dev Address to STASH_AURA token\n    address public STASH_AURA;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => mapping(address => uint256)) public accExtPerShare;\n    /// @dev Aura extra rewards addresses\n    address[] public extraRewards;\n    /// @dev The index of extra rewards\n    mapping(address => uint256) public extraRewardsIdx;\n\n    uint public REWARD_MULTIPLIER_DENOMINATOR;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes contract with dependencies\n    /// @param aura_ The AURA token address\n    /// @param auraPools_ The auraPools contract address\n    /// @param stash_aura_ The stash for AURA\n    function initialize(\n        address aura_,\n        address auraPools_,\n        address stash_aura_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WAuraPools\");\n        AURA = IAura(aura_);\n        STASH_AURA = stash_aura_;\n        auraPools = IAuraPools(auraPools_);\n        REWARD_MULTIPLIER_DENOMINATOR = auraPools\n            .REWARD_MULTIPLIER_DENOMINATOR();\n    }\n\n    /// @notice Encodes pool id and AURA per share into an ERC1155 token id\n    /// @param pid The pool id (The first 16-bits)\n    /// @param auraPerShare Amount of AURA per share, multiplied by 1e18 (The last 240-bits)\n    /// @return id The resulting ERC1155 token id\n\n    function encodeId(\n        uint256 pid,\n        uint256 auraPerShare\n    ) public pure returns (uint256 id) {\n        // Ensure the pool id and auraPerShare are within expected bounds\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (auraPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(auraPerShare);\n        return (pid << 240) | auraPerShare;\n    }\n\n    /// @notice Decodes ERC1155 token id to pool id and AURA per share\n    /// @param id The ERC1155 token id\n    /// @return gid The decoded pool id\n    /// @return auraPerShare The decoded amount of AURA per share\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 auraPerShare) {\n        gid = id >> 240; // Extracting the first 16 bits\n        auraPerShare = id & ((1 << 240) - 1); // Extracting the last 240 bits\n    }\n\n    /// @notice Retrieves the underlying ERC20 token of the specified ERC1155 token id\n    /// @param id The ERC1155 token id\n    /// @return uToken Address of the underlying ERC20 token\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    /// @notice Gets the Balancer vault for a given BPT token\n    /// @param bpt Address of the BPT token\n    /// @return Vault associated with the provided BPT token\n    function getVault(address bpt) public view returns (IBalancerVault) {\n        return IBalancerVault(IBalancerPool(bpt).getVault());\n    }\n\n    /// @notice Retrieves pool tokens from a given BPT address\n    /// @param bpt Address of the BPT token\n    /// @return tokens Array of token addresses in the pool\n    /// @return balances Corresponding balances of the tokens in the pool\n    /// @return lastChangedBlock The last block when the pool composition changed\n    function getPoolTokens(\n        address bpt\n    )\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangedBlock\n        )\n    {\n        return getVault(bpt).getPoolTokens(IBalancerPool(bpt).getPoolId());\n    }\n\n    /// @notice Retrieves pool id from a BPT token\n    /// @param bpt Address of the BPT token\n    /// @return Pool id associated with the BPT token\n    function getBPTPoolId(address bpt) public view returns (bytes32) {\n        return IBalancerPool(bpt).getPoolId();\n    }\n\n    /// @notice Fetches pool information using a provided aura finance pool id\n    /// @param pid The aura finance pool id\n    /// @return lptoken Address of the LP token\n    /// @return token Address of the associated token\n    /// @return gauge Address of the gauge\n    /// @return auraRewards Address for AURA rewards\n    /// @return stash Address of the stash\n    /// @return shutdown Boolean indicating if the pool is shut down\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address auraRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return auraPools.poolInfo(pid);\n    }\n\n    /// @notice Calculate the amount of pending reward for a given LP amount.\n    /// @param stRewardPerShare The stored reward per share value.\n    /// @param rewarder The address of the rewarder contract.\n    /// @param amount The amount of LP for which reward is being calculated.\n    /// @param lpDecimals The number of decimals of the LP token.\n    /// @return rewards The calculated reward amount.\n    function _getPendingReward(\n        uint256 stRewardPerShare,\n        address rewarder,\n        uint256 amount,\n        uint256 lpDecimals\n    ) internal view returns (uint256 rewards) {\n        /// Retrieve current reward per token from rewarder\n        uint256 enRewardPerShare = IAuraRewarder(rewarder).rewardPerToken();\n        /// Calculatethe difference in reward per share\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        /// Calculate the total rewards base on share and amount.\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// @notice  Calculate the pending AURA reward amount.\n    /// @dev AuraMinter can mint additional tokens after `inflationProtectionTime` has passed\n    /// And its value is `1749120350`  ==> Thursday 5 June 2025 12:32:30 PM GMT+07:00\n    /// @param auraRewarder Address of Aura rewarder contract\n    /// @param balAmount The amount of BAL reward for AURA calculation.\n    /// @dev AURA token is minted in booster contract following the mint logic in the below\n    function _getAuraPendingReward(\n        address auraRewarder,\n        uint256 balAmount\n    ) internal view returns (uint256 mintAmount) {\n        /// AURA mint request amount = amount * reward_multiplier / reward_multiplier_denominator\n        uint256 mintRequestAmount = (balAmount *\n            auraPools.getRewardMultipliers(auraRewarder)) /\n            REWARD_MULTIPLIER_DENOMINATOR;\n\n        /// AURA token mint logic\n        /// e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;\n        uint256 totalSupply = AURA.totalSupply();\n        uint256 initAmount = AURA.INIT_MINT_AMOUNT();\n        uint256 minterMinted;\n        uint256 reductionPerCliff = AURA.reductionPerCliff();\n        uint256 totalCliffs = AURA.totalCliffs();\n        uint256 emissionMaxSupply = AURA.EMISSIONS_MAX_SUPPLY();\n\n        uint256 emissionsMinted = totalSupply - initAmount - minterMinted;\n        /// e.g. reductionPerCliff = 5e25 / 500 = 1e23\n        /// e.g. cliff = 1e25 / 1e23 = 100\n        uint256 cliff = emissionsMinted / reductionPerCliff;\n\n        /// e.g. 100 < 500\n        if (cliff < totalCliffs) {\n            /// e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;\n            /// e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;\n            /// e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;\n            uint256 reduction = ((totalCliffs - cliff) * 5) / 2 + 700;\n            /// e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;\n            /// e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;\n            /// e.g. (new) amount = 1e19 * 950 / 500  =  19e17;\n            mintAmount = (mintRequestAmount * reduction) / totalCliffs;\n\n            /// e.g. amtTillMax = 5e25 - 1e25 = 4e25\n            uint256 amtTillMax = emissionMaxSupply - emissionsMinted;\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n    }\n\n    /// @notice Retrieve pending rewards for a given tokenId and amount.\n    /// @dev The rewards can be split among multiple tokens.\n    /// @param tokenId The ID of the token.\n    /// @param amount The amount of the token.\n    /// @return tokens Array of token addresses.\n    /// @return rewards Array of corresponding reward amounts.\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stAuraPerShare) = decodeId(tokenId);\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint256 extraRewardsCount = extraRewards.length;\n        tokens = new address[](extraRewardsCount + 2);\n        rewards = new uint256[](extraRewardsCount + 2);\n\n        /// BAL reward\n        tokens[0] = IAuraRewarder(auraRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stAuraPerShare,\n            auraRewarder,\n            amount,\n            lpDecimals\n        );\n\n        /// AURA reward\n        tokens[1] = address(AURA);\n        rewards[1] = _getAuraPendingReward(auraRewarder, rewards[0]);\n\n        /// Additional rewards\n        for (uint256 i; i != extraRewardsCount; ) {\n            address rewarder = extraRewards[i];\n            uint256 stRewardPerShare = accExtPerShare[tokenId][rewarder];\n            tokens[i + 2] = IAuraRewarder(rewarder).rewardToken();\n            if (stRewardPerShare == 0) {\n                rewards[i + 2] = 0;\n            } else {\n                rewards[i + 2] = _getPendingReward(\n                    stRewardPerShare == type(uint).max ? 0 : stRewardPerShare,\n                    rewarder,\n                    amount,\n                    lpDecimals\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Mint an ERC1155 token corresponding to the provided LP token amount.\n    /// @param pid The ID of the AURA pool.\n    /// @param amount The amount of the LP token to be wrapped.\n    /// @return id The minted ERC1155 token's ID.\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(auraPools), amount);\n        auraPools.deposit(pid, amount, true);\n\n        /// BAL reward handle logic\n        uint256 balRewardPerToken = IAuraRewarder(auraRewarder)\n            .rewardPerToken();\n        id = encodeId(pid, balRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n\n        /// Store extra rewards info\n        uint256 extraRewardsCount = IAuraRewarder(auraRewarder)\n            .extraRewardsLength();\n        for (uint256 i; i != extraRewardsCount; ) {\n            address extraRewarder = IAuraRewarder(auraRewarder).extraRewards(i);\n            uint256 rewardPerToken = IAuraRewarder(extraRewarder)\n                .rewardPerToken();\n            accExtPerShare[id][extraRewarder] = rewardPerToken == 0\n                ? type(uint).max\n                : rewardPerToken;\n\n            _syncExtraReward(extraRewarder);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Burn the provided ERC1155 token and redeem its underlying ERC20 token.\n    /// @param id The ID of the ERC1155 token to burn.\n    /// @param amount The amount of the ERC1155 token to burn.\n    /// @return rewardTokens An array of reward tokens that the user is eligible to receive.\n    /// @return rewards The corresponding amounts of reward tokens.\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n\n        /// Claim Rewards\n        IAuraRewarder(auraRewarder).withdraw(amount, true);\n        /// Withdraw LP\n        auraPools.withdraw(pid, amount);\n\n        /// Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        uint256 extraRewardsCount = IAuraRewarder(auraRewarder)\n            .extraRewardsLength();\n\n        for (uint256 i; i != extraRewardsCount; ) {\n            _syncExtraReward(IAuraRewarder(auraRewarder).extraRewards(i));\n\n            unchecked {\n                ++i;\n            }\n        }\n        uint256 storedExtraRewardLength = extraRewards.length;\n        bool hasDiffExtraRewards = extraRewardsCount != storedExtraRewardLength;\n\n        /// Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        /// Withdraw manually\n        if (hasDiffExtraRewards) {\n            for (uint256 i; i != storedExtraRewardLength; ) {\n                IAuraExtraRewarder(extraRewards[i]).getReward();\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint256 rewardTokensLength = rewardTokens.l"
    }
  ]
}