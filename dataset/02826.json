{
  "Title": "M-1: Curve LP Controller withdraw and claim function uses wrong signature",
  "Content": "# Issue M-1: Curve LP Controller withdraw and claim function uses wrong signature \n\nSource: https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/23 \n\n## Found by \nobront\n\n## Summary\n\nThe function signature used for `WITHDRAWCLAIM` in both CurveLPStakingController.sol and BalancerLPStakingController.sol are incorrect, leading to the function not succeeding.\n\n## Vulnerability Detail\n\nIn both the CurveLPStakingController.sol and BalancerLPStakingController.sol contracts, the function selector `0x00ebf5dd` is used for `WITHDRAWCLAIM`. This selector corresponds to a function signature of `withdraw(uint256,address,bool)`.\n\n```solidity\nbytes4 constant WITHDRAWCLAIM = 0x00ebf5dd;\n```\n\nHowever, the `withdraw()` function in the Curve contract does not have an address argument. Instead, the function signature reads `withdraw(uint256,bool)`, which corresponds to a function selector of `0x38d07436`.\n\n## Impact\n\nUsers who have deposited assets into Curve pools will not be able to claim their rewards when they withdraw their tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-sentiment/blob/main/controller-merged/src/balancer/BalancerLPStakingController.sol#L30-L31\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the function selector in both contracts to `0x38d07436`.\n\n## Discussion\n\n**ruvaag**\n\nThe Curve docs don't reflect this but both [2CRV](https://arbiscan.io/address/0xCE5F24B7A95e9cBa7df4B54E911B4A3Dc8CDAf6f#writeContract) and [crv3Crypto](https://arbiscan.io/address/0x555766f3da968ecBefa690Ffd49A2Ac02f47aa5f#writeContract) expose `withdraw(uint256,address,bool)` so this issue is invalid when looking at CRV LP tokens\n\nThat being said, Balancer exposes `withdraw(uint256,bool)` instead of `withdraw(uint256,address,bool)` so we will implement a fix to that effect.\n\n**ruvaag**\n\nDisagree with severity because users could use the `claim_rewards` function to claim pending rewards. But agree with the issue.\n\n**r0ohafza**\n\nFix: https://github.com/sentimentxyz/controller/pull/48\n\n**zobront**\n\nFix confirmed.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/17",
  "Code": [
    {
      "filename": "controller-merged/src/balancer/BalancerLPStakingController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\n\ninterface IChildGauge {\n    function lp_token() external view returns (address);\n    function reward_tokens(uint256) external view returns (address);\n}\n\n/**\n    @title Curve LP staking controller\n    @notice Interaction controller for staking curve LP controllers\n*/\ncontract BalancerLPStakingController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice deposit(uint256)\n    bytes4 constant DEPOSIT = 0xb6b55f25;\n\n    /// @notice deposit(uint256,address,bool)\n    bytes4 constant DEPOSITCLAIM = 0x83df6747;\n\n    /// @notice withdraw(uint256)\n    bytes4 constant WITHDRAW = 0x2e1a7d4d;\n\n    /// @notice withdraw(uint256,address,bool)\n    bytes4 constant WITHDRAWCLAIM = 0x00ebf5dd;\n\n    /// @notice claim_rewards()\n    bytes4 constant CLAIM = 0xe6f1daf2;\n\n    /// @notice reward count\n    uint256 constant rewardsCount = 8;\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == DEPOSIT) return canDeposit(target);\n        if (sig == DEPOSITCLAIM) return canDepositAndClaim(target);\n        if (sig == WITHDRAW) return canWithdraw(target);\n        if (sig == WITHDRAWCLAIM) return canWithdrawAndClaim(target);\n        if (sig == CLAIM) return canClaim(target);\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    function canDeposit(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](1);\n        tokensIn[0] = target;\n        tokensOut[0] = IChildGauge(target).lp_token();\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canDepositAndClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount + 1);\n        address reward; uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        tokensIn[i] = target;\n        i++;\n        assembly { mstore(tokensIn, i) }\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = IChildGauge(target).lp_token();\n\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canWithdraw(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = target;\n        tokensIn[0] = IChildGauge(target).lp_token();\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canWithdrawAndClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount + 1);\n        address reward;\n        uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        tokensIn[i] = IChildGauge(target).lp_token();\n        i++;\n        assembly { mstore(tokensIn, i) }\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = target;\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount);\n        address reward;\n        uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        assembly { mstore(tokensIn, i) }\n\n        return (true, tokensIn, new address[](0));\n    }\n}"
    }
  ]
}