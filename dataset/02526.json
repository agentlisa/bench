{
  "Title": "H-4: Lender force Loan become default",
  "Content": "# Issue H-4: Lender force Loan become default \n\nSource: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/23 \n\n## Found by \nhansfriese, 0x52, wagmi, IllIllI, bin2chen, Zarf, dipp, libratus, simon135, Trumpero, zaskoh, TrungOre, cccz\n\n## Summary\nin ```repay()``` directly transfer the debt token to Lender, but did not consider that Lender can not accept the token (in contract blacklist), resulting in repay() always revert, and finally the Loan can only expire, Loan be default\n\n## Vulnerability Detail\nThe only way for the borrower to get the collateral token back is to repay the amount owed via repay(). Currently in the repay() method transfers the debt token directly to the Lender.\nThis has a problem:\n if the Lender is blacklisted by the debt token now, the debtToken.transferFrom() method will fail and the repay() method will always fail and finally the Loan will default.\nExample:\nAssume collateral token = ETH,debt token = USDC, owner = alice\n1.alice call request() to loan 2000 usdc , duration = 1 mon\n2.bob call clear(): loanID =1\n3.bob transfer loan[1].lender = jack by Cooler.approve/transfer  \n  Note: jack has been in USDC's blacklist for some reason before\nor bob in USDC's blacklist for some reason now, it doesn't need transfer 'lender')\n4.Sometime before the expiration date, alice call repay(id=1) , it will always revert, Because usdc.transfer(jack) will revert\n5.after 1 mon, loan[1] default, jack call defaulted() get collateral token\n\n```solidity\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n...\n        debt.transferFrom(msg.sender, loan.lender, repaid);   //***<------- lender in debt token's blocklist will revert , example :debt = usdc\n        collateral.transfer(owner, decollateralized);\n    }\n```\n\n## Impact\n\nLender forced Loan become default for get collateral token, owner lost collateral token\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L122\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of transferring the debt token directly, put the debt token into the Cooler.sol and set like: withdrawBalance[lender]+=amount, and provide the method withdraw() for lender to get debtToken back\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Niche case + lender can transfer lender role to different, non-blacklisted wallet if needed.\n\n\n**IllIllI000**\n\nThe attacker in this case is the lender, so they wouldn't transfer to another wallet\n\n**hrishibhat**\n\nAgree with Lead Watson as the lender themself is the attacker here\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/36",
  "Code": [
    {
      "filename": "src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./lib/mininterfaces.sol\";\nimport \"./Factory.sol\";\n\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration loans\n///         for a specific user and debt-collateral pair.\ncontract Cooler {\n    // Errors\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n\n    // Data Structures\n\n    Request[] public requests;\n    struct Request { // A loan begins with a borrow request. It specifies:\n        uint256 amount; // the amount they want to borrow,\n        uint256 interest; // the annualized percentage they will pay as interest,\n        uint256 loanToCollateral; // the loan-to-collateral ratio they want,\n        uint256 duration; // and the length of time until the loan defaults.\n        bool active; // Any lender can clear an active loan request.\n    } \n\n    Loan[] public loans;\n    struct Loan { // A request is converted to a loan when a lender clears it.\n        Request request; // The terms of the loan are saved, along with:\n        uint256 amount; // the amount of debt owed,\n        uint256 collateral; // the amount of collateral pledged,\n        uint256 expiry; // the time when the loan defaults,\n        bool rollable; // whether the loan can be rolled over,\n        address lender; // and the lender's address.\n    }\n\n    // Facilitates transfer of lender ownership to new address\n    mapping(uint256 => address) public approvals;\n\n    // Immutables\n\n    // This address owns the collateral in escrow.\n    address private immutable owner;\n    // This token is borrowed against.\n    ERC20 public immutable collateral;\n    // This token is lent.\n    ERC20 public immutable debt;\n    // This contract created the Cooler\n    CoolerFactory public immutable factory;\n\n    // This makes the code look prettier.\n    uint256 private constant decimals = 1e18;\n\n    // Initialization\n\n    constructor (address o, ERC20 c, ERC20 d) {\n        owner = o;\n        collateral = c;\n        debt = d;\n        factory = CoolerFactory(msg.sender);\n    }\n\n    // Borrower\n\n    /// @notice request a loan with given parameters\n    /// @notice collateral is taken at time of request\n    /// @param amount of debt tokens to borrow\n    /// @param interest to pay (annualized % of 'amount')\n    /// @param loanToCollateral debt tokens per collateral token pledged\n    /// @param duration of loan tenure in seconds\n    /// @param reqID index of request in requests[]\n    function request (\n        uint256 amount,\n        uint256 interest,\n        uint256 loanToCollateral,\n        uint256 duration\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        factory.newEvent(reqID, CoolerFactory.Events.Request);\n        requests.push(\n            Request(amount, interest, loanToCollateral, duration, true)\n        );\n        collateral.transferFrom(msg.sender, address(this), collateralFor(amount, loanToCollateral));\n    }\n\n    /// @notice cancel a loan request and return collateral\n    /// @param reqID index of request in requests[]\n    function rescind (uint256 reqID) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n\n        factory.newEvent(reqID, CoolerFactory.Events.Rescind);\n\n        Request storage req = requests[reqID];\n\n        if (!req.active)\n            revert Deactivated();\n        \n        req.active = false;\n        collateral.transfer(owner, collateralFor(req.amount, req.loanToCollateral));\n    }\n\n    /// @notice repay a loan to recoup collateral\n    /// @param loanID index of loan in loans[]\n    /// @param repaid debt tokens to repay\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n        \n        uint256 decollateralized = loan.collateral * repaid / loan.amount;\n\n        if (repaid == loan.amount) delete loans[loanID];\n        else {\n            loan.amount -= repaid;\n            loan.collateral -= decollateralized;\n        }\n\n        debt.transferFrom(msg.sender, loan.lender, repaid);\n        collateral.transfer(owner, decollateralized);\n    }\n\n    /// @notice roll a loan over\n    /// @notice uses terms from request\n    /// @param loanID index of loan in loans[]\n    function roll (uint256 loanID) external {\n        Loan storage loan = loans[loanID];\n        Request memory req = loan.request;\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n\n        if (!loan.rollable)\n            revert NotRollable();\n\n        uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n        uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n        loan.amount += newDebt;\n        loan.expiry += req.duration;\n        loan.collateral += newCollateral;\n        \n        collateral.transferFrom(msg.sender, address(this), newCollateral);\n    }\n\n    /// @notice delegate voting power on collateral\n    /// @param to address to delegate\n    function delegate (address to) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n        IDelegateERC20(address(collateral)).delegate(to);\n    }\n\n    // Lender\n\n    /// @notice fill a requested loan as a lender\n    /// @param reqID index of request in requests[]\n    /// @param loanID index of loan in loans[]\n    function clear (uint256 reqID) external returns (uint256 loanID) {\n        Request storage req = requests[reqID];\n\n        factory.newEvent(reqID, CoolerFactory.Events.Clear);\n\n        if (!req.active) \n            revert Deactivated();\n        else req.active = false;\n\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n\n        loanID = loans.length;\n        loans.push(\n            Loan(req, req.amount + interest, collat, expiration, true, msg.sender)\n        );\n        debt.transferFrom(msg.sender, owner, req.amount);\n    }\n\n    /// @notice change 'rollable' status of loan\n    /// @param loanID index of loan in loans[]\n    /// @return bool new 'rollable' status\n    function toggleRoll(uint256 loanID) external returns (bool) {\n        Loan storage loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        loan.rollable = !loan.rollable;\n        return loan.rollable;\n    }\n\n    /// @notice send collateral to lender upon default\n    /// @param loanID index of loan in loans[]\n    /// @return uint256 collateral amount\n    function defaulted (uint256 loanID) external returns (uint256) {\n        Loan memory loan = loans[loanID];\n        delete loans[loanID];\n\n        if (block.timestamp <= loan.expiry) \n            revert NoDefault();\n\n        collateral.transfer(loan.lender, loan.collateral);\n        return loan.collateral;\n    }\n\n    /// @notice approve transfer of loan ownership to new address\n    /// @param to address to approve\n    /// @param loanID index of loan in loans[]\n    function approve (address to, uint256 loanID) external {\n        Loan memory loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        approvals[loanID] = to;\n    }\n\n    /// @notice execute approved transfer of loan ownership\n    /// @param loanID index of loan in loans[]\n    function transfer (uint256 loanID) external {\n        if (msg.sender != approvals[loanID])\n            revert OnlyApproved();\n\n        approvals[loanID] = address(0);\n        loans[loanID].lender = msg.sender;\n    }\n\n    // Views\n\n    /// @notice compute collateral needed for loan amount at given loan to collateral ratio\n    /// @param amount of collateral tokens\n    /// @param loanToCollateral ratio for loan\n    function collateralFor(uint256 amount, uint256 loanToCollateral) public pure returns (uint256) {\n        return amount * decimals / loanToCollateral;\n    }\n\n    /// @notice compute interest cost on amount for duration at given annualized rate\n    /// @param amount of debt tokens\n    /// @param rate of interest (annualized)\n    /// @param duration of loan in seconds\n    /// @return interest as a number of debt tokens\n    function interestFor(uint256 amount, uint256 rate, uint256 duration) public pure returns (uint256) {\n        uint256 interest = rate * duration / 365 days;\n        return amount * interest / decimals;\n    }\n\n    /// @notice check if given loan is in default\n    /// @param loanID index of loan in loans[]\n    /// @return defaulted status\n    function isDefaulted(uint256 loanID) external view returns (bool) {\n        return block.timestamp > loans[loanID].expiry;\n    }\n\n    /// @notice check if given request is active\n    /// @param reqID index of request in requests[]\n    /// @return active status\n    function isActive(uint256 reqID) external view returns (bool) {\n        return requests[reqID].active;\n    }\n}"
    }
  ]
}