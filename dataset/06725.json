{
  "Title": "[M-02] POSITION LIMIT COULD BE FULLY REDUCED TO ZERO BY CLONES",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/MintingHub.sol#L126> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L97-L101>\n\n### Impact\n\nA newly opened position could have its limit fully reduced to zero as soon as the cooldown period has elapsed.\n\n### Proof of Concept\n\nAs seen in the function below, a newly opened position with `0` Frankencoin minted could have its `limit` turn `0` if the function parameter, `_minimum`, is inputted with an amount equal to `limit`. In this case, `reduction` is equal to `0`, making `limit - _minimum = 0` while the cloner is assigned `reduction + _minimum = 0 + limit = limit`:\n\n[Position.sol#L97-L101](https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L97-L101)\n\n        function reduceLimitForClone(uint256 _minimum) external noChallenge noCooldown alive onlyHub returns (uint256) {\n            uint256 reduction = (limit - minted - _minimum)/2; // this will fail with an underflow if minimum is too high\n            limit -= reduction + _minimum;\n            return reduction + _minimum;\n        }\n\nWith the limit now fully allocated to the cloner, the original position owner is left with zero limit to mint Frankencoin after spending 1000 Frankencoin to open this position. This situation could readily happen especially when it involves popular position contracts.\n\n### Recommended Mitigation Steps\n\nIt is recommended position contract charging fees to cloners. Additionally, a reserve limit should be left untouched allocated solely to the original owner to be in line with the context of position opening.\n\n**[0xA5DF (lookout) commented](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/932#issuecomment-1516037713):**\n > Setting this one as primary since it shows how a single clone can reduce the remaining limit to zero.\n\n**[luziusmeisser (Frankencoin) acknowledged and commented](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/932#issuecomment-1528894234):**\n > Charging clones a fee payable to the original is an interesting idea!\n> \n> If the position comes with a high enough fee, this should not be relevant in practice as the limit will not be reached or new positions being created if there is enough demand. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-frankencoin",
  "Code": [
    {
      "filename": "contracts/MintingHub.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./IPosition.sol\";\n\n/**\n * The central hub for creating, cloning and challenging collateralized Frankencoin positions.\n * Only one instance of this contract is required, whereas every new position comes with a new position\n * contract. Pending challenges are stored as structs in an array.\n */\ncontract MintingHub {\n\n    /**\n     * Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\n     */\n    uint256 public constant OPENING_FEE = 1000 * 10**18;\n\n    /**\n     * The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\n     */\n    uint32 public constant CHALLENGER_REWARD = 20000; // 2%\n\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n    IFrankencoin public immutable zchf; // currency\n    Challenge[] public challenges; // list of open challenges\n\n    /**\n     * Map to remember pending postponed collateral returns.\n     * It maps collateral => beneficiary => amount.\n     */\n    mapping (address /** col */ => mapping (address => uint256)) public pendingReturns;\n\n    struct Challenge {\n        address challenger; // the address from which the challenge was initiated\n        IPosition position; // the position that was challenged\n        uint256 size;       // how much collateral the challenger provided\n        uint256 end;        // the deadline of the challenge (block.timestamp)\n        address bidder;     // the address from which the highest bid was made, if any\n        uint256 bid;        // the highest bid in ZCHF (total amount, not price per unit)\n    }\n\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\n    event ChallengeAverted(address indexed position, uint256 number);\n    event ChallengeSucceeded(address indexed position, uint256 bid, uint256 number);\n    event NewBid(uint256 challengedId, uint256 bidAmount, address bidder);\n    event PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\n\n    constructor(address _zchf, address factory) {\n        zchf = IFrankencoin(_zchf);\n        POSITION_FACTORY = IPositionFactory(factory);\n    }\n\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n            return openPosition(_collateralAddress, _minCollateral, _initialCollateral, _mintingMaximum,\n            7 days, _expirationSeconds, _challengeSeconds, _mintingFeePPM, _liqPrice, _reservePPM);\n    }\n\n    /**\n     * Open a collateralized loan position. See also https://docs.frankencoin.com/positions/open .\n     * For a successful call, you must set allowances for both ZCHF and the collateral token, allowing\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\n     * withdraw the fees.\n     *\n     * Together, the expiration and the minting fee imply an interest rate.\n     * TODO: in future versions, it might be better to fix the interest and not the fee\n     *\n     * @param _collateralAddress        address of collateral token\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\n     * @param _initialCollateral amount of initial collateral to be deposited\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\n     * @param _mintingFeePPM     ppm of minted amount that is paid as fee to the equity contract\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\n     *                           e.g. 18 decimals for an 18 decimal collateral, 36 decimals for a 0 decimal collateral.\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\n     * @return address           address of created position\n     */\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _initPeriodSeconds, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n        IPosition pos = IPosition(\n            POSITION_FACTORY.createNewPosition(\n                msg.sender,\n                address(zchf),\n                _collateralAddress,\n                _minCollateral,\n                _mintingMaximum,\n                _initPeriodSeconds,\n                _expirationSeconds,\n                _challengeSeconds,\n                _mintingFeePPM,\n                _liqPrice,\n                _reservePPM\n            )\n        );\n        zchf.registerPosition(address(pos));\n        zchf.transferFrom(msg.sender, address(zchf.reserve()), OPENING_FEE);\n        require(_initialCollateral >= _minCollateral, \"must start with min col\");\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n        return address(pos);\n    }\n\n    modifier validPos(address position) {\n        require(zchf.isPosition(position) == address(this), \"not our pos\");\n        _;\n    }\n\n    /**\n     * Clones an existing position and immediately tries to mint the specified amount using the given amount of collateral.\n     * This requires an allowance to be set on the collateral contract such that the minting hub can withdraw the collateral.\n     */\n    function clonePosition(address position, uint256 _initialCollateral, uint256 _initialMint) public validPos(position) returns (address) {\n        IPosition existing = IPosition(position);\n        uint256 limit = existing.reduceLimitForClone(_initialMint);\n        address pos = POSITION_FACTORY.clonePosition(position);\n        zchf.registerPosition(pos);\n        existing.collateral().transferFrom(msg.sender, address(pos), _initialCollateral);\n        IPosition(pos).initializeClone(msg.sender, existing.price(), limit, _initialCollateral, _initialMint);\n        return address(pos);\n    }\n\n    /**\n     * Launch a challenge on a position\n     * @param _positionAddr      address of the position we want to challenge\n     * @param _collateralAmount  size of the collateral we want to challenge (dec 18)\n     * @return index of the challenge in challenge-array\n     */\n    function launchChallenge(address _positionAddr, uint256 _collateralAmount) external validPos(_positionAddr) returns (uint256) {\n        IPosition position = IPosition(_positionAddr);\n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\n        uint256 pos = challenges.length;\n        challenges.push(Challenge(msg.sender, position, _collateralAmount, block.timestamp + position.challengePeriod(), address(0x0), 0));\n        position.notifyChallengeStarted(_collateralAmount);\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\n        return pos;\n    }\n\n    /**\n     * Splits a challenge into two smaller challenges.\n     * This can be useful to guard an attack, where a challenger launches a challenge so big that most bidders do not\n     * have the liquidity available to bid a sufficient amount. With this function, the can split of smaller slices of\n     * the challenge and avert it piece by piece.\n     */\n    function splitChallenge(uint256 _challengeNumber, uint256 splitOffAmount) external returns (uint256) {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        Challenge memory copy = Challenge(\n            challenge.challenger,\n            challenge.position,\n            splitOffAmount,\n            challenge.end,\n            challenge.bidder,\n            (challenge.bid * splitOffAmount) / challenge.size\n        );\n        challenge.bid -= copy.bid;\n        challenge.size -= copy.size;\n\n        uint256 min = IPosition(challenge.position).minimumCollateral();\n        require(challenge.size >= min);\n        require(copy.size >= min);\n\n        uint256 pos = challenges.length;\n        challenges.push(copy);\n        emit ChallengeStarted(challenge.challenger, address(challenge.position), challenge.size, _challengeNumber);\n        emit ChallengeStarted(copy.challenger, address(copy.position), copy.size, pos);\n        return pos;\n    }\n\n    function minBid(uint256 challenge) public view returns (uint256) {\n        return minBid(challenges[challenge]);\n    }\n\n    /**\n     * The minimum bid size for the next bid. It must be 0.5% higher than the previous bid.\n     */\n    function minBid(Challenge storage challenge) internal view returns (uint256) {\n        return (challenge.bid * 1005) / 1000;\n    }\n\n    /**\n     * Post a bid in ZCHF given an open challenge. Requires a ZCHF allowance from the caller to the minting hub.\n     *\n     * @param _challengeNumber   index of the challenge as broadcast in the event\n     * @param _bidAmountZCHF     how much to bid for the collateral of this challenge (dec 18)\n     * @param expectedSize       size verification to guard against frontrunners doing a split-challenge-attack\n     */\n    function bid(uint256 _challengeNumber, uint256 _bidAmountZCHF, uint256 expectedSize) external {\n        Challenge storage challenge = challenges[_challengeNumber];\n        if (block.timestamp >= challenge.end) revert TooLate();\n        if (expectedSize != challenge.size) revert UnexpectedSize();\n        if (challenge.bid > 0) {\n            zchf.transfer(challenge.bidder, challenge.bid); // return old bid\n        }\n        emit NewBid(_challengeNumber, _bidAmountZCHF, msg.sender);\n        // ask position if the bid was high enough to avert the challenge\n        if (challenge.position.tryAvertChallenge(challenge.size, _bidAmountZCHF)) {\n            // bid was high enough, let bidder buy collateral from challenger\n            zchf.transferFrom(msg.sender, challenge.challenger, _bidAmountZCHF);\n            challenge.position.collateral().transfer(msg.sender, challenge.size);\n            emit ChallengeAverted(address(challenge.position), _challengeNumber);\n            delete challenges[_challengeNumber];\n        } else {\n            // challenge is not averted, update bid\n            if (_bidAmountZCHF < minBid(challenge)) revert BidTooLow(_bidAmountZCHF, minBid(challenge));\n            uint256 earliestEnd = block.timestamp + 30 minutes;\n            if (earliestEnd >= challenge.end) {\n                // bump remaining time like ebay does when last minute bids come in\n                // An attacker trying to postpone the challenge forever must increase the bid by 0.5%\n                // every 30 minutes, or double it every three days, making the attack hard to sustain\n                // for a prolonged period of time.\n                challenge.end = earliestEnd;\n            }\n            zchf.transferFrom(msg.sender, address(this), _bidAmountZCHF);\n            challenge.bid = _bidAmountZCHF;\n            challenge.bidder = msg.sender;\n        }\n    }\n\n    error TooLate();\n    error UnexpectedSize();\n    error BidTooLow(uint256 bid, uint256 min);\n\n    function end(uint256 _challengeNumber) external {\n        end(_challengeNumber, false);\n    }\n\n    function isChallengeOpen(uint256 _challengeNumber) external view returns (bool) {\n        return challenges[_challengeNumber].end > block.timestamp;\n    }\n\n    /**\n     * Ends a challenge successfully after the auction period ended, whereas successfully means that the challenger\n     * could show that the price of the collateral is too low to make the position well-collateralized.\n     *\n     * In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token has a blacklist and the\n     * challenger is on it), it is possible to postpone the return of the collateral.\n     *\n     * @param postponeCollateralReturn Can be used to postpone the return of the collateral to the challenger. Usually false. \n     */\n    function end(uint256 _challengeNumber, bool postponeCollateralReturn) public {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        require(block.timestamp >= challenge.end, \"period has not ended\");\n        // challenge must have been successful, because otherwise it would have immediately ended on placing the winning bid\n        returnCollateral(challenge, postponeCollateralReturn);\n        // notify the position that will send the collateral to the bidder. If there is no bid, send the collateral to msg.sender\n        address recipient = challenge.bidder == address(0x0) ? msg.sender : challenge.bidder;\n        (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size);\n        if (effectiveBid < challenge.bid) {\n            // overbid, return excess amount\n            IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid);\n        }\n        uint256 reward = (volume * CHALLENGER_REWARD) / 1000_000;\n        uint256 fundsNeeded = reward + repayment;\n        if (effectiveBid > fundsNeeded){\n            zchf.transfer(owner, effectiveBid - fundsNeeded);\n        } else if (effectiveBid < fundsNeeded){\n            zchf.notifyLoss(fundsNeeded - effectiveBid); // ensure we have enough to pay everything\n        }\n        zchf.transfer(challenge.challenger, reward); // pay out the challenger reward\n        zchf.burn(repayment, reservePPM); // Repay the challenged part\n        emit ChallengeSucceeded(address(challenge.position), challenge.bid, _challengeNumber);\n        delete challenges[_challengeNumber];\n    }\n\n    /**\n     * Challengers can call this method to withdraw collateral whose return was postponed.\n     */\n    function returnPostponedCollateral(address collateral, address target) external {\n        uint256 amount = pendingReturns[collateral][msg.sender];\n        delete pendingReturns[collateral][msg.sender];\n        IERC20(collateral).transfer(target, amount);\n    }\n\n    function returnCollateral(Challenge storage challenge, bool postpone) internal {\n        if (postpone){\n            // Postponing helps in case the challenger was blacklisted on the collateral token or otherwise cannot receive it at the moment.\n            address collateral = address(challenge.position.collateral());\n            pendingReturns[collateral][challenge.challenger] += challenge.size;\n            emit PostPonedReturn(collateral, challenge.challenger, challenge.size);\n        } else {\n            challenge.position.collateral().transfer(challenge.challenger, challenge.size); // return the challenger's collateral\n        }\n    }\n}\n\ninterface IPositionFactory {\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint256 _initPeriodSeconds,\n        uint256 _duration,\n        uint256 _challengePeriod,\n        uint32 _mintingFeePPM,\n        uint256 _liqPrice,\n        uint32 _reserve\n    ) external returns (address);\n\n    function clonePosition(address _existing) external returns (address);\n}"
    },
    {
      "filename": "contracts/Position.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IPosition.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./MathUtil.sol\";\n\n/**\n * A collateralized minting position.\n */\ncontract Position is Ownable, IPosition, MathUtil {\n\n    /**\n     * Note that this contract is intended to be cloned. All clones will share the same values for\n     * the constant and immutable fields, but have their own values for the other fields.\n     */\n\n    uint256 public price; // the zchf price per unit of the collateral below which challenges succeed, (36 - collateral.decimals) decimals\n    uint256 public minted; // net minted amount, including reserve\n    uint256 public challengedAmount; // amount of the collateral that is currently under a challenge\n    uint256 public immutable challengePeriod; // challenge period in seconds\n\n    uint256 public cooldown; // timestamp of the end of the latest cooldown\n    uint256 public limit; // the minted amount must never exceed the limit\n\n    uint256 public immutable start; // timestamp when minting can start\n    uint256 public immutable expiration; // timestamp at which the position expires\n\n    address public immutable original; // originals point to themselves, clone to their origin\n    address public immutable hub; // the hub this position was created by\n    IFrankencoin public immutable zchf; // currency\n    IERC20 public override immutable collateral; // collateral\n    uint256 public override immutable minimumCollateral; // prevent dust amounts\n\n    uint32 public immutable mintingFeePPM;\n    uint32 public immutable reserveContribution; // in ppm\n\n    event PositionOpened(address indexed owner, address original, address zchf, address collateral, uint256 price);\n    event MintingUpdate(uint256 collateral, uint256 price, uint256 minted, uint256 limit);\n    event PositionDenied(address indexed sender, string message); // emitted if closed by governance\n\n    error InsufficientCollateral();\n\n    /**\n    * See MintingHub.openPosition\n    */\n    constructor(address _owner, address _hub, address _zchf, address _collateral, \n        uint256 _minCollateral, uint256 _initialLimit, uint256 initPeriod, uint256 _duration,\n        uint256 _challengePeriod, uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) {\n        require(initPeriod >= 3 days); // must be at least three days, recommended to use higher values\n        setOwner(_owner);\n        original = address(this);\n        hub = _hub;\n        price = _liqPrice;\n        zchf = IFrankencoin(_zchf);\n        collateral = IERC20(_collateral);\n        mintingFeePPM = _mintingFeePPM;\n        reserveContribution = _reservePPM;\n        minimumCollateral = _minCollateral;\n        challengePeriod = _challengePeriod;\n        start = block.timestamp + initPeriod; // one week time to deny the position\n        cooldown = start;\n        expiration = start + _duration;\n        limit = _initialLimit;\n        \n        emit PositionOpened(_owner, original, _zchf, address(collateral), _liqPrice);\n    }\n\n    /**\n     * Method to initialize a freshly created clone. It is the responsibility of the creator to make sure this is only\n     * called once and to call reduceLimitForClone on the original position before initializing the clone.\n     */\n    function initializeClone(address owner, uint256 _price, uint256 _limit, uint256 _coll, uint256 _mint) external onlyHub {\n        if(_coll < minimumCollateral) revert InsufficientCollateral();\n        setOwner(owner);\n        \n        price = _mint * ONE_DEC18 / _coll;\n        if (price > _price) revert InsufficientCollateral();\n        limit = _limit;\n        mintInternal(owner, _mint, _coll);\n\n        emit PositionOpened(owner, original, address(zchf), address(collateral), _price);\n    }\n\n    /**\n     * Adjust this position's limit to give away half of the remaining limit to the clone.\n     * Invariant: global limit stays the same.\n     *\n     * Cloning a position is only allowed if the position is not challenged, not expired and not in cooldown.\n     *\n     * @param _minimum amount that clone wants to mint initially\n     * @return limit for the clone\n     */\n    function reduceLimitForClone(uint256 _minimum) external noChallenge noCooldown alive onlyHub returns (uint256) {\n        uint256 reduction = (limit - minted - _minimum)/2; // this will fail with an underflow if minimum is too high\n        limit -= reduction + _minimum;\n        return reduction + _minimum;\n    }\n\n    error TooLate();\n    error NotQualified();\n\n    /**\n     * Qualified pool share holders can call this method to immediately expire a freshly proposed position.\n     */ \n    function deny(address[] calldata helpers, string calldata message) public {\n        if (block.timestamp >= start) revert TooLate();\n        IReserve(zchf.reserve()).checkQualified(msg.sender, helpers);\n        cooldown = expiration; // since expiration is immutable, we put it under cooldown until the end\n        emit PositionDenied(msg.sender, message);\n    }\n\n    /**\n     * This is how much the minter can actually use when minting ZCHF, with the rest being used\n     * to buy reserve pool shares.\n     */\n    function getUsableMint(uint256 totalMint, bool afterFees) public view returns (uint256){\n        if (afterFees){\n            return totalMint * (1000_000 - reserveContribution - calculateCurrentFee()) / 1000_000;\n        } else {\n            return totalMint * (1000_000 - reserveContribution) / 1000_000;\n        }\n    }\n\n    /**\n     * \"All in one\" function to adjust the outstanding amount of ZCHF, the collateral amount, \n     * and the price in one transaction.\n     */\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) public onlyOwner {\n        if (newPrice != price){\n            adjustPrice(newPrice);\n        }\n        uint256 colbal = collateralBalance();\n        if (newCollateral > colbal){\n            collateral.transferFrom(msg.sender, address(this), newCollateral - colbal);\n        }\n        // Must be called after collateral deposit, but before withdrawal\n        if (newMinted < minted){\n            zchf.burnFrom(msg.sender, minted - newMinted, reserveContribution);\n            minted = newMinted;\n        }\n        if (newCollateral < colbal){\n            withdrawCollateral(msg.sender, colbal - newCollateral);\n        }\n        // Must be called after collateral withdrawal\n        if (newMinted > minted){\n            mint(msg.sender, newMinted - minted);\n        }\n    }\n\n    /**\n     * Allows the position owner to adjust the liquidation price as long as there is no pending challenge.\n     * Lowering the liquidation price can be done with immediate effect, given that there is enough collateral.\n     * Increasing the liquidation price triggers a cooldown period of 3 days, during which minting is suspended.\n     */\n    function adjustPrice(uint256 newPrice) public onlyOwner noChallenge {\n        if (newPrice > price) {\n            restrictMinting(3 days);\n        } else {\n            checkCollateral(collateralBalance(), newPrice);\n        }\n        price = newPrice;\n        emitUpdate();\n    }\n\n    function collateralBalance() internal view returns (uint256){\n        return IERC20(collateral).balanceOf(address(this));\n    }\n\n    /**\n     * Mint ZCHF as long as there is no open challenge, the position is not subject to a cooldown,\n     * and there is sufficient collateral.\n     */\n    function mint(address target, uint256 amount) public onlyOwner noChallenge noCooldown alive {\n       mintInternal(target, amount, collateralBalance());\n    }\n\n    function calculateCurrentFee() public view returns (uint32) {\n        uint256 exp = expiration;\n        uint256 time = block.timestamp;\n        if (time >= exp){\n            return 0;\n        } else {\n            return uint32(mintingFeePPM - mintingFeePPM * (time - start) / (exp - start));\n        }\n    }\n\n    error LimitExceeded();\n\n    function mintInternal(address target, uint256 amount, uint256 collateral_) internal {\n        if (minted + amount > limit) revert LimitExceeded();\n        zchf.mint(target, amount, reserveContribution, calculateCurrentFee());\n        minted += amount;\n\n        checkCollateral(collateral_, price);\n        emitUpdate();\n    }\n\n    function restrictMinting(uint256 period) internal {\n        uint256 horizon = block.timestamp + period;\n        if (horizon > cooldown){\n            cooldown = horizon;\n        }\n    }\n    \n    /**\n     * Repay some ZCHF. Requires an allowance to be in place. If too much is repaid, the call fails.\n     * It is possible to repay while there are challenges, but the collateral is locked until all is clear again.\n     *\n     * The repaid amount should fulfill the following equation in order to close the position, i.e. bring the minted amount to 0:\n     * minted = amount + zchf.calculateAssignedReserve(amount, reservePPM)\n     *\n     * Under normal circumstances, this implies:\n     * amount = minted * (1000000 - reservePPM)\n     *\n     * For example, if minted is 50 and reservePPM is 200000, it is necessary to repay 40 to be able to close the position.\n     *\n     * Only the owner is allowed to repay a position. This is necessary to prevent a 'limit stealing attack': if a popular position\n     * has reached its limit, an attacker could try to repay the position, clone it, and take a loan himself. This is prevented by\n     * requiring the owner to do the repayment. Other restrictions are not necessary. In particular, it must be possible to repay\n     * the position once it is expired or subject to cooldown. Also, repaying it during a challenge is no problem as the collateral\n     * remains present.\n     */\n    function repay(uint256 amount) public onlyOwner {\n        IERC20(zchf).transferFrom(msg.sender, address(this), amount);\n        repayInternal(amount);\n    }\n\n    function repayInternal(uint256 burnable) internal {\n        uint256 actuallyBurned = IFrankencoin(zchf).burnWithReserve(burnable, reserveContribution);\n        notifyRepaidInternal(actuallyBurned);\n        emitUpdate();\n    }\n\n    error RepaidTooMuch(uint256 excess);\n\n    function notifyRepaidInternal(uint256 amount) internal {\n        if (amount > minted) revert RepaidTooMuch(amount - minted);\n        minted -= amount;\n    }\n\n    /**\n     * Withdraw any ERC20 token that might have ended up on this address.\n     * Withdrawing collateral is subject to the same restrictions as withdrawCollateral(...).\n     */\n    function withdraw(address token, address target, uint256 amount) external onlyOwner {\n        if (token == address(collateral)){\n            withdrawCollateral(target, amount);\n        } else {\n            IERC20(token).transfer(target, amount);\n        }\n    }\n\n    /**\n     * Withdraw collateral from the position up to the extent that it is still well collateralized afterwards.\n     * Not possible as long as there is an open challenge or the contract is subject to a cooldown.\n     *\n     * Withdrawing collateral below the minimum collateral amount formally closes the position.\n     */\n    function withdrawCollateral(address target, uint256 amount) public onlyOwner noChallenge noCooldown {\n        uint256 balance = internalWithdrawCollateral(target, amount);\n        checkCollateral(balance, price);\n    }\n\n    function internalWithdrawCollateral(address target, uint256 amount) internal returns (uint256) {\n        IERC20(collateral).transfer(target, amount);\n        uint256 balance = collateralBalance();\n        if (balance < minimumCollateral){\n            cooldown = expiration;\n        }\n        emitUpdate();\n        return balance;\n    }\n\n    /**\n     * This invariant must always hold and must always be checked when any of the three\n     * variables change in an adverse way.\n     */\n    function checkCollateral(uint256 collateralReserve, uint256 atPrice) internal view {\n        if (collateralReserve * atPrice < minted * ONE_DEC18) revert InsufficientCollateral();\n    }\n\n    function emitUpdate() internal {\n        emit MintingUpdate(collateralBalance(), price, minted, limit);\n    }\n\n    error ChallengeTooSmall();\n\n    function notifyChallengeStarted(uint256 size) external onlyHub {\n        // require minimum size, note that collateral balance can be below minimum if it was partially challenged before\n        if (size < minimumCollateral && size < collateralBalance()) revert ChallengeTooSmall();\n        challengedAmount += size;\n    }\n\n    /**\n     * @notice check whether challenge can be averted\n     * @param _collateralAmount   amount of collateral challenged (dec18)\n     * @param _bidAmountZCHF      bid amount in ZCHF (dec18)\n     * @return true if challenge can be averted\n     */\n    function tryAvertChallenge(uint256 _collateralAmount, uint256 _bidAmountZCHF) external onlyHub returns (bool) {\n        if (block.timestamp >= expiration){\n            return false; // position expired, let every challenge succeed\n        } else if (_bidAmountZCHF * ONE_DEC18 >= price * _collateralAmount){\n            // challenge averted, bid is high enough\n            challengedAmount -= _collateralAmount;\n            // Don't allow minter to close the position immediately so challenge can be repeated before\n            // the owner has a chance to mint more on an undercollateralized position\n            restrictMinting(1 days);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Notifies the position that a challenge was successful.\n     * Triggers the payout of the challenged part of the collateral.\n     * Everything else is assumed to be handled by the hub.\n     *\n     * @param _bidder   address of the bidder that receives the collateral\n     * @param _bid      bid amount in ZCHF (dec18)\n     * @param _size     size of the collateral bid for (dec 18)\n     * @return (position owner, effective bid size in ZCHF, effective challenge size in ZCHF, repaid amount, reserve ppm)\n     */\n    function notifyChallengeSucceeded(address _bidder, uint256 _bid, uint256 _size) external onlyHub returns (address, uint256, uint256, uint256, uint32) {\n        challengedAmount -= _size;\n        uint256 colBal = collateralBalance();\n        if (_size > colBal){\n            // Challenge is larger than the position. This can for example happen if there are multiple concurrent\n            // challenges that exceed the collateral balance in size. In this case, we need to redimension the bid and\n            // tell the caller that a part of the bid needs to be returned to the bidder.\n            _bid = _divD18(_mulD18(_bid, colBal), _size);\n            _size = colBal;\n        }\n\n        // Note that thanks to the collateral invariant, we know that\n        //    colBal * price >= minted * ONE_DEC18\n        // and that therefore\n        //    price >= minted / colbal * E18\n        // such that\n        //    volumeZCHF = price * size / E18 >= minted * size / colbal\n        // So the owner cannot maliciously decrease the price to make volume fall below the proportionate repayment.\n        uint256 volumeZCHF = _mulD18(price, _size); // How much could have minted with the challenged amount of the collateral\n        // The owner does not have to repay (and burn) more than the owner actually minted.  \n        uint256 repayment = minted < volumeZCHF ? minted : volumeZCHF; // how much must be burned to make things even\n\n        notifyRepaidInternal(repayment); // we assume the caller takes care of the actual repayment\n        internalWithdrawCollateral(_bidder, _size); // transfer collateral to the bidder and emit update\n        return (owner, _bid, volumeZCHF, repayment, reserveContribution);\n    }\n\n    /**\n     * A position should only be considered 'closed', once its collateral has been withdrawn.\n     * This is also a good creterion when deciding whether it should be shown in a frontend.\n     */\n    function isClosed() public view returns (bool) {\n        return collateralBalance() < minimumCollateral;\n    }\n\n    error Expired();\n\n    modifier alive() {\n        if (block.timestamp > expiration) revert Expired();\n        _;\n    }\n\n    error Hot();\n\n    modifier noCooldown() {\n        if (block.timestamp <= cooldown) revert Hot();\n        _;\n    }\n\n    error Challenged();\n\n    modifier noChallenge() {\n        if (challengedAmount > 0) revert Challenged();\n        _;\n    }\n\n    error NotHub();\n\n    modifier onlyHub() {\n        if (msg.sender != address(hub)) revert NotHub();\n        _;\n    }\n\n}"
    }
  ]
}