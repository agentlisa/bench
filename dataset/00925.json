{
  "Title": "Wrong Argument Validation in Modifier Generation",
  "Content": "In the [`generate`](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/lang/codegen/src/modifier_definition.rs#L34) function of the `modifier_definition` macro, modifier arguments are matched against certain expected types. When checking that the [second argument is not `self`](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/lang/codegen/src/modifier_definition.rs#L178), the `if let` block erroneously tries to match against the [first](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/lang/codegen/src/modifier_definition.rs#L175C47-L175C53) argument again. This may allow flawed methods to be accepted as valid modifiers.\n\n\nAdditionally, when matching on [additional arguments](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/lang/codegen/src/modifier_definition.rs#L182), the error message implies a necessary check that the argument is passed by value and implements the `Clone` trait. However, the check only ensures that the argument is not a reference.\n\n\nConsider correcting the argument validation in the `generate` function to correspond to the intended behavior.\n\n\n***Update:** Partially resolved in [pull request #144](https://github.com/Brushfam/openbrush-contracts/pull/144/files) at commit [b48968d](https://github.com/Brushfam/openbrush-contracts/pull/144/commits/b48968d62acf23e4c7c8dea2fc9d505d6bb0b7d2). The client did not take any action on the inaccurate error message. They expressed that checking if `Clone` trait is implemented, it is not realistic to do in Rust. Nonetheless, they should modify the error message to more accurately reflect what the code is actually checking.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "lang/codegen/src/modifier_definition.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nuse proc_macro2::TokenStream;\nuse quote::{\n    quote,\n    quote_spanned,\n    ToTokens,\n};\nuse syn::{\n    parse2,\n    spanned::Spanned,\n    ItemFn,\n};\n\npub fn generate(_: TokenStream, _input: TokenStream) -> TokenStream {\n    let fn_item: ItemFn = parse2(_input).unwrap();\n\n    if fn_item.sig.inputs.len() < 2 {\n        return quote_spanned! {\n            fn_item.sig.inputs.span() =>\n                compile_error!(\n                    \"Modifier must take at least two arguments, \\\n                    where first is a reference to instance `instance: \\\n                    & Trait/Struct` and second is Fn, FnMut or FnOnce\");\n        }\n    }\n\n    let instance_ty: syn::TypeReference;\n    let first = fn_item.sig.inputs.first().unwrap();\n    if let syn::FnArg::Typed(pat) = first {\n        if let syn::Type::Reference(refer) = pat.ty.as_ref() {\n            instance_ty = refer.clone();\n        } else {\n            return quote_spanned! {\n                pat.ty.as_ref().span() =>\n                    compile_error!(\"First argument of modifier must be a reference to instance `&T` or `&mut T`\");\n            }\n        }\n    } else {\n        return quote_spanned! {\n            first.span() =>\n                compile_error!(\"First argument of modifier can't be `self`\");\n        }\n    }\n\n    let return_ty = fn_item.sig.output.clone();\n    let mut fn_string = format!(\"Fn({}) {}\", instance_ty.to_token_stream(), return_ty.to_token_stream());\n\n    let mut fn_mut_string = format!(\n        \"FnMut({}) {}\",\n        instance_ty.to_token_stream(),\n        return_ty.to_token_stream()\n    );\n\n    let mut fn_once_string = format!(\n        \"FnOnce({}) {}\",\n        instance_ty.to_token_stream(),\n        return_ty.to_token_stream()\n    );\n    let err_message = format!(\n        \"Second argument of modifier must be body `{}`, `{}` or `{}`\",\n        fn_string.as_str(),\n        fn_mut_string.as_str(),\n        fn_once_string.as_str()\n    );\n\n    fn_string.retain(|c| !c.is_whitespace());\n    fn_mut_string.retain(|c| !c.is_whitespace());\n    fn_once_string.retain(|c| !c.is_whitespace());\n\n    let second = fn_item.sig.inputs.iter().nth(1).unwrap();\n    if let syn::FnArg::Typed(pat) = second {\n        let mut found = false;\n        let mut found_ty = None;\n        let mut found_span = None;\n        let mut t = pat.ty.to_token_stream().to_string();\n        t.retain(|c| !c.is_whitespace());\n        if t.contains(&fn_string) || t.contains(&fn_mut_string) || t.contains(&fn_once_string) {\n            found_ty = Some(t.clone());\n            found_span = Some(pat.ty.span());\n            found = true;\n        }\n\n        let generic = fn_item\n            .sig\n            .generics\n            .params\n            .iter()\n            .filter_map(|param| {\n                if let syn::GenericParam::Type(type_param) = &param {\n                    Some(type_param)\n                } else {\n                    None\n                }\n            })\n            .find(|type_param| type_param.ident == t);\n\n        if let Some(generic) = generic {\n            if let Some(generic_bound) = &generic.bounds.first() {\n                let mut t = generic_bound.to_token_stream().to_string();\n                t.retain(|c| !c.is_whitespace());\n                if t.contains(&fn_string) || t.contains(&fn_mut_string) || t.contains(&fn_once_string) {\n                    found_ty = Some(t);\n                    found_span = Some(generic_bound.span());\n                    found = true;\n                }\n            }\n        }\n\n        if let Some(where_clause) = &fn_item.sig.generics.where_clause {\n            let predicate = where_clause\n                .predicates\n                .iter()\n                .filter_map(|pred| {\n                    if let syn::WherePredicate::Type(type_pred) = &pred {\n                        Some(type_pred)\n                    } else {\n                        None\n                    }\n                })\n                .find(|type_pred| type_pred.bounded_ty.to_token_stream().to_string() == t);\n\n            if let Some(pred) = predicate {\n                if let Some(pred_bound) = pred.bounds.first() {\n                    let mut t = pred_bound.to_token_stream().to_string();\n                    t.retain(|c| !c.is_whitespace());\n                    if t.contains(&fn_string) || t.contains(&fn_mut_string) || t.contains(&fn_once_string) {\n                        found_ty = Some(t);\n                        found_span = Some(pred_bound.span());\n                        found = true;\n                    }\n                }\n            }\n        }\n\n        if !found {\n            return quote_spanned! {\n                pat.ty.span() =>\n                    compile_error!(#err_message);\n            }\n        } else {\n            let mut modifier_ty_str = fn_item.sig.output.to_token_stream().to_string();\n            modifier_ty_str.retain(|c| !c.is_whitespace());\n            let found_ty = found_ty.unwrap();\n\n            let found_index = found_ty.find(\"->\").unwrap_or(found_ty.len());\n            let found_ty_str = &found_ty[found_index..];\n\n            if found_ty_str != modifier_ty_str {\n                return quote_spanned! {\n                    found_span.unwrap().span() =>\n                        compile_error!(\"Return type of body mismatched with return type of modifier\");\n                }\n            }\n        }\n    } else if let syn::FnArg::Receiver(rec) = first {\n        return quote_spanned! {\n            rec.span() =>\n                compile_error!(\"Second argument of modifier can't be `self`\");\n        }\n    }\n\n    for arg in fn_item.sig.inputs.iter().skip(2) {\n        if let syn::FnArg::Typed(arg) = arg {\n            if let syn::Type::Reference(refer) = arg.ty.as_ref() {\n                return quote_spanned! {\n                    refer.span() =>\n                        compile_error!(\"The argument is a reference. \\\n                        Modifier only accepts arguments which implement `Clone` trait and only by value.\");\n                }\n            }\n        } else {\n            return quote_spanned! {\n                arg.span() =>\n                    compile_error!(\"`self` is not allowed.\");\n            }\n        }\n    }\n\n    quote! {\n        #fn_item\n    }\n}"
    },
    {
      "filename": "lang/codegen/src/modifier_definition.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nuse proc_macro2::TokenStream;\nuse quote::{\n    quote,\n    quote_spanned,\n    ToTokens,\n};\nuse syn::{\n    parse2,\n    spanned::Spanned,\n    ItemFn,\n};\n\npub fn generate(_: TokenStream, _input: TokenStream) -> TokenStream {\n    let fn_item: ItemFn = parse2(_input).unwrap();\n\n    if fn_item.sig.inputs.len() < 2 {\n        return quote_spanned! {\n            fn_item.sig.inputs.span() =>\n                compile_error!(\n                    \"Modifier must take at least two arguments, \\\n                    where first is a reference to instance `instance: \\\n                    & Trait/Struct` and second is Fn, FnMut or FnOnce\");\n        }\n    }\n\n    let instance_ty: syn::TypeReference;\n    let first = fn_item.sig.inputs.first().unwrap();\n    if let syn::FnArg::Typed(pat) = first {\n        if let syn::Type::Reference(refer) = pat.ty.as_ref() {\n            instance_ty = refer.clone();\n        } else {\n            return quote_spanned! {\n                pat.ty.as_ref().span() =>\n                    compile_error!(\"First argument of modifier must be a reference to instance `&T` or `&mut T`\");\n            }\n        }\n    } else {\n        return quote_spanned! {\n            first.span() =>\n                compile_error!(\"First argument of modifier can't be `self`\");\n        }\n    }\n\n    let return_ty = fn_item.sig.output.clone();\n    let mut fn_string = format!(\"Fn({}) {}\", instance_ty.to_token_stream(), return_ty.to_token_stream());\n\n    let mut fn_mut_string = format!(\n        \"FnMut({}) {}\",\n        instance_ty.to_token_stream(),\n        return_ty.to_token_stream()\n    );\n\n    let mut fn_once_string = format!(\n        \"FnOnce({}) {}\",\n        instance_ty.to_token_stream(),\n        return_ty.to_token_stream()\n    );\n    let err_message = format!(\n        \"Second argument of modifier must be body `{}`, `{}` or `{}`\",\n        fn_string.as_str(),\n        fn_mut_string.as_str(),\n        fn_once_string.as_str()\n    );\n\n    fn_string.retain(|c| !c.is_whitespace());\n    fn_mut_string.retain(|c| !c.is_whitespace());\n    fn_once_string.retain(|c| !c.is_whitespace());\n\n    let second = fn_item.sig.inputs.iter().nth(1).unwrap();\n    if let syn::FnArg::Typed(pat) = second {\n        let mut found = false;\n        let mut found_ty = None;\n        let mut found_span = None;\n        let mut t = pat.ty.to_token_stream().to_string();\n        t.retain(|c| !c.is_whitespace());\n        if t.contains(&fn_string) || t.contains(&fn_mut_string) || t.contains(&fn_once_string) {\n            found_ty = Some(t.clone());\n            found_span = Some(pat.ty.span());\n            found = true;\n        }\n\n        let generic = fn_item\n            .sig\n            .generics\n            .params\n            .iter()\n            .filter_map(|param| {\n                if let syn::GenericParam::Type(type_param) = &param {\n                    Some(type_param)\n                } else {\n                    None\n                }\n            })\n            .find(|type_param| type_param.ident == t);\n\n        if let Some(generic) = generic {\n            if let Some(generic_bound) = &generic.bounds.first() {\n                let mut t = generic_bound.to_token_stream().to_string();\n                t.retain(|c| !c.is_whitespace());\n                if t.contains(&fn_string) || t.contains(&fn_mut_string) || t.contains(&fn_once_string) {\n                    found_ty = Some(t);\n                    found_span = Some(generic_bound.span());\n                    found = true;\n                }\n            }\n        }\n\n        if let Some(where_clause) = &fn_item.sig.generics.where_clause {\n            let predicate = where_clause\n                .predicates\n                .iter()\n                .filter_map(|pred| {\n                    if let syn::WherePredicate::Type(type_pred) = &pred {\n                        Some(type_pred)\n                    } else {\n                        None\n                    }\n                })\n                .find(|type_pred| type_pred.bounded_ty.to_token_stream().to_string() == t);\n\n            if let Some(pred) = predicate {\n                if let Some(pred_bound) = pred.bounds.first() {\n                    let mut t = pred_bound.to_token_stream().to_string();\n                    t.retain(|c| !c.is_whitespace());\n                    if t.contains(&fn_string) || t.contains(&fn_mut_string) || t.contains(&fn_once_string) {\n                        found_ty = Some(t);\n                        found_span = Some(pred_bound.span());\n                        found = true;\n                    }\n                }\n            }\n        }\n\n        if !found {\n            return quote_spanned! {\n                pat.ty.span() =>\n                    compile_error!(#err_message);\n            }\n        } else {\n            let mut modifier_ty_str = fn_item.sig.output.to_token_stream().to_string();\n            modifier_ty_str.retain(|c| !c.is_whitespace());\n            let found_ty = found_ty.unwrap();\n\n            let found_index = found_ty.find(\"->\").unwrap_or(found_ty.len());\n            let found_ty_str = &found_ty[found_index..];\n\n            if found_ty_str != modifier_ty_str {\n                return quote_spanned! {\n                    found_span.unwrap().span() =>\n                        compile_error!(\"Return type of body mismatched with return type of modifier\");\n                }\n            }\n        }\n    } else if let syn::FnArg::Receiver(rec) = first {\n        return quote_spanned! {\n            rec.span() =>\n                compile_error!(\"Second argument of modifier can't be `self`\");\n        }\n    }\n\n    for arg in fn_item.sig.inputs.iter().skip(2) {\n        if let syn::FnArg::Typed(arg) = arg {\n            if let syn::Type::Reference(refer) = arg.ty.as_ref() {\n                return quote_spanned! {\n                    refer.span() =>\n                        compile_error!(\"The argument is a reference. \\\n                        Modifier only accepts arguments which implement `Clone` trait and only by value.\");\n                }\n            }\n        } else {\n            return quote_spanned! {\n                arg.span() =>\n                    compile_error!(\"`self` is not allowed.\");\n            }\n        }\n    }\n\n    quote! {\n        #fn_item\n    }\n}"
    }
  ]
}