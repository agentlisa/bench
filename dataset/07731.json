{
  "Title": "[06] Inadequate NatSpec",
  "Content": "\nSolidity contracts can use a special form of comments, i.e., the Ethereum Natural Language Specification Format (NatSpec) to provide rich documentation for functions, return variables and more. Please visit the following link for further details:\n\nhttps://docs.soliditylang.org/en/v0.8.16/natspec-format.html\n\nHere are some of the instances entailed:\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/LooksRareProxy.sol#L107-L134\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L88-L269\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/LooksRareAggregator.sol#L51-L112\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/LooksRareAggregator.sol#L220-L251\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/TokenReceiver.sol\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/proxies/LooksRareProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {SignatureChecker} from \"../SignatureChecker.sol\";\nimport {IERC721} from \"../../contracts/interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../contracts/interfaces/IERC1155.sol\";\nimport {ILooksRareExchange} from \"@looksrare/contracts-exchange-v1/contracts/interfaces/ILooksRareExchange.sol\";\nimport {OrderTypes} from \"@looksrare/contracts-exchange-v1/contracts/libraries/OrderTypes.sol\";\n\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\nimport {TokenTransferrer} from \"../TokenTransferrer.sol\";\n\n/**\n * @title LooksRareProxy\n * @notice This contract allows NFT sweepers to batch buy NFTs from LooksRare\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareProxy is IProxy, TokenRescuer, TokenTransferrer, SignatureChecker {\n    struct OrderExtraData {\n        uint256 makerAskPrice; // Maker ask price, which is not necessarily equal to the taker bid price\n        uint256 minPercentageToAsk; // The maker's minimum % to receive from the sale\n        uint256 nonce; // The maker's nonce\n        address strategy; // LooksRare execution strategy\n    }\n\n    ILooksRareExchange public immutable marketplace;\n    address public immutable aggregator;\n\n    /**\n     * @param _marketplace LooksRareExchange's address\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _marketplace, address _aggregator) {\n        marketplace = ILooksRareExchange(_marketplace);\n        aggregator = _aggregator;\n    }\n\n    /**\n     * @notice Execute LooksRare NFT sweeps in a single transaction\n     * @dev extraData, feeBp and feeRecipient are not used\n     * @param orders Orders to be executed by LooksRare\n     * @param ordersExtraData Extra data for each order\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes memory,\n        address recipient,\n        bool isAtomic,\n        uint256,\n        address\n    ) external payable override {\n        if (address(this) != aggregator) revert InvalidCaller();\n\n        uint256 ordersLength = orders.length;\n        if (ordersLength == 0 || ordersLength != ordersExtraData.length) revert InvalidOrderLength();\n\n        for (uint256 i; i < ordersLength; ) {\n            BasicOrder memory order = orders[i];\n\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n\n            OrderTypes.MakerOrder memory makerAsk;\n            {\n                makerAsk.isOrderAsk = true;\n                makerAsk.signer = order.signer;\n                makerAsk.collection = order.collection;\n                makerAsk.tokenId = order.tokenIds[0];\n                makerAsk.price = orderExtraData.makerAskPrice;\n                makerAsk.amount = order.amounts[0];\n                makerAsk.strategy = orderExtraData.strategy;\n                makerAsk.nonce = orderExtraData.nonce;\n                makerAsk.minPercentageToAsk = orderExtraData.minPercentageToAsk;\n                makerAsk.currency = order.currency;\n                makerAsk.startTime = order.startTime;\n                makerAsk.endTime = order.endTime;\n\n                (bytes32 r, bytes32 s, uint8 v) = _splitSignature(order.signature);\n                makerAsk.v = v;\n                makerAsk.r = r;\n                makerAsk.s = s;\n            }\n\n            OrderTypes.TakerOrder memory takerBid;\n            {\n                takerBid.isOrderAsk = false;\n                takerBid.taker = address(this);\n                takerBid.price = order.price;\n                takerBid.tokenId = makerAsk.tokenId;\n                takerBid.minPercentageToAsk = makerAsk.minPercentageToAsk;\n            }\n\n            _executeSingleOrder(takerBid, makerAsk, recipient, order.collectionType, isAtomic);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _executeSingleOrder(\n        OrderTypes.TakerOrder memory takerBid,\n        OrderTypes.MakerOrder memory makerAsk,\n        address recipient,\n        CollectionType collectionType,\n        bool isAtomic\n    ) private {\n        if (isAtomic) {\n            marketplace.matchAskWithTakerBidUsingETHAndWETH{value: takerBid.price}(takerBid, makerAsk);\n            _transferTokenToRecipient(\n                collectionType,\n                recipient,\n                makerAsk.collection,\n                makerAsk.tokenId,\n                makerAsk.amount\n            );\n        } else {\n            try marketplace.matchAskWithTakerBidUsingETHAndWETH{value: takerBid.price}(takerBid, makerAsk) {\n                _transferTokenToRecipient(\n                    collectionType,\n                    recipient,\n                    makerAsk.collection,\n                    makerAsk.tokenId,\n                    makerAsk.amount\n                );\n            } catch {}\n        }\n    }\n}"
    },
    {
      "filename": "contracts/proxies/SeaportProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {ItemType, OrderType} from \"../libraries/seaport/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, OrderParameters, OfferItem, ConsiderationItem, FulfillmentComponent, AdditionalRecipient} from \"../libraries/seaport/ConsiderationStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {SeaportInterface} from \"../interfaces/SeaportInterface.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\n\n/**\n * @title SeaportProxy\n * @notice This contract allows NFT sweepers to batch buy NFTs from Seaport\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract SeaportProxy is IProxy, TokenRescuer {\n    SeaportInterface public immutable marketplace;\n    address public immutable aggregator;\n\n    error TradeExecutionFailed();\n\n    struct ExtraData {\n        FulfillmentComponent[][] offerFulfillments; // Contains the order and item index of each offer item\n        FulfillmentComponent[][] considerationFulfillments; // Contains the order and item index of each consideration item\n    }\n\n    struct OrderExtraData {\n        uint120 numerator; // A fraction to attempt to fill\n        uint120 denominator; // The total size of the order\n        OrderType orderType; // Seaport order type\n        address zone; // A zone can cancel the order or restrict who can fulfill the order depending on the type\n        bytes32 zoneHash; // An arbitrary 32-byte value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order\n        uint256 salt; // An arbitrary source of entropy for the order\n        bytes32 conduitKey; // A bytes32 value that indicates what conduit, if any, should be utilized as a source for token approvals when performing transfers\n        AdditionalRecipient[] recipients; // Recipients of consideration items\n    }\n\n    /**\n     * @param _marketplace Seaport's address\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _marketplace, address _aggregator) {\n        marketplace = SeaportInterface(_marketplace);\n        aggregator = _aggregator;\n    }\n\n    /**\n     * @notice Execute Seaport NFT sweeps in a single transaction\n     * @param orders Orders to be executed by Seaport\n     * @param ordersExtraData Extra data for each order\n     * @param extraData Extra data for the whole transaction\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     * @param feeBp Fee basis point to pay for the trade, set by the aggregator\n     * @param feeRecipient Fee recipient for the trade, set by the aggregator\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        bool isAtomic,\n        uint256 feeBp,\n        address feeRecipient\n    ) external payable override {\n        if (address(this) != aggregator) revert InvalidCaller();\n\n        uint256 ordersLength = orders.length;\n        if (ordersLength == 0 || ordersLength != ordersExtraData.length) revert InvalidOrderLength();\n\n        if (isAtomic) {\n            _executeAtomicOrders(orders, ordersExtraData, extraData, recipient, feeBp, feeRecipient);\n        } else {\n            _executeNonAtomicOrders(orders, ordersExtraData, recipient, feeBp, feeRecipient);\n        }\n    }\n\n    /**\n     * @dev If fulfillAvailableAdvancedOrders fails, the ETH paid to Seaport\n     *      is refunded to the proxy contract. The proxy then has to refund\n     *      the ETH back to the user through _returnETHIfAny.\n     */\n    receive() external payable {}\n\n    function _executeAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 ordersLength = orders.length;\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](ordersLength);\n        ExtraData memory extraDataStruct = abi.decode(extraData, (ExtraData));\n\n        uint256 ethValue;\n\n        for (uint256 i; i < ordersLength; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            advancedOrders[i].parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrders[i].numerator = orderExtraData.numerator;\n            advancedOrders[i].denominator = orderExtraData.denominator;\n            advancedOrders[i].signature = orders[i].signature;\n\n            if (orders[i].currency == address(0)) ethValue += orders[i].price;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        (bool[] memory availableOrders, ) = marketplace.fulfillAvailableAdvancedOrders{value: ethValue}(\n            advancedOrders,\n            new CriteriaResolver[](0),\n            extraDataStruct.offerFulfillments,\n            extraDataStruct.considerationFulfillments,\n            bytes32(0),\n            recipient,\n            ordersLength\n        );\n\n        for (uint256 i; i < availableOrders.length; ) {\n            if (!availableOrders[i]) revert TradeExecutionFailed();\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (feeRecipient != address(0)) _handleFees(orders, feeBp, feeRecipient);\n    }\n\n    function _handleFees(\n        BasicOrder[] calldata orders,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        address lastOrderCurrency;\n        uint256 fee;\n        uint256 ordersLength = orders.length;\n\n        for (uint256 i; i < ordersLength; ) {\n            address currency = orders[i].currency;\n            uint256 orderFee = (orders[i].price * feeBp) / 10000;\n\n            if (currency == lastOrderCurrency) {\n                fee += orderFee;\n            } else {\n                if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                lastOrderCurrency = currency;\n                fee = orderFee;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _transferFee(\n        uint256 fee,\n        address lastOrderCurrency,\n        address recipient\n    ) private {\n        if (lastOrderCurrency == address(0)) {\n            _transferETH(recipient, fee);\n        } else {\n            _executeERC20DirectTransfer(lastOrderCurrency, recipient, fee);\n        }\n    }\n\n    function _executeNonAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 fee;\n        address lastOrderCurrency;\n        for (uint256 i; i < orders.length; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            AdvancedOrder memory advancedOrder;\n            advancedOrder.parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrder.numerator = orderExtraData.numerator;\n            advancedOrder.denominator = orderExtraData.denominator;\n            advancedOrder.signature = orders[i].signature;\n\n            address currency = orders[i].currency;\n            uint256 price = orders[i].price;\n\n            try\n                marketplace.fulfillAdvancedOrder{value: currency == address(0) ? price : 0}(\n                    advancedOrder,\n                    new CriteriaResolver[](0),\n                    bytes32(0),\n                    recipient\n                )\n            {\n                if (feeRecipient != address(0)) {\n                    uint256 orderFee = (price * feeBp) / 10000;\n                    if (currency == lastOrderCurrency) {\n                        fee += orderFee;\n                    } else {\n                        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                        lastOrderCurrency = currency;\n                        fee = orderFee;\n                    }\n                }\n            } catch {}\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _populateParameters(BasicOrder calldata order, OrderExtraData memory orderExtraData)\n        private\n        pure\n        returns (OrderParameters memory parameters)\n    {\n        uint256 recipientsLength = orderExtraData.recipients.length;\n\n        parameters.offerer = order.signer;\n        parameters.zone = orderExtraData.zone;\n        parameters.zoneHash = orderExtraData.zoneHash;\n        parameters.salt = orderExtraData.salt;\n        parameters.conduitKey = orderExtraData.conduitKey;\n        parameters.orderType = orderExtraData.orderType;\n        parameters.startTime = order.startTime;\n        parameters.endTime = order.endTime;\n        parameters.totalOriginalConsiderationItems = recipientsLength;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        // Seaport enums start with NATIVE and ERC20 so plus 2\n        offer[0].itemType = ItemType(uint8(order.collectionType) + 2);\n        offer[0].token = order.collection;\n        offer[0].identifierOrCriteria = order.tokenIds[0];\n        uint256 amount = order.amounts[0];\n        offer[0].startAmount = amount;\n        offer[0].endAmount = amount;\n        parameters.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](recipientsLength);\n        for (uint256 j; j < recipientsLength; ) {\n            // We don't need to assign value to identifierOrCriteria as it is always 0.\n            uint256 recipientAmount = orderExtraData.recipients[j].amount;\n            consideration[j].startAmount = recipientAmount;\n            consideration[j].endAmount = recipientAmount;\n            consideration[j].recipient = payable(orderExtraData.recipients[j].recipient);\n            consideration[j].itemType = order.currency == address(0) ? ItemType.NATIVE : ItemType.ERC20;\n            consideration[j].token = order.currency;\n\n            unchecked {\n                ++j;\n            }\n        }\n        parameters.consideration = consideration;\n    }\n}"
    },
    {
      "filename": "contracts/LooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"./lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC721Transfer} from \"./lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"./lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {BasicOrder, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenRescuer,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to this contract\n     *         directly. Transactions that involve ERC20 orders should be submitted to the contract\n     *         ERC20EnabledLooksRareAggregator and it will call this contract's execution function.\n     *         The purpose is to prevent a malicious proxy from stealing users' ERC20 tokens if\n     *         this contract's ownership is compromised. By not providing any allowances to this\n     *         aggregator, even if a malicious proxy is added, it cannot call\n     *         token.transferFrom(victim, attacker, amount) inside the proxy within the context of the\n     *         aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => bool)) private _proxyFunctionSelectors;\n    mapping(address => FeeData) private _proxyFeeData;\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) revert ZeroAddress();\n        uint256 tradeDataLength = tradeData.length;\n        if (tradeDataLength == 0) revert InvalidOrderLength();\n\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        if (tokenTransfersLength == 0) {\n            originator = msg.sender;\n        } else if (msg.sender != erc20EnabledLooksRareAggregator) {\n            revert UseERC20EnabledLooksRareAggregator();\n        }\n\n        for (uint256 i; i < tradeDataLength; ) {\n            TradeData calldata singleTradeData = tradeData[i];\n            if (!_proxyFunctionSelectors[singleTradeData.proxy][singleTradeData.selector]) revert InvalidFunction();\n\n            (bytes memory proxyCalldata, bool maxFeeBpViolated) = _encodeCalldataAndValidateFeeBp(\n                singleTradeData,\n                recipient,\n                isAtomic\n            );\n            if (maxFeeBpViolated) {\n                if (isAtomic) {\n                    revert FeeTooHigh();\n                } else {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n            (bool success, bytes memory returnData) = singleTradeData.proxy.delegatecall(proxyCalldata);\n\n            if (!success) {\n                if (isAtomic) {\n                    if (returnData.length > 0) {\n                        assembly {\n                            let returnDataSize := mload(returnData)\n                            revert(add(32, returnData), returnDataSize)\n                        }\n                    } else {\n                        revert TradeExecutionFailed();\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (tokenTransfersLength > 0) _returnERC20TokensIfAny(tokenTransfers, originator);\n        _returnETHIfAny(originator);\n\n        emit Sweep(originator);\n    }\n\n    /**\n     * @notice Enable making ERC20 trades by setting the ERC20 enabled LooksRare aggregator\n     * @dev Must be called by the current owner. It can only be set once to prevent\n     *      a malicious aggregator from being set in case of an ownership compromise.\n     * @param _erc20EnabledLooksRareAggregator The ERC20 enabled LooksRare aggregator's address\n     */\n    function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n        if (erc20EnabledLooksRareAggregator != address(0)) revert AlreadySet();\n        erc20EnabledLooksRareAggregator = _erc20EnabledLooksRareAggregator;\n        emit ERC20EnabledLooksRareAggregatorSet();\n    }\n\n    /**\n     * @notice Enable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n        _proxyFunctionSelectors[proxy][selector] = true;\n        emit FunctionAdded(proxy, selector);\n    }\n\n    /**\n     * @notice Disable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n        delete _proxyFunctionSelectors[proxy][selector];\n        emit FunctionRemoved(proxy, selector);\n    }\n\n    /**\n     * @param proxy Proxy to apply the fee to\n     * @param bp Fee basis point\n     * @param recipient Fee recipient\n     */\n    function setFee(\n        address proxy,\n        uint256 bp,\n        address recipient\n    ) external onlyOwner {\n        if (bp > 10000) revert FeeTooHigh();\n        _proxyFeeData[proxy].bp = bp;\n        _proxyFeeData[proxy].recipient = recipient;\n\n        emit FeeUpdated(proxy, bp, recipient);\n    }\n\n    /**\n     * @notice Approve marketplaces to transfer ERC20 tokens from the aggregator\n     * @param marketplace The marketplace address to approve\n     * @param currency The ERC20 token address to approve\n     * @param amount The amount of ERC20 token to approve\n     */\n    function approve(\n        address marketplace,\n        address currency,\n        uint256 amount\n    ) external onlyOwner {\n        _executeERC20Approve(currency, marketplace, amount);\n    }\n\n    /**\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     * @return Whether the marketplace proxy's function can be called from the aggregator\n     */\n    function supportsProxyFunction(address proxy, bytes4 selector) external view returns (bool) {\n        return _proxyFunctionSelectors[proxy][selector];\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC721 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC721 token to rescue from the contract\n     * @param tokenId The token ID of the ERC721 token to rescue from the contract\n     * @param to Send the contract's specified ERC721 token ID to this address\n     */\n    function rescueERC721(\n        address collection,\n        address to,\n        uint256 tokenId\n    ) external onlyOwner {\n        _executeERC721TransferFrom(collection, address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC1155 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC1155 token to rescue from the contract\n     * @param tokenIds The token IDs of the ERC1155 token to rescue from the contract\n     * @param amounts The amount of each token ID to rescue\n     * @param to Send the contract's specified ERC1155 token ID to this address\n     */\n    function rescueERC1155(\n        address collection,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        _executeERC1155SafeBatchTransferFrom(collection, address(this), to, tokenIds, amounts);\n    }\n\n    receive() external payable {}\n\n    function _encodeCalldataAndValidateFeeBp(\n        TradeData calldata singleTradeData,\n        address recipient,\n        bool isAtomic\n    ) private view returns (bytes memory proxyCalldata, bool maxFeeBpViolated) {\n        FeeData memory feeData = _proxyFeeData[singleTradeData.proxy];\n        maxFeeBpViolated = singleTradeData.maxFeeBp < feeData.bp;\n        proxyCalldata = abi.encodeWithSelector(\n            singleTradeData.selector,\n            singleTradeData.orders,\n            singleTradeData.ordersExtraData,\n            singleTradeData.extraData,\n            recipient,\n            isAtomic,\n            feeData.bp,\n            feeData.recipient\n        );\n    }\n\n    function _returnERC20TokensIfAny(TokenTransfer[] calldata tokenTransfers, address recipient) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tokenTransfersLength; ) {\n            uint256 balance = IERC20(tokenTransfers[i].currency).balanceOf(address(this));\n            if (balance > 0) _executeERC20DirectTransfer(tokenTransfers[i].currency, recipient, balance);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/LooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"./lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC721Transfer} from \"./lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"./lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {BasicOrder, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenRescuer,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to this contract\n     *         directly. Transactions that involve ERC20 orders should be submitted to the contract\n     *         ERC20EnabledLooksRareAggregator and it will call this contract's execution function.\n     *         The purpose is to prevent a malicious proxy from stealing users' ERC20 tokens if\n     *         this contract's ownership is compromised. By not providing any allowances to this\n     *         aggregator, even if a malicious proxy is added, it cannot call\n     *         token.transferFrom(victim, attacker, amount) inside the proxy within the context of the\n     *         aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => bool)) private _proxyFunctionSelectors;\n    mapping(address => FeeData) private _proxyFeeData;\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) revert ZeroAddress();\n        uint256 tradeDataLength = tradeData.length;\n        if (tradeDataLength == 0) revert InvalidOrderLength();\n\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        if (tokenTransfersLength == 0) {\n            originator = msg.sender;\n        } else if (msg.sender != erc20EnabledLooksRareAggregator) {\n            revert UseERC20EnabledLooksRareAggregator();\n        }\n\n        for (uint256 i; i < tradeDataLength; ) {\n            TradeData calldata singleTradeData = tradeData[i];\n            if (!_proxyFunctionSelectors[singleTradeData.proxy][singleTradeData.selector]) revert InvalidFunction();\n\n            (bytes memory proxyCalldata, bool maxFeeBpViolated) = _encodeCalldataAndValidateFeeBp(\n                singleTradeData,\n                recipient,\n                isAtomic\n            );\n            if (maxFeeBpViolated) {\n                if (isAtomic) {\n                    revert FeeTooHigh();\n                } else {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n            (bool success, bytes memory returnData) = singleTradeData.proxy.delegatecall(proxyCalldata);\n\n            if (!success) {\n                if (isAtomic) {\n                    if (returnData.length > 0) {\n                        assembly {\n                            let returnDataSize := mload(returnData)\n                            revert(add(32, returnData), returnDataSize)\n                        }\n                    } else {\n                        revert TradeExecutionFailed();\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (tokenTransfersLength > 0) _returnERC20TokensIfAny(tokenTransfers, originator);\n        _returnETHIfAny(originator);\n\n        emit Sweep(originator);\n    }\n\n    /**\n     * @notice Enable making ERC20 trades by setting the ERC20 enabled LooksRare aggregator\n     * @dev Must be called by the current owner. It can only be set once to prevent\n     *      a malicious aggregator from being set in case of an ownership compromise.\n     * @param _erc20EnabledLooksRareAggregator The ERC20 enabled LooksRare aggregator's address\n     */\n    function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n        if (erc20EnabledLooksRareAggregator != address(0)) revert AlreadySet();\n        erc20EnabledLooksRareAggregator = _erc20EnabledLooksRareAggregator;\n        emit ERC20EnabledLooksRareAggregatorSet();\n    }\n\n    /**\n     * @notice Enable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n        _proxyFunctionSelectors[proxy][selector] = true;\n        emit FunctionAdded(proxy, selector);\n    }\n\n    /**\n     * @notice Disable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n        delete _proxyFunctionSelectors[proxy][selector];\n        emit FunctionRemoved(proxy, selector);\n    }\n\n    /**\n     * @param proxy Proxy to apply the fee to\n     * @param bp Fee basis point\n     * @param recipient Fee recipient\n     */\n    function setFee(\n        address proxy,\n        uint256 bp,\n        address recipient\n    ) external onlyOwner {\n        if (bp > 10000) revert FeeTooHigh();\n        _proxyFeeData[proxy].bp = bp;\n        _proxyFeeData[proxy].recipient = recipient;\n\n        emit FeeUpdated(proxy, bp, recipient);\n    }\n\n    /**\n     * @notice Approve marketplaces to transfer ERC20 tokens from the aggregator\n     * @param marketplace The marketplace address to approve\n     * @param currency The ERC20 token address to approve\n     * @param amount The amount"
    }
  ]
}