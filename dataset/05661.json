{
  "Title": "[G-02] State variable read in a loop",
  "Content": "\nThe state variable should be cached in a local variable rather than reading it on every iteration of the `for-loop`, which will replace each Gwarmaccess (**100 gas**) with a much cheaper stack read.\n\nEstimated saving:\n| Method call or Contract deployment | Before | After | After - Before | (After - Before) / Before |\n| :- | :-: | :-: | :-: | :-: |\n| `LiquidityMiningPath` | 1540432 | 1538524 | -1908 | -0.12% |\n\nThere are 5 instances of this issue:\n\n[[87-97](https://github.com/code-423n4/2023-10-canto/blob/29c92a926453a49c8935025a4d3de449150fc2ff/canto_ambient/contracts/mixins/LiquidityMining.sol#L87-L97)]\n\n```diff\nFile: LiquidityMining.sol\n\n    uint256 liquidity = pos.liquidity_;\n+   uint256 wweek = WEEK;\n    for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n        uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n        uint32 origIndex = tickTrackingIndex;\n        uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n        uint32 time = lastAccrued;\n        // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n        while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n            TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n-              uint32 currWeek = uint32((time / WEEK) * WEEK);\n-              uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n+               uint32 currWeek = uint32((time / WEEK) * WEEK);\n+               uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-canto",
  "Code": [
    {
      "filename": "canto_ambient/contracts/mixins/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"./PositionRegistrar.sol\";\nimport \"./StorageLayout.sol\";\nimport \"./PoolRegistry.sol\";\n\n/* @title Liquidity mining mixin\n * @notice Contains the functions related to liquidity mining claiming. */\ncontract LiquidityMining is PositionRegistrar {\n    uint256 constant WEEK = 604800; // Week in seconds 604800\n\n    /// @notice Initialize the tick tracking for the first tick of a pool\n    function initTickTracking(bytes32 poolIdx, int24 tick) internal {\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][tick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the tick crossings\n    /// @dev Needs to be called whenever a tick is crossed\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the global in-range time-weighted concentrated liquidity per week\n    /// @dev Needs to be called whenever the concentrated liquidity is modified (tick crossed, positions changed)\n    function accrueConcentratedGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalConcLiquidityLastSet_[\n            poolIdx\n        ];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.concLiq_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalConcLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n    /// @dev Needs to be called whenever a position is modified\n    function accrueConcentratedPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal {\n        RangePosition72 storage pos = lookupPosition(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = pos.liquidity_;\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                uint32 origIndex = tickTrackingIndex;\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                uint32 time = lastAccrued;\n                // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                    TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                    uint32 currWeek = uint32((time / WEEK) * WEEK);\n                    uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                    uint32 dt = uint32(\n                        nextWeek < block.timestamp\n                            ? nextWeek - time\n                            : block.timestamp - time\n                    );\n                    uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                    uint32 tickActiveEnd;\n                    if (tickTracking.enterTimestamp < nextWeek) {\n                        // Tick was active before next week, need to add the liquidity\n                        if (tickTracking.enterTimestamp < time) {\n                            // Tick was already active when last claim happened, only accrue from last claim timestamp\n                            tickActiveStart = time;\n                        } else {\n                            // Tick has become active this week\n                            tickActiveStart = tickTracking.enterTimestamp;\n                        }\n                        if (tickTracking.exitTimestamp == 0) {\n                            // Tick still active, do not increase index because we need to continue from here\n                            tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                        } else {\n                            // Tick is no longer active\n                            if (tickTracking.exitTimestamp < nextWeek) {\n                                // Exit was in this week, continue with next tick\n                                tickActiveEnd = tickTracking.exitTimestamp;\n                                tickTrackingIndex++;\n                                dt = tickActiveEnd - tickActiveStart;\n                            } else {\n                                // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                tickActiveEnd = nextWeek;\n                            }\n                        }\n                        timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n                            (tickActiveEnd - tickActiveStart) * liquidity;\n                    }\n                    time += dt;\n                }\n                if (tickTrackingIndex != origIndex) {\n                    tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n                }\n            }\n        } else {\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                if (numTickTracking > 0) {\n                    if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n                        // Tick currently active\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n                    } else {\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n                    }\n                }\n            }\n        }\n        timeWeightedWeeklyPositionConcLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimConcentratedRewards(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick,\n        uint32[] memory weeksToClaim\n    ) internal {\n        accrueConcentratedPositionTimeWeightedLiquidity(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        // Need to do a global accrual in case the current tick was already in range for a long time without any modifications that triggered an accrual\n        accrueConcentratedGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !concLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallInRangeLiquidity = timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][week];\n            if (overallInRangeLiquidity > 0) {\n                uint256 inRangeLiquidityOfPosition;\n                for (int24 j = lowerTick + 10; j <= upperTick - 10; ++j) {\n                    inRangeLiquidityOfPosition += timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][week][j];\n                }\n                // Percentage of this weeks overall in range liquidity that was provided by the user times the overall weekly rewards\n                rewardsToSend += inRangeLiquidityOfPosition * concRewardPerWeek_[poolIdx][week] / overallInRangeLiquidity;\n            }\n            concLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n\n    function accrueAmbientGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.ambientSeeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalAmbLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    function accrueAmbientPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx\n    ) internal {\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint32 lastAccrued = timeWeightedWeeklyPositionAmbLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only init time on first call\n        if (lastAccrued != 0) {\n            AmbientPosition storage pos = lookupPosition(owner, poolIdx);\n            uint256 liquidity = pos.seeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyPositionAmbLiquidity_[poolIdx][posKey][\n                    currWeek\n                ] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyPositionAmbLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimAmbientRewards(\n        address owner,\n        bytes32 poolIdx,\n        uint32[] memory weeksToClaim\n    ) internal {\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        accrueAmbientPositionTimeWeightedLiquidity(payable(owner), poolIdx);\n        accrueAmbientGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !ambLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallTimeWeightedLiquidity = timeWeightedWeeklyGlobalAmbLiquidity_[\n                    poolIdx\n                ][week];\n            if (overallTimeWeightedLiquidity > 0) {\n                uint256 rewardsForWeek = (timeWeightedWeeklyPositionAmbLiquidity_[\n                    poolIdx\n                ][posKey][week] * ambRewardPerWeek_[poolIdx][week]) /\n                    overallTimeWeightedLiquidity;\n                rewardsToSend += rewardsForWeek;\n            }\n            ambLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n}"
    }
  ]
}