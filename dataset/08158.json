{
  "Title": "[G-02]  `storage` pointer to a structure is cheaper than copying each value of the structure into `memory`, same for `array` and `mapping` (7 instances)",
  "Content": "\nDeployment Gas Saved: **188 639**<br>\nMethod Call Gas Saved: **5 032**<br>\n\nIt may not be obvious, but every time you copy a storage `struct`/`array`/`mapping` to a `memory` variable, you are literally copying each member by reading it from `storage`, which is expensive. And when you use the `storage` keyword, you are just storing a pointer to the storage, which is much cheaper.\n\n*   src/Kernel.sol:[379](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L379)\n\n```solidity\n379        Policy[] memory dependents = moduleDependents[keycode_];\n```\n\nfix(the same for others):\n\n```solidity\nPolicy[] storage dependents = moduleDependents[keycode_];\n```\n\n*   src/policies/BondCallback.sol:[179](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L179)\n\n```solidity\n179        uint256[2] memory marketAmounts = _amountsPerMarket[id_];\n```\n\n*   src/policies/Governance.sol:[206](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L206)\n\n```solidity\n206        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n```\n\n*   src/policies/Operator.sol:[205-206](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L205-L206), [384-385](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L384-L385), [439-440](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L439-L440), [666](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L666)\n\n```solidity\n205        /// Cache config in memory\n206        Config memory config_ = _config;\n...\n384            /// Cache config struct to avoid multiple SLOADs\n385            Config memory config_ = _config;\n...\n439            /// Cache config struct to avoid multiple SLOADs\n440            Config memory config_ = _config;\n...\n666        Regen memory regen = _status.low;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/Kernel.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/utils/KernelUtils.sol\";\n\n// Kernel Adapter errors\nerror KernelAdapter_OnlyKernel(address caller_);\n\n// Module errors\nerror Module_PolicyNotPermitted(address policy_);\n\n// Policy errors\nerror Policy_OnlyRole(Role role_);\nerror Policy_ModuleDoesNotExist(Keycode keycode_);\n\n// Kernel errors\nerror Kernel_OnlyExecutor(address caller_);\nerror Kernel_OnlyAdmin(address caller_);\nerror Kernel_ModuleAlreadyInstalled(Keycode module_);\nerror Kernel_InvalidModuleUpgrade(Keycode module_);\nerror Kernel_PolicyAlreadyActivated(address policy_);\nerror Kernel_PolicyNotActivated(address policy_);\nerror Kernel_AddressAlreadyHasRole(address addr_, Role role_);\nerror Kernel_AddressDoesNotHaveRole(address addr_, Role role_);\nerror Kernel_RoleDoesNotExist(Role role_);\n\n/*//////////////////////////////////////////////////////////////\n                          GLOBAL TYPES\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\nenum Actions {\n    InstallModule,\n    UpgradeModule,\n    ActivatePolicy,\n    DeactivatePolicy,\n    ChangeExecutor,\n    ChangeAdmin,\n    MigrateKernel\n}\n\n/// @notice Used by executor to select an action and a target contract for a kernel action\nstruct Instruction {\n    Actions action;\n    address target;\n}\n\n/// @notice Used to define which module functions a policy needs access to\nstruct Permissions {\n    Keycode keycode;\n    bytes4 funcSelector;\n}\n\ntype Keycode is bytes5;\ntype Role is bytes32;\n\n/*//////////////////////////////////////////////////////////////\n                      COMPONENT ABSTRACTS\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Generic adapter interface for kernel access in modules and policies.\nabstract contract KernelAdapter {\n    Kernel public kernel;\n\n    constructor(Kernel kernel_) {\n        kernel = kernel_;\n    }\n\n    /// @notice Modifier to restrict functions to be called only by kernel.\n    modifier onlyKernel() {\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n        _;\n    }\n\n    /// @notice Function used by kernel when migrating to a new kernel.\n    function changeKernel(Kernel newKernel_) external onlyKernel {\n        kernel = newKernel_;\n    }\n}\n\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\n///         interacted with and mutated through policies.\n/// @dev    Modules are installed and uninstalled via the executor.\nabstract contract Module is KernelAdapter {\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict which policies have access to module functions.\n    modifier permissioned() {\n        if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig))\n            revert Module_PolicyNotPermitted(msg.sender);\n        _;\n    }\n\n    /// @notice 5 byte identifier for a module.\n    function KEYCODE() public pure virtual returns (Keycode) {}\n\n    /// @notice Returns which semantic version of a module is being implemented.\n    /// @return major - Major version upgrade indicates breaking change to the interface.\n    /// @return minor - Minor version change retains backward-compatible interface.\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n    /// @notice Initialization function for the module\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\n    function INIT() external virtual onlyKernel {}\n}\n\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\nabstract contract Policy is KernelAdapter {\n    /// @notice Denote if a policy is activated or not.\n    bool public isActive;\n\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict policy function access to certain addresses with a role.\n    /// @dev    Roles are defined in the policy and set by the kernel admin.\n    modifier onlyRole(bytes32 role_) {\n        Role role = toRole(role_);\n        if (!kernel.hasRole(msg.sender, role)) revert Policy_OnlyRole(role);\n        _;\n    }\n\n    /// @notice Function to let kernel grant or revoke active status.\n    function setActiveStatus(bool activate_) external onlyKernel {\n        isActive = activate_;\n    }\n\n    /// @notice Function to grab module address from a given keycode.\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n        return moduleForKeycode;\n    }\n\n    /// @notice Define module dependencies for this policy.\n    /// @return dependencies - Keycode array of module dependencies.\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\n\n    /// @notice Function called by kernel to set module function permissions.\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\n}\n\n/// @notice Main contract that acts as a central component registry for the protocol.\n/// @dev    The kernel manages modules, policies and defined roles. The kernel is mutated via predefined Actions,\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\ncontract Kernel {\n    /*//////////////////////////////////////////////////////////////\n                          PRIVILEGED ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\n    address public executor;\n\n    /// @notice Address that is responsible for assigning policy-defined roles to addresses.\n    address public admin;\n\n    /*//////////////////////////////////////////////////////////////\n                           MODULE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Array of all modules currently installed.\n    Keycode[] public allKeycodes;\n\n    /// @notice Mapping of module address to keycode.\n    mapping(Keycode => Module) public getModuleForKeycode;\n\n    /// @notice Mapping of keycode to module address.\n    mapping(Module => Keycode) public getKeycodeForModule;\n\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\n    mapping(Keycode => Policy[]) public moduleDependents;\n\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n\n    /// @notice Module <> Policy Permissions.\n    /// @dev    Policy -> Keycode -> Function Selector -> bool for permission\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\n\n    /*//////////////////////////////////////////////////////////////\n                           POLICY MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice List of all active policies\n    Policy[] public activePolicies;\n\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\n    mapping(Policy => uint256) public getPolicyIndex;\n\n    /// @notice Mapping for if an address has a policy-defined role.\n    mapping(address => mapping(Role => bool)) public hasRole;\n\n    /// @notice Mapping for if role exists.\n    mapping(Role => bool) public isRole;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PermissionsUpdated(\n        Keycode indexed keycode_,\n        Policy indexed policy_,\n        bytes4 funcSelector_,\n        bool granted_\n    );\n    event RoleGranted(Role indexed role_, address indexed addr_);\n    event RoleRevoked(Role indexed role_, address indexed addr_);\n    event ActionExecuted(Actions indexed action_, address indexed target_);\n\n    /*//////////////////////////////////////////////////////////////\n                              KERNEL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        executor = msg.sender;\n        admin = msg.sender;\n    }\n\n    /// @notice Modifier to check if caller is the executor.\n    modifier onlyExecutor() {\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n        _;\n    }\n\n    /// @notice Modifier to check if caller is the roles admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) revert Kernel_OnlyAdmin(msg.sender);\n        _;\n    }\n\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\n    function executeAction(Actions action_, address target_) external onlyExecutor {\n        if (action_ == Actions.InstallModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _installModule(Module(target_));\n        } else if (action_ == Actions.UpgradeModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _upgradeModule(Module(target_));\n        } else if (action_ == Actions.ActivatePolicy) {\n            ensureContract(target_);\n            _activatePolicy(Policy(target_));\n        } else if (action_ == Actions.DeactivatePolicy) {\n            ensureContract(target_);\n            _deactivatePolicy(Policy(target_));\n        } else if (action_ == Actions.ChangeExecutor) {\n            executor = target_;\n        } else if (action_ == Actions.ChangeAdmin) {\n            admin = target_;\n        } else if (action_ == Actions.MigrateKernel) {\n            ensureContract(target_);\n            _migrateKernel(Kernel(target_));\n        }\n\n        emit ActionExecuted(action_, target_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ACTIONS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _installModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n\n        if (address(getModuleForKeycode[keycode]) != address(0))\n            revert Kernel_ModuleAlreadyInstalled(keycode);\n\n        getModuleForKeycode[keycode] = newModule_;\n        getKeycodeForModule[newModule_] = keycode;\n        allKeycodes.push(keycode);\n\n        newModule_.INIT();\n    }\n\n    function _upgradeModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n        Module oldModule = getModuleForKeycode[keycode];\n\n        if (address(oldModule) == address(0) || oldModule == newModule_)\n            revert Kernel_InvalidModuleUpgrade(keycode);\n\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n        getKeycodeForModule[newModule_] = keycode;\n        getModuleForKeycode[keycode] = newModule_;\n\n        newModule_.INIT();\n\n        _reconfigurePolicies(keycode);\n    }\n\n    function _activatePolicy(Policy policy_) internal {\n        if (policy_.isActive()) revert Kernel_PolicyAlreadyActivated(address(policy_));\n\n        // Add policy to list of active policies\n        activePolicies.push(policy_);\n        getPolicyIndex[policy_] = activePolicies.length - 1;\n\n        // Record module dependencies\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depLength = dependencies.length;\n\n        for (uint256 i; i < depLength; ) {\n            Keycode keycode = dependencies[i];\n\n            moduleDependents[keycode].push(policy_);\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Grant permissions for policy to access restricted module functions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, true);\n\n        // Set policy status to active\n        policy_.setActiveStatus(true);\n    }\n\n    function _deactivatePolicy(Policy policy_) internal {\n        if (!policy_.isActive()) revert Kernel_PolicyNotActivated(address(policy_));\n\n        // Revoke permissions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, false);\n\n        // Remove policy from all policy data structures\n        uint256 idx = getPolicyIndex[policy_];\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\n\n        activePolicies[idx] = lastPolicy;\n        activePolicies.pop();\n        getPolicyIndex[lastPolicy] = idx;\n        delete getPolicyIndex[policy_];\n\n        // Remove policy from module dependents\n        _pruneFromDependents(policy_);\n\n        // Set policy status to inactive\n        policy_.setActiveStatus(false);\n    }\n\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\n    /// @dev    NOTE: Data does not get cleared from this kernel.\n    function _migrateKernel(Kernel newKernel_) internal {\n        uint256 keycodeLen = allKeycodes.length;\n        for (uint256 i; i < keycodeLen; ) {\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n            module.changeKernel(newKernel_);\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 policiesLen = activePolicies.length;\n        for (uint256 j; j < policiesLen; ) {\n            Policy policy = activePolicies[j];\n\n            // Deactivate before changing kernel\n            policy.setActiveStatus(false);\n            policy.changeKernel(newKernel_);\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _reconfigurePolicies(Keycode keycode_) internal {\n        Policy[] memory dependents = moduleDependents[keycode_];\n        uint256 depLength = dependents.length;\n\n        for (uint256 i; i < depLength; ) {\n            dependents[i].configureDependencies();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _setPolicyPermissions(\n        Policy policy_,\n        Permissions[] memory requests_,\n        bool grant_\n    ) internal {\n        uint256 reqLength = requests_.length;\n        for (uint256 i = 0; i < reqLength; ) {\n            Permissions memory request = requests_[i];\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _pruneFromDependents(Policy policy_) internal {\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depcLength = dependencies.length;\n\n        for (uint256 i; i < depcLength; ) {\n            Keycode keycode = dependencies[i];\n            Policy[] storage dependents = moduleDependents[keycode];\n\n            uint256 origIndex = getDependentIndex[keycode][policy_];\n            Policy lastPolicy = dependents[dependents.length - 1];\n\n            // Swap with last and pop\n            dependents[origIndex] = lastPolicy;\n            dependents.pop();\n\n            // Record new index and delete deactivated policy index\n            getDependentIndex[keycode][lastPolicy] = origIndex;\n            delete getDependentIndex[keycode][policy_];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ROLES ADMIN FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Function to grant policy-defined roles to some address. Can only be called by admin.\n    function grantRole(Role role_, address addr_) public onlyAdmin {\n        if (hasRole[addr_][role_]) revert Kernel_AddressAlreadyHasRole(addr_, role_);\n\n        ensureValidRole(role_);\n        if (!isRole[role_]) isRole[role_] = true;\n\n        hasRole[addr_][role_] = true;\n\n        emit RoleGranted(role_, addr_);\n    }\n\n    /// @notice Function to revoke policy-defined roles from some address. Can only be called by admin.\n    function revokeRole(Role role_, address addr_) public onlyAdmin {\n        if (!isRole[role_]) revert Kernel_RoleDoesNotExist(role_);\n        if (!hasRole[addr_][role_]) revert Kernel_AddressDoesNotHaveRole(addr_, role_);\n\n        hasRole[addr_][role_] = false;\n\n        emit RoleRevoked(role_, addr_);\n    }\n}"
    },
    {
      "filename": "src/policies/BondCallback.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"interfaces/IBondAggregator.sol\";\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {Operator} from \"policies/Operator.sol\";\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\n/// @title Olympus Bond Callback\ncontract BondCallback is Policy, ReentrancyGuard, IBondCallback {\n    using TransferHelper for ERC20;\n\n    error Callback_MarketNotSupported(uint256 id);\n    error Callback_TokensNotReceived();\n    error Callback_InvalidParams();\n\n    mapping(address => mapping(uint256 => bool)) public approvedMarkets;\n    mapping(uint256 => uint256[2]) internal _amountsPerMarket;\n    mapping(ERC20 => uint256) public priorBalances;\n\n    IBondAggregator public aggregator;\n    OlympusTreasury public TRSRY;\n    OlympusMinter public MINTR;\n    Operator public operator;\n    ERC20 public ohm;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IBondAggregator aggregator_,\n        ERC20 ohm_\n    ) Policy(kernel_) {\n        aggregator = aggregator_;\n        ohm = ohm_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"TRSRY\");\n        dependencies[1] = toKeycode(\"MINTR\");\n\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[0]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[1]));\n\n        // Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](4);\n        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\n        requests[2] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[3] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBondCallback\n    function whitelist(address teller_, uint256 id_)\n        external\n        override\n        onlyRole(\"callback_whitelist\")\n    {\n        approvedMarkets[teller_][id_] = true;\n\n        // Get payout tokens for market\n        (, , ERC20 payoutToken, , , ) = aggregator.getAuctioneer(id_).getMarketInfoForPurchase(id_);\n\n        /// If payout token is not OHM, request approval from TRSRY for withdrawals\n        if (address(payoutToken) != address(ohm)) {\n            TRSRY.setApprovalFor(address(this), payoutToken, type(uint256).max);\n        }\n    }\n\n    /// @inheritdoc IBondCallback\n    function callback(\n        uint256 id_,\n        uint256 inputAmount_,\n        uint256 outputAmount_\n    ) external override nonReentrant {\n        /// Confirm that the teller and market id are whitelisted\n        if (!approvedMarkets[msg.sender][id_]) revert Callback_MarketNotSupported(id_);\n\n        // Get tokens for market\n        (, , ERC20 payoutToken, ERC20 quoteToken, , ) = aggregator\n            .getAuctioneer(id_)\n            .getMarketInfoForPurchase(id_);\n\n        // Check that quoteTokens were transferred prior to the call\n        if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)\n            revert Callback_TokensNotReceived();\n\n        // Handle payout\n        if (quoteToken == payoutToken && quoteToken == ohm) {\n            // If OHM-OHM bond, only mint the difference and transfer back to teller\n            uint256 toMint = outputAmount_ - inputAmount_;\n            MINTR.mintOhm(address(this), toMint);\n\n            // Transfer payoutTokens to sender\n            payoutToken.safeTransfer(msg.sender, outputAmount_);\n        } else if (quoteToken == ohm) {\n            // If inverse bond (buying ohm), transfer payout tokens to sender\n            TRSRY.withdrawReserves(msg.sender, payoutToken, outputAmount_);\n\n            // Burn OHM received from sender\n            MINTR.burnOhm(address(this), inputAmount_);\n        } else if (payoutToken == ohm) {\n            // Else (selling ohm), mint OHM to sender\n            MINTR.mintOhm(msg.sender, outputAmount_);\n        } else {\n            // Revert since this callback only handles OHM bonds\n            revert Callback_MarketNotSupported(id_);\n        }\n\n        // Store amounts in/out.\n        // Updated after internal call so previous balances are available to check against\n        priorBalances[quoteToken] = quoteToken.balanceOf(address(this));\n        priorBalances[payoutToken] = payoutToken.balanceOf(address(this));\n        _amountsPerMarket[id_][0] += inputAmount_;\n        _amountsPerMarket[id_][1] += outputAmount_;\n\n        // Check if the market is deployed by range operator and update capacity if so\n        operator.bondPurchase(id_, outputAmount_);\n    }\n\n    /// @notice Send tokens to the TRSRY in a batch\n    /// @param  tokens_ - Array of tokens to send\n    function batchToTreasury(ERC20[] memory tokens_) external onlyRole(\"callback_admin\") {\n        ERC20 token;\n        uint256 balance;\n        uint256 len = tokens_.length;\n        for (uint256 i; i < len; ) {\n            token = tokens_[i];\n            balance = token.balanceOf(address(this));\n            token.safeTransfer(address(TRSRY), balance);\n            priorBalances[token] = token.balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBondCallback\n    function amountsForMarket(uint256 id_)\n        external\n        view\n        override\n        returns (uint256 in_, uint256 out_)\n    {\n        uint256[2] memory marketAmounts = _amountsPerMarket[id_];\n        return (marketAmounts[0], marketAmounts[1]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the operator contract for the callback to use to report bond purchases\n    /// @notice Must be set before the callback is used\n    /// @param  operator_ - Address of the Operator contract\n    function setOperator(Operator operator_) external onlyRole(\"callback_admin\") {\n        if (address(operator_) == address(0)) revert Callback_InvalidParams();\n        operator = operator_;\n    }\n}"
    },
    {
      "filename": "src/policies/Governance.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// The Governance Policy submits & activates instructions in a INSTR module\n\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n// proposing\nerror NotEnoughVotesToPropose();\n\n// endorsing\nerror CannotEndorseNullProposal();\nerror CannotEndorseInvalidProposal();\n\n// activating\nerror NotAuthorizedToActivateProposal();\nerror NotEnoughEndorsementsToActivateProposal();\nerror ProposalAlreadyActivated();\nerror ActiveProposalNotExpired();\nerror SubmittedProposalHasExpired();\n\n// voting\nerror NoActiveProposalDetected();\nerror UserAlreadyVoted();\n\n// executing\nerror NotEnoughVotesToExecute();\nerror ExecutionTimelockStillActive();\n\n// claiming\nerror VotingTokensAlreadyReclaimed();\nerror CannotReclaimTokensForActiveVote();\nerror CannotReclaimZeroVotes();\n\nstruct ProposalMetadata {\n    bytes32 title;\n    address submitter;\n    uint256 submissionTimestamp;\n    string proposalURI;\n}\n\nstruct ActivatedProposal {\n    uint256 proposalId;\n    uint256 activationTimestamp;\n}\n\n/// @notice OlympusGovernance\n/// @dev The Governor Policy is also the Kernel's Executor.\ncontract OlympusGovernance is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    OlympusInstructions public INSTR;\n    OlympusVotes public VOTES;\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"INSTR\");\n        dependencies[1] = toKeycode(\"VOTES\");\n\n        INSTR = OlympusInstructions(getModuleAddress(dependencies[0]));\n        VOTES = OlympusVotes(getModuleAddress(dependencies[1]));\n    }\n\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n        requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                             Policy Variables                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    event ProposalSubmitted(uint256 proposalId);\n    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);\n    event ProposalActivated(uint256 proposalId, uint256 timestamp);\n    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);\n    event ProposalExecuted(uint256 proposalId);\n\n    /// @notice The currently activated proposal in the governance system.\n    ActivatedProposal public activeProposal;\n\n    /// @notice Return a proposal metadata object for a given proposal id.\n    mapping(uint256 => ProposalMetadata) public getProposalMetadata;\n\n    /// @notice Return the total endorsements for a proposal id.\n    mapping(uint256 => uint256) public totalEndorsementsForProposal;\n\n    /// @notice Return the number of endorsements a user has given a proposal id.\n    mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal;\n\n    /// @notice Return whether a proposal id has been activated. Once this is true, it should never be flipped false.\n    mapping(uint256 => bool) public proposalHasBeenActivated;\n\n    /// @notice Return the total yes votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public yesVotesForProposal;\n\n    /// @notice Return the total no votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public noVotesForProposal;\n\n    /// @notice Return the amount of votes a user has applied to a proposal id. This does not record how the user voted.\n    mapping(uint256 => mapping(address => uint256)) public userVotesForProposal;\n\n    /// @notice Return the amount of tokens reclaimed by a user after voting on a proposal id.\n    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\n\n    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n    /// @dev    This is set to 1% of the total supply.\n    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n\n    /// @notice Amount of time a submitted proposal has to activate before it expires.\n    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n\n    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n\n    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n    uint256 public constant EXECUTION_THRESHOLD = 33;\n\n    /// @notice Required time for a proposal to be active before it can be executed.\n    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                               User Actions                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the metadata for a proposal.\n    /// @dev    Used to return & access the entire metadata struct in solidity\n    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {\n        return getProposalMetadata[proposalId_];\n    }\n\n    /// @notice Return the currently active proposal in governance.\n    /// @dev    Used to return & access the entire struct active proposal struct in solidity.\n    function getActiveProposal() public view returns (ActivatedProposal memory) {\n        return activeProposal;\n    }\n\n    /// @notice Submit an on chain governance proposal.\n    /// @param  instructions_ - an array of Instruction objects each containing a Kernel Action and a target Contract address.\n    /// @param  title_ - a human-readable title of the proposal â€” i.e. \"OIP XX - My Proposal Title\".\n    /// @param  proposalURI_ - an arbitrary url linking to a human-readable description of the proposal - i.e. Snapshot, Discourse, Google Doc.\n    function submitProposal(\n        Instruction[] calldata instructions_,\n        bytes32 title_,\n        string memory proposalURI_\n    ) external {\n        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\n            revert NotEnoughVotesToPropose();\n\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n\n        emit ProposalSubmitted(proposalId);\n    }\n\n    /// @notice Endorse a proposal.\n    /// @param  proposalId_ - The ID of the proposal being endorsed.\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorse"
    }
  ]
}