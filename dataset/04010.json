{
  "Title": "[L10] Missing docstrings",
  "Content": "Some of the contracts and functions in Celo’s codebase lack documentation. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. Some examples of incomplete docstrings are:\n\n\n* The [`inflationFactor` parameter](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/stability/StableToken.sol#L394-L397) of the `_valueToUnits` function in the `StableToken` contract.\n* The [`index` parameter](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/identity/Attestations.sol#L697) of the `approveTransfer` function in the `Attestations` contract.\n* The [events](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/identity/Attestations.sol#L99-L135) located in the `Attestations` contract.\n* The new [`getTotalPendingWithdrawals` function](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/LockedGold.sol#L280) in the `LockedGold` contract.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update**: Partially fixed on [pull request 5041](https://github.com/celo-org/celo-monorepo/pull/5041/files). [Events of the `Attestations` contract](https://github.com/celo-org/celo-monorepo/blob/28004274b5fb68894fb93a645c9c2c6de8a76e81/packages/protocol/contracts/identity/Attestations.sol#L97-L115) still do not have documentation.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/stability/StableToken.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IStableToken.sol\";\nimport \"../common/interfaces/ICeloToken.sol\";\nimport \"../common/CalledByVm.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Freezable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title An ERC20 compliant token with adjustable supply.\n */\n// solhint-disable-next-line max-line-length\ncontract StableToken is\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  UsingPrecompiles,\n  Freezable,\n  CalledByVm,\n  IStableToken,\n  IERC20,\n  ICeloToken\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  event InflationFactorUpdated(uint256 factor, uint256 lastUpdated);\n\n  event InflationParametersUpdated(uint256 rate, uint256 updatePeriod, uint256 lastUpdated);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event TransferComment(string comment);\n\n  string internal name_;\n  string internal symbol_;\n  uint8 internal decimals_;\n\n  // Stored as units. Value can be found using unitsToValue().\n  mapping(address => uint256) internal balances;\n  uint256 internal totalSupply_;\n\n  // Stored as values. Units can be found using valueToUnits().\n  mapping(address => mapping(address => uint256)) internal allowed;\n\n  // STABILITY FEE PARAMETERS\n\n  // The `rate` is how much the `factor` is adjusted by per `updatePeriod`.\n  // The `factor` describes units/value of StableToken, and is greater than or equal to 1.\n  // The `updatePeriod` governs how often the `factor` is updated.\n  // `factorLastUpdated` indicates when the inflation factor was last updated.\n  struct InflationState {\n    FixidityLib.Fraction rate;\n    FixidityLib.Fraction factor;\n    uint256 updatePeriod;\n    uint256 factorLastUpdated;\n  }\n\n  InflationState inflationState;\n\n  /**\n   * @notice recomputes and updates inflation factor if more than `updatePeriod`\n   * has passed since last update.\n   */\n  modifier updateInflationFactor() {\n    FixidityLib.Fraction memory updatedInflationFactor;\n    uint256 lastUpdated;\n\n    (updatedInflationFactor, lastUpdated) = getUpdatedInflationFactor();\n\n    if (lastUpdated != inflationState.factorLastUpdated) {\n      inflationState.factor = updatedInflationFactor;\n      inflationState.factorLastUpdated = lastUpdated;\n      emit InflationFactorUpdated(inflationState.factor.unwrap(), inflationState.factorLastUpdated);\n    }\n    _;\n  }\n\n  /**\n   * @param _name The name of the stable token (English)\n   * @param _symbol A short symbol identifying the token (e.g. \"cUSD\")\n   * @param _decimals Tokens are divisible to this many decimal places.\n   * @param registryAddress Address of the Registry contract.\n   * @param inflationRate weekly inflation rate.\n   * @param inflationFactorUpdatePeriod how often the inflation factor is updated.\n   */\n  function initialize(\n    string calldata _name,\n    string calldata _symbol,\n    uint8 _decimals,\n    address registryAddress,\n    uint256 inflationRate,\n    uint256 inflationFactorUpdatePeriod,\n    address[] calldata initialBalanceAddresses,\n    uint256[] calldata initialBalanceValues\n  ) external initializer {\n    require(inflationRate != 0, \"Must provide a non-zero inflation rate\");\n    require(inflationFactorUpdatePeriod > 0, \"inflationFactorUpdatePeriod must be > 0\");\n\n    _transferOwnership(msg.sender);\n\n    totalSupply_ = 0;\n    name_ = _name;\n    symbol_ = _symbol;\n    decimals_ = _decimals;\n\n    inflationState.rate = FixidityLib.wrap(inflationRate);\n    inflationState.factor = FixidityLib.fixed1();\n    inflationState.updatePeriod = inflationFactorUpdatePeriod;\n    // solhint-disable-next-line not-rely-on-time\n    inflationState.factorLastUpdated = now;\n\n    require(initialBalanceAddresses.length == initialBalanceValues.length, \"Array length mismatch\");\n    for (uint256 i = 0; i < initialBalanceAddresses.length; i = i.add(1)) {\n      _mint(initialBalanceAddresses[i], initialBalanceValues[i]);\n    }\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Updates Inflation Parameters.\n   * @param rate new rate.\n   * @param updatePeriod how often inflationFactor is updated.\n   */\n  function setInflationParameters(uint256 rate, uint256 updatePeriod)\n    external\n    onlyOwner\n    updateInflationFactor\n  {\n    require(rate != 0, \"Must provide a non-zero inflation rate.\");\n    require(updatePeriod > 0, \"updatePeriod must be > 0\");\n    inflationState.rate = FixidityLib.wrap(rate);\n    inflationState.updatePeriod = updatePeriod;\n\n    emit InflationParametersUpdated(\n      rate,\n      updatePeriod,\n      // solhint-disable-next-line not-rely-on-time\n      now\n    );\n  }\n\n  /**\n   * @notice Increase the allowance of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The increment of the amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function increaseAllowance(address spender, uint256 value)\n    external\n    updateInflationFactor\n    returns (bool)\n  {\n    require(spender != address(0), \"reserved address 0x0 cannot have allowance\");\n    uint256 oldValue = allowed[msg.sender][spender];\n    uint256 newValue = oldValue.add(value);\n    allowed[msg.sender][spender] = newValue;\n    emit Approval(msg.sender, spender, newValue);\n    return true;\n  }\n\n  /**\n   * @notice Decrease the allowance of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The decrement of the amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function decreaseAllowance(address spender, uint256 value)\n    external\n    updateInflationFactor\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][spender];\n    uint256 newValue = oldValue.sub(value);\n    allowed[msg.sender][spender] = newValue;\n    emit Approval(msg.sender, spender, newValue);\n    return true;\n  }\n\n  /**\n   * @notice Approve a user to transfer StableToken on behalf of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function approve(address spender, uint256 value) external updateInflationFactor returns (bool) {\n    require(spender != address(0), \"reserved address 0x0 cannot have allowance\");\n    allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @notice Mints new StableToken and gives it to 'to'.\n   * @param to The account for which to mint tokens.\n   * @param value The amount of StableToken to mint.\n   */\n  function mint(address to, uint256 value) external updateInflationFactor returns (bool) {\n    require(\n      msg.sender == registry.getAddressFor(EXCHANGE_REGISTRY_ID) ||\n        msg.sender == registry.getAddressFor(VALIDATORS_REGISTRY_ID),\n      \"Only the Exchange and Validators contracts are authorized to mint\"\n    );\n    return _mint(to, value);\n  }\n\n  /**\n   * @notice Mints new StableToken and gives it to 'to'.\n   * @param to The account for which to mint tokens.\n   * @param value The amount of StableToken to mint.\n   */\n  function _mint(address to, uint256 value) private returns (bool) {\n    require(to != address(0), \"0 is a reserved address\");\n    if (value == 0) {\n      return true;\n    }\n\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    totalSupply_ = totalSupply_.add(units);\n    balances[to] = balances[to].add(units);\n    emit Transfer(address(0), to, value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer token for a specified address\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   * @param comment The transfer comment.\n   * @return True if the transaction succeeds.\n   */\n  function transferWithComment(address to, uint256 value, string calldata comment)\n    external\n    updateInflationFactor\n    onlyWhenNotFrozen\n    returns (bool)\n  {\n    bool succeeded = transfer(to, value);\n    emit TransferComment(comment);\n    return succeeded;\n  }\n\n  /**\n   * @notice Burns StableToken from the balance of msg.sender.\n   * @param value The amount of StableToken to burn.\n   */\n  function burn(uint256 value)\n    external\n    onlyRegisteredContract(EXCHANGE_REGISTRY_ID)\n    updateInflationFactor\n    returns (bool)\n  {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    require(units <= balances[msg.sender], \"value exceeded balance of sender\");\n    totalSupply_ = totalSupply_.sub(units);\n    balances[msg.sender] = balances[msg.sender].sub(units);\n    emit Transfer(msg.sender, address(0), units);\n    return true;\n  }\n\n  /**\n   * @notice Transfers StableToken from one address to another on behalf of a user.\n   * @param from The address to transfer StableToken from.\n   * @param to The address to transfer StableToken to.\n   * @param value The amount of StableToken to transfer.\n   * @return True if the transaction succeeds.\n   */\n  function transferFrom(address from, address to, uint256 value)\n    external\n    updateInflationFactor\n    onlyWhenNotFrozen\n    returns (bool)\n  {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    require(to != address(0), \"transfer attempted to reserved address 0x0\");\n    require(units <= balances[from], \"transfer value exceeded balance of sender\");\n    require(\n      value <= allowed[from][msg.sender],\n      \"transfer value exceeded sender's allowance for recipient\"\n    );\n\n    balances[to] = balances[to].add(units);\n    balances[from] = balances[from].sub(units);\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @return The name of the stable token.\n   */\n  function name() external view returns (string memory) {\n    return name_;\n  }\n\n  /**\n   * @return The symbol of the stable token.\n   */\n  function symbol() external view returns (string memory) {\n    return symbol_;\n  }\n\n  /**\n   * @return The number of decimal places to which StableToken is divisible.\n   */\n  function decimals() external view returns (uint8) {\n    return decimals_;\n  }\n\n  /**\n   * @notice Gets the amount of owner's StableToken allowed to be spent by spender.\n   * @param accountOwner The owner of the StableToken.\n   * @param spender The spender of the StableToken.\n   * @return The amount of StableToken owner is allowing spender to spend.\n   */\n  function allowance(address accountOwner, address spender) external view returns (uint256) {\n    return allowed[accountOwner][spender];\n  }\n\n  /**\n   * @notice Gets the balance of the specified address using the presently stored inflation factor.\n   * @param accountOwner The address to query the balance of.\n   * @return The balance of the specified address.\n   */\n  function balanceOf(address accountOwner) external view returns (uint256) {\n    return unitsToValue(balances[accountOwner]);\n  }\n\n  /**\n   * @return The total value of StableToken in existence\n   * @dev Though totalSupply_ is stored in units, this returns value.\n   */\n  function totalSupply() external view returns (uint256) {\n    return unitsToValue(totalSupply_);\n  }\n\n  /**\n   * @notice gets inflation parameters.\n   * @return rate\n   * @return factor\n   * @return updatePeriod\n   * @return factorLastUpdated\n   */\n  function getInflationParameters() external view returns (uint256, uint256, uint256, uint256) {\n    return (\n      inflationState.rate.unwrap(),\n      inflationState.factor.unwrap(),\n      inflationState.updatePeriod,\n      inflationState.factorLastUpdated\n    );\n  }\n\n  /**\n   * @notice Returns the units for a given value given the current inflation factor.\n   * @param value The value to convert to units.\n   * @return The units corresponding to `value` given the current inflation factor.\n   * @dev We don't compute the updated inflationFactor here because\n   * we assume any function calling this will have updated the inflation factor.\n   */\n  function valueToUnits(uint256 value) external view returns (uint256) {\n    FixidityLib.Fraction memory updatedInflationFactor;\n\n    (updatedInflationFactor, ) = getUpdatedInflationFactor();\n    return _valueToUnits(updatedInflationFactor, value);\n  }\n\n  /**\n   * @notice Returns the value of a given number of units given the current inflation factor.\n   * @param units The units to convert to value.\n   * @return The value corresponding to `units` given the current inflation factor.\n   */\n  function unitsToValue(uint256 units) public view returns (uint256) {\n    FixidityLib.Fraction memory updatedInflationFactor;\n\n    (updatedInflationFactor, ) = getUpdatedInflationFactor();\n\n    // We're ok using FixidityLib.divide here because updatedInflationFactor is\n    // not going to surpass maxFixedDivisor any time soon.\n    // Quick upper-bound estimation: if annual inflation were 5% (an order of\n    // magnitude more than the initial proposal of 0.5%), in 500 years, the\n    // inflation factor would be on the order of 10**10, which is still a safe\n    // divisor.\n    return FixidityLib.newFixed(units).divide(updatedInflationFactor).fromFixed();\n  }\n\n  /**\n   * @notice Returns the units for a given value given the current inflation factor.\n   * @param value The value to convert to units.\n   * @return The units corresponding to `value` given the current inflation factor.\n   * @dev we assume any function calling this will have updated the inflation factor.\n   */\n  function _valueToUnits(FixidityLib.Fraction memory inflationFactor, uint256 value)\n    private\n    pure\n    returns (uint256)\n  {\n    return inflationFactor.multiply(FixidityLib.newFixed(value)).fromFixed();\n  }\n\n  /**\n   * @notice Computes the up-to-date inflation factor.\n   * @return current inflation factor.\n   * @return lastUpdated time when the returned inflation factor went into effect.\n   */\n  function getUpdatedInflationFactor() private view returns (FixidityLib.Fraction memory, uint256) {\n    /* solhint-disable not-rely-on-time */\n    if (now < inflationState.factorLastUpdated.add(inflationState.updatePeriod)) {\n      return (inflationState.factor, inflationState.factorLastUpdated);\n    }\n\n    uint256 numerator;\n    uint256 denominator;\n\n    // TODO: handle retroactive updates given decreases to updatePeriod\n    uint256 timesToApplyInflation = now.sub(inflationState.factorLastUpdated).div(\n      inflationState.updatePeriod\n    );\n\n    (numerator, denominator) = fractionMulExp(\n      inflationState.factor.unwrap(),\n      FixidityLib.fixed1().unwrap(),\n      inflationState.rate.unwrap(),\n      FixidityLib.fixed1().unwrap(),\n      timesToApplyInflation,\n      decimals_\n    );\n\n    // This should never happen. If something went wrong updating the\n    // inflation factor, keep the previous factor\n    if (numerator == 0 || denominator == 0) {\n      return (inflationState.factor, inflationState.factorLastUpdated);\n    }\n\n    FixidityLib.Fraction memory currentInflationFactor = FixidityLib.wrap(numerator).divide(\n      FixidityLib.wrap(denominator)\n    );\n    uint256 lastUpdated = inflationState.factorLastUpdated.add(\n      inflationState.updatePeriod.mul(timesToApplyInflation)\n    );\n\n    return (currentInflationFactor, lastUpdated);\n    /* solhint-enable not-rely-on-time */\n  }\n\n  /**\n   * @notice Transfers `value` from `msg.sender` to `to`\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   */\n  // solhint-disable-next-line no-simple-event-func-name\n  function transfer(address to, uint256 value)\n    public\n    updateInflationFactor\n    onlyWhenNotFrozen\n    returns (bool)\n  {\n    return _transfer(to, value);\n  }\n\n  /**\n   * @notice Transfers StableToken from one address to another\n   * @param to The address to transfer StableToken to.\n   * @param value The amount of StableToken to be transferred.\n   */\n  function _transfer(address to, uint256 value) internal returns (bool) {\n    require(to != address(0), \"transfer attempted to reserved address 0x0\");\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    require(balances[msg.sender] >= units, \"transfer value exceeded balance of sender\");\n    balances[msg.sender] = balances[msg.sender].sub(units);\n    balances[to] = balances[to].add(units);\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @notice Reserve balance for making payments for gas in this StableToken currency.\n   * @param from The account to reserve balance from\n   * @param value The amount of balance to reserve\n   * @dev Note that this function is called by the protocol when paying for tx fees in this\n   * currency. After the tx is executed, gas is refunded to the sender and credited to the\n   * various tx fee recipients via a call to `creditGasFees`. Note too that the events emitted\n   * by `creditGasFees` reflect the *net* gas fee payments for the transaction.\n   */\n  function debitGasFees(address from, uint256 value)\n    external\n    onlyVm\n    onlyWhenNotFrozen\n    updateInflationFactor\n  {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    balances[from] = balances[from].sub(units);\n    totalSupply_ = totalSupply_.sub(units);\n  }\n\n  /**\n   * @notice Alternative function to credit balance after making payments\n   * for gas in this StableToken currency.\n   * @param from The account to debit balance from\n   * @param feeRecipient Coinbase address\n   * @param gatewayFeeRecipient Gateway address\n   * @param communityFund Community fund address\n   * @param tipTxFee Coinbase fee\n   * @param baseTxFee Community fund fee\n   * @param gatewayFee Gateway fee\n   * @dev Note that this function is called by the protocol when paying for tx fees in this\n   * currency. Before the tx is executed, gas is debited from the sender via a call to\n   * `debitGasFees`. Note too that the events emitted by `creditGasFees` reflect the *net* gas fee\n   * payments for the transaction.\n   */\n  function creditGasFees(\n    address from,\n    address feeRecipient,\n    address gatewayFeeRecipient,\n    address communityFund,\n    uint256 refund,\n    uint256 tipTxFee,\n    uint256 gatewayFee,\n    uint256 baseTxFee\n  ) external onlyVm onlyWhenNotFrozen {\n    uint256 units = _valueToUnits(inflationState.factor, refund);\n    balances[from] = balances[from].add(units);\n\n    units = units.add(_creditGas(from, communityFund, baseTxFee));\n    units = units.add(_creditGas(from, feeRecipient, tipTxFee));\n    units = units.add(_creditGas(from, gatewayFeeRecipient, gatewayFee));\n    totalSupply_ = totalSupply_.add(units);\n  }\n\n  function _creditGas(address from, address to, uint256 value) internal returns (uint256) {\n    if (to == address(0)) {\n      return 0;\n    }\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    balances[to] = balances[to].add(units);\n    emit Transfer(from, to, value);\n    return units;\n  }\n\n}"
    },
    {
      "filename": "packages/protocol/contracts/identity/Attestations.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/utils/SafeCast.sol\";\n\nimport \"./interfaces/IAttestations.sol\";\nimport \"./interfaces/IRandom.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title Contract mapping identifiers to accounts\n */\ncontract Attestations is\n  IAttestations,\n  ICeloVersionedContract,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard,\n  UsingPrecompiles\n{\n  using SafeMath for uint256;\n  using SafeCast for uint256;\n\n  enum AttestationStatus { None, Incomplete, Complete }\n\n  struct Attestation {\n    AttestationStatus status;\n    // For outstanding attestations, this is the block number of the request.\n    // For completed attestations, this is the block number of the attestation completion.\n    uint32 blockNumber;\n    // The token with which attestation request fees were paid.\n    address attestationRequestFeeToken;\n  }\n\n  // Stores attestations state for a single (identifier, account address) pair.\n  struct AttestedAddress {\n    // Total number of requested attestations.\n    uint32 requested;\n    // Total number of completed attestations.\n    uint32 completed;\n    // List of selected issuers responsible for attestations. The length of this list\n    // might be smaller than `requested` (which represents the total number of requested\n    // attestations) if users are not calling `selectIssuers` on unselected requests.\n    address[] selectedIssuers;\n    // State of each attestation keyed by issuer.\n    mapping(address => Attestation) issuedAttestations;\n  }\n\n  struct UnselectedRequest {\n    // The block at which the attestations were requested.\n    uint32 blockNumber;\n    // The number of attestations that were requested.\n    uint32 attestationsRequested;\n    // The token with which attestation request fees were paid in this request.\n    address attestationRequestFeeToken;\n  }\n\n  struct IdentifierState {\n    // All account addresses associated with this identifier.\n    address[] accounts;\n    // Keeps the state of attestations for account addresses for this identifier.\n    mapping(address => AttestedAddress) attestations;\n    // Temporarily stores attestation requests for which issuers should be selected by the account.\n    mapping(address => UnselectedRequest) unselectedRequests;\n  }\n\n  mapping(bytes32 => IdentifierState) identifiers;\n\n  // The duration in blocks in which an attestation can be completed from the block in which the\n  // attestation was requested.\n  uint256 public attestationExpiryBlocks;\n\n  // The duration to wait until selectIssuers can be called for an attestation request.\n  uint256 public selectIssuersWaitBlocks;\n\n  // Limit the maximum number of attestations that can be requested\n  uint256 public maxAttestations;\n\n  // The fees that are associated with attestations for a particular token.\n  mapping(address => uint256) public attestationRequestFees;\n\n  // Maps a token and attestation issuer to the amount that they're owed.\n  mapping(address => mapping(address => uint256)) public pendingWithdrawals;\n\n  // Attestation transfer approvals, keyed by user and keccak(identifier, from, to)\n  mapping(address => mapping(bytes32 => bool)) public transferApprovals;\n\n  event AttestationsRequested(\n    bytes32 indexed identifier,\n    address indexed account,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationIssuerSelected(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationCompleted(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer\n  );\n\n  event Withdrawal(address indexed account, address indexed token, uint256 amount);\n  event AttestationExpiryBlocksSet(uint256 value);\n  event AttestationRequestFeeSet(address indexed token, uint256 value);\n  event SelectIssuersWaitBlocksSet(uint256 value);\n  event MaxAttestationsSet(uint256 value);\n  event AttestationsTransferred(\n    bytes32 indexed identifier,\n    address indexed fromAccount,\n    address indexed toAccount\n  );\n  event TransferApproval(\n    address indexed approver,\n    bytes32 indexed indentifier,\n    address from,\n    address to,\n    bool approved\n  );\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _attestationExpiryBlocks The new limit on blocks allowed to come between requesting\n   * an attestation and completing it.\n   * @param _selectIssuersWaitBlocks The wait period in blocks to call selectIssuers on attestation\n   * requests.\n   * @param attestationRequestFeeTokens The address of tokens that fees should be payable in.\n   * @param attestationRequestFeeValues The corresponding fee values.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 _attestationExpiryBlocks,\n    uint256 _selectIssuersWaitBlocks,\n    uint256 _maxAttestations,\n    address[] calldata attestationRequestFeeTokens,\n    uint256[] calldata attestationRequestFeeValues\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setAttestationExpiryBlocks(_attestationExpiryBlocks);\n    setSelectIssuersWaitBlocks(_selectIssuersWaitBlocks);\n    setMaxAttestations(_maxAttestations);\n\n    require(\n      attestationRequestFeeTokens.length > 0 &&\n        attestationRequestFeeTokens.length == attestationRequestFeeValues.length,\n      \"attestationRequestFeeTokens specification was invalid\"\n    );\n    for (uint256 i = 0; i < attestationRequestFeeTokens.length; i = i.add(1)) {\n      setAttestationRequestFee(attestationRequestFeeTokens[i], attestationRequestFeeValues[i]);\n    }\n  }\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 1, 0);\n  }\n\n  /**\n   * @notice Commit to the attestation request of a hashed identifier.\n   * @param identifier The hash of the identifier to be attested.\n   * @param attestationsRequested The number of requested attestations for this request.\n   * @param attestationRequestFeeToken The address of the token with which the attestation fee will\n   * be paid.\n   * @dev Note that if an attestion expires before it is completed, the fee is forfeited. This is\n   * to prevent folks from attacking validators by requesting attestations that they do not\n   * complete, and to increase the cost of validators attempting to manipulate the attestations\n   * protocol.\n   */\n  function request(\n    bytes32 identifier,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  ) external nonReentrant {\n    require(\n      attestationRequestFees[attestationRequestFeeToken] > 0,\n      \"Invalid attestationRequestFeeToken\"\n    );\n    require(\n      IERC20(attestationRequestFeeToken).transferFrom(\n        msg.sender,\n        address(this),\n        attestationRequestFees[attestationRequestFeeToken].mul(attestationsRequested)\n      ),\n      \"Transfer of attestation request fees failed\"\n    );\n\n    require(attestationsRequested > 0, \"You have to request at least 1 attestation\");\n    require(attestationsRequested <= maxAttestations, \"Too many attestations requested\");\n\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber == 0 ||\n        isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber) ||\n        !isAttestationRequestSelectable(state.unselectedRequests[msg.sender].blockNumber),\n      \"There exists an unexpired, unselected attestation request\"\n    );\n\n    state.unselectedRequests[msg.sender].blockNumber = block.number.toUint32();\n    state.unselectedRequests[msg.sender].attestationsRequested = attestationsRequested.toUint32();\n    state.unselectedRequests[msg.sender].attestationRequestFeeToken = attestationRequestFeeToken;\n\n    state.attestations[msg.sender].requested = uint256(state.attestations[msg.sender].requested)\n      .add(attestationsRequested)\n      .toUint32();\n\n    emit AttestationsRequested(\n      identifier,\n      msg.sender,\n      attestationsRequested,\n      attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Selects the issuers for the most recent attestation request.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function selectIssuers(bytes32 identifier) external {\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber > 0,\n      \"No unselected attestation request to select issuers for\"\n    );\n\n    require(\n      !isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber),\n      \"The attestation request has expired\"\n    );\n\n    addIncompleteAttestations(identifier);\n    delete state.unselectedRequests[msg.sender];\n  }\n\n  /**\n   * @notice Submit the secret message sent by the issuer to complete the attestation request.\n   * @param identifier The hash of the identifier for this attestation.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function complete(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) external {\n    address issuer = validateAttestationCode(identifier, msg.sender, v, r, s);\n\n    Attestation storage attestation = identifiers[identifier].attestations[msg.sender]\n      .issuedAttestations[issuer];\n\n    address token = attestation.attestationRequestFeeToken;\n\n    // solhint-disable-next-line not-rely-on-time\n    attestation.blockNumber = block.number.toUint32();\n    attestation.status = AttestationStatus.Complete;\n    delete attestation.attestationRequestFeeToken;\n    AttestedAddress storage attestedAddress = identifiers[identifier].attestations[msg.sender];\n    require(\n      attestedAddress.completed < attestedAddress.completed + 1,\n      \"SafeMath32 integer overflow\"\n    );\n    attestedAddress.completed = attestedAddress.completed + 1;\n\n    pendingWithdrawals[token][issuer] = pendingWithdrawals[token][issuer].add(\n      attestationRequestFees[token]\n    );\n\n    IdentifierState storage state = identifiers[identifier];\n    if (identifiers[identifier].attestations[msg.sender].completed == 1) {\n      state.accounts.push(msg.sender);\n    }\n\n    emit AttestationCompleted(identifier, msg.sender, issuer);\n  }\n\n  /**\n   * @notice Revokes an account for an identifier.\n   * @param identifier The identifier for which to revoke.\n   * @param index The index of the account in the accounts array.\n   */\n  function revoke(bytes32 identifier, uint256 index) external {\n    uint256 numAccounts = identifiers[identifier].accounts.length;\n    require(index < numAccounts, \"Index is invalid\");\n    require(\n      msg.sender == identifiers[identifier].accounts[index],\n      \"Index does not match msg.sender\"\n    );\n\n    uint256 newNumAccounts = numAccounts.sub(1);\n    if (index != newNumAccounts) {\n      identifiers[identifier].accounts[index] = identifiers[identifier].accounts[newNumAccounts];\n    }\n    identifiers[identifier].accounts[newNumAccounts] = address(0x0);\n    identifiers[identifier].accounts.length = identifiers[identifier].accounts.length.sub(1);\n  }\n\n  /**\n   * @notice Allows issuers to withdraw accumulated attestation rewards.\n   * @param token The address of the token that will be withdrawn.\n   * @dev Throws if msg.sender does not have any rewards to withdraw.\n   */\n  function withdraw(address token) external {\n    address issuer = getAccounts().attestationSignerToAccount(msg.sender);\n    uint256 value = pendingWithdrawals[token][issuer];\n    require(value > 0, \"value was negative/zero\");\n    pendingWithdrawals[token][issuer] = 0;\n    require(IERC20(token).transfer(issuer, value), \"token transfer failed\");\n    emit Withdrawal(issuer, token, value);\n  }\n\n  /**\n   * @notice Returns the unselected attestation request for an identifier/account pair, if any.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [\n   *           Block number at which was requested,\n   *           Number of unselected requests,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getUnselectedRequest(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32, address)\n  {\n    return (\n      identifiers[identifier].unselectedRequests[account].blockNumber,\n      identifiers[identifier].unselectedRequests[account].attestationsRequested,\n      identifiers[identifier].unselectedRequests[account].attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Returns sel"
    }
  ]
}