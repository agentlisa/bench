{
  "Title": "[M-06] `_ownedTokensIndex` is SHARED by different owners, as a result, `_removeTokenFromAllTokensEnumeration` might remove the wrong tokenId.",
  "Content": "\nThe data structure `_ownedTokensIndex` is SHARED by different owners, as a result, `_removeTokenFromAllTokensEnumeration()` might remove the wrong tokenId.\n\n### Proof of Concept\n\n`_ownedTokensIndex` is used to map from token ID to index of the owner tokens list, unfortunately, all owners share the same data structure at the same time (non-fungible tokens). So, the mapping for one owner might be overwritten by another owner when `_addTokenToOwnerEnumeration` is called: <br><https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-token/src/base/ERC1155Enumerable.sol#L116-L121>.\nAs a result,    `_removeTokenFromOwnerEnumeration()` might remove the wrong tokenID.\n\nRemoving the wrong tokenID can happen like the following:\n\n1.  Suppose Alice owns three tokens A, B, C with indices 1 -> A, 2->B, 3->C\n2.  Suppose Bob owns token D, 1->D, and will add A to his list via `_addTokenToOwnerEnumeration()`. As a result, we have 1->D, and 2-A, since `_ownedTokensIndex` is shared, we have A->2 in `_ownedTokensIndex`.\n3.  Next, `_removeTokenFromOwnerEnumeration()` is called to remove A from Alice. However, `tokenIndex` will be 2, which points to B, as a result, instead of deleting A, B is deleted from `_ownedTokens`. Wrong token delete!\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n            uint256 lastTokenIndex = _currentIndex[from] - 1;\n            uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n            if (tokenIndex != lastTokenIndex) {\n                uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n                _ownedTokens[from][tokenIndex] = lastTokenId;\n                _ownedTokensIndex[lastTokenId] = tokenIndex;\n            }\n\n            delete _ownedTokensIndex[tokenId];\n            delete _ownedTokens[from][lastTokenIndex];\n        }\n\n### Tools Used\n\nRemix\n\n### Recommended Mitigation Steps\n\nRedefine `ownedTokensIndex` so that is is not shared:\n\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokensIndex;\n\n**[vhawk19 (Timeswap) confirmed and commented](https://github.com/code-423n4/2023-01-timeswap-findings/issues/168#issuecomment-1434503390):**\n > Updated the [ERC1155Enumerable.sol](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/blob/devel/packages/v2-token/contracts/base/ERC1155Enumerable.sol) implementation, which should resolve these issues. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-token/src/base/ERC1155Enumerable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\nimport {IERC1155Enumerable} from \"../interfaces/IERC1155Enumerable.sol\";\n\n/// Extension of {ERC1155} that adds\n/// enumerability of all the token ids in the contract as well as all token ids owned by each\n/// account.\nabstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens; // An index of all tokens\n\n    mapping(address => uint256) private _currentIndex; // the current index for an address\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    mapping(uint256 => uint256) private _idTotalSupply;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /// @inheritdoc IERC1155Enumerable\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view override returns (uint256) {\n        return _ownedTokens[owner][index];\n    }\n\n    /// @inheritdoc IERC1155Enumerable\n    function totalSupply() public view override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /// @inheritdoc IERC1155Enumerable\n    function tokenByIndex(uint256 index) external view override returns (uint256) {\n        return _allTokens[index];\n    }\n\n    /// @dev Hook that is called before any token transfer. This includes minting\n    /// and burning.\n    function _beforeTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _addTokenEnumeration(from, to, ids[i], amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Add token enumeration list if necessary.\n    function _addTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            if (_idTotalSupply[id] == 0 && _additionalConditionAddTokenToAllTokensEnumeration(id)) _addTokenToAllTokensEnumeration(id);\n            _idTotalSupply[id] += amount;\n        }\n\n        if (to != address(0) && to != from) {\n            if (balanceOf(to, id) == 0 && _additionalConditionAddTokenToOwnerEnumeration(to, id)) _addTokenToOwnerEnumeration(to, id);\n        }\n    }\n\n    /// @dev Any additional condition to add token enumeration when overidden.\n    function _additionalConditionAddTokenToAllTokensEnumeration(uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Any additional condition to add token enumeration when overidden.\n    function _additionalConditionAddTokenToOwnerEnumeration(address, uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Hook that is called after any token transfer. This includes minting\n    /// and burning.\n    function _afterTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _removeTokenEnumeration(from, to, ids[i], amounts[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Remove token enumeration list if necessary.\n    function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n        if (to == address(0)) {\n            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n            _idTotalSupply[id] -= amount;\n        }\n\n        if (from != address(0) && from != to) {\n            if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n        }\n    }\n\n    /// @dev Any additional condition to remove token enumeration when overidden.\n    function _additionalConditionRemoveTokenFromAllTokensEnumeration(uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Any additional condition to remove token enumeration when overidden.\n    function _additionalConditionRemoveTokenFromOwnerEnumeration(address, uint256) internal virtual returns (bool) {\n        return true;\n    }\n\n    /// @dev Private function to add a token to this extension's ownership-tracking data structures.\n    /// @param to address representing the new owner of the given token ID\n    /// @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _currentIndex[to] += 1;\n        uint256 length = _currentIndex[to];\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /// @dev Private function to add a token to this extension's token tracking data structures.\n    /// @param tokenId uint256 ID of the token to be added to the tokens list\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /// @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n    /// while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n    /// gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n    /// This has O(1) time complexity, but alters the order of the _ownedTokens array.\n    /// @param from address representing the previous owner of the given token ID\n    /// @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        uint256 lastTokenIndex = _currentIndex[from] - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /// @dev Private function to remove a token from this extension's token tracking data structures.\n    /// This has O(1) time complexity, but alters the order of the _allTokens array.\n    /// @param tokenId uint256 ID of the token to be removed from the tokens list\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId;\n        _allTokensIndex[lastTokenId] = tokenIndex;\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}"
    }
  ]
}