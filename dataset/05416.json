{
  "Title": "[G-01] UniswapV3 Pool address can be computed locally",
  "Content": "\nUniswapV3 deploys pools deterministically, which means that their addresses can be computed locally by using the token addresses and the fee. \n\nInstead of externally querying `IUniswapV3Factory.getPool()`, pool addresses can be using the [`PoolAddress.computeAddress()`](https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/libraries/PoolAddress.sol#L33) helper function.\n\nInstances:\n\n- https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/Base.sol#L182\n- https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/Base.sol#L325\n- https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/protocol/ParticleInfoReader.sol#L92\n- https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/protocol/ParticleInfoReader.sol#L131\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-particle",
  "Code": [
    {
      "filename": "contracts/libraries/PoolAddress.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                )\n            )\n        );\n    }\n}"
    },
    {
      "filename": "contracts/libraries/Base.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport {FixedPoint128} from \"../../lib/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport {IUniswapV3Pool} from \"../../lib/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IUniswapV3Factory} from \"../../lib/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {INonfungiblePositionManager} from \"../interfaces/INonfungiblePositionManager.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {FullMath} from \"./FullMath.sol\";\nimport {TickMath} from \"./TickMath.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\n\n/// @title Base Library\n/// @notice Contains internal helper functions for all contracts\nlibrary Base {\n    // solhint-disable private-vars-leading-underscore\n    address internal constant UNI_POSITION_MANAGER_ADDR = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\n    uint256 internal constant BASIS_POINT = 1_000_000;\n\n    INonfungiblePositionManager internal constant UNI_POSITION_MANAGER =\n        INonfungiblePositionManager(UNI_POSITION_MANAGER_ADDR);\n    IUniswapV3Factory internal constant UNI_FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    // solhint-enable private-vars-leading-underscore\n\n    /**\n     * @notice Swap at most `amountFrom` of `tokenFrom` for at least `amountToMinimum` of `tokenTo`\n     * @dev Caller must check for non-reentrancy and proper amount is deposited in\n     * @param tokenFrom address of token to swap from\n     * @param tokenTo address of token to swap to\n     * @param amountFrom amount of tokenFrom to swap\n     * @param amountToMinimum minimum amount of tokenTo to receive\n     * @param dexAggregator address of DEX aggregator to perform swapping\n     * @param data calldata bytes to pass into DEX aggregator to perform swapping\n     * @return amountSpent amount of tokenFrom spent\n     * @return amountReceived amount of tokenTo received\n     */\n    function swap(\n        address tokenFrom,\n        address tokenTo,\n        uint256 amountFrom,\n        uint256 amountToMinimum,\n        address dexAggregator,\n        bytes calldata data\n    ) internal returns (uint256 amountSpent, uint256 amountReceived) {\n        uint256 balanceFromBefore = IERC20(tokenFrom).balanceOf(address(this));\n        uint256 balanceToBefore = IERC20(tokenTo).balanceOf(address(this));\n\n        if (amountFrom > 0) {\n            ///@dev only allow amountFrom of tokenFrom to be spent by the DEX aggregator\n            TransferHelper.safeApprove(tokenFrom, dexAggregator, amountFrom);\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = dexAggregator.call(data);\n            if (!success) revert Errors.SwapFailed();\n            TransferHelper.safeApprove(tokenFrom, dexAggregator, 0);\n        }\n\n        amountSpent = balanceFromBefore - IERC20(tokenFrom).balanceOf(address(this));\n        amountReceived = IERC20(tokenTo).balanceOf(address(this)) - balanceToBefore;\n\n        if (amountReceived < amountToMinimum) revert Errors.InsufficientSwap();\n    }\n\n    /**\n     * @notice Helper function to refund a token\n     * @param recipient the address to receive the refund\n     * @param token address of token to potentially refund\n     * @param amountExpected amount of token0 expected to spend\n     * @param amountActual amount of token0 actually spent\n     */\n    function refund(address recipient, address token, uint256 amountExpected, uint256 amountActual) internal {\n        if (amountExpected > amountActual) {\n            TransferHelper.safeTransfer(token, recipient, amountExpected - amountActual);\n        }\n    }\n\n    /**\n     * @notice Helper function to refund a token, with additional check that amountActual must not exceed amountExpected\n     * @param recipient the address to receive the refund\n     * @param token address of token to potentially refund\n     * @param amountExpected amount of token0 expected to spend\n     * @param amountActual amount of token0 actually spent\n     */\n    function refundWithCheck(address recipient, address token, uint256 amountExpected, uint256 amountActual) internal {\n        if (amountActual > amountExpected) revert Errors.OverRefund();\n        refund(recipient, token, amountExpected, amountActual);\n    }\n\n    /**\n     * @notice Helper function to prepare data for leveraged swap\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount of liquidity to borrow out\n     * @param zeroForOne direction of the swap\n     * @return tokenFrom token to swap from\n     * @return tokenTo token to swap to\n     * @return feeGrowthInside0LastX128 the current fee growth of the aggregate position for token0\n     * @return feeGrowthInside1LastX128 the current fee growth of the aggregate position for token1\n     * @return collateralFrom amount of `tokenFrom` that `liquidity` concentrates to at its end\n     * @return collateralTo amount of `tokenTo` that `liquidity` concentrate to at its end\n     */\n    function prepareLeverage(\n        uint256 tokenId,\n        uint128 liquidity,\n        bool zeroForOne\n    )\n        internal\n        view\n        returns (\n            address tokenFrom,\n            address tokenTo,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 collateralFrom,\n            uint256 collateralTo\n        )\n    {\n        int24 tickLower;\n        int24 tickUpper;\n        (\n            ,\n            ,\n            tokenFrom,\n            tokenTo,\n            ,\n            tickLower,\n            tickUpper,\n            ,\n            feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128,\n            ,\n\n        ) = UNI_POSITION_MANAGER.positions(tokenId);\n\n        (collateralFrom, collateralTo) = getRequiredCollateral(liquidity, tickLower, tickUpper);\n        if (!zeroForOne) {\n            (tokenFrom, tokenTo) = (tokenTo, tokenFrom);\n            (collateralFrom, collateralTo) = (collateralTo, collateralFrom);\n        }\n    }\n\n    /**\n     * @notice Calculates the amount of collateral needed when borrowing liquidity from a position\n     * @param liquidity amount of liquidity to borrow\n     * @param tickLower lower tick of the position\n     * @param tickUpper upper tick of the position\n     * @return amount0 amount that the liquidity concentrates to at tickLower\n     * @return amount1 amount that the liquidity concentrates to at tickHigher\n     */\n    function getRequiredCollateral(\n        uint128 liquidity,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    }\n\n    function getRequiredRepay(\n        uint128 liquidity,\n        uint256 tokenId\n    ) internal view returns (uint256 amount0, uint256 amount1) {\n        DataCache.RepayCache memory repayCache;\n        (\n            ,\n            ,\n            repayCache.token0,\n            repayCache.token1,\n            repayCache.fee,\n            repayCache.tickLower,\n            repayCache.tickUpper,\n            ,\n            ,\n            ,\n            ,\n\n        ) = UNI_POSITION_MANAGER.positions(tokenId);\n        IUniswapV3Pool pool = IUniswapV3Pool(UNI_FACTORY.getPool(repayCache.token0, repayCache.token1, repayCache.fee));\n        (repayCache.sqrtRatioX96, , , , , , ) = pool.slot0();\n        repayCache.sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(repayCache.tickLower);\n        repayCache.sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(repayCache.tickUpper);\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            repayCache.sqrtRatioX96,\n            repayCache.sqrtRatioAX96,\n            repayCache.sqrtRatioBX96,\n            liquidity\n        );\n    }\n\n    /**\n     * @notice Get the current owed fees for a position\n     * @param params.tokenId tokenId of the liquidity position NFT\n     * @param params.liquidity amount of liquidity in the position\n     * @param params.feeGrowthInside0LastX128 the fee growth of the position for token0 as of the last fee update\n     * @param params.feeGrowthInside1LastX128 the fee growth of the position for token1 as of the last fee update\n     * @param params.token0PremiumPortion the portion of token0 premium locked in the lien\n     * @param params.token1PremiumPortion the portion of token1 premium locked in the lien\n     * @param zeroForOne direction of the swap\n     * @return tokenFrom  address of token to swap from at close position\n     * @return tokenTo address of token to swap to at close position\n     * @return tokenFromOwed amount owed to the liquidity provider for the token on the side of swap from\n     * @return tokenToOwed amount owed to the liquidity provider for the token on the side of swap to\n     * @return tokenFromPremium amount of premium for the token on the side of swap from\n     * @return tokenToPremium amount of premium for the token on the side of swap to\n     * @return collateralFrom amount of collateral for the token on the side of swap from\n     * @return collateralTo amount of collateral for the token on the side of swap to\n     */\n    function getOwedInfoConverted(\n        DataStruct.OwedInfoParams memory params,\n        bool zeroForOne\n    )\n        internal\n        view\n        returns (\n            address tokenFrom,\n            address tokenTo,\n            uint128 tokenFromOwed,\n            uint128 tokenToOwed,\n            uint128 tokenFromPremium,\n            uint128 tokenToPremium,\n            uint256 collateralFrom,\n            uint256 collateralTo\n        )\n    {\n        (\n            tokenFrom,\n            tokenTo,\n            tokenFromOwed,\n            tokenToOwed,\n            tokenFromPremium,\n            tokenToPremium,\n            collateralFrom,\n            collateralTo\n        ) = getOwedInfo(params);\n        if (zeroForOne) {\n            (tokenFrom, tokenTo) = (tokenTo, tokenFrom);\n            (tokenFromOwed, tokenToOwed) = (tokenToOwed, tokenFromOwed);\n            (tokenFromPremium, tokenToPremium) = (tokenToPremium, tokenFromPremium);\n            (collateralFrom, collateralTo) = (collateralTo, collateralFrom);\n        }\n    }\n\n    /**\n     * @notice Get the current owed fees for a position\n     * @param params.tokenId tokenId of the liquidity position NFT\n     * @param params.liquidity amount of liquidity in the position\n     * @param params.feeGrowthInside0LastX128 the fee growth of the position for token0 as of the last fee update\n     * @param params.feeGrowthInside1LastX128 the fee growth of the position for token1 as of the last fee update\n     * @param params.token0PremiumPortion the portion of token0 premium locked in the lien\n     * @param params.token1PremiumPortion the portion of token1 premium locked in the lien\n     * @return token0 address of token0\n     * @return token1 address of token1\n     * @return token0Owed amount of token0 owed to the liquidity provider\n     * @return token1Owed amount of token1 owed to the liquidity provider\n     * @return token0Premium amount of token0 premium locked in the lien\n     * @return token1Premium amount of token1 premium locked in the lien\n     * @return collateral0 amount of token0 required by the lp (if oneForZero)\n     * @return collateral1 amount of token1 required by the lp (if zeroForOne)\n     */\n    function getOwedInfo(\n        DataStruct.OwedInfoParams memory params\n    )\n        internal\n        view\n        returns (\n            address token0,\n            address token1,\n            uint128 token0Owed,\n            uint128 token1Owed,\n            uint128 token0Premium,\n            uint128 token1Premium,\n            uint256 collateral0,\n            uint256 collateral1\n        )\n    {\n        DataCache.OwedInfoCache memory cache;\n        (, , token0, token1, cache.fee, cache.tickLower, cache.tickUpper, , , , , ) = UNI_POSITION_MANAGER.positions(\n            params.tokenId\n        );\n        (cache.feeGrowthInside0X128, cache.feeGrowthInside1X128) = getFeeGrowthInside(\n            token0,\n            token1,\n            cache.fee,\n            cache.tickLower,\n            cache.tickUpper\n        );\n        (token0Owed, token1Owed) = getOwedFee(\n            cache.feeGrowthInside0X128,\n            cache.feeGrowthInside1X128,\n            params.feeGrowthInside0LastX128,\n            params.feeGrowthInside1LastX128,\n            params.liquidity\n        );\n        (collateral0, collateral1) = getRequiredCollateral(params.liquidity, cache.tickLower, cache.tickUpper);\n        (token0Premium, token1Premium) = getPremium(\n            collateral0,\n            collateral1,\n            params.token0PremiumPortion,\n            params.token1PremiumPortion\n        );\n    }\n\n    /**\n     * @notice Helper function to calculate the current feeGrothInside(0/1)X128 based on tickLower and tickUpper\n     * @dev feeGrowthInsideX128 calculation adopted from uniswap v3 periphery PositionValue\n     * @param token0 address of token0\n     * @param token1 address of token1\n     * @param fee fee level of the pool\n     * @param tickLower lower tick of the position\n     * @param tickUpper upper tick of the position\n     * @return feeGrowthInside0X128 the current fee growth of the position for token0\n     * @return feeGrowthInside1X128 the current fee growth of the position for token1\n     */\n    function getFeeGrowthInside(\n        address token0,\n        address token1,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n        IUniswapV3Pool pool = IUniswapV3Pool(UNI_FACTORY.getPool(token0, token1, fee));\n        (, int24 tickCurrent, , , , , ) = pool.slot0();\n        (, , uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128, , , , ) = pool.ticks(tickLower);\n        (, , uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128, , , , ) = pool.ticks(tickUpper);\n\n        if (tickCurrent < tickLower) {\n            feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else if (tickCurrent < tickUpper) {\n            uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n            uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n            feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else {\n            feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n        }\n    }\n\n    /**\n     * @notice Helper function to get the fee owed based on the current and last feeGrowthInside\n     * @param feeGrowthInside0X128 the current fee growth of the position for token0\n     * @param feeGrowthInside1X128 the current fee growth of the position for token1\n     * @param feeGrowthInside0LastX128 the fee growth of the position for token0 at the last borrow / fee collection\n     * @param feeGrowthInside1LastX128 the fee growth of the position for token1 at the last borrow / fee collection\n     * @param liquidity liquidity of the position\n     * @return token0Owed amount of token0 owed\n     * @return token1Owed amount of token1 owed\n     */\n    function getOwedFee(\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128,\n        uint256 feeGrowthInside0LastX128,\n        uint256 feeGrowthInside1LastX128,\n        uint128 liquidity\n    ) internal pure returns (uint128 token0Owed, uint128 token1Owed) {\n        if (feeGrowthInside0X128 > feeGrowthInside0LastX128) {\n            token0Owed = uint128(\n                FullMath.mulDiv(feeGrowthInside0X128 - feeGrowthInside0LastX128, liquidity, FixedPoint128.Q128)\n            );\n        }\n        if (feeGrowthInside1X128 > feeGrowthInside1LastX128) {\n            token1Owed = uint128(\n                FullMath.mulDiv(feeGrowthInside1X128 - feeGrowthInside1LastX128, liquidity, FixedPoint128.Q128)\n            );\n        }\n    }\n\n    /**\n     * @notice Helper function to get the premium amount based on the premium portion and collateral as base\n     * @param collateral0 the amount of collateral for token0\n     * @param collateral1 the amount of collateral for token1\n     * @param token0PremiumPortion the premium portion based on collateral0 and BASIS_POINT\n     * @param token1PremiumPortion the premium portion based on collateral1 and BASIS_POINT\n     * @return token0Premium amount of premium for token0\n     * @return token1Premium amount of premium for token1\n     */\n    function getPremium(\n        uint256 collateral0,\n        uint256 collateral1,\n        uint24 token0PremiumPortion,\n        uint24 token1PremiumPortion\n    ) internal pure returns (uint128 token0Premium, uint128 token1Premium) {\n        token0Premium = uint128((token0PremiumPortion * collateral0) / BASIS_POINT);\n        token1Premium = uint128((token1PremiumPortion * collateral1) / BASIS_POINT);\n    }\n\n    /**\n     * @notice Helper function to fit a non-overflow uint256 value to uint24\n     * @param value the uint256 value to fit\n     * @return result uint24 value that fits\n     */\n    function uint256ToUint24(uint256 value) internal pure returns (uint24 result) {\n        if (value > type(uint24).max) revert Errors.Overflow();\n        result = uint24(value);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/Base.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport {FixedPoint128} from \"../../lib/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport {IUniswapV3Pool} from \"../../lib/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IUniswapV3Factory} from \"../../lib/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {INonfungiblePositionManager} from \"../interfaces/INonfungiblePositionManager.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {FullMath} from \"./FullMath.sol\";\nimport {TickMath} from \"./TickMath.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\n\n/// @title Base Library\n/// @notice Contains internal helper functions for all contracts\nlibrary Base {\n    // solhint-disable private-vars-leading-underscore\n    address internal constant UNI_POSITION_MANAGER_ADDR = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\n    uint256 internal constant BASIS_POINT = 1_000_000;\n\n    INonfungiblePositionManager internal constant UNI_POSITION_MANAGER =\n        INonfungiblePositionManager(UNI_POSITION_MANAGER_ADDR);\n    IUniswapV3Factory internal constant UNI_FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    // solhint-enable private-vars-leading-underscore\n\n    /**\n     * @notice Swap at most `amountFrom` of `tokenFrom` for at least `amountToMinimum` of `tokenTo`\n     * @dev Caller must check for non-reentrancy and proper amount is deposited in\n     * @param tokenFrom address of token to swap from\n     * @param tokenTo address of token to swap to\n     * @param amountFrom amount of tokenFrom to swap\n     * @param amountToMinimum minimum amount of tokenTo to receive\n     * @param dexAggregator address of DEX aggregator to perform swapping\n     * @param data calldata bytes to pass into DEX aggregator to perform swapping\n     * @return amountSpent amount of tokenFrom spent\n     * @return amountReceived amount of tokenTo received\n     */\n    function swap(\n        address tokenFrom,\n        address tokenTo,\n        uint256 amountFrom,\n        uint256 amountToMinimum,\n        address dexAggregator,\n        bytes calldata data\n    ) internal returns (uint256 amountSpent, uint256 amountReceived) {\n        uint256 balanceFromBefore = IERC20(tokenFrom).balanceOf(address(this));\n        uint256 balanceToBefore = IERC20(tokenTo).balanceOf(address(this));\n\n        if (amountFrom > 0) {\n            ///@dev only allow amountFrom of tokenFrom to be spent by the DEX aggregator\n            TransferHelper.safeApprove(tokenFrom, dexAggregator, amountFrom);\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = dexAggregator.call(data);\n            if (!success) revert Errors.SwapFailed();\n            TransferHelper.safeApprove(tokenFrom, dexAggregator, 0);\n        }\n\n        amountSpent = balanceFromBefore - IERC20(tokenFrom).balanceOf(address(this));\n        amountReceived = IERC20(tokenTo).balanceOf(address(this)) - balanceToBefore;\n\n        if (amountReceived < amountToMinimum) revert Errors.InsufficientSwap();\n    }\n\n    /**\n     * @notice Helper function to refund a token\n     * @param recipient the address to receive the refund\n     * @param token address of token to potentially refund\n     * @param amountExpected amount of token0 expected to spend\n     * @param amountActual amount of token0 actually spent\n     */\n    function refund(address recipient, address token, uint256 amountExpected, uint256 amountActual) internal {\n        if (amountExpected > amountActual) {\n            TransferHelper.safeTransfer(token, recipient, amountExpected - amountActual);\n        }\n    }\n\n    /**\n     * @notice Helper function to refund a token, with additional check that amountActual must not exceed amountExpected\n     * @param recipient the address to receive the refund\n     * @param token address of token to potentially refund\n     * @param amountExpected amount of token0 expected to spend\n     * @param amountActual amount of token0 actually spent\n     */\n    function refundWithCheck(address recipient, address token, uint256 amountExpected, uint256 amountActual) internal {\n        if (amountActual > amountExpected) revert Errors.OverRefund();\n        refund(recipient, token, amountExpected, amountActual);\n    }\n\n    /**\n     * @notice Helper function to prepare data for leveraged swap\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount of liquidity to borrow out\n     * @param zeroForOne direction of the swap\n     * @return tokenFrom token to swap from\n     * @return tokenTo token to swap to\n     * @return feeGrowthInside0LastX128 the current fee growth of the aggregate position for token0\n     * @return feeGrowthInside1LastX128 the current fee growth of the aggregate position for token1\n     * @return collateralFrom amount of `tokenFrom` that `liquidity` concentrates to at its end\n     * @return collateralTo amount of `tokenTo` that `liquidity` concentrate to at its end\n     */\n    function prepareLeverage(\n        uint256 tokenId,\n        uint128 liquidity,\n        bool zeroForOne\n    )\n        internal\n        view\n        returns (\n            address tokenFrom,\n            address tokenTo,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 collateralFrom,\n            uint256 collateralTo\n        )\n    {\n        int24 tickLower;\n        int24 tickUpper;\n        (\n            ,\n            ,\n            tokenFrom,\n            tokenTo,\n            ,\n            tickLower,\n            tickUpper,\n            ,\n            feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128,\n            ,\n\n        ) = UNI_POSITION_MANAGER.positions(tokenId);\n\n        (collateralFrom, collateralTo) = getRequiredCollateral(liquidity, tickLower, tickUpper);\n        if (!zeroForOne) {\n            (tokenFrom, tokenTo) = (tokenTo, tokenFrom);\n            (collateralFrom, collateralTo) = (collateralTo, collateralFrom);\n        }\n    }\n\n    /**\n     * @notice Calculates the amount of collateral needed when borrowing liquidity from a position\n     * @param liquidity amount of liquidity to borrow\n     * @param tickLower lower tick of the position\n     * @param tickUpper upper tick of the position\n     * @return amount0 amount that the liquidity concentrates to at tickLower\n     * @return amount1 amount that the liquidity concentrates to at tickHigher\n     */\n    function getRequiredCollateral(\n        uint128 liquidity,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    }\n\n    function getRequiredRepay(\n        uint128 liquidity,\n        uint256 tokenId\n    ) internal view returns (uint256 amount0, uint256 amount1) {\n        DataCache.RepayCache memory repayCache;\n        (\n            ,\n            ,\n            repayCache.token0,\n            repayCache.token1,\n            repayCache.fee,\n            repayCache.tickLower,\n            repayCache.tickUpper,\n            ,\n            ,\n            ,\n            ,\n\n        ) = UNI_POSITION_MANAGER.positions(tokenId);\n        IUniswapV3Pool pool = IUniswapV3Pool(UNI_FACTORY.getPool(repayCache.token0, repayCache.token1, repayCache.fee));\n        (repayCache.sqrtRatioX96, , , , , , ) = pool.slot0();\n        repayCache.sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(repayCache.tickLower);\n        repayCache.sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(repayCache.tickUpper);\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            repayCache.sqrtRatioX96,\n            repayCache.sqrtRatioAX96,\n            repayCache.sqrtRatioBX96,\n            liquidity\n        );\n    }\n\n    /**\n     * @notice Get the current owed fees for a position\n     * @param params.tokenId tokenId of the liquidity position NFT\n     * @param params.liquidity amount of liquidity in the position\n     * @param params.feeGrowthInside0LastX128 the fee growth of the position for token0 as of the last fee update\n     * @param params.feeGrowthInside1LastX128 the fee growth of the position for token1 as of the last fee update\n     * @param params.token0PremiumPortion the portion of token0 premium locked in the lien\n     * @param params.token1PremiumPortion the portion of token1 premium locked in the lien\n     * @param zeroForOne direction of the swap\n     * @return tokenFrom  address of token to swap from at close position\n     * @return tokenTo address of token to swap to at close position\n     * @return tokenFromOwed amount owed to the liquidity provider for the token on the side of swap from\n     * @return tokenToOwed amount owed to the liquidity provider for the token on the side of swap to\n     * @return tokenFromPremium amount of premium for the token on the side of swap from\n     * @return tokenToPremium amount of premium for the token on the side of swap to\n     * @return collateralFrom amount of collateral for the token on the side of swap from\n     * @return collateralTo amount of collateral for the token on the side of swap to\n     */\n    function getOwedInfoConverted(\n        DataStruct.OwedInfoParams memory params,\n        bool zeroForOne\n    )\n        internal\n        view\n        returns (\n            address tokenFrom,\n            address tokenTo,\n            uint128 tokenFromOwed,\n            uint128 tokenToOwed,\n            uint128 tokenFromPremium,\n            uint128 tokenToPremium,\n            uint256 collateralFrom,\n            uint256 collateralTo\n        )\n    {\n        (\n            tokenFrom,\n            tokenTo,\n            tokenFromOwed,\n            tokenToOwed,\n            tokenFromPremium,\n            tokenToPremium,\n            collateralFrom,\n            collateralTo\n        ) = getOwedInfo(params);\n        if (zeroForOne) {\n            (tokenFrom, tokenTo) = (tokenTo, tokenFrom);\n            (tokenFromOwed, tokenToOwed) = (tokenToOwed, tokenFromOwed);\n            (tokenFromPremium, tokenToPremium) = (tokenToPremium, tokenFromPremium);\n            (collateralFrom, collateralTo) = (collateralTo, collateralFrom);\n        }\n    }\n\n    /**\n     * @notice Get the current owed fees for a position\n     * @param params.tokenId tokenId of the liquidity position NFT\n     * @param params.liquidity amount of liquidity in the position\n     * @param params.feeGrowthInside0LastX128 the fee growth of the position for token0 as of the last fee update\n     * @param params.feeGrowthInside1LastX128 the fee growth of the position for token1 as of the last fee update\n     * @param params.token0PremiumPortion the portion of token0 premium locked in the lien\n     * @param params.token1PremiumPortion the portion of token1 premium locked in the lien\n     * @return token0 address of token0\n     * @return token1 address of token1\n     * @return token0Owed amount of token0 owed to the liquidity provider\n     * @return token1Owed amount of token1 owed to the liquidity provider\n     * @return token0Premium amount of token0 premium locked in the lien\n     * @return token1Premium amount of token1 premium locked in the lien\n     * @return collateral0 amount of token0 required by the lp (if oneForZero)\n     * @return collateral1 amount of token1 required by the lp (if zeroForOne)\n     */\n    function getOwedInfo(\n        DataStruct.OwedInfoParams memory params\n    )\n        internal\n        view\n        returns (\n            address token0,\n            address token1,\n            uint128 token0Owed,\n            uint128 token1Owed,\n            uint128 token0Premium,\n            uint128 token1Premium,\n            uint256 collateral0,\n            uint256 collateral1\n        )\n    {\n        DataCache.OwedInfoCache memory cache;\n        (, , token0, token1, cache.fee, cache.tickLower, cache.tickUpper, , , , , ) = UNI_POSITION_MANAGER.positions(\n            params.tokenId\n        );\n        (cache.feeGrowthInside0X128, cache.feeGrowthInside1X128) = getFeeGrowthInside(\n            token0,\n            token1,\n            cache.fee,\n            cache.tickLower,\n            cache.tickUpper\n        );\n        (token0Owed, token1Owed) = getOwedFee(\n            cache.feeGrowthInside0X128,\n            cache.feeGrowthInside1X128,\n            params.feeGrowthInside0LastX128,\n            params.feeGrowthInside1LastX128,\n            params.liquidity\n        );\n        (collateral0, collateral1) = getRequiredCollat"
    }
  ]
}