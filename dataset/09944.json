{
  "Title": "[M-06] Imprecise management of usersâ€™ allowance allows the admin of the upgradeable proxy contract to rug users",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9/contracts/core/modules/follow/FeeFollowModule.sol#L75-L91\n\n\n# Vulnerability details\n\nIn the current implementation, when there is a fee on follow or collect, users need to approve to the follow modules or collect module contract, and then the `Hub` contract can call `processFollow()` and transfer funds from an arbitrary address (as the `follower` parameter).\n\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9/contracts/core/modules/follow/FeeFollowModule.sol#L75-L91\n\n```solidity\nfunction processFollow(\n    address follower,\n    uint256 profileId,\n    bytes calldata data\n) external override onlyHub {\n    uint256 amount = _dataByProfile[profileId].amount;\n    address currency = _dataByProfile[profileId].currency;\n    _validateDataIsExpected(data, currency, amount);\n\n    (address treasury, uint16 treasuryFee) = _treasuryData();\n    address recipient = _dataByProfile[profileId].recipient;\n    uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n    uint256 adjustedAmount = amount - treasuryAmount;\n\n    IERC20(currency).safeTransferFrom(follower, recipient, adjustedAmount);\n    IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n}\n```\n\nA common practice is asking users to approve an unlimited amount to the contracts. Normally, the `allowance` can only be used by the user who initiated the transaction.\n\nIt's not a problem as long as `transferFrom` will always only transfer funds from `msg.sender` and the contract is non-upgradable.\n\nHowever, the `LensHub` contract is upgradeable, and `FeeFollowModule` will `transferFrom` an address decided by an input parameter `follower`, use of upgradeable proxy contract structure allows the logic of the contract to be arbitrarily changed.\n\nThis allows the proxy admin to perform many malicious actions, including taking funds from users' wallets up to the allowance limit.\n\nThis action can be performed by the malicious/compromised proxy admin without any restriction.\n\n### PoC\n\nGiven:\n\n- profileId `1` uses `FeeCollectModule` with `currency` = `WETH` and `amount` = `1e18`\n- Alice is rich (with 1,000,000 WETH in wallet balance)\n\n1. Alice `approve()` `type(uint256).max` to `FeeCollectModule` and `follow()` profileId `1` with `1e18 WETH`;\n2. A malicious/compromised proxy admin can call `upgradeToAndCall()` on the proxy contract and set a malicious contract as `newImplementation`, adding a new functions:\n\n```solidity\nfunction rugFollow(address follower, address followModule, uint256 profileId, bytes calldata data)\n    external\n{\n    IFollowModule(followModule).processFollow(\n        follower,\n        profileIds,\n        data\n    );\n}\n```\n3. The attacker creates a new profile with `FeeCollectModule` and set `currency` = `WETH` and `amount` = `1,000,000`, got profileId = `2`\n4. The attacker `rugFollow()` with `follower` = `Alice`, profileId = `2`, stolen `1,000,000` WETH from Alice's wallet\n\n\n### Recommendation\n\nImproper management of users' `allowance` is the root cause of some of the biggest attacks in the history of DeFi security. We believe there are 2 rules that should be followed:\n\n1. the `from` of `transferFrom` should always be `msg.sender`;\n2. the contracts that hold users' `allowance` should always be non-upgradable.\n\nWe suggest adding a non-upgradeable contract for processing user payments:\n\n```solidity\nfunction followWithFee(uint256 profileId, bytes calldata data)\n    external\n{\n    (address currency, uint256 amount) = abi.decode(data, (address, uint256));\n    IERC20(currency).transferFrom(msg.sender, HUB, amount);\n\n    uint256[] memory profileIds = new uint256[](1);\n    profileIds[0] = profileId;\n\n    bytes[] memory datas = new bytes[](1);\n    datas[0] = data;\n\n    IHUB(HUB).follow(profileIds, datas);\n}\n```\n\nThis comes with an additional benefit: users only need to approve one contract instead of approving multiple `follow` or `collect` module contracts. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-aave-lens-contest",
  "Code": [
    {
      "filename": "contracts/core/modules/follow/FeeFollowModule.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../../../interfaces/ILensHub.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute follow actions on a given profile.\n *\n * @param currency The currency associated with this profile.\n * @param amount The following cost associated with this profile.\n * @param recipient The recipient address associated with this profile.\n */\nstruct ProfileData {\n    address currency;\n    uint256 amount;\n    address recipient;\n}\n\n/**\n * @title FeeFollowModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens FollowModule implementation, inheriting from the IFollowModule interface, but with additional\n * variables that can be controlled by governance, such as the governance & treasury addresses as well as the treasury fee.\n */\ncontract FeeFollowModule is IFollowModule, FeeModuleBase, FollowValidatorFollowModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => ProfileData) internal _dataByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This follow module levies a fee on follows.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      address currency: The currency address, must be internally whitelisted.\n     *      uint256 amount: The currency total amount to levy.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        (uint256 amount, address currency, address recipient) = abi.decode(\n            data,\n            (uint256, address, address)\n        );\n        if (!_currencyWhitelisted(currency) || recipient == address(0) || amount < BPS_MAX)\n            revert Errors.InitParamsInvalid();\n\n        _dataByProfile[profileId].amount = amount;\n        _dataByProfile[profileId].currency = currency;\n        _dataByProfile[profileId].recipient = recipient;\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Charging a fee\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        uint256 amount = _dataByProfile[profileId].amount;\n        address currency = _dataByProfile[profileId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByProfile[profileId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(follower, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns the profile data for a given profile, or an empty struct if that profile was not initialized\n     * with this module.\n     *\n     * @param profileId The token ID of the profile to query.\n     *\n     * @return The ProfileData struct mapped to that profile.\n     */\n    function getProfileData(uint256 profileId) external view returns (ProfileData memory) {\n        return _dataByProfile[profileId];\n    }\n}"
    }
  ]
}