{
  "Title": "H-3: moveQuoteToken updates pool state using intermediary LUP, biasing pool's interest rate calculations",
  "Content": "# Issue H-3: moveQuoteToken updates pool state using intermediary LUP, biasing pool's interest rate calculations \n\nSource: https://github.com/sherlock-audit/2023-04-ajna-judging/issues/87 \n\n## Found by \nhyh\n## Summary\n\nIn LenderActions's moveQuoteToken() LUP is being evaluated after liquidity removal, but before liquidity addition. This intermediary LUP doesn't correspond to the final state of the pool, but is returned as if it does, leading to a bias in pool target utilization and interest rate calculations.\n\n## Vulnerability Detail\n\nmoveQuoteToken() calculates LUP after deposit removal only instead of doing so after the whole operation, being atomic removal from one index and addition to another, and then updates the pool accounting `_updateInterestState(poolState, newLup)` with this intermediary `newLup`, that doesn't correspond to the final state of the pool.\n\n## Impact\n\nmoveQuoteToken() is one of the base frequently used operations, so the state of the pool will be frequently enough updated with incorrect LUP and `EMA of LUP * t0 debt` internal accounting variable be systematically biased, which leads to incorrect interest rate dynamics of the pool.\n\nThere is no low-probability prerequisites and the impact is a bias in interest rate calculations, so setting the severity to be high.\n\n## Code Snippet\n\nmoveQuoteToken() calculates the LUP right after the deposit removal:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/LenderActions.sol#L237-L312\n\n```solidity\n    function moveQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        MoveQuoteParams calldata params_\n>>  ) external returns (uint256 fromBucketRedeemedLP_, uint256 toBucketLP_, uint256 movedAmount_, uint256 lup_) {\n        ...\n\n>>      (movedAmount_, fromBucketRedeemedLP_, vars.fromBucketRemainingDeposit) = _removeMaxDeposit(\n            deposits_,\n            RemoveDepositParams({\n                depositConstraint: params_.maxAmountToMove,\n                lpConstraint:      vars.fromBucketLenderLP,\n                bucketLP:          vars.fromBucketLP,\n                bucketCollateral:  vars.fromBucketCollateral,\n                price:             vars.fromBucketPrice,\n                index:             params_.fromIndex,\n                dustLimit:         poolState_.quoteTokenScale\n            })\n        );\n\n>>      lup_ = Deposits.getLup(deposits_, poolState_.debt);\n        // apply unutilized deposit fee if quote token is moved from above the LUP to below the LUP\n        if (vars.fromBucketPrice >= lup_ && vars.toBucketPrice < lup_) {\n            movedAmount_ = Maths.wmul(movedAmount_, Maths.WAD - _depositFeeRate(poolState_.rate));\n        }\n\n        vars.toBucketUnscaledDeposit = Deposits.unscaledValueAt(deposits_, params_.toIndex);\n        vars.toBucketScale           = Deposits.scale(deposits_, params_.toIndex);\n        vars.toBucketDeposit         = Maths.wmul(vars.toBucketUnscaledDeposit, vars.toBucketScale);\n\n        toBucketLP_ = Buckets.quoteTokensToLP(\n            toBucket.collateral,\n            toBucket.lps,\n            vars.toBucketDeposit,\n            movedAmount_,\n            vars.toBucketPrice,\n            Math.Rounding.Down\n        );\n\n        // revert if (due to rounding) the awarded LP in to bucket is 0\n        if (toBucketLP_ == 0) revert InsufficientLP();\n\n>>      Deposits.unscaledAdd(deposits_, params_.toIndex, Maths.wdiv(movedAmount_, vars.toBucketScale));\n\n        vars.htp = Maths.wmul(params_.thresholdPrice, poolState_.inflator);\n\n        // check loan book's htp against new lup, revert if move drives LUP below HTP\n        if (params_.fromIndex < params_.toIndex && vars.htp > lup_) revert LUPBelowHTP();\n```\n\nIntermediary LUP is then being used for interest rate state update:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/base/Pool.sol#L176-L207\n\n```solidity\n    function moveQuoteToken(\n        uint256 maxAmount_,\n        uint256 fromIndex_,\n        uint256 toIndex_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 fromBucketLP_, uint256 toBucketLP_, uint256 movedAmount_) {\n        _revertAfterExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, fromIndex_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            fromBucketLP_,\n            toBucketLP_,\n            movedAmount_,\n>>          newLup\n        ) = LenderActions.moveQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            MoveQuoteParams({\n                maxAmountToMove: maxAmount_,\n                fromIndex:       fromIndex_,\n                toIndex:         toIndex_,\n                thresholdPrice:  Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n>>      _updateInterestState(poolState, newLup);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/base/Pool.sol#L675-L680\n\n```solidity\n    function _updateInterestState(\n        PoolState memory poolState_,\n        uint256 lup_\n    ) internal {\n\n>>      PoolCommons.updateInterestState(interestState, emaState, deposits, poolState_, lup_);\n```\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/PoolCommons.sol#L148-L152\n\n```solidity\n                // calculate the EMA of LUP * t0 debt\n                vars.lupt0DebtEma = uint256(\n                    PRBMathSD59x18.mul(vars.weightTu, int256(vars.lupt0DebtEma)) +\n                    PRBMathSD59x18.mul(1e18 - vars.weightTu, int256(interestParams_.lupt0Debt))\n                );\n```\n\nThis will lead to a bias in target utilization and interest rate dynamics:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/PoolCommons.sol#L269-L289\n\n```solidity\n    function _calculateInterestRate(\n        PoolState memory poolState_,\n        uint256 debtEma_,\n        uint256 depositEma_,\n        uint256 debtColEma_,\n        uint256 lupt0DebtEma_\n    ) internal pure returns (uint256 newInterestRate_)  {\n        // meaningful actual utilization\n        int256 mau;\n        // meaningful actual utilization * 1.02\n        int256 mau102;\n\n        if (poolState_.debt != 0) {\n            // calculate meaningful actual utilization for interest rate update\n            mau    = int256(_utilization(debtEma_, depositEma_));\n            mau102 = mau * PERCENT_102 / 1e18;\n        }\n\n        // calculate target utilization\n        int256 tu = (lupt0DebtEma_ != 0) ? \n            int256(Maths.wdiv(debtColEma_, lupt0DebtEma_)) : int(Maths.WAD);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider calculating LUP in moveQuoteToken() after deposit addition to the destination bucket. Deposit fee can be calculated from initial LUP only, so only one, final, LUP recalculation looks to be necessary.\n\n\n\n## Discussion\n\n**grandizzy**\n\nhttps://github.com/ajna-finance/contracts/pull/891\n\n**dmitriia**\n\n> [ajna-finance/contracts#891](https://github.com/ajna-finance/contracts/pull/891)\n\nFix looks ok, final LUP is now used.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/75",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/external/LenderActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { Math } from '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport {\n    AddQuoteParams,\n    MoveQuoteParams,\n    RemoveQuoteParams\n}                     from '../../interfaces/pool/commons/IPoolInternals.sol';\nimport {\n    Bucket,\n    DepositsState,\n    Lender,\n    PoolState\n}                     from '../../interfaces/pool/commons/IPoolState.sol';\n\nimport { _depositFeeRate, _priceAt, MAX_FENWICK_INDEX } from '../helpers/PoolHelper.sol';\n\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  LenderActions library\n    @notice External library containing logic for lender actors:\n            - `Lenders`: add, remove and move quote tokens;\n            - `Traders`: add, remove and move quote tokens; add and remove collateral\n */\nlibrary LenderActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `moveQuoteToken` function local vars.\n    struct MoveQuoteLocalVars {\n        uint256 fromBucketPrice;            // [WAD] Price of the bucket to move amount from.\n        uint256 fromBucketCollateral;       // [WAD] Total amount of collateral in from bucket.\n        uint256 fromBucketLP;               // [WAD] Total amount of LP in from bucket.\n        uint256 fromBucketLenderLP;         // [WAD] Amount of LP owned by lender in from bucket.\n        uint256 fromBucketDepositTime;      // Time of lender deposit in the bucket to move amount from.\n        uint256 fromBucketRemainingLP;      // Amount of LP remaining in from bucket after move.\n        uint256 fromBucketRemainingDeposit; // Amount of scaled deposit remaining in from bucket after move.\n        uint256 toBucketPrice;              // [WAD] Price of the bucket to move amount to.\n        uint256 toBucketBankruptcyTime;     // Time the bucket to move amount to was marked as insolvent.\n        uint256 toBucketDepositTime;        // Time of lender deposit in the bucket to move amount to.\n        uint256 toBucketUnscaledDeposit;    // Amount of unscaled deposit in to bucket.\n        uint256 toBucketDeposit;            // Amount of scaled deposit in to bucket.\n        uint256 toBucketScale;              // Scale deposit of to bucket.\n        uint256 ptp;                        // [WAD] Pool Threshold Price.\n        uint256 htp;                        // [WAD] Highest Threshold Price.\n    }\n\n    /// @dev Struct used for `removeQuoteToken` function local vars.\n    struct RemoveDepositParams {\n        uint256 depositConstraint; // [WAD] Constraint on deposit in quote token.\n        uint256 lpConstraint;      // [WAD] Constraint in LPB terms.\n        uint256 bucketLP;          // [WAD] Total LPB in the bucket.\n        uint256 bucketCollateral;  // [WAD] Claimable collateral in the bucket.\n        uint256 price;             // [WAD] Price of bucket.\n        uint256 index;             // Bucket index.\n        uint256 dustLimit;         // Minimum amount of deposit which may reside in a bucket.\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AddQuoteToken(address indexed lender, uint256 indexed index, uint256 amount, uint256 lpAwarded, uint256 lup);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    event MoveQuoteToken(address indexed lender, uint256 indexed from, uint256 indexed to, uint256 amount, uint256 lpRedeemedFrom, uint256 lpAwardedTo, uint256 lup);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed index, uint256 amount, uint256 lpRedeemed, uint256 lup);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error BucketBankruptcyBlock();\n    error CannotMergeToHigherPrice();\n    error DustAmountNotExceeded();\n    error InvalidIndex();\n    error InvalidAmount();\n    error LUPBelowHTP();\n    error NoClaim();\n    error InsufficientLP();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error MoveToSameIndex();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IERC20PoolLenderActions` and `IERC721PoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Buckets.addCollateral`:\n     *  @dev      increment `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev      `addLenderLP`: increment `lender.lps` accumulator and `lender.depositTime `state\n     *  @dev    === Reverts on ===\n     *  @dev    invalid bucket index `InvalidIndex()`\n     *  @dev    no LP awarded in bucket `InsufficientLP()`\n     */\n    function addCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 collateralAmountToAdd_,\n        uint256 index_\n    ) external returns (uint256 bucketLP_) {\n        // revert if no amount to be added\n        if (collateralAmountToAdd_ == 0) revert InvalidAmount();\n        // revert if adding at invalid index\n        if (index_ == 0 || index_ > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n        uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n        uint256 bucketPrice   = _priceAt(index_);\n\n        bucketLP_ = Buckets.addCollateral(\n            buckets_[index_],\n            msg.sender,\n            bucketDeposit,\n            collateralAmountToAdd_,\n            bucketPrice\n        );\n\n        // revert if (due to rounding) the awarded LP is 0\n        if (bucketLP_ == 0) revert InsufficientLP();\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledAdd` (add new amount in `Fenwick` tree): update `values` array state \n     *  @dev    - increment `bucket.lps` accumulator\n     *  @dev    - increment `lender.lps` accumulator and `lender.depositTime` state\n     *  @dev    === Reverts on ===\n     *  @dev    invalid bucket index `InvalidIndex()`\n     *  @dev    same block when bucket becomes insolvent `BucketBankruptcyBlock()`\n     *  @dev    no LP awarded in bucket `InsufficientLP()`\n     *  @dev    calculated unscaled amount to add is 0 `InvalidAmount()`\n     *  @dev    === Emit events ===\n     *  @dev    - `AddQuoteToken`\n     */\n    function addQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        AddQuoteParams calldata params_\n    ) external returns (uint256 bucketLP_, uint256 lup_) {\n        // revert if no amount to be added\n        if (params_.amount == 0) revert InvalidAmount();\n        // revert if adding to an invalid index\n        if (params_.index == 0 || params_.index > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n        Bucket storage bucket = buckets_[params_.index];\n\n        uint256 bankruptcyTime = bucket.bankruptcyTime;\n\n        // cannot deposit in the same block when bucket becomes insolvent\n        if (bankruptcyTime == block.timestamp) revert BucketBankruptcyBlock();\n\n        uint256 unscaledBucketDeposit = Deposits.unscaledValueAt(deposits_, params_.index);\n        uint256 bucketScale           = Deposits.scale(deposits_, params_.index);\n        uint256 bucketDeposit         = Maths.wmul(bucketScale, unscaledBucketDeposit);\n        uint256 bucketPrice           = _priceAt(params_.index);\n        uint256 addedAmount           = params_.amount;\n\n        // charge unutilized deposit fee where appropriate\n        uint256 lupIndex = Deposits.findIndexOfSum(deposits_, poolState_.debt);\n        bool depositBelowLup = lupIndex != 0 && params_.index > lupIndex;\n        if (depositBelowLup) {\n            addedAmount = Maths.wmul(addedAmount, Maths.WAD - _depositFeeRate(poolState_.rate));\n        }\n\n        bucketLP_ = Buckets.quoteTokensToLP(\n            bucket.collateral,\n            bucket.lps,\n            bucketDeposit,\n            addedAmount,\n            bucketPrice,\n            Math.Rounding.Down\n        );\n\n        // revert if (due to rounding) the awarded LP is 0\n        if (bucketLP_ == 0) revert InsufficientLP();\n\n        uint256 unscaledAmount = Maths.wdiv(addedAmount, bucketScale);\n        // revert if unscaled amount is 0\n        if (unscaledAmount == 0) revert InvalidAmount();\n\n        Deposits.unscaledAdd(deposits_, params_.index, unscaledAmount);\n\n        // update lender LP\n        Buckets.addLenderLP(bucket, bankruptcyTime, msg.sender, bucketLP_);\n\n        // update bucket LP\n        bucket.lps += bucketLP_;\n\n        // only need to recalculate LUP if the deposit was above it\n        if (!depositBelowLup) {\n            lupIndex = Deposits.findIndexOfSum(deposits_, poolState_.debt);\n        }\n        lup_ = _priceAt(lupIndex);\n\n        emit AddQuoteToken(\n            msg.sender,\n            params_.index,\n            addedAmount,\n            bucketLP_,\n            lup_\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `_removeMaxDeposit`:\n     *  @dev      `Deposits.unscaledRemove` (remove amount in `Fenwick` tree, from index): update `values` array state\n     *  @dev    - `Deposits.unscaledAdd` (add amount in `Fenwick` tree, to index): update `values` array state\n     *  @dev    - decrement `lender.lps` accumulator for from bucket\n     *  @dev    - increment `lender.lps` accumulator and `lender.depositTime` state for to bucket\n     *  @dev    - decrement `bucket.lps` accumulator for from bucket\n     *  @dev    - increment `bucket.lps` accumulator for to bucket\n     *  @dev    === Reverts on ===\n     *  @dev    same index `MoveToSameIndex()`\n     *  @dev    dust amount `DustAmountNotExceeded()`\n     *  @dev    invalid index `InvalidIndex()`\n     *  @dev    no LP awarded in to bucket `InsufficientLP()`\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @dev    - `MoveQuoteToken`\n     */\n    function moveQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        MoveQuoteParams calldata params_\n    ) external returns (uint256 fromBucketRedeemedLP_, uint256 toBucketLP_, uint256 movedAmount_, uint256 lup_) {\n        if (params_.maxAmountToMove == 0)\n            revert InvalidAmount();\n        if (params_.fromIndex == params_.toIndex)\n            revert MoveToSameIndex();\n        if (params_.maxAmountToMove != 0 && params_.maxAmountToMove < poolState_.quoteTokenScale)\n            revert DustAmountNotExceeded();\n        if (params_.toIndex == 0 || params_.toIndex > MAX_FENWICK_INDEX) \n            revert InvalidIndex();\n\n        Bucket storage toBucket = buckets_[params_.toIndex];\n\n        MoveQuoteLocalVars memory vars;\n        vars.toBucketBankruptcyTime = toBucket.bankruptcyTime;\n\n        // cannot move in the same block when target bucket becomes insolvent\n        if (vars.toBucketBankruptcyTime == block.timestamp) revert BucketBankruptcyBlock();\n\n        Bucket storage fromBucket       = buckets_[params_.fromIndex];\n        Lender storage fromBucketLender = fromBucket.lenders[msg.sender];\n\n        vars.fromBucketPrice       = _priceAt(params_.fromIndex);\n        vars.fromBucketCollateral  = fromBucket.collateral;\n        vars.fromBucketLP          = fromBucket.lps;\n        vars.fromBucketDepositTime = fromBucketLender.depositTime;\n\n        vars.toBucketPrice         = _priceAt(params_.toIndex);\n\n        if (fromBucket.bankruptcyTime < vars.fromBucketDepositTime) vars.fromBucketLenderLP = fromBucketLender.lps;\n\n        (movedAmount_, fromBucketRedeemedLP_, vars.fromBucketRemainingDeposit) = _removeMaxDeposit(\n            deposits_,\n            RemoveDepositParams({\n                depositConstraint: params_.maxAmountToMove,\n                lpConstraint:      vars.fromBucketLenderLP,\n                bucketLP:          vars.fromBucketLP,\n                bucketCollateral:  vars.fromBucketCollateral,\n                price:             vars.fromBucketPrice,\n                index:             params_.fromIndex,\n                dustLimit:         poolState_.quoteTokenScale\n            })\n        );\n\n        lup_ = Deposits.getLup(deposits_, poolState_.debt);\n        // apply unutilized deposit fee if quote token is moved from above the LUP to below the LUP\n        if (vars.fromBucketPrice >= lup_ && vars.toBucketPrice < lup_) {\n            movedAmount_ = Maths.wmul(movedAmount_, Maths.WAD - _depositFeeRate(poolState_.rate));\n        }\n\n        vars.toBucketUnscaledDeposit = Deposits.unscaledValueAt(deposits_, params_.toIndex);\n        vars.toBucketScale           = Deposits.scale(deposits_, params_.toIndex);\n        vars.toBucketDeposit         = Maths.wmul(vars.toBucketUnscaledDeposit, vars.toBucketScale);\n\n        toBucketLP_ = Buckets.quoteTokensToLP(\n            toBucket.collateral,\n            toBucket.lps,\n            vars.toBucketDeposit,\n            movedAmount_,\n            vars.toBucketPrice,\n            Math.Rounding.Down\n        );\n\n        // revert if (due to rounding) the awarded LP in to bucket is 0\n        if (toBucketLP_ == 0) revert InsufficientLP();\n\n        Deposits.unscaledAdd(deposits_, params_.toIndex, Maths.wdiv(movedAmount_, vars.toBucketScale));\n\n        vars.htp = Maths.wmul(params_.thresholdPrice, poolState_.inflator);\n\n        // check loan book's htp against new lup, revert if move drives LUP below HTP\n        if (params_.fromIndex < params_.toIndex && vars.htp > lup_) revert LUPBelowHTP();\n\n        // update lender and bucket LP balance in from bucket\n        vars.fromBucketRemainingLP = vars.fromBucketLP - fromBucketRedeemedLP_;\n\n        // check if from bucket healthy after move quote tokens - set bankruptcy if collateral and deposit are 0 but there's still LP\n        if (vars.fromBucketCollateral == 0 && vars.fromBucketRemainingDeposit == 0 && vars.fromBucketRemainingLP != 0) {\n            fromBucket.lps            = 0;\n            fromBucket.bankruptcyTime = block.timestamp;\n\n            emit BucketBankruptcy(\n                params_.fromIndex,\n                vars.fromBucketRemainingLP\n            );\n        } else {\n            // update lender and bucket LP balance\n            fromBucketLender.lps -= fromBucketRedeemedLP_;\n\n            fromBucket.lps = vars.fromBucketRemainingLP;\n        }\n\n        // update lender and bucket LP balance in target bucket\n        Lender storage toBucketLender = toBucket.lenders[msg.sender];\n\n        vars.toBucketDepositTime = toBucketLender.depositTime;\n        if (vars.toBucketBankruptcyTime >= vars.toBucketDepositTime) {\n            // bucket is bankrupt and deposit was done before bankruptcy time, reset lender lp amount\n            toBucketLender.lps = toBucketLP_;\n\n            // set deposit time of the lender's to bucket as bucket's last bankruptcy timestamp + 1 so deposit won't get invalidated\n            vars.toBucketDepositTime = vars.toBucketBankruptcyTime + 1;\n        } else {\n            toBucketLender.lps += toBucketLP_;\n        }\n\n        // set deposit time to the greater of the lender's from bucket and the target bucket\n        toBucketLender.depositTime = Maths.max(vars.fromBucketDepositTime, vars.toBucketDepositTime);\n\n        // update bucket LP balance\n        toBucket.lps += toBucketLP_;\n\n        emit MoveQuoteToken(\n            msg.sender,\n            params_.fromIndex,\n            params_.toIndex,\n            movedAmount_,\n            fromBucketRedeemedLP_,\n            toBucketLP_,\n            lup_\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `_removeMaxDeposit`:\n     *  @dev      `Deposits.unscaledRemove` (remove amount in `Fenwick` tree, from index): update `values` array state\n     *  @dev    - decrement `lender.lps` accumulator\n     *  @dev    - decrement `bucket.lps` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    no `LP` `NoClaim()`;\n     *  @dev    `LUP` lower than `HTP` `LUPBelowHTP()`\n     *  @dev    === Emit events ===\n     *  @dev    - `RemoveQuoteToken`\n     *  @dev    - `BucketBankruptcy`\n     */\n    function removeQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        RemoveQuoteParams calldata params_\n    ) external returns (uint256 removedAmount_, uint256 redeemedLP_, uint256 lup_) {\n        // revert if no amount to be removed\n        if (params_.maxAmount == 0) revert InvalidAmount();\n\n        Bucket storage bucket = buckets_[params_.index];\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 depositTime = lender.depositTime;\n\n        RemoveDepositParams memory removeParams;\n\n        if (bucket.bankruptcyTime < depositTime) removeParams.lpConstraint = lender.lps;\n\n        // revert if no LP to claim\n        if (removeParams.lpConstraint == 0) revert NoClaim();\n\n        removeParams.depositConstraint = params_.maxAmount;\n        removeParams.price             = _priceAt(params_.index);\n        removeParams.bucketLP          = bucket.lps;\n        removeParams.bucketCollateral  = bucket.collateral;\n        removeParams.index             = params_.index;\n        removeParams.dustLimit         = poolState_.quoteTokenScale;\n\n        uint256 unscaledRemaining;\n\n        (removedAmount_, redeemedLP_, unscaledRemaining) = _removeMaxDeposit(\n            deposits_,\n            removeParams\n        );\n\n        lup_ = Deposits.getLup(deposits_, poolState_.debt);\n\n        uint256 htp = Maths.wmul(params_.thresholdPrice, poolState_.inflator);\n\n        if (\n            // check loan book's htp doesn't exceed new lup\n            htp > lup_\n            ||\n            // ensure that pool debt < deposits after removal\n            // this can happen if lup and htp are less than min bucket price and htp > lup (since LUP is capped at min bucket price)\n            (poolState_.debt != 0 && poolState_.debt > Deposits.treeSum(deposits_))\n        ) revert LUPBelowHTP();\n\n        uint256 lpRemaining = removeParams.bucketLP - redeemedLP_;\n\n        // check if bucket healthy after remove quote tokens - set bankruptcy if collateral and deposit are 0 but there's still LP\n        if (removeParams.bucketCollateral == 0 && unscaledRemaining == 0 && lpRemaining != 0) {\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n\n            emit BucketBankruptcy(\n                params_.index,\n                lpRemaining\n            );\n        } else {\n            // update lender and bucket LP balances\n            lender.lps -= redeemedLP_;\n\n            bucket.lps = lpRemaining;\n        }\n\n        emit RemoveQuoteToken(\n            msg.sender,\n            params_.index,\n            removedAmount_,\n            redeemedLP_,\n            lup_\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    decrement `lender.lps` accumulator\n     *  @dev    decrement `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    not enough collateral `InsufficientCollateral()`\n     *  @dev    no `LP` redeemed `InsufficientLP()`\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     */\n    function removeCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 amount_,\n        uint256 index_\n    ) external returns (uint256 lpAmount_) {\n        // revert if no amount to be removed\n        if (amount_ == 0) revert InvalidAmount();\n\n        Bucket storage bucket = buckets_[index_];\n\n        uint256 bucketCollateral = bucket.collateral;\n\n        if (amount_ > bucketCollateral) revert InsufficientCollateral();\n\n        uint256 bucketPrice   = _priceAt(index_);\n        uint256 bucketLP      = bucket.lps;\n        uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n\n        lpAmount_ = Buckets.collateralToLP(\n            bucketCollateral,\n            bucketLP,\n            bucketDeposit,\n            amount_,\n            bucketPrice,\n            Math.Rounding.Up\n        );\n\n        // revert if (due to rounding) required LP is 0\n        if (lpAmount_ == 0) revert InsufficientLP();\n\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 lenderLpBalance;\n        if (bucket.bankruptcyTime < lender.depositTime) lenderLpBalance = lender.lps;\n        if (lenderLpBalance == 0 || lpAmount_ > lenderLpBalance) revert InsufficientLP();\n\n        // update bucket LP and collateral balance\n        bucketLP -= lpAmount_;\n\n        // If clearing out the bucket collateral, ensure it's zeroed out\n        if (bucketLP == 0 && bucketDeposit == 0) {\n            amount_ = bucketCollateral;\n        }\n\n        bucketCollateral  -= amount_;\n        bucket.collateral = bucketCollateral;\n\n        // check if bucket healthy after collateral remove - set bankruptcy if collateral and deposit are 0 but there's still LP\n        if (bucketCollateral == 0 && bucketDeposit == 0 && bucketLP != 0) {\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n\n            emit BucketBankruptcy(\n                index_,\n                bucketLP\n            );\n        } else {\n            // update lender and bucket LP balances\n            lender.lps -= lpAmount_;\n            bucket.lps = bucketLP;\n        }\n    }\n\n    /**\n     *  @notice Removes max collateral amount from a given bucket index.\n     *  @dev    === Write state ===\n     *  @dev    - `_removeMaxCollateral`:\n     *  @dev      decrement `lender.lps` accumulator\n     *  @dev      decrement `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    not enough collateral `InsufficientCollateral()`\n     *  @dev    no claim `NoClaim()`\n     *  @dev    leaves less than dust limit in bucket `DustAmountNotExceeded()`\n     *  @return Amount of collateral that was removed.\n     *  @return Amount of LP redeemed for removed collateral amount.\n     */\n    function removeMaxCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 dustLimit_,\n        uint256 maxAmount_,\n        uint256 index_\n    ) external returns (uint256, uint256) {\n        // revert if no amount to remove\n        if (maxAmount_ == 0) revert InvalidAmount();\n\n        return _removeMaxCollateral(\n            buckets_,\n            deposits_,\n            dustLimit_,\n            maxAmount_,\n            index_\n        );\n    }\n\n    /**\n     *  @notice See `IERC721PoolLenderActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Buckets.addCollateral`:\n     *  @dev      increment `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev      increment `lender.lps` accumulator and `lender.depositTime` state\n     *  @dev    === Reverts on ===\n     *  @dev    invalid merge index `CannotMergeToHigherPrice()`\n     *  @dev    no `LP` awarded in `toIndex_` bucket `InsufficientLP()`\n     *  @dev    no collateral removed from bucket `InvalidAmount()`\n     */\n    function mergeOrRemoveCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256[] calldata removalIndexes_,\n        uint256 collateralAmount_,\n        uint256 toIndex_\n    ) external returns (uint256 collateralToMerge_, uint256 bucketLP_) {\n        uint256 i;\n        uint256 fromIndex;\n        uint256 collateralRemoved;\n        uint256 noOfBuckets = removalIndexes_.length;\n        uint256 collateralRemaining = collateralAmount_;\n\n        // Loop over buckets, exit if collateralAmount is reached or max noOfBuckets is reached\n        while (collateralToMerge_ < collateralAmount_ && i < noOfBuckets) {\n            fromIndex = removalIndexes_[i];\n\n            if (fromIndex > toIndex_) revert CannotMergeToHigherPrice();\n\n            (collateralRemoved, ) = _removeMaxCollateral(\n                buckets_,\n                deposits_,\n                1,                   // dust limit is same as collateral scale\n                collateralRemaining,\n                fromIndex\n            );\n\n            // revert if calculated amount of collateral to remove is 0\n            if (collateralRemoved == 0) revert InvalidAmount();\n\n            collateralToMerge_ += collateralRemoved;\n\n            collateralRemaining = collateralRemaining - collateralRemoved;\n\n            unchecked { ++i; }\n        }\n\n        if (collateralToMerge_ != collateralAmount_) {\n            // Merge totalled collateral to specified bucket, toIndex_\n            uint256 toBucketDeposit = Deposits.valueAt(deposits_, toIndex_);\n            uint256 toBucketPrice   = _priceAt(toIndex_);\n\n            bucketLP_ = Buckets.addCollateral(\n                buckets_[toIndex_],\n                msg.sender,\n                toBucketDeposit,\n                collateralToMerge_,\n                toBucketPrice\n            );\n\n            // revert if (due to rounding) the awarded LP is 0\n            if (bucketLP_ == 0) revert InsufficientLP();\n        }\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Removes max collateral amount from a given bucket index.\n     *  @dev    === Write state ===\n     *  @dev    decrement `lender.lps` accumulator\n     *  @dev    decrement `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    not enough collateral `InsufficientCollateral()`\n     *  @dev    no claim `NoClaim()`\n     *  @dev    no `LP` redeemed `InsufficientLP()`\n     *  @dev    leaves less than dust limit in bucket `DustAmountNotExceeded()`\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @return collateralAmount_ Amount of collateral that was removed.\n     *  @return lpAmount_         Amount of `LP` redeemed for removed collateral amount.\n     */\n    function _removeMaxCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 dustLimit_,\n        uint256 maxAmount_,\n        uint256 index_\n    ) internal returns (uint256 collateralAmount_, uint256 lpAmount_) {\n        Bucket storage bucket = buckets_[index_];\n\n        uint256 bucketCollateral = bucket.collateral;\n        // revert if there's no collateral in bucket\n        if (bucketCollateral == 0) revert InsufficientCollateral();\n\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 lenderLpBalance;\n\n        if (bucket.bankruptcyTime < lender.depositTime) lenderLpBalance = lender.lps;\n        // revert if no LP to redeem\n        if (lenderLpBalance == 0) revert NoClaim();\n\n        uint256 bucketPrice   = _priceAt(index_);\n        uint256 bucketLP     = bucket.lps;\n        uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n\n        // limit amount by what is available in the bucket\n        collateralAmount_ = Maths.min(maxAmount_, bucketCollateral);\n\n        // determine how much LP would be required to remove the requested amount\n        uint256 requiredLP = Buckets.collateralToLP(\n            bucketCollateral,\n            bucketLP,\n            bucketDeposit,\n            collateralAmount_,\n            bucketPrice,\n            Math.Rounding.Up\n        );\n\n        // revert if (due to rounding) the required LP is 0\n        if (requiredLP == 0) revert InsufficientLP();\n\n        // limit withdrawal by the lender's LPB\n        if (requiredLP <= lenderLpBalance) {\n            // withdraw collateralAmount_ as is\n            lpAmount_ = requiredLP;\n        } else {\n            lpAmount_         = lenderLpBalance;\n            collateralAmount_ = Math.mulDiv(lenderLpBalance, collateralAmount_, requiredLP);\n\n            if (collateralAmount_ == 0) revert InsufficientLP();\n        }\n\n        // update bucket LP and collateral balance\n        bucketLP -= Maths.min(bucketLP, lpAmount_);\n\n        // If clearing out the bucket collateral, ensure it's zeroed out\n        if (bucketLP == 0 && bucketDeposit == 0) collateralAmount_ = bucketCollateral;\n\n        collateralAmount_ = Maths.min(bucketCollateral, collateralAmount_);\n        bucketCollateral  -= collateralAmount_;\n        if (bucketCollateral != 0 && bucketCollateral < dustLimit_) revert DustAmountNotExceeded();\n        bucket.collateral = bucketCollateral;\n\n        // check if bucket healthy after collateral remove - set bankruptcy if collateral and deposit are 0 but there's still LP\n        if (bucketCollateral == 0 && bucketDeposit == 0 && bucketLP != 0) {\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n\n            emit BucketBankruptcy(\n                index_,\n                bucketLP\n            );\n        } else {\n            // update lender and bucket LP balances\n            lender.lps -= lpAmount_;\n            bucket.lps = bucketLP;\n        }\n    }\n\n    /**\n     *  @notice Removes the amount of quote tokens calculated for the given amount of LP.\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledRemove` (remove amount in `Fenwick` tree, from index):\n     *  @dev      update `values` array state\n     *  @dev    === Reverts on ===\n     *  @dev    no `LP` redeemed `InsufficientLP()`\n     *  @dev    no unscaled amount removed` `InvalidAmount()`\n     *  @return removedAmount_     Amount of scaled deposit removed.\n     *  @return redeemedLP_        Amount of bucket `LP` corresponding for calculated scaled deposit amount.\n     *  @return unscaledRemaining_ Amount of unscaled deposit remaining.\n     */\n    function _removeMaxDeposit(\n        DepositsState storage deposits_,\n        RemoveDepositParams memory params_\n    ) internal returns (uint256 removedAmount_, uint256 redeemedLP_, uint256 unscaledRemaining_) {\n\n        uint256 unscaledDepositAvailable = Deposits.unscaledValueAt(deposits_, params_.index);\n\n        // revert if there's no liquidity available to remove\n        if (unscaledDepositAvailable == 0) revert InsufficientLiquidity();\n\n        uint256 depositScale           = Deposits.scale(deposits_, params_.index);\n        uint256 scaledDepositAvailable = Maths.wmul(unscaledDepositAvailable, depositScale);\n\n        // Below is pseudocode explaining the logic behind finding the constrained amount of deposit and LPB\n        // scaledRemovedAmount is constrained by the scaled maxAmount(in QT), the scaledDeposit constraint, and\n        // the lender LPB exchange rate in scaled deposit-to-LPB for the bucket:\n        // scaledRemovedAmount = min ( maxAmount_, scaledDeposit, lenderLPBalance*exchangeRate)\n        // redeemedLP_ = min ( maxAmount_/scaledExchangeRate, scaledDeposit/exchangeRate, lenderLPBalance)\n\n        uint256 scaledLpConstraint = Buckets.lpToQuoteTokens(\n            params_.bucketCollateral,\n            params_.bucketLP,\n            scaledDepositAvailable,\n            params_.lpConstraint,\n            params_.price,\n            Math.Rounding.Down\n        );\n        uint256 unscaledRemovedAmount;\n        if (\n            params_.depositConstraint < scaledDepositAvailable &&\n            params_.depositConstraint < scaledLpConstraint\n        ) {\n            // depositConstraint is binding constraint\n            removedAmount_ = params_.depositConstraint;\n            redeemedLP_    = Buckets.quoteTokensToLP(\n                params_.bucketCollateral,\n                params_.bucketLP,\n                scaledDepositAvailable,\n                removedAmount_,\n                params_.price,\n                Math.Rounding.Up\n            );\n            redeemedLP_ = Maths.min(redeemedLP_, params_.lpConstraint);\n            unscaledRemovedAmount = Maths.wdiv(removedAmount_, depositScale);\n        } else if (scaledDepositAvailable < scaledLpConstraint) {\n            // scaledDeposit is binding constraint\n            removedAmount_ = scaledDepositAvailable;\n            redeemedLP_    = Buckets.quoteTokensToLP(\n                params_.bucketCollateral,\n                params_.bucketLP,\n                scaledDepositAvailable,\n                removedAmount_,\n                params_.price,\n                Math.Rounding.Up\n            );\n            redeemedLP_ = Maths.min(redeemedLP_, params_.lpConstraint);\n            unscaledRemovedAmount = unscaledDepositAvailable;\n        } else {\n            // redeeming all LP\n            redeemedLP_    = params"
    }
  ]
}