{
  "Title": "[M-09] Aquifer is vulnerable to Metamorphic Contract Attack",
  "Content": "\nThe [Aquifer](https://github.com/code-423n4/2023-07-basin/blob/9403cf973e95ef7219622dbbe2a08396af90b64c/src/Aquifer.sol#L40-L64) contract supports multiple ways to deploy the `Well` contracts. More specifically, it supports `create` and `create2` at the same time. However, such a feature is vulnerable to the [Metamorphic Contract Attack](https://github.com/0age/metamorphic/tree/master). That is to say, attackers are capable to deploy two different `Well` implementations in the same address, which is recorded by `mapping(address => address) wellImplementations;`.\n\nAlthough the Aquifer contract is claimed to be permissionless, it should not break the immutability. Thus, we consider it a medium-risk bug.\n\n### Impact\n\nThe real implementation of the `Well` contract listed in `Aquifer` may be inconsistent with the expectation of users. Even worse, users may suffer from unexpected loss due to the change of contract logic.\n\n### Proof of Concept\n\n    // the Aquifer contract\n    function boreWell(\n        address implementation,\n        bytes calldata immutableData,\n        bytes calldata initFunctionCall,\n        bytes32 salt\n    ) external nonReentrant returns (address well) {\n        if (immutableData.length > 0) {\n            if (salt != bytes32(0)) {\n                well = implementation.cloneDeterministic(immutableData, salt);\n            } else {\n                well = implementation.clone(immutableData);\n            }\n        } else {\n            if (salt != bytes32(0)) {\n                well = implementation.cloneDeterministic(salt);\n            } else {\n                well = implementation.clone();\n            }\n        }\n        ...\n    }\n\n    // the cloneDeterministic() function\n    function cloneDeterministic(address implementation, bytes32 salt)\n            internal\n            returns (address instance)\n        {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n                mstore(0x14, implementation)\n                mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n                instance := create2(0, 0x0c, 0x35, salt)\n                // Restore the part of the free memory pointer that has been overwritten.\n                mstore(0x21, 0)\n                // If `instance` is zero, revert.\n                if iszero(instance) {\n                    // Store the function selector of `DeploymentFailed()`.\n                    mstore(0x00, 0x30116425)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n\nAs shown in the above code, attackers are capable to deploy new `Well` contracts through `cloneDeterministic` multiple times with the same input parameter `implementation`. And the `cloneDeterministic` function utilizes the following bytecode to deploy a new `Well` contract: `0x602c3d8160093d39f33d3d3d3d363d3d37363d73 + implementation + 5af43d3d93803e602a57fd5bf3`. That is to say, if the address (i.e., `implementation`) remains the same, then the address of the deployed `Well` contract also remains the same.\n\nNormally, EVM would revert if anyone re-deploy a contract to the same address. However, if the `implementation` contract contains self-destruct logic, then attackers can re-deploy a new contract with different bytecode to the same address through `cloneDeterministic`.\n\nHere is how we attack:\n\n*   Assuming Bob deploys `Well_Implementation1` to address 1.\n*   Bob invoke `Aquifer:boreWell` with address 1 as the parameter to get a newly deployed `Well1` contract at address 2.\n*   Bob invokes the self-destruct logic in the `Well_Implementation1` contract and re-deploy a new contract to address 1 through [Metamorphic Contract](https://github.com/0age/metamorphic/tree/master), namely `Well_Implementation2`.\n*   Bob invoke `Aquifer:boreWell` with address 1 again. Since the input of `create2` remains the same, a new contract is deployed to address 2 with new logic from `Well_Implementation2`.\n\n### Recommended Mitigation Steps\n\nRemove the `cloneDeterministic` feature, leaving the `clone` functionality only.\n\n**[publiuss (Basin) acknowledged and commented](https://github.com/code-423n4/2023-07-basin-findings/issues/168#issuecomment-1638531518):**\n > This issue is only an issue if an implementation address contains a way to self-destruct itself. No implementation address should be considered valid if it contains a way to self-destruct. This should be probably documented in all documentation.\n\n\n**[alcueca (Judge) commented](https://github.com/code-423n4/2023-07-basin-findings/issues/168#issuecomment-1665047792):**\n > Agree that this should be documented. It is pertinent to those auditing Wells.\n\n**[publiuss (Basin) commented](https://github.com/code-423n4/2023-07-basin-findings/issues/168#issuecomment-1689105408):**\n > It was documented [here](https://github.com/BeanstalkFarms/Basin/blob/91233a22005986aa7c9f3b0c67393842cd8a8e4d/src/interfaces/IWell.sol#L19).\n> \n> That Well implementations should not be able to self-destruct.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/Aquifer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {ReentrancyGuard} from \"oz/security/ReentrancyGuard.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\nimport {IAquifer} from \"src/interfaces/IAquifer.sol\";\nimport {Well, IWell, Call, IERC20} from \"src/Well.sol\";\nimport {LibClone} from \"src/libraries/LibClone.sol\";\n\n/**\n * @title Aquifer\n * @author Publius, Silo Chad, Brean\n * @notice Aquifer is a permissionless Well registry and factory.\n * @dev Aquifer deploys Wells by cloning a pre-deployed Well implementation.\n */\ncontract Aquifer is IAquifer, ReentrancyGuard {\n    using SafeCast for uint256;\n    using LibClone for address;\n\n    // A mapping of Well address to the Well implementation addresses\n    // Mapping gets set on Well deployment\n    mapping(address => address) wellImplementations;\n\n    constructor() ReentrancyGuard() {}\n\n    /**\n     * @dev\n     * Use `salt == 0` to deploy a new Well with `create`\n     * Use `salt > 0` to deploy a new Well with `create2`\n     */\n    function boreWell(\n        address implementation,\n        bytes calldata immutableData,\n        bytes calldata initFunctionCall,\n        bytes32 salt\n    ) external nonReentrant returns (address well) {\n        if (immutableData.length > 0) {\n            if (salt != bytes32(0)) {\n                well = implementation.cloneDeterministic(immutableData, salt);\n            } else {\n                well = implementation.clone(immutableData);\n            }\n        } else {\n            if (salt != bytes32(0)) {\n                well = implementation.cloneDeterministic(salt);\n            } else {\n                well = implementation.clone();\n            }\n        }\n\n        if (initFunctionCall.length > 0) {\n            (bool success, bytes memory returnData) = well.call(initFunctionCall);\n            if (!success) {\n                // Next 5 lines are based on https://ethereum.stackexchange.com/a/83577\n                if (returnData.length < 68) revert InitFailed(\"\");\n                assembly {\n                    returnData := add(returnData, 0x04)\n                }\n                revert InitFailed(abi.decode(returnData, (string)));\n            }\n        }\n\n        // The Aquifer address MUST be set, either (a) via immutable data during cloning,\n        // or (b) as a storage variable during an init function call. In either case,\n        // the address MUST match the address of the Aquifer that performed deployment.\n        if (IWell(well).aquifer() != address(this)) {\n            revert InvalidConfig();\n        }\n\n        // Save implementation\n        wellImplementations[well] = implementation;\n\n        emit BoreWell(\n            well,\n            implementation,\n            IWell(well).tokens(),\n            IWell(well).wellFunction(),\n            IWell(well).pumps(),\n            IWell(well).wellData()\n        );\n    }\n\n    function wellImplementation(address well) external view returns (address implementation) {\n        return wellImplementations[well];\n    }\n}"
    },
    {
      "filename": "src/interfaces/IWell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"oz/token/ERC20/IERC20.sol\";\n\n/**\n * @title Call is the struct that contains the target address and extra calldata of a generic call.\n */\nstruct Call {\n    address target; // The address the call is executed on.\n    bytes data; // Extra calldata to be passed during the call\n}\n\n/**\n * @title IWell is the interface for the Well contract.\n *\n * In order for a Well to be verified using a permissionless on-chain registry, a Well Implementation should:\n * - Not be able to self-destruct (Aquifer's registry would be vulnerable to a metamorphic contract attack)\n * - Not be able to change its tokens, Well Function, Pumps and Well Data\n */\ninterface IWell {\n    /**\n     * @notice Emitted when a Swap occurs.\n     * @param fromToken The token swapped from\n     * @param toToken The token swapped to\n     * @param amountIn The amount of `fromToken` transferred into the Well\n     * @param amountOut The amount of `toToken` transferred out of the Well\n     * @param recipient The address that received `toToken`\n     */\n    event Swap(IERC20 fromToken, IERC20 toToken, uint256 amountIn, uint256 amountOut, address recipient);\n\n    /**\n     * @notice Emitted when liquidity is added to the Well.\n     * @param tokenAmountsIn The amount of each token added to the Well\n     * @param lpAmountOut The amount of LP tokens minted\n     * @param recipient The address that received the LP tokens\n     */\n    event AddLiquidity(uint256[] tokenAmountsIn, uint256 lpAmountOut, address recipient);\n\n    /**\n     * @notice Emitted when liquidity is removed from the Well as multiple underlying tokens.\n     * @param lpAmountIn The amount of LP tokens burned\n     * @param tokenAmountsOut The amount of each underlying token removed\n     * @param recipient The address that received the underlying tokens\n     * @dev Gas cost scales with `n` tokens.\n     */\n    event RemoveLiquidity(uint256 lpAmountIn, uint256[] tokenAmountsOut, address recipient);\n\n    /**\n     * @notice Emitted when liquidity is removed from the Well as a single underlying token.\n     * @param lpAmountIn The amount of LP tokens burned\n     * @param tokenOut The underlying token removed\n     * @param tokenAmountOut The amount of `tokenOut` removed\n     * @param recipient The address that received the underlying tokens\n     * @dev Emitting a separate event when removing liquidity as a single token\n     * saves gas, since `tokenAmountsOut` in {RemoveLiquidity} must emit a value\n     * for each token in the Well.\n     */\n    event RemoveLiquidityOneToken(uint256 lpAmountIn, IERC20 tokenOut, uint256 tokenAmountOut, address recipient);\n\n    /**\n     * @notice Emitted when a Shift occurs.\n     * @param reserves The ending reserves after a shift\n     * @param toToken The token swapped to\n     * @param amountOut The amount of `toToken` transferred out of the Well\n     * @param recipient The address that received `toToken`\n     */\n    event Shift(uint256[] reserves, IERC20 toToken, uint256 amountOut, address recipient);\n\n    /**\n     * @notice Emitted when a Sync occurs.\n     * @param reserves The ending reserves after a sync\n     * @param lpAmountOut The amount of LP tokens received from the sync.\n     * @param recipient The address that received the LP tokens\n     */\n    event Sync(uint256[] reserves, uint256 lpAmountOut, address recipient);\n\n    //////////////////// WELL DEFINITION ////////////////////\n\n    /**\n     * @notice Returns a list of ERC20 tokens supported by the Well.\n     */\n    function tokens() external view returns (IERC20[] memory);\n\n    /**\n     * @notice Returns the Well function as a Call struct.\n     * @dev Contains the address of the Well function contract and extra data to\n     * pass during calls.\n     *\n     * **Well functions** define a relationship between the reserves of the\n     * tokens in the Well and the number of LP tokens.\n     *\n     * A Well function MUST implement {IWellFunction}.\n     */\n    function wellFunction() external view returns (Call memory);\n\n    /**\n     * @notice Returns the Pumps attached to the Well as Call structs.\n     * @dev Contains the addresses of the Pumps contract and extra data to pass\n     * during calls.\n     *\n     * **Pumps** are on-chain oracles that are updated every time the Well is\n     * interacted with.\n     *\n     * A Pump is not required for Well operation. For Wells without a Pump:\n     * `pumps().length = 0`.\n     *\n     * An attached Pump MUST implement {IPump}.\n     */\n    function pumps() external view returns (Call[] memory);\n\n    /**\n     * @notice Returns the Well data that the Well was bored with.\n     * @dev The existence and signature of Well data is determined by each individual implementation.\n     */\n    function wellData() external view returns (bytes memory);\n\n    /**\n     * @notice Returns the Aquifer that created this Well.\n     * @dev Wells can be permissionlessly bored in an Aquifer.\n     *\n     * Aquifers stores the implementation that was used to bore the Well.\n     */\n    function aquifer() external view returns (address);\n\n    /**\n     * @notice Returns the tokens, Well Function, Pumps and Well Data associated\n     * with the Well as well as the Aquifer that deployed the Well.\n     */\n    function well()\n        external\n        view\n        returns (\n            IERC20[] memory _tokens,\n            Call memory _wellFunction,\n            Call[] memory _pumps,\n            bytes memory _wellData,\n            address _aquifer\n        );\n\n    //////////////////// SWAP: FROM ////////////////////\n\n    /**\n     * @notice Swaps from an exact amount of `fromToken` to a minimum amount of `toToken`.\n     * @param fromToken The token to swap from\n     * @param toToken The token to swap to\n     * @param amountIn The amount of `fromToken` to spend\n     * @param minAmountOut The minimum amount of `toToken` to receive\n     * @param recipient The address to receive `toToken`\n     * @param deadline The timestamp after which this operation is invalid\n     * @return amountOut The amount of `toToken` received\n     */\n    function swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    /**\n     * @notice Swaps from an exact amount of `fromToken` to a minimum amount of `toToken` and supports fee on transfer tokens.\n     * @param fromToken The token to swap from\n     * @param toToken The token to swap to\n     * @param amountIn The amount of `fromToken` to spend\n     * @param minAmountOut The minimum amount of `toToken` to take from the Well. Note that if `toToken` charges a fee on transfer, `recipient` will receive less than this amount.\n     * @param recipient The address to receive `toToken`\n     * @param deadline The timestamp after which this operation is invalid\n     * @return amountOut The amount of `toToken` transferred from the Well. Note that if `toToken` charges a fee on transfer, `recipient` may receive less than this amount.\n     * @dev Can also be used for tokens without a fee on transfer, but is less gas efficient.\n     */\n    function swapFromFeeOnTransfer(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    /**\n     * @notice Gets the amount of one token received for swapping an amount of another token.\n     * @param fromToken The token to swap from\n     * @param toToken The token to swap to\n     * @param amountIn The amount of `fromToken` to spend\n     * @return amountOut The amount of `toToken` to receive\n     */\n    function getSwapOut(IERC20 fromToken, IERC20 toToken, uint256 amountIn) external view returns (uint256 amountOut);\n\n    //////////////////// SWAP: TO ////////////////////\n\n    /**\n     * @notice Swaps from a maximum amount of `fromToken` to an exact amount of `toToken`.\n     * @param fromToken The token to swap from\n     * @param toToken The token to swap to\n     * @param maxAmountIn The maximum amount of `fromToken` to spend\n     * @param amountOut The amount of `toToken` to receive\n     * @param recipient The address to receive `toToken`\n     * @param deadline The timestamp after which this operation is invalid\n     * @return amountIn The amount of `toToken` received\n     */\n    function swapTo(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 maxAmountIn,\n        uint256 amountOut,\n        address recipient,\n        uint256 deadline\n    ) external returns (uint256 amountIn);\n\n    /**\n     * @notice Gets the amount of one token that must be spent to receive an amount of another token during a swap.\n     * @param fromToken The token to swap from\n     * @param toToken The token to swap to\n     * @param amountOut The amount of `toToken` desired\n     * @return amountIn The amount of `fromToken` that must be spent\n     */\n    function getSwapIn(IERC20 fromToken, IERC20 toToken, uint256 amountOut) external view returns (uint256 amountIn);\n\n    //////////////////// SHIFT ////////////////////\n\n    /**\n     * @notice Shifts excess tokens held by the Well into `tokenOut` and delivers to `recipient`.\n     * @param tokenOut The token to shift into\n     * @param minAmountOut The minimum amount of `tokenOut` to receive\n     * @param recipient The address to receive the token\n     * @return amountOut The amount of `tokenOut` received\n     * @dev No deadline is needed since this function does not use the user's assets. If used with\n     * with a multicall contract like Pipeline to perform a swap, a deadline check could be added\n     * to the multicall.\n     */\n    function shift(IERC20 tokenOut, uint256 minAmountOut, address recipient) external returns (uint256 amountOut);\n\n    /**\n     * @notice Calculates the amount of the token out received from shifting excess tokens held by the Well.\n     * @param tokenOut The token to shift into\n     * @return amountOut The amount of `tokenOut` received\n     */\n    function getShiftOut(IERC20 tokenOut) external returns (uint256 amountOut);\n\n    //////////////////// ADD LIQUIDITY ////////////////////\n\n    /**\n     * @notice Adds liquidity to the Well as multiple tokens in any ratio.\n     * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}\n     * @param minLpAmountOut The minimum amount of LP tokens to receive\n     * @param recipient The address to receive the LP tokens\n     * @param deadline The timestamp after which this operation is invalid\n     * @return lpAmountOut The amount of LP tokens received\n     */\n    function addLiquidity(\n        uint256[] memory tokenAmountsIn,\n        uint256 minLpAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external returns (uint256 lpAmountOut);\n\n    /**\n     * @notice Adds liquidity to the Well as multiple tokens in any ratio and supports\n     * fee on transfer tokens.\n     * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}\n     * @param minLpAmountOut The minimum amount of LP tokens to receive\n     * @param recipient The address to receive the LP tokens\n     * @param deadline The timestamp after which this operation is invalid\n     * @return lpAmountOut The amount of LP tokens received\n     * @dev Can also be used for tokens without a fee on transfer, but is less gas efficient.\n     */\n    function addLiquidityFeeOnTransfer(\n        uint256[] memory tokenAmountsIn,\n        uint256 minLpAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external returns (uint256 lpAmountOut);\n\n    /**\n     * @notice Gets the amount of LP tokens received from adding liquidity as multiple tokens in any ratio.\n     * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}\n     * @return lpAmountOut The amount of LP tokens received\n     */\n    function getAddLiquidityOut(uint256[] memory tokenAmountsIn) external view returns (uint256 lpAmountOut);\n\n    //////////////////// REMOVE LIQUIDITY: BALANCED ////////////////////\n\n    /**\n     * @notice Removes liquidity from the Well as all underlying tokens in a balanced ratio.\n     * @param lpAmountIn The amount of LP tokens to burn\n     * @param minTokenAmountsOut The minimum amount of each underlying token to receive; MUST match the indexing of {Well.tokens}\n     * @param recipient The address to receive the underlying tokens\n     * @param deadline The timestamp after which this operation is invalid\n     * @return tokenAmountsOut The amount of each underlying token received\n     */\n    function removeLiquidity(\n        uint256 lpAmountIn,\n        uint256[] calldata minTokenAmountsOut,\n        address recipient,\n        uint256 deadline\n    ) external returns (uint256[] memory tokenAmountsOut);\n\n    /**\n     * @notice Gets the amount of each underlying token received from removing liquidity in a balanced ratio.\n     * @param lpAmountIn The amount of LP tokens to burn\n     * @return tokenAmountsOut The amount of each underlying token received\n     */\n    function getRemoveLiquidityOut(uint256 lpAmountIn) external view returns (uint256[] memory tokenAmountsOut);\n\n    //////////////////// REMOVE LIQUIDITY: ONE TOKEN ////////////////////\n\n    /**\n     * @notice Removes liquidity from the Well as a single underlying token.\n     * @param lpAmountIn The amount of LP tokens to burn\n     * @param tokenOut The underlying token to receive\n     * @param minTokenAmountOut The minimum amount of `tokenOut` to receive\n     * @param recipient The address to receive the underlying tokens\n     * @param deadline The timestamp after which this operation is invalid\n     * @return tokenAmountOut The amount of `tokenOut` received\n     */\n    function removeLiquidityOneToken(\n        uint256 lpAmountIn,\n        IERC20 tokenOut,\n        uint256 minTokenAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external returns (uint256 tokenAmountOut);\n\n    /**\n     * @notice Gets the amount received from removing liquidity from the Well as a single underlying token.\n     * @param lpAmountIn The amount of LP tokens to burn\n     * @param tokenOut The underlying token to receive\n     * @return tokenAmountOut The amount of `tokenOut` received\n     *\n     */\n    function getRemoveLiquidityOneTokenOut(\n        uint256 lpAmountIn,\n        IERC20 tokenOut\n    ) external view returns (uint256 tokenAmountOut);\n\n    //////////////////// REMOVE LIQUIDITY: IMBALANCED ////////////////////\n\n    /**\n     * @notice Removes liquidity from the Well as multiple underlying tokens in any ratio.\n     * @param maxLpAmountIn The maximum amount of LP tokens to burn\n     * @param tokenAmountsOut The amount of each underlying token to receive; MUST match the indexing of {Well.tokens}\n     * @param recipient The address to receive the underlying tokens\n     * @return lpAmountIn The amount of LP tokens burned\n     */\n    function removeLiquidityImbalanced(\n        uint256 maxLpAmountIn,\n        uint256[] calldata tokenAmountsOut,\n        address recipient,\n        uint256 deadline\n    ) external returns (uint256 lpAmountIn);\n\n    /**\n     * @notice Gets the amount of LP tokens to burn from removing liquidity as multiple underlying tokens in any ratio.\n     * @param tokenAmountsOut The amount of each underlying token to receive; MUST match the indexing of {Well.tokens}\n     * @return lpAmountIn The amount of LP tokens burned\n     */\n    function getRemoveLiquidityImbalancedIn(uint256[] calldata tokenAmountsOut)\n        external\n        view\n        returns (uint256 lpAmountIn);\n\n    //////////////////// RESERVES ////////////////////\n\n    /**\n     * @notice Syncs the reserves of the Well with the Well's balances of underlying tokens.\n     * @param recipient The address to receive the LP tokens\n     * @return lpAmountOut The amount of LP tokens received\n     * @dev No deadline is needed since this function does not use the user's assets. If used with\n     * with a multicall contract like Pipeline to perform add liquidity, a deadline check could be\n     * added to the multicall.\n     */\n    function sync(address recipient) external returns (uint256 lpAmountOut);\n\n    /**\n     * @notice Sends excess tokens held by the Well to the `recipient`.\n     * @param recipient The address to send the tokens\n     * @return skimAmounts The amount of each token skimmed\n     * @dev No deadline is needed since this function does not use the user's assets.\n     */\n    function skim(address recipient) external returns (uint256[] memory skimAmounts);\n\n    /**\n     * @notice Gets the reserves of each token held by the Well.\n     */\n    function getReserves() external view returns (uint256[] memory reserves);\n\n    /**\n     * @notice Returns whether or not the Well is initialized if it requires initialization.\n     * If a Well does not require initialization, it should always return `true`.\n     */\n    function isInitialized() external view returns (bool);\n}"
    }
  ]
}