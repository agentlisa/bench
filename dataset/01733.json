{
  "Title": "M-10: User would liquidate his account to sidestep `takerInvariant` modifier",
  "Content": "# Issue M-10: User would liquidate his account to sidestep `takerInvariant` modifier \n\nSource: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/77 \n\n## Found by \nEmmanuel, branch\\_indigo\n## Summary\nA single user could open a massive maker position, using the maximum leverage possible(and possibly reach the maker limit), and when a lot of takers open take positions, maker would liquidate his position, effectively bypassing the taker invariant and losing nothing apart from position fees.\nThis would cause takers to be charged extremely high funding fees(at the maxRate), and takers that are not actively monitoring their positions will be greatly affected. \n\n## Vulnerability Detail\nIn the closeMakeFor function, there is a modifier called `takerInvariant`.\n```solidity\nfunction closeMakeFor(\n        address account,\n        UFixed18 amount\n    )\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        takerInvariant\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeMake(account, amount);\n    }\n```\nThis modifier prevents makers from closing their positions if it would make the global maker open positions to fall below the global taker open positions.\nA malicious maker can easily sidestep this by liquidating his own account.\nLiquidating an account pays the liquidator a fee from the account's collateral, and then forcefully closes all open maker and taker positions for that account.\n```solidity\nfunction closeAll(address account) external onlyCollateral notClosed settleForAccount(account) {\n        AccountPosition storage accountPosition = _positions[account];\n        Position memory p = accountPosition.position.next(_positions[account].pre);\n\n        // Close all positions\n        _closeMake(account, p.maker);\n        _closeTake(account, p.taker);\n\n        // Mark liquidation to lock position\n        accountPosition.liquidation = true; \n    }\n```\nThis would make the open maker positions to drop significantly below the open taker position, and greatly increase the funding fee and utilization ratio.\n\n### ATTACK SCENARIO\n- A new Product(ETH-Long) is launched on arbitrum with the following configurations:\n    - 20x max leverage(5% maintenance)\n    - makerFee = 0\n    - takerFee = 0.015\n    - liquidationFee = 20%\n    - minRate = 4%\n    - maxRate = 120%\n    - targetRate = 12%\n    - targetUtilization = 80%\n    - makerLimit = 4000 Eth\n    - ETH price = 1750 USD\n    - Coll Token = USDC\n    - max liquidity(USD) = 4000*1750 = $7,000,000\n- Whale initially supplies 350k USDC of collateral(~200ETH), and opens a maker position of 3000ETH($5.25mn), at 15x leverage.\n- After 2 weeks of activity, global open maker position goes up to 3429ETH($6mn), and because fundingFee is low, people are incentivized to open taker positions, so global open taker position gets to 2743ETH($4.8mn) at 80% utilization. Now, rate of fundingFee is 12%\n- Now, Whale should only be able to close up to 686ETH($1.2mn) of his maker position using the `closeMakeFor` function because of the `takerInvariant` modifier.\n- Whale decides to withdraw 87.5k USDC(~50ETH), bringing his total collateral to 262.5k USDC, and his leverage to 20x(which is the max leverage)\n- If price of ETH temporarily goes up to 1755 USD, totalMaintenance=3000 * 1755 * 5% = $263250. Because his totalCollateral is 262500 USDC(which is less than totalMaintenance), his account becomes liquidatable.\n- Whale liquidates his account, he receives liquidationFee*totalMaintenance = 20% * 263250 = 52650USDC, and his maker position of 3000ETH gets closed. Now, he can withdraw his remaining collateral(262500-52650=209850)USDC because he has no open positions.\n- Global taker position is now 2743ETH($4.8mn), and global maker position is 429ETH($750k)\n- Whale has succeeded in bypassing the takerInvaraiant modifier, which was to prevent him from closing his maker position if it would make global maker position less than global taker position.\n\nConsequently,\n- Funding fees would now be very high(120%), so the currently open taker positions will be greatly penalized, and takers who are not actively monitoring their position could lose a lot.\n- Whale would want to gain from the high funding fees, so he would open a maker position that would still keep the global maker position less than the global taker position(e.g. collateral of 232750USDC at 15x leverage, open position = ~2000ETH($3.5mn)) so that taker positions will keep getting charged at the funding fee maxRate.\n\n\n## Impact\nUser will close his maker position when he shouldn't be allowed to, and it would cause open taker positions to be greatly impacted. And those who are not actively monitoring their open taker positions will suffer loss due to high funding fees.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/collateral/Collateral.sol#L123-L132\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L362-L372\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L334\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L535-L544\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider implementing any of these:\n- Protocol should receive a share of liquidation fee: This would disincentivize users from wanting to liquidate their own accounts, and they would want to keep their positions healthy and over-collateralized\n- Let there be a maker limit on each account: In addition to the global maker limit, there should be maker limit for each account which may be capped at 5% of global maker limit. This would decentralize liquidity provisioning.\n\n\n\n\n## Discussion\n\n**arjun-io**\n\nThis is working as intended. The market dynamics (namely funding rate curve) should incentivize more makers to come into the market in this case, although it is possible for a malicious maker to temporarily increase funding rates in situations where there is not other LPs (or vaults).\n\n**mstpr**\n\nEscalate for 10 USDC\n\nI think this is an invalid issue. \n\nFirst of all, it's a great example. However, I would consider this as a great trader than an attacker. There are many assumptions and too many risk factors to pull of such thing and it is definitely a very custom scenario. \n\nWhale deposits tons of maker position and waits for utilization to come to 80%. Since this is very unlikely to happen in a block it will happen over time and meanwhile whale is subject to risk for the entire time since makers are taking the opposite direction of the trade. If everything goes well to plan then whale can pull off this action which again in order to do that whale needs to liquidate itself which is another risk. I think there are too much custom assumptions that are most likely never happens in real world scenarios. \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I think this is an invalid issue. \n> \n> First of all, it's a great example. However, I would consider this as a great trader than an attacker. There are many assumptions and too many risk factors to pull of such thing and it is definitely a very custom scenario. \n> \n> Whale deposits tons of maker position and waits for utilization to come to 80%. Since this is very unlikely to happen in a block it will happen over time and meanwhile whale is subject to risk for the entire time since makers are taking the opposite direction of the trade. If everything goes well to plan then whale can pull off this action which again in order to do that whale needs to liquidate itself which is another risk. I think there are too much custom assumptions that are most likely never happens in real world scenarios. \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**flowercrimson**\n\nI think the issue is valid. It points to opportunities to exploit during liquidation because market liquidity protection is completely bypassed.\n\nThe escalation is incorrect in saying that whales are discouraged/unlikely to perform such attacks because of the risks of losing to traders. All makers and traders have risks losing to each other, just because there is inherent risk in trading, doesnâ€™t prevent one from becoming a maker. In addition, makers will also be further compensated with position fees. \n\nTo me, this issue provides a possible scenario where makers can be malicious and there could be more than one malicious makers. \n\nFunding rates might not be sufficient when there are no other LPs, and also because it is designed under the assumption that  `takerOI>makerOI` are edge cases and â€˜very rare situationsâ€™ according to docs. When whale makers can be liquidated in a malicious manner, `takerOI>makerOI` is no longer edge case, it would become a regular occurrence for malicious makers to profit, creating cycles of penalization on takers.\n\n**KenzoAgada**\n\nI think the submission is valid and I agree with flowercrimson's points above.\n\nAdditionally, the original escalation said:\n> I would consider this as a great trader than an attacker\n\nThis reminds me of the Mango Markets exploit, where the exploiter called it _\"a very profitable trading strategy\"_... Yes, there was no smart contract hack or bug, but the economics allowed manipulation.\nThe situation is not the same here, but there is similarity. The issue throws light on a possible strategy that subverts protocol expectations for fair functioning. I think that the scenario that Emmanuel described is not unlikely enough to be totally dismissed.\nThis will cause unsuspecting users to lose funds (pay fees) in a way the protocol didn't intend to (which is why there is `takerInvariant`).\nEven if the protocol \"accepts the risk\", I think this is a good finding that deserves to be pointed out.\nSo I think the first escalation is invalid and a medium severity is appropriate.\n\n**jacksanford1**\n\n@mstpr Anything else to add after seeing @flowercrimson and @KenzoAgada's responses?\n\n**mstpr**\n\n@jacksanford1 The reason why I said great trader than an attacker is because this scenario is not a planned attack scenario. This is a very custom scenario overall. \n\nI think the main problem described here is that, in some cases where it is not possible to exit the market users may put theirselves to liquidation and hope to liquidate themselves to exit the market. Which is correct. However, can you block this from happening? \n\nUser can't decrease their collateral to a level where they are liquidatable. They can decrease the collateral up to liquidation threshold + 1 at minimum. Then, since the market is reporting in settlements, user needs and hopes that the price declines tiny bit more such that the next settlement user is liquidatable. Meanwhile, user needs to make sure that he will be able to liquidate hisself. If someone else liquidates the position, there is no profit or benefit of doing this action. If there is a robust liquidator community then user takes a great risk.\n\nI would say this is valid if only user could have done this actions in 1 tx.\nUser notices he can't exit the market. Reduce some collateral and liquidates hisself in 1 tx.\n\nI think everything works as intended. User doesn't close the position here, user decrease its collateral and hopes to liquidate itself before others. \n\nAnother take to the issue:\nWhale above scenario might say \"I don't care about who liquidates me and takes the liquidation fee I need to exit this position because being a maker in current market will be worse than me to just give up the liquidation fee right now\" . Well, obviously this is a trading choice of the whale then. Pay the liquidation fee and exit your position our wait for the utilization to go down and exit your position. \n\n**jacksanford1**\n\n@flowercrimson @KenzoAgada Any response to @mstpr's latest comment?\n\n**Emedudu**\n\nThe issue here is that `takerInvariant` modifier will not serve its intended purpose.\n\n`takerInvariant` modifier was put in place to ensure that open maker positions does not go lower than open taker positions.\n\nOf course, it is the right of users to close their open positions, but according to Perennial's rules(`takerInvariant` modifier), they shouldn't be able to close their positions such that the global open positions will be less than global taker positions. \n\nI don't think protocol would have added `takerInvariant` to `closeMakeFor` function if they are comfortable with global maker positions dropping below taker positions.\n\n>The reason why I said great trader than an attacker is because this scenario is not a planned attack scenario. This is a very custom scenario overall.\n\nThe protocol put `takerInvariant` in place to prevent this scenario from happening, whether it was a planned attack scenario or not.\n\nBut now, instead of using the normal door way, which is `closeMakeFor` function (which would enforce the rules and restrict a user from closing his position), User goes through \"liquidation\" door way(which would have about same effect as `closeMakeFor` and bypass the rules).\n\nThis would also lead to HIGH funding fees which would be unfair to all open taker positions.\n\n**KenzoAgada**\n\n@mstpr in your reply you kind of reframed the discussion to about \"user may want to liquidate themselves to exit the market\". But what you haven't touched upon in your explanation is the problem of the forced high funding fee.\nLooking at the original issue's example, the whale can \"force\" takers to pay the maximum high maxRate.\nHe can then take another maker position himself and make himself the beneficiary of the payment.\nIsn't this valid as a possible attack path (/a very profitable trading strategy ðŸ™‚)?\n\nI understand there are some requirements, such as no other large maker positions and the attacker/trader liquidating himself (though depending on params that might be less necessary). So it's not a high severity issue. And I understand that the sponsor says this is working as intended and the market _should_ take care of it. But _should_ does not guarantee it... It seems to me that the issue describes a valid possible oversight/exploit of the mechanism.\n\n**jacksanford1**\n\n@arjun-io Do you still feel the same way about this issue?\n\n**arjun-io**\n\nOur view is this is working as intended as per my initial comment (reposted below). Part of a healthy market is numerous LPs (directly or indirectly through the vault). \n\n> This is working as intended. The market dynamics (namely funding rate curve) should incentivize more makers to come into the market in this case, although it is possible for a malicious maker to temporarily increase funding rates in situations where there is not other LPs (or vaults).\n\nOne note: The protocol+market can receive a portion of the close fees which would disincentivize this behavior (similar to the liquidation fee share as described in the recommendation). Capping LPs as a % of the maker limit doesn't really achieve anything, as it creates a bad UX for good actors and bad actors can simply split positions across multiple accounts\n\n\n**jacksanford1**\n\nThis is a really tricky issue. I think the Mango Markets example actually doesn't apply here, and if this were an issue similar to Mango Markets then it would be Low. The Mango Markets exploit was poorly chosen collateral (MNGO token) and/or a poorly chosen LTV for that collateral. Those are not smart contract issues, and the Mango Markets protocol actually functioned exactly as it was intended to function from a smart contract perspective. \n\nBut coming back to the original Impact of this issue:\n\n> User will close his maker position when he shouldn't be allowed to, and it would cause open taker positions to be greatly impacted. And those who are not actively monitoring their open taker positions will suffer loss due to high funding fees.\n\nIf it's true that the user shouldn't be allowed to close his position (i.e. not an intended functionality of the smart contracts) AND if it's true that it could cause potentially large losses for other users, then it should be a Medium. \n\nUnless there is further discussion around either of those aspects (intended functionality or loss potential to users) then this should be a Medium imo. \n\n\n\n**jacksanford1**\n\nResult:\nMedium\nHas duplicates\nSee previous message for reasoning. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/77/#issuecomment-1613235685): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/79",
  "Code": [
    {
      "filename": "perennial-mono/packages/perennial/contracts/collateral/Collateral.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../interfaces/ICollateral.sol\";\nimport \"./types/OptimisticLedger.sol\";\nimport \"../controller/UControllerProvider.sol\";\n\n/**\n * @title Collateral\n * @notice Manages logic and state for all collateral accounts in the protocol.\n */\ncontract Collateral is ICollateral, UInitializable, UControllerProvider, UReentrancyGuard {\n    /// @dev ERC20 stablecoin for collateral\n    Token18 public immutable token;\n\n    /// @dev Per product collateral state\n    mapping(IProduct => OptimisticLedger) private _products;\n\n    /// @dev Protocol and product fees collected, but not yet claimed\n    mapping(address => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the immutable contract state\n     * @dev Called at implementation instantiate and constant for that implementation.\n     * @param token_ Collateral ERC20 stablecoin address\n     */\n    constructor(Token18 token_) {\n        token = token_;\n    }\n\n    /**\n     * @notice Initializes the contract state\n     * @dev Must be called atomically as part of the upgradeable proxy deployment to\n     *      avoid front-running\n     * @param controller_ Factory contract address\n     */\n    function initialize(IController controller_) external initializer(1) {\n        __UControllerProvider__initialize(controller_);\n        __UReentrancyGuard__initialize();\n    }\n\n    /**\n     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`\n     *         account\n     * @param account Account to deposit the collateral for\n     * @param product Product to credit the collateral to\n     * @param amount Amount of collateral to deposit\n     */\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    external\n    nonReentrant\n    notPaused\n    notZeroAddress(account)\n    isProduct(product)\n    collateralInvariant(account, product)\n    {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account\n     *         and sends it to `receiver`\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawTo(address receiver, IProduct product, UFixed18 amount) external {\n        withdrawFrom(msg.sender, receiver, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `account`'s `product` account\n     *         and sends it to `receiver`\n     * @param account Account to withdraw the collateral from\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawFrom(address account, address receiver, IProduct product, UFixed18 amount)\n    public\n    nonReentrant\n    notPaused\n    notZeroAddress(receiver)\n    isProduct(product)\n    onlyAccountOrMultiInvoker(account)\n    settleForAccount(account, product)\n    collateralInvariant(account, product)\n    maintenanceInvariant(account, product)\n    {\n        amount = amount.eq(UFixed18Lib.MAX) ? collateral(account, product) : amount;\n        _products[product].debitAccount(account, amount);\n        token.push(receiver, amount);\n\n        emit Withdrawal(account, product, amount);\n    }\n\n    /**\n     * @notice Liquidates `account`'s `product` collateral account\n     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`\n     * @param account Account to liquidate\n     * @param product Product to liquidate for\n     */\n    function liquidate(address account, IProduct product)\n    external\n    nonReentrant\n    notPaused\n    isProduct(product)\n    settleForAccount(account, product)\n    {\n        if (product.isLiquidating(account)) revert CollateralAccountLiquidatingError(account);\n\n        UFixed18 totalMaintenance = product.maintenance(account);\n        UFixed18 totalCollateral = collateral(account, product);\n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 liquidationFee = controller().liquidationFee();\n        // If maintenance is less than minCollateral, use minCollateral for fee amount\n        UFixed18 collateralForFee = UFixed18Lib.max(totalMaintenance, controller().minCollateral());\n        UFixed18 fee = UFixed18Lib.min(totalCollateral, collateralForFee.mul(liquidationFee));\n\n        _products[product].debitAccount(account, fee);\n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n\n    /**\n     * @notice Credits `amount` to `account`'s collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel.\n     *      Moves collateral within a product, any collateral leaving the product due to\n     *      fees has already been accounted for in the settleProduct flywheel.\n     *      Debits in excess of the account balance get recorded as shortfall, and can be\n     *      resolved by the product owner as needed.\n     * @param account Account to credit\n     * @param amount Amount to credit the account (can be negative)\n     */\n    function settleAccount(address account, Fixed18 amount) external onlyProduct {\n        IProduct product = IProduct(msg.sender);\n\n        UFixed18 newShortfall = _products[product].settleAccount(account, amount);\n\n        emit AccountSettle(product, account, amount, newShortfall);\n    }\n\n    /**\n     * @notice Debits `amount` from product's total collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel\n     *      Removes collateral from the product as fees.\n     * @param amount Amount to debit from the account\n     */\n    function settleProduct(UFixed18 amount) external onlyProduct {\n        (IProduct product, IController controller) = (IProduct(msg.sender), controller());\n\n        address protocolTreasury = controller.treasury();\n        address productTreasury = controller.treasury(product);\n\n        UFixed18 protocolFee = amount.mul(controller.protocolFee());\n        UFixed18 productFee = amount.sub(protocolFee);\n\n        _products[product].debit(amount);\n        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);\n        fees[productTreasury] = fees[productTreasury].add(productFee);\n\n        emit ProductSettle(product, protocolFee, productFee);\n    }\n\n    /**\n     * @notice Returns the balance of `account`'s `product` collateral account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return The balance of the collateral account\n     */\n    function collateral(address account, IProduct product) public view returns (UFixed18) {\n        return _products[product].balances[account];\n    }\n\n    /**\n     * @notice Returns the total balance of `product`'s collateral\n     * @param product Product to return for\n     * @return The total balance of collateral in the product\n     */\n    function collateral(IProduct product) external view returns (UFixed18) {\n        return _products[product].total;\n    }\n\n    /**\n     * @notice Returns the current shortfall of `product`'s collateral\n     * @param product Product to return for\n     * @return The current shortfall of the product\n     */\n    function shortfall(IProduct product) external view returns (UFixed18) {\n        return _products[product].shortfall;\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatable(address account, IProduct product) external view returns (bool) {\n        if (product.isLiquidating(account)) return false;\n\n        return product.maintenance(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     *         after the next oracle version settlement\n     * @dev Takes into account the current pre-position on the account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatableNext(address account, IProduct product) external view returns (bool) {\n        return product.maintenanceNext(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Injects additional collateral into a product to resolve shortfall\n     * @dev Shortfall is a measure of settled insolvency in the market\n     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market\n     * @param product Product to resolve shortfall for\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolveShortfall(IProduct product, UFixed18 amount) external isProduct(product) notPaused {\n        _products[product].resolve(amount);\n        token.pull(msg.sender, amount);\n\n        emit ShortfallResolution(product, amount);\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s fees\n     */\n    function claimFee() external notPaused {\n        UFixed18 amount = fees[msg.sender];\n\n        fees[msg.sender] = UFixed18Lib.ZERO;\n        token.push(msg.sender, amount);\n\n        emit FeeClaim(msg.sender, amount);\n    }\n\n    /// @dev Ensure that the address is non-zero\n    modifier notZeroAddress(address account) {\n        if (account == address(0)) revert CollateralZeroAddressError();\n\n        _;\n    }\n\n    /// @dev Ensure that the user has sufficient margin for both current and next maintenance\n    modifier maintenanceInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 maintenance = product.maintenance(account);\n        UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n            revert CollateralInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the account is either empty or above the collateral minimum\n    modifier collateralInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 accountCollateral = collateral(account, product);\n        if (!accountCollateral.isZero() && accountCollateral.lt(controller().minCollateral()))\n            revert CollateralUnderLimitError();\n    }\n\n    /// @dev Helper to fully settle an account's state\n    modifier settleForAccount(address account, IProduct product) {\n        product.settleAccount(account);\n\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial/contracts/product/Product.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../controller/UControllerProvider.sol\";\nimport \"./UPayoffProvider.sol\";\nimport \"./UParamProvider.sol\";\nimport \"./types/position/AccountPosition.sol\";\nimport \"./types/accumulator/AccountAccumulator.sol\";\n\n/**\n * @title Product\n * @notice Manages logic and state for a single product market.\n * @dev Cloned by the Controller contract to launch new product markets.\n */\ncontract Product is IProduct, UInitializable, UParamProvider, UPayoffProvider, UReentrancyGuard {\n    /// @dev Whether or not the product is closed\n    BoolStorage private constant _closed = BoolStorage.wrap(keccak256(\"equilibria.perennial.Product.closed\"));\n\n    function closed() public view returns (bool) {\n        return _closed.read();\n    }\n\n    /// @dev The name of the product\n    string public name;\n\n    /// @dev The symbol of the product\n    string public symbol;\n\n    /// @dev The individual position state for each account\n    mapping(address => AccountPosition) private _positions;\n\n    /// @dev The global position state for the product\n    VersionedPosition private _position;\n\n    /// @dev The individual accumulator state for each account\n    mapping(address => AccountAccumulator) private _accumulators;\n\n    /// @dev The global accumulator state for the product\n    VersionedAccumulator private _accumulator;\n\n    /**\n     * @notice Initializes the contract state\n     * @param productInfo_ Product initialization params\n     */\n    function initialize(ProductInfo calldata productInfo_) external initializer(1) {\n        __UControllerProvider__initialize(IController(msg.sender));\n        __UPayoffProvider__initialize(productInfo_.oracle, productInfo_.payoffDefinition);\n        __UReentrancyGuard__initialize();\n        __UParamProvider__initialize(\n            productInfo_.maintenance,\n            productInfo_.fundingFee,\n            productInfo_.makerFee,\n            productInfo_.takerFee,\n            productInfo_.positionFee,\n            productInfo_.makerLimit,\n            productInfo_.utilizationCurve\n        );\n\n        name = productInfo_.name;\n        symbol = productInfo_.symbol;\n    }\n\n    /**\n     * @notice Surfaces global settlement externally\n     */\n    function settle() external nonReentrant notPaused {\n        _settle();\n    }\n\n    /**\n     * @notice Core global settlement flywheel\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settle() private returns (IOracleProvider.OracleVersion memory currentOracleVersion) {\n        IController _controller = controller();\n\n        // Get current oracle version\n        currentOracleVersion = _sync();\n\n        // Get latest oracle version\n        uint256 _latestVersion = latestVersion();\n        if (_latestVersion == currentOracleVersion.version) return currentOracleVersion; // short circuit entirely if a == c\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(_latestVersion);\n\n        // Get settle oracle version\n        uint256 _settleVersion = _position.pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // Initiate\n        _controller.incentivizer().sync(currentOracleVersion);\n        UFixed18 boundedFundingFee = _boundedFundingFee();\n\n        // value a->b\n        UFixed18 accumulatedFee = _accumulator.accumulate(\n            boundedFundingFee, _position, latestOracleVersion, settleOracleVersion);\n\n        // position a->b\n        _position.settle(_latestVersion, settleOracleVersion);\n\n        // Apply any pending fee updates if present\n        _settleFeeUpdates();\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // value b->c\n            accumulatedFee = accumulatedFee.add(\n                _accumulator.accumulate(boundedFundingFee, _position, settleOracleVersion, currentOracleVersion)\n            );\n\n            // position b->c (every accumulator version needs a position stamp)\n            _position.settle(settleOracleVersion.version, currentOracleVersion);\n        }\n\n        // settle collateral\n        _controller.collateral().settleProduct(accumulatedFee);\n\n        emit Settle(settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Surfaces account settlement externally\n     * @param account Account to settle\n     */\n    function settleAccount(address account) external nonReentrant notPaused {\n        IOracleProvider.OracleVersion memory currentOracleVersion = _settle();\n        _settleAccount(account, currentOracleVersion);\n    }\n\n    /**\n     * @notice Core account settlement flywheel\n     * @param account Account to settle\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settleAccount(address account, IOracleProvider.OracleVersion memory currentOracleVersion) private {\n        IController _controller = controller();\n\n        // Get latest oracle version\n        if (latestVersion(account) == currentOracleVersion.version) return; // short circuit entirely if a == c\n\n        // Get settle oracle version\n        uint256 _settleVersion = _positions[account].pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // sync incentivizer before accumulator\n        _controller.incentivizer().syncAccount(account, settleOracleVersion);\n\n        // value a->b\n        Fixed18 accumulated = _accumulators[account].syncTo(\n            _accumulator, _positions[account], settleOracleVersion.version).sum();\n\n        // position a->b\n        _positions[account].settle(settleOracleVersion);\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // sync incentivizer before accumulator\n            _controller.incentivizer().syncAccount(account, currentOracleVersion);\n\n            // value b->c\n            accumulated = accumulated.add(\n                _accumulators[account].syncTo(_accumulator, _positions[account], currentOracleVersion.version).sum()\n            );\n        }\n\n        // settle collateral\n        _controller.collateral().settleAccount(account, accumulated);\n\n        emit AccountSettle(account, settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Opens a taker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openTake(UFixed18 amount) external {\n        openTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open the position for\n     * @param amount Amount of the position to open\n     */\n    function openTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        maxUtilizationInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openTake(latestOracleVersion.version, amount);\n        _position.pre.openTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeTake(UFixed18 amount) external {\n        closeTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeTake(account, amount);\n    }\n\n    function _closeTake(address account, UFixed18 amount) private {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.closeTake(latestOracleVersion.version, amount);\n        _position.pre.closeTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeClosed(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openMake(UFixed18 amount) external {\n        openMakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open position for\n     * @param amount Amount of the position to open\n     */\n    function openMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        nonZeroVersionInvariant\n        makerInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openMake(latestOracleVersion.version, amount);\n        _position.pre.openMake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(makerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit MakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeMake(UFixed18 amount) external {\n        closeMakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        takerInvariant\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeMake(account, amount);\n    }\n\n    function _closeMake(address account, UFixed18 amount) private {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.closeMake(latestOracleVersion.version, amount);\n        _position.pre.closeMake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(makerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit MakeClosed(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes all open and pending positions, locking for liquidation\n     * @dev Only callable by the Collateral contract as part of the liquidation flow\n     * @param account Account to close out\n     */\n    function closeAll(address account) external onlyCollateral notClosed settleForAccount(account) {\n        AccountPosition storage accountPosition = _positions[account];\n        Position memory p = accountPosition.position.next(_positions[account].pre);\n\n        // Close all positions\n        _closeMake(account, p.maker);\n        _closeTake(account, p.taker);\n\n        // Mark liquidation to lock position\n        accountPosition.liquidation = true;\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account`\n     * @param account Account to return for\n     * @return The current maintenance requirement\n     */\n    function maintenance(address account) external view returns (UFixed18) {\n        return _positions[account].maintenance();\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account` after next settlement\n     * @dev Assumes no price change and no funding, used to protect user from over-opening\n     * @param account Account to return for\n     * @return The next maintenance requirement\n     */\n    function maintenanceNext(address account) external view returns (UFixed18) {\n        return _positions[account].maintenanceNext();\n    }\n\n    /**\n     * @notice Returns whether `account` has a completely zero'd position\n     * @param account Account to return for\n     * @return The the account is closed\n     */\n    function isClosed(address account) external view returns (bool) {\n        return _positions[account].isClosed();\n    }\n\n    /**\n     * @notice Returns whether `account` is currently locked for an in-progress liquidation\n     * @param account Account to return for\n     * @return Whether the account is in liquidation\n     */\n    function isLiquidating(address account) external view returns (bool) {\n        return _positions[account].liquidation;\n    }\n\n    /**\n     * @notice Returns `account`'s current position\n     * @param account Account to return for\n     * @return Current position of the account\n     */\n    function position(address account) external view returns (Position memory) {\n        return _positions[account].position;\n    }\n\n    /**\n     * @notice Returns `account`'s current pending-settlement position\n     * @param account Account to return for\n     * @return Current pre-position of the account\n     */\n    function pre(address account) external view returns (PrePosition memory) {\n        return _positions[account].pre;\n    }\n\n    /**\n     * @notice Returns the global latest settled oracle version\n     * @return Latest settled oracle version of the product\n     */\n    function latestVersion() public view returns (uint256) {\n        return _accumulator.latestVersion;\n    }\n\n    /**\n     * @notice Returns the global position at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global position at oracle version\n     */\n    function positionAtVersion(uint256 oracleVersion) public view returns (Position memory) {\n        return _position.positionAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns the current global pending-settlement position\n     * @return Global pending-settlement position\n     */\n    function pre() external view returns (PrePosition memory) {\n        return _position.pre;\n    }\n\n    /**\n     * @notice Returns the global accumulator value at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator value at oracle version\n     */\n    function valueAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.valueAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns the global accumulator share at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator share at oracle version\n     */\n    function shareAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.shareAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns `account`'s latest settled oracle version\n     * @param account Account to return for\n     * @return Latest settled oracle version of the account\n     */\n    function latestVersion(address account) public view returns (uint256) {\n        return _accumulators[account].latestVersion;\n    }\n\n    /**\n     * @notice Returns The per-second rate based on the provided `position`\n     * @dev Handles 0-maker/taker edge cases\n     * @param position_ Position to base utilization on\n     * @return The per-second rate\n     */\n    function rate(Position calldata position_) public view returns (Fixed18) {\n        UFixed18 utilization = position_.taker.unsafeDiv(position_.maker);\n        Fixed18 annualizedRate = utilizationCurve().compute(utilization);\n        return annualizedRate.div(Fixed18Lib.from(365 days));\n    }\n\n    /**\n     * @notice Returns the minimum funding fee parameter with a capped range for safety\n     * @dev Caps controller.minFundingFee() <= fundingFee() <= 1\n     * @return Safe minimum funding fee parameter\n     */\n    function _boundedFundingFee() private view returns (UFixed18) {\n        return fundingFee().max(controller().minFundingFee());\n    }\n\n    /**\n     * @notice Updates product closed state\n     * @dev only callable by product owner. Settles the product before flipping the flag\n     * @param newClosed new closed value\n     */\n    function updateClosed(bool newClosed) external nonReentrant notPaused onlyProductOwner {\n        IOracleProvider.OracleVersion memory oracleVersion = _settle();\n        _closed.store(newClosed);\n        emit ClosedUpdated(newClosed, oracleVersion.version);\n    }\n\n    /**\n     * @notice Updates underlying product oracle\n     * @dev only callable by product owner\n     * @param newOracle new oracle address\n     */\n    function updateOracle(IOracleProvider newOracle) external onlyProductOwner {\n        _updateOracle(address(newOracle), latestVersion());\n    }\n\n    /// @dev Limit total maker for guarded rollouts\n    modifier makerInvariant() {\n        _;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n\n        if (next.maker.gt(makerLimit())) revert ProductMakerOverLimitError();\n    }\n\n    /// @dev Limit maker short exposure to the range 0.0-1.0x of their position. Does not apply when in closeOnly state\n    modifier takerInvariant() {\n        _;\n\n        if (closed()) return;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n        UFixed18 socializationFactor = next.socializationFactor();\n\n        if (socializationFactor.lt(UFixed18Lib.ONE)) revert ProductInsufficientLiquidityError(socializationFactor);\n    }\n\n    /// @dev Limit utilization to (1 - utilizationBuffer)\n    modifier maxUtilizationInvariant() {\n        _;\n\n        if (closed()) return;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n        UFixed18 utilization = next.taker.unsafeDiv(next.maker);\n        if (utilization.gt(UFixed18Lib.ONE.sub(utilizationBuffer())))\n            revert ProductInsufficientLiquidityError(utilization);\n    }\n\n    /// @dev Ensure that the user has only taken a maker or taker position, but not both\n    modifier positionInvariant(address account) {\n        _;\n\n        if (_positions[account].isDoubleSided()) re"
    }
  ]
}