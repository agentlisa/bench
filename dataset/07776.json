{
  "Title": "[M-10] address.call{value:x}() should be used instead of payable.transfer()",
  "Content": "# Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L48\n\n\n# Vulnerability details\n\n## Impact\n\nWhen withdrawing and refund  ETH, the  contract uses Solidity’s `transfer()` function. \n\nUsing Solidity's `transfer()` function has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw. Specifically, the withdrawal will inevitably fail when:\n* The withdrawer smart contract does not implement a payable fallback function.\n* The withdrawer smart contract implements a payable fallback function which uses more than 2300 gas units.\n* The withdrawer smart contract implements a payable fallback function which needs less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.\n\nRisks of reentrancy stemming from the use of this function can be mitigated by tightly following the \"Check-Effects-Interactions\" pattern and using OpenZeppelin Contract’s ReentrancyGuard contract. \n\n## Proof of Concept\n\n```solidity\n// Line-of-Credit/contracts/utils/LineLib.sol\n48:    payable(receiver).transfer(amount);\n```\n\n\n#### References:\n\nThe issues with `transfer()` are outlined [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\n)\n\nFor further reference on why using Solidity’s `transfer()` is no longer recommended, refer to these [articles](https://blog.openzeppelin.com/reentrancy-after-istanbul/).\n\n\n\n## Tools Used\nManual analysis.\n\n## Recommended Mitigation Steps\n\nUsing low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised, [reference](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60).\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-debt-dao-contest",
  "Code": [
    {
      "filename": "contracts/utils/LineLib.sol",
      "content": "pragma solidity 0.8.9;\nimport { IInterestRateCredit } from \"../interfaces/IInterestRateCredit.sol\";\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { Denominations } from \"chainlink/Denominations.sol\";\n\n/**\n  * @title Debt DAO Line of Credit Library\n  * @author Kiba Gateaux\n  * @notice Core logic and variables to be reused across all Debt DAO Marketplace Line of Credit contracts\n */\nlibrary LineLib {\n    using SafeERC20 for IERC20;\n\n    error TransferFailed();\n    error BadToken();\n\n    enum STATUS {\n        UNINITIALIZED,\n        ACTIVE,\n        LIQUIDATABLE,\n        REPAID,\n        INSOLVENT\n    }\n\n    /**\n     * @notice - Send ETH or ERC20 token from this contract to an external contract\n     * @param token - address of token to send out. Denominations.ETH for raw ETH\n     * @param receiver - address to send tokens to\n     * @param amount - amount of tokens to send\n     */\n    function sendOutTokenOrETH(\n      address token,\n      address receiver,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        \n        // both branches revert if call failed\n        if(token!= Denominations.ETH) { // ERC20\n            IERC20(token).safeTransfer(receiver, amount);\n        } else { // ETH\n            payable(receiver).transfer(amount);\n        }\n        return true;\n    }\n\n    /**\n     * @notice - Receive ETH or ERC20 token at this contract from an external contract\n     * @param token - address of token to receive. Denominations.ETH for raw ETH\n     * @param sender - address that is sendingtokens/ETH\n     * @param amount - amount of tokens to send\n     */\n    function receiveTokenOrETH(\n      address token,\n      address sender,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        if(token != Denominations.ETH) { // ERC20\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n            if(msg.value < amount) { revert TransferFailed(); }\n        }\n        return true;\n    }\n\n    /**\n     * @notice - Helper function to get current balance of this contract for ERC20 or ETH\n     * @param token - address of token to check. Denominations.ETH for raw ETH\n    */\n    function getBalance(address token) external view returns (uint256) {\n        if(token == address(0)) return 0;\n        return token != Denominations.ETH ?\n            IERC20(token).balanceOf(address(this)) :\n            address(this).balance;\n    }\n\n}"
    }
  ]
}