{
  "Title": "[H-06] Repaying a line of credit with a higher than necessary claimed revenue amount will force the borrower into liquidation",
  "Content": "# Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186\n\n\n# Vulnerability details\n\nA borrower can repay (parts) of a credit line with the `SpigotedLine.useAndRepay` function. This function will use `amount` of `unusedTokens[credit.token]` as a repayment. However, if `amount` exceeds the principal and the accrued interest, `credit.principal` will underflow without an error and set the principal value to a very large number.\n\nThis a problem because a borrower can unknowingly provide a larger than necessary `amount` to the `SpigotedLine.useAndRepay` function to make sure enough funds are used to fully repay the principal and the remaining interest.\n\nAdditionally, a lender can do the same thing as the lender can call this function.\n\n## Impact\n\nThe `credit.principal` underflows without an error and will be set to a very large number. This will force a secured line **immediately** into liquidation. Additionally, having a principal value close to `2^256 - 1` will make it hugely expensive to repay the credit line.\n\n## Proof of Concept\n\n[utils/CreditLib.sol#L186](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186)\n\n```solidity\nfunction repay(\n  ILineOfCredit.Credit memory credit,\n  bytes32 id,\n  uint256 amount\n)\n  external\n  returns (ILineOfCredit.Credit memory)\n{ unchecked {\n    if (amount <= credit.interestAccrued) {\n        credit.interestAccrued -= amount;\n        credit.interestRepaid += amount;\n        emit RepayInterest(id, amount);\n        return credit;\n    } else {\n        uint256 interest = credit.interestAccrued;\n        uint256 principalPayment = amount - interest;\n\n        // update individual credit line denominated in token\n        credit.principal -= principalPayment; // @audit-info potential underflow without an error due to the unchecked block\n        credit.interestRepaid += interest;\n        credit.interestAccrued = 0;\n\n        emit RepayInterest(id, interest);\n        emit RepayPrincipal(id, principalPayment);\n\n        return credit;\n    }\n} }\n```\n\nTo demonstrate the issue, copy the following test case and paste it into the `SpigotedLine.t.sol` test file. Then run `forge test --match-test \"test_lender_use_and_repay_underflow\"`.\n\nFollowing scenario causes the repayment to underflow:\n\n1. Borrower borrows `1 ether` of `revenueToken`\n2. `2 ether` worth of `revenueToken` is claimed and traded from the revenue contract\n3. Use all of the previously claimed funds (`2 ether`) to repay the line of credit (= `1 ether`)\n4. `credit.principal` underflows due to `principalPayment` is larger than `credit.principal`\n\n```solidity\nfunction test_lender_use_and_repay_underflow() public {\n    uint256 largeRevenueAmount = lentAmount * 2;\n\n    deal(address(lender), lentAmount + 1 ether);\n    deal(address(revenueToken), MAX_REVENUE);\n    address revenueC = address(0xbeef); // need new spigot for testing\n    bytes32 id = _createCredit(address(revenueToken), Denominations.ETH, revenueC);\n\n    // 1. Borrow lentAmount = 1 ether\n    _borrow(id, lentAmount);\n\n    // 2. Claim and trade largeRevenueAmount = 2 ether (revenue)\n    bytes memory tradeData = abi.encodeWithSignature(\n      'trade(address,address,uint256,uint256)',\n      address(revenueToken),\n      Denominations.ETH,\n      1 gwei,\n      largeRevenueAmount\n    );\n\n    hoax(borrower);\n    line.claimAndTrade(address(revenueToken), tradeData);\n\n    (, uint256 principalBeforeRepaying,,,,,) = line.credits(line.ids(0));\n    assertEq(principalBeforeRepaying, lentAmount);\n\n    // 3. Use and repay debt with previously claimed and traded revenue (largeRevenueAmount = 2 ether)\n    vm.prank(lender);\n    line.useAndRepay(largeRevenueAmount);\n    (, uint256 _principal,,,,,) = line.credits(line.ids(0));\n\n    uint256 underflowedPrincipal = principalBeforeRepaying;\n\n    unchecked {\n      underflowedPrincipal -= (largeRevenueAmount);\n    }\n\n    // 4. Principal underflowed\n    assertEq(_principal, underflowedPrincipal);\n  }\n```\n\n## Tools Used\n\nManual review\n\n## Recommended mitigation steps\n\nConsider asserting `amount` is less or equal than `credit.principal + credit.interestAccrued` (`require(amount <= credit.principal + credit.interestAccrued);`). Similar as how it is done in [`LineOfCredit.depositAndRepay()`](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L326)\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-debt-dao-contest",
  "Code": [
    {
      "filename": "contracts/utils/CreditLib.sol",
      "content": "pragma solidity 0.8.9;\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IInterestRateCredit } from \"../interfaces/IInterestRateCredit.sol\";\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { LineLib } from \"./LineLib.sol\";\n\n/**\n  * @title Debt DAO Line of Credit Library\n  * @author Kiba Gateaux\n  * @notice Core logic and variables to be reused across all Debt DAO Marketplace Line of Credit contracts\n */\nlibrary CreditLib {\n\n    event AddCredit(\n        address indexed lender,\n        address indexed token,\n        uint256 indexed deposit,\n        bytes32 id\n    );\n\n  /// @notice Emits data re Lender removes funds (principal) - there is no corresponding function, just withdraw()\n  event WithdrawDeposit(bytes32 indexed id, uint256 indexed amount);\n  \n  /// @notice Emits data re Lender withdraws interest - there is no corresponding function, just withdraw()\n  // Bob - consider changing event name to WithdrawInterest\n  event WithdrawProfit(bytes32 indexed id, uint256 indexed amount);\n  \n\n  /// @notice After accrueInterest runs, emits the amount of interest added to a Borrower's outstanding balance of interest due \n  // but not yet repaid to the Line of Credit contract\n  event InterestAccrued(bytes32 indexed id, uint256 indexed amount);\n\n\n  // Borrower Events\n\n  event Borrow(bytes32 indexed id, uint256 indexed amount);\n  // Emits notice that a Borrower has drawn down an amount on a credit line\n\n  event RepayInterest(bytes32 indexed id, uint256 indexed amount);\n  /** Emits that a Borrower has repaid an amount of interest \n  (N.B. results in an increase in interestRepaid, i.e. interest not yet withdrawn by a Lender). There is no corresponding function\n  */\n  \n  event RepayPrincipal(bytes32 indexed id, uint256 indexed amount);\n  // Emits that a Borrower has repaid an amount of principal - there is no corresponding function\n\n  error NoTokenPrice();\n\n  error PositionExists();\n\n\n  /**\n   * @dev          - Creates a deterministic hash id for a credit line provided by a single Lender for a given token on a Line of Credit facility\n   * @param line   - The Line of Credit facility concerned\n   * @param lender - The address managing the credit line concerned\n   * @param token  - The token being lent out on the credit line concerned\n   * @return id\n   */\n  function computeId(\n    address line,\n    address lender,\n    address token\n  )\n    external pure\n    returns(bytes32)\n  {\n    return keccak256(abi.encode(line, lender, token));\n  }\n\n  // getOutstandingDebt() is called by updateOutstandingDebt()\n  function getOutstandingDebt(\n    ILineOfCredit.Credit memory credit,\n    bytes32 id,\n    address oracle,\n    address interestRate\n  )\n    external\n    returns (ILineOfCredit.Credit memory c, uint256 principal, uint256 interest)\n  {\n    c = accrue(credit, id, interestRate);\n\n    int256 price = IOracle(oracle).getLatestAnswer(c.token);\n\n    principal = calculateValue(\n      price,\n      c.principal,\n      c.decimals\n    );\n    interest = calculateValue(\n      price,\n      c.interestAccrued,\n      c.decimals\n    );\n\n    return (c, principal, interest);\n  }\n\n    /**\n    * @notice         - Calculates value of tokens.  Used for calculating the USD value of principal and of interest during getOutstandingDebt()\n    * @dev            - Assumes Oracle returns answers in USD with 1e8 decimals\n                      - If price < 0 then we treat it as 0.\n    * @param price    - The Oracle price of the asset. 8 decimals\n    * @param amount   - The amount of tokens being valued.\n    * @param decimals - Token decimals to remove for USD price\n    * @return         - The total USD value of the amount of tokens being valued in 8 decimals \n    */\n  function calculateValue(\n    int price,\n    uint256 amount,\n    uint8 decimals\n  )\n    public  pure\n    returns(uint256)\n  {\n    return price <= 0 ? 0 : (amount * uint(price)) / (1 * 10 ** decimals);\n  }\n  \n  /**\n    * see ILineOfCredit._createCredit\n    * @notice called by LineOfCredit._createCredit during every repayment function\n    * @param oracle - interset rate contract used by line that will calculate interest owed\n   */\n  function create(\n      bytes32 id,\n      uint256 amount,\n      address lender,\n      address token,\n      address oracle\n  )\n      external \n      returns(ILineOfCredit.Credit memory credit)\n  {\n      int price = IOracle(oracle).getLatestAnswer(token);\n      if(price <= 0 ) { revert NoTokenPrice(); }\n\n      uint8 decimals;\n      if(token == Denominations.ETH) {\n          decimals = 18;\n      } else {\n          (bool passed, bytes memory result) = token.call(\n              abi.encodeWithSignature(\"decimals()\")\n          );\n          decimals = !passed ? 18 : abi.decode(result, (uint8));\n      }\n\n      credit = ILineOfCredit.Credit({\n          lender: lender,\n          token: token,\n          decimals: decimals,\n          deposit: amount,\n          principal: 0,\n          interestAccrued: 0,\n          interestRepaid: 0\n      });\n\n      emit AddCredit(lender, token, amount, id);\n\n      return credit;\n  }\n\n  /**\n    * see ILineOfCredit._repay\n    * @notice called by LineOfCredit._repay during every repayment function\n    * @param credit - The lender position being repaid\n   */\n  function repay(\n    ILineOfCredit.Credit memory credit,\n    bytes32 id,\n    uint256 amount\n  )\n    external\n    returns (ILineOfCredit.Credit memory)\n  { unchecked {\n      if (amount <= credit.interestAccrued) {\n          credit.interestAccrued -= amount;\n          credit.interestRepaid += amount;\n          emit RepayInterest(id, amount);\n          return credit;\n      } else {\n          uint256 interest = credit.interestAccrued;\n          uint256 principalPayment = amount - interest;\n\n          // update individual credit line denominated in token\n          credit.principal -= principalPayment;\n          credit.interestRepaid += interest;\n          credit.interestAccrued = 0;\n\n          emit RepayInterest(id, interest);\n          emit RepayPrincipal(id, principalPayment);\n\n          return credit;\n      }\n  } }\n\n  /**\n    * see ILineOfCredit.withdraw\n    * @notice called by LineOfCredit.withdraw during every repayment function\n    * @param credit - The lender position that is being bwithdrawn from\n   */\n  function withdraw(\n    ILineOfCredit.Credit memory credit,\n    bytes32 id,\n    uint256 amount\n  )\n    external\n    returns (ILineOfCredit.Credit memory)\n  { unchecked {\n      if(amount > credit.deposit - credit.principal + credit.interestRepaid) {\n        revert ILineOfCredit.NoLiquidity();\n      }\n\n      if (amount > credit.interestRepaid) {\n          uint256 interest = credit.interestRepaid;\n          amount -= interest;\n\n          credit.deposit -= amount;\n          credit.interestRepaid = 0;\n\n          // emit events before seeting to 0\n          emit WithdrawDeposit(id, amount);\n          emit WithdrawProfit(id, interest);\n\n          return credit;\n      } else {\n          credit.interestRepaid -= amount;\n          emit WithdrawProfit(id, amount);\n          return credit;\n      }\n  } }\n\n\n  /**\n    * see ILineOfCredit._accrue\n    * @notice called by LineOfCredit._accrue during every repayment function\n    * @param interest - interset rate contract used by line that will calculate interest owed\n   */\n  function accrue(\n    ILineOfCredit.Credit memory credit,\n    bytes32 id,\n    address interest\n  )\n    public\n    returns (ILineOfCredit.Credit memory)\n  { unchecked {\n      // interest will almost always be less than deposit\n      // low risk of overflow unless extremely high interest rate\n\n      // get token demoninated interest accrued\n      uint256 accruedToken = IInterestRateCredit(interest).accrueInterest(\n          id,\n          credit.principal,\n          credit.deposit\n      );\n\n      // update credit line balance\n      credit.interestAccrued += accruedToken;\n\n      emit InterestAccrued(id, accruedToken);\n      return credit;\n  } }\n}"
    }
  ]
}