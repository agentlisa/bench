{
  "Title": "[M-05] Oracle.getUnderlyingPrice could have wrong decimals",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L34\n\n\n# Vulnerability details\n\n## Impact\nThe `Oracle.getUnderlyingPrice` function divides the chainlink price by `100`.\nIt probably assumes that the answer for the underlying is in 8 decimals but then wants to reduce it for 6 decimals to match USDC.\n\nHowever, arbitrary `underlying` tokens are used and the chainlink oracles can have different decimals.\n\n## Recommended Mitigation Steps\nWhile most USD price feeds use 8 decimals, it's better to take the on-chain reported decimals into account by doing `AggregatorV3Interface(chainLinkAggregatorMap[underlying]).decimals()`, see [Chainlink docs](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination).\nThe price should then be scaled down to 6 decimals.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { AggregatorV3Interface } from \"./Interfaces.sol\";\n\ncontract Oracle is Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    mapping(address => address) public chainLinkAggregatorMap;\n    mapping(address => int256) public stablePrice;\n\n    uint256[50] private __gap;\n\n    function initialize(address _governance) external initializer {\n        _setGovernace(_governance);\n    }\n\n    function getUnderlyingPrice(address underlying)\n        virtual\n        external\n        view\n        returns(int256 answer)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        (,answer,,,) = AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData();\n        answer /= 100;\n    }\n\n    function getUnderlyingTwapPrice(address underlying, uint256 intervalInSeconds)\n        virtual\n        public\n        view\n        returns (int256)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]);\n        requireNonEmptyAddress(address(aggregator));\n        require(intervalInSeconds != 0, \"interval can't be 0\");\n\n        // 3 different timestamps, `previous`, `current`, `target`\n        // `base` = now - intervalInSeconds\n        // `current` = current round timestamp from aggregator\n        // `previous` = previous round timestamp form aggregator\n        // now >= previous > current > = < base\n        //\n        //  while loop i = 0\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base                 current  now(previous)\n        //\n        //  while loop i = 1\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base           current previous now\n\n        (uint80 round, uint256 latestPrice, uint256 latestTimestamp) = getLatestRoundData(aggregator);\n        uint256 baseTimestamp = _blockTimestamp() - intervalInSeconds;\n        // if latest updated timestamp is earlier than target timestamp, return the latest price.\n        if (latestTimestamp < baseTimestamp || round == 0) {\n            return formatPrice(latestPrice);\n        }\n\n        // rounds are like snapshots, latestRound means the latest price snapshot. follow chainlink naming\n        uint256 previousTimestamp = latestTimestamp;\n        uint256 cumulativeTime = _blockTimestamp() - previousTimestamp;\n        uint256 weightedPrice = latestPrice * cumulativeTime;\n        while (true) {\n            if (round == 0) {\n                // if cumulative time is less than requested interval, return current twap price\n                return formatPrice(weightedPrice / cumulativeTime);\n            }\n\n            round = round - 1; // check round sanity\n            (, uint256 currentPrice, uint256 currentTimestamp) = getRoundData(aggregator, round);\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentTimestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, intervalInSeconds is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice + (currentPrice * (previousTimestamp - baseTimestamp));\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp - currentTimestamp;\n            weightedPrice = weightedPrice + (currentPrice * timeFraction);\n            cumulativeTime = cumulativeTime + timeFraction;\n            previousTimestamp = currentTimestamp;\n        }\n        return formatPrice(weightedPrice / intervalInSeconds);\n    }\n\n    //\n    // INTERNAL VIEW FUNCTIONS\n    //\n\n    function getLatestRoundData(AggregatorV3Interface _aggregator)\n        internal\n        view\n        returns (\n            uint80,\n            uint256 finalPrice,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();\n        finalPrice = uint256(latestPrice);\n        if (latestPrice < 0) {\n            requireEnoughHistory(round);\n            (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);\n        }\n        return (round, finalPrice, latestTimestamp);\n    }\n\n    function getRoundData(AggregatorV3Interface _aggregator, uint80 _round)\n        internal\n        view\n        returns (\n            uint80,\n            uint256,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.getRoundData(_round);\n        while (latestPrice < 0) {\n            requireEnoughHistory(round);\n            round = round - 1;\n            (, latestPrice, , latestTimestamp, ) = _aggregator.getRoundData(round);\n        }\n        return (round, uint256(latestPrice), latestTimestamp);\n    }\n\n    function formatPrice(uint256 _price) internal pure returns (int256) {\n        return (_price / 100).toInt256(); // 6 decimals\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    // Internal\n\n    function requireEnoughHistory(uint80 _round) internal pure {\n        require(_round > 0, \"Not enough history\");\n    }\n\n    function requireNonEmptyAddress(address _addr) internal pure {\n        require(_addr != address(0), \"empty address\");\n    }\n\n    // Governance\n\n    function setAggregator(address underlying, address aggregator) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        requireNonEmptyAddress(aggregator);\n        chainLinkAggregatorMap[underlying] = aggregator;\n        // AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData(); // sanity check\n    }\n\n    function setStablePrice(address underlying, int256 price) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        stablePrice[underlying] = price;\n    }\n}"
    }
  ]
}