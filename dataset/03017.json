{
  "Title": "M-1: Unregulated joining fees",
  "Content": "# Issue M-1: Unregulated joining fees \n\nSource: https://github.com/sherlock-audit/2022-09-sherlock-judging/tree/main/001-M \n\n## Found by \ncsanuragjain, defsec\n\n## Summary\ntfUSDC.join deducts fees from deposited balance. Now this fees is unregulated and could be 100% of amount passed as can be seen at setJoiningFee function at https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L449. Since minting will not fail even with zero amount, our contract will end up everything given as fees\n\n## Vulnerability Detail\n1. Observe the _deposit function\n\n```python\nfunction _deposit() internal override whenNotPaused {\n    // https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L469\n    tfUSDC.join(want.balanceOf(address(this)));\n...\n}\n```\n\n2. This makes call to [join function](https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L469)\n\n```python\nfunction join(uint256 amount) external override joiningNotPaused {\n        uint256 fee = amount.mul(joiningFee).div(BASIS_PRECISION);\n        uint256 mintedAmount = mint(amount.sub(fee));\n        claimableFees = claimableFees.add(fee);\n\n        // TODO: tx.origin will be deprecated in a future ethereum upgrade\n        latestJoinBlock[tx.origin] = block.number;\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Joined(msg.sender, amount, mintedAmount);\n    }\n```\n\n3. As we can see this join function deducts a fees from the deposited amount before minting. Lets see this joining fees\n4. The joining fees is introduced using [setJoiningFee function](https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L449)\n\n```python\nfunction setJoiningFee(uint256 fee) external onlyOwner {\n        require(fee <= BASIS_PRECISION, \"TrueFiPool: Fee cannot exceed transaction value\");\n        joiningFee = fee;\n        emit JoiningFeeChanged(fee);\n    }\n```\n\n5. This means the joiningFee will always be in between 0 to BASIS_PRECISION. This BASIS_PRECISION can be 100% as shown\n\n```python\nuint256 private constant BASIS_PRECISION = 10000;\n```\n\n6. This means if joiningFee is set to BASIS_PRECISION then all user deposit will goto joining fees with user getting nothing\n\n## Impact\nContract will lose all deposited funds\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-09-sherlock/blob/main/sherlock-v2-core/contracts/strategy/TrueFiStrategy.sol#L90\n\n## Tool used\nManual Review\n\n## Recommendation\nPost calling join, check amount of shares minted for this user (use balanceOF on TrueFiPool2.sol) and if it is below minimum expected revert the transaction\n\n```python\nuint256 tfUsdcBalance = tfUSDC.balanceOf(address(this));\nrequire(tfUsdcBalance>=minSharesExpected, \"Too high fees\");\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/5",
  "Code": [
    {
      "filename": "contracts/truefi2/TrueFiPool2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {ERC20} from \"../common/UpgradeableERC20.sol\";\nimport {UpgradeableClaimable} from \"../common/UpgradeableClaimable.sol\";\n\nimport {IFixedTermLoanAgency} from \"./interface/IFixedTermLoanAgency.sol\";\nimport {ITrueStrategy} from \"./interface/ITrueStrategy.sol\";\nimport {ITrueFiPool2, ITrueFiPoolOracle} from \"./interface/ITrueFiPool2.sol\";\nimport {ITrueLender2Deprecated} from \"./deprecated/ITrueLender2Deprecated.sol\";\nimport {ILoanToken2Deprecated} from \"./deprecated/ILoanToken2Deprecated.sol\";\nimport {IFixedTermLoan} from \"./interface/IFixedTermLoan.sol\";\nimport {IDebtToken} from \"./interface/IDebtToken.sol\";\nimport {IPauseableContract} from \"../common/interface/IPauseableContract.sol\";\nimport {ISAFU} from \"./interface/ISAFU.sol\";\nimport {IDeficiencyToken} from \"./interface/IDeficiencyToken.sol\";\nimport {ILineOfCreditAgency} from \"./interface/ILineOfCreditAgency.sol\";\nimport {ILoanFactory2} from \"./interface/ILoanFactory2.sol\";\n\nimport {ABDKMath64x64} from \"../truefi/Log.sol\";\n\n/**\n * @title TrueFiPool2\n * @dev Lending pool which may use a strategy to store idle funds\n * Earn high interest rates on currency deposits through uncollateralized loans\n *\n * Funds deposited in this pool are not fully liquid.\n * Exiting incurs an exit penalty depending on pool liquidity\n * After exiting, an account will need to wait for LoanTokens to expire and burn them\n * It is recommended to perform a zap or swap tokens on Uniswap for increased liquidity\n *\n * Funds are managed through an external function to save gas on deposits\n */\ncontract TrueFiPool2 is ITrueFiPool2, IPauseableContract, ERC20, UpgradeableClaimable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IDeficiencyToken;\n    using SafeERC20 for IDebtToken;\n\n    uint256 private constant BASIS_PRECISION = 10000;\n\n    // max slippage on liquidation token swaps\n    // Measured in basis points, e.g. 10000 = 100%\n    uint16 public constant TOLERATED_SLIPPAGE = 100; // 1%\n\n    // tolerance difference between\n    // expected and actual transaction results\n    // when dealing with strategies\n    // Measured in  basis points, e.g. 10000 = 100%\n    uint16 public constant TOLERATED_STRATEGY_LOSS = 10; // 0.1%\n\n    // ================ WARNING ==================\n    // ===== THIS CONTRACT IS INITIALIZABLE ======\n    // === STORAGE VARIABLES ARE DECLARED BELOW ==\n    // REMOVAL OR REORDER OF VARIABLES WILL RESULT\n    // ========= IN STORAGE CORRUPTION ===========\n\n    uint8 public constant VERSION = 1;\n\n    ERC20 public override token;\n\n    ITrueStrategy public strategy;\n    ITrueLender2Deprecated public lender;\n\n    // fee for deposits\n    // fee precision: 10000 = 100%\n    uint256 public joiningFee;\n    // track claimable fees\n    uint256 public claimableFees;\n\n    mapping(address => uint256) latestJoinBlock;\n\n    address private DEPRECATED__liquidationToken;\n\n    ITrueFiPoolOracle public override oracle;\n\n    // allow pausing of deposits\n    bool public pauseStatus;\n\n    // cache values during sync for gas optimization\n    bool private inSync;\n    uint256 private strategyValueCache;\n    uint256 private loansValueCache;\n\n    // who gets all fees\n    address public beneficiary;\n\n    address private DEPRECATED__1Inch;\n\n    ISAFU public safu;\n\n    ILineOfCreditAgency public creditAgency;\n\n    uint256 public debtValue;\n\n    IFixedTermLoanAgency public ftlAgency;\n\n    ILoanFactory2 public loanFactory;\n\n    // ======= STORAGE DECLARATION END ===========\n\n    /**\n     * @dev Helper function to concatenate two strings\n     * @param a First part of string to concat\n     * @param b Second part of string to concat\n     * @return Concatenated string of `a` and `b`\n     */\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n\n    function initialize(\n        ERC20 _token,\n        IFixedTermLoanAgency _ftlAgency,\n        ISAFU _safu,\n        ILoanFactory2 _loanFactory,\n        address __owner\n    ) external override initializer {\n        ERC20.__ERC20_initialize(concat(\"TrueFi \", _token.name()), concat(\"tf\", _token.symbol()));\n        UpgradeableClaimable.initialize(__owner);\n\n        token = _token;\n        ftlAgency = _ftlAgency;\n        lender = ITrueLender2Deprecated(address(0));\n        safu = _safu;\n        loanFactory = _loanFactory;\n    }\n\n    /**\n     * @dev Initializer for single borrower pools\n     */\n    function singleBorrowerInitialize(\n        ERC20 _token,\n        IFixedTermLoanAgency _ftlAgency,\n        ISAFU _safu,\n        ILoanFactory2 _loanFactory,\n        address __owner,\n        string memory borrowerName,\n        string memory borrowerSymbol\n    ) external override initializer {\n        ERC20.__ERC20_initialize(\n            concat(concat(\"TrueFi \", borrowerName), concat(\" \", _token.name())),\n            concat(concat(\"tf\", borrowerSymbol), _token.symbol())\n        );\n        UpgradeableClaimable.initialize(__owner);\n\n        token = _token;\n        ftlAgency = _ftlAgency;\n        safu = _safu;\n        loanFactory = _loanFactory;\n    }\n\n    /**\n     * @dev Emitted when fee is changed\n     * @param newFee New fee\n     */\n    event JoiningFeeChanged(uint256 newFee);\n\n    /**\n     * @dev Emitted when beneficiary is changed\n     * @param newBeneficiary New beneficiary\n     */\n    event BeneficiaryChanged(address newBeneficiary);\n\n    /**\n     * @dev Emitted when oracle is changed\n     * @param newOracle New oracle\n     */\n    event OracleChanged(ITrueFiPoolOracle newOracle);\n\n    /**\n     * @dev Emitted when someone joins the pool\n     * @param staker Account staking\n     * @param deposited Amount deposited\n     * @param minted Amount of pool tokens minted\n     */\n    event Joined(address indexed staker, uint256 deposited, uint256 minted);\n\n    /**\n     * @dev Emitted when someone exits the pool\n     * @param staker Account exiting\n     * @param amount Amount unstaking\n     */\n    event Exited(address indexed staker, uint256 amount);\n\n    /**\n     * @dev Emitted when funds are flushed into the strategy\n     * @param currencyAmount Amount of tokens deposited\n     */\n    event Flushed(uint256 currencyAmount);\n\n    /**\n     * @dev Emitted when funds are pulled from the strategy\n     * @param minTokenAmount Minimal expected amount received tokens\n     */\n    event Pulled(uint256 minTokenAmount);\n\n    /**\n     * @dev Emitted when funds are borrowed from pool\n     * @param borrower Borrower address\n     * @param amount Amount of funds borrowed from pool\n     */\n    event Borrow(address borrower, uint256 amount);\n\n    /**\n     * @dev Emitted when borrower repays the pool\n     * @param payer Address of borrower\n     * @param amount Amount repaid\n     */\n    event Repaid(address indexed payer, uint256 amount);\n\n    /**\n     * @dev Emitted when fees are collected\n     * @param beneficiary Account to receive fees\n     * @param amount Amount of fees collected\n     */\n    event Collected(address indexed beneficiary, uint256 amount);\n\n    /**\n     * @dev Emitted when strategy is switched\n     * @param newStrategy Strategy to switch to\n     */\n    event StrategySwitched(ITrueStrategy newStrategy);\n\n    /**\n     * @dev Emitted when joining is paused or unpaused\n     * @param pauseStatus New pausing status\n     */\n    event PauseStatusChanged(bool pauseStatus);\n\n    /**\n     * @dev Emitted when SAFU address is changed\n     * @param newSafu New SAFU address\n     */\n    event SafuChanged(ISAFU newSafu);\n\n    /**\n     * @dev Emitted when pool reclaims deficit from SAFU\n     * @param debt Debt for which the deficit was reclaimed\n     * @param deficit Amount reclaimed\n     */\n    event DeficitReclaimed(IDebtToken debt, uint256 deficit);\n\n    /**\n     * @dev Emitted when Credit Agency address is changed\n     * @param newCreditAgency New Credit Agency address\n     */\n    event CreditAgencyChanged(ILineOfCreditAgency newCreditAgency);\n\n    /**\n     * @dev Emitted when Fixed Term Loan Agency address is changed\n     * @param newFTLAgency New Fixed Term Loan Agency address\n     */\n    event FixedTermLoanAgencyChanged(IFixedTermLoanAgency newFTLAgency);\n\n    /**\n     * @dev Emitted when Loan Factory address is changed\n     * @param newLoanFactory New Loan Factory address\n     */\n    event LoanFactoryChanged(ILoanFactory2 newLoanFactory);\n\n    /**\n     * @dev Emitted when DebtTokens are added to the pool\n     * @param debtToken token address\n     * @param amount token amount\n     */\n    event DebtAdded(IDebtToken debtToken, uint256 amount);\n\n    /**\n     * @dev only FixedTermLoanAgency, or CreditAgency can perform borrowing or repaying\n     */\n    modifier onlyAgencies() {\n        require(\n            msg.sender == address(ftlAgency) || msg.sender == address(creditAgency),\n            \"TrueFiPool: Caller is neither the ftlAgency nor creditAgency\"\n        );\n        _;\n    }\n\n    /**\n     * @dev only TrueLender, FixedTermLoanAgency, or CreditAgency can perform borrowing or repaying\n     */\n    modifier onlyLenderOrFTLAgencyOrLineOfCreditAgency() {\n        require(\n            msg.sender == address(lender) || msg.sender == address(ftlAgency) || msg.sender == address(creditAgency),\n            \"TrueFiPool: Caller is not the lender, ftlAgency, or creditAgency\"\n        );\n        _;\n    }\n\n    /**\n     * @dev pool can only be joined when it's unpaused\n     */\n    modifier joiningNotPaused() {\n        require(!pauseStatus, \"TrueFiPool: Joining the pool is paused\");\n        _;\n    }\n\n    /**\n     * Sync values to avoid making expensive calls multiple times\n     * Will set inSync to true, allowing getter functions to return cached values\n     * Wipes cached values to save gas\n     */\n    modifier sync() {\n        // sync\n        strategyValueCache = strategyValue();\n        loansValueCache = loansValue();\n        inSync = true;\n        _;\n        // wipe\n        inSync = false;\n        strategyValueCache = 0;\n        loansValueCache = 0;\n    }\n\n    /**\n     * @dev Allow pausing of deposits in case of emergency\n     * @param status New deposit status\n     */\n    function setPauseStatus(bool status) external override onlyOwner {\n        pauseStatus = status;\n        emit PauseStatusChanged(status);\n    }\n\n    /**\n     * @dev Change SAFU address\n     */\n    function setSafuAddress(ISAFU _safu) external onlyOwner {\n        safu = _safu;\n        emit SafuChanged(_safu);\n    }\n\n    function setCreditAgency(ILineOfCreditAgency _creditAgency) external onlyOwner {\n        creditAgency = _creditAgency;\n        emit CreditAgencyChanged(_creditAgency);\n    }\n\n    function setFixedTermLoanAgency(IFixedTermLoanAgency _ftlAgency) external onlyOwner {\n        ftlAgency = _ftlAgency;\n        emit FixedTermLoanAgencyChanged(_ftlAgency);\n    }\n\n    function setLoanFactory(ILoanFactory2 _loanFactory) external onlyOwner {\n        require(address(_loanFactory) != address(0), \"TrueFiPool2: loanFactory is zero address\");\n        loanFactory = _loanFactory;\n        emit LoanFactoryChanged(_loanFactory);\n    }\n\n    /**\n     * @dev Number of decimals for user-facing representations.\n     * Delegates to the underlying pool token.\n     */\n    function decimals() public view override returns (uint8) {\n        return token.decimals();\n    }\n\n    /**\n     * @dev Virtual value of liquid assets in the pool\n     * @return Virtual liquid value of pool assets\n     */\n    function liquidValue() public view returns (uint256) {\n        return currencyBalance().add(strategyValue());\n    }\n\n    /**\n     * @dev Value of funds deposited into the strategy denominated in underlying token\n     * @return Virtual value of strategy\n     */\n    function strategyValue() public view returns (uint256) {\n        if (address(strategy) == address(0)) {\n            return 0;\n        }\n        if (inSync) {\n            return strategyValueCache;\n        }\n        return strategy.value();\n    }\n\n    /**\n     * @dev Calculate pool value in underlying token\n     * \"virtual price\" of entire pool - LoanTokens, UnderlyingTokens, strategy value\n     * @return pool value denominated in underlying token\n     */\n    function poolValue() public view override returns (uint256) {\n        // this assumes defaulted loans are worth their full value\n        return liquidValue().add(loansValue()).add(deficitValue()).add(creditValue()).add(debtValue);\n    }\n\n    /**\n     * @dev Return pool deficiency value, to be returned by safu\n     * @return pool deficiency value\n     */\n    function deficitValue() public view returns (uint256) {\n        if (address(safu) == address(0)) {\n            return 0;\n        }\n        return safu.poolDeficit(address(this));\n    }\n\n    /**\n     * @dev Return pool credit line value\n     * @return pool credit value\n     */\n    function creditValue() public view returns (uint256) {\n        if (address(creditAgency) == address(0)) {\n            return 0;\n        }\n        return creditAgency.poolCreditValue(ITrueFiPool2(this));\n    }\n\n    /**\n     * @dev Virtual value of loan assets in the pool\n     * Will return cached value if inSync\n     * @return Value of loans in pool\n     */\n    function loansValue() public view returns (uint256) {\n        if (inSync) {\n            return loansValueCache;\n        }\n        uint256 lenderLoansValue = 0;\n        if (address(lender) != address(0)) {\n            lenderLoansValue = lender.value(this);\n        }\n        return lenderLoansValue.add(ftlAgency.value(this));\n    }\n\n    /**\n     * @dev ensure enough tokens are available\n     * Check if current available amount of `token` is enough and\n     * withdraw remainder from strategy\n     * @param neededAmount amount required\n     */\n    function ensureSufficientLiquidity(uint256 neededAmount) internal {\n        uint256 currentlyAvailableAmount = currencyBalance();\n        if (currentlyAvailableAmount < neededAmount) {\n            require(address(strategy) != address(0), \"TrueFiPool: Pool has no strategy to withdraw from\");\n            strategy.withdraw(neededAmount.sub(currentlyAvailableAmount));\n            require(currencyBalance() >= neededAmount, \"TrueFiPool: Not enough funds taken from the strategy\");\n        }\n    }\n\n    /**\n     * @dev set pool join fee\n     * @param fee new fee\n     */\n    function setJoiningFee(uint256 fee) external onlyOwner {\n        require(fee <= BASIS_PRECISION, \"TrueFiPool: Fee cannot exceed transaction value\");\n        joiningFee = fee;\n        emit JoiningFeeChanged(fee);\n    }\n\n    /**\n     * @dev set beneficiary\n     * @param newBeneficiary new beneficiary\n     */\n    function setBeneficiary(address newBeneficiary) external onlyOwner {\n        require(newBeneficiary != address(0), \"TrueFiPool: Beneficiary address cannot be set to 0\");\n        beneficiary = newBeneficiary;\n        emit BeneficiaryChanged(newBeneficiary);\n    }\n\n    /**\n     * @dev Join the pool by depositing tokens\n     * @param amount amount of token to deposit\n     */\n    function join(uint256 amount) external override joiningNotPaused {\n        uint256 fee = amount.mul(joiningFee).div(BASIS_PRECISION);\n        uint256 mintedAmount = mint(amount.sub(fee));\n        claimableFees = claimableFees.add(fee);\n\n        // TODO: tx.origin will be deprecated in a future ethereum upgrade\n        latestJoinBlock[tx.origin] = block.number;\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Joined(msg.sender, amount, mintedAmount);\n    }\n\n    /**\n     * @dev Exit pool only with liquid tokens\n     * This function will only transfer underlying token but with a small penalty\n     * Uses the sync() modifier to reduce gas costs of using strategy and lender\n     * @param amount amount of pool liquidity tokens to redeem for underlying tokens\n     */\n    function liquidExit(uint256 amount) external sync {\n        require(block.number != latestJoinBlock[tx.origin], \"TrueFiPool: Cannot join and exit in same block\");\n        require(amount <= balanceOf(msg.sender), \"TrueFiPool: Insufficient funds\");\n\n        uint256 amountToWithdraw = poolValue().mul(amount).div(totalSupply());\n        amountToWithdraw = amountToWithdraw.mul(liquidExitPenalty(amountToWithdraw)).div(BASIS_PRECISION);\n        require(amountToWithdraw <= liquidValue(), \"TrueFiPool: Not enough liquidity in pool\");\n\n        // burn tokens sent\n        _burn(msg.sender, amount);\n\n        ensureSufficientLiquidity(amountToWithdraw);\n\n        token.safeTransfer(msg.sender, amountToWithdraw);\n\n        emit Exited(msg.sender, amountToWithdraw);\n    }\n\n    /**\n     * @dev Penalty (in % * 100) applied if liquid exit is performed with this amount\n     * returns BASIS_PRECISION (10000) if no penalty\n     */\n    function liquidExitPenalty(uint256 amount) public view returns (uint256) {\n        uint256 lv = liquidValue();\n        uint256 pv = poolValue();\n        if (amount == pv) {\n            return BASIS_PRECISION;\n        }\n        uint256 liquidRatioBefore = lv.mul(BASIS_PRECISION).div(pv);\n        uint256 liquidRatioAfter = lv.sub(amount).mul(BASIS_PRECISION).div(pv.sub(amount));\n        return BASIS_PRECISION.sub(averageExitPenalty(liquidRatioAfter, liquidRatioBefore));\n    }\n\n    /**\n     * @dev Calculates integral of 5/(x+50)dx times 10000\n     */\n    function integrateAtPoint(uint256 x) public pure returns (uint256) {\n        return uint256(ABDKMath64x64.ln(ABDKMath64x64.fromUInt(x.add(50)))).mul(50000).div(2**64);\n    }\n\n    /**\n     * @dev Calculates average penalty on interval [from; to]\n     * @return average exit penalty\n     */\n    function averageExitPenalty(uint256 from, uint256 to) public pure returns (uint256) {\n        require(from <= to, \"TrueFiPool: To precedes from\");\n        if (from == BASIS_PRECISION) {\n            // When all liquid, don't penalize\n            return 0;\n        }\n        if (from == to) {\n            return uint256(50000).div(from.add(50));\n        }\n        return integrateAtPoint(to).sub(integrateAtPoint(from)).div(to.sub(from));\n    }\n\n    /**\n     * @dev Deposit idle funds into strategy\n     * @param amount Amount of funds to deposit into strategy\n     */\n    function flush(uint256 amount) external onlyOwner {\n        require(address(strategy) != address(0), \"TrueFiPool: Pool has no strategy set up\");\n        require(amount <= currencyBalance(), \"TrueFiPool: Insufficient currency balance\");\n\n        uint256 expectedMinStrategyValue = strategy.value().add(withToleratedStrategyLoss(amount));\n        token.safeApprove(address(strategy), amount);\n        strategy.deposit(amount);\n        require(strategy.value() >= expectedMinStrategyValue, \"TrueFiPool: Strategy value expected to be higher\");\n        emit Flushed(amount);\n    }\n\n    /**\n     * @dev Remove liquidity from strategy\n     * @param minTokenAmount minimum amount of tokens to withdraw\n     */\n    function pull(uint256 minTokenAmount) external onlyOwner {\n        require(address(strategy) != address(0), \"TrueFiPool: Pool has no strategy set up\");\n\n        uint256 expectedCurrencyBalance = currencyBalance().add(minTokenAmount);\n        strategy.withdraw(minTokenAmount);\n        require(currencyBalance() >= expectedCurrencyBalance, \"TrueFiPool: Currency balance expected to be higher\");\n\n        emit Pulled(minTokenAmount);\n    }\n\n    /**\n     * @dev Remove liquidity from strategy if necessary and transfer to lender\n     * @param amount amount for lender to withdraw\n     */\n    function borrow(uint256 amount) external override onlyAgencies {\n        require(amount <= liquidValue(), \"TrueFiPool: Insufficient liquidity\");\n        if (amount > 0) {\n            ensureSufficientLiquidity(amount);\n        }\n\n        token.safeTransfer(msg.sender, amount);\n\n        emit Borrow(msg.sender, amount);\n    }\n\n    /**\n     * @dev repay debt by transferring tokens to the contract\n     * @param currencyAmount amount to repay\n     */\n    function repay(uint256 currencyAmount) external override onlyLenderOrFTLAgencyOrLineOfCreditAgency {\n        token.safeTransferFrom(msg.sender, address(this), currencyAmount);\n        emit Repaid(msg.sender, currencyAmount);\n    }\n\n    /**\n     * @dev Claim fees from the pool\n     */\n    function collectFees() external {\n        require(beneficiary != address(0), \"TrueFiPool: Beneficiary is not set\");\n\n        uint256 amount = claimableFees;\n        claimableFees = 0;\n\n        if (amount > 0) {\n            token.safeTransfer(beneficiary, amount);\n        }\n\n        emit Collected(beneficiary, amount);\n    }\n\n    /**\n     * @dev Switches current strategy to a new strategy\n     * @param newStrategy strategy to switch to\n     */\n    function switchStrategy(ITrueStrategy newStrategy) external onlyOwner {\n        require(strategy != newStrategy, \"TrueFiPool: Cannot switch to the same strategy\");\n\n        ITrueStrategy previousStrategy = strategy;\n        strategy = newStrategy;\n\n        if (address(previousStrategy) != address(0)) {\n            uint256 expectedMinCurrencyBalance = currencyBalance().add(withToleratedStrategyLoss(previousStrategy.value()));\n            previousStrategy.withdrawAll();\n            require(currencyBalance() >= expectedMinCurrencyBalance, \"TrueFiPool: All funds should be withdrawn to pool\");\n            require(previousStrategy.value() == 0, \"TrueFiPool: Switched strategy should be depleted\");\n        }\n\n        emit StrategySwitched(newStrategy);\n    }\n\n    /**\n     * @dev Function called by SAFU when liquidation happens. It will transfer all tokens of this loan the SAFU\n     */\n    function liquidateLegacyLoan(ILoanToken2Deprecated loan) external override {\n        require(msg.sender == address(safu), \"TrueFiPool: Should be called by SAFU\");\n        lender.transferAllLoanTokens(loan, address(safu));\n    }\n\n    /**\n     * @dev Function called by SAFU when liquidation happens. It will transfer whole balance of the debt token to the SAFU\n     */\n    function liquidateDebt(IDebtToken debtToken) external override {\n        require(msg.sender == address(safu), \"TrueFiPool: Should be called by SAFU\");\n        uint256 balance = debtToken.balanceOf(address(this));\n        require(balance > 0, \"TrueFiPool: Pool doesn't hold this debt token\");\n\n        debtValue = debtValue.sub(balance);\n        debtToken.safeTransfer(msg.sender, balance);\n    }\n\n    function reclaimLegacyDeficit(ILoanToken2Deprecated loan) external {\n        IDeficiencyToken dToken = safu.legacyDeficiencyToken(loan);\n        require(address(dToken) != address(0), \"TrueFiPool2: No deficiency token found for loan\");\n        uint256 deficit = dToken.balanceOf(address(this));\n        dToken.safeApprove(address(safu), deficit);\n        safu.legacyReclaim(loan, deficit);\n\n        emit DeficitReclaimed(IDebtToken(address(loan)), deficit);\n    }\n\n    /**\n     * @dev Function called when debt is repaid to SAFU, pool has a deficit value towards that debt\n     */\n    function reclaimDeficit(IDebtToken debt) external {\n        IDeficiencyToken dToken = safu.deficiencyToken(debt);\n        require(address(dToken) != address(0), \"TrueFiPool2: No deficiency token found for debt\");\n        uint256 deficit = dToken.balanceOf(address(this));\n        dToken.safeApprove(address(safu), deficit);\n        safu.reclaim(debt, deficit);\n\n        emit DeficitReclaimed(debt, deficit);\n    }\n\n    /**\n     * @dev CreditAgency transfers DebtToken to the pool\n     */\n    function addDebt(IDebtToken debtToken, uint256 amount) external override {\n        require(\n            msg.sender == address(creditAgency) || loanFactory.isLoanToken(IFixedTermLoan(msg.sender)),\n            \"TruePool: Only LineOfCreditAgency and Loans can add debtTokens\"\n        );\n        debtValue = debtValue.add(amount);\n        debtToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit DebtAdded(debtToken, amount);\n    }\n\n    /**\n     * @dev Change oracle, can only be called by owner\n     */\n    function setOracle(ITrueFiPoolOracle newOracle) external onlyOwner {\n        oracle = newOracle;\n        emit OracleChanged(newOracle);\n    }\n\n    /**\n     * @dev Currency token balance\n     * @return Currency token balance\n     */\n    function currencyBalance() public view returns (uint256) {\n        return token.balanceOf(address(this)).sub(claimableFees);\n    }\n\n    /**\n     * @dev Ratio of liquid assets in the pool after lending\n     * @param afterAmountLent Amount of asset being lent\n     * @return Calculated ratio in basis points\n     */\n    function liquidRatio(uint256 afterAmountLent) external view override returns (uint256) {\n        uint256 _poolValue = poolValue();\n        if (_poolValue == 0) {\n            return 0;\n        }\n        return (liquidValue().sub(afterAmountLent)).mul(BASIS_PRECISION).div(_poolValue);\n    }\n\n    /**\n     * @param depositedAmount Amount of currency deposited\n     * @return amount minted from this transaction\n     */\n    function mint(uint256 depositedAmount) internal returns (uint256) {\n        if (depositedAmount == 0) {\n            return depositedAmount;\n        }\n        uint256 mintedAmount = depositedAmount;\n\n        // first staker mints same amount as deposited\n        if (totalSupply() > 0) {\n            mintedAmount = totalSupply().mul(depositedAmount).div(poolValue());\n        }\n        // mint pool liquidity tokens\n        _mint(msg.sender, mintedAmount);\n\n        return mintedAmount;\n    }\n\n    /**\n     * @dev Decrease provided amount percentwise by error\n     * @param amount Amount to decrease\n     * @return Calculated value\n     */\n    function withToleratedSlippage(uint256 amount) internal pure returns (uint256) {\n        return amount.mul(BASIS_PRECISION - TOLERATED_SLIPPAGE).div(BASIS_PRECISION);\n    }\n\n    /**\n     * @dev Decrease provided amount percentwise by error\n     * @param amount Amount to decrease\n     * @return Calculated value\n     */\n    function withToleratedStrategyLoss(uint256 amount) internal pure returns (uint256) {\n        return amount.mul(BASIS_PRECISION - TOLERATED_STRATEGY_LOSS).div(BASIS_PRECISION);\n    }\n}"
    },
    {
      "filename": "contracts/truefi2/TrueFiPool2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {ERC20} from \"../common/UpgradeableERC20.sol\";\nimport {UpgradeableClaimable} from \"../common/UpgradeableClaimable.sol\";\n\nimport {IFixedTermLoanAgency} from \"./interface/IFixedTermLoanAgency.sol\";\nimport {ITrueStrategy} from \"./interface/ITrueStrategy.sol\";\nimport {ITrueFiPool2, ITrueFiPoolOracle} from \"./interface/ITrueFiPool2.sol\";\nimport {ITrueLender2Deprecated} from \"./deprecated/ITrueLender2Deprecated.sol\";\nimport {ILoanToken2Deprecated} from \"./deprecated/ILoanToken2Deprecated.sol\";\nimport {IFixedTermLoan} from \"./interface/IFixedTermLoan.sol\";\nimport {IDebtToken} from \"./interface/IDebtToken.sol\";\nimport {IPauseableContract} from \"../common/interface/IPauseableContract.sol\";\nimport {ISAFU} from \"./interface/ISAFU.sol\";\nimport {IDeficiencyToken} from \"./interface/IDeficiencyToken.sol\";\nimport {ILineOfCreditAgency} from \"./interface/ILineOfCreditAgency.sol\";\nimport {ILoanFactory2} from \"./interface/ILoanFactory2.sol\";\n\nimport {ABDKMath64x64} from \"../truefi/Log.sol\";\n\n/**\n * @title TrueFiPool2\n * @dev Lending pool which may use a strategy to store idle funds\n * Earn high interest rates on currency deposits through uncollateralized loans\n *\n * Funds deposited in this pool are not fully liquid.\n * Exiting incurs an exit penalty depending on pool liquidity\n * After exiting, an account will need to wait for LoanTokens to expire and burn them\n * It is recommended to perform a zap or swap tokens on Uniswap for increased liquidity\n *\n * Funds are managed through an external function to save gas on deposits\n */\ncontract TrueFiPool2 is ITrueFiPool2, IPauseableContract, ERC20, UpgradeableClaimable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IDeficiencyToken;\n    using SafeERC20 for IDebtToken;\n\n    uint256 private constant BASIS_PRECISION = 10000;\n\n    // max slippage on liquidation token swaps\n    // Measured in basis points, e.g. 10000 = 100%\n    uint16 public constant TOLERATED_SLIPPAGE = 100; // 1%\n\n    // tolerance difference between\n    // expected and actual transaction results\n    // when dealing with strategies\n    // Measured in  basis points, e.g. 10000 = 100%\n    uint16 public constant TOLERATED_STRATEGY_LOSS = 10; // 0.1%\n\n    // ================ WARNING ==================\n    // ===== THIS CONTRACT IS INITIALIZABLE ======\n    // === STORAGE VARIABLES ARE DECLARED BELOW ==\n    // REMOVAL OR REORDER OF VARIABLES WILL RESULT\n    // ========= IN STORAGE CORRUPTION ===========\n\n    uint8 public constant VERSION = 1;\n\n    ERC20 public override token;\n\n    ITrueStrategy public strategy;\n    ITrueLender2Deprecated public lender;\n\n    // fee for deposits\n    // fee precision: 10000 = 100%\n    uint256 public joiningFee;\n    // track claimable fees\n    uint256 public claimableFees;\n\n    mapping(address => uint256) latestJoinBlock;\n\n    address private DEPRECATED__liquidationToken;\n\n    ITrueFiPoolOracle public override oracle;\n\n    // allow pausing of deposits\n    bool public pauseStatus;\n\n    // cache values during sync for gas optimization\n    bool private inSync;\n    uint256 private strategyValueCache;\n    uint256 private loansValueCache;\n\n    // who gets all fees\n    address public beneficiary;\n\n    address private DEPRECATED__1Inch;\n\n    ISAFU public safu;\n\n    ILineOfCreditAgency public creditAgency;\n\n    uint256 public debtValue;\n\n    IFixedTermLoanAgency public ftlAgency;\n\n    ILoanFactory2 public loanFactory;\n\n    // ======= STORAGE DECLARATION END ===========\n\n    /**\n     * @dev Helper function to concatenate two strings\n     * @param a First part of string to concat\n     * @param b Second part of string to concat\n     * @return Concatenated string of `a` and `b`\n     */\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n\n    function initialize(\n        ERC20 _token,\n        IFixedTermLoanAgency _ftlAgency,\n        ISAFU _safu,\n        ILoanFactory2 _loanFactory,\n        address __owner\n    ) external override initializer {\n        ERC20.__ERC20_initialize(concat(\"TrueFi \", _token.name()), concat(\"tf\", _token.symbol()));\n        UpgradeableClaimable.initialize(__owner);\n\n        token = _token;\n        ftlAgency = _ftlAgency;\n        lender = ITrueLender2Deprecated(address(0));\n        safu = _safu;\n        loanFactory = _loanFactory;\n    }\n\n    /**\n     * @dev Initializer for single borrower pools\n     */\n    function singleBorrowerInitialize(\n        ERC20 _token,\n        IFixedTermLoanAgency _ftlAgency,\n        ISAFU _safu,\n        ILoanFactory2 _loanFactory,\n        address __owner,\n        string memory borrowerName,\n        string memory borrowerSymbol\n    ) external override initializer {\n        ERC20.__ERC20_initialize(\n            concat(concat(\"TrueFi \", borrowerName), concat(\" \", _token.name())),\n            concat(concat(\"tf\", borrowerSymbol), _token.symbol())\n        );\n        UpgradeableClaimable.initialize(__owner);\n\n        token = _token;\n        ftlAgency = _ftlAgency;\n        safu = _safu;\n        loanFactory = _loanFactory;\n    }\n\n    /**\n     * @dev Emitted when fee is changed\n     * @param newFee New fee\n     */\n    event JoiningFeeChanged(uint256 newFee);\n\n    /**\n     * @dev Emitted when beneficiary is changed\n     * @param newBeneficiary New beneficiary\n     */\n    event BeneficiaryChanged(address newBeneficiary);\n\n    /**\n     * @dev Emitted when oracle is changed\n     * @param newOracle New oracle\n     */\n    event OracleChanged(ITrueFiPoolOracle newOracle);\n\n    /**\n     * @dev Emitted when someone joins the pool\n     * @param staker Account staking\n     * @param deposited Amount deposited\n     * @param minted Amount of pool tokens minted\n     */\n    event Joined(address indexed staker, uint256 deposited, uint256 minted);\n\n    /**\n     * @dev Emitted when someone exits the pool\n     * @param staker Account exiting\n     * @param amount Amount unstaking\n     */\n    event Exited(address indexed staker, uint256 amount);\n\n    /**\n     * @dev Emitted when funds are flushed into the strategy\n     * @param currencyAmount Amount of tokens deposited\n     */\n    event Flushed(uint256 currencyAmount);\n\n    /**\n     * @dev Emitted when funds are pulled from the"
    }
  ]
}