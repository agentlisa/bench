{
  "Title": "[H-26] Not enough TAP tokens to exercise if a user participates and exercises in the same epoch",
  "Content": "\nUsers were unable to purchase their deserved amount of TAPs\n\n### Proof of Concept\n\nDuring each `epoch` and for a specific `sglAssetID`, there is a fixed amount of TAP tokens that will be minted and stored in the STORAGE mapping `singularityGauges[epoch][sglAssetID]`. Users have the option to purchase these TAP tokens by first calling the function `TapiocaOptionBroker.participate()` and then executing `TapiocaOptionBroker.exerciseOption()` before the position expires to buy TAPs at a discounted price. The amount of TAP tokens that a user can purchase with each position can be calculated using the formula:\n\n    eligibleTapAmount = position.amount * gaugeTotalForEpoch / totalPoolDeposited\n\n    - position.amount: The locked amount of the position in `sglAssetId`.\n    - gaugeTotalForEpoch: The total number of TAP tokens that can be minted for the `(epoch, sglAssetId)`.\n    - totalPoolDeposited: The total locked amount of all positions in `sglAssetId`.\n\nThe flaw arises when a user who participates in `sglAssetId` in the current epoch can immediately call `exerciseOption()` to purchase the TAP tokens. This results in a situation where the participants cannot exercise their expected TAP tokens.\n\nFor example:\n\n*   Both Alice and Bob participate in the broker with `position.amount = 1`.\n*   The amount of TAP tokens allocated for the current epoch is `gaugeTotalForEpoch = 60`.\n*   Alice calls `exerciseOption()` to buy `eligibleAmount = 1 * 60 / 2 = 30` TAPs.\n*   In the same epoch, Candice participates in the broker with `position.amount = 1` and immediately calls `exerciseOption()`. She will buy `eligibleAmount = 1 * 60 / 3 = 20` TAPs.\n*   When Bob calls `exerciseOption`, he can buy `eligibleAmount = 1 * 60 / 3 = 20` TAPs, but this cannot happen since if Bob decides to buy 20 TAPs, the total minted amount of TAPs will exceed `gaugeTotalForEpoch` (30 + 20 + 20 = 70 > 60), resulting in a revert.\n\n### Recommended Mitigation Steps\n\nConsider developing a technique similar to the one implemented in [`twTAP.sol`](https://github.com/Tapioca-DAO/tap-token-audit/blob/59749be5bc2286f0bdbf59d7ddc258ddafd49a9f/contracts/governance/twTAP.sol#L343-L344) for storing the `netAmounts`. When a user participates in the broker, perform the following actions:\n\n*   `netAmounts[block.timestamp+1] += lock.amount`\n*   `netAmounts[lockTime+lockDuration] += lock.amount`\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1101#issuecomment-1702850526)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/governance/twTAP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {ICommonOFT} from \"tapioca-sdk/dist/contracts/token/oft/v2/ICommonOFT.sol\";\nimport {ONFT721} from \"tapioca-sdk/src/contracts/token/onft/ONFT721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"tapioca-sdk/dist/contracts/util/ERC4494.sol\";\nimport \"../tokens/TapOFT.sol\";\nimport \"../twAML.sol\";\n\n/*\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\n// Justification for data sizes:\n// - 56 bits can represent over 2 billion years in seconds\n// - TAP has a maximum supply of 100 million, and a precision of 10^18. Any\n//   amount will therefore fit in (lg 10^26 = 87) bits.\n// - The multiplier has a maximum of 1 million; dMAX = 100 * 1e4, which fits\n//   in 20 bits.\n// - A week is 86400 * 7 = 604800 seconds; less than 2^20. Even if we start\n//   counting at the (Unix) epoch, we will run out of `expiry` before we\n//   saturate the week fields.\nstruct Participation {\n    uint256 averageMagnitude;\n    bool hasVotingPower;\n    bool divergenceForce; // 0 negative, 1 positive\n    bool tapReleased; // allow restaking while rewards may still accumulate\n    uint56 expiry; // expiry timestamp. Big enough for over 2 billion years..\n    uint88 tapAmount; // amount of TAP locked\n    uint24 multiplier; // Votes = multiplier * tapAmount\n    uint40 lastInactive; // One week BEFORE the staker gets a share of rewards\n    uint40 lastActive; // Last week that the staker shares in rewards\n}\n\nstruct TWAMLPool {\n    uint256 totalParticipants;\n    uint256 averageMagnitude;\n    uint256 totalDeposited;\n    uint256 cumulative;\n}\n\nstruct WeekTotals {\n    // For [0..currentWeek] this is a cumulative total: it consists of the\n    // active votes in the previous week, minus the votes known to expire this\n    // week. For future weeks, it is a negative number corresponding to the\n    // expiring votes.\n    int256 netActiveVotes;\n    // rewardTokens index -> amount\n    mapping(uint256 => uint256) totalDistPerVote;\n}\n\n/// @title twTAP\n/// @notice Governance contract for TAP\n/// @dev This contract allow the locking of TAP to twTAP. The amount of twTAP received is based on the amount of locked TAP, and the duration of the lock.\n///      It uses twAML to compute the amount of twTAP received, details about the model can be found here https://docs.tapioca.xyz/tapioca/core-technologies/twaml.\n///      The contract distributes a set of rewards tokens each week to the twTAP holders. The amount of rewards received is based on the amount of twTAP held.\n/// @dev Actions:\n///          - Lock TAP.\n///          - Unlock TAP.\n///          - Claim rewards (Same chain or cross chain).\ncontract TwTAP is TWAML, ONFT721, ERC721Permit {\n    using SafeERC20 for IERC20;\n\n    TapOFT public immutable tapOFT;\n\n    /// ===== TWAML ======\n    TWAMLPool public twAML; // sglAssetId => twAMLPool\n\n    mapping(uint256 => Participation) public participants; // tokenId => part.\n\n    uint256 constant MIN_WEIGHT_FACTOR = 10; // In BPS, 0.1%\n    uint256 constant dMAX = 100 * 1e4; // 10% - 100% voting power multiplier\n    uint256 constant dMIN = 10 * 1e4;\n    uint256 public constant EPOCH_DURATION = 7 days;\n\n    // If we assume 128 bit balances for the reward token -- which fit 1e40\n    // \"tokens\" at the most commonly used 1e18 precision -- then we can use the\n    // other 128 bits to store the tokens allotted to a single vote more\n    // accurately. Votes in turn are proportional to the amount of TAP locked,\n    // weighted by a multiplier. This number is at most 107 bits long (see\n    // definition of `Participation` struct).\n    // the weight ranges from 10-100% where 1% = 1e4, so 1 million (20 bits).\n    // the multiplier is at most 100% = 1M (20 bits), so votes is at most a\n    // 107-bit number.\n    uint256 constant DIST_PRECISION = 2 ** 128;\n\n    IERC20[] public rewardTokens;\n    mapping(IERC20 => uint256) public rewardTokenIndex;\n    // tokenId -> rewardTokens index -> amount\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed;\n\n    // The current week is determined by creation, but there are values that\n    // need to be updated weekly. If, for any reason whatsoever, this cannot\n    // be done in time, the `lastProcessedWeek` will be behind until this is\n    // done.\n    uint256 public mintedTWTap;\n    uint256 public creation; // Week 0 starts here\n    uint256 public lastProcessedWeek;\n    mapping(uint256 => WeekTotals) public weekTotals;\n\n    uint256 public immutable HOST_CHAIN_ID;\n    string private baseURI;\n\n    /// =====-------======\n    constructor(\n        address payable _tapOFT,\n        address _owner,\n        address _layerZeroEndpoint,\n        uint256 _hostChainID,\n        uint256 _minGas\n    )\n        ONFT721(\"Time Weighted TAP\", \"twTAP\", _minGas, _layerZeroEndpoint)\n        ERC721Permit(\"Time Weighted TAP\")\n    {\n        tapOFT = TapOFT(_tapOFT);\n        transferOwnership(_owner);\n        creation = block.timestamp;\n        HOST_CHAIN_ID = _hostChainID;\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(\n        address indexed participant,\n        uint256 tapAmount,\n        uint256 multiplier\n    );\n    event AMLDivergence(\n        uint256 cumulative,\n        uint256 averageMagnitude,\n        uint256 totalParticipants\n    );\n    event ExitPosition(uint256 tokenId, uint256 amount);\n\n    // ==========\n    //    READ\n    // ==========\n\n    function currentWeek() public view returns (uint256) {\n        return (block.timestamp - creation) / EPOCH_DURATION;\n    }\n\n    /// @notice Return the participation of a token. Returns 0 votes for expired tokens.\n    function getParticipation(\n        uint _tokenId\n    ) public view returns (Participation memory participant) {\n        participant = participants[_tokenId];\n        if (participant.expiry < block.timestamp) {\n            participant.multiplier = 0;\n        }\n        return participant;\n    }\n\n    /// @notice Amount currently claimable for each reward token\n    function claimable(\n        uint256 _tokenId\n    ) public view returns (uint256[] memory) {\n        uint256 len = rewardTokens.length;\n        uint256[] memory result = new uint256[](len);\n\n        Participation memory position = participants[_tokenId];\n        uint256 votes;\n        unchecked {\n            // Math is safe: Types fit\n            votes = uint256(position.tapAmount) * uint256(position.multiplier);\n        }\n\n        if (votes == 0) {\n            return result;\n        }\n\n        // If the \"last processed week\" is behind the actual week, rewards\n        // get processed as if it were earlier.\n        uint256 week = lastProcessedWeek;\n        if (week <= position.lastInactive) {\n            return result;\n        }\n        if (position.lastActive < week) {\n            week = position.lastActive;\n        }\n\n        WeekTotals storage cur = weekTotals[week];\n        WeekTotals storage prev = weekTotals[position.lastInactive];\n\n        for (uint256 i = 0; i < len; ) {\n            // Math is safe (but we do the checks anyway):\n            //\n            // -- The `totalDistPerVote[i]` values are increasing as a\n            //    function of weeks (see `advanceWeek()`), and if `week`\n            //    were not greater than `position.lastInactive`, this bit\n            //    of code would not be reached (see above). Therefore the\n            //    subtraction in the calculation of `net` cannot underflow.\n            //\n            // -- `votes * net` is at most the entire reward amount given\n            //    out, ever, in units of\n            //\n            //        (reward tokens) * DIST_PRECISION.\n            //\n            //    If this number were to exceed 256 bits, then\n            //    `distributeReward` would revert.\n            //\n            // -- `claimed[_tokenId][i]` is the sum of all (the i-th values\n            //    of) previous calls to the current function that were made\n            //    by `_claimRewards()`. Let there be n such calls, and let\n            //    r_j be `result[i]`, c_j be `claimed[_tokenId][i]`, and\n            //    net_j be `net` during that j-th call. Then, up to a\n            //    multiplication by votes / DIST_PRECISION:\n            //\n            //              c_1 = 0 <= net_1,\n            //\n            //    and, for n > 1:\n            //\n            //              c_n = r_(n-1) + r_(n-2) + ... + r_1\n            //                  = r_(n-1) + c_(n-1)\n            //                  = (net_(n-1) - c_(n-1) + c_(n-1)\n            //                  = net_(n-1)\n            //                  <= net_n,\n            //\n            //    so that the subtraction net_n - c_n does not underflow.\n            //    (The rounding the calculation favors the greater first\n            //    term).\n            //    (TODO: Word better?)\n            //\n            uint256 net = cur.totalDistPerVote[i] - prev.totalDistPerVote[i];\n            result[i] = ((votes * net) / DIST_PRECISION) - claimed[_tokenId][i];\n            unchecked {\n                ++i;\n            }\n        }\n        return result;\n    }\n\n    // ===========\n    //    WRITE\n    // ===========\n\n    /// @notice Participate in twAMl voting and mint an oTAP position\n    /// @param _participant The address of the participant\n    /// @param _amount The amount of TAP to participate with\n    /// @param _duration The duration of the lock\n    function participate(\n        address _participant,\n        uint256 _amount,\n        uint256 _duration\n    ) external returns (uint256 tokenId) {\n        require(_duration >= EPOCH_DURATION, \"twTAP: Lock not a week\");\n\n        // Transfer TAP to this contract\n        tapOFT.transferFrom(msg.sender, address(this), _amount);\n\n        // Copy to memory\n        TWAMLPool memory pool = twAML;\n\n        uint256 magnitude = computeMagnitude(_duration, pool.cumulative);\n        bool divergenceForce;\n        uint256 multiplier = computeTarget(\n            dMIN,\n            dMAX,\n            magnitude,\n            pool.cumulative\n        );\n\n        // Calculate twAML voting weight\n        bool hasVotingPower = _amount >=\n            computeMinWeight(pool.totalDeposited, MIN_WEIGHT_FACTOR);\n        if (hasVotingPower) {\n            pool.totalParticipants++; // Save participation\n            pool.averageMagnitude =\n                (pool.averageMagnitude + magnitude) /\n                pool.totalParticipants; // compute new average magnitude\n\n            // Compute and save new cumulative\n            divergenceForce = _duration > pool.cumulative;\n\n            if (divergenceForce) {\n                pool.cumulative += pool.averageMagnitude;\n            } else {\n                // TODO: Strongly suspect this is never less. Prove it.\n                if (pool.cumulative > pool.averageMagnitude) {\n                    pool.cumulative -= pool.averageMagnitude;\n                } else {\n                    pool.cumulative = 0;\n                }\n            }\n\n            // Save new weight\n            pool.totalDeposited += _amount;\n\n            twAML = pool; // Save twAML participation\n            emit AMLDivergence(\n                pool.cumulative,\n                pool.averageMagnitude,\n                pool.totalParticipants\n            );\n        }\n\n        // Mint twTAP position\n        tokenId = ++mintedTWTap;\n        _safeMint(_participant, tokenId);\n\n        uint256 expiry = block.timestamp + _duration;\n        require(expiry < type(uint56).max, \"twTAP: too long\");\n        // Eligibility starts NEXT week, and lasts until the week that the lock\n        // expires. This is guaranteed to be at least one week later by the\n        // check on `_duration`.\n        // If a user locks right before the current week ends, and have a\n        // duration slightly over one week, straddling the two starting points,\n        // then that user is eligible for the rewards during both weeks; the\n        // price for this maneuver is a lower multiplier, and loss of voting\n        // power in the DAO after the lock expires.\n        uint256 w0 = currentWeek();\n        uint256 w1 = (expiry - creation) / EPOCH_DURATION;\n\n        // Save twAML participation\n        // Casts are safe: see struct definition\n        uint256 votes = _amount * multiplier;\n        participants[tokenId] = Participation({\n            averageMagnitude: pool.averageMagnitude,\n            hasVotingPower: hasVotingPower,\n            divergenceForce: divergenceForce,\n            tapReleased: false,\n            expiry: uint56(expiry),\n            tapAmount: uint88(_amount),\n            multiplier: uint24(multiplier),\n            lastInactive: uint40(w0),\n            lastActive: uint40(w1)\n        });\n\n        // w0 + 1 = lastInactive + 1 = first active\n        // w1 + 1 = lastActive + 1 = first inactive\n        // Cast is safe: `votes` is the product of a uint88 and a uint24\n        weekTotals[w0 + 1].netActiveVotes += int256(votes);\n        weekTotals[w1 + 1].netActiveVotes -= int256(votes);\n\n        emit Participate(_participant, _amount, multiplier);\n        // TODO: Mint event?\n    }\n\n    /// @notice claims all rewards distributed since token mint or last claim.\n    /// @param _tokenId tokenId whose rewards to claim\n    /// @param _to address to receive the rewards\n    function claimRewards(uint256 _tokenId, address _to) external {\n        _requireClaimPermission(_to, _tokenId);\n        _claimRewards(_tokenId, _to);\n    }\n\n    /// @notice claims all rewards distributed since token mint or last claim, and send them to another chain.\n    /// @param _tokenId The tokenId of the twTAP position\n    /// @param _rewardTokens The address of the reward token\n    function claimAndSendRewards(\n        uint256 _tokenId,\n        IERC20[] memory _rewardTokens\n    ) external {\n        require(msg.sender == address(tapOFT), \"twTAP: only tapOFT\");\n        _claimRewardsOn(_tokenId, address(tapOFT), _rewardTokens);\n    }\n\n    /// @notice claims the TAP locked in a position whose votes have expired,\n    /// @notice and undoes the effect on the twAML calculations.\n    /// @param _tokenId tokenId whose locked TAP to claim\n    /// @param _to address to receive the TAP\n    function releaseTap(uint256 _tokenId, address _to) external {\n        _requireClaimPermission(_to, _tokenId);\n        _releaseTap(_tokenId, _to);\n    }\n\n    /// @notice Exit a twAML participation and delete the voting power if existing\n    /// @param _tokenId The tokenId of the twTAP position\n    function exitPosition(uint256 _tokenId) external {\n        address to = ownerOf(_tokenId);\n        _releaseTap(_tokenId, to);\n    }\n\n    /// @notice Exit a twAML participation and send the withdrawn TAP to tapOFT to send it to another chain.\n    /// @param _tokenId The tokenId of the twTAP position\n    function exitPositionAndSendTap(\n        uint256 _tokenId\n    ) external returns (uint256) {\n        require(msg.sender == address(tapOFT), \"twTAP: only tapOFT\");\n        return _releaseTap(_tokenId, address(tapOFT));\n    }\n\n    /// @notice Indicate that (a) week(s) have passed and update running totals\n    /// @notice Reverts if called in week 0. Let it.\n    /// @param _limit Maximum number of weeks to process in one call\n    function advanceWeek(uint256 _limit) public {\n        // TODO: Make whole function unchecked\n        uint256 cur = currentWeek();\n        uint256 week = lastProcessedWeek;\n        uint256 goal = cur;\n        unchecked {\n            if (goal - week > _limit) {\n                goal = week + _limit;\n            }\n        }\n        uint256 len = rewardTokens.length;\n        while (week < goal) {\n            WeekTotals storage prev = weekTotals[week];\n            WeekTotals storage next = weekTotals[++week];\n            // TODO: Prove that math is safe\n            next.netActiveVotes += prev.netActiveVotes;\n            for (uint256 i = 0; i < len; ) {\n                next.totalDistPerVote[i] += prev.totalDistPerVote[i];\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        lastProcessedWeek = goal;\n    }\n\n    /// @notice distributes a reward among all tokens, weighted by voting power\n    /// @notice The reward gets allocated to all positions that have locked in\n    /// @notice the current week. Fails, intentionally, if this number is zero.\n    /// @notice Total rewards cannot exceed 2^128 tokens.\n    /// @param _rewardTokenId index of the reward in `rewardTokens`\n    /// @param _amount amount of reward token to distribute.\n    function distributeReward(\n        uint256 _rewardTokenId,\n        uint256 _amount\n    ) external {\n        require(\n            lastProcessedWeek == currentWeek(),\n            \"twTAP: Advance week first\"\n        );\n        WeekTotals storage totals = weekTotals[lastProcessedWeek];\n        IERC20 rewardToken = rewardTokens[_rewardTokenId];\n        // If this is a DBZ then there are no positions to give the reward to.\n        // Since reward eligibility starts in the week after locking, there is\n        // no way to give out rewards THIS week.\n        // Cast is safe: `netActiveVotes` is at most zero by construction of\n        // weekly totals and the requirement that they are up to date.\n        // TODO: Word this better\n        totals.totalDistPerVote[_rewardTokenId] +=\n            (_amount * DIST_PRECISION) /\n            uint256(totals.netActiveVotes);\n        rewardToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    // =========\n    //   OWNER\n    // =========\n\n    function addRewardToken(IERC20 token) external onlyOwner returns (uint256) {\n        uint256 i = rewardTokens.length;\n        rewardTokens.push(token);\n        rewardTokenIndex[token] = i;\n        return i;\n    }\n\n    // ============\n    //   INTERNAL\n    // ============\n\n    /// @dev Mirrors the implementation of _isApprovedOrOwner, with the modification\n    /// that it is allowed if `_to` is the owner:\n    function _requireClaimPermission(\n        address _to,\n        uint256 _tokenId\n    ) internal view {\n        address tokenOwner = ownerOf(_tokenId);\n        require(\n            msg.sender == tokenOwner ||\n                _to == tokenOwner ||\n                isApprovedForAll(tokenOwner, msg.sender) ||\n                getApproved(_tokenId) == msg.sender,\n            \"twTAP: cannot claim\"\n        );\n    }\n\n    /// @dev Claim all rewards on a position and send them to `_to`.\n    function _claimRewards(uint256 _tokenId, address _to) internal {\n        uint256[] memory amounts = claimable(_tokenId);\n        uint256 len = amounts.length;\n        unchecked {\n            for (uint256 i = 0; i < len; ++i) {\n                uint256 amount = amounts[i];\n                if (amount > 0) {\n                    // Math is safe: `amount` calculated safely in `claimable()`\n                    claimed[_tokenId][i] += amount;\n                    rewardTokens[i].safeTransfer(_to, amount);\n                }\n            }\n        }\n    }\n\n    /// @dev Claim rewards of a specific token on a position and send them to `_to`.\n    function _claimRewardsOn(\n        uint256 _tokenId,\n        address _to,\n        IERC20[] memory _rewardTokens\n    ) internal {\n        uint256[] memory amounts = claimable(_tokenId);\n        unchecked {\n            uint256 len = _rewardTokens.length;\n            for (uint256 i = 0; i < len; ) {\n                uint256 claimableIndex = rewardTokenIndex[_rewardTokens[i]];\n                uint256 amount = amounts[i];\n\n                if (amount > 0) {\n                    // Math is safe: `amount` calculated safely in `claimable()`\n                    claimed[_tokenId][claimableIndex] += amount;\n                    rewardTokens[claimableIndex].safeTransfer(_to, amount);\n                }\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Release the tap of a position and send it to `_to`. Remove the user from twAML.\n    function _releaseTap(\n        uint256 _tokenId,\n        address _to\n    ) internal returns (uint256 releasedAmount) {\n        Participation memory position = participants[_tokenId];\n        if (position.tapReleased) {\n            return 0;\n        }\n        require(position.expiry <= block.timestamp, \"twTAP: Lock not expired\");\n\n        releasedAmount = position.tapAmount;\n\n        // Remove participation\n        if (position.hasVotingPower) {\n            TWAMLPool memory pool = twAML;\n            pool.totalParticipants--;\n\n            // Inverse of the participation. The participation entry tracks\n            // the average magnitude as it was at the time the participant\n            // entered. When going the other way around, this value matches the\n            // one in the pool, but here it does not.\n            if (position.divergenceForce) {\n                if (pool.cumulative > position.averageMagnitude) {\n                    pool.cumulative -= position.averageMagnitude;\n                } else {\n                    pool.cumulative = 0;\n                }\n            } else {\n                pool.cumulative += position.averageMagnitude;\n            }\n\n            // Save new weight\n            pool.totalDeposited -= position.tapAmount;\n\n            twAML = pool; // Save twAML exit\n            emit AMLDivergence(\n                pool.cumulative,\n                pool.averageMagnitude,\n                pool.totalParticipants\n            ); // Register new voting power event\n        }\n\n        participants[_tokenId].tapReleased = true;\n        tapOFT.transfer(_to, releasedAmount);\n\n        emit ExitPosition(_tokenId, releasedAmount);\n    }\n\n    /// @dev Returns the chain ID of the current network\n    function _getChainId() internal view virtual returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ONFT721, ERC721) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}"
    }
  ]
}