{
  "Title": "[M-02] The `RandomizerVRF` and `RandomizerRNG` do not produce hash value.",
  "Content": "\nAccording to documentation and other randomizer implementations, Randomizers are expected to set a random `HASH` for the minted tokens.\n\nHowever, the implementation mistakenly uses bytes32 in the format:\n\n- `bytes32(abi.encodePacked(numbers, requestToToken[id])` or\n- `bytes32(abi.encodePacked(_randomWords, requestToToken[_requestId]))`.\n\n```js\nFile: 2023-10-nextgen\\smart-contracts\\RandomizerVRF.sol\n65:     function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\n66:         gencoreContract.setTokenHash(tokenIdToCollection[requestToToken[_requestId]], requestToToken[_requestId], bytes32(abi.encodePacked(_randomWords,requestToToken[_requestId])));\n67:         emit RequestFulfilled(_requestId, _randomWords);\n68:     }\n69: \n\nFile: 2023-10-nextgen\\smart-contracts\\RandomizerRNG.sol\n48:     function fulfillRandomWords(uint256 id, uint256[] memory numbers) internal override {\n49:         gencoreContract.setTokenHash(tokenIdToCollection[requestToToken[id]], requestToToken[id], bytes32(abi.encodePacked(numbers, requestToToken[id])));\n50:     }\n```\n\nThe hash is calculated as `bytes32` from `abi.encodePacked` of the `random number` and `tokenId`.\n\nKey observations:\n\n1. `bytes32` truncates the result of `abi.encodePacked(numbers, requestToToken[id]`) and *only considers the first element of the random numbers array*.\n2. The random number is directly passed to `setTokenHash`. *It is not a hash*, and the second parameter meant to contribute to the hash creation is ignored.\n3. Now, the token's hash is directly dependent on the provided number.\n\nThus, these contracts only pass the random number instead of generating a hash value.\n\n### Proof of Concept\n\n- <https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/RandomizerVRF.sol#L66>\n-  <https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/RandomizerRNG.sol#L49>\n\n### Description\n\nExample:\n\nIf `_randomWords = [1, 2]` and `requestToToken = 1000`,\nthe result will be `0x0000000000000000000000000000000000000000000000000000000000000001`, which equals only the first provided random number.\n\n```js\nFile: 2023-10-nextgen\\smart-contracts\\RandomizerVRF.sol\n65:     function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\n66:         gencoreContract.setTokenHash(tokenIdToCollection[requestToToken[_requestId]], requestToToken[_requestId], bytes32(abi.encodePacked(_randomWords,requestToToken[_requestId])));\n67:         emit RequestFulfilled(_requestId, _randomWords);\n68:     }\n69: \n\nFile: 2023-10-nextgen\\smart-contracts\\RandomizerRNG.sol\n48:     function fulfillRandomWords(uint256 id, uint256[] memory numbers) internal override {\n49:         gencoreContract.setTokenHash(tokenIdToCollection[requestToToken[id]], requestToToken[id], bytes32(abi.encodePacked(numbers, requestToToken[id])));\n50:     }\n```\n\n### Tools Used\n\nHardHat\n\n### Recommended Mitigation Steps\n\nAt a minimum, calculate the hash from the provided data using `keccak256`.\n\n```diff\nFile: 2023-10-nextgen\\smart-contracts\\RandomizerVRF.sol\n65:     function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\n-66:         gencoreContract.setTokenHash(tokenIdToCollection[requestToToken[_requestId]], requestToToken[_requestId], bytes32(abi.encodePacked(_randomWords,requestToToken[_requestId])));\n+66:         gencoreContract.setTokenHash(tokenIdToCollection[requestToToken[_requestId]], requestToToken[_requestId], keccak256(abi.encodePacked(_randomWords,requestToToken[_requestId])));\n67:         emit RequestFulfilled(_requestId, _randomWords);\n68:     }\n69: \n\nFile: 2023-10-nextgen\\smart-contracts\\RandomizerRNG.sol\n48:     function fulfillRandomWords(uint256 id, uint256[] memory numbers) internal override {\n-49:         gencoreContract.setTokenHash(tokenIdToCollection[requestToToken[id]], requestToToken[id], bytes32(abi.encodePacked(numbers, requestToToken[id])));\n+49:         gencoreContract.setTokenHash(tokenIdToCollection[requestToToken[id]], requestToToken[id], keccak256(abi.encodePacked(numbers, requestToToken[id])));\n\n50:     }\n```\n\nThis change will ensure compliance with documentation and consider all data involved in the hash creation process.\n\n**[a2rocket (NextGen) confirmed via duplicate issue #1688](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1688#issuecomment-1823861588)**\n\n**[aslanbek (warden) commented via duplicate issue #1688](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1688#issuecomment-1848332019):**\n> I believe this report contradicts itself: \n>\n> The [RandomizerVRF](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/RandomizerVRF.sol) and [RandomizerRNG](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/RandomizerRNG.sol) contracts will not return random hashes, instead, they will only return the generated random number.\n>\n> This results in non-unique/duplicated tokenHash values and non-randomly generated NFTs. How can two random numbers not being hashed result in non-randomly generated NFTs?\n>\n> There's indeed a discrepancy between the spec and implementation, but not fixing the issue will simply result in tokens having a random `tokenToHash` anyway, which is sufficient for correct functioning of the protocol. \n\n**[d3e4 (warden) commented via duplicate issue #1688](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1688#issuecomment-1848368235):**\n> Only one random number is requested, so nothing is trimmed away. Hashing a random `256-bit` value does not make it any more random, it is just an arbitrary bijection. A random number and a hash digest (of an unknown or random number) are equivalent. It is randomness that is sought, not the output of specifically a hash function.\n\n**[0xsomeone (judge) commented via duplicate issue #1688](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1688#issuecomment-1848416930):**\n> @aslanbek and @d3e4, thanks for your feedback! Let me address both of your points:\n>\n> **Report Contradiction** - Indeed the report contradicts itself, however, it was the sole submission of this issue and as such is the primary one. \n>\n>**Randomness Impact** - A value not being hashed does not impact its randomness, however, it does impact the range the values will be present in. As such, it allows the \"expansion\" of a randomness range to cover the full `uint256` value range. For example, if the randomness values are in a sub-range `[X,Y]`, the randomness oracles will produce token IDs solely in that range. \n>\n> If a hash function is utilized (such as `keccak256`), the range will be expanded to `[0, type(uint256).max]` which is the desirable outcome. This is further illustrated by the fact that the `tokenHash` entry specifies it should be a hash.\n>\n>**ARRNG-Specific Impact** - Another important trait of hashing is the minimization of monobit bias. A monobit bias occurs when a single bit in the randomness output is more frequently `0` or `1` in relation to the rest of the bits. This is especially prevalent in random sources such as ARRNG which rely on radio waves and other real-world data that may bias their measurements.\n>\n> A hash will induce the avalanche effect whereby a bit will have a rough chance of being flipped. As such, monobit bias is somewhat eliminated by using hashing functions. While I won't criticize Chainlink, the ARRNG service relies on `RANDOM.ORG` which provides publicly accessible data showcasing its monobit bias.\n>\n> **Chainlink-Specific Impact** - The Chainlink oracle of NextGen is defined to have the `numWords` requested as updateable. This is very useful when the perceived entropy of random numbers is small; specifically, a hash of multiple lower-than-maximum (`256` in this case) entropy numbers will \"compress\" the entropy (with some loss of course) into 32 bytes. As an example, hashing two numbers with `16` and `19` bits of entropy each will produce an output that has their entropy combined minus one to account for entropy lost due to compression and collisions.\n> \n> As the `numWords` variable can be updated, we can see a problem in the codebase whereby any value of `numWords` greater than one will not increase the entropy of the randomness generator as expected. \n> \n> **Closing Thought** - Given that the code contains an egregious error that directly impacts its functionality, I will maintain the current medium risk rating. The `tokenHash` mapping is expected to contain a hash, and assigning it otherwise is an invariant that is broken. I will consider inviting other judges to contribute to this particular judgment. \n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1688).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "smart-contracts/RandomizerVRF.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Randomizer Contract VRF\n *  @date: 18-October-2023 \n *  @version: 1.8\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./VRFCoordinatorV2Interface.sol\";\nimport \"./VRFConsumerBaseV2.sol\";\nimport \"./Ownable.sol\";\nimport \"./INextGenCore.sol\";\nimport \"./INextGenAdmins.sol\";\n\ncontract NextGenRandomizerVRF is VRFConsumerBaseV2, Ownable {\n    event RequestFulfilled(uint256 requestId, uint256[] randomWords);\n\n    VRFCoordinatorV2Interface public COORDINATOR;\n\n    // chainlink data\n    uint64 s_subscriptionId;\n    bytes32 public keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;\n    uint32 public callbackGasLimit = 40000;\n    uint16 public requestConfirmations = 3;\n    uint32 public numWords = 1;\n\n    mapping(uint256 => uint256) public tokenIdToCollection;\n    mapping(uint256 => uint256) public tokenToRequest;\n    mapping(uint256 => uint256) public requestToToken;\n\n    address gencore;\n    INextGenCore public gencoreContract;\n    INextGenAdmins private adminsContract;\n\n    constructor(uint64 subscriptionId, address vrfCoordinator, address _gencore, address _adminsContract) VRFConsumerBaseV2(vrfCoordinator) {\n        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n        s_subscriptionId = subscriptionId;\n        gencore = _gencore;\n        gencoreContract = INextGenCore(_gencore);\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    function requestRandomWords(uint256 tokenid) public {\n        require(msg.sender == gencore);\n        uint256 requestId = COORDINATOR.requestRandomWords(\n            keyHash,\n            s_subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,  \n            numWords\n        );\n        tokenToRequest[tokenid] = requestId;\n        requestToToken[requestId] = tokenid;\n    }\n\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\n        gencoreContract.setTokenHash(tokenIdToCollection[requestToToken[_requestId]], requestToToken[_requestId], bytes32(abi.encodePacked(_randomWords,requestToToken[_requestId])));\n        emit RequestFulfilled(_requestId, _randomWords);\n    }\n\n    // function that calculates the random hash and returns it to the gencore contract\n    function calculateTokenHash(uint256 _collectionID, uint256 _mintIndex, uint256 _saltfun_o) public {\n        require(msg.sender == gencore);\n        tokenIdToCollection[_mintIndex] = _collectionID;\n        requestRandomWords(_mintIndex);\n    }\n\n    // function to update callbackGasLimit & keyHash\n\n    function updatecallbackGasLimitAndkeyHash(uint32 _callbackGasLimit, bytes32 _keyHash) public FunctionAdminRequired(this.updatecallbackGasLimitAndkeyHash.selector){\n        callbackGasLimit = _callbackGasLimit;\n        keyHash = _keyHash;\n    }\n\n    // function to change the requests other data\n\n    function updateAdditionalData(uint64 _s_subscriptionId, uint32 _numWords, uint16 _requestConfirmations) public FunctionAdminRequired(this.updateAdditionalData.selector){\n        s_subscriptionId = _s_subscriptionId;\n        numWords = _numWords;\n        requestConfirmations = _requestConfirmations;\n    }\n\n     // function to update contracts\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);\n    }\n\n    function updateCoreContract(address _gencore) public FunctionAdminRequired(this.updateCoreContract.selector) { \n        gencore = _gencore;\n        gencoreContract = INextGenCore(_gencore);\n    }\n\n    // get randomizer contract status\n    function isRandomizerContract() external view returns (bool) {\n        return true;\n    }\n\n}"
    },
    {
      "filename": "smart-contracts/RandomizerRNG.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Randomizer Contract RNG\n *  @date: 18-October-2023\n *  @version: 1.7\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./ArrngConsumer.sol\";\nimport \"./Ownable.sol\";\nimport \"./INextGenCore.sol\";\nimport \"./INextGenAdmins.sol\";\n\ncontract NextGenRandomizerRNG is ArrngConsumer, Ownable {\n\n    mapping(uint256 => uint256) public requestToToken;\n    address gencore;\n    INextGenCore public gencoreContract;\n    INextGenAdmins private adminsContract;\n    event Withdraw(address indexed _add, bool status, uint256 indexed funds);\n    uint256 ethRequired;\n    mapping(uint256 => uint256) public tokenToRequest;\n    mapping(uint256 => uint256) public tokenIdToCollection;\n\n    constructor(address _gencore, address _adminsContract, address _arRNG) ArrngConsumer(_arRNG) {\n        gencore = _gencore;\n        gencoreContract = INextGenCore(_gencore);\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n        require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n        _;\n    }\n\n    function requestRandomWords(uint256 tokenid, uint256 _ethRequired) public payable {\n        require(msg.sender == gencore);\n        uint256 requestId = arrngController.requestRandomWords{value: _ethRequired}(1, (address(this)));\n        tokenToRequest[tokenid] = requestId;\n        requestToToken[requestId] = tokenid;\n\n    }\n\n    function fulfillRandomWords(uint256 id, uint256[] memory numbers) internal override {\n        gencoreContract.setTokenHash(tokenIdToCollection[requestToToken[id]], requestToToken[id], bytes32(abi.encodePacked(numbers,requestToToken[id])));\n    }\n\n    // function that calculates the random hash and returns it to the gencore contract\n    function calculateTokenHash(uint256 _collectionID, uint256 _mintIndex, uint256 _saltfun_o) public {\n        require(msg.sender == gencore);\n        tokenIdToCollection[_mintIndex] = _collectionID;\n        requestRandomWords(_mintIndex, ethRequired);\n    }\n\n    // function to update contracts\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);\n    }\n\n    function updateCoreContract(address _gencore) public FunctionAdminRequired(this.updateCoreContract.selector) { \n        gencore = _gencore;\n        gencoreContract = INextGenCore(_gencore);\n    }\n\n    // function to update cost\n\n    function updateRNGCost(uint256 _ethRequired) public FunctionAdminRequired(this.updateRNGCost.selector) {\n        ethRequired = _ethRequired;\n    }\n\n    // function to withdraw any balance from the smart contract\n\n    function emergencyWithdraw() public FunctionAdminRequired(this.emergencyWithdraw.selector) {\n        uint balance = address(this).balance;\n        address admin = adminsContract.owner();\n        (bool success, ) = payable(admin).call{value: balance}(\"\");\n        emit Withdraw(msg.sender, success, balance);\n    }\n\n    receive() external payable {}\n\n    // get randomizer contract status\n    function isRandomizerContract() external view returns (bool) {\n        return true;\n    }\n}"
    }
  ]
}