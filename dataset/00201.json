{
  "Title": "M-7: EMA Data Point From Unlock Is Discarded",
  "Content": "# Issue M-7: EMA Data Point From Unlock Is Discarded \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/201 \n\n## Found by \nJigglypuffAndPikachu, Tendency, lemonmon, pseudoArtist\n## Summary\n\nThe `ema` calculation fails to incorporate the `emaJTT` and `emaSTT` amounts which are initally set in `unlock`.\n\n## Vulnerability Details\n\nLet's carefully consider the EMA calculation. Firstly during the unlock, the `emaSTT` and `emaJTT `are set to the current values. This acts as our first data point. Since this is the only data point, this doesn't have any averaging which is why `MATH.ema()` is not called.\n\nNow, after unlocking consider when `distributeYield` is called for the first time after unlocking. `emaSTT` and `emaJTT` should incorporate the first data point (which was recorded during unlock) with the new `totalSupply` of `STT` and `JTT`.\n\nNow let's show why the contract will actually ignore the `emaSTT`/JTT set during unlock during the first yield distribution:\n\nThe `distributionCounter` is `0` when `distributeYield` is called, but due to the line `distributionCounter += 1;`, `1` is passed as the 3rd parameter to the `ema` formula in `emaSTT = MATH.ema(emaSTT, aSTT, retrospectiveDistributions.min(distributionCounter));`\n\nWhen `N == 1` in the `ema` formula, the function will return only `eV`, which is only the latest data point. It completely ignores `bV` which is the data point during the unlock:\n\n```solidity\nfunction ema(uint256 bV, uint256 cV, uint256 N) external pure returns (uint256 eV) {\n\n    assert(N != 0);\n\n    uint256 M = (WAD * 2).floorDiv(N + 1); //When N = 1, M = WAD\n\n    eV = ((M * cV) + (WAD - M) * bV).floorDiv(WAD); //Substituting M = WAD, eV = cV\n\n}\n```\n\n## Impact\n\nIncorrect EMA calculation which leads to incorrect yield distribution\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L213-L310\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe `distributionCounter` should actually be `2` rather than 1 during the first pass into the `MATH.ema()` formula. However then the varibale would not really correspond to the number of times `distribution` was called, so it might need to be renamed.\n\n\n\n## Discussion\n\n**pseudonaut**\n\nValid, distributionCounter must be set to 1 initially\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> borderline low/medium, while true, the impact is questionable as there can be situations when current method is better than fixed one, so this is basically a choice of N=1 or N=2 - both are valid, just whatever developer prefers to better fit the protocol needs.\n\n\n\n**panprog**\n\nKeeping this medium as sponsor confirmed it's valid (thus considering that N=2 is the intended value, but it's N=1 right now). The impact then is unintended values used in further calculations.\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/252\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/ZivoeYDL.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./ZivoeMath.sol\";\n\nimport \"./libraries/FloorMath.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IZivoeGlobals_YDL {\n    /// @notice Returns the address of the ZivoeDAO contract.\n    function DAO() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeITO contract.\n    function ITO() external view returns (address);\n    \n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($ZVE) contract.\n    function stZVE() external view returns (address);\n\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewardsVesting ($ZVE) vesting contract.\n    function vestZVE() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zSTT) contract.\n    function zSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zJTT) contract.\n    function zJTT() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns total circulating supply of zSTT and zJTT, accounting for defaults via markdowns.\n    /// @return zSTTSupply zSTT.totalSupply() adjusted for defaults.\n    /// @return zJTTSupply zJTT.totalSupply() adjusted for defaults.\n    function adjustedSupplies() external view returns (uint256 zSTTSupply, uint256 zJTTSupply);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount The amount of a given \"asset\".\n    /// @param  asset The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount The above amount standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n\n    /// @notice This function will verify if a given stablecoin has been whitelisted for use throughout system.\n    /// @param  stablecoin address of the stablecoin to verify acceptance for.\n    function stablecoinWhitelist(address stablecoin) external view returns (bool);\n}\n\ninterface IZivoeRewards_YDL {\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @param  reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external;\n}\n\n\n\n/// @notice  This contract manages the accounting for distributing yield across multiple contracts.\n///          This contract has the following responsibilities:\n///            - Escrows yield in between distribution periods.\n///            - Manages accounting for yield distribution.\n///            - Supports modification of certain state variables for governance purposes.\n///            - Tracks historical values using EMA (exponential moving average) on 30-day basis.\ncontract ZivoeYDL is Context, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using FloorMath for uint256;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Recipients {\n        address[] recipients;\n        uint256[] proportion;\n    }\n\n    Recipients protocolRecipients;          /// @dev Tracks the distributions for protocol earnings.\n    Recipients residualRecipients;          /// @dev Tracks the distributions for residual earnings.\n\n    address public immutable GBL;           /// @dev The ZivoeGlobals contract.\n\n    address public distributedAsset;        /// @dev The \"stablecoin\" that will be distributed via YDL.\n\n    // Weighted moving averages.\n    uint256 public emaSTT;          /// @dev Weighted moving average for senior tranche size, a.k.a. zSTT.totalSupply().\n    uint256 public emaJTT;          /// @dev Weighted moving average for junior tranche size, a.k.a. zJTT.totalSupply().\n\n    // Indexing.\n    uint256 public distributionCounter;     /// @dev Number of calls to distributeYield().\n    uint256 public lastDistribution;        /// @dev Used for timelock constraint to call distributeYield().\n\n    // Accounting vars (governable).\n    uint256 public targetAPYBIPS = 1000;                /// @dev The target annualized yield for senior tranche.\n    uint256 public targetRatioBIPS = 22000;             /// @dev The target ratio of junior to senior tranche.\n    uint256 public protocolEarningsRateBIPS = 2000;     /// @dev The protocol earnings rate.\n\n    // Accounting vars (constant).\n    uint256 public constant daysBetweenDistributions = 30;   /// @dev Number of days between yield distributions.\n    uint256 public constant retrospectiveDistributions = 6;  /// @dev Retrospective moving average period.\n    \n    bool public unlocked;                   /// @dev Prevents contract from supporting functionality until unlocked.\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant RAY = 10 ** 27;\n\n    ZivoeMath public MATH;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initialize the ZivoeYDL contract.\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _distributedAsset The \"stablecoin\" that will be distributed via YDL.\n    constructor(address _GBL, address _distributedAsset) {\n        GBL = _GBL;\n        distributedAsset = _distributedAsset;\n        MATH = new ZivoeMath();\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during returnAsset().\n    /// @param  asset The asset returned.\n    /// @param  amount The amount of \"asset\" returned to DAO.\n    event AssetReturned(address indexed asset, uint256 amount);\n\n    /// @notice Emitted during updateDistributedAsset().\n    /// @param  oldAsset The old value of distributedAsset.\n    /// @param  newAsset The new value of distributedAsset.\n    event UpdatedDistributedAsset(address indexed oldAsset, address indexed newAsset);\n\n    /// @notice Emitted during updateProtocolEarningsRateBIPS().\n    /// @param  oldValue The old value of protocolEarningsRateBIPS.\n    /// @param  newValue The new value of protocolEarningsRateBIPS.\n    event UpdatedProtocolEarningsRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive protocol earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedProtocolRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive residual earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedResidualRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateTargetAPYBIPS().\n    /// @param  oldValue The old value of targetAPYBIPS.\n    /// @param  newValue The new value of targetAPYBIPS.\n    event UpdatedTargetAPYBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateTargetRatioBIPS().\n    /// @param  oldValue The old value of targetRatioBIPS.\n    /// @param  newValue The new value of targetRatioBIPS.\n    event UpdatedTargetRatioBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  protocol The amount of earnings distributed to protocol earnings recipients.\n    /// @param  senior The amount of earnings distributed to the senior tranche.\n    /// @param  junior The amount of earnings distributed to the junior tranche.\n    /// @param  residual The amount of earnings distributed to residual earnings recipients.\n    event YieldDistributed(uint256[] protocol, uint256 senior, uint256 junior, uint256[] residual);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  recipient The recipient of the distribution.\n    /// @param  amount The amount distributed.\n    event YieldDistributedSingle(address indexed asset, address indexed recipient, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice View distribution information for protocol and residual earnings recipients.\n    /// @return protocolEarningsRecipients The destinations for protocol earnings distributions.\n    /// @return protocolEarningsProportion The proportions for protocol earnings distributions.\n    /// @return residualEarningsRecipients The destinations for residual earnings distributions.\n    /// @return residualEarningsProportion The proportions for residual earnings distributions.\n    function viewDistributions() external view returns (\n        address[] memory protocolEarningsRecipients, uint256[] memory protocolEarningsProportion, \n        address[] memory residualEarningsRecipients, uint256[] memory residualEarningsProportion\n    ) {\n        return (\n            protocolRecipients.recipients, \n            protocolRecipients.proportion, \n            residualRecipients.recipients, \n            residualRecipients.proportion\n        );\n    }\n    \n    /// @notice Distributes available yield within this contract to appropriate entities.\n    function distributeYield() external nonReentrant {\n        require(unlocked, \"ZivoeYDL::distributeYield() !unlocked\"); \n        require(\n            block.timestamp >= lastDistribution + daysBetweenDistributions * 86400, \n            \"ZivoeYDL::distributeYield() block.timestamp < lastDistribution + daysBetweenDistributions * 86400\"\n        );\n\n        // Calculate protocol earnings.\n        uint256 earnings = IERC20(distributedAsset).balanceOf(address(this));\n        uint256 protocolEarnings = protocolEarningsRateBIPS * earnings / BIPS;\n        uint256 postFeeYield = earnings.floorSub(protocolEarnings);\n\n        // Update timeline.\n        distributionCounter += 1;\n        lastDistribution = block.timestamp;\n\n        // Calculate yield distribution (trancheuse = \"slicer\" in French).\n        (\n            uint256[] memory _protocol, uint256 _seniorTranche, uint256 _juniorTranche, uint256[] memory _residual\n        ) = earningsTrancheuse(protocolEarnings, postFeeYield); \n\n        emit YieldDistributed(_protocol, _seniorTranche, _juniorTranche, _residual);\n        \n        // Update ema-based supply values.\n        (uint256 aSTT, uint256 aJTT) = IZivoeGlobals_YDL(GBL).adjustedSupplies();\n        emaSTT = MATH.ema(emaSTT, aSTT, retrospectiveDistributions.min(distributionCounter));\n        emaJTT = MATH.ema(emaJTT, aJTT, retrospectiveDistributions.min(distributionCounter));\n\n        // Distribute protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            address _recipient = protocolRecipients.recipients[i];\n            if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _protocol[i]);\n                IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n            else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                uint256 splitBIPS = (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                ) / (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                    IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                );\n                uint stZVEAllocation = _protocol[i] * splitBIPS / BIPS;\n                uint vestZVEAllocation = _protocol[i] * (BIPS - splitBIPS) / BIPS;\n                IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).vestZVE(),vestZVEAllocation);\n                IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stZVE()).depositReward(distributedAsset, stZVEAllocation);\n                IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).vestZVE()).depositReward(distributedAsset, vestZVEAllocation);\n                emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n            }\n            else {\n                IERC20(distributedAsset).safeTransfer(_recipient, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n        }\n\n        // Distribute senior and junior tranche earnings.\n        IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stSTT(), _seniorTranche);\n        IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stJTT(), _juniorTranche);\n        IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stSTT()).depositReward(distributedAsset, _seniorTranche);\n        IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stJTT()).depositReward(distributedAsset, _juniorTranche);\n        emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stSTT(), _seniorTranche);\n        emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stJTT(), _juniorTranche);\n\n        // Distribute residual earnings.\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            if (_residual[i] > 0) {\n                address _recipient = residualRecipients.recipients[i];\n                if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                    IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _residual[i]);\n                    IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n                }\n                else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                    uint256 splitBIPS = (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                    ) / (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                        IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                    );\n                    uint stZVEAllocation = _residual[i] * splitBIPS / BIPS;\n                    uint vestZVEAllocation = _residual[i] * (BIPS - splitBIPS) / BIPS;\n                    IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                    IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n                    IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stZVE()).depositReward(distributedAsset, stZVEAllocation);\n                    IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).vestZVE()).depositReward(distributedAsset, vestZVEAllocation);\n                    emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                    emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n                }\n                else {\n                    IERC20(distributedAsset).safeTransfer(_recipient, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _residual[i]);\n                }\n            }\n        }\n    }\n\n    /// @notice Returns an asset to DAO if not distributedAsset().\n    /// @param asset The asset to return.\n    function returnAsset(address asset) external {\n        require(asset != distributedAsset, \"ZivoeYDL::returnAsset() asset == distributedAsset\");\n        emit AssetReturned(asset, IERC20(asset).balanceOf(address(this)));\n        IERC20(asset).safeTransfer(IZivoeGlobals_YDL(GBL).DAO(), IERC20(asset).balanceOf(address(this)));\n    }\n\n    /// @notice Unlocks this contract for distributions, initializes values.\n    function unlock() external {\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).ITO(), \n            \"ZivoeYDL::unlock() _msgSender() != IZivoeGlobals_YDL(GBL).ITO()\"\n        );\n\n        unlocked = true;\n        lastDistribution = block.timestamp + 30 days;\n\n        emaSTT = IERC20(IZivoeGlobals_YDL(GBL).zSTT()).totalSupply();\n        emaJTT = IERC20(IZivoeGlobals_YDL(GBL).zJTT()).totalSupply();\n\n        address[] memory protocolRecipientAcc = new address[](2);\n        uint256[] memory protocolRecipientAmt = new uint256[](2);\n\n        protocolRecipientAcc[0] = address(IZivoeGlobals_YDL(GBL).stZVE());\n        protocolRecipientAmt[0] = 6666;\n        protocolRecipientAcc[1] = address(IZivoeGlobals_YDL(GBL).ZVL());\n        protocolRecipientAmt[1] = 3334;\n\n        protocolRecipients = Recipients(protocolRecipientAcc, protocolRecipientAmt);\n\n        address[] memory residualRecipientAcc = new address[](2);\n        uint256[] memory residualRecipientAmt = new uint256[](2);\n\n        residualRecipientAcc[0] = address(IZivoeGlobals_YDL(GBL).stZVE());\n        residualRecipientAmt[0] = 6666;\n        residualRecipientAcc[1] = address(IZivoeGlobals_YDL(GBL).ZVL());\n        residualRecipientAmt[1] = 3334;\n\n        residualRecipients = Recipients(residualRecipientAcc, residualRecipientAmt);\n    }\n\n    /// @notice Updates the distributed asset for this particular contract.\n    /// @param  _distributedAsset The new value for distributedAsset.\n    function updateDistributedAsset(address _distributedAsset) external nonReentrant {\n        require(\n            _distributedAsset != distributedAsset, \n            \"ZivoeYDL::updateDistributedAsset() _distributedAsset == distributedAsset\"\n        );\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \n            \"ZivoeYDL::updateDistributedAsset() _msgSender() != TLC()\"\n        );\n        require(\n            IZivoeGlobals_YDL(GBL).stablecoinWhitelist(_distributedAsset),\n            \"ZivoeYDL::updateDistributedAsset() !IZivoeGlobals_YDL(GBL).stablecoinWhitelist(_distributedAsset)\"\n        );\n        emit UpdatedDistributedAsset(distributedAsset, _distributedAsset);\n        distributedAsset = _distributedAsset;\n    }\n\n    /// @notice Updates the state variable \"protocolEarningsRateBIPS\".\n    /// @param  _protocolEarningsRateBIPS The new value for protocolEarningsRateBIPS.\n    function updateProtocolEarningsRateBIPS(uint256 _protocolEarningsRateBIPS) external {\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \n            \"ZivoeYDL::updateProtocolEarningsRateBIPS() _msgSender() != TLC()\"\n        );\n        require(\n            _protocolEarningsRateBIPS <= 9000, \n            \"ZivoeYDL::updateProtocolEarningsRateBIPS() _protocolEarningsRateBIPS > 9000\"\n        );\n        emit UpdatedProtocolEarningsRateBIPS(protocolEarningsRateBIPS, _protocolEarningsRateBIPS);\n        protocolEarningsRateBIPS = _protocolEarningsRateBIPS;\n    }\n\n    /// @notice Updates the protocolRecipients or residualRecipients.\n    /// @param  recipients An array of addresses to which protocol earnings will be distributed.\n    /// @param  proportions An array of ratios relative to the recipients - in BIPS. Sum should equal to 10000.\n    /// @param  protocol Specify \"true\" to update protocol earnings, or \"false\" to update residual earnings.\n    function updateRecipients(address[] memory recipients, uint256[] memory proportions, bool protocol) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateRecipients() _msgSender() != TLC()\");\n        require(\n            recipients.length == proportions.length && recipients.length > 0, \n            \"ZivoeYDL::updateRecipients() recipients.length != proportions.length || recipients.length == 0\"\n        );\n        require(unlocked, \"ZivoeYDL::updateRecipients() !unlocked\");\n\n        uint256 proportionTotal;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            proportionTotal += proportions[i];\n            require(proportions[i] > 0, \"ZivoeYDL::updateRecipients() proportions[i] == 0\");\n            require(recipients[i] != address(0), \"ZivoeYDL::updateRecipients() recipients[i] == address(0)\");\n        }\n\n        require(proportionTotal == BIPS, \"ZivoeYDL::updateRecipients() proportionTotal != BIPS (10,000)\");\n        if (protocol) {\n            emit UpdatedProtocolRecipients(recipients, proportions);\n            protocolRecipients = Recipients(recipients, proportions);\n        }\n        else {\n            emit UpdatedResidualRecipients(recipients, proportions);\n            residualRecipients = Recipients(recipients, proportions);\n        }\n    }\n\n    /// @notice Updates the state variable \"targetAPYBIPS\".\n    /// @param  _targetAPYBIPS The new value for targetAPYBIPS.\n    function updateTargetAPYBIPS(uint256 _targetAPYBIPS) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateTargetAPYBIPS() _msgSender() != TLC()\");\n        emit UpdatedTargetAPYBIPS(targetAPYBIPS, _targetAPYBIPS);\n        targetAPYBIPS = _targetAPYBIPS;\n    }\n\n    /// @notice Updates the state variable \"targetRatioBIPS\".\n    /// @param  _targetRatioBIPS The new value for targetRatioBIPS.\n    function updateTargetRatioBIPS(uint256 _targetRatioBIPS) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateTargetRatioBIPS() _msgSender() != TLC()\");\n        emit UpdatedTargetRatioBIPS(targetRatioBIPS, _targetRatioBIPS);\n        targetRatioBIPS = _targetRatioBIPS;\n    }\n\n\n\n    // ----------\n    //    Math\n    // ----------\n\n    /// @notice Calculates the distribution of yield (\"earnings\") for the four primary groups.\n    /// @param  yP Yield for the protocol.\n    /// @param  yD Yield for the remaining three groups.\n    /// @return protocol Protocol earnings.\n    /// @return senior Senior tranche earnings.\n    /// @return junior Junior tranche earnings.\n    /// @return residual Residual earnings.\n    function earningsTrancheuse(uint256 yP, uint256 yD) public view returns (\n        uint256[] memory protocol, uint256 senior, uint256 junior, uint256[] memory residual\n    ) {\n        protocol = new uint256[](protocolRecipients.recipients.length);\n        residual = new uint256[](residualRecipients.recipients.length);\n        \n        // Accounting for protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            protocol[i] = protocolRecipients.proportion[i] * yP / BIPS;\n        }\n\n        // Accounting for senior and junior earnings.\n        uint256 _seniorProportion = MATH.seniorProportion(\n            IZivoeGlobals_YDL(GBL).standardize(yD, distributedAsset),\n            MATH.yieldTarget(emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions),\n            emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions\n        );\n        senior = (yD * _seniorProportion) / RAY;\n        junior = (yD * MATH.juniorProportion(emaSTT, emaJTT, _seniorProportion, targetRatioBIPS)) / RAY;\n        \n        // Handle accounting for residual earnings.\n        yD = yD.floorSub(senior + junior);\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            residual[i] = residualRecipients.proportion[i] * yD / BIPS;\n        }\n    }\n\n}"
    }
  ]
}