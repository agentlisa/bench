{
  "Title": "The `svTokenValue` function can return overestimated value of each strategy vault share token",
  "Content": "# The `svTokenValue` function can return overestimated value of each strategy vault share token\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L27-L32\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L27-L32</a>\n\n\n## Summary\nThe `GMXReader.svTokenValue` function can return overestimated value of each strategy vault share token due to outdated `totalSupply`, i.e. without including pending management fees for a long period. This issue can cause the protocol unexpected behavior while keepers provide rebalance and when other protocols receive information about shares value.\n\n## Vulnerability Details\nThe `svTokenValue` function calculates the value of each strategy vault share token with the current amount of `totalSupply`, which may not include pending management fees:\n```solidity\n  function svTokenValue(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 equityValue_ = equityValue(self);\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    if (equityValue_ == 0 || totalSupply_ == 0) return SAFE_MULTIPLIER;\n    return equityValue_ * SAFE_MULTIPLIER / totalSupply_;\n  }\n```  \nSo the returned share value will be overestimated. The longer the period since the last `mintFee` was called the more overestimated shares value is.\n\n## Impact\nThe `GMXReader.svTokenValue` function returns an overestimated value of the share token. This issue can cause the protocol unexpected behavior while keepers provide rebalance and when other protocols receive information about the shares value.\n\n## Tools used\nManual Review\n\n## Recommendations\nConsider adding `pendingFee` to the `totalSupply`:\n```diff\n  function svTokenValue(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 equityValue_ = equityValue(self);\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    if (equityValue_ == 0 || totalSupply_ == 0) return SAFE_MULTIPLIER;\n-    return equityValue_ * SAFE_MULTIPLIER / totalSupply_;\n+    return equityValue_ * SAFE_MULTIPLIER / (totalSupply_ + pendingFee(self));\n  } \n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXReader.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\n\n/**\n  * @title GMXReader\n  * @author Steadefi\n  * @notice Re-usable library functions for reading data and values for Steadefi leveraged vaults\n*/\nlibrary GMXReader {\n  using SafeCast for uint256;\n\n  /* =================== CONSTANTS FUNCTIONS ================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function svTokenValue(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 equityValue_ = equityValue(self);\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    if (equityValue_ == 0 || totalSupply_ == 0) return SAFE_MULTIPLIER;\n    return equityValue_ * SAFE_MULTIPLIER / totalSupply_;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function pendingFee(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    uint256 _secondsFromLastCollection = block.timestamp - self.lastFeeCollected;\n    return (totalSupply_ * self.feePerSecond * _secondsFromLastCollection) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function valueToShares(\n    GMXTypes.Store storage self,\n    uint256 value,\n    uint256 currentEquity\n  ) public view returns (uint256) {\n    uint256 _sharesSupply = IERC20(address(self.vault)).totalSupply() + pendingFee(self);\n    if (_sharesSupply == 0 || currentEquity == 0) return value;\n    return value * _sharesSupply / currentEquity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function convertToUsdValue(\n    GMXTypes.Store storage self,\n    address token,\n    uint256 amt\n  ) public view returns (uint256) {\n    return amt * 10**(18 - IERC20Metadata(token).decimals())\n                * self.chainlinkOracle.consultIn18Decimals(token)\n                / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function tokenWeights(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    // Get amounts of tokenA and tokenB in liquidity pool in token decimals\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    // Get value of tokenA and tokenB in 1e18\n    uint256 _tokenAValue = convertToUsdValue(self, address(self.tokenA), _reserveA);\n    uint256 _tokenBValue = convertToUsdValue(self, address(self.tokenB), _reserveB);\n\n    uint256 _totalLpValue = _tokenAValue + _tokenBValue;\n\n    return (\n      _tokenAValue * SAFE_MULTIPLIER / _totalLpValue,\n      _tokenBValue * SAFE_MULTIPLIER / _totalLpValue\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetValue(GMXTypes.Store storage self) public view returns (uint256) {\n    return lpAmt(self) * self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    ) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtValue(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n    return (\n      convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt),\n      convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt)\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function equityValue(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n\n    uint256 assetValue_ = assetValue(self);\n\n    uint256 _debtValue = convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt)\n                         + convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt);\n\n    // in underflow condition return 0\n    unchecked {\n      if (assetValue_ < _debtValue) return 0;\n\n      return assetValue_ - _debtValue;\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    return (\n      _reserveA * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER,\n      _reserveB * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    return (\n      self.tokenALendingVault.maxRepay(address(self.vault)),\n      self.tokenBLendingVault.maxRepay(address(self.vault))\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function lpAmt(GMXTypes.Store storage self) public view returns (uint256) {\n    return self.lpToken.balanceOf(address(self.vault));\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function leverage(GMXTypes.Store storage self) public view returns (uint256) {\n    if (assetValue(self) == 0 || equityValue(self) == 0) return 0;\n    return assetValue(self) * SAFE_MULTIPLIER / equityValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function delta(GMXTypes.Store storage self) public view returns (int256) {\n    (uint256 _tokenAAmt,) = assetAmt(self);\n    (uint256 _tokenADebtAmt,) = debtAmt(self);\n    uint256 equityValue_ = equityValue(self);\n\n    if (_tokenAAmt == 0 && _tokenADebtAmt == 0) return 0;\n    if (equityValue_ == 0) return 0;\n\n    bool _isPositive = _tokenAAmt >= _tokenADebtAmt;\n\n    uint256 _unsignedDelta = _isPositive ?\n      _tokenAAmt - _tokenADebtAmt :\n      _tokenADebtAmt - _tokenAAmt;\n\n    int256 signedDelta = (_unsignedDelta\n      * self.chainlinkOracle.consultIn18Decimals(address(self.tokenA))\n      / equityValue_).toInt256();\n\n    if (_isPositive) return signedDelta;\n    else return -signedDelta;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtRatio(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtValue, uint256 _tokenBDebtValue) = debtValue(self);\n    if (assetValue(self) == 0) return 0;\n    return (_tokenADebtValue + _tokenBDebtValue) * SAFE_MULTIPLIER / assetValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function additionalCapacity(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 _additionalCapacity;\n\n    // Long strategy only borrows short token (typically stablecoin)\n    if (self.delta == GMXTypes.Delta.Long) {\n      _additionalCapacity = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER / (self.leverage - 1e18);\n    }\n\n    // Neutral strategy borrows both long (typical volatile) and short token (typically stablecoin)\n    // Amount of long token to borrow is equivalent to deposited value x leverage x longTokenWeight\n    // Amount of short token to borrow is remaining borrow value AFTER borrowing long token\n    // ---------------------------------------------------------------------------------------------\n    // E.g: 3x Neutral ETH-USDC with weight of ETH being 55%, USDC 45%\n    // A $1 equity deposit should result in a $2 borrow for a total of $3 assets\n    // Amount of ETH to borrow would be $3 x 55% = $1.65 worth of ETH\n    // Amount of USDC to borrow would be $3 (asset) - $1.65 (ETH borrowed) - $1 (equity) = $0.35\n    // ---------------------------------------------------------------------------------------------\n    // Note that for Neutral strategies, vault's leverage has to be 3x and above.\n    // A 2x leverage neutral strategy may not work to correctly to borrow enough long token to hedge\n    // while still adhering to the correct leverage factor.\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      (uint256 _tokenAWeight, ) = tokenWeights(self);\n\n      uint256 _maxTokenALending = convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenALendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER);\n\n      uint256 _maxTokenBLending = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER)\n        - 1e18;\n\n      _additionalCapacity = _maxTokenALending > _maxTokenBLending ? _maxTokenBLending : _maxTokenALending;\n    }\n\n    return _additionalCapacity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function capacity(GMXTypes.Store storage self) public view returns (uint256) {\n    return additionalCapacity(self) + equityValue(self);\n  }\n}"
    }
  ]
}