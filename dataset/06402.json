{
  "Title": "[G-09] `BasketLib.nextBasket()` caching",
  "Content": "On top of the above refactoring:\n* `config.erc20s[i]` is being read a few times [here](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/mixins/BasketLib.sol#L193-L224)\n* `config.erc20s.length` and `backup.erc20s.length` can be cached\n* `targetNames.at(i)` is  being read twice in the second loop (3 before the proposed refactoring)\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-reserve",
  "Code": [
    {
      "filename": "contracts/p1/mixins/BasketLib.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../interfaces/IAssetRegistry.sol\";\nimport \"../../libraries/Fixed.sol\";\n\n// A \"valid collateral array\" is a IERC20[] array without rtoken/rsr/stRSR/zero address/duplicates\n\n// A BackupConfig value is valid if erc20s is a valid collateral array\nstruct BackupConfig {\n    uint256 max; // Maximum number of backup collateral erc20s to use in a basket\n    IERC20[] erc20s; // Ordered list of backup collateral ERC20s\n}\n\n// What does a BasketConfig value mean?\n//\n// erc20s, targetAmts, and targetNames should be interpreted together.\n// targetAmts[erc20] is the quantity of target units of erc20 that one BU should hold\n// targetNames[erc20] is the name of erc20's target unit\n// and then backups[tgt] is the BackupConfig to use for the target unit named tgt\n//\n// For any valid BasketConfig value:\n//     erc20s == keys(targetAmts) == keys(targetNames)\n//     if name is in values(targetNames), then backups[name] is a valid BackupConfig\n//     erc20s is a valid collateral array\n//\n// In the meantime, treat erc20s as the canonical set of keys for the target* maps\nstruct BasketConfig {\n    // The collateral erc20s in the prime (explicitly governance-set) basket\n    IERC20[] erc20s;\n    // Amount of target units per basket for each prime collateral token. {target/BU}\n    mapping(IERC20 => uint192) targetAmts;\n    // Cached view of the target unit for each erc20 upon setup\n    mapping(IERC20 => bytes32) targetNames;\n    // Backup configurations, per target name.\n    mapping(bytes32 => BackupConfig) backups;\n}\n\n/// The type of BasketHandler.basket.\n/// Defines a basket unit (BU) in terms of reference amounts of underlying tokens\n// Logically, basket is just a mapping of erc20 addresses to ref-unit amounts.\n//\n// A Basket is valid if erc20s is a valid collateral array and erc20s == keys(refAmts)\nstruct Basket {\n    IERC20[] erc20s; // enumerated keys for refAmts\n    mapping(IERC20 => uint192) refAmts; // {ref/BU}\n}\n\n/**\n * @title BasketLibP1\n * @notice A helper library that implements a `nextBasket()` function for selecting a reference\n *   basket from the current basket config in combination with collateral statuses/exchange rates.\n */\nlibrary BasketLibP1 {\n    using BasketLibP1 for Basket;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using FixLib for uint192;\n\n    // === Basket Algebra ===\n\n    /// Set self to a fresh, empty basket\n    // self'.erc20s = [] (empty list)\n    // self'.refAmts = {} (empty map)\n    function empty(Basket storage self) internal {\n        uint256 length = self.erc20s.length;\n        for (uint256 i = 0; i < length; ++i) self.refAmts[self.erc20s[i]] = FIX_ZERO;\n        delete self.erc20s;\n    }\n\n    /// Set `self` equal to `other`\n    function setFrom(Basket storage self, Basket storage other) internal {\n        empty(self);\n        uint256 length = other.erc20s.length;\n        for (uint256 i = 0; i < length; ++i) {\n            self.erc20s.push(other.erc20s[i]);\n            self.refAmts[other.erc20s[i]] = other.refAmts[other.erc20s[i]];\n        }\n    }\n\n    /// Add `weight` to the refAmount of collateral token `tok` in the basket `self`\n    // self'.refAmts[tok] = self.refAmts[tok] + weight\n    // self'.erc20s is keys(self'.refAmts)\n    function add(\n        Basket storage self,\n        IERC20 tok,\n        uint192 weight\n    ) internal {\n        // untestable:\n        //      Both calls to .add() use a weight that has been CEIL rounded in the\n        //      Fixed library div function, so weight will never be 0 here.\n        //      Additionally, setPrimeBasket() enforces prime-basket tokens must have a weight > 0.\n        if (weight == FIX_ZERO) return;\n        if (self.refAmts[tok].eq(FIX_ZERO)) {\n            self.erc20s.push(tok);\n            self.refAmts[tok] = weight;\n        } else {\n            self.refAmts[tok] = self.refAmts[tok].plus(weight);\n        }\n    }\n\n    // === Basket Selection ===\n\n    /* nextBasket() computes basket' from three inputs:\n       - the basket configuration (config: BasketConfig)\n       - the function (isGood: erc20 -> bool), implemented here by goodCollateral()\n       - the function (targetPerRef: erc20 -> Fix) implemented by the Collateral plugin\n\n       ==== Definitions ====\n\n       We use e:IERC20 to mean any erc20 token address, and tgt:bytes32 to mean any target name\n\n       // targetWeight(b, e) is the target-unit weight of token e in basket b\n       Let targetWeight(b, e) = b.refAmt[e] * targetPerRef(e)\n\n       // backups(tgt) is the list of sound backup tokens we plan to use for target `tgt`.\n       Let backups(tgt) = config.backups[tgt].erc20s\n                          .filter(isGood)\n                          .takeUpTo(config.backups[tgt].max)\n\n       Let primeWt(e) = if e in config.erc20s and isGood(e)\n                        then config.targetAmts[e]\n                        else 0\n       Let backupWt(e) = if e in backups(tgt)\n                         then unsoundPrimeWt(tgt) / len(Backups(tgt))\n                         else 0\n       Let unsoundPrimeWt(tgt) = sum(config.targetAmts[e]\n                                     for e in config.erc20s\n                                     where config.targetNames[e] == tgt and !isGood(e))\n\n       ==== The correctness condition ====\n\n       If unsoundPrimeWt(tgt) > 0 and len(backups(tgt)) == 0 for some tgt, then return false.\n       Else, return true and targetWeight(basket', e) == primeWt(e) + backupWt(e) for all e.\n\n       ==== Higher-level desideratum ====\n\n       The resulting total target weights should equal the configured target weight. Formally:\n\n       let configTargetWeight(tgt) = sum(config.targetAmts[e]\n                                         for e in config.erc20s\n                                         where targetNames[e] == tgt)\n\n       let targetWeightSum(b, tgt) = sum(targetWeight(b, e)\n                                         for e in config.erc20s\n                                         where targetNames[e] == tgt)\n\n       Given all that, if nextBasket() returns true, then for all tgt,\n           targetWeightSum(basket', tgt) == configTargetWeight(tgt)\n    */\n\n    /// Select next reference basket from basket config\n    /// Works in-place on `newBasket`\n    /// @param targetNames Scratch space for computation; initial value unused\n    /// @param newBasket Scratch space for computation; initial value unused\n    /// @param config The current basket configuration\n    /// @return success result; i.e newBasket can be expected to contain a valid reference basket\n    function nextBasket(\n        Basket storage newBasket,\n        EnumerableSet.Bytes32Set storage targetNames,\n        BasketConfig storage config,\n        IAssetRegistry assetRegistry\n    ) external returns (bool) {\n        // targetNames := {}\n        while (targetNames.length() > 0) targetNames.remove(targetNames.at(0));\n\n        // newBasket := {}\n        newBasket.empty();\n\n        // targetNames = set(values(config.targetNames))\n        // (and this stays true; targetNames is not touched again in this function)\n        for (uint256 i = 0; i < config.erc20s.length; ++i) {\n            targetNames.add(config.targetNames[config.erc20s[i]]);\n        }\n        uint256 targetsLength = targetNames.length();\n\n        // \"good\" collateral is collateral with any status() other than DISABLED\n        // goodWeights and totalWeights are in index-correspondence with targetNames\n        // As such, they're each interepreted as a map from target name -> target weight\n\n        // {target/BU} total target weight of good, prime collateral with target i\n        // goodWeights := {}\n        uint192[] memory goodWeights = new uint192[](targetsLength);\n\n        // {target/BU} total target weight of all prime collateral with target i\n        // totalWeights := {}\n        uint192[] memory totalWeights = new uint192[](targetsLength);\n\n        // For each prime collateral token:\n        for (uint256 i = 0; i < config.erc20s.length; ++i) {\n            // Find collateral's targetName index\n            uint256 targetIndex;\n            for (targetIndex = 0; targetIndex < targetsLength; ++targetIndex) {\n                if (targetNames.at(targetIndex) == config.targetNames[config.erc20s[i]]) break;\n            }\n            assert(targetIndex < targetsLength);\n            // now, targetNames[targetIndex] == config.targetNames[erc20]\n\n            // Set basket weights for good, prime collateral,\n            // and accumulate the values of goodWeights and targetWeights\n            uint192 targetWeight = config.targetAmts[config.erc20s[i]];\n            totalWeights[targetIndex] = totalWeights[targetIndex].plus(targetWeight);\n\n            if (\n                goodCollateral(\n                    config.targetNames[config.erc20s[i]],\n                    config.erc20s[i],\n                    assetRegistry\n                ) && targetWeight.gt(FIX_ZERO)\n            ) {\n                goodWeights[targetIndex] = goodWeights[targetIndex].plus(targetWeight);\n                newBasket.add(\n                    config.erc20s[i],\n                    targetWeight.div(\n                        // this div is safe: targetPerRef() > 0: goodCollateral check\n                        assetRegistry.toColl(config.erc20s[i]).targetPerRef(),\n                        CEIL\n                    )\n                );\n            }\n        }\n\n        // Analysis: at this point:\n        // for all tgt in target names,\n        //   totalWeights(tgt)\n        //   = sum(config.targetAmts[e] for e in config.erc20s where targetNames[e] == tgt), and\n        //   goodWeights(tgt)\n        //   = sum(primeWt(e) for e in config.erc20s where targetNames[e] == tgt)\n        // for all e in config.erc20s,\n        //   targetWeight(newBasket, e)\n        //   = sum(primeWt(e) if goodCollateral(e), else 0)\n\n        // For each tgt in target names, if we still need more weight for tgt then try to add the\n        // backup basket for tgt to make up that weight:\n        for (uint256 i = 0; i < targetsLength; ++i) {\n            if (totalWeights[i].lte(goodWeights[i])) continue; // Don't need any backup weight\n\n            // \"tgt\" = targetNames[i]\n            // Now, unsoundPrimeWt(tgt) > 0\n\n            uint256 size = 0; // backup basket size\n            BackupConfig storage backup = config.backups[targetNames.at(i)];\n\n            // Find the backup basket size: min(backup.max, # of good backup collateral)\n            for (uint256 j = 0; j < backup.erc20s.length && size < backup.max; ++j) {\n                if (goodCollateral(targetNames.at(i), backup.erc20s[j], assetRegistry)) size++;\n            }\n\n            // Now, size = len(backups(tgt)). If empty, fail.\n            if (size == 0) return false;\n\n            // Set backup basket weights...\n            uint256 assigned = 0;\n\n            // Loop: for erc20 in backups(tgt)...\n            for (uint256 j = 0; j < backup.erc20s.length && assigned < size; ++j) {\n                if (goodCollateral(targetNames.at(i), backup.erc20s[j], assetRegistry)) {\n                    // Across this .add(), targetWeight(newBasket',erc20)\n                    // = targetWeight(newBasket,erc20) + unsoundPrimeWt(tgt) / len(backups(tgt))\n                    newBasket.add(\n                        backup.erc20s[j],\n                        totalWeights[i].minus(goodWeights[i]).div(\n                            // this div is safe: targetPerRef > 0: goodCollateral check\n                            assetRegistry.toColl(backup.erc20s[j]).targetPerRef().mulu(size),\n                            CEIL\n                        )\n                    );\n                    assigned++;\n                }\n            }\n            // Here, targetWeight(newBasket, e) = primeWt(e) + backupWt(e) for all e targeting tgt\n        }\n        // Now we've looped through all values of tgt, so for all e,\n        //   targetWeight(newBasket, e) = primeWt(e) + backupWt(e)\n\n        return newBasket.erc20s.length > 0;\n    }\n\n    // === Private ===\n\n    /// Good collateral is registered, collateral, SOUND, has the expected targetName,\n    /// has nonzero targetPerRef() and refPerTok(), and is not a system token or 0 addr\n    function goodCollateral(\n        bytes32 targetName,\n        IERC20 erc20,\n        IAssetRegistry assetRegistry\n    ) private view returns (bool) {\n        // untestable:\n        //      ERC20 is not address(0), validated when setting prime/backup baskets\n        if (address(erc20) == address(0)) return false;\n        // P1 gas optimization\n        // We do not need to check that the ERC20 is not a system token\n        // BasketHandlerP1.requireValidCollArray() has been run on all ERC20s already\n\n        try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n            return\n                targetName == coll.targetName() &&\n                coll.status() == CollateralStatus.SOUND &&\n                coll.refPerTok() > 0 &&\n                coll.targetPerRef() > 0;\n        } catch {\n            return false;\n        }\n    }\n}"
    }
  ]
}