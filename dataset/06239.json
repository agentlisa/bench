{
  "Title": "[H-30] `utilization` for `_getInterestRate()` does not factor in interest",
  "Content": "\nThe calculation for `utilization` in `_getInterestRate()` does not factor in the accrued interest. This leads to `_accrueInfo.interestPerSecond` being under-represented, and leading to incorrect interest rate calculation and potentially endangering conditions such as `utilization > maximumTargetUtilization` on line [124](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLCommon.sol#L124).\n\n### Proof of Concept\n\nThe calculation for `utilization` in the `_getInterestRate()` function for `SGLCommon.sol` occurs on lines [61-64](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLCommon.sol#L61-L64) as a portion of the `fullAssetAmount` (which is also problematic) and the `_totalBorrow.elastic`. However, `_totalBorrow.elastic` is accrued by interest on line [99](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLCommon.sol#L99). This accrued amount is not factored into the calculation for `utilization`, which will be used to update the new interest rate, as purposed by the comment on line [111](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLCommon.sol#L111).\n\n### Recommended Mitigation Steps\n\nFactor in the interest accrual into the `utilization` calculation:\n\n    ...\n            // Accrue interest\n            extraAmount =\n                (uint256(_totalBorrow.elastic) *\n                    _accrueInfo.interestPerSecond *\n                    elapsedTime) /\n                1e18;\n            _totalBorrow.elastic += uint128(extraAmount);\n            \n        +    uint256 fullAssetAmount = yieldBox.toAmount(    \n        +        assetId,\n        +        _totalAsset.elastic,\n        +        false\n        +    ) + _totalBorrow.elastic;\n            //@audit utilization factors in accrual\n        +    utilization = fullAssetAmount == 0\n        +   ? 0\n        +        : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) /\n        +        fullAssetAmount;\n    ...\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1057#issuecomment-1701770815)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/singularity/SGLCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./SGLStorage.sol\";\n\n/// @title Singularity Common\n/// @notice Singularity market common module\n/// @dev this module is implemented by all the others\ncontract SGLCommon is SGLStorage {\n    using RebaseLibrary for Rebase;\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() public {\n        _accrue();\n    }\n\n    function getInterestDetails()\n        external\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            uint256 utilization\n        )\n    {\n        (_accrueInfo, , , , , utilization, ) = _getInterestRate();\n    }\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getInterestRate()\n        internal\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        )\n    {\n        _accrueInfo = accrueInfo;\n        _totalBorrow = totalBorrow;\n        _totalAsset = totalAsset;\n        extraAmount = 0;\n        feeFraction = 0;\n        logStartingInterest = false;\n\n        uint256 fullAssetAmount = yieldBox.toAmount(\n            assetId,\n            _totalAsset.elastic,\n            false\n        ) + _totalBorrow.elastic;\n\n        utilization = fullAssetAmount == 0\n            ? 0\n            : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) /\n                fullAssetAmount;\n\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return (\n                _accrueInfo,\n                totalBorrow,\n                totalAsset,\n                0,\n                0,\n                utilization,\n                logStartingInterest\n            );\n        }\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\n\n        if (_totalBorrow.base == 0) {\n            // If there are no borrows, reset the interest rate\n            if (_accrueInfo.interestPerSecond != startingInterestPerSecond) {\n                _accrueInfo.interestPerSecond = startingInterestPerSecond;\n                logStartingInterest = true;\n            }\n            return (\n                _accrueInfo,\n                _totalBorrow,\n                totalAsset,\n                0,\n                0,\n                utilization,\n                logStartingInterest\n            );\n        }\n\n        // Accrue interest\n        extraAmount =\n            (uint256(_totalBorrow.elastic) *\n                _accrueInfo.interestPerSecond *\n                elapsedTime) /\n            1e18;\n        _totalBorrow.elastic += uint128(extraAmount);\n\n        uint256 feeAmount = (extraAmount * protocolFee) / FEE_PRECISION; // % of interest paid goes to fee\n        feeFraction = (feeAmount * _totalAsset.base) / fullAssetAmount;\n        _accrueInfo.feesEarnedFraction += uint128(feeFraction);\n        _totalAsset.base = _totalAsset.base + uint128(feeFraction);\n\n        // Update interest rate\n        if (utilization < minimumTargetUtilization) {\n            uint256 underFactor = ((minimumTargetUtilization - utilization) *\n                FACTOR_PRECISION) / minimumTargetUtilization;\n            uint256 scale = interestElasticity +\n                (underFactor * underFactor * elapsedTime);\n            _accrueInfo.interestPerSecond = uint64(\n                (uint256(_accrueInfo.interestPerSecond) * interestElasticity) /\n                    scale\n            );\n            if (_accrueInfo.interestPerSecond < minimumInterestPerSecond) {\n                _accrueInfo.interestPerSecond = minimumInterestPerSecond; // 0.25% APR minimum\n            }\n        } else if (utilization > maximumTargetUtilization) {\n            uint256 overFactor = ((utilization - maximumTargetUtilization) *\n                FACTOR_PRECISION) / fullUtilizationMinusMax;\n            uint256 scale = interestElasticity +\n                (overFactor * overFactor * elapsedTime);\n            uint256 newInterestPerSecond = (uint256(\n                _accrueInfo.interestPerSecond\n            ) * scale) / interestElasticity;\n            if (newInterestPerSecond > maximumInterestPerSecond) {\n                newInterestPerSecond = maximumInterestPerSecond; // 1000% APR maximum\n            }\n            _accrueInfo.interestPerSecond = uint64(newInterestPerSecond);\n        }\n    }\n\n    function _accrue() internal override {\n        (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        ) = _getInterestRate();\n\n        if (logStartingInterest) {\n            emit LogAccrue(0, 0, startingInterestPerSecond, 0);\n        } else {\n            emit LogAccrue(\n                extraAmount,\n                feeFraction,\n                _accrueInfo.interestPerSecond,\n                utilization\n            );\n        }\n        accrueInfo = _accrueInfo;\n        totalBorrow = _totalBorrow;\n        totalAsset = _totalAsset;\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param to The user that receives the tokens.\n    /// @param _assetId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(\n        address from,\n        address to,\n        uint256 _assetId,\n        uint256 share,\n        uint256 total,\n        bool skim\n    ) internal {\n        bytes32 _asset_sig = _assetId == assetId ? ASSET_SIG : COLLATERAL_SIG;\n\n        _yieldBoxShares[to][_asset_sig] += share;\n\n        if (skim) {\n            require(\n                share <= yieldBox.balanceOf(address(this), _assetId) - total,\n                \"SGL: too much\"\n            );\n        } else {\n            yieldBox.transfer(from, address(this), _assetId, share);\n        }\n    }\n\n    /// @dev Concrete implementation of `addAsset`.\n    function _addAsset(\n        address from,\n        address to,\n        bool skim,\n        uint256 share\n    ) internal returns (uint256 fraction) {\n        Rebase memory _totalAsset = totalAsset;\n        uint256 totalAssetShare = _totalAsset.elastic;\n        uint256 allShare = _totalAsset.elastic +\n            yieldBox.toShare(assetId, totalBorrow.elastic, true);\n        fraction = allShare == 0\n            ? share\n            : (share * _totalAsset.base) / allShare;\n        if (_totalAsset.base + uint128(fraction) < 1000) {\n            return 0;\n        }\n        totalAsset = _totalAsset.add(share, fraction);\n        balanceOf[to] += fraction;\n        emit Transfer(address(0), to, fraction);\n\n        _addTokens(from, to, assetId, share, totalAssetShare, skim);\n        emit LogAddAsset(skim ? address(yieldBox) : from, to, share, fraction);\n    }\n\n    /// @dev Concrete implementation of `removeAsset`.\n    /// @param from The account to remove from. Should always be msg.sender except for `depositFeesToyieldBox()`.\n    function _removeAsset(\n        address from,\n        address to,\n        uint256 fraction,\n        bool updateYieldBoxShares\n    ) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic +\n            yieldBox.toShare(assetId, totalBorrow.elastic, true);\n        share = (fraction * allShare) / _totalAsset.base;\n        balanceOf[from] -= fraction;\n        emit Transfer(from, address(0), fraction);\n        _totalAsset.elastic -= uint128(share);\n        _totalAsset.base -= uint128(fraction);\n        require(_totalAsset.base >= 1000, \"SGL: min limit\");\n        totalAsset = _totalAsset;\n        emit LogRemoveAsset(from, to, share, fraction);\n        yieldBox.transfer(address(this), to, assetId, share);\n        if (updateYieldBoxShares) {\n            if (share > _yieldBoxShares[from][ASSET_SIG]) {\n                _yieldBoxShares[from][ASSET_SIG] = 0; //some assets accrue in time\n            } else {\n                _yieldBoxShares[from][ASSET_SIG] -= share;\n            }\n        }\n    }\n\n    /// @dev Return the equivalent of collateral borrow part in asset amount.\n    function _getAmountForBorrowPart(\n        uint256 borrowPart\n    ) internal view returns (uint256) {\n        return totalBorrow.toElastic(borrowPart, false);\n    }\n}"
    },
    {
      "filename": "contracts/markets/singularity/SGLCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./SGLStorage.sol\";\n\n/// @title Singularity Common\n/// @notice Singularity market common module\n/// @dev this module is implemented by all the others\ncontract SGLCommon is SGLStorage {\n    using RebaseLibrary for Rebase;\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() public {\n        _accrue();\n    }\n\n    function getInterestDetails()\n        external\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            uint256 utilization\n        )\n    {\n        (_accrueInfo, , , , , utilization, ) = _getInterestRate();\n    }\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getInterestRate()\n        internal\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        )\n    {\n        _accrueInfo = accrueInfo;\n        _totalBorrow = totalBorrow;\n        _totalAsset = totalAsset;\n        extraAmount = 0;\n        feeFraction = 0;\n        logStartingInterest = false;\n\n        uint256 fullAssetAmount = yieldBox.toAmount(\n            assetId,\n            _totalAsset.elastic,\n            false\n        ) + _totalBorrow.elastic;\n\n        utilization = fullAssetAmount == 0\n            ? 0\n            : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) /\n                fullAssetAmount;\n\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return (\n                _accrueInfo,\n                totalBorrow,\n                totalAsset,\n                0,\n                0,\n                utilization,\n                logStartingInterest\n            );\n        }\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\n\n        if (_totalBorrow.base == 0) {\n            // If there are no borrows, reset the interest rate\n            if (_accrueInfo.interestPerSecond != startingInterestPerSecond) {\n                _accrueInfo.interestPerSecond = startingInterestPerSecond;\n                logStartingInterest = true;\n            }\n            return (\n                _accrueInfo,\n                _totalBorrow,\n                totalAsset,\n                0,\n                0,\n                utilization,\n                logStartingInterest\n            );\n        }\n\n        // Accrue interest\n        extraAmount =\n            (uint256(_totalBorrow.elastic) *\n                _accrueInfo.interestPerSecond *\n                elapsedTime) /\n            1e18;\n        _totalBorrow.elastic += uint128(extraAmount);\n\n        uint256 feeAmount = (extraAmount * protocolFee) / FEE_PRECISION; // % of interest paid goes to fee\n        feeFraction = (feeAmount * _totalAsset.base) / fullAssetAmount;\n        _accrueInfo.feesEarnedFraction += uint128(feeFraction);\n        _totalAsset.base = _totalAsset.base + uint128(feeFraction);\n\n        // Update interest rate\n        if (utilization < minimumTargetUtilization) {\n            uint256 underFactor = ((minimumTargetUtilization - utilization) *\n                FACTOR_PRECISION) / minimumTargetUtilization;\n            uint256 scale = interestElasticity +\n                (underFactor * underFactor * elapsedTime);\n            _accrueInfo.interestPerSecond = uint64(\n                (uint256(_accrueInfo.interestPerSecond) * interestElasticity) /\n                    scale\n            );\n            if (_accrueInfo.interestPerSecond < minimumInterestPerSecond) {\n                _accrueInfo.interestPerSecond = minimumInterestPerSecond; // 0.25% APR minimum\n            }\n        } else if (utilization > maximumTargetUtilization) {\n            uint256 overFactor = ((utilization - maximumTargetUtilization) *\n                FACTOR_PRECISION) / fullUtilizationMinusMax;\n            uint256 scale = interestElasticity +\n                (overFactor * overFactor * elapsedTime);\n            uint256 newInterestPerSecond = (uint256(\n                _accrueInfo.interestPerSecond\n            ) * scale) / interestElasticity;\n            if (newInterestPerSecond > maximumInterestPerSecond) {\n                newInterestPerSecond = maximumInterestPerSecond; // 1000% APR maximum\n            }\n            _accrueInfo.interestPerSecond = uint64(newInterestPerSecond);\n        }\n    }\n\n    function _accrue() internal override {\n        (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        ) = _getInterestRate();\n\n        if (logStartingInterest) {\n            emit LogAccrue(0, 0, startingInterestPerSecond, 0);\n        } else {\n            emit LogAccrue(\n                extraAmount,\n                feeFraction,\n                _accrueInfo.interestPerSecond,\n                utilization\n            );\n        }\n        accrueInfo = _accrueInfo;\n        totalBorrow = _totalBorrow;\n        totalAsset = _totalAsset;\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param to The user that receives the tokens.\n    /// @param _assetId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(\n        address from,\n        address to,\n        uint256 _assetId,\n        uint256 share,\n        uint256 total,\n        bool skim\n    ) internal {\n        bytes32 _asset_sig = _assetId == assetId ? ASSET_SIG : COLLATERAL_SIG;\n\n        _yieldBoxShares[to][_asset_sig] += share;\n\n        if (skim) {\n            require(\n                share <= yieldBox.balanceOf(address(this), _assetId) - total,\n                \"SGL: too much\"\n            );\n        } else {\n            yieldBox.transfer(from, address(this), _assetId, share);\n        }\n    }\n\n    /// @dev Concrete implementation of `addAsset`.\n    function _addAsset(\n        address from,\n        address to,\n        bool skim,\n        uint256 share\n    ) internal returns (uint256 fraction) {\n        Rebase memory _totalAsset = totalAsset;\n        uint256 totalAssetShare = _totalAsset.elastic;\n        uint256 allShare = _totalAsset.elastic +\n            yieldBox.toShare(assetId, totalBorrow.elastic, true);\n        fraction = allShare == 0\n            ? share\n            : (share * _totalAsset.base) / allShare;\n        if (_totalAsset.base + uint128(fraction) < 1000) {\n            return 0;\n        }\n        totalAsset = _totalAsset.add(share, fraction);\n        balanceOf[to] += fraction;\n        emit Transfer(address(0), to, fraction);\n\n        _addTokens(from, to, assetId, share, totalAssetShare, skim);\n        emit LogAddAsset(skim ? address(yieldBox) : from, to, share, fraction);\n    }\n\n    /// @dev Concrete implementation of `removeAsset`.\n    /// @param from The account to remove from. Should always be msg.sender except for `depositFeesToyieldBox()`.\n    function _removeAsset(\n        address from,\n        address to,\n        uint256 fraction,\n        bool updateYieldBoxShares\n    ) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic +\n            yieldBox.toShare(assetId, totalBorrow.elastic, true);\n        share = (fraction * allShare) / _totalAsset.base;\n        balanceOf[from] -= fraction;\n        emit Transfer(from, address(0), fraction);\n        _totalAsset.elastic -= uint128(share);\n        _totalAsset.base -= uint128(fraction);\n        require(_totalAsset.base >= 1000, \"SGL: min limit\");\n        totalAsset = _totalAsset;\n        emit LogRemoveAsset(from, to, share, fraction);\n        yieldBox.transfer(address(this), to, assetId, share);\n        if (updateYieldBoxShares) {\n            if (share > _yieldBoxShares[from][ASSET_SIG]) {\n                _yieldBoxShares[from][ASSET_SIG] = 0; //some assets accrue in time\n            } else {\n                _yieldBoxShares[from][ASSET_SIG] -= share;\n            }\n        }\n    }\n\n    /// @dev Return the equivalent of collateral borrow part in asset amount.\n    function _getAmountForBorrowPart(\n        uint256 borrowPart\n    ) internal view returns (uint256) {\n        return totalBorrow.toElastic(borrowPart, false);\n    }\n}"
    }
  ]
}