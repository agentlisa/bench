{
  "Title": "[M-07] Users can fail to withdraw deposited assets from a vault that uses `YearnAdapter` contract as its adapter because `maxLoss` input for calling corresponding Yearn vault's `withdraw` function cannot be specified",
  "Content": "\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/abstracts/AdapterBase.sol#L210-L235> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/yearn/YearnAdapter.sol#L166-L172> \n\n<https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy#L1028-L1167>\n\n### Impact\n\nFor a vault that uses the `YearnAdapter` contract as its adapter, calling the `Vault.withdraw` or `Vault.redeem` function will eventually call the `AdapterBase._withdraw` and `YearnAdapter._protocolWithdraw` functions below when the adapter is not paused. When the `YearnAdapter._protocolWithdraw` function executes `yVault.withdraw(convertToUnderlyingShares(assets, shares))`, the `maxLoss` input is not specified when calling the Yearn vault's `withdraw` function below. Thus, the Yearn vault's `withdraw` function will be called with its default `maxLoss` input value that is 0.01%. If the total loss incurred during the withdrawal is more than 0.01%, calling the Yearn vault's `withdraw` function that executes `assert totalLoss <= maxLoss * (value + totalLoss) / MAX_BPS` will revert. In a bear market, it is possible that the Yearn vault's strategies do not perform well so the total loss can be more than 0.01% permanently. In this situation, calling the `Vault.withdraw` or `Vault.redeem` function will always revert because calling the Yearn vault's `withdraw` function without specifying the `maxLoss` input reverts. As a result, users lose the deposited assets that they are unable to withdraw.\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/abstracts/AdapterBase.sol#L210-L235>\n\n```solidity\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        ...\n\n        if (!paused()) {\n            uint256 underlyingBalance_ = _underlyingBalance();  \n            _protocolWithdraw(assets, shares);\n            // Update the underlying balance to prevent inflation attacks\n            underlyingBalance -= underlyingBalance_ - _underlyingBalance();\n        }\n\n        ...\n    }\n```\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/yearn/YearnAdapter.sol#L166-L172>\n\n```solidity\n    function _protocolWithdraw(uint256 assets, uint256 shares)\n        internal\n        virtual\n        override\n    {\n        yVault.withdraw(convertToUnderlyingShares(assets, shares));\n    }\n```\n\n<https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy#L1028-L1167>\n\n```vyper\n@external\n@nonreentrant(\"withdraw\")\ndef withdraw(\n    maxShares: uint256 = MAX_UINT256,\n    recipient: address = msg.sender,\n    maxLoss: uint256 = 1,  # 0.01% [BPS]\n) -> uint256:\n    \"\"\"\n    ...\n    @param maxLoss\n        The maximum acceptable loss to sustain on withdrawal. Defaults to 0.01%.\n        If a loss is specified, up to that amount of shares may be burnt to cover losses on withdrawal.\n    @return The quantity of tokens redeemed for `_shares`.\n    \"\"\"\n    shares: uint256 = maxShares  # May reduce this number below\n\n    # Max Loss is <=100%, revert otherwise\n    assert maxLoss <= MAX_BPS\n\n    # If _shares not specified, transfer full share balance\n    if shares == MAX_UINT256:\n        shares = self.balanceOf[msg.sender]\n\n    # Limit to only the shares they own\n    assert shares <= self.balanceOf[msg.sender]\n\n    # Ensure we are withdrawing something\n    assert shares > 0\n\n    # See @dev note, above.\n    value: uint256 = self._shareValue(shares)\n    vault_balance: uint256 = self.totalIdle\n\n    if value > vault_balance:\n        totalLoss: uint256 = 0\n        # We need to go get some from our strategies in the withdrawal queue\n        # NOTE: This performs forced withdrawals from each Strategy. During\n        #       forced withdrawal, a Strategy may realize a loss. That loss\n        #       is reported back to the Vault, and the will affect the amount\n        #       of tokens that the withdrawer receives for their shares. They\n        #       can optionally specify the maximum acceptable loss (in BPS)\n        #       to prevent excessive losses on their withdrawals (which may\n        #       happen in certain edge cases where Strategies realize a loss)\n        for strategy in self.withdrawalQueue:\n            if strategy == ZERO_ADDRESS:\n                break  # We've exhausted the queue\n\n            if value <= vault_balance:\n                break  # We're done withdrawing\n\n            amountNeeded: uint256 = value - vault_balance\n\n            # NOTE: Don't withdraw more than the debt so that Strategy can still\n            #       continue to work based on the profits it has\n            # NOTE: This means that user will lose out on any profits that each\n            #       Strategy in the queue would return on next harvest, benefiting others\n            amountNeeded = min(amountNeeded, self.strategies[strategy].totalDebt)\n            if amountNeeded == 0:\n                continue  # Nothing to withdraw from this Strategy, try the next one\n\n            # Force withdraw amount from each Strategy in the order set by governance\n            preBalance: uint256 = self.token.balanceOf(self)\n            loss: uint256 = Strategy(strategy).withdraw(amountNeeded)\n            withdrawn: uint256 = self.token.balanceOf(self) - preBalance\n            vault_balance += withdrawn\n\n            # NOTE: Withdrawer incurs any losses from liquidation\n            if loss > 0:\n                value -= loss\n                totalLoss += loss\n                self._reportLoss(strategy, loss)\n\n            # Reduce the Strategy's debt by the amount withdrawn (\"realized returns\")\n            # NOTE: This doesn't add to returns as it's not earned by \"normal means\"\n            self.strategies[strategy].totalDebt -= withdrawn\n            self.totalDebt -= withdrawn\n            log WithdrawFromStrategy(strategy, self.strategies[strategy].totalDebt, loss)\n\n        self.totalIdle = vault_balance\n        # NOTE: We have withdrawn everything possible out of the withdrawal queue\n        #       but we still don't have enough to fully pay them back, so adjust\n        #       to the total amount we've freed up through forced withdrawals\n        if value > vault_balance:\n            value = vault_balance\n            # NOTE: Burn # of shares that corresponds to what Vault has on-hand,\n            #       including the losses that were incurred above during withdrawals\n            shares = self._sharesForAmount(value + totalLoss)\n\n        # NOTE: This loss protection is put in place to revert if losses from\n        #       withdrawing are more than what is considered acceptable.\n        assert totalLoss <= maxLoss * (value + totalLoss) / MAX_BPS\n\n    # Burn shares (full value of what is being withdrawn)\n    self.totalSupply -= shares\n    self.balanceOf[msg.sender] -= shares\n    log Transfer(msg.sender, ZERO_ADDRESS, shares)\n    \n    self.totalIdle -= value\n    # Withdraw remaining balance to _recipient (may be different to msg.sender) (minus fee)\n    self.erc20_safe_transfer(self.token.address, recipient, value)\n    log Withdraw(recipient, shares, value)\n    \n    return value\n```\n\n### Proof of Concept\n\nThe following steps can occur for the described scenario.\n\n1.  A vault that uses the `YearnAdapter` contract as its adapter exists.\n2.  A user calls the `Vault.deposit` function to deposit some asset tokens in the corresponding Yearn vault.\n3.  A bear market starts so the Yearn vault's strategies do not perform well, and the total loss is more than 0.01% consistently.\n4.  Calling the `Vault.withdraw` or `Vault.redeem` function always reverts because the user cannot specify the `maxLoss` input for calling the Yearn vault's `withdraw` function. As a result, the user loses the deposited asset tokens.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nThe `YearnAdapter._protocolWithdraw` function can be updated to add an additional input that would be used as the `maxLoss` input for calling the Yearn vault's `withdraw` function. The other functions that call the `YearnAdapter._protocolWithdraw` function need to add this input as well.\n\n**[RedVeil (Popcorn) confirmed, but disagreed with severity](https://github.com/code-423n4/2023-01-popcorn-findings/issues/581)** \n\n**[LSDan (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-popcorn-findings/issues/581)** \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/vault/adapter/abstracts/AdapterBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {ERC4626Upgradeable, IERC20Upgradeable as IERC20, IERC20MetadataUpgradeable as IERC20Metadata, ERC20Upgradeable as ERC20} from \"openzeppelin-contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {MathUpgradeable as Math} from \"openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IStrategy} from \"../../../interfaces/vault/IStrategy.sol\";\nimport {IAdapter} from \"../../../interfaces/vault/IAdapter.sol\";\nimport {EIP165} from \"../../../utils/EIP165.sol\";\nimport {OnlyStrategy} from \"./OnlyStrategy.sol\";\nimport {OwnedUpgradeable} from \"../../../utils/OwnedUpgradeable.sol\";\n\n/**\n * @title   AdapterBase\n * @author  RedVeil\n * @notice  See the following for the full EIP-4626 specification https://eips.ethereum.org/EIPS/eip-4626.\n *\n * The ERC4626 compliant base contract for all adapter contracts.\n * It allows interacting with an underlying protocol.\n * All specific interactions for the underlying protocol need to be overriden in the actual implementation.\n * The adapter can be initialized with a strategy that can perform additional operations. (Leverage, Compounding, etc.)\n */\nabstract contract AdapterBase is\n    ERC4626Upgradeable,\n    PausableUpgradeable,\n    OwnedUpgradeable,\n    ReentrancyGuardUpgradeable,\n    EIP165,\n    OnlyStrategy\n{\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint8 internal _decimals;\n\n    error StrategySetupFailed();\n\n    /**\n     * @notice Initialize a new Adapter.\n     * @param popERC4626InitData Encoded data for the base adapter initialization.\n     * @dev `asset` - The underlying asset\n     * @dev `_owner` - Owner of the contract. Controls management functions.\n     * @dev `_strategy` - An optional strategy to enrich the adapter with additional functionality.\n     * @dev `_harvestCooldown` - Cooldown period between harvests.\n     * @dev `_requiredSigs` - Function signatures required by the strategy (EIP-165)\n     * @dev `_strategyConfig` - Additional data which can be used by the strategy on `harvest()`\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev Each Adapter implementation should implement checks to make sure that the adapter is wrapping the underlying protocol correctly.\n     * @dev If a strategy is provided, it will be verified to make sure it implements the required functions.\n     */\n    function __AdapterBase_init(bytes memory popERC4626InitData)\n        internal\n        onlyInitializing\n    {\n        (\n            address asset,\n            address _owner,\n            address _strategy,\n            uint256 _harvestCooldown,\n            bytes4[8] memory _requiredSigs,\n            bytes memory _strategyConfig\n        ) = abi.decode(\n                popERC4626InitData,\n                (address, address, address, uint256, bytes4[8], bytes)\n            );\n        __Owned_init(_owner);\n        __Pausable_init();\n        __ERC4626_init(IERC20Metadata(asset));\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        _decimals = IERC20Metadata(asset).decimals();\n\n        strategy = IStrategy(_strategy);\n        strategyConfig = _strategyConfig;\n        harvestCooldown = _harvestCooldown;\n\n        if (_strategy != address(0)) _verifyAndSetupStrategy(_requiredSigs);\n\n        highWaterMark = 1e18;\n        lastHarvest = block.timestamp;\n    }\n\n    function decimals()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (uint8)\n    {\n        return _decimals;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    error MaxError(uint256 amount);\n    error ZeroAmount();\n\n    /**\n     * @notice Deposits assets into the underlying protocol and mints vault shares to `receiver`.\n     * @param assets Amount of assets to deposit.\n     * @param receiver Receiver of the shares.\n     */\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        if (assets > maxDeposit(receiver)) revert MaxError(assets);\n\n        uint256 shares = _previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /**\n     * @notice Mints vault shares to `receiver` and deposits assets into the underlying protocol.\n     * @param shares Amount of shares to mint.\n     * @param receiver Receiver of the shares.\n     */\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        if (shares > maxMint(receiver)) revert MaxError(shares);\n\n        uint256 assets = _previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @notice Deposit `assets` into the underlying protocol and mints vault shares to `receiver`.\n     * @dev Executes harvest if `harvestCooldown` is passed since last invocation.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal nonReentrant virtual override {\n        IERC20(asset()).safeTransferFrom(caller, address(this), assets);\n        \n        uint256 underlyingBalance_ = _underlyingBalance();\n        _protocolDeposit(assets, shares);\n        // Update the underlying balance to prevent inflation attacks\n        underlyingBalance += _underlyingBalance() - underlyingBalance_;\n\n        _mint(receiver, shares);\n\n        harvest();\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @notice Withdraws `assets` from the underlying protocol and burns vault shares from `owner`.\n     * @param assets Amount of assets to withdraw.\n     * @param receiver Receiver of the assets.\n     * @param owner Owner of the shares.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        if (assets > maxWithdraw(owner)) revert MaxError(assets);\n\n        uint256 shares = _previewWithdraw(assets);\n\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /**\n     * @notice Burns vault shares from `owner` and withdraws `assets` from the underlying protocol.\n     * @param shares Amount of shares to burn.\n     * @param receiver Receiver of the assets.\n     * @param owner Owner of the shares.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        if (shares > maxRedeem(owner)) revert MaxError(shares);\n\n        uint256 assets = _previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @notice Withdraws `assets` from the underlying protocol and burns vault shares from `owner`.\n     * @dev Executes harvest if `harvestCooldown` is passed since last invocation.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        if (!paused()) {\n            uint256 underlyingBalance_ = _underlyingBalance();  \n            _protocolWithdraw(assets, shares);\n            // Update the underlying balance to prevent inflation attacks\n            underlyingBalance -= underlyingBalance_ - _underlyingBalance();\n        }\n\n        _burn(owner, shares);\n\n        IERC20(asset()).safeTransfer(receiver, assets);\n\n        harvest();\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal underlyingBalance;\n\n    /**\n     * @notice Total amount of underlying `asset` token managed by adapter.\n     * @dev Return assets held by adapter if paused.\n     */\n    function totalAssets() public view override returns (uint256) {\n        return\n            paused()\n                ? IERC20(asset()).balanceOf(address(this))\n                : _totalAssets();\n    }\n\n    /**\n     * @notice Total amount of underlying `asset` token managed by adapter through the underlying protocol.\n     * @dev This should utilize `underlyingBalance` to return the currently held assets and prevent inflation attacks.\n     */\n    function _totalAssets() internal view virtual returns (uint256) {}\n\n    /**\n     * @notice Total amount of underlying balance owned by the adapter.\n     * @dev This could be the balance of shares held by the adapter or a similar balance call to prevent inflation attacks.\n     * @dev It should NOT return the actual asset amount.\n     */\n    function _underlyingBalance() internal view virtual returns (uint256) {}\n\n    /**\n     * @notice Convert either `assets` or `shares` into underlying shares\n     * @dev This is an optional function for underlying protocols that require deposit/withdrawal amounts in their shares.\n     */\n    function convertToUnderlyingShares(uint256 assets, uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {}\n\n    /// @notice See _previewDeposit natspec\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _previewDeposit(assets);\n    }\n\n    /**\n     * @notice Simulate the effects of a deposit at the current block, given current on-chain conditions.\n     * @dev Return 0 if paused since no further deposits are allowed.\n     * @dev Override this function if the underlying protocol has a unique deposit logic and/or deposit fees.\n     */\n    function _previewDeposit(uint256 assets)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return paused() ? 0 : _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /// @notice See _previewMint natspec\n    function previewMint(uint256 shares)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _previewMint(shares);\n    }\n\n    /**\n     * @notice Simulate the effects of a mint at the current block, given current on-chain conditions.\n     * @dev Return 0 if paused since no further deposits are allowed.\n     * @dev Override this function if the underlying protocol has a unique deposit logic and/or deposit fees.\n     */\n    function _previewMint(uint256 shares)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return paused() ? 0 : _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /// @notice See _previewWithdraw natspec\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _previewWithdraw(assets);\n    }\n\n    /**\n     * @notice Simulate the effects of a withdraw at the current block, given current on-chain conditions.\n     * @dev Override this function if the underlying protocol has a unique withdrawal logic and/or withdraw fees.\n     */\n    function _previewWithdraw(uint256 assets)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /// @notice See _previewRedeem natspec\n    function previewRedeem(uint256 shares)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _previewRedeem(shares);\n    }\n\n    /**\n     * @notice Simulate the effects of a redeem at the current block, given current on-chain conditions.\n     * @dev Override this function if the underlying protocol has a unique redeem logic and/or redeem fees.\n     */\n    function _previewRedeem(uint256 shares)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /**\n     * @notice Amount of shares the vault would exchange for given amount of assets, in an ideal scenario.\n     * @dev Added totalAssets() check to prevent division by zero in case of rounding issues. (off-by-one issue)\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding)\n        internal\n        view\n        virtual\n        override\n        returns (uint256 shares)\n    {\n        uint256 _totalSupply = totalSupply();\n        uint256 _totalAssets = totalAssets();\n        return\n            (assets == 0 || _totalSupply == 0 || _totalAssets == 0)\n                ? assets\n                : assets.mulDiv(_totalSupply, _totalAssets, rounding);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @return Maximum amount of vault shares that may be minted to given address. Delegates to adapter.\n     * @dev Return 0 if paused since no further deposits are allowed.\n     * @dev Override this function if the underlying protocol has a unique deposit logic and/or deposit fees.\n     */\n    function maxDeposit(address)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return paused() ? 0 : type(uint256).max;\n    }\n\n    /**\n     * @return Maximum amount of vault shares that may be minted to given address. Delegates to adapter.\n     * @dev Return 0 if paused since no further deposits are allowed.\n     * @dev Override this function if the underlying protocol has a unique deposit logic and/or deposit fees.\n     */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return paused() ? 0 : type(uint256).max;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            STRATEGY LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    IStrategy public strategy;\n    bytes public strategyConfig;\n    uint256 public lastHarvest;\n\n    event Harvested();\n\n    /**\n     * @notice Execute Strategy and take fees.\n     * @dev Delegatecall to strategy's harvest() function. All necessary data is passed via `strategyConfig`.\n     * @dev Delegatecall is used to in case any logic requires the adapters address as a msg.sender. (e.g. Synthetix staking)\n     */\n    function harvest() public takeFees {\n        if (\n            address(strategy) != address(0) &&\n            ((lastHarvest + harvestCooldown) < block.timestamp)\n        ) {\n            // solhint-disable\n            address(strategy).delegatecall(\n                abi.encodeWithSignature(\"harvest()\")\n            );\n        }\n\n        emit Harvested();\n    }\n\n    /**\n     * @notice Allows the strategy to deposit assets into the underlying protocol without minting new adapter shares.\n     * @dev This can be used e.g. for a compounding strategy to increase the value of each adapter share.\n     */\n    function strategyDeposit(uint256 amount, uint256 shares)\n        public\n        onlyStrategy\n    {\n        _protocolDeposit(amount, shares);\n    }\n\n    /**\n     * @notice Allows the strategy to withdraw assets from the underlying protocol without burning adapter shares.\n     * @dev This can be used e.g. for a leverage strategy to reduce leverage without the need for the strategy to hold any adapter shares.\n     */\n    function strategyWithdraw(uint256 amount, uint256 shares)\n        public\n        onlyStrategy\n    {\n        _protocolWithdraw(amount, shares);\n    }\n\n    /**\n     * @notice Verifies that the Adapter and Strategy are compatible and sets up the strategy.\n     * @dev This checks EIP165 compatibility and potentially other strategy specific checks (matching assets...).\n     * @dev It aftwards sets up anything required by the strategy to call `harvest()` like approvals etc.\n     */\n    function _verifyAndSetupStrategy(bytes4[8] memory requiredSigs) internal {\n        strategy.verifyAdapterSelectorCompatibility(requiredSigs);\n        strategy.verifyAdapterCompatibility(strategyConfig);\n        strategy.setUp(strategyConfig);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      HARVEST COOLDOWN LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    uint256 public harvestCooldown;\n\n    event HarvestCooldownChanged(uint256 oldCooldown, uint256 newCooldown);\n\n    error InvalidHarvestCooldown(uint256 cooldown);\n\n    /**\n     * @notice Set a new harvestCooldown for this adapter. Caller must be owner.\n     * @param newCooldown Time in seconds that must pass before a harvest can be called again.\n     * @dev Cant be longer than 1 day.\n     */\n    function setHarvestCooldown(uint256 newCooldown) external onlyOwner {\n        // Dont wait more than X seconds\n        if (newCooldown >= 1 days) revert InvalidHarvestCooldown(newCooldown);\n\n        emit HarvestCooldownChanged(harvestCooldown, newCooldown);\n\n        harvestCooldown = newCooldown;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      FEE LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    uint256 public performanceFee;\n    uint256 public highWaterMark;\n\n    // TODO use deterministic fee recipient proxy\n    address FEE_RECIPIENT = address(0x4444);\n\n    event PerformanceFeeChanged(uint256 oldFee, uint256 newFee);\n\n    error InvalidPerformanceFee(uint256 fee);\n\n    /**\n     * @notice Performance fee that has accrued since last fee harvest.\n     * @return Accrued performance fee in underlying `asset` token.\n     * @dev Performance fee is based on a high water mark value. If vault share value has increased above the\n     *   HWM in a fee period, issue fee shares to the vault equal to the performance fee.\n     */\n    function accruedPerformanceFee() public view returns (uint256) {\n        uint256 highWaterMark_ = highWaterMark;\n        uint256 shareValue = convertToAssets(1e18);\n        uint256 performanceFee_ = performanceFee;\n\n        return\n            performanceFee_ > 0 && shareValue > highWaterMark_\n                ? performanceFee_.mulDiv(\n                    (shareValue - highWaterMark_) * totalSupply(),\n                    1e36,\n                    Math.Rounding.Down\n                )\n                : 0;\n    }\n\n    /**\n     * @notice Set a new performance fee for this adapter. Caller must be owner.\n     * @param newFee performance fee in 1e18.\n     * @dev Fees can be 0 but never more than 2e17 (1e18 = 100%, 1e14 = 1 BPS)\n     */\n    function setPerformanceFee(uint256 newFee) public onlyOwner {\n        // Dont take more than 20% performanceFee\n        if (newFee > 2e17) revert InvalidPerformanceFee(newFee);\n\n        emit PerformanceFeeChanged(performanceFee, newFee);\n\n        performanceFee = newFee;\n    }\n\n    /// @notice Collect performance fees and update asset checkpoint.\n    modifier takeFees() {\n        _;\n\n        uint256 fee = accruedPerformanceFee();\n        if (fee > 0) _mint(FEE_RECIPIENT, convertToShares(fee));\n\n        uint256 shareValue = convertToAssets(1e18);\n        if (shareValue > highWaterMark) highWaterMark = shareValue;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      PAUSING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pause Deposits and withdraw all funds from the underlying protocol. Caller must be owner.\n    function pause() external onlyOwner {\n        _protocolWithdraw(totalAssets(), totalSupply());\n        // Update the underlying balance to prevent inflation attacks\n        underlyingBalance = 0;\n        _pause();\n    }\n\n    /// @notice Unpause Deposits and deposit all funds into the underlying protocol. Caller must be owner.\n    function unpause() external onlyOwner {\n        _protocolDeposit(totalAssets(), totalSupply());\n        // Update the underlying balance to prevent inflation attacks\n        underlyingBalance = _underlyingBalance();\n        _unpause();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice deposit into the underlying protocol.\n    function _protocolDeposit(uint256 assets, uint256 shares) internal virtual {\n        // OPTIONAL - convertIntoUnderlyingShares(assets,shares)\n    }\n\n    /// @notice Withdraw from the underlying protocol.\n    function _protocolWithdraw(uint256 assets, uint256 shares)\n        internal\n        virtual\n    {\n        // OPTIONAL - convertIntoUnderlyingShares(assets,shares)\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      EIP-165 LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IAdapter).interfaceId;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      EIP-2612 LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    //  EIP-2612 STORAGE\n    uint256 internal INITIAL_CHAIN_ID;\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n\n    error PermitDeadlineExpired(uint256 deadline);\n    error InvalidSigner(address signer);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (deadline < block.timestamp) revert PermitDeadlineExpired(deadline);\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            if (recoveredAddress == address(0) || recoveredAddress != owner)\n                revert InvalidSigner(recoveredAddress);\n\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return\n            block.chainid == INITIAL_CHAIN_ID\n                ? INITIAL_DOMAIN_SEPARATOR\n                : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name())),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n}"
    },
    {
      "filename": "src/vault/adapter/yearn/YearnAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {AdapterBase, ERC4626Upgradeable as ERC4626, IERC20, IERC20Metadata, ERC20, SafeERC20, Math, IStrategy, IAdapter} from \"../abstracts/AdapterBase.sol\";\nimport {VaultAPI, IYearnRegistry} from \"./IYearn.sol\";\n\n/**\n * @title   Yearn Adapter\n * @author  RedVeil\n * @notice  ERC4626 wrapper for Yearn Vaults.\n *\n * An ERC4626 compliant Wrapper for https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy.\n * Allows wrapping Yearn Vaults.\n */\ncontract YearnAdapter is AdapterBase {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    string internal _name;\n    string internal _symbol;\n\n    VaultAPI public yVault;\n    uint256 constant DEGRADATION_COEFFICIENT = 10**18;\n\n    /**\n     * @notice Initialize a new Yearn Adapter.\n     * @param adapterInitData Encoded data for the base adapter initialization.\n     * @param externalRegistry Yearn registry address.\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev The yearn registry will be used given the `asset` from `adapterInitData` to find the latest yVault.\n     */\n    function initialize(\n        bytes memory adapterInitData,\n        address externalRegistry,\n        bytes memory\n    ) external initializer {\n        (address _asset, , , , , ) = abi.decode(\n            adapterInitData,\n            (address, address, address, uint256, bytes4[8], bytes)\n        );\n        __AdapterBase_init(adapterInitData);\n\n        yVault = VaultAPI(IYearnRegistry(externalRegistry).latestVault(_asset));\n\n        _name = string.concat(\n            \"Popcorn Yearn\",\n            IERC20Metadata(asset()).name(),\n            \" Adapter\"\n        );\n        _symbol = string.concat(\"popY-\", IERC20Metadata(asset()).symbol());\n\n        IERC20(_asset).approve(address(yVault), type(uint256).max);\n    }\n\n    function name()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ACCOUNTING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emulate yearns total asset calculation to return the total assets of the vault.\n    function _totalAssets() internal view override returns (uint256) {\n        return _shareValue(underlyingBalance);\n    }\n\n    function _underlyingBalance() internal view override returns (uint256) {\n        return yVault.balanceOf(address(this));\n    }\n\n    /// @notice Determines the current value of `yShares` in assets\n    function _shareValue(uint256 yShares) internal view returns (uint256) {\n        if (yVault.totalSupply() == 0) return yShares;\n\n        return\n            yShares.mulDiv(\n                _freeFunds(),\n                yVault.totalSupply(),\n                Math.Rounding.Down\n            );\n    }\n\n    /// @notice The amount of assets that are free to be withdrawn from the yVault after locked profts.\n    function _freeFunds() internal view returns (uint256) {\n        return _yTotalAssets() - _calculateLockedProfit();\n    }\n\n    /**\n     * @notice Returns the total quantity of all assets under control of this Vault,\n     * whether they're loaned out to a Strategy, or currently held in the Vault.\n     */\n    function _yTotalAssets() internal view returns (uint256) {\n        return IERC20(asset()).balanceOf(address(yVault)) + yVault.totalDebt();\n    }\n\n    /// @notice Calculates how much profit is locked and cant be withdrawn.\n    function _calculateLockedProfit() internal view returns (uint256) {\n        uint256 lockedFundsRatio = (block.timestamp - yVault.lastReport()) *\n            yVault.lockedProfitDegradation();\n\n        if (lockedFundsRatio < DEGRADATION_COEFFICIENT) {\n            uint256 lockedProfit = yVault.lockedProfit();\n            return\n                lockedProfit -\n                ((lockedFundsRatio * lockedProfit) / DEGRADATION_COEFFICIENT);\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice The amount of yearn shares to withdraw given an amount of adapter shares\n    function convertToUnderlyingShares(uint256, uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            shares.mulDiv(underlyingBalance, totalSupply(), Math.Rounding.Up);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    DEPOSIT/WITHDRAWAL LIMIT LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Applies the yVault deposit limit to the adapter.\n    function maxDeposit(address) public view override returns (uint256) {\n        if (paused()) return 0;\n\n        VaultAPI _bestVault = yVault;\n        uint256 assets = _bestVault.totalAssets();\n        uint256 _depositLimit = _bestVault.depositLimit();\n        if (assets >= _depositLimit) return 0;\n        return _depositLimit - assets;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _protocolDeposit(uint256 amount, uint256)\n        internal\n        virtual\n        override\n    {\n        yVault.deposit(amount);\n    }\n\n    function _protocolWithdraw(uint256 assets, uint256 shares)\n        internal\n        virtual\n        override\n    {\n        yVault.withdraw(convertToUnderlyingShares(assets, shares));\n    }\n}"
    },
    {
      "filename": "contracts/Vault.vy",
      "content": "# @version 0.3.3\n\"\"\"\n@title Yearn Token Vault\n@license GNU AGPLv3\n@author yearn.finance\n@notice\n    Yearn Token Vault. Holds an underlying token, and allows users to interact\n    with the Yearn ecosystem through Strategies connected to the Vault.\n    Vaults are not limited to a single Strategy, they can have as many Strategies\n    as can be designed (however the withdrawal queue is capped at 20.)\n\n    Deposited funds are moved into the most impactful strategy that has not\n    already reached its limit for assets under management, regardless of which\n    Strategy a user's funds end up in, they receive their portion of yields\n    generated across all Strategies.\n\n    When a user withdraws, if there are no funds sitting undeployed in the\n    Vault, the Vault withdraws funds from Strategies in the order of least\n    impact. (Funds are taken from the Strategy that will disturb everyone's\n    gains the least, then the next least, etc.) In order to achieve this, the\n    withdrawal queue's order must be properly set and managed by the community\n    (through governance).\n\n    Vault Strategies are parameterized to pursue the highest risk-adjusted yield.\n\n    There is an \"Emergency Shutdown\" mode. When the Vault is put into emergency\n    shutdown, assets will be recalled from the Strategies as quickly as is\n    practical (given on-chain conditions), minimizing loss. Deposits are\n    halted, new Strategies may not be added, and each Strategy exits with the\n    minimum possible damage to position, while opening up deposits to be\n    withdrawn by users. There are no restrictions on withdrawals above what is\n    expected under Normal Operation.\n\n    For further details, please refer to the specification:\n    https://github.com/iearn-finance/yearn-vaults/blob/main/SPECIFICATION.md\n\"\"\"\n\nAPI_VERSION: constant(String[28]) = \"0.4.6\"\n\nfrom vyper.interfaces import ERC20\n\nimplements: ERC20\n\n\ninterface DetailedERC20:\n    def name() -> String[42]: view\n    def symbol() -> String[20]: view\n    def decimals() -> uint256: view\n\n\ninterface Strategy:\n    def want() -> address: view\n    def vault() -> address: view\n    def isActive() -> bool: view\n    def delegatedAssets() -> uint256: view\n    def estimatedTotalAssets() -> uint256: view\n    def withdraw(_amount: uint256) -> uint256: nonpayable\n    def migrate(_newStrategy: address): nonpayable\n    def emergencyExit() -> bool: view\n\nname: public(String[64])\nsymbol: public(String[32])\ndecimals: public(uint256)\n\nbalanceOf: public(HashMap[address, uint256])\nallowance:"
    }
  ]
}