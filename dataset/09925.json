{
  "Title": "[G-03] Remove redundant access control checks can save gas",
  "Content": "\n_Note: suggested optimation, save a decent amount of gas without compromising readability._\n\n[TokemakBribe.sol#L125-L135](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L125-L135)<br>\n\n```solidity\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline >= block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n\n        emit SetProposal(proposal, deadline, _round);\n    }\n```\n\n[TokemakBribe.sol#L142-L157](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L142-L157)<br>\n\n```solidity\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length > 0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n```\n\n`setProposal()` already got `onlyAuthorized` check, and `setProposals()` will check it again multiple times.\n\nConsider creating `_setProposal()` private function without access control and call it inside the public functions.\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\n    function _setProposal(address proposal, uint256 deadline)\n        private\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline >= block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n    }\n\n    /**\n        @notice Set a single proposal\n        @param  proposal  addresss Proposal address\n        @param  deadline  uint256  Proposal deadline\n     */\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        _setProposal(proposal, deadline);\n        emit SetProposal(proposal, deadline, _round);\n    }\n\n    /**\n        @notice Set multiple proposals\n        @param  proposals  address[]  Proposal addresses\n        @param  deadlines  uint256[]  Proposal deadlines\n     */\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length > 0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            _setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-02-redacted-cartel-contest",
  "Code": [
    {
      "filename": "contracts/TokemakBribe.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ninterface IBribeVault {\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external;\n\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount);\n\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable;\n}\n\ncontract TokemakBribe is AccessControl {\n    address public bribeVault;\n\n    // Used for generating the bribe and reward identifiers\n    string public constant protocol = \"TOKEMAK\";\n    uint256 private _round;\n\n    // Proposal addresses mapped to deadlines by which bribers can deposit\n    mapping(address => uint256) public proposalDeadlines;\n\n    // Voter addresses mapped to addresses which will claim rewards on their behalf\n    mapping(address => address) public rewardForwarding;\n\n    bytes32 public constant TEAM_ROLE = keccak256(\"TEAM_ROLE\");\n\n    event GrantTeamRole(address teamMember);\n    event RevokeTeamRole(address teamMember);\n    event SetProposal(\n        address indexed proposal,\n        uint256 deadline,\n        uint256 indexed round\n    );\n    event SetProposals(address[] proposals, uint256[] deadlines, uint256 round);\n    event DepositBribe(\n        address indexed proposal,\n        uint256 indexed round,\n        address indexed token,\n        uint256 amount,\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier\n    );\n    event SetRewardForwarding(address from, address to);\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                hasRole(TEAM_ROLE, msg.sender),\n            \"Not authorized\"\n        );\n        _;\n    }\n\n    /**\n        @notice Grant the team role to an address\n        @param  teamMember  address  Address to grant the teamMember role\n     */\n    function grantTeamRole(address teamMember)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(teamMember != address(0), \"Invalid teamMember\");\n        _grantRole(TEAM_ROLE, teamMember);\n\n        emit GrantTeamRole(teamMember);\n    }\n\n    /**\n        @notice Revoke the team role from an address\n        @param  teamMember  address  Address to revoke the teamMember role\n     */\n    function revokeTeamRole(address teamMember)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(TEAM_ROLE, teamMember), \"Invalid teamMember\");\n        _revokeRole(TEAM_ROLE, teamMember);\n\n        emit RevokeTeamRole(teamMember);\n    }\n\n    /**\n        @notice Set a new voting round\n        @param  _newRound uint256 The new round number\n     */\n    function setRound(uint256 _newRound) external onlyAuthorized {\n        _round = _newRound;\n    }\n\n    /**\n        @notice Set a new voting round\n        @return round uint256 The current round number\n     */\n    function getRound() external view returns (uint256) {\n        return _round;\n    }\n\n    /**\n        @notice Set a single proposal\n        @param  proposal  addresss Proposal address\n        @param  deadline  uint256  Proposal deadline\n     */\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline >= block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n\n        emit SetProposal(proposal, deadline, _round);\n    }\n\n    /**\n        @notice Set multiple proposals\n        @param  proposals  address[]  Proposal addresses\n        @param  deadlines  uint256[]  Proposal deadlines\n     */\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length > 0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n\n    /**\n        @notice Generate the BribeVault identifier based on a scheme\n        @param  proposal    address  Proposal\n        @param  round       uint256  Voting round\n        @param  token       address  Token\n        @return identifier  bytes32  BribeVault identifier\n     */\n    function generateBribeVaultIdentifier(\n        address proposal,\n        uint256 round,\n        address token\n    ) internal pure returns (bytes32 identifier) {\n        return keccak256(abi.encodePacked(protocol, proposal, round, token));\n    }\n\n    /**\n        @notice Generate the reward identifier based on a scheme\n        @param  round       uint256  Round\n        @param  token       address  Token\n        @return identifier  bytes32  Reward identifier\n     */\n    function generateRewardIdentifier(uint256 round, address token)\n        internal\n        pure\n        returns (bytes32 identifier)\n    {\n        return keccak256(abi.encodePacked(protocol, round, token));\n    }\n\n    /**\n        @notice Get bribe from BribeVault\n        @param  proposal            address  Proposal\n        @param  token               address  Token\n        @return bribeToken          address  Token address\n        @return bribeAmount         address  Token address\n     */\n    function getBribe(\n        address proposal,\n        uint256 round,\n        address token\n    ) external view returns (address bribeToken, uint256 bribeAmount) {\n        return\n            IBribeVault(bribeVault).getBribe(\n                generateBribeVaultIdentifier(proposal, round, token)\n            );\n    }\n\n    /**\n        @notice Deposit bribe for a proposal (ERC20 tokens only)\n        @param  proposal  address  Proposal\n        @param  token     address  Token\n        @param  amount    uint256  Token amount\n     */\n    function depositBribeERC20(\n        address proposal,\n        address token,\n        uint256 amount\n    ) external {\n        uint256 currentRound = _round;\n        require(\n            proposalDeadlines[proposal] > block.timestamp,\n            \"Proposal deadline has passed\"\n        );\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Bribe amount must be greater than 0\");\n\n        bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n            proposal,\n            currentRound,\n            token\n        );\n        bytes32 rewardIdentifier = generateRewardIdentifier(\n            currentRound,\n            token\n        );\n\n        IBribeVault(bribeVault).depositBribeERC20(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            msg.sender\n        );\n\n        emit DepositBribe(\n            proposal,\n            currentRound,\n            token,\n            amount,\n            bribeIdentifier,\n            rewardIdentifier\n        );\n    }\n\n    /**\n        @notice Deposit bribe for a proposal (native token only)\n        @param  proposal  address  Proposal\n     */\n    function depositBribe(address proposal) external payable {\n        uint256 currentRound = _round;\n        require(\n            proposalDeadlines[proposal] > block.timestamp,\n            \"Proposal deadline has passed\"\n        );\n        require(msg.value > 0, \"Bribe amount must be greater than 0\");\n\n        bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n            proposal,\n            currentRound,\n            bribeVault\n        );\n        bytes32 rewardIdentifier = generateRewardIdentifier(\n            currentRound,\n            bribeVault\n        );\n\n        IBribeVault(bribeVault).depositBribe{value: msg.value}(\n            // NOTE: Native token bribes have bribeVault set as the address\n            bribeIdentifier,\n            rewardIdentifier,\n            msg.sender\n        );\n\n        emit DepositBribe(\n            proposal,\n            currentRound,\n            bribeVault,\n            msg.value,\n            bribeIdentifier,\n            rewardIdentifier\n        );\n    }\n\n    /**\n        @notice Voters can opt in or out of reward-forwarding\n        @notice Opt-in: A voter sets another address to forward rewards to\n        @notice Opt-out: A voter sets their own address or the zero address\n        @param  to  address  Account that rewards will be sent to\n     */\n    function setRewardForwarding(address to) public {\n        rewardForwarding[msg.sender] = to;\n\n        emit SetRewardForwarding(msg.sender, to);\n    }\n}"
    },
    {
      "filename": "contracts/TokemakBribe.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ninterface IBribeVault {\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external;\n\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount);\n\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable;\n}\n\ncontract TokemakBribe is AccessControl {\n    address public bribeVault;\n\n    // Used for generating the bribe and reward identifiers\n    string public constant protocol = \"TOKEMAK\";\n    uint256 private _round;\n\n    // Proposal addresses mapped to deadlines by which bribers can deposit\n    mapping(address => uint256) public proposalDeadlines;\n\n    // Voter addresses mapped to addresses which will claim rewards on their behalf\n    mapping(address => address) public rewardForwarding;\n\n    bytes32 public constant TEAM_ROLE = keccak256(\"TEAM_ROLE\");\n\n    event GrantTeamRole(address teamMember);\n    event RevokeTeamRole(address teamMember);\n    event SetProposal(\n        address indexed proposal,\n        uint256 deadline,\n        uint256 indexed round\n    );\n    event SetProposals(address[] proposals, uint256[] deadlines, uint256 round);\n    event DepositBribe(\n        address indexed proposal,\n        uint256 indexed round,\n        address indexed token,\n        uint256 amount,\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier\n    );\n    event SetRewardForwarding(address from, address to);\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier onlyAuthorized() {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                hasRole(TEAM_ROLE, msg.sender),\n            \"Not authorized\"\n        );\n        _;\n    }\n\n    /**\n        @notice Grant the team role to an address\n        @param  teamMember  address  Address to grant the teamMember role\n     */\n    function grantTeamRole(address teamMember)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(teamMember != address(0), \"Invalid teamMember\");\n        _grantRole(TEAM_ROLE, teamMember);\n\n        emit GrantTeamRole(teamMember);\n    }\n\n    /**\n        @notice Revoke the team role from an address\n        @param  teamMember  address  Address to revoke the teamMember role\n     */\n    function revokeTeamRole(address teamMember)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(TEAM_ROLE, teamMember), \"Invalid teamMember\");\n        _revokeRole(TEAM_ROLE, teamMember);\n\n        emit RevokeTeamRole(teamMember);\n    }\n\n    /**\n        @notice Set a new voting round\n        @param  _newRound uint256 The new round number\n     */\n    function setRound(uint256 _newRound) external onlyAuthorized {\n        _round = _newRound;\n    }\n\n    /**\n        @notice Set a new voting round\n        @return round uint256 The current round number\n     */\n    function getRound() external view returns (uint256) {\n        return _round;\n    }\n\n    /**\n        @notice Set a single proposal\n        @param  proposal  addresss Proposal address\n        @param  deadline  uint256  Proposal deadline\n     */\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline >= block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n\n        emit SetProposal(proposal, deadline, _round);\n    }\n\n    /**\n        @notice Set multiple proposals\n        @param  proposals  address[]  Proposal addresses\n        @param  deadlines  uint256[]  Proposal deadlines\n     */\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length > 0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n\n    /**\n        @notice Generate the BribeVault identifier based on a scheme\n        @param  proposal    address  Proposal\n        @param  round       uint256  Voting round\n        @param  token       address  Token\n        @return identifier  bytes32  BribeVault identifier\n     */\n    function generateBribeVaultIdentifier(\n        address proposal,\n        uint256 round,\n        address token\n    ) internal pure returns (bytes32 identifier) {\n        return keccak256(abi.encodePacked(protocol, proposal, round, token));\n    }\n\n    /**\n        @notice Generate the reward identifier based on a scheme\n        @param  round       uint256  Round\n        @param  token       address  Token\n        @return identifier  bytes32  Reward identifier\n     */\n    function generateRewardIdentifier(uint256 round, address token)\n        internal\n        pure\n        returns (bytes32 identifier)\n    {\n        return keccak256(abi.encodePacked(protocol, round, token));\n    }\n\n    /**\n        @notice Get bribe from BribeVault\n        @param  proposal            address  Proposal\n        @param  token               address  Token\n        @return bribeToken          address  Token address\n        @return bribeAmount         address  Token address\n     */\n    function getBribe(\n        address proposal,\n        uint256 round,\n        address token\n    ) external view returns (address bribeToken, uint256 bribeAmount) {\n        return\n            IBribeVault(bribeVault).getBribe(\n                generateBribeVaultIdentifier(proposal, round, token)\n            );\n    }\n\n    /**\n        @notice Deposit bribe for a proposal (ERC20 tokens only)\n        @param  proposal  address  Proposal\n        @param  token     address  Token\n        @param  amount    uint256  Token amount\n     */\n    function depositBribeERC20(\n        address proposal,\n        address token,\n        uint256 amount\n    ) external {\n        uint256 currentRound = _round;\n        require(\n            proposalDeadlines[proposal] > block.timestamp,\n            \"Proposal deadline has passed\"\n        );\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Bribe amount must be greater than 0\");\n\n        bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n            proposal,\n            currentRound,\n            token\n        );\n        bytes32 rewardIdentifier = generateRewardIdentifier(\n            currentRound,\n            token\n        );\n\n        IBribeVault(bribeVault).depositBribeERC20(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            msg.sender\n        );\n\n        emit DepositBribe(\n            proposal,\n            currentRound,\n            token,\n            amount,\n            bribeIdentifier,\n            rewardIdentifier\n        );\n    }\n\n    /**\n        @notice Deposit bribe for a proposal (native token only)\n        @param  proposal  address  Proposal\n     */\n    function depositBribe(address proposal) external payable {\n        uint256 currentRound = _round;\n        require(\n            proposalDeadlines[proposal] > block.timestamp,\n            \"Proposal deadline has passed\"\n        );\n        require(msg.value > 0, \"Bribe amount must be greater than 0\");\n\n        bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n            proposal,\n            currentRound,\n            bribeVault\n        );\n        bytes32 rewardIdentifier = generateRewardIdentifier(\n            currentRound,\n            bribeVault\n        );\n\n        IBribeVault(bribeVault).depositBribe{value: msg.value}(\n            // NOTE: Native token bribes have bribeVault set as the address\n            bribeIdentifier,\n            rewardIdentifier,\n            msg.sender\n        );\n\n        emit DepositBribe(\n            proposal,\n            currentRound,\n            bribeVault,\n            msg.value,\n            bribeIdentifier,\n            rewardIdentifier\n        );\n    }\n\n    /**\n        @notice Voters can opt in or out of reward-forwarding\n        @notice Opt-in: A voter sets another address to forward rewards to\n        @notice Opt-out: A voter sets their own address or the zero address\n        @param  to  address  Account that rewards will be sent to\n     */\n    function setRewardForwarding(address to) public {\n        rewardForwarding[msg.sender] = to;\n\n        emit SetRewardForwarding(msg.sender, to);\n    }\n}"
    }
  ]
}