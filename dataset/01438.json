{
  "Title": "Potential DOS due to Gas Exhaustion Due to Large Array Iteration in `_distribute` Function",
  "Content": "# Potential DOS due to Gas Exhaustion Due to Large Array Iteration in `_distribute` Function\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/codefox-inc/sparkn-contracts/blob/9063a0851ad6538e23728dcb4ba53dc0f722eb96/src/Distributor.sol#L144-L152\">https://github.com/codefox-inc/sparkn-contracts/blob/9063a0851ad6538e23728dcb4ba53dc0f722eb96/src/Distributor.sol#L144-L152</a>\n\n\n## Summary\nThe `_distribute` function in the provided contract contains a loop that iterates through arrays of winners and percentages to distribute tokens. If these arrays are very large, this loop could lead to excessive gas consumption, potentially causing transactions to run out of gas and fail.\n## Vulnerability Details\nThe `_distribute` function is responsible for distributing tokens to winners based on their percentages. This function iterates through arrays of winners and percentages, calculating the amount to transfer to each winner based on their percentage. While the function's purpose is to fairly distribute tokens, a potential vulnerability arises when dealing with a large number of winners and percentages.\n```solidity\nfunction _distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n    internal\n{\n    // ...\n\n    uint256 winnersLength = winners.length;\n    for (uint256 i; i < winnersLength;) {\n        uint256 amount = totalAmount * percentages[i] / BASIS_POINTS;\n        erc20.safeTransfer(winners[i], amount);\n        unchecked {\n            ++i;\n        }\n    }\n\n    // ...\n}\n\n```\nThe loop's gas cost increases linearly with the size of the `winners` and `percentages` arrays. If these arrays contain a significant number of elements, the gas consumption of the transaction could exceed the gas limit, causing the transaction to fail due to out-of-gas.\n## Impact\nThe impact of this issue is that transactions attempting to distribute tokens to a large number of winners in a single execution may fail due to running out of gas. Users may experience frustration and inconvenience if their intended distributions cannot be completed successfully.\n## Tools Used\nManual\n## Recommendations\nImplement a batching mechanism that processes a limited number of winners and percentages in each iteration of the loop. ",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
  "Code": [
    {
      "filename": "src/Distributor.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {ProxyFactory} from \"./ProxyFactory.sol\";\n\n/**\n * @title Distributor contract\n * @notice General ERC20 stable coin tokens, e.g. JPYC, USDC, USDT, DAI, etc, are suppsoed to be used in SPARKN.\n * @notice This contract is used as the implementation of proxy contracts to distribute ERC20 token(e.g. JPYC) to winners\n * @dev The main logic of prize token distribution sits in this contract waiting to be called by factory contract\n * @dev Although the contract is immutable after deployment, If we want to upgrade the implementation contract\n * we can deploy a new one and change the implementation address of proxy contract.\n */\ncontract Distributor {\n    using SafeERC20 for IERC20;\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n\n    error Distributor__InvalidCommissionFee();\n    error Distributor__NoZeroAddress();\n    error Distributor__OnlyFactoryAddressIsAllowed();\n    error Distributor__InvalidTokenAddress();\n    error Distributor__MismatchedArrays();\n    error Distributor__MismatchedPercentages();\n    error Distributor__NoTokenToDistribute();\n\n    //////////////////////////////////////\n    /////// Immutable Variables //////////\n    //////////////////////////////////////\n    /* solhint-disable */\n    uint8 private constant VERSION = 1; // version is 1 for now\n    address private immutable FACTORY_ADDRESS;\n    address private immutable STADIUM_ADDRESS;\n    uint256 private constant COMMISSION_FEE = 500; // this can be changed in the future\n    // a constant value of 10,000 (basis points) = 100%\n    uint256 private constant BASIS_POINTS = 10000;\n\n    // prize distribution event. data is for logging purpose\n    event Distributed(address token, address[] winners, uint256[] percentages, bytes data);\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /// @dev initiate the contract with factory address and other key addresses, fee rate\n    constructor(\n        // uint256 version, // for future use\n        address factoryAddress,\n        address stadiumAddress\n    ) \n    /* solhint-enable */\n    {\n        if (factoryAddress == address(0) || stadiumAddress == address(0)) revert Distributor__NoZeroAddress();\n        FACTORY_ADDRESS = factoryAddress; // initialize with deployed factory address beforehand\n        STADIUM_ADDRESS = stadiumAddress; // official address to receive commission fee\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Distribute token to winners according to the percentages\n     * @dev Only factory contract can call this function\n     * @param token The token address to distribute\n     * @param winners The addresses array of winners\n     * @param percentages The percentages array of winners\n     */\n    function distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        external\n    {\n        if (msg.sender != FACTORY_ADDRESS) {\n            revert Distributor__OnlyFactoryAddressIsAllowed();\n        }\n        _distribute(token, winners, percentages, data);\n    }\n\n    ////////////////////////////////////////////\n    /////// Internal & Private functions ///////\n    ////////////////////////////////////////////\n    /**\n     * @notice An internal function to distribute JPYC to winners\n     * @dev Main logic of distribution is implemented here. The length of winners and percentages must be the same\n     * The token address must be one of the whitelisted tokens\n     * The winners and percentages array are supposed not to be so long, so the loop can stay unbounded\n     * The total percentage must be correct. It must be (100 - COMMITION_FEE).\n     * Finally send the remained token(fee) to STADIUM_ADDRESS with no dust in the contract\n     * @param token The token address\n     * @param winners The addresses of winners\n     * @param percentages The percentages of winners\n     * @param data The data to be logged. It is supposed to be used for showing the realation bbetween winners and proposals.\n     */\n    function _distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        internal\n    {\n        // token address input check\n        if (token == address(0)) revert Distributor__NoZeroAddress();\n        if (!_isWhiteListed(token)) {\n            revert Distributor__InvalidTokenAddress();\n        }\n        // winners and percentages input check\n        if (winners.length == 0 || winners.length != percentages.length) revert Distributor__MismatchedArrays();\n        uint256 percentagesLength = percentages.length;\n        uint256 totalPercentage;\n        for (uint256 i; i < percentagesLength;) {\n            totalPercentage += percentages[i];\n            unchecked {\n                ++i;\n            }\n        }\n        // check if totalPercentage is correct\n        if (totalPercentage != (10000 - COMMISSION_FEE)) {\n            revert Distributor__MismatchedPercentages();\n        }\n        IERC20 erc20 = IERC20(token);\n        uint256 totalAmount = erc20.balanceOf(address(this));\n\n        // if there is no token to distribute, then revert\n        if (totalAmount == 0) revert Distributor__NoTokenToDistribute();\n\n        uint256 winnersLength = winners.length; // cache length\n        for (uint256 i; i < winnersLength;) {\n            uint256 amount = totalAmount * percentages[i] / BASIS_POINTS;\n            erc20.safeTransfer(winners[i], amount);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // send commission fee as well as all the remaining tokens to STADIUM_ADDRESS to avoid dust remaining\n        _commissionTransfer(erc20);\n        emit Distributed(token, winners, percentages, data);\n    }\n\n    /**\n     * @notice Transfer commission fee to STADIUM_ADDRESS\n     * @dev This internal function is called after distribution in `_distribute` function\n     * @param token The token address\n     */\n    function _commissionTransfer(IERC20 token) internal {\n        token.safeTransfer(STADIUM_ADDRESS, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Check if the token is whitelisted. calling FACTORY_ADDRESS\n     * @param token The token address\n     * @return true if the token is whitelisted, vice versa\n     */\n    function _isWhiteListed(address token) internal view returns (bool) {\n        return ProxyFactory(FACTORY_ADDRESS).whitelistedTokens(token);\n    }\n\n    ///////////////////////////////////////////\n    /////// Getter pure/view functions ////////\n    ///////////////////////////////////////////\n    /**\n     * @notice returns all the immutable and constant addresses and values\n     * @dev This function is for convenience to check the addresses and values\n     */\n    function getConstants()\n        external\n        view\n        returns (address _FACTORY_ADDRESS, address _STADIUM_ADDRESS, uint256 _COMMISSION_FEE, uint8 _VERSION)\n    {\n        /* solhint-disable */\n        _FACTORY_ADDRESS = FACTORY_ADDRESS;\n        _STADIUM_ADDRESS = STADIUM_ADDRESS;\n        _COMMISSION_FEE = COMMISSION_FEE;\n        _VERSION = VERSION;\n        /* solhint-enable */\n    }\n}"
    }
  ]
}