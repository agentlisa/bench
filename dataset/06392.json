{
  "Title": "[M-02] The broker should not be fully disabled by GnosisTrade.reportViolation",
  "Content": "\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/trading/GnosisTrade.sol#L202> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Broker.sol#L119-L123>\n\nGnosisTrade and DutchTrade are two separate auction systems where the failing of either system should not affect the other one. The current design will have `Broker.sol` disabled when `reportViolation` is invoked by `GnosisTrade.settle()` if the auction's clearing price was below what we assert it should be.\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/trading/GnosisTrade.sol#L202>\n\n```solidity\n                broker.reportViolation();\n```\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Broker.sol#L119-L123>\n\n```solidity\n    function reportViolation() external notTradingPausedOrFrozen {\n        require(trades[_msgSender()], \"unrecognized trade contract\");\n        emit DisabledSet(disabled, true);\n        disabled = true;\n    }\n```\n\nConsequently, both `BackingManager` and `RevenueTrader (rsrTrader and rTokenTrader)` will not be able to call `openTrade()`:\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Broker.sol#L97-L98>\n\n```soliidty\n    function openTrade(TradeKind kind, TradeRequest memory req) external returns (ITrade) {\n        require(!disabled, \"broker disabled\");\n        ...\n```\n\ntill it's resolved by the governance:\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Broker.sol#L180-L183>\n\n```solidity\n    function setDisabled(bool disabled_) external governance {\n        emit DisabledSet(disabled, disabled_);\n        disabled = disabled_;\n    }\n```\n\n### Proof of Concept\n\nThe following `Trading.trytrade()` as inherited by `BackingManager` and `RevenueTrader` will be denied on line 121, deterring recollaterization and boosting of Rtoken and stRSR exchange rate. The former deterrence will have [`Rtoken.redeemTo`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RToken.sol#L190) and [`StRSR.withdraw`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/StRSR.sol#L335) (both [requiring](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RToken.sol#L190) [`fullyCollateralized`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/StRSR.sol#L335)) denied whereas the latter will have the Rtoken and stRSR holders divested of intended gains.\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/mixins/Trading.sol#L113-L126>\n\n```solidty\n    function tryTrade(TradeKind kind, TradeRequest memory req) internal returns (ITrade trade) {\n        /*  */\n        IERC20 sell = req.sell.erc20();\n        assert(address(trades[sell]) == address(0));\n\n        IERC20Upgradeable(address(sell)).safeApprove(address(broker), 0);\n        IERC20Upgradeable(address(sell)).safeApprove(address(broker), req.sellAmount);\n\n121:        trade = broker.openTrade(kind, req);\n        trades[sell] = trade;\n        tradesOpen++;\n\n        emit TradeStarted(trade, sell, req.buy.erc20(), req.sellAmount, req.minBuyAmount);\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider having the affected code refactored as follows:\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Broker.sol#L97-L113>\n\n```diff\n    function openTrade(TradeKind kind, TradeRequest memory req) external returns (ITrade) {\n-        require(!disabled, \"broker disabled\");\n\n        address caller = _msgSender();\n        require(\n            caller == address(backingManager) ||\n                caller == address(rsrTrader) ||\n                caller == address(rTokenTrader),\n            \"only traders\"\n        );\n\n        // Must be updated when new TradeKinds are created\n        if (kind == TradeKind.BATCH_AUCTION) {\n+            require(!disabled, \"Gnosis Trade disabled\");\n            return newBatchAuction(req, caller);\n        }\n        return newDutchAuction(req, ITrading(caller));\n    }\n```\n\nThis will have the Gnosis Trade conditionally denied while still allowing the opening of Dutch Trade.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/47#issuecomment-1613867516):**\n > This currently mostly reads like a design suggestion. I can see the merits of disabling the entire broker in the scenario where the invariant has been violated. Probably best as QA, but will allow for sponsor comment before downgrading. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/47#issuecomment-1618919354):**\n > @0xean - We think this should be kept as Medium. It's a good design suggestion that otherwise could lead to the protocol not trading for the length of the governance cycle. This matters when it comes to selling defaulted collateral. \n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Disable dutch auctions on a per-collateral basis, use 4-step dutch trade curve.<br>\n> PRs:<br>\n> - https://github.com/reserve-protocol/protocol/pull/873<br>\n> - https://github.com/reserve-protocol/protocol/pull/869<br>\n\n**Status:** Two mitigation errors. Full details in reports from [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/20) and [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/40) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/trading/GnosisTrade.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"../../interfaces/IBroker.sol\";\nimport \"../../interfaces/IGnosis.sol\";\nimport \"../../interfaces/ITrade.sol\";\n\n// Modifications to this contract's state must only ever be made when status=PENDING!\n\n/// Trade contract against the Gnosis EasyAuction mechanism\ncontract GnosisTrade is ITrade {\n    using FixLib for uint192;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // ==== Constants\n    TradeKind public constant KIND = TradeKind.BATCH_AUCTION;\n    uint256 public constant FEE_DENOMINATOR = 1000;\n\n    // Upper bound for the max number of orders we're happy to have the auction clear in;\n    // When we have good price information, this determines the minimum buy amount per order.\n    uint96 public constant MAX_ORDERS = 1e5;\n\n    // raw \"/\" for compile-time const\n    uint192 public constant DEFAULT_MIN_BID = FIX_ONE / 100; // {tok}\n\n    // ==== status: This contract's state-machine state. See TradeStatus enum, above\n    TradeStatus public status;\n\n    // ==== The rest of contract state is all parameters that are immutable after init()\n    // == Metadata\n    IGnosis public gnosis; // Gnosis Auction contract\n    uint256 public auctionId; // The Gnosis Auction ID returned by gnosis.initiateAuction()\n    IBroker public broker; // The Broker that cloned this contract into existence\n\n    // == Economic parameters\n    // This trade is on behalf of origin. Only origin may call settle(), and the `buy` tokens\n    // from this trade's acution will all eventually go to origin.\n    address public origin;\n    IERC20Metadata public sell; // address of token this trade is selling\n    IERC20Metadata public buy; // address of token this trade is buying\n    uint256 public initBal; // {qTok}, this trade's balance of `sell` when init() was called\n    uint48 public endTime; // timestamp after which this trade's auction can be settled\n    uint192 public worstCasePrice; // {buyTok/sellTok}, the worst price we expect to get at Auction\n    // We expect Gnosis Auction either to meet or beat worstCasePrice, or to return the `sell`\n    // tokens. If we actually *get* a worse clearing that worstCasePrice, we consider it an error in\n    // our trading scheme and call broker.reportViolation()\n\n    // This modifier both enforces the state-machine pattern and guards against reentrancy.\n    modifier stateTransition(TradeStatus begin, TradeStatus end) {\n        require(status == begin, \"Invalid trade state\");\n        status = TradeStatus.PENDING;\n        _;\n        assert(status == TradeStatus.PENDING);\n        status = end;\n    }\n\n    /// Constructor function, can only be called once\n    /// @dev Expects sell tokens to already be present\n    /// @custom:interaction reentrancy-safe b/c state-locking\n    // checks:\n    //   state is NOT_STARTED\n    //   req.sellAmount <= our balance of sell tokens < 2**96\n    //   req.minBuyAmount < 2**96\n    // effects:\n    //   state' is OPEN\n    //   correctly sets all Metadata and Economic parameters of this contract\n    //\n    // actions:\n    //   increases the `req.sell` allowance for `gnosis` by the amount needed to fund the auction\n    //   calls gnosis.initiateAuction(...) to launch the requested auction.\n    function init(\n        IBroker broker_,\n        address origin_,\n        IGnosis gnosis_,\n        uint48 batchAuctionLength,\n        TradeRequest calldata req\n    ) external stateTransition(TradeStatus.NOT_STARTED, TradeStatus.OPEN) {\n        require(req.sellAmount <= type(uint96).max, \"sellAmount too large\");\n        require(req.minBuyAmount <= type(uint96).max, \"minBuyAmount too large\");\n\n        sell = req.sell.erc20();\n        buy = req.buy.erc20();\n        initBal = sell.balanceOf(address(this));\n\n        require(initBal <= type(uint96).max, \"initBal too large\");\n        require(initBal >= req.sellAmount, \"unfunded trade\");\n\n        assert(origin_ != address(0));\n\n        broker = broker_;\n        origin = origin_;\n        gnosis = gnosis_;\n        endTime = uint48(block.timestamp) + batchAuctionLength;\n\n        // {buyTok/sellTok}\n        worstCasePrice = shiftl_toFix(req.minBuyAmount, -int8(buy.decimals())).div(\n            shiftl_toFix(req.sellAmount, -int8(sell.decimals()))\n        );\n\n        // Downsize our sell amount to adjust for fee\n        // {qTok} = {qTok} * {1} / {1}\n        uint96 sellAmount = uint96(\n            _divrnd(\n                req.sellAmount * FEE_DENOMINATOR,\n                FEE_DENOMINATOR + gnosis.feeNumerator(),\n                FLOOR\n            )\n        );\n\n        // Don't decrease minBuyAmount even if fees are in effect. The fee is part of the slippage\n        uint96 minBuyAmount = uint96(Math.max(1, req.minBuyAmount)); // Safe downcast; require'd\n\n        uint256 minBuyAmtPerOrder = Math.max(\n            minBuyAmount / MAX_ORDERS,\n            DEFAULT_MIN_BID.shiftl_toUint(int8(buy.decimals()))\n        );\n\n        // Gnosis EasyAuction requires minBuyAmtPerOrder > 0\n        // untestable:\n        //      Value will always be at least 1. Handled previously in the calling contracts.\n        if (minBuyAmtPerOrder == 0) minBuyAmtPerOrder = 1;\n\n        // == Interactions ==\n\n        // Set allowance (two safeApprove calls to support USDT)\n        IERC20Upgradeable(address(sell)).safeApprove(address(gnosis), 0);\n        IERC20Upgradeable(address(sell)).safeApprove(address(gnosis), initBal);\n\n        auctionId = gnosis.initiateAuction(\n            sell,\n            buy,\n            endTime,\n            endTime,\n            sellAmount,\n            minBuyAmount,\n            minBuyAmtPerOrder,\n            0,\n            false,\n            address(0),\n            new bytes(0)\n        );\n    }\n\n    /// Settle trade, transfer tokens to trader, and report bad trade if needed\n    /// @custom:interaction reentrancy-safe b/c state-locking\n    // checks:\n    //   state is OPEN\n    //   caller is `origin`\n    //   now >= endTime\n    // actions:\n    //   (if not already called) call gnosis.settleAuction(auctionID), which:\n    //     settles the Gnosis Auction\n    //     transfers the resulting tokens back to this address\n    //   if the auction's clearing price was below what we assert it should be,\n    //     then broker.reportViolation()\n    //   transfer all balancess of `buy` and `sell` at this address to `origin`\n    // effects:\n    //   state' is CLOSED\n    function settle()\n        external\n        stateTransition(TradeStatus.OPEN, TradeStatus.CLOSED)\n        returns (uint256 soldAmt, uint256 boughtAmt)\n    {\n        require(msg.sender == origin, \"only origin can settle\");\n\n        // Optionally process settlement of the auction in Gnosis\n        if (!isAuctionCleared()) {\n            // By design, we don't rely on this return value at all, just the\n            // \"cleared\" state of the auction, and the token balances this contract owns.\n            // slither-disable-next-line unused-return\n            gnosis.settleAuction(auctionId);\n            assert(isAuctionCleared());\n        }\n\n        // At this point we know the auction has cleared\n\n        // Transfer balances to origin\n        uint256 sellBal = sell.balanceOf(address(this));\n        boughtAmt = buy.balanceOf(address(this));\n\n        if (sellBal > 0) IERC20Upgradeable(address(sell)).safeTransfer(origin, sellBal);\n        if (boughtAmt > 0) IERC20Upgradeable(address(buy)).safeTransfer(origin, boughtAmt);\n\n        // Check clearing prices\n        if (sellBal < initBal) {\n            soldAmt = initBal - sellBal;\n\n            // Gnosis rounds defensively in the buy token; we should not consider it a violation\n            uint256 adjustedSoldAmt = Math.max(soldAmt, 1);\n            uint256 adjustedBuyAmt = boughtAmt + 1;\n\n            // {buyTok/sellTok}\n            uint192 clearingPrice = shiftl_toFix(adjustedBuyAmt, -int8(buy.decimals())).div(\n                shiftl_toFix(adjustedSoldAmt, -int8(sell.decimals()))\n            );\n\n            if (clearingPrice.lt(worstCasePrice)) {\n                broker.reportViolation();\n            }\n        }\n    }\n\n    /// Anyone can transfer any ERC20 back to the origin after the trade has been closed\n    /// @dev Escape hatch in case trading partner freezes up, or other unexpected events\n    /// @custom:interaction CEI (and respects the state lock)\n    function transferToOriginAfterTradeComplete(IERC20 erc20) external {\n        require(status == TradeStatus.CLOSED, \"only after trade is closed\");\n        IERC20Upgradeable(address(erc20)).safeTransfer(origin, erc20.balanceOf(address(this)));\n    }\n\n    /// @return True if the trade can be settled.\n    // Guaranteed to be true some time after init(), until settle() is called\n    function canSettle() external view returns (bool) {\n        return status == TradeStatus.OPEN && endTime <= block.timestamp;\n    }\n\n    // === Private ===\n\n    function isAuctionCleared() private view returns (bool) {\n        GnosisAuctionData memory data = gnosis.auctionData(auctionId);\n        return data.clearingPriceOrder != bytes32(0);\n    }\n}"
    },
    {
      "filename": "contracts/plugins/trading/GnosisTrade.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"../../interfaces/IBroker.sol\";\nimport \"../../interfaces/IGnosis.sol\";\nimport \"../../interfaces/ITrade.sol\";\n\n// Modifications to this contract's state must only ever be made when status=PENDING!\n\n/// Trade contract against the Gnosis EasyAuction mechanism\ncontract GnosisTrade is ITrade {\n    using FixLib for uint192;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // ==== Constants\n    TradeKind public constant KIND = TradeKind.BATCH_AUCTION;\n    uint256 public constant FEE_DENOMINATOR = 1000;\n\n    // Upper bound for the max number of orders we're happy to have the auction clear in;\n    // When we have good price information, this determines the minimum buy amount per order.\n    uint96 public constant MAX_ORDERS = 1e5;\n\n    // raw \"/\" for compile-time const\n    uint192 public constant DEFAULT_MIN_BID = FIX_ONE / 100; // {tok}\n\n    // ==== status: This contract's state-machine state. See TradeStatus enum, above\n    TradeStatus public status;\n\n    // ==== The rest of contract state is all parameters that are immutable after init()\n    // == Metadata\n    IGnosis public gnosis; // Gnosis Auction contract\n    uint256 public auctionId; // The Gnosis Auction ID returned by gnosis.initiateAuction()\n    IBroker public broker; // The Broker that cloned this contract into existence\n\n    // == Economic parameters\n    // This trade is on behalf of origin. Only origin may call settle(), and the `buy` tokens\n    // from this trade's acution will all eventually go to origin.\n    address public origin;\n    IERC20Metadata public sell; // address of token this trade is selling\n    IERC20Metadata public buy; // address of token this trade is buying\n    uint256 public initBal; // {qTok}, this trade's balance of `sell` when init() was called\n    uint48 public endTime; // timestamp after which this trade's auction can be settled\n    uint192 public worstCasePrice; // {buyTok/sellTok}, the worst price we expect to get at Auction\n    // We expect Gnosis Auction either to meet or beat worstCasePrice, or to return the `sell`\n    // tokens. If we actually *get* a worse clearing that worstCasePrice, we consider it an error in\n    // our trading scheme and call broker.reportViolation()\n\n    // This modifier both enforces the state-machine pattern and guards against reentrancy.\n    modifier stateTransition(TradeStatus begin, TradeStatus end) {\n        require(status == begin, \"Invalid trade state\");\n        status = TradeStatus.PENDING;\n        _;\n        assert(status == TradeStatus.PENDING);\n        status = end;\n    }\n\n    /// Constructor function, can only be called once\n    /// @dev Expects sell tokens to already be present\n    /// @custom:interaction reentrancy-safe b/c state-locking\n    // checks:\n    //   state is NOT_STARTED\n    //   req.sellAmount <= our balance of sell tokens < 2**96\n    //   req.minBuyAmount < 2**96\n    // effects:\n    //   state' is OPEN\n    //   correctly sets all Metadata and Economic parameters of this contract\n    //\n    // actions:\n    //   increases the `req.sell` allowance for `gnosis` by the amount needed to fund the auction\n    //   calls gnosis.initiateAuction(...) to launch the requested auction.\n    function init(\n        IBroker broker_,\n        address origin_,\n        IGnosis gnosis_,\n        uint48 batchAuctionLength,\n        TradeRequest calldata req\n    ) external stateTransition(TradeStatus.NOT_STARTED, TradeStatus.OPEN) {\n        require(req.sellAmount <= type(uint96).max, \"sellAmount too large\");\n        require(req.minBuyAmount <= type(uint96).max, \"minBuyAmount too large\");\n\n        sell = req.sell.erc20();\n        buy = req.buy.erc20();\n        initBal = sell.balanceOf(address(this));\n\n        require(initBal <= type(uint96).max, \"initBal too large\");\n        require(initBal >= req.sellAmount, \"unfunded trade\");\n\n        assert(origin_ != address(0));\n\n        broker = broker_;\n        origin = origin_;\n        gnosis = gnosis_;\n        endTime = uint48(block.timestamp) + batchAuctionLength;\n\n        // {buyTok/sellTok}\n        worstCasePrice = shiftl_toFix(req.minBuyAmount, -int8(buy.decimals())).div(\n            shiftl_toFix(req.sellAmount, -int8(sell.decimals()))\n        );\n\n        // Downsize our sell amount to adjust for fee\n        // {qTok} = {qTok} * {1} / {1}\n        uint96 sellAmount = uint96(\n            _divrnd(\n                req.sellAmount * FEE_DENOMINATOR,\n                FEE_DENOMINATOR + gnosis.feeNumerator(),\n                FLOOR\n            )\n        );\n\n        // Don't decrease minBuyAmount even if fees are in effect. The fee is part of the slippage\n        uint96 minBuyAmount = uint96(Math.max(1, req.minBuyAmount)); // Safe downcast; require'd\n\n        uint256 minBuyAmtPerOrder = Math.max(\n            minBuyAmount / MAX_ORDERS,\n            DEFAULT_MIN_BID.shiftl_toUint(int8(buy.decimals()))\n        );\n\n        // Gnosis EasyAuction requires minBuyAmtPerOrder > 0\n        // untestable:\n        //      Value will always be at least 1. Handled previously in the calling contracts.\n        if (minBuyAmtPerOrder == 0) minBuyAmtPerOrder = 1;\n\n        // == Interactions ==\n\n        // Set allowance (two safeApprove calls to support USDT)\n        IERC20Upgradeable(address(sell)).safeApprove(address(gnosis), 0);\n        IERC20Upgradeable(address(sell)).safeApprove(address(gnosis), initBal);\n\n        auctionId = gnosis.initiateAuction(\n            sell,\n            buy,\n            endTime,\n            endTime,\n            sellAmount,\n            minBuyAmount,\n            minBuyAmtPerOrder,\n            0,\n            false,\n            address(0),\n            new bytes(0)\n        );\n    }\n\n    /// Settle trade, transfer tokens to trader, and report bad trade if needed\n    /// @custom:interaction reentrancy-safe b/c state-locking\n    // checks:\n    //   state is OPEN\n    //   caller is `origin`\n    //   now >= endTime\n    // actions:\n    //   (if not already called) call gnosis.settleAuction(auctionID), which:\n    //     settles the Gnosis Auction\n    //     transfers the resulting tokens back to this address\n    //   if the auction's clearing price was below what we assert it should be,\n    //     then broker.reportViolation()\n    //   transfer all balancess of `buy` and `sell` at this address to `origin`\n    // effects:\n    //   state' is CLOSED\n    function settle()\n        external\n        stateTransition(TradeStatus.OPEN, TradeStatus.CLOSED)\n        returns (uint256 soldAmt, uint256 boughtAmt)\n    {\n        require(msg.sender == origin, \"only origin can settle\");\n\n        // Optionally process settlement of the auction in Gnosis\n        if (!isAuctionCleared()) {\n            // By design, we don't rely on this return value at all, just the\n            // \"cleared\" state of the auction, and the token balances this contract owns.\n            // slither-disable-next-line unused-return\n            gnosis.settleAuction(auctionId);\n            assert(isAuctionCleared());\n        }\n\n        // At this point we know the auction has cleared\n\n        // Transfer balances to origin\n        uint256 sellBal = sell.balanceOf(address(this));\n        boughtAmt = buy.balanceOf(address(this));\n\n        if (sellBal > 0) IERC20Upgradeable(address(sell)).safeTransfer(origin, sellBal);\n        if (boughtAmt > 0) IERC20Upgradeable(address(buy)).safeTransfer(origin, boughtAmt);\n\n        // Check clearing prices\n        if (sellBal < initBal) {\n            soldAmt = initBal - sellBal;\n\n            // Gnosis rounds defensively in the buy token; we should not consider it a violation\n            uint256 adjustedSoldAmt = Math.max(soldAmt, 1);\n            uint256 adjustedBuyAmt = boughtAmt + 1;\n\n            // {buyTok/sellTok}\n            uint192 clearingPrice = shiftl_toFix(adjustedBuyAmt, -int8(buy.decimals())).div(\n                shiftl_toFix(adjustedSoldAmt, -int8(sell.decimals()))\n            );\n\n            if (clearingPrice.lt(worstCasePrice)) {\n                broker.reportViolation();\n            }\n        }\n    }\n\n    /// Anyone can transfer any ERC20 back to the origin after the trade has been closed\n    /// @dev Escape hatch in case trading partner freezes up, or other unexpected events\n    /// @custom:interaction CEI (and respects the state lock)\n    function transferToOriginAfterTradeComplete(IERC20 erc20) external {\n        require(status == TradeStatus.CLOSED, \"only after trade is closed\");\n        IERC20Upgradeable(address(erc20)).safeTransfer(origin, erc20.balanceOf(address(this)));\n    }\n\n    /// @return True if the trade can be settled.\n    // Guaranteed to be true some time after init(), until settle() is called\n    function canSettle() external view returns (bool) {\n        return status == TradeStatus.OPEN && endTime <= block.timestamp;\n    }\n\n    // === Private ===\n\n    function isAuctionCleared() private view returns (bool) {\n        GnosisAuctionData memory data = gnosis.auctionData(auctionId);\n        return data.clearingPriceOrder != bytes32(0);\n    }\n}"
    },
    {
      "filename": "contracts/p1/Broker.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../interfaces/IBroker.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../interfaces/ITrade.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Component.sol\";\nimport \"../plugins/trading/DutchTrade.sol\";\nimport \"../plugins/trading/GnosisTrade.sol\";\n\n// Gnosis: uint96 ~= 7e28\nuint256 constant GNOSIS_MAX_TOKENS = 7e28;\n\n/// A simple core contract that deploys disposable trading contracts for Traders\ncontract BrokerP1 is ComponentP1, IBroker {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using FixLib for uint192;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using Clones for address;\n\n    uint48 public constant MAX_AUCTION_LENGTH = 604800; // {s} max valid duration - 1 week\n    uint48 public constant MIN_AUCTION_LENGTH = ONE_BLOCK * 2; // {s} min auction length - 2 blocks\n    // warning: blocktime <= 12s assumption\n\n    IBackingManager private backingManager;\n    IRevenueTrader private rsrTrader;\n    IRevenueTrader private rTokenTrader;\n\n    /// @custom:oz-renamed-from tradeImplementation\n    // The Batch Auction Trade contract to clone on openTrade(). Governance parameter.\n    ITrade public batchTradeImplementation;\n\n    // The Gnosis contract to init batch auction trades with. Governance parameter.\n    IGnosis public gnosis;\n\n    /// @custom:oz-renamed-from auctionLength\n    // {s} the length of a Gnosis EasyAuction. Governance parameter.\n    uint48 public batchAuctionLength;\n\n    // Whether trading is disabled.\n    // Initially false. Settable by OWNER. A trade clone can set it to true via reportViolation()\n    bool public disabled;\n\n    // The set of ITrade (clone) addresses this contract has created\n    mapping(address => bool) private trades;\n\n    // === 3.0.0 ===\n\n    // The Dutch Auction Trade contract to clone on openTrade(). Governance parameter.\n    ITrade public dutchTradeImplementation;\n\n    // {s} the length of a Dutch Auction. Governance parameter.\n    uint48 public dutchAuctionLength;\n\n    // ==== Invariant ====\n    // (trades[addr] == true) iff this contract has created an ITrade clone at addr\n\n    // effects: initial parameters are set\n    function init(\n        IMain main_,\n        IGnosis gnosis_,\n        ITrade batchTradeImplementation_,\n        uint48 batchAuctionLength_,\n        ITrade dutchTradeImplementation_,\n        uint48 dutchAuctionLength_\n    ) external initializer {\n        __Component_init(main_);\n\n        backingManager = main_.backingManager();\n        rsrTrader = main_.rsrTrader();\n        rTokenTrader = main_.rTokenTrader();\n\n        setGnosis(gnosis_);\n        setBatchTradeImplementation(batchTradeImplementation_);\n        setBatchAuctionLength(batchAuctionLength_);\n        setDutchTradeImplementation(dutchTradeImplementation_);\n        setDutchAuctionLength(dutchAuctionLength_);\n    }\n\n    /// Handle a trade request by deploying a customized disposable trading contract\n    /// @param kind TradeKind.DUTCH_AUCTION or TradeKind.BATCH_AUCTION\n    /// @dev Requires setting an allowance in advance\n    /// @custom:protected and @custom:interaction CEI\n    // checks:\n    //   not disabled, paused (trading), or frozen\n    //   caller is a system Trader\n    // effects:\n    //   Deploys a new trade clone, `trade`\n    //   trades'[trade] = true\n    // actions:\n    //   Transfers req.sellAmount of req.sell.erc20 from caller to `trade`\n    //   Calls trade.init() with appropriate parameters\n    function openTrade(TradeKind kind, TradeRequest memory req) external returns (ITrade) {\n        require(!disabled, \"broker disabled\");\n\n        address caller = _msgSender();\n        require(\n            caller == address(backingManager) ||\n                caller == address(rsrTrader) ||\n                caller == address(rTokenTrader),\n            \"only traders\"\n        );\n\n        // Must be updated when new TradeKinds are created\n        if (kind == TradeKind.BATCH_AUCTION) {\n            return newBatchAuction(req, caller);\n        }\n        return newDutchAuction(req, ITrading(caller));\n    }\n\n    /// Disable the broker until re-enabled by governance\n    /// @custom:protected\n    // checks: not paused (trading), not frozen, caller is a Trade this contract cloned\n    // effects: disabled' = true\n    function reportViolation() external notTradingPausedOrFrozen {\n        require(trades[_msgSender()], \"unrecognized trade contract\");\n        emit DisabledSet(disabled, true);\n        disabled = true;\n    }\n\n    // === Setters ===\n\n    /// @custom:governance\n    function setGnosis(IGnosis newGnosis) public governance {\n        require(address(newGnosis) != address(0), \"invalid Gnosis address\");\n\n        emit GnosisSet(gnosis, newGnosis);\n        gnosis = newGnosis;\n    }\n\n    /// @custom:governance\n    function setBatchTradeImplementation(ITrade newTradeImplementation) public governance {\n        require(\n            address(newTradeImplementation) != address(0),\n            \"invalid batchTradeImplementation address\"\n        );\n\n        emit BatchTradeImplementationSet(batchTradeImplementation, newTradeImplementation);\n        batchTradeImplementation = newTradeImplementation;\n    }\n\n    /// @custom:governance\n    function setBatchAuctionLength(uint48 newAuctionLength) public governance {\n        require(\n            newAuctionLength == 0 ||\n                (newAuctionLength >= MIN_AUCTION_LENGTH && newAuctionLength <= MAX_AUCTION_LENGTH),\n            \"invalid batchAuctionLength\"\n        );\n        emit BatchAuctionLengthSet(batchAuctionLength, newAuctionLength);\n        batchAuctionLength = newAuctionLength;\n    }\n\n    /// @custom:governance\n    function setDutchTradeImplementation(ITrade newTradeImplementation) public governance {\n        require(\n            address(newTradeImplementation) != address(0),\n            \"invalid dutchTradeImplementation address\"\n        );\n\n        emit DutchTradeImplementationSet(dutchTradeImplementation, newTradeImplementation);\n        dutchTradeImplementation = newTradeImplementation;\n    }\n\n    /// @custom:governance\n    function setDutchAuctionLength(uint48 newAuctionLength) public governance {\n        require(\n            newAuctionLength == 0 ||\n                (newAuctionLength >= MIN_AUCTION_LENGTH && newAuctionLength <= MAX_AUCTION_LENGTH),\n            \"invalid dutchAuctionLength\"\n        );\n        emit DutchAuctionLengthSet(dutchAuctionLength, newAuctionLength);\n        dutchAuctionLength = newAuctionLength;\n    }\n\n    /// @custom:governance\n    function setDisabled(bool disabled_) external governance {\n        emit DisabledSet(disabled, disabled_);\n        disabled = disabled_;\n    }\n\n    // === Private ===\n\n    function newBatchAuction(TradeRequest memory req, address caller) private returns (ITrade) {\n        require(batchAuctionLength > 0, \"batch auctions not enabled\");\n        GnosisTrade trade = GnosisTrade(address(batchTradeImplementation).clone());\n        trades[address(trade)] = true;\n\n        // Apply Gnosis EasyAuction-specific resizing of req, if needed: Ensure that\n        // max(sellAmount, minBuyAmount) <= maxTokensAllowed, while maintaining their proportion\n        uint256 maxQty = (req.minBuyAmount > req.sellAmount) ? req.minBuyAmount : req.sellAmount;\n\n        if (maxQty > GNOSIS_MAX_TOKENS) {\n            req.sellAmount = mulDiv256(req.sellAmount, GNOSIS_MAX_TOKENS, maxQty, CEIL);\n            req.minBuyAmount = mulDiv256(req.minBuyAmount, GNOSIS_MAX_TOKENS, maxQty, FLOOR);\n        }\n\n        // == Interactions ==\n        IERC20Upgradeable(address(req.sell.erc20())).safeTransferFrom(\n            caller,\n            address(trade),\n            req.sellAmount\n        );\n        trade.init(this, caller, gnosis, batchAuctionLength, req);\n        return trade;\n    }\n\n    function newDutchAuction(TradeRequest memory req, ITrading caller) private returns (ITrade) {\n        require(dutchAuctionLength > 0, \"dutch auctions not enabled\");\n        DutchTrade trade = DutchTrade(address(dutchTradeImplementation).clone());\n        trades[address(trade)] = true;\n\n        // == Interactions ==\n        IERC20Upgradeable(address(req.sell.erc20())).safeTransferFrom(\n            address(caller),\n            address(trade),\n            req.sellAmount\n        );\n\n        trade.init(caller, req.sell, req.buy, req.sellAmount, dutchAuctionLength);\n        return trade;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[43] private __gap;\n}"
    },
    {
      "filename": "contracts/p1/Broker.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../interfaces/IBroker.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../interfaces/ITrade.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Component.sol\";\nimport \"../plugins/trading/DutchTrade.sol\";\nimport \"../plugins/trading/GnosisTrade.sol\";\n\n// Gnosis: uint96 ~= 7e28\nuint256 constant GNOSIS_MAX_TOKENS = 7e28;\n\n/// A simple core contract that deploys disposable trading contracts for Traders\ncontract BrokerP1 is ComponentP1, IBroker {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using FixLib for uint192;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using Clones for address;\n\n    uint48 public constant MAX_AUCTION_LENGTH = 604800; // {s} max valid duration - 1 week\n    uint48 public constant MIN_AUCTION_LENGTH = ONE_BLOCK * 2; // {s} min auction length - 2 blocks\n    // warning: blocktime <= 12s assumption\n\n    IBackingManager private backingManager;\n    IRevenueTrader private rsrTrader;\n    IRevenueTrader private rTokenTrader;\n\n    /// @custom:oz-renamed-from tradeImplementation\n    // The Batch Auction Trade contract to clone on openTrade(). Governance parameter.\n    ITrade public batchTradeImplementation;\n\n    // The Gnosis contract to init batch auction trades with. Governance parameter.\n    IGnosis public gnosis;\n\n    /// @custom:oz-renamed-from auctionLength\n    // {s} the length of a Gnosis EasyAuction. Governance parameter.\n    uint48 public batchAuctionLength;\n\n    // Whether trading is disabled.\n    // Initially false. Settable by OWNER. A trade clone can set it to true via reportViolation()\n    bool public disabled;\n\n    // The set of ITrade (clone) addresses this contract has created\n    mapping(address => bool) private trades;\n\n    // === 3.0.0 ===\n\n    // The Dutch Auction Trade contract to clone on openTrade(). Governance parameter.\n    ITrade public dutchTradeImplementation;\n\n    // {s} the length of a Dutch Auction. Governance parameter.\n    uint48 public dutchAuctionLength;\n\n    // ==== Invariant ====\n    // (trades[addr] == true) iff this contract has created an ITrade clone at addr\n\n    // effects: initial parameters are set\n    function init(\n        IMain main_,\n        IGnosis gnosis_,\n        ITrade batchTradeImplementation_,\n        uint48 batchAuctionLength_,\n        ITrade dutchTradeImplementation_,\n        uint48 dutchAuctionLength_\n    ) external initializer {\n        __Component_init(main_);\n\n        backingManager = main_.backingManager();\n        rsrTrader = main_.rsrTrader();\n        rTokenTrader = main_.rTokenTrader();\n\n        setGnosis(gnosis_);\n        setBatchTradeImplementation(batchTradeImplementation_);\n        setBatchAuctionLength(batchAuctionLength_);\n        setDutchTradeImplementation(dutchTradeImplementation_);\n        setDutchAuctionLength(dutchAuctionLength_);\n    }\n\n    /// Handle a trade request by deploying a customized disposable trading contract\n    /// @param kind TradeKind.DUTCH_AUCTION or TradeKind.BATCH_AUCTION\n    /// @dev Requires setting an allowance in advance\n    /// @custom:protected and @custom:interaction CEI\n    // checks:\n    //   not disabled, paused (trading), or frozen\n    //   caller is a system Trader\n    // effects:\n    //   Deploys a new trade clone, `trade`\n    //   trades'[trade] = true\n    // actions:\n    //   Transfers req.sellAmount of req.sell.erc20 from caller to `trade`\n    //   Calls trade.init() with appropriate parameters\n    function openTrade(TradeKind kind, TradeRequest memory req) external returns (ITrade) {\n        require(!disabled, \"broker disabled\");\n\n        address caller = _msgSender();\n        require(\n            caller == address(backingManager) ||\n                caller == address(rsrTrader) ||\n                caller == address(rTokenTrader),\n            \"only traders\"\n        );\n\n        // Must be updated when new TradeKinds are created\n        if (kind == TradeKind.BATCH_AUCTION) {\n            return newBatchAuction(req, caller);\n        }\n        return newDutchAuction(req, ITrading(caller));\n    }\n\n    /// Disable the broker until re-enabled by governance\n    /// @custom:protected\n    // checks: not paused (trading), not frozen, caller is a Trade this contract cloned\n    // effects: disabled' = true\n    function reportViolation() external notTradingPausedOrFrozen {\n        require(trades[_msgSender()], \"unrecognized trade contract\");\n        emit DisabledSet(disabled, true);\n        disabled = true;\n    }\n\n    // === Setters ===\n\n    /// @custom:governance\n    function setGnosis(IGnosis newGnosis) public governance {\n        require(address(newGnosis) != address(0), \"invalid Gnosis address\");\n\n        emit GnosisSet(gnosis, newGnosis);\n        gnosis = newGnosis;\n    }\n\n    /// @custom:governance\n    function setBatchTradeImplementation(ITrade newTradeImplementation) public governance {\n        requir"
    }
  ]
}