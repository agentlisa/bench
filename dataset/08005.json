{
  "Title": "[H-04] Users who deposit in one vault can lose all deposits and receive nothing when counterparty vault has no deposits",
  "Content": "\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L148-L192>\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L350-L352>\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234>\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426>\n\n### Impact\n\nFor a market, if users only deposit in the hedge vault or only deposit in the risk vault but not in both, then these users will lose their deposits and receive nothing when they call the following `withdraw` function after the depeg event occurs.\n\nIf the vault that has deposits is called Vault A, and the counterparty vault that has no deposit is called Vault B, then:\n\n*   As shown by the `triggerDepeg` function below, when executing `insrVault.sendTokens(epochEnd, address(riskVault))` and `riskVault.sendTokens(epochEnd, address(insrVault))`, the deposits of Vault A are transferred to Vault B but nothing is transferred to Vault A since Vault B has no deposit;\n*   When `triggerDepeg` executes `insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd))` and `riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd))`, Vault B's `idClaimTVL[id]` is set to Vault A's `idFinalTVL(epochEnd))` but Vault A's `idClaimTVL[id]` is set to 0 because Vault B's `idFinalTVL(epochEnd)` is 0.\n\nBecause of these, calling the `beforeWithdraw` function below will return a 0 `entitledAmount`, and calling `withdraw` then transfers that 0 amount to the user who has deposited. As a result, these users' deposits are transferred to the counterparty vault, and they receive nothing at all.\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L148-L192>\n\n```solidity\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n```\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L350-L352>\n\n```solidity\n    function setClaimTVL(uint256 id, uint256 claimTVL) public onlyController {\n        idClaimTVL[id] = claimTVL;\n    }\n```\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234>\n\n```solidity\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        external\n        override\n        epochHasEnded(id)\n        marketExists(id)\n        returns (uint256 shares)\n    {\n        if(\n            msg.sender != owner &&\n            isApprovedForAll(owner, receiver) == false)\n            revert OwnerDidNotAuthorize(msg.sender, owner);\n\n        shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        uint256 entitledShares = beforeWithdraw(id, shares);\n        _burn(owner, id, shares);\n\n        //Taking fee from the amount\n        uint256 feeValue = calculateWithdrawalFeeValue(entitledShares, id);\n        entitledShares = entitledShares - feeValue;\n        asset.transfer(treasury, feeValue);\n\n        emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);\n        asset.transfer(receiver, entitledShares);\n\n        return entitledShares;\n    }\n```\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426>\n\n```solidity\n    function beforeWithdraw(uint256 id, uint256 amount)\n        public\n        view\n        returns (uint256 entitledAmount)\n    {\n        // in case the risk wins aka no depeg event\n        // risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)\n        // hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool\n        // in case there is a depeg event, the risk users can only withdraw the hedge\n        if (\n            keccak256(abi.encodePacked(symbol)) ==\n            keccak256(abi.encodePacked(\"rY2K\"))\n        ) {\n            if (!idDepegged[id]) {\n                //depeg event did not happen\n                /*\n                entitledAmount =\n                    (amount / idFinalTVL[id]) *\n                    idClaimTVL[id] +\n                    amount;\n                */\n                entitledAmount =\n                    amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                        idClaimTVL[id],\n                        1 ether\n                    ) +\n                    amount;\n            } else {\n                //depeg event did happen\n                entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                    idClaimTVL[id],\n                    1 ether\n                );\n            }\n        }\n        // in case the hedge wins aka depegging\n        // hedge users pay the hedge to risk users anyway,\n        // hedge guy can withdraw risk (that is transfered from the risk pool),\n        // withdraw = % tvl that hedge buyer owns\n        // otherwise hedge users cannot withdraw any Eth\n        else {\n            entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                idClaimTVL[id],\n                1 ether\n            );\n        }\n\n        return entitledAmount;\n    }\n```\n\n### Proof of Concept\n\nPlease append the following tests in `test\\AssertTest.t.sol`. These tests will pass to demonstrate the described scenarios.\n\n```solidity\n    function testWithdrawFromRiskAfterDepegWhenThereIsNoCounterparty() public {\n        vm.deal(chad, AMOUNT * CHAD_MULTIPLIER);\n\n        vm.startPrank(admin);\n        FakeOracle fakeOracle = new FakeOracle(oracleFRAX, STRIKE_PRICE_FAKE_ORACLE);\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, address(fakeOracle), \"y2kFRAX_99*\");\n        vm.stopPrank();\n\n        address hedge = vaultFactory.getVaults(1)[0];\n        address risk = vaultFactory.getVaults(1)[1];\n        \n        Vault vHedge = Vault(hedge);\n        Vault vRisk = Vault(risk);\n\n        // chad deposits in risk vault, and no one deposits in hedge vault\n        vm.startPrank(chad);\n        ERC20(WETH).approve(risk, AMOUNT * CHAD_MULTIPLIER);\n        vRisk.depositETH{value: AMOUNT * CHAD_MULTIPLIER}(endEpoch, chad);\n\n        assertTrue(vRisk.balanceOf(chad,endEpoch) == (AMOUNT * CHAD_MULTIPLIER));\n        vm.stopPrank();\n\n        vm.warp(beginEpoch + 10 days);\n\n        // depeg occurs\n        controller.triggerDepeg(SINGLE_MARKET_INDEX, endEpoch);\n\n        vm.startPrank(chad);\n\n        // chad withdraws from risk vault\n        uint256 assets = vRisk.balanceOf(chad,endEpoch);\n        vRisk.withdraw(endEpoch, assets, chad, chad);\n\n        assertTrue(vRisk.balanceOf(chad,endEpoch) == NULL_BALANCE);\n        uint256 entitledShares = vRisk.beforeWithdraw(endEpoch, assets);\n        assertTrue(entitledShares - vRisk.calculateWithdrawalFeeValue(entitledShares,endEpoch) == ERC20(WETH).balanceOf(chad));\n\n        // chad receives nothing\n        assertEq(entitledShares, 0);\n        assertEq(ERC20(WETH).balanceOf(chad), 0);\n\n        vm.stopPrank();\n    }\n```\n\n```solidity\n    function testWithdrawFromHedgeAfterDepegWhenThereIsNoCounterparty() public {\n        vm.deal(alice, AMOUNT);\n\n        vm.startPrank(admin);\n        FakeOracle fakeOracle = new FakeOracle(oracleFRAX, STRIKE_PRICE_FAKE_ORACLE);\n        vaultFactory.createNewMarket(FEE, tokenFRAX, DEPEG_AAA, beginEpoch, endEpoch, address(fakeOracle), \"y2kFRAX_99*\");\n        vm.stopPrank();\n\n        address hedge = vaultFactory.getVaults(1)[0];\n        address risk = vaultFactory.getVaults(1)[1];\n        \n        Vault vHedge = Vault(hedge);\n        Vault vRisk = Vault(risk);\n\n        // alice deposits in hedge vault, and no one deposits in risk vault\n        vm.startPrank(alice);\n        ERC20(WETH).approve(hedge, AMOUNT);\n        vHedge.depositETH{value: AMOUNT}(endEpoch, alice);\n\n        assertTrue(vHedge.balanceOf(alice,endEpoch) == (AMOUNT));\n        vm.stopPrank();\n\n        vm.warp(beginEpoch + 10 days);\n\n        // depeg occurs\n        controller.triggerDepeg(SINGLE_MARKET_INDEX, endEpoch);\n\n        vm.startPrank(alice);\n\n        // alice withdraws from hedge vault\n        uint256 assets = vHedge.balanceOf(alice,endEpoch);\n        vHedge.withdraw(endEpoch, assets, alice, alice);\n\n        assertTrue(vHedge.balanceOf(alice,endEpoch) == NULL_BALANCE);\n        uint256 entitledShares = vHedge.beforeWithdraw(endEpoch, assets);\n        assertTrue(entitledShares - vHedge.calculateWithdrawalFeeValue(entitledShares,endEpoch) == ERC20(WETH).balanceOf(alice));\n        \n        // alice receives nothing\n        assertEq(entitledShares, 0);\n        assertEq(ERC20(WETH).balanceOf(alice), 0);\n\n        vm.stopPrank();\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen users only deposit in one vault, and no one deposits in the counterparty vault, the insurance practice of hedging and risking actually does not exist. In this situation, after the epoch is started, the users, who have deposited, should be allowed to withdraw their full deposit amounts.\n\n**[3xHarry (Y2K Finance) confirmed](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/409)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-y2k-finance-contest",
  "Code": [
    {
      "filename": "src/Controller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"./VaultFactory.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract Controller {\n    address public immutable admin;\n    VaultFactory public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n    uint256 public constant VAULTS_LENGTH = 2;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error NotZeroTVL();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error TimestampZero();\n    error AddressNotAdmin();\n    error EpochNotExist();\n    error EpochNotExpired();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Depegs insurance vault when event is emitted\n      * @param epochMarketID Current market epoch ID\n      * @param tvl Current TVL\n      * @param isDisaster Flag if event isDisaster\n      * @param epoch Current epoch \n      * @param time Current time\n      * @param depegPrice Price that triggered depeg\n      */\n    event DepegInsurance(\n        bytes32 epochMarketID,\n        VaultTVL tvl,\n        bool isDisaster,\n        uint256 epoch,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /* solhint-disable  var-name-mixedcase */\n    struct VaultTVL {\n        uint256 RISK_claimTVL;\n        uint256 RISK_finalTVL;\n        uint256 INSR_claimTVL;\n        uint256 INSR_finalTVL;\n    }\n    /* solhint-enable  var-name-mixedcase */\n\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != admin)\n            revert AddressNotAdmin();\n        _;\n    }\n\n    /** @notice Modifier to ensure market exists, current market epoch time and price are valid \n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    modifier isDisaster(uint256 marketIndex, uint256 epochEnd) {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        if(\n            vaultsAddress.length != VAULTS_LENGTH\n            )\n            revert MarketDoesNotExist(marketIndex);\n\n        address vaultAddress = vaultsAddress[0];\n        Vault vault = Vault(vaultAddress);\n\n        if(vault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        if(\n            vault.strikePrice() < getLatestPrice(vault.tokenInsured())\n            )\n            revert PriceNotAtStrikePrice(getLatestPrice(vault.tokenInsured()));\n\n        if(\n            vault.idEpochBegin(epochEnd) > block.timestamp)\n            revert EpochNotStarted();\n\n        if(\n            block.timestamp > epochEnd\n            )\n            revert EpochExpired();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _factory VaultFactory address\n      * @param _admin Admin address\n      * @param _l2Sequencer Arbitrum sequencer address\n      */ \n    constructor(\n        address _factory,\n        address _admin,\n        address _l2Sequencer\n    ) {\n        if(_admin == address(0))\n            revert ZeroAddress();\n\n        if(_factory == address(0)) \n            revert ZeroAddress();\n\n        if(_l2Sequencer == address(0))\n            revert ZeroAddress();\n        \n        admin = _admin;\n        vaultFactory = VaultFactory(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerDepeg(uint256 marketIndex, uint256 epochEnd)\n        public\n        isDisaster(marketIndex, epochEnd)\n    {\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, true);\n        riskVault.endEpoch(epochEnd, true);\n\n        insrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd));\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n\n        insrVault.sendTokens(epochEnd, address(riskVault));\n        riskVault.sendTokens(epochEnd, address(insrVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            true,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n      * @param marketIndex Target market index\n      * @param epochEnd End of epoch set for market\n      */\n    function triggerEndEpoch(uint256 marketIndex, uint256 epochEnd) public {\n        if(\n            vaultFactory.getVaults(marketIndex).length != VAULTS_LENGTH)\n                revert MarketDoesNotExist(marketIndex);\n        if(\n            block.timestamp < epochEnd)\n            revert EpochNotExpired();\n\n        address[] memory vaultsAddress = vaultFactory.getVaults(marketIndex);\n\n        Vault insrVault = Vault(vaultsAddress[0]);\n        Vault riskVault = Vault(vaultsAddress[1]);\n\n        if(insrVault.idExists(epochEnd) == false || riskVault.idExists(epochEnd) == false)\n            revert EpochNotExist();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if(insrVault.idFinalTVL(epochEnd) != 0)\n            revert NotZeroTVL();\n        if(riskVault.idFinalTVL(epochEnd) != 0) \n            revert NotZeroTVL();\n\n        insrVault.endEpoch(epochEnd, false);\n        riskVault.endEpoch(epochEnd, false);\n\n        insrVault.setClaimTVL(epochEnd, 0);\n        riskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd));\n        insrVault.sendTokens(epochEnd, address(riskVault));\n\n        VaultTVL memory tvl = VaultTVL(\n            riskVault.idClaimTVL(epochEnd),\n            insrVault.idClaimTVL(epochEnd),\n            riskVault.idFinalTVL(epochEnd),\n            insrVault.idFinalTVL(epochEnd)\n        );\n\n        emit DepegInsurance(\n            keccak256(\n                abi.encodePacked(\n                    marketIndex,\n                    insrVault.idEpochBegin(epochEnd),\n                    epochEnd\n                )\n            ),\n            tvl,\n            false,\n            epochEnd,\n            block.timestamp,\n            getLatestPrice(insrVault.tokenInsured())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN SETTINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n      * @param _token Target token address\n      * @return nowPrice Current token price\n      */\n    function getLatestPrice(address _token)\n        public\n        view\n        returns (int256 nowPrice)\n    {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        uint256 decimals = 10**(18-(priceFeed.decimals()));\n        price = price * int256(decimals);\n\n        if(price <= 0)\n            revert OraclePriceZero();\n\n        if(answeredInRound < roundID)\n            revert RoundIDOutdated();\n\n        if(timeStamp == 0)\n            revert TimestampZero();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n      * @dev need to find way to express typecasts in NatSpec\n      */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n}"
    },
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {SemiFungibleVault} from \"./SemiFungibleVault.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract Vault is SemiFungibleVault, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error AddressZero();\n    error AddressNotFactory(address _contract);\n    error AddressNotController(address _contract);\n    error MarketEpochDoesNotExist();\n    error EpochAlreadyStarted();\n    error EpochNotFinished();\n    error FeeMoreThan150(uint256 _fee);\n    error ZeroValue();\n    error OwnerDidNotAuthorize(address _sender, address _owner);\n    error EpochEndMustBeAfterBegin();\n    error MarketEpochExists();\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable tokenInsured;\n    address private treasury;\n    int256 public immutable strikePrice;\n    address private immutable factory;\n    address public controller;\n\n    uint256[] public epochs;\n    uint256 public timewindow;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => uint256) public idFinalTVL;\n    mapping(uint256 => uint256) public idClaimTVL;\n    // @audit uint32 for timestamp is enough for the next 80 years\n    mapping(uint256 => uint256) public idEpochBegin;\n    // @audit id can be uint32\n    mapping(uint256 => bool) public idDepegged;\n    // @audit id can be uint32\n    mapping(uint256 => bool) public idExists;\n    mapping(uint256 => uint256) public epochFee;\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only factory addresses can call functions that use this modifier\n      */\n    modifier onlyFactory() {\n        if(msg.sender != factory)\n            revert AddressNotFactory(msg.sender);\n        _;\n    }\n\n    /** @notice Only controller addresses can call functions that use this modifier\n      */\n    modifier onlyController() {\n        if(msg.sender != controller)\n            revert AddressNotController(msg.sender);\n        _;\n    }\n\n    /** @notice Only market addresses can call functions that use this modifier\n      */\n    modifier marketExists(uint256 id) {\n        if(idExists[id] != true)\n            revert MarketEpochDoesNotExist();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier before the current epoch has started\n      */\n    modifier epochHasNotStarted(uint256 id) {\n        if(block.timestamp > idEpochBegin[id] - timewindow)\n            revert EpochAlreadyStarted();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier after the current epoch has started\n      */\n    modifier epochHasEnded(uint256 id) {\n        if((block.timestamp < id) && idDepegged[id] == false)\n            revert EpochNotFinished();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice constructor\n        @param  _assetAddress    token address representing your asset to be deposited;\n        @param  _name   token name for the ERC1155 mints. Insert the name of your token; Example: Y2K_USDC_1.2$\n        @param  _symbol token symbol for the ERC1155 mints. insert here if risk or hedge + Symbol. Example: HedgeY2K or riskY2K;\n        @param  _token  address of the oracle to lookup the price in chainlink oracles;\n        @param  _strikePrice    uint256 representing the price to trigger the depeg event;\n        @param _controller  address of the controller contract, this contract can trigger the depeg events;\n     */\n    constructor(\n        address _assetAddress,\n        string memory _name,\n        string memory _symbol,\n        address _treasury,\n        address _token,\n        int256 _strikePrice,\n        address _controller\n    ) SemiFungibleVault(ERC20(_assetAddress), _name, _symbol) {\n\n        if(_treasury == address(0))\n            revert AddressZero();\n\n        if(_controller == address(0))\n            revert AddressZero();\n\n        if(_token == address(0))\n            revert AddressZero();\n\n        tokenInsured = _token;\n        treasury = _treasury;\n        strikePrice = _strikePrice;\n        factory = msg.sender;\n        controller = _controller;\n        timewindow = 1 days;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Deposit function from ERC4626, with payment of a fee to a treasury implemented;\n        @param  id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param  assets  uint256 representing how many assets the user wants to deposit, a fee will be taken from this value;\n        @param receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n        @return shares how many assets the owner is entitled to, removing the fee from it's shares;\n     */\n    function deposit(\n        uint256 id,\n        uint256 assets,\n        address receiver\n    )\n        public\n        override\n        marketExists(id)\n        epochHasNotStarted(id)\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(id, assets)) != 0, \"ZeroValue\");\n\n        asset.transferFrom(msg.sender, address(this), shares);\n\n        _mint(receiver, id, shares, EMPTY);\n\n        emit Deposit(msg.sender, receiver, id, shares, shares);\n\n        return shares;\n    }\n\n    /**\n        @notice Deposit ETH function\n        @param  id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n        @return shares how many assets the owner is entitled to, removing the fee from its shares;\n     */\n    function depositETH(uint256 id, address receiver)\n        external\n        payable\n        returns (uint256 shares)\n    {\n        require(msg.value > 0, \"ZeroValue\");\n\n        IWETH(address(asset)).deposit{value: msg.value}();\n        assert(IWETH(address(asset)).transfer(msg.sender, msg.value));\n\n        return deposit(id, msg.value, receiver);\n    }\n\n    /**\n    @notice Withdraw entitled deposited assets, checking if a depeg event //TODO add GOV token rewards\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n    @param assets   uint256 of how many assets you want to withdraw, this value will be used to calculate how many assets you are entitle to according to the events;\n    @param receiver  Address of the receiver of the assets provided by this function, that represent the ownership of the transfered asset;\n    @param owner    Address of the owner of these said assets;\n    @return shares How many shares the owner is entitled to, according to the conditions;\n     */\n    function withdraw(\n        uint256 id,\n        uint256 assets,\n        address receiver,\n        address owner\n    )\n        external\n        override\n        epochHasEnded(id)\n        marketExists(id)\n        returns (uint256 shares)\n    {\n        if(\n            msg.sender != owner &&\n            isApprovedForAll(owner, receiver) == false)\n            revert OwnerDidNotAuthorize(msg.sender, owner);\n\n        shares = previewWithdraw(id, assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        uint256 entitledShares = beforeWithdraw(id, shares);\n        _burn(owner, id, shares);\n\n        //Taking fee from the amount\n        uint256 feeValue = calculateWithdrawalFeeValue(entitledShares, id);\n        entitledShares = entitledShares - feeValue;\n        asset.transfer(treasury, feeValue);\n\n        emit Withdraw(msg.sender, receiver, owner, id, assets, entitledShares);\n        asset.transfer(receiver, entitledShares);\n\n        return entitledShares;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice returns total assets for the id of given epoch\n        @param  _id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n     */\n    function totalAssets(uint256 _id)\n        public\n        view\n        override\n        marketExists(_id)\n        returns (uint256)\n    {\n        return totalSupply(_id);\n    }\n\n    /**\n    @notice Calculates how much ether the %fee is taking from @param amount\n    @param amount Amount to withdraw from vault\n    @param _epoch Target epoch\n    @return feeValue Current fee value\n     */\n    function calculateWithdrawalFeeValue(uint256 amount, uint256 _epoch)\n        public\n        view\n        returns (uint256 feeValue)\n    {\n        // 0.5% = multiply by 1000 then divide by 5\n        return (amount * epochFee[_epoch]) / 1000;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           Factory FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Factory function, changes treasury address\n    @param _treasury New treasury address\n     */\n    function changeTreasury(address _treasury) public onlyFactory {\n        if(_treasury == address(0))\n            revert AddressZero();\n        treasury = _treasury;\n    }\n\n    /**\n    @notice Factory function, changes vault time window\n    @param _timewindow New vault time window\n     */\n    function changeTimewindow(uint256 _timewindow) public onlyFactory {\n        timewindow = _timewindow;\n    }\n\n    /**\n    @notice Factory function, changes controller address\n    @param _controller New controller address\n     */\n    function changeController(address _controller) public onlyFactory {\n        if(_controller == address(0))\n            revert AddressZero();\n        controller = _controller;\n    }\n\n    /**\n    @notice Function to deploy hedge assets for given epochs, after the creation of this vault\n    @param  epochBegin uint256 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  epochEnd uint256 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint256 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function createAssets(uint256 epochBegin, uint256 epochEnd, uint256 _withdrawalFee)\n        public\n        onlyFactory\n    {\n        if(_withdrawalFee > 150)\n            revert FeeMoreThan150(_withdrawalFee);\n\n        if(idExists[epochEnd] == true)\n            revert MarketEpochExists();\n        \n        if(epochBegin >= epochEnd)\n            revert EpochEndMustBeAfterBegin();\n\n        idExists[epochEnd] = true;\n        idEpochBegin[epochEnd] = epochBegin;\n        epochs.push(epochEnd);\n\n        epochFee[epochEnd] = _withdrawalFee;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         CONTROLLER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Controller can call this function to trigger the end of the epoch, storing the TVL of that epoch and if a depeg event occurred\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param depeg Boolean value indicating if the depeg event occurred, or not. Example: If depeg occurred depeg = true\n     */\n    function endEpoch(uint256 id, bool depeg)\n        public\n        onlyController\n        marketExists(id)\n    {\n        idDepegged[id] = depeg;\n        idFinalTVL[id] = totalAssets(id);\n    }\n\n    /**\n    @notice Function to be called after endEpoch, by the Controller only, this function stores the TVL of the counterparty vault in a mapping to be used for later calculations of the entitled withdraw\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param claimTVL uint256 representing the TVL the counterparty vault has, storing this value in a mapping\n     */\n    function setClaimTVL(uint256 id, uint256 claimTVL) public onlyController {\n        idClaimTVL[id] = claimTVL;\n    }\n\n    /**\n    solhint-disable-next-line max-line-length\n    @notice Function to be called after endEpoch and setClaimTVL functions, respecting the calls in order, after storing the TVL of the end of epoch and the TVL amount to claim, this function will allow the transfer of tokens to the counterparty vault\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param _counterparty Address of the other vault, meaning address of the risk vault, if this is an hedge vault, and vice-versa\n    */\n    function sendTokens(uint256 id, address _counterparty)\n        public\n        onlyController\n        marketExists(id)\n    {\n        asset.transfer(_counterparty, idFinalTVL[id]);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Calculations of how much the user will receive;\n    @param  id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000\n    @param amount uint256 of the amount the user wants to withdraw\n    @return entitledAmount How much amount the user will receive, according to the conditions\n    */\n    function beforeWithdraw(uint256 id, uint256 amount)\n        public\n        view\n        returns (uint256 entitledAmount)\n    {\n        // in case the risk wins aka no depeg event\n        // risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)\n        // hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool\n        // in case there is a depeg event, the risk users can only withdraw the hedge\n        if (\n            keccak256(abi.encodePacked(symbol)) ==\n            keccak256(abi.encodePacked(\"rY2K\"))\n        ) {\n            if (!idDepegged[id]) {\n                //depeg event did not happen\n                /*\n                entitledAmount =\n                    (amount / idFinalTVL[id]) *\n                    idClaimTVL[id] +\n                    amount;\n                */\n                entitledAmount =\n                    amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                        idClaimTVL[id],\n                        1 ether\n                    ) +\n                    amount;\n            } else {\n                //depeg event did happen\n                entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                    idClaimTVL[id],\n                    1 ether\n                );\n            }\n        }\n        // in case the hedge wins aka depegging\n        // hedge users pay the hedge to risk users anyway,\n        // hedge guy can withdraw risk (that is transfered from the risk pool),\n        // withdraw = % tvl that hedge buyer owns\n        // otherwise hedge users cannot withdraw any Eth\n        else {\n            entitledAmount = amount.divWadDown(idFinalTVL[id]).mulDivDown(\n                idClaimTVL[id],\n                1 ether\n            );\n        }\n\n        return entitledAmount;\n    }\n    \n    /** @notice Lookup total epochs length\n      */\n    function epochsLength() public view returns (uint256) {\n        return epochs.length;\n    }\n\n    /** @notice Lookup next epochs' end from target\n        @param _epoch Target epoch\n        @return nextEpochEnd Next epoch end\n      */\n    function getNextEpoch(uint256 _epoch)\n        public\n        view\n        returns (uint256 nextEpochEnd)\n    {\n        for (uint256 i = 0; i < epochsLength(); i++) {\n            if (epochs[i] == _epoch) {\n                if (i == epochsLength() - 1) {\n                    return 0;\n                }\n                return epochs[i + 1];\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {SemiFungibleVault} from \"./SemiFungibleVault.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract Vault is SemiFungibleVault, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error AddressZero();\n    error AddressNotFactory(address _contract);\n    error AddressNotController(address _contract);\n    error MarketEpochDoesNotExist();\n    error EpochAlreadyStarted();\n    error EpochNotFinished();\n    error FeeMoreThan150(uint256 _fee);\n    error ZeroValue();\n    error OwnerDidNotAuthorize(address _sender, address _owner);\n    error EpochEndMustBeAfterBegin();\n    error MarketEpochExists();\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable tokenInsured;\n    address private treasury;\n    int256 public immutable strikePrice;\n    address private immutable factory;\n    address public controller;\n\n    uint256[] public epochs;\n    uint256 public timewindow;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => uint256) public idFinalTVL;\n    mapping(uint256 => uint256) public idClaimTVL;\n    // @audit uint32 for timestamp is enough for the next 80 years\n    mapping(uint256 => uint256) public idEpochBegin;\n    // @audit id can be uint32\n    mapping(uint256 => bool) public idDepegged;\n    // @audit id can be uint32\n    mapping(uint256 => bool) public idExists;\n    mapping(uint256 => uint256) public epochFee;\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only factory addresses can call functions that use this modifier\n      */\n    modifier onlyFactory() {\n        if(msg.sender != factory)\n            revert AddressNotFactory(msg.sender);\n        _;\n    }\n\n    /** @notice Only controller addresses can call functions that use this modifier\n      */\n    modifier onlyController() {\n        if(msg.sender != controller)\n            revert AddressNotController(msg.sender);\n        _;\n    }\n\n    /** @notice Only market addresses can call functions that use this modifier\n      */\n    modifier marketExists(uint256 id) {\n        if(idExists[id] != true)\n            revert MarketEpochDoesNotExist();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier before the current epoch has started\n      */\n    modifier epochHasNotStarted(uint256 id) {\n        if(block.timestamp > idEpochBegin[id] - timewindow)\n            revert EpochAlreadyStarted();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier after the current epoch has started\n      */\n    modifier epochHasEnded(uint256 id) {\n        if((block.timestamp < id) && idDepegged[id] == false)\n            revert EpochNotFinished();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice constructor\n        @param  _assetAddress    token address representing your asset to be deposited;\n        @param  _name   token name for the ERC1155 mints. Insert the name of your token; Example: Y2K_USDC_1.2$\n        @param  _symbol token symbol for the ERC1155 mints. insert here if risk or hedge + Symbol. Example: HedgeY2K or riskY2K;\n        @param  _token  address of the oracle to lookup the price in chainlink oracles;\n        @param  _strikePrice    uint256 representing the price to trigger the depeg event;\n        @param _controller  address of the controller contract, this contract can trigger the depeg events;\n     */\n    constructor(\n        address _assetAddress,\n        string memory _name,\n        string memory _symbol,\n        address _treasury,\n        address _token,\n        int256 _strikePrice,\n        address _controller\n    ) SemiFungibleVault(ERC20(_assetAddress), _name, _symbol) {\n\n        if(_treasury == address(0))\n            revert AddressZero();\n\n        if(_controller == address(0))\n            revert AddressZero();\n\n        if(_token == address(0))\n            revert"
    }
  ]
}