{
  "Title": "[M-09] Rebasing tokens go to the pool owner, or remain locked in the various contracts",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L72-L77\n\n\n# Vulnerability details\n\nRebasing tokens are tokens that have each holder's `balanceof()` increase over time. Aave aTokens are an example of such tokens.\n\n## Impact\nUsers expect that when they deposit tokens to a pool, that they get back all rewards earned, not just a flat rate. With the contracts of this project, deposited tokens will grow in value, but the value in excess of the pre-calculated `getMaximumRewards()`/deposited amounts go solely to the owner/creator, or will remain locked in the contract\n\n## Proof of Concept\nIn the case of pools, the owner can withdraw the excess rebasing reward tokens by calling `withdrawExcessRewards()`, but is unable to withdraw excess deposited rebasing tokens. The Merkle-tree-related contracts have no way to withdraw any excess rebasing tokens.\n\nAll parts of the code assume that the value stated is the balance that is available to withdraw. It stores the values...\n\n```solidity\nFile: contracts/MerkleDropFactory.sol   #1\n\n72           // bookkeeping to make sure trees don't share tokens\n73           merkleTree.tokenBalance += value;\n74   \n75           // transfer tokens, if this is a malicious token, then this whole tree is malicious\n76           // but it does not effect the other trees\n77           require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L72-L77\n\n```solidity\nFile: contracts/MerkleResistor.sol   #2\n\n111           // bookkeeping to make sure trees do not share tokens\n112           merkleTree.tokenBalance += value;\n113   \n114           // do the transfer from the caller\n115           // NOTE: it is possible for user to overfund the tree and there is no mechanism to reclaim excess tokens\n116           // this is because there is no way for the contract to know when a tree has had all leaves claimed.\n117           // There is also no way for the contract to know the minimum or maximum liabilities represented by the leaves\n118           // in short, there is no on-chain inspection of any of the leaf data except at initialization time\n119           // NOTE: a malicious token contract could cause merkleTree.tokenBalance to be out of sync with the token contract\n120           // this is an unavoidable possibility, and it could render the tree unusable, while leaving other trees unharmed\n121           require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L111-L121\n\n```solidity\nFile: contracts/MerkleVesting.sol   #3\n\n84           // bookkeeping to make sure trees don't share tokens\n85           merkleTree.tokenBalance += value;\n86   \n87           // transfer tokens, if this is a malicious token, then this whole tree is malicious\n88           // but it does not effect the other trees\n89           require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L84-L89\n\n```solidity\nFile: contracts/PermissionlessBasicPoolFactory.sol   #4\n\n144               success = success && IERC20(pool.rewardTokens[i]).transferFrom(msg.sender, address(this), amount);\n145               // bookkeeping to make sure pools don't share tokens\n146               pool.rewardFunding[i] += amount;\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L144-L146\n\n```solidity\nFile: contracts/PermissionlessBasicPoolFactory.sol   #5\n\n194           receipt.amountDepositedWei = amount;\n195           receipt.timeDeposited = block.timestamp;\n196           receipt.owner = msg.sender;\n197   \n198           bool success = IERC20(pool.depositToken).transferFrom(msg.sender, address(this), amount);\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L194-L198\n\n...and attempts to withdraw the exact amount stored:\n\n```solidity\nFile: /contracts/MerkleDropFactory.sol   #6\n\n107           require(IERC20(tree.tokenAddress).transfer(destination, value), \"ERC20 transfer failed\");\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleDropFactory.sol#L107\n\n```solidity\nFile: /contracts/MerkleResistor.sol   #7\n\n204           require(IERC20(tree.tokenAddress).transfer(destination, currentWithdrawal), 'Token transfer failed');\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleResistor.sol#L204\n\n```solidity\nFile: /contracts/MerkleVesting.sol   #8\n\n173           IERC20(tree.tokenAddress).transfer(destination, currentWithdrawal);\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/MerkleVesting.sol#L173\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #9\n\n230               success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L230\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #10\n\n233           success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L233\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #11\n\n252               success = success && IERC20(pool.rewardTokens[i]).transfer(pool.excessBeneficiary, rewards);\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L252\n\n```solidity\nFile: /contracts/PermissionlessBasicPoolFactory.sol   #12\n\n269               success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax);\n```\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L269\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nProvide a function for the pool owner to withdraw excess deposited tokens and repay any associated taxes. In the case of the Merkle trees though, pro rata share amounts need to be calculated and tracked and updated with every withdrawal, which will require drastic changes to the code, making it much more expensive\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-factorydao-contest",
  "Code": [
    {
      "filename": "contracts/MerkleDropFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A factory pattern for merkledrops, that is, airdrops using merkleproofs to compute eligibility\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof,\n/// @dev therefore the total liabilities of the merkle tree are untrusted and tree balances must be managed separately\ncontract MerkleDropFactory {\n    using MerkleLib for bytes32;\n\n    // the number of airdrops in this contract\n    uint public numTrees = 0;\n\n    // this represents a single airdrop\n    struct MerkleTree {\n        bytes32 merkleRoot;  // merkleroot of tree whose leaves are (address,uint) pairs representing amount owed to user\n        bytes32 ipfsHash; // ipfs hash of entire dataset, as backup in case our servers turn off...\n        address tokenAddress; // address of token that is being airdropped\n        uint tokenBalance; // amount of tokens allocated for this tree\n        uint spentTokens; // amount of tokens dispensed from this tree\n    }\n\n    // withdrawn[recipient][treeIndex] = hasUserWithdrawnAirdrop\n    mapping (address => mapping (uint => bool)) public withdrawn;\n\n    // array-like map for all ze merkle trees (airdrops)\n    mapping (uint => MerkleTree) public merkleTrees;\n\n    // every time there's a withdraw\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint value);\n\n    // every time a tree is added\n    event MerkleTreeAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\n\n    // every time a tree is topped up\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\n\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-drop\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\n    /// @param newRoot root hash of merkle tree representing liabilities == (destination, value) pairs\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\n    /// @param tokenAddress the address of the token contract that is being distributed\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n        // prefix operator ++ increments then evaluates\n        merkleTrees[++numTrees] = MerkleTree(\n            newRoot,\n            ipfsHash,\n            tokenAddress,\n            0,  // ain't no tokens in here yet\n            0   // ain't nobody claimed no tokens yet either\n        );\n        // you don't get to add a tree without funding it\n        depositTokens(numTrees, tokenBalance);\n        // I guess we should tell people (interfaces) what happened\n        emit MerkleTreeAdded(numTrees, tokenAddress, newRoot, ipfsHash);\n    }\n\n    /// @notice Add funds to an existing merkle-drop\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n\n    /// @notice Claim funds as a recipient in the merkle-drop\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\n    /// @param destination recipient of tokens\n    /// @param value amount of tokens that will be sent to destination\n    /// @param proof array of hashes bridging from leaf (hash of destination | value) to merkle root\n    function withdraw(uint treeIndex, address destination, uint value, bytes32[] memory proof) public {\n        // no withdrawing from uninitialized merkle trees\n        require(treeIndex <= numTrees, \"Provided merkle index doesn't exist\");\n        // no withdrawing same airdrop twice\n        require(!withdrawn[destination][treeIndex], \"You have already withdrawn your entitled token.\");\n        // compute merkle leaf, this is first element of proof\n        bytes32 leaf = keccak256(abi.encode(destination, value));\n        // storage because we edit\n        MerkleTree storage tree = merkleTrees[treeIndex];\n        // this calls to MerkleLib, will return false if recursive hashes do not end in merkle root\n        require(tree.merkleRoot.verifyProof(leaf, proof), \"The proof could not be verified.\");\n        // close re-entrance gate, prevent double claims\n        withdrawn[destination][treeIndex] = true;\n        // update struct\n        tree.tokenBalance -= value;\n        tree.spentTokens += value;\n        // transfer the tokens\n        // NOTE: if the token contract is malicious this call could re-enter this function\n        // which will fail because withdrawn will be set to true\n        require(IERC20(tree.tokenAddress).transfer(destination, value), \"ERC20 transfer failed\");\n        emit WithdrawalOccurred(treeIndex, destination, value);\n    }\n\n}"
    }
  ]
}