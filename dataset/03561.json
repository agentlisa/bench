{
  "Title": "[L17] Not using safeTransfer",
  "Content": "The [`Flipper` contract](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/flipper/Flipper.sol#L14) allows users to exchange OUSD 1:1 for any of DAI, USDC, or USDT and vice versa as a low cost way to perform swaps. Although the [`withdraw` functions](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/flipper/Flipper.sol#L99-L116) use `safeTransfer`, none of the [other `transfer` functions](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/flipper/Flipper.sol#L38-L39) in the Flipper contracts use `safeTransfer`.\n\n\nConsider always using `safeTransfer` as a best practice.\n\n\n**Update:** *Acknowledged. The Origin team states:*\n\n\n\n> The flipper contract uses hard-coded token addresses, and does not support adding tokens without deploying a new contract. For the swaps, each token has the correct interface for it, with USDT in particular using their own returnless transfers. We do use `safeTransfer` on methods that can operate on arbitrary tokens. Weâ€™re going to keep this as is, since the focus on this contract is extremely low gas usage for small swaps.\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/flipper/Flipper.sol",
      "content": "pragma solidity 0.5.11;\n\nimport \"../governance/Governable.sol\";\nimport \"../token/OUSD.sol\";\nimport \"../interfaces/Tether.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n// Contract to exchange usdt, usdc, dai from and to ousd.\n//   - 1 to 1. No slippage\n//   - Optimized for low gas usage\n//   - No guarantee of availability\n\ncontract Flipper is Governable {\n    using SafeERC20 for IERC20;\n\n    uint256 constant MAXIMUM_PER_TRADE = (25000 * 1e18);\n\n    // Saves approx 4K gas per swap by using hardcoded addresses.\n    IERC20 dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    OUSD constant ousd = OUSD(0x2A8e1E676Ec238d8A992307B495b45B3fEAa5e86);\n    IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    Tether constant usdt = Tether(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n\n    // -----------\n    // Constructor\n    // -----------\n    constructor() public {}\n\n    // -----------------\n    // Trading functions\n    // -----------------\n\n    /// @notice Purchase OUSD with Dai\n    /// @param amount Amount of OUSD to purchase, in 18 fixed decimals.\n    function buyOusdWithDai(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(dai.transferFrom(msg.sender, address(this), amount));\n        require(ousd.transfer(msg.sender, amount));\n    }\n\n    /// @notice Sell OUSD for Dai\n    /// @param amount Amount of OUSD to sell, in 18 fixed decimals.\n    function sellOusdForDai(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(dai.transfer(msg.sender, amount));\n        require(ousd.transferFrom(msg.sender, address(this), amount));\n    }\n\n    /// @notice Purchase OUSD with USDC\n    /// @param amount Amount of OUSD to purchase, in 18 fixed decimals.\n    function buyOusdWithUsdc(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // Potential rounding error is an intentional tradeoff\n        require(usdc.transferFrom(msg.sender, address(this), amount / 1e12));\n        require(ousd.transfer(msg.sender, amount));\n    }\n\n    /// @notice Sell OUSD for USDC\n    /// @param amount Amount of OUSD to sell, in 18 fixed decimals.\n    function sellOusdForUsdc(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(usdc.transfer(msg.sender, amount / 1e12));\n        require(ousd.transferFrom(msg.sender, address(this), amount));\n    }\n\n    /// @notice Purchase OUSD with USDT\n    /// @param amount Amount of OUSD to purchase, in 18 fixed decimals.\n    function buyOusdWithUsdt(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // Potential rounding error is an intentional tradeoff\n        // USDT does not return a boolean and reverts,\n        // so no need for a require.\n        usdt.transferFrom(msg.sender, address(this), amount / 1e12);\n        require(ousd.transfer(msg.sender, amount));\n    }\n\n    /// @notice Sell OUSD for USDT\n    /// @param amount Amount of OUSD to sell, in 18 fixed decimals.\n    function sellOusdForUsdt(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // USDT does not return a boolean and reverts,\n        // so no need for a require.\n        usdt.transfer(msg.sender, amount / 1e12);\n        require(ousd.transferFrom(msg.sender, address(this), amount));\n    }\n\n    // --------------------\n    // Governance functions\n    // --------------------\n\n    /// @dev Opting into yield reduces the gas cost per transfer by about 4K, since\n    /// ousd needs to do less accounting and one less storage write.\n    function rebaseOptIn() external onlyGovernor nonReentrant {\n        ousd.rebaseOptIn();\n    }\n\n    /// @notice Owner function to withdraw a specific amount of a token\n    function withdraw(address token, uint256 amount)\n        external\n        onlyGovernor\n        nonReentrant\n    {\n        IERC20(token).safeTransfer(_governor(), amount);\n    }\n\n    /// @notice Owner function to withdraw all tradable tokens\n    /// @dev Equivalent to \"pausing\" the contract.\n    function withdrawAll() external onlyGovernor nonReentrant {\n        IERC20(dai).safeTransfer(_governor(), dai.balanceOf(address(this)));\n        IERC20(ousd).safeTransfer(_governor(), ousd.balanceOf(address(this)));\n        IERC20(address(usdt)).safeTransfer(\n            _governor(),\n            usdt.balanceOf(address(this))\n        );\n        IERC20(usdc).safeTransfer(_governor(), usdc.balanceOf(address(this)));\n    }\n}"
    }
  ]
}