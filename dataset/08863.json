{
  "Title": "[M-06] Minter.sol#_executeInflationRateUpdate() inflationManager().checkpointAllGauges() is called after InflationRate is updated, causing users to lose rewards",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215\n\n\n# Vulnerability details\n\nWhen `Minter.sol#_executeInflationRateUpdate()` is called, if an `_INFLATION_DECAY_PERIOD` has past since `lastInflationDecay`, it will update the InflationRate for all of the gauges.\n\nHowever, in the current implementation, the rates will be updated first, followed by the rewards being settled using the new rates on the gauges using `inflationManager().checkpointAllGauges()`.\n\nIf the `_INFLATION_DECAY_PERIOD` has passed for a long time before `Minter.sol#executeInflationRateUpdate()` is called, the users may lose a significant amount of rewards.\n\nOn a side note, `totalAvailableToNow` is updated correctly.\n\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215\n\n```solidity\nfunction _executeInflationRateUpdate() internal returns (bool) {\n    totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));\n    lastEvent = block.timestamp;\n    if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {\n        currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);\n        if (initialPeriodEnded) {\n            currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(\n                annualInflationDecayKeeper\n            );\n            currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(\n                annualInflationDecayAmm\n            );\n        } else {\n            currentInflationAmountKeeper =\n                initialAnnualInflationRateKeeper /\n                _INFLATION_DECAY_PERIOD;\n\n            currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;\n            initialPeriodEnded = true;\n        }\n        currentTotalInflation =\n            currentInflationAmountLp +\n            currentInflationAmountKeeper +\n            currentInflationAmountAmm;\n        controller.inflationManager().checkpointAllGauges();\n        lastInflationDecay = block.timestamp;\n    }\n    return true;\n}\n```\n\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L110-L125\n\n```solidity\nfunction checkpointAllGauges() external override returns (bool) {\n    uint256 length = _keeperGauges.length();\n    for (uint256 i; i < length; i = i.uncheckedInc()) {\n        IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();\n    }\n    address[] memory stakerVaults = addressProvider.allStakerVaults();\n    for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {\n        IStakerVault(stakerVaults[i]).poolCheckpoint();\n    }\n\n    length = _ammGauges.length();\n    for (uint256 i; i < length; i = i.uncheckedInc()) {\n        IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();\n    }\n    return true;\n}\n```\n\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L110-L117\n\n```solidity\nfunction poolCheckpoint() public override returns (bool) {\n    if (killed) return false;\n    uint256 timeElapsed = block.timestamp - uint256(lastUpdated);\n    uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);\n    perPeriodTotalInflation[epoch] += currentRate * timeElapsed;\n    lastUpdated = uint48(block.timestamp);\n    return true;\n}\n```\n\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L507-L519\n\n```solidity\nfunction getKeeperRateForPool(address pool) external view override returns (uint256) {\n    if (minter == address(0)) {\n        return 0;\n    }\n    uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();\n    // After deactivation of weight based dist, KeeperGauge handles the splitting\n    if (weightBasedKeeperDistributionDeactivated) return keeperInflationRate;\n    if (totalKeeperPoolWeight == 0) return 0;\n    bytes32 key = _getKeeperGaugeKey(pool);\n    uint256 poolInflationRate = (currentUInts256[key] * keeperInflationRate) /\n        totalKeeperPoolWeight;\n    return poolInflationRate;\n}\n```\n\n\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L173-L176\n\n```solidity\n    function getKeeperInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountKeeper;\n    }\n```\n\n### PoC\n\nGiven:\n\n- currentInflationAmountAmm: 12,000 Bkd (1000 per month)\n- annualInflationDecayAmm: 50%\n- initialPeriodEnded: true\n- lastInflationDecay: 11 months ago\n- _INFLATION_DECAY_PERIOD: 1 year\n\n1. Alice deposited as the one and only staker in the `AmmGauge` pool;\n2. 1 month later;\n3. `Minter.sol#_executeInflationRateUpdate()` is called;\n4. Alice `claimableRewards()` and received `500` Bkd tokens.\n\nExpected Results:\n\n- Alice to receive `1000` Bkd tokens as rewards.\n\nActual Results:\n\n- Alice received `500` Bkd tokens as rewards.\n\n### Recommendation\n\nConsider moving the call to `checkpointAllGauges()` to before the `currentInflationAmountKeeper` is updated.\n\n```solidity\nfunction _executeInflationRateUpdate() internal returns (bool) {\n    totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));\n    lastEvent = block.timestamp;\n    if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {\n        controller.inflationManager().checkpointAllGauges();\n        currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);\n        if (initialPeriodEnded) {\n            currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(\n                annualInflationDecayKeeper\n            );\n            currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(\n                annualInflationDecayAmm\n            );\n        } else {\n            currentInflationAmountKeeper =\n                initialAnnualInflationRateKeeper /\n                _INFLATION_DECAY_PERIOD;\n\n            currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;\n            initialPeriodEnded = true;\n        }\n        currentTotalInflation =\n            currentInflationAmountLp +\n            currentInflationAmountKeeper +\n            currentInflationAmountAmm;\n        lastInflationDecay = block.timestamp;\n    }\n    return true;\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/tokenomics/Minter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/IBkdToken.sol\";\nimport \"../../interfaces/tokenomics/IMinter.sol\";\n\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"./BkdToken.sol\";\nimport \"../access/Authorization.sol\";\n\ncontract Minter is IMinter, Authorization, ReentrancyGuard {\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    uint256 private constant _INFLATION_DECAY_PERIOD = 365 days;\n\n    // Lp Rates\n    uint256 public immutable initialAnnualInflationRateLp;\n    uint256 public immutable annualInflationDecayLp;\n    uint256 public currentInflationAmountLp;\n\n    // Keeper Rates\n    uint256 public immutable initialPeriodKeeperInflation;\n    uint256 public immutable initialAnnualInflationRateKeeper;\n    uint256 public immutable annualInflationDecayKeeper;\n    uint256 public currentInflationAmountKeeper;\n\n    // AMM Rates\n    uint256 public immutable initialPeriodAmmInflation;\n    uint256 public immutable initialAnnualInflationRateAmm;\n    uint256 public immutable annualInflationDecayAmm;\n    uint256 public currentInflationAmountAmm;\n\n    bool public initialPeriodEnded;\n\n    // Non-inflation rates\n    uint256 public immutable nonInflationDistribution;\n    uint256 public issuedNonInflationSupply;\n\n    uint256 public lastInflationDecay;\n    uint256 public currentTotalInflation;\n\n    // Used for final safety check to ensure inflation is not exceeded\n    uint256 public totalAvailableToNow;\n    uint256 public totalMintedToNow;\n    uint256 public lastEvent;\n\n    IController public immutable controller;\n    BkdToken public token;\n\n    event TokensMinted(address beneficiary, uint256 amount);\n\n    constructor(\n        uint256 _annualInflationRateLp,\n        uint256 _annualInflationRateKeeper,\n        uint256 _annualInflationRateAmm,\n        uint256 _annualInflationDecayLp,\n        uint256 _annualInflationDecayKeeper,\n        uint256 _annualInflationDecayAmm,\n        uint256 _initialPeriodKeeperInflation,\n        uint256 _initialPeriodAmmInflation,\n        uint256 _nonInflationDistribution,\n        IController _controller\n    ) Authorization(_controller.addressProvider().getRoleManager()) {\n        require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        initialAnnualInflationRateLp = _annualInflationRateLp;\n        initialAnnualInflationRateKeeper = _annualInflationRateKeeper;\n        initialAnnualInflationRateAmm = _annualInflationRateAmm;\n\n        annualInflationDecayLp = _annualInflationDecayLp;\n        annualInflationDecayKeeper = _annualInflationDecayKeeper;\n        annualInflationDecayAmm = _annualInflationDecayAmm;\n\n        initialPeriodKeeperInflation = _initialPeriodKeeperInflation;\n        initialPeriodAmmInflation = _initialPeriodAmmInflation;\n\n        currentInflationAmountLp = _annualInflationRateLp / _INFLATION_DECAY_PERIOD;\n        currentInflationAmountKeeper = _initialPeriodKeeperInflation / _INFLATION_DECAY_PERIOD;\n        currentInflationAmountAmm = _initialPeriodAmmInflation / _INFLATION_DECAY_PERIOD;\n\n        currentTotalInflation =\n            currentInflationAmountLp +\n            currentInflationAmountKeeper +\n            currentInflationAmountAmm;\n\n        nonInflationDistribution = _nonInflationDistribution;\n        controller = _controller;\n    }\n\n    function setToken(address _token) external override onlyGovernance {\n        require(address(token) == address(0), \"Token already set!\");\n        token = BkdToken(_token);\n    }\n\n    function startInflation() external override onlyGovernance {\n        require(lastEvent == 0, \"Inflation has already started.\");\n        lastEvent = block.timestamp;\n        lastInflationDecay = block.timestamp;\n    }\n\n    /**\n     * @notice Update the inflation rate according to the piecewise linear schedule.\n     * @dev This updates the inflation rate to the next linear segment in the inflations schedule.\n     * @return `true` if successful.\n     */\n    function executeInflationRateUpdate() external override returns (bool) {\n        return _executeInflationRateUpdate();\n    }\n\n    /**\n     * @notice Mints BKD tokens to a specified address.\n     * @dev Can only be called by the controller.\n     * @param beneficiary Address to mint tokens for.\n     * @param amount Amount of tokens to mint.\n     * @return `true` if successful.\n     */\n    function mint(address beneficiary, uint256 amount)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        if (lastEvent == 0) return false;\n        return _mint(beneficiary, amount);\n    }\n\n    /**\n     * @notice Mint tokens that are not part of the inflation schedule.\n     * @dev The amount of tokens that can be minted in total is subject to a pre-set upper limit.\n     * @param beneficiary Address to mint tokens for.\n     * @param amount Amount of tokens to mint.\n     * @return `true` if successful.\n     */\n    function mintNonInflationTokens(address beneficiary, uint256 amount)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            issuedNonInflationSupply + amount <= nonInflationDistribution,\n            \"Maximum non-inflation amount exceeded.\"\n        );\n        issuedNonInflationSupply += amount;\n        token.mint(beneficiary, amount);\n        emit TokensMinted(beneficiary, amount);\n        return true;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for LPs per unit of time (seconds).\n     * @return LP inflation rate.\n     */\n    function getLpInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountLp;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for keepers per unit of time (seconds).\n     * @return keeper inflation rate.\n     */\n    function getKeeperInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountKeeper;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for LPs on AMMs per unit of time (seconds).\n     * @return AMM inflation rate.\n     */\n    function getAmmInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountAmm;\n    }\n\n    function _executeInflationRateUpdate() internal returns (bool) {\n        totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));\n        lastEvent = block.timestamp;\n        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {\n            currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);\n            if (initialPeriodEnded) {\n                currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(\n                    annualInflationDecayKeeper\n                );\n                currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(\n                    annualInflationDecayAmm\n                );\n            } else {\n                currentInflationAmountKeeper =\n                    initialAnnualInflationRateKeeper /\n                    _INFLATION_DECAY_PERIOD;\n\n                currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;\n                initialPeriodEnded = true;\n            }\n            currentTotalInflation =\n                currentInflationAmountLp +\n                currentInflationAmountKeeper +\n                currentInflationAmountAmm;\n            controller.inflationManager().checkpointAllGauges();\n            lastInflationDecay = block.timestamp;\n        }\n        return true;\n    }\n\n    function _mint(address beneficiary, uint256 amount) internal returns (bool) {\n        totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);\n        uint256 newTotalMintedToNow = totalMintedToNow + amount;\n        require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");\n        totalMintedToNow = newTotalMintedToNow;\n        lastEvent = block.timestamp;\n        token.mint(beneficiary, amount);\n        _executeInflationRateUpdate();\n        emit TokensMinted(beneficiary, amount);\n        return true;\n    }\n}"
    }
  ]
}