{
  "Title": "[L05] Check backwards-compatibility throws for versions 10 and above",
  "Content": "The [`fromGetVersionNumberReturnValue` function of the `ContractVersion` `class`](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/compatibility/version.ts#L36) converts each version component from `Buffer` to a hex `string` representation to return a `ContractVersion` object using its [`fromString`](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/compatibility/version.ts#L46) method. The `fromString` method [throws](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/compatibility/version.ts#L14) within the call to [`isValid`](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/lib/compatibility/version.ts#L20) if the conversion of `versionComponent` using [`Number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) is `NaN`. The `Number` wrapper object returns `NaN` on string representations of integers containing non-decimal characters. \n\n\nThis means that checking backward compatibility will throw for most versions having a component greater than 9, since non-decimal hexadecimal digits such as `a` or `f` may be present in the hex representation of a version component.\n\n\nConsider forming a string of joined decimal representations of the components to be input of the `fromString` method.\n\n\n**Update**: *Fixed in [PR#6487](https://github.com/celo-org/celo-monorepo/pull/6487)*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/lib/compatibility/version.ts",
      "content": "// tslint:disable: max-classes-per-file\nexport const DEFAULT_VERSION_STRING = '1.1.0.0'\n\nexport class ContractVersion {\n\n  static isValid = (version: string): boolean => {\n    const v = version.split(\".\")\n    if (v.length !== 4) {\n      return false\n    }\n\n    const isNonNegativeNumber = (versionComponent): boolean => {\n      const number = Number(versionComponent)\n      return !isNaN(number) && number >= 0\n    }\n    return v.every(isNonNegativeNumber)\n  }\n\n  static fromString = (version: string): ContractVersion => {\n    if (!ContractVersion.isValid(version)) {\n      throw new Error(`Invalid version format: ${version}`)\n    }\n    const v = version.split(\".\")\n    return new ContractVersion(\n      Number(v[0]),\n      Number(v[1]),\n      Number(v[2]),\n      Number(v[3])\n    )\n  }\n\n  /**\n   * @param version A 256 byte buffer containing the 32 byte storage, major, minor, and patch\n   * version numbers.\n   */\n  static fromGetVersionNumberReturnValue = (version: Buffer): ContractVersion => {\n    if (version.length !== 4 * 32) {\n      throw new Error(`Invalid version buffer: ${version.toString('hex')}`)\n    }\n    const versions = [\n      version.slice(0, 32),  // Storage\n      version.slice(32, 64), // Major\n      version.slice(64, 96), // Minor\n      version.slice(96, 128) // Patch\n    ]\n    return ContractVersion.fromString(versions.map((x) => x.toString('hex')).join('.'))\n  }\n\n  constructor(\n    public readonly storage: number,\n    public readonly major: number,\n    public readonly minor: number,\n    public readonly patch: number) {}\n\n  public toString = () : string => {\n    const deltas = [this.storage, this.major, this.minor, this.patch]\n    return deltas.join('.')\n  }\n}\n\nexport enum Delta {\n  None = \"=\",\n  Increment = \"+1\",\n  Reset = \"0\"\n}\n\nexport class DeltaUtil {\n\n  static applyToNumber = (delta: Delta, n: number): number => {\n    if (delta === Delta.None) {\n      return n\n    }\n    if (delta === Delta.Reset) {\n      return 0\n    }\n    if (delta === Delta.Increment) {\n      return n + 1\n    }\n    throw new Error(`Unexpected Delta instance: ${delta}`)\n  }\n}\n\nexport class ContractVersionDelta {\n\n  static fromChanges = (\n    storageChanged: boolean,\n    majorChanged: boolean,\n    minorChanged: boolean,\n    patchChanged: boolean): ContractVersionDelta => {\n    const r = Delta.Reset\n    const n = Delta.None\n    if (storageChanged) {\n      return new ContractVersionDelta(Delta.Increment, r, r, r)\n    }\n    if (majorChanged) {\n      return new ContractVersionDelta(n, Delta.Increment, r, r)\n    }\n    if (minorChanged) {\n      return new ContractVersionDelta(n, n, Delta.Increment, r)\n    }\n    if (patchChanged) {\n      return new ContractVersionDelta(n, n, n, Delta.Increment)\n    }\n    return new ContractVersionDelta(n, n, n, n)\n  }\n\n  constructor(\n    public readonly storage: Delta,\n    public readonly major: Delta,\n    public readonly minor: Delta,\n    public readonly patch: Delta) {}\n\n  appliedTo = (version: ContractVersion): ContractVersion => {\n    return new ContractVersion(\n      DeltaUtil.applyToNumber(this.storage, version.storage),\n      DeltaUtil.applyToNumber(this.major, version.major),\n      DeltaUtil.applyToNumber(this.minor, version.minor),\n      DeltaUtil.applyToNumber(this.patch, version.patch)\n      )\n  }\n\n  public toString = () : string => {\n    const deltas = [this.storage, this.major, this.minor, this.patch]\n    return deltas.map(d => d.toString()).join('.')\n  }\n}\n\n/**\n * A mapping {contract name => {@link ContractVersionDelta}}.\n */\nexport interface ContractVersionDeltaIndex {\n  [contract: string]: ContractVersionDelta\n}\n\n/**\n * A mapping {contract name => {@link ContractVersion}}.\n */\nexport interface ContractVersionIndex {\n  [contract: string]: ContractVersion;\n}\n\n/**\n * A version checker for a specific contract.\n */\nexport class ContractVersionChecker {\n  constructor(public readonly oldVersion: ContractVersion, public readonly newVersion: ContractVersion, public readonly expectedDelta: ContractVersionDelta) {}\n\n  public expectedVersion = (): ContractVersion => {\n    if (this.oldVersion === null) {\n      // Newly added contracts should have version 1.1.0.0\n      return ContractVersion.fromString(DEFAULT_VERSION_STRING)\n    } else { \n      return this.expectedDelta.appliedTo(this.oldVersion)\n    }\n  }\n\n  public matches = (): boolean => {\n    return this.newVersion.toString() === this.expectedVersion().toString()\n  }\n}\n\n/**\n * A mapping {contract name => {@link ContractVersionChecker}}.\n */\nexport interface ContractVersionCheckerIndex {\n  [contract: string]: ContractVersionChecker\n}"
    }
  ]
}