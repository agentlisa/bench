{
  "Title": "[H-02] Budget cap will not account for transfers of approved or permitted ERC20 tokens",
  "Content": "`ApprovalVotingModule.sol` contains a feature where the governor can input a `budgetToken` and a `budgetAmount`, and the module ensures that passed proposals cannot spend more than this amount of this token.\n\nThis check occurs in `_formatExecuteParams()`. In this function, we loop over all of the transaction options that met the criteria, tally up the amount of budget token spent, and break the loop if the amount spent crosses the budget.\n\nIt is implemented as follows:\n\n```solidity\nfor (n = 0; n < option.targets.length;) {\n// Shortcircuit if `budgetAmount` is exceeded\nif (settings.budgetAmount != 0) {\nif (settings.budgetToken == address(0)) {\n// If `budgetToken` is ETH and value is not zero, add msg value to `totalValue`\nif (option.values[n] != 0) totalValue += option.values[n];\n} else {\n// If `target` is `budgetToken` and calldata is not zero\nif (settings.budgetToken == option.targets[n]) {\nbytes memory data = option.calldatas[n];\nif (data.length != 0) {\nuint256 amount;\n// If it's a `transfer` or `transferFrom`, add `amount` to `totalValue`\nif (bytes4(data) == IERC20.transfer.selector) {\nassembly {\n// Load the last 32 bytes of `data` into 'amount'\namount := mload(add(data, 0x44))\n}\n} else if (bytes4(data) == IERC20.transferFrom.selector) {\nassembly {\n// Load the last 32 bytes of `data` into 'amount'\namount := mload(add(data, 0x64))\n}\n}\nif (amount != 0) totalValue += amount;\n}\n}\n}\n\n// Break loop if `budgetAmount` is exceeded\nif (totalValue > settings.budgetAmount) break;\n}\n\nunchecked {\nexecuteParams[executeParamsLength + n] =\nExecuteParams(option.targets[n], option.values[n], option.calldatas[n]);\n\n++n;\n}\n}\n```\n\n[ApprovalVotingModule.sol#L206-L284](https://github.com/voteagora/optimism-gov/blob/35f441738bd7864bd37949a40842486bc0ac51b0/src/modules/ApprovalVotingModule.sol#L206-L284)\n\nFor ERC20 tokens, this code increments the `totalValue` only when the following conditions are met:\n\n- the `target` for the transaction is the ERC20 token itself\n- the function selector is `transfer()` or `transferFrom()`\n\nHowever, these conditions do not succeed in accomplishing their goal. Most importantly, they miss two extremely common patterns for ERC20 transfers. Additionally, they may count spent tokens that should not be.\n\n1. `approve()` & `transferFrom()`: The most common way for contracts to interact with other contracts that require ERC20 tokens for payment is to first call `approve()` and then call a function on the other contract, which calls `transferFrom()`. In this case, because the first call is using the `approve()` selector and the second is to another contract, `totalValue` will not be incremented.\n\n2. `permit()`: An alternative rising in popularity is the `permit()` method, which allows passing a signature to another contract that can be used to first approve transfers on your behalf, and then perform `transferFrom()`. Such a function call will not interact with the ERC20 directly at all, so will not trigger the budget incrementer.\n\n3. non-spending `transferFrom()`: The budget count is currently triggered when the contract calls `transferFrom()` on the `budgetToken`, but in many cases, this could be transferring the tokens of another user, not the contract itself. In this case, the `totalValue` would be incremented by the amount sent, which is most likely not the intended behavior.\n\n**Recommendations**\n\nThis is a tricky problem without a clear solution. Of course, we could simply check the balance before and after relative to the budget, but this would have the effect of reverting the whole proposal if the budget was exceeded. It is preferable to have only the transactions that push the proposal over the budget to revert.\n\nMy original recommendation was to remove this feature. However, it was made clear that this feature is not optional.\n\nThe best solution I can think of it to have the proposer include an amount that is expected to be spent for each transaction, and then to verify that they were honest after execution is completed.\n\nThis could be performed as follows:\n\n- Check the initial balance of the ERC20 before beginning execution.\n- Have the proposal include a `tokenBudget` for each action.\n- Tally up these `tokenBudget` values, and reject any push the total over the `budgetAmount`.\n- After the proposal has been executed, check the final balance of the ERC20, and ensure that it hasn't fallen by more than it should have based on the sum of `tokenBudget`s.\n\nWhile this solution is not exactly perfect (as it has the potential be gamed by a proposer who wants additional transactions to revert that doesn't exceed the cap), it does serve the expressed purpose of imposing an informal budget cap on proposals.\n\n**Review**\n\nFixed as recommended in [39880bd56c99a83b5df3fafbc3c6d35f104a1cda](https://github.com/voteagora/optimism-gov/commit/39880bd56c99a83b5df3fafbc3c6d35f104a1cda).",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/modules/ApprovalVotingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {VotingModule} from \"./VotingModule.sol\";\nimport {SafeCastLib} from \"@solady/utils/SafeCastLib.sol\";\n\nenum VoteType {\n    For,\n    Abstain\n}\n\nenum PassingCriteria {\n    Threshold,\n    TopChoices\n}\n\nstruct ExecuteParams {\n    address targets;\n    uint256 values;\n    bytes calldatas;\n}\n\nstruct ProposalVotes {\n    uint128 forVotes;\n    uint128 abstainVotes;\n}\n\nstruct ProposalSettings {\n    uint8 maxApprovals;\n    uint8 criteria;\n    address budgetToken;\n    uint128 criteriaValue;\n    uint128 budgetAmount;\n}\n\nstruct ProposalOption {\n    address[] targets;\n    uint256[] values;\n    bytes[] calldatas;\n    string description;\n}\n\nstruct Proposal {\n    address governor;\n    uint128[] optionVotes;\n    ProposalVotes votes;\n    ProposalOption[] options;\n    ProposalSettings settings;\n}\n\ncontract ApprovalVotingModule is VotingModule {\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MaxChoicesExceeded();\n    error MaxApprovalsExceeded();\n    error OptionsNotStrictlyAscending();\n\n    /*//////////////////////////////////////////////////////////////\n                               LIBRARIES\n    //////////////////////////////////////////////////////////////*/\n\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                           IMMUTABLE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * Defines the encoding for the expected `proposalData` in `propose`.\n     * Encoding: `(ProposalOption[], ProposalSettings)`\n     *\n     * @dev Can be used by clients to interact with modules programmatically without prior knowledge\n     * on expected types.\n     */\n    string public constant override PROPOSAL_DATA_ENCODING =\n        \"((address[] targets,uint256[] values,bytes[] calldatas,string description)[] proposalOptions,(uint8 maxApprovals,uint8 criteria,address budgetToken,uint128 criteriaValue,uint128 budgetAmount) proposalSettings)\";\n\n    /**\n     * Defines the encoding for the expected `params` in `_countVote`.\n     * Encoding: `uint256[]`\n     *\n     * @dev Can be used by clients to interact with modules programmatically without prior knowledge\n     * on expected types.\n     */\n    string public constant override VOTE_PARAMS_ENCODING = \"uint256[] options\";\n\n    /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 proposalId => Proposal) public _proposals;\n    mapping(uint256 proposalId => mapping(address account => uint8 votes)) public _accountVotes;\n\n    /*//////////////////////////////////////////////////////////////\n                            WRITE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * Save settings and options for a new proposal.\n     *\n     * @param proposalId The id of the proposal.\n     * @param proposalData The proposal data encoded as `PROPOSAL_DATA_ENCODING`.\n     */\n    function propose(uint256 proposalId, bytes memory proposalData) external override {\n        if (_proposals[proposalId].governor != address(0)) revert ExistingProposal();\n\n        (ProposalOption[] memory proposalOptions, ProposalSettings memory proposalSettings) =\n            abi.decode(proposalData, (ProposalOption[], ProposalSettings));\n\n        uint256 optionsLength = proposalOptions.length;\n        if (optionsLength == 0 || optionsLength > type(uint8).max) revert InvalidParams();\n        if (proposalSettings.criteria == uint8(PassingCriteria.TopChoices)) {\n            if (proposalSettings.criteriaValue > optionsLength) revert MaxChoicesExceeded();\n        }\n\n        unchecked {\n            // Ensure proposal params of each option have the same length between themselves\n            ProposalOption memory option;\n            for (uint256 i; i < optionsLength; ++i) {\n                option = proposalOptions[i];\n                if (option.targets.length != option.values.length || option.targets.length != option.calldatas.length) {\n                    revert InvalidParams();\n                }\n            }\n\n            // Push proposal options in storage\n            for (uint256 i; i < optionsLength; ++i) {\n                _proposals[proposalId].options.push(proposalOptions[i]);\n            }\n        }\n\n        _proposals[proposalId].governor = msg.sender;\n        _proposals[proposalId].settings = proposalSettings;\n        _proposals[proposalId].optionVotes = new uint128[](optionsLength);\n    }\n\n    /**\n     * Count approvals voted by `account`. If voting for, options need to be set in ascending order.\n     *\n     * @param proposalId The id of the proposal.\n     * @param account The account to count votes for.\n     * @param support The type of vote to count. 0 = For, 1 = Abstain.\n     * @param weight The weight of the vote.\n     * @param params The ids of the options to vote for sorted in ascending order, encoded as `uint256[]`.\n     */\n    function _countVote(uint256 proposalId, address account, uint8 support, uint256 weight, bytes memory params)\n        external\n        override\n    {\n        Proposal memory proposal = _proposals[proposalId];\n        _onlyGovernor(proposal.governor);\n\n        if (hasVoted(proposalId, account)) revert VoteAlreadyCast();\n\n        uint128 weight_ = weight.toUint128();\n\n        if (support == uint8(VoteType.For)) {\n            uint256[] memory options = abi.decode(params, (uint256[]));\n            uint256 totalOptions = options.length;\n            if (totalOptions == 0) revert InvalidParams();\n            if (totalOptions > proposal.settings.maxApprovals) revert MaxApprovalsExceeded();\n\n            uint256 option;\n            uint256 prevOption;\n            for (uint256 i; i < totalOptions;) {\n                option = options[i];\n\n                // Revert if `option` is not strictly ascending\n                if (i != 0) {\n                    if (option <= prevOption) revert OptionsNotStrictlyAscending();\n                }\n\n                prevOption = option;\n\n                /// @dev Revert if `option` is out of bounds\n                _proposals[proposalId].optionVotes[option] += weight_;\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            /// @dev `totalOptions` cannot overflow uint8 as it is checked against `maxApprovals`\n            _accountVotes[proposalId][account] = uint8(totalOptions);\n            _proposals[proposalId].votes.forVotes += weight_;\n        } else if (support == uint8(VoteType.Abstain)) {\n            _accountVotes[proposalId][account] = 1;\n            _proposals[proposalId].votes.abstainVotes += weight_;\n        } else {\n            revert InvalidVoteType();\n        }\n    }\n\n    /**\n     * Format executeParams for a governor, given `proposalId` and `proposalData`.\n     *\n     * @param proposalId The id of the proposal.\n     * @param proposalData The proposal data encoded as `(ProposalOption[], ProposalSettings)`.\n     * @return targets The targets of the proposal.\n     * @return values The values of the proposal.\n     * @return calldatas The calldatas of the proposal.\n     */\n    function _formatExecuteParams(uint256 proposalId, bytes memory proposalData)\n        public\n        view\n        override\n        returns (address[] memory targets, uint256[] memory values, bytes[] memory calldatas)\n    {\n        _onlyGovernor(_proposals[proposalId].governor);\n\n        (ProposalOption[] memory options, ProposalSettings memory settings) =\n            abi.decode(proposalData, (ProposalOption[], ProposalSettings));\n\n        (uint128[] memory sortedOptionVotes, ProposalOption[] memory sortedOptions) =\n            _sortOptions(_proposals[proposalId].optionVotes, options);\n\n        (uint256 executeParamsLength, uint256 succeededOptionsLength) =\n            _countOptions(sortedOptions, sortedOptionVotes, settings);\n\n        ExecuteParams[] memory executeParams = new ExecuteParams[](executeParamsLength);\n        executeParamsLength = 0;\n        uint256 n;\n        uint256 totalValue;\n        ProposalOption memory option;\n\n        // Flatten `options` by filling `executeParams` until budgetAmount is exceeded\n        for (uint256 i; i < succeededOptionsLength;) {\n            option = sortedOptions[i];\n\n            for (n = 0; n < option.targets.length;) {\n                // Shortcircuit if `budgetAmount` is exceeded\n                if (settings.budgetAmount != 0) {\n                    if (settings.budgetToken == address(0)) {\n                        // If `budgetToken` is ETH and value is not zero, add msg value to `totalValue`\n                        if (option.values[n] != 0) totalValue += option.values[n];\n                    } else {\n                        // If `target` is `budgetToken` and calldata is not zero\n                        if (settings.budgetToken == option.targets[n]) {\n                            bytes memory data = option.calldatas[n];\n                            if (data.length != 0) {\n                                uint256 amount;\n                                // If it's a `transfer` or `transferFrom`, add `amount` to `totalValue`\n                                if (bytes4(data) == IERC20.transfer.selector) {\n                                    assembly {\n                                        // Load the last 32 bytes of `data` into 'amount'\n                                        amount := mload(add(data, 0x44))\n                                    }\n                                } else if (bytes4(data) == IERC20.transferFrom.selector) {\n                                    assembly {\n                                        // Load the last 32 bytes of `data` into 'amount'\n                                        amount := mload(add(data, 0x64))\n                                    }\n                                }\n                                if (amount != 0) totalValue += amount;\n                            }\n                        }\n                    }\n\n                    // Break loop if `budgetAmount` is exceeded\n                    if (totalValue > settings.budgetAmount) break;\n                }\n\n                unchecked {\n                    executeParams[executeParamsLength + n] =\n                        ExecuteParams(option.targets[n], option.values[n], option.calldatas[n]);\n\n                    ++n;\n                }\n            }\n\n            // Break loop if `budgetAmount` is exceeded\n            if (settings.budgetAmount != 0) {\n                if (totalValue > settings.budgetAmount) break;\n            }\n\n            unchecked {\n                executeParamsLength += n;\n\n                ++i;\n            }\n        }\n\n        // Init param lengths based on the `n` passed elements\n        targets = new address[](executeParamsLength);\n        values = new uint256[](executeParamsLength);\n        calldatas = new bytes[](executeParamsLength);\n\n        // Set n `targets`, `values` and `calldatas`\n        for (uint256 i; i < executeParamsLength;) {\n            targets[i] = executeParams[i].targets;\n            values[i] = executeParams[i].values;\n            calldatas[i] = executeParams[i].calldatas;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev Return true if `account` has cast a vote for `proposalId`.\n     *\n     * @param proposalId The id of the proposal.\n     * @param account The address of the account.\n     */\n    function hasVoted(uint256 proposalId, address account) public view override returns (bool) {\n        return _accountVotes[proposalId][account] != 0;\n    }\n\n    /**\n     * @dev Return for, abstain and option votes for a `proposalId`.\n     *\n     * @param proposalId The id of the proposal.\n     */\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (uint256 forVotes, uint256 abstainVotes, uint128[] memory optionVotes)\n    {\n        ProposalVotes memory votes = _proposals[proposalId].votes;\n        return (votes.forVotes, votes.abstainVotes, _proposals[proposalId].optionVotes);\n    }\n\n    /**\n     * @dev Used by governor in `_quorumReached`. See {Governor-_quorumReached}.\n     *\n     * @param proposalId The id of the proposal.\n     * @param quorum The quorum value at the proposal start block.\n     */\n    function _quorumReached(uint256 proposalId, uint256 quorum) external view override returns (bool) {\n        _onlyGovernor(_proposals[proposalId].governor);\n        ProposalVotes memory votes = _proposals[proposalId].votes;\n\n        return quorum <= votes.forVotes + votes.abstainVotes;\n    }\n\n    /**\n     * @dev Return true if at least one option satisfies the passing criteria.\n     * Used by governor in `_voteSucceeded`. See {Governor-_voteSucceeded}.\n     *\n     * @param proposalId The id of the proposal.\n     */\n    function _voteSucceeded(uint256 proposalId) external view override returns (bool) {\n        Proposal memory proposal = _proposals[proposalId];\n        _onlyGovernor(proposal.governor);\n\n        ProposalOption[] memory options = proposal.options;\n        uint256 n = options.length;\n        unchecked {\n            if (proposal.settings.criteria == uint8(PassingCriteria.Threshold)) {\n                for (uint256 i; i < n; ++i) {\n                    if (proposal.optionVotes[i] >= proposal.settings.criteriaValue) return true;\n                }\n            } else if (proposal.settings.criteria == uint8(PassingCriteria.TopChoices)) {\n                for (uint256 i; i < n; ++i) {\n                    if (proposal.optionVotes[i] != 0) return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     *\n     * - `support=for,abstain`: the vote options are 0 = For, 1 = Abstain.\n     * - `quorum=for,abstain`: For and Abstain votes are counted towards quorum.\n     * - `params=approvalVote`: params needs to be formatted as `VOTE_PARAMS_ENCODING`.\n     */\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=for,abstain&quorum=for,abstain&params=approvalVote\";\n    }\n\n    /**\n     * Module version.\n     */\n    function version() public pure returns (uint256) {\n        return 1;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    // Sort `options` by `optionVotes` in descending order\n    function _sortOptions(uint128[] memory optionVotes, ProposalOption[] memory options)\n        internal\n        pure\n        returns (uint128[] memory, ProposalOption[] memory)\n    {\n        unchecked {\n            uint128 highestValue;\n            ProposalOption memory highestOption;\n            uint256 index;\n\n            for (uint256 i; i < optionVotes.length - 1; ++i) {\n                highestValue = optionVotes[i];\n\n                for (uint256 j = i + 1; j < optionVotes.length; ++j) {\n                    if (optionVotes[j] > highestValue) {\n                        highestValue = optionVotes[j];\n                        index = j;\n                    }\n                }\n\n                if (index != 0) {\n                    optionVotes[index] = optionVotes[i];\n                    optionVotes[i] = highestValue;\n\n                    highestOption = options[index];\n                    options[index] = options[i];\n                    options[i] = highestOption;\n\n                    index = 0;\n                }\n            }\n\n            return (optionVotes, options);\n        }\n    }\n\n    // Derive `executeParamsLength` and `succeededOptionsLength` based on passing criteria\n    function _countOptions(\n        ProposalOption[] memory options,\n        uint128[] memory optionVotes,\n        ProposalSettings memory settings\n    ) internal pure returns (uint256 executeParamsLength, uint256 succeededOptionsLength) {\n        uint256 n = options.length;\n        unchecked {\n            uint256 i;\n            if (settings.criteria == uint8(PassingCriteria.Threshold)) {\n                // if criteria is `Threshold`, loop through options until `optionVotes` is less than threshold\n                for (i; i < n; ++i) {\n                    if (optionVotes[i] >= settings.criteriaValue) {\n                        executeParamsLength += options[i].targets.length;\n                    } else {\n                        break;\n                    }\n                }\n            } else if (settings.criteria == uint8(PassingCriteria.TopChoices)) {\n                // if criteria is `TopChoices`, loop through options until the top choices are filled\n                for (i; i < settings.criteriaValue; ++i) {\n                    executeParamsLength += options[i].targets.length;\n                }\n            }\n            succeededOptionsLength = i;\n        }\n    }\n}"
    }
  ]
}