{
  "Title": "[G-05] Modifier execution order can help save an entire SLOAD(Save 2100 Gas)",
  "Content": "\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/Vault721.sol#L104-L114\n\n**Note: This would only make sense if `governor` remains a state variable, bot has suggested making it immutable.**\n\n```solidity\nFile: /src/contracts/proxies/Vault721.sol\n104:  function updateNftRenderer(\n105:    address _nftRenderer,\n106:    address _oracleRelayer,\n107:    address _taxCollector,\n108:    address _collateralJoinFactory\n109:  ) external onlyGovernor nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) {\n110:    address _safeManager = address(safeManager);\n111:    require(_safeManager != address(0));\n112:    _setNftRenderer(_nftRenderer);\n113:    nftRenderer.setImplementation(_safeManager, _oracleRelayer, _taxCollector, _collateralJoinFactory);\n114:  }\n```\n\nOur function makes use of 2 modifers `onlyGovernor` and `nonZero`. The modifiers are defined as follows\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/Vault721.sol#L40-L43\n```solidity\n40:  modifier onlyGovernor() {\n41:    if (msg.sender != governor) revert NotGovernor();\n42:    _;\n43:  }\n```\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/Vault721.sol#L48-L51\n```solidity\n48:  modifier nonZero(address _addr) {\n49:    if (_addr == address(0)) revert ZeroAddress();\n50:    _;\n51:  }\n```\n\nThe first modifier `onlyGovernor` which is also the first one to be executed in our function involves reading a state variable `governor`, Since this is the first SLOAD we consume 2100 Gas for the SLOAD.\nThe second modifier `nonZero` does not read any state variable, only parameters being passed to it, in our case , some function parameters.\n\nAccording to the docs,multiple modifiers are evaluated in the order presented.\n\nDue to how they are order in our calling function `updateNftRenderer` ie \n`  ) external onlyGovernor nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) {`\nThe `onlyGovernor` is checked first and if `msg.sender` == `governor` we proceed to check the second modifier `nonZero` passing our function parameter `_oracleRelayer` and again proceed to the next or revert if the passed parameter `==` `address(0)`.\n\nIn case we do revert on the check `nonZero` it means, the gas cost used to do the SLOAD in the `onlyGovernor` check, would be wasted.\nWe can save some gas (2100 Gas) for the SLOAD if we reorder the modifier execution to first check for `nonZero` and only do `onlyGovernor` if all our parameters are not `zero`.\n\n```diff\ndiff --git a/src/contracts/proxies/Vault721.sol b/src/contracts/proxies/Vault721.sol\nindex 54dc8f7..eca21a1 100644\n--- a/src/contracts/proxies/Vault721.sol\n+++ b/src/contracts/proxies/Vault721.sol\n@@ -106,7 +106,7 @@ contract Vault721 is ERC721Enumerable {\n     address _oracleRelayer,\n     address _taxCollector,\n     address _collateralJoinFactory\n-  ) external onlyGovernor nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) {\n+  ) external  nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) onlyGovernor {\n     address _safeManager = address(safeManager);\n     require(_safeManager != address(0));\n     _setNftRenderer(_nftRenderer);\n\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/proxies/Vault721.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ERC721} from '@openzeppelin/token/ERC721/ERC721.sol';\nimport {ERC721Enumerable} from '@openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol';\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\nimport {NFTRenderer} from '@contracts/proxies/NFTRenderer.sol';\n\n// Open Dollar\n// Version 1.5.5\n\ncontract Vault721 is ERC721Enumerable {\n  error NotGovernor();\n  error ProxyAlreadyExist();\n  error ZeroAddress();\n\n  address public governor;\n  IODSafeManager public safeManager;\n  NFTRenderer public nftRenderer;\n\n  string public contractMetaData =\n    '{\"name\": \"Open Dollar Vaults\",\"description\": \"Tradable Vaults for the Open Dollar stablecoin protocol. Caution! Trading this NFT means trading the ownership of your Vault in the Open Dollar protocol and all of the assets/collateral inside each Vault.\",\"image\": \"https://app.opendollar.com/collectionImage.png\",\"external_link\": \"https://opendollar.com\"}';\n\n  mapping(address proxy => address user) internal _proxyRegistry;\n  mapping(address user => address proxy) internal _userRegistry;\n\n  event CreateProxy(address indexed _user, address _proxy);\n\n  /**\n   * @dev initializes DAO governor contract\n   */\n  constructor(address _governor) ERC721('OpenDollar Vault', 'ODV') {\n    governor = _governor;\n  }\n\n  /**\n   * @dev control access for DAO governor\n   */\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert NotGovernor();\n    _;\n  }\n\n  /**\n   * @dev enforce non-zero address params\n   */\n  modifier nonZero(address _addr) {\n    if (_addr == address(0)) revert ZeroAddress();\n    _;\n  }\n\n  /**\n   * @dev initializes SafeManager contract\n   */\n  function initializeManager() external {\n    if (address(safeManager) == address(0)) _setSafeManager(msg.sender);\n  }\n\n  /**\n   * @dev initializes NFTRenderer contract\n   */\n  function initializeRenderer() external {\n    if (address(nftRenderer) == address(0)) _setNftRenderer(msg.sender);\n  }\n\n  /**\n   * @dev get proxy by user address\n   */\n  function getProxy(address _user) external view returns (address _proxy) {\n    _proxy = _userRegistry[_user];\n  }\n\n  /**\n   * @dev allows msg.sender without an ODProxy to deploy a new ODProxy\n   */\n  function build() external returns (address payable _proxy) {\n    if (!_isNotProxy(msg.sender)) revert ProxyAlreadyExist();\n    _proxy = _build(msg.sender);\n  }\n\n  /**\n   * @dev allows user without an ODProxy to deploy a new ODProxy\n   */\n  function build(address _user) external returns (address payable _proxy) {\n    if (!_isNotProxy(_user)) revert ProxyAlreadyExist();\n    _proxy = _build(_user);\n  }\n\n  /**\n   * @dev mint can only be called by the SafeManager\n   * enforces that only ODProxies call `openSafe` function by checking _proxyRegistry\n   */\n  function mint(address _proxy, uint256 _safeId) external {\n    require(msg.sender == address(safeManager), 'V721: only safeManager');\n    require(_proxyRegistry[_proxy] != address(0), 'V721: non-native proxy');\n    address _user = _proxyRegistry[_proxy];\n    _safeMint(_user, _safeId);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation on NFTRenderer\n   */\n  function updateNftRenderer(\n    address _nftRenderer,\n    address _oracleRelayer,\n    address _taxCollector,\n    address _collateralJoinFactory\n  ) external onlyGovernor nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) {\n    address _safeManager = address(safeManager);\n    require(_safeManager != address(0));\n    _setNftRenderer(_nftRenderer);\n    nftRenderer.setImplementation(_safeManager, _oracleRelayer, _taxCollector, _collateralJoinFactory);\n  }\n\n  /**\n   * @dev update meta data\n   */\n  function updateContractURI(string memory _metaData) external onlyGovernor {\n    contractMetaData = _metaData;\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function setSafeManager(address _safeManager) external onlyGovernor {\n    _setSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function setNftRenderer(address _nftRenderer) external onlyGovernor {\n    _setNftRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev generate URI with updated vault information\n   */\n  function tokenURI(uint256 _safeId) public view override returns (string memory uri) {\n    uri = nftRenderer.render(_safeId);\n  }\n\n  /**\n   * @dev contract level meta data\n   */\n  function contractURI() public view returns (string memory uri) {\n    uri = string.concat('data:application/json;utf8,', contractMetaData);\n  }\n\n  /**\n   * @dev check that proxy does not exist OR that the user does not own proxy\n   */\n  function _isNotProxy(address _user) internal view returns (bool) {\n    return _userRegistry[_user] == address(0) || ODProxy(_userRegistry[_user]).OWNER() != _user;\n  }\n\n  /**\n   * @dev deploys ODProxy for user to interact with protocol\n   * updates _proxyRegistry and _userRegistry mappings for new ODProxy\n   */\n  function _build(address _user) internal returns (address payable _proxy) {\n    _proxy = payable(address(new ODProxy(_user)));\n    _proxyRegistry[_proxy] = _user;\n    _userRegistry[_user] = _proxy;\n    emit CreateProxy(_user, address(_proxy));\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function _setSafeManager(address _safeManager) internal nonZero(_safeManager) {\n    safeManager = IODSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function _setNftRenderer(address _nftRenderer) internal nonZero(_nftRenderer) {\n    nftRenderer = NFTRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev _transfer calls `transferSAFEOwnership` on SafeManager\n   * enforces that ODProxy exists for transfer or it deploys a new ODProxy for receiver of vault/nft\n   */\n  function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal override {\n    require(to != address(0), 'V721: no burn');\n    if (from != address(0)) {\n      address payable proxy;\n\n      if (_isNotProxy(to)) {\n        proxy = _build(to);\n      } else {\n        proxy = payable(_userRegistry[to]);\n      }\n      IODSafeManager(safeManager).transferSAFEOwnership(firstTokenId, address(proxy));\n    }\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/Vault721.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ERC721} from '@openzeppelin/token/ERC721/ERC721.sol';\nimport {ERC721Enumerable} from '@openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol';\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\nimport {NFTRenderer} from '@contracts/proxies/NFTRenderer.sol';\n\n// Open Dollar\n// Version 1.5.5\n\ncontract Vault721 is ERC721Enumerable {\n  error NotGovernor();\n  error ProxyAlreadyExist();\n  error ZeroAddress();\n\n  address public governor;\n  IODSafeManager public safeManager;\n  NFTRenderer public nftRenderer;\n\n  string public contractMetaData =\n    '{\"name\": \"Open Dollar Vaults\",\"description\": \"Tradable Vaults for the Open Dollar stablecoin protocol. Caution! Trading this NFT means trading the ownership of your Vault in the Open Dollar protocol and all of the assets/collateral inside each Vault.\",\"image\": \"https://app.opendollar.com/collectionImage.png\",\"external_link\": \"https://opendollar.com\"}';\n\n  mapping(address proxy => address user) internal _proxyRegistry;\n  mapping(address user => address proxy) internal _userRegistry;\n\n  event CreateProxy(address indexed _user, address _proxy);\n\n  /**\n   * @dev initializes DAO governor contract\n   */\n  constructor(address _governor) ERC721('OpenDollar Vault', 'ODV') {\n    governor = _governor;\n  }\n\n  /**\n   * @dev control access for DAO governor\n   */\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert NotGovernor();\n    _;\n  }\n\n  /**\n   * @dev enforce non-zero address params\n   */\n  modifier nonZero(address _addr) {\n    if (_addr == address(0)) revert ZeroAddress();\n    _;\n  }\n\n  /**\n   * @dev initializes SafeManager contract\n   */\n  function initializeManager() external {\n    if (address(safeManager) == address(0)) _setSafeManager(msg.sender);\n  }\n\n  /**\n   * @dev initializes NFTRenderer contract\n   */\n  function initializeRenderer() external {\n    if (address(nftRenderer) == address(0)) _setNftRenderer(msg.sender);\n  }\n\n  /**\n   * @dev get proxy by user address\n   */\n  function getProxy(address _user) external view returns (address _proxy) {\n    _proxy = _userRegistry[_user];\n  }\n\n  /**\n   * @dev allows msg.sender without an ODProxy to deploy a new ODProxy\n   */\n  function build() external returns (address payable _proxy) {\n    if (!_isNotProxy(msg.sender)) revert ProxyAlreadyExist();\n    _proxy = _build(msg.sender);\n  }\n\n  /**\n   * @dev allows user without an ODProxy to deploy a new ODProxy\n   */\n  function build(address _user) external returns (address payable _proxy) {\n    if (!_isNotProxy(_user)) revert ProxyAlreadyExist();\n    _proxy = _build(_user);\n  }\n\n  /**\n   * @dev mint can only be called by the SafeManager\n   * enforces that only ODProxies call `openSafe` function by checking _proxyRegistry\n   */\n  function mint(address _proxy, uint256 _safeId) external {\n    require(msg.sender == address(safeManager), 'V721: only safeManager');\n    require(_proxyRegistry[_proxy] != address(0), 'V721: non-native proxy');\n    address _user = _proxyRegistry[_proxy];\n    _safeMint(_user, _safeId);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation on NFTRenderer\n   */\n  function updateNftRenderer(\n    address _nftRenderer,\n    address _oracleRelayer,\n    address _taxCollector,\n    address _collateralJoinFactory\n  ) external onlyGovernor nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) {\n    address _safeManager = address(safeManager);\n    require(_safeManager != address(0));\n    _setNftRenderer(_nftRenderer);\n    nftRenderer.setImplementation(_safeManager, _oracleRelayer, _taxCollector, _collateralJoinFactory);\n  }\n\n  /**\n   * @dev update meta data\n   */\n  function updateContractURI(string memory _metaData) external onlyGovernor {\n    contractMetaData = _metaData;\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function setSafeManager(address _safeManager) external onlyGovernor {\n    _setSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function setNftRenderer(address _nftRenderer) external onlyGovernor {\n    _setNftRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev generate URI with updated vault information\n   */\n  function tokenURI(uint256 _safeId) public view override returns (string memory uri) {\n    uri = nftRenderer.render(_safeId);\n  }\n\n  /**\n   * @dev contract level meta data\n   */\n  function contractURI() public view returns (string memory uri) {\n    uri = string.concat('data:application/json;utf8,', contractMetaData);\n  }\n\n  /**\n   * @dev check that proxy does not exist OR that the user does not own proxy\n   */\n  function _isNotProxy(address _user) internal view returns (bool) {\n    return _userRegistry[_user] == address(0) || ODProxy(_userRegistry[_user]).OWNER() != _user;\n  }\n\n  /**\n   * @dev deploys ODProxy for user to interact with protocol\n   * updates _proxyRegistry and _userRegistry mappings for new ODProxy\n   */\n  function _build(address _user) internal returns (address payable _proxy) {\n    _proxy = payable(address(new ODProxy(_user)));\n    _proxyRegistry[_proxy] = _user;\n    _userRegistry[_user] = _proxy;\n    emit CreateProxy(_user, address(_proxy));\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function _setSafeManager(address _safeManager) internal nonZero(_safeManager) {\n    safeManager = IODSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function _setNftRenderer(address _nftRenderer) internal nonZero(_nftRenderer) {\n    nftRenderer = NFTRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev _transfer calls `transferSAFEOwnership` on SafeManager\n   * enforces that ODProxy exists for transfer or it deploys a new ODProxy for receiver of vault/nft\n   */\n  function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal override {\n    require(to != address(0), 'V721: no burn');\n    if (from != address(0)) {\n      address payable proxy;\n\n      if (_isNotProxy(to)) {\n        proxy = _build(to);\n      } else {\n        proxy = payable(_userRegistry[to]);\n      }\n      IODSafeManager(safeManager).transferSAFEOwnership(firstTokenId, address(proxy));\n    }\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/Vault721.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ERC721} from '@openzeppelin/token/ERC721/ERC721.sol';\nimport {ERC721Enumerable} from '@openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol';\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\nimport {NFTRenderer} from '@contracts/proxies/NFTRenderer.sol';\n\n// Open Dollar\n// Version 1.5.5\n\ncontract Vault721 is ERC721Enumerable {\n  error NotGovernor();\n  error ProxyAlreadyExist();\n  error ZeroAddress();\n\n  address public governor;\n  IODSafeManager public safeManager;\n  NFTRenderer public nftRenderer;\n\n  string public contractMetaData =\n    '{\"name\": \"Open Dollar Vaults\",\"description\": \"Tradable Vaults for the Open Dollar stablecoin protocol. Caution! Trading this NFT means trading the ownership of your Vault in the Open Dollar protocol and all of the assets/collateral inside each Vault.\",\"image\": \"https://app.opendollar.com/collectionImage.png\",\"external_link\": \"https://opendollar.com\"}';\n\n  mapping(address proxy => address user) internal _proxyRegistry;\n  mapping(address user => address proxy) internal _userRegistry;\n\n  event CreateProxy(address indexed _user, address _proxy);\n\n  /**\n   * @dev initializes DAO governor contract\n   */\n  constructor(address _governor) ERC721('OpenDollar Vault', 'ODV') {\n    governor = _governor;\n  }\n\n  /**\n   * @dev control access for DAO governor\n   */\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert NotGovernor();\n    _;\n  }\n\n  /**\n   * @dev enforce non-zero address params\n   */\n  modifier nonZero(address _addr) {\n    if (_addr == address(0)) revert ZeroAddress();\n    _;\n  }\n\n  /**\n   * @dev initializes SafeManager contract\n   */\n  function initializeManager() external {\n    if (address(safeManager) == address(0)) _setSafeManager(msg.sender);\n  }\n\n  /**\n   * @dev initializes NFTRenderer contract\n   */\n  function initializeRenderer() external {\n    if (address(nftRenderer) == address(0)) _setNftRenderer(msg.sender);\n  }\n\n  /**\n   * @dev get proxy by user address\n   */\n  function getProxy(address _user) external view returns (address _proxy) {\n    _proxy = _userRegistry[_user];\n  }\n\n  /**\n   * @dev allows msg.sender without an ODProxy to deploy a new ODProxy\n   */\n  function build() external returns (address payable _proxy) {\n    if (!_isNotProxy(msg.sender)) revert ProxyAlreadyExist();\n    _proxy = _build(msg.sender);\n  }\n\n  /**\n   * @dev allows user without an ODProxy to deploy a new ODProxy\n   */\n  function build(address _user) external returns (address payable _proxy) {\n    if (!_isNotProxy(_user)) revert ProxyAlreadyExist();\n    _proxy = _build(_user);\n  }\n\n  /**\n   * @dev mint can only be called by the SafeManager\n   * enforces that only ODProxies call `openSafe` function by checking _proxyRegistry\n   */\n  function mint(address _proxy, uint256 _safeId) external {\n    require(msg.sender == address(safeManager), 'V721: only safeManager');\n    require(_proxyRegistry[_proxy] != address(0), 'V721: non-native proxy');\n    address _user = _proxyRegistry[_proxy];\n    _safeMint(_user, _safeId);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation on NFTRenderer\n   */\n  function updateNftRenderer(\n    address _nftRenderer,\n    address _oracleRelayer,\n    address _taxCollector,\n    address _collateralJoinFactory\n  ) external onlyGovernor nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) {\n    address _safeManager = address(safeManager);\n    require(_safeManager != address(0));\n    _setNftRenderer(_nftRenderer);\n    nftRenderer.setImplementation(_safeManager, _oracleRelayer, _taxCollector, _collateralJoinFactory);\n  }\n\n  /**\n   * @dev update meta data\n   */\n  function updateContractURI(string memory _metaData) external onlyGovernor {\n    contractMetaData = _metaData;\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function setSafeManager(address _safeManager) external onlyGovernor {\n    _setSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function setNftRenderer(address _nftRenderer) external onlyGovernor {\n    _setNftRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev generate URI with updated vault information\n   */\n  function tokenURI(uint256 _safeId) public view override returns (string memory uri) {\n    uri = nftRenderer.render(_safeId);\n  }\n\n  /**\n   * @dev contract level meta data\n   */\n  function contractURI() public view returns (string memory uri) {\n    uri = string.concat('data:application/json;utf8,', contractMetaData);\n  }\n\n  /**\n   * @dev check that proxy does not exist OR that the user does not own proxy\n   */\n  function _isNotProxy(address _user) internal view returns (bool) {\n    return _userRegistry[_user] == address(0) || ODProxy(_userRegistry[_user]).OWNER() != _user;\n  }\n\n  /**\n   * @dev deploys ODProxy for user to interact with protocol\n   * updates _proxyRegistry and _userRegistry mappings for new ODProxy\n   */\n  function _build(address _user) internal returns (address payable _proxy) {\n    _proxy = payable(address(new ODProxy(_user)));\n    _proxyRegistry[_proxy] = _user;\n    _userRegistry[_user] = _proxy;\n    emit CreateProxy(_user, address(_proxy));\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function _setSafeManager(address _safeManager) internal nonZero(_safeManager) {\n    safeManager = IODSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function _setNftRenderer(address _nftRenderer) internal nonZero(_nftRenderer) {\n    nftRenderer = NFTRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev _transfer calls `transferSAFEOwnership` on SafeManager\n   * enforces that ODProxy exists for transfer or it deploys a new ODProxy for receiver of vault/nft\n   */\n  function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal override {\n    require(to != address(0), 'V721: no burn');\n    if (from != address(0)) {\n      address payable proxy;\n\n      if (_isNotProxy(to)) {\n        proxy = _build(to);\n      } else {\n        proxy = payable(_userRegistry[to]);\n      }\n      IODSafeManager(safeManager).transferSAFEOwnership(firstTokenId, address(proxy));\n    }\n  }\n}"
    }
  ]
}