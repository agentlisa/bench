{
  "Title": "[L-01] ETH is not refunded when `allowArbCallsToSpendPatyETH=true`",
  "Content": "The `ArbitraryCallsProposal` contract does not refund `ETH` to the `msg.sender` if `allowArbCallsToSpendPartyEth=true`.  \n\nIt only refunds when `allowArbCallsToSpendPartyEth=false`:  \n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/ArbitraryCallsProposal.sol#L108-L110)  \n```solidity\nif (!allowArbCallsToSpendPartyEth && ethAvailable > 0) {\n    payable(msg.sender).transferEth(ethAvailable);\n}\n```\n\nThe reason this is the case is that it is not expected that the `msg.sender` will provide `ETH` if it is allowed to spend `ETH` from the Party's balance.  \n\nI don't think this is a good assumption. There should be a refund mechanism.  \n\nPlease also refer to my report `#5` which discusses a more severe similar issue. Some of the reasoning there also applies here. Specifically that there are two broad options to implement refunds when `allowArbCallsToSpendPartyEth=true`.  \n\n1. Use `msg.value` first\n2. Use Party balance first\n\nThe sponsor needs to decide which policy (if any) to use.  \n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/proposals/ArbitraryCallsProposal.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../party/PartyGovernanceNFT.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../vendor/markets/IZoraAuctionHouse.sol\";\nimport \"./vendor/IOpenseaExchange.sol\";\n\nimport \"./LibProposal.sol\";\nimport \"./IProposalExecutionEngine.sol\";\n\n// Implements arbitrary call proposals. Inherited by the `ProposalExecutionEngine`.\n// This contract will be delegatecall'ed into by `Party` proxy instances.\ncontract ArbitraryCallsProposal {\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct ArbitraryCall {\n        // The call target.\n        address payable target;\n        // Amount of ETH to attach to the call.\n        uint256 value;\n        // Calldata.\n        bytes data;\n        // Hash of the successful return data of the call.\n        // If 0x0, no return data checking will occur for this call.\n        bytes32 expectedResultHash;\n    }\n\n    error PreciousLostError(IERC721 token, uint256 tokenId);\n    error CallProhibitedError(address target, bytes data);\n    error ArbitraryCallFailedError(bytes revertData);\n    error UnexpectedCallResultHashError(\n        uint256 idx,\n        bytes32 resultHash,\n        bytes32 expectedResultHash\n    );\n    error NotEnoughEthAttachedError(uint256 callValue, uint256 ethAvailable);\n    error InvalidApprovalCallLength(uint256 callDataLength);\n\n    event ArbitraryCallExecuted(uint256 proposalId, uint256 idx, uint256 count);\n\n    IZoraAuctionHouse private immutable _ZORA;\n\n    constructor(IZoraAuctionHouse zora) {\n        _ZORA = zora;\n    }\n\n    function _executeArbitraryCalls(\n        IProposalExecutionEngine.ExecuteProposalParams memory params,\n        bool allowArbCallsToSpendPartyEth\n    ) internal returns (bytes memory nextProgressData) {\n        // Get the calls to execute.\n        ArbitraryCall[] memory calls = abi.decode(params.proposalData, (ArbitraryCall[]));\n        // Check whether the proposal was unanimously passed.\n        bool isUnanimous = params.flags & LibProposal.PROPOSAL_FLAG_UNANIMOUS ==\n            LibProposal.PROPOSAL_FLAG_UNANIMOUS;\n        // If not unanimous, keep track of which preciouses we had before the calls\n        // so we can check that we still have them later.\n        bool[] memory hadPreciouses = new bool[](params.preciousTokenIds.length);\n        if (!isUnanimous) {\n            for (uint256 i; i < hadPreciouses.length; ++i) {\n                hadPreciouses[i] = _getHasPrecious(\n                    params.preciousTokens[i],\n                    params.preciousTokenIds[i]\n                );\n            }\n        }\n        // If we're not allowing arbitrary calls to spend the Party's ETH, only\n        // allow forwarded ETH attached to the call to be spent.\n        uint256 ethAvailable = allowArbCallsToSpendPartyEth ? address(this).balance : msg.value;\n        for (uint256 i; i < calls.length; ++i) {\n            // Execute an arbitrary call.\n            _executeSingleArbitraryCall(\n                i,\n                calls,\n                params.preciousTokens,\n                params.preciousTokenIds,\n                isUnanimous,\n                ethAvailable\n            );\n            // Update the amount of ETH available for the subsequent calls.\n            ethAvailable = allowArbCallsToSpendPartyEth\n                ? address(this).balance\n                : ethAvailable - calls[i].value;\n            emit ArbitraryCallExecuted(params.proposalId, i, calls.length);\n        }\n        // If not a unanimous vote and we had a precious beforehand,\n        // ensure that we still have it now.\n        if (!isUnanimous) {\n            for (uint256 i; i < hadPreciouses.length; ++i) {\n                if (hadPreciouses[i]) {\n                    if (!_getHasPrecious(params.preciousTokens[i], params.preciousTokenIds[i])) {\n                        revert PreciousLostError(\n                            params.preciousTokens[i],\n                            params.preciousTokenIds[i]\n                        );\n                    }\n                }\n            }\n        }\n        // Refund leftover ETH attached to the call if none was spent from the\n        // Party's balance.\n        if (!allowArbCallsToSpendPartyEth && ethAvailable > 0) {\n            payable(msg.sender).transferEth(ethAvailable);\n        }\n        // No next step, so no progressData.\n        return \"\";\n    }\n\n    function _executeSingleArbitraryCall(\n        uint256 idx,\n        ArbitraryCall[] memory calls,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        bool isUnanimous,\n        uint256 ethAvailable\n    ) private {\n        ArbitraryCall memory call = calls[idx];\n        // Check that the call is not prohibited.\n        if (\n            !_isCallAllowed(call, isUnanimous, idx, calls.length, preciousTokens, preciousTokenIds)\n        ) {\n            revert CallProhibitedError(call.target, call.data);\n        }\n        // Check that we have enough ETH to execute the call.\n        if (ethAvailable < call.value) {\n            revert NotEnoughEthAttachedError(call.value, ethAvailable);\n        }\n        // Execute the call.\n        (bool s, bytes memory r) = call.target.call{ value: call.value }(call.data);\n        if (!s) {\n            // Call failed. If not optional, revert.\n            revert ArbitraryCallFailedError(r);\n        } else {\n            // Call succeeded.\n            // If we have a nonzero expectedResultHash, check that the result data\n            // from the call has a matching hash.\n            if (call.expectedResultHash != bytes32(0)) {\n                bytes32 resultHash = keccak256(r);\n                if (resultHash != call.expectedResultHash) {\n                    revert UnexpectedCallResultHashError(idx, resultHash, call.expectedResultHash);\n                }\n            }\n        }\n    }\n\n    // Do we possess the precious?\n    function _getHasPrecious(\n        IERC721 preciousToken,\n        uint256 preciousTokenId\n    ) private view returns (bool hasPrecious) {\n        hasPrecious = preciousToken.safeOwnerOf(preciousTokenId) == address(this);\n    }\n\n    function _isCallAllowed(\n        ArbitraryCall memory call,\n        bool isUnanimous,\n        uint256 callIndex,\n        uint256 callsCount,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    ) private view returns (bool isAllowed) {\n        // Cannot call ourselves.\n        if (call.target == address(this)) {\n            return false;\n        }\n        if (call.data.length >= 4) {\n            // Get the function selector of the call (first 4 bytes of calldata).\n            bytes4 selector;\n            {\n                bytes memory callData = call.data;\n                assembly {\n                    selector := and(\n                        mload(add(callData, 32)),\n                        0xffffffff00000000000000000000000000000000000000000000000000000000\n                    )\n                }\n            }\n            // Non-unanimous proposals restrict what ways some functions can be\n            // called on a precious token.\n            if (!isUnanimous) {\n                // Cannot call `approve()` or `setApprovalForAll()` on the precious\n                // unless it's to revoke approvals.\n                if (selector == IERC721.approve.selector) {\n                    // Can only call `approve()` on the precious if the operator is null.\n                    (address op, uint256 tokenId) = _decodeApproveCallDataArgs(call.data);\n                    if (op != address(0)) {\n                        return\n                            !LibProposal.isTokenIdPrecious(\n                                IERC721(call.target),\n                                tokenId,\n                                preciousTokens,\n                                preciousTokenIds\n                            );\n                    }\n                    // Can only call `setApprovalForAll()` on the precious if\n                    // toggling off.\n                } else if (selector == IERC721.setApprovalForAll.selector) {\n                    (, bool isApproved) = _decodeSetApprovalForAllCallDataArgs(call.data);\n                    if (isApproved) {\n                        return !LibProposal.isTokenPrecious(IERC721(call.target), preciousTokens);\n                    }\n                    // Can only call cancelAuction on the zora AH if it's the last call\n                    // in the sequence.\n                } else if (selector == IZoraAuctionHouse.cancelAuction.selector) {\n                    if (call.target == address(_ZORA)) {\n                        return callIndex + 1 == callsCount;\n                    }\n                }\n            }\n            // Can never call receive hooks on any target.\n            if (\n                selector == IERC721Receiver.onERC721Received.selector ||\n                selector == ERC1155TokenReceiverBase.onERC1155Received.selector ||\n                selector == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector\n            ) {\n                return false;\n            }\n            // Disallow calling `validate()` on Seaport.\n            if (selector == IOpenseaExchange.validate.selector) {\n                return false;\n            }\n        }\n        // All other calls are allowed.\n        return true;\n    }\n\n    // Get the `operator` and `tokenId` from the `approve()` call data.\n    function _decodeApproveCallDataArgs(\n        bytes memory callData\n    ) private pure returns (address operator, uint256 tokenId) {\n        if (callData.length < 68) {\n            revert InvalidApprovalCallLength(callData.length);\n        }\n        assembly {\n            operator := and(mload(add(callData, 36)), 0xffffffffffffffffffffffffffffffffffffffff)\n            tokenId := mload(add(callData, 68))\n        }\n    }\n\n    // Get the `operator` and `tokenId` from the `setApprovalForAll()` call data.\n    function _decodeSetApprovalForAllCallDataArgs(\n        bytes memory callData\n    ) private pure returns (address operator, bool isApproved) {\n        if (callData.length < 68) {\n            revert InvalidApprovalCallLength(callData.length);\n        }\n        assembly {\n            operator := and(mload(add(callData, 36)), 0xffffffffffffffffffffffffffffffffffffffff)\n            isApproved := xor(iszero(mload(add(callData, 68))), 1)\n        }\n    }\n}"
    }
  ]
}