{
  "Title": "[H-01] Wrong timing of check allows users to withdraw collateral without paying for the debt",
  "Content": "_Submitted by WatchPug, also found by IllIllI_\n\n[TimeswapPair.sol#L459-L490](https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L490)<br>\n\n```solidity\nfunction pay(PayParam calldata param)\n    external \n    override \n    lock \n    returns (\n        uint128 assetIn, \n        uint128 collateralOut\n    ) \n{\n    require(block.timestamp < param.maturity, 'E202');\n    require(param.owner != address(0), 'E201');\n    require(param.to != address(0), 'E201');\n    require(param.to != address(this), 'E204');\n    require(param.ids.length == param.assetsIn.length, 'E205');\n    require(param.ids.length == param.collateralsOut.length, 'E205');\n\n    Pool storage pool = pools[param.maturity];\n\n    Due[] storage dues = pool.dues[param.owner];\n    require(dues.length >= param.ids.length, 'E205');\n\n    for (uint256 i; i < param.ids.length;) {\n        Due storage due = dues[param.ids[i]];\n        require(due.startBlock != BlockNumber.get(), 'E207');\n        if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');\n        require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');\n        due.debt -= param.assetsIn[i];\n        due.collateral -= param.collateralsOut[i];\n        assetIn += param.assetsIn[i];\n        collateralOut += param.collateralsOut[i];\n        unchecked { ++i; }\n    }\n    ...\n```\n\nAt L484, if there is only one `id`, and for the first and only time of the for loop, `assetIn` and `collateralOut` will be `0`, therefore `require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');` will pass.\n\nA attacker can call `pay()` with `param.assetsIn[0] == 0` and `param.collateralsOut[i] == due.collateral`.\n\n### Proof of Concept\n\nThe attacker can:\n\n1.  `borrow()` `10,000 USDC` with `1 BTC` as `collateral`;\n2.  `pay()` with `0 USDC` as `assetsIn` and `1 BTC` as `collateralsOut`.\n\nAs a result, the attacker effectively stole `10,000 USDC`.\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\nfor (uint256 i; i < param.ids.length;) {\n    Due storage due = dues[param.ids[i]];\n    require(due.startBlock != BlockNumber.get(), 'E207');\n    if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');\n    due.debt -= param.assetsIn[i];\n    due.collateral -= param.collateralsOut[i];\n    assetIn += param.assetsIn[i];\n    collateralOut += param.collateralsOut[i];\n    unchecked { ++i; }\n}\n\nrequire(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');\n...\n```\n\n**[Mathepreneur (Timeswap) resolved and commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/16#issuecomment-1063973580):**\n > [Timeswap-Labs/Timeswap-V1-Core@b23b44a](https://github.com/Timeswap-Labs/Timeswap-V1-Core/commit/b23b44a01d577a5bee77fb5f19d9f4ad1e8d13af)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/16#issuecomment-1086569306):**\n > This is an interesting find. It appears that `assetIn` and `collateralOut` are not checked properly during the first iteration of the for loop. As a result, this functionality of this function is inherently broken as the `require` statement will always be satisfied. Nice job!\n\n\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-03-timeswap",
  "Code": [
    {
      "filename": "Timeswap/Core/contracts/TimeswapPair.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from './interfaces/IPair.sol';\nimport {IFactory} from './interfaces/IFactory.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {TimeswapMath} from './libraries/TimeswapMath.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Array} from './libraries/Array.sol';\nimport {Callback} from './libraries/Callback.sol';\nimport {BlockNumber} from './libraries/BlockNumber.sol';\n\n/// @title Timeswap Pair\n/// @author Timeswap Labs\n/// @notice It is recommended to use Timeswap Convenience to interact with this contract.\n/// @notice All error messages are coded and can be found in the documentation.\ncontract TimeswapPair is IPair {\n    using SafeERC20 for IERC20;\n    using Array for Due[];\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc IPair\n    IFactory public immutable override factory;\n    /// @inheritdoc IPair\n    IERC20 public immutable override asset;\n    /// @inheritdoc IPair\n    IERC20 public immutable override collateral;\n    /// @inheritdoc IPair\n    uint16 public immutable override fee;\n    /// @inheritdoc IPair\n    uint16 public immutable override protocolFee;\n\n    /// @inheritdoc IPair\n    uint256 public override protocolFeeStored;\n\n    /// @dev Stores the individual states of each Pool.\n    mapping(uint256 => Pool) private pools;\n\n    /// @dev Stores the access state for reentrancy guard.\n    uint256 private locked = 1;\n\n    /* ===== VIEW =====*/\n\n    /// @inheritdoc IPair\n    function feeStored(uint256 maturity)\n        external\n        view\n        override\n        returns (uint256) \n    {\n        return pools[maturity].state.feeStored;\n    }\n\n    /// @inheritdoc IPair\n    function constantProduct(uint256 maturity)\n        external\n        view\n        override\n        returns (uint112, uint112, uint112)\n    {\n        State storage state = pools[maturity].state;\n        return (state.x, state.y, state.z);\n    }\n\n    /// @inheritdoc IPair\n    function totalReserves(uint256 maturity) external view override returns (Tokens memory) {\n        return pools[maturity].state.reserves;\n    }\n\n    /// @inheritdoc IPair\n    function totalLiquidity(uint256 maturity) external view override returns (uint256) {\n        return pools[maturity].state.totalLiquidity;\n    }\n\n    /// @inheritdoc IPair\n    function liquidityOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].liquidities[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalClaims(uint256 maturity) external view override returns (Claims memory) {\n        return pools[maturity].state.totalClaims;\n    }\n\n    /// @inheritdoc IPair\n    function claimsOf(uint256 maturity, address owner) external view override returns (Claims memory) {\n        return pools[maturity].claims[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalDebtCreated(uint256 maturity) external view override returns (uint120) {\n        return pools[maturity].state.totalDebtCreated;\n    }\n\n    /// @inheritdoc IPair\n    function totalDuesOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].dues[owner].length;\n    }\n\n    /// @inheritdoc IPair\n    function dueOf(uint256 maturity, address owner, uint256 id) external view override returns (Due memory) {\n        return pools[maturity].dues[owner][id];\n    }\n\n    /* ===== INIT ===== */\n\n    /// @dev Initializes the Pair contract.\n    /// @dev Called by the Timeswap factory contract.\n    /// @param _asset The address of the ERC20 being lent and borrowed.\n    /// @param _collateral The address of the ERC20 as the collateral.\n    /// @param _fee The chosen fee rate.\n    /// @param _protocolFee The chosen protocol fee rate.\n    constructor(\n        IERC20 _asset,\n        IERC20 _collateral,\n        uint16 _fee,\n        uint16 _protocolFee\n    ) {\n        factory = IFactory(msg.sender);\n        asset = _asset;\n        collateral = _collateral;\n        fee = _fee;\n        protocolFee = _protocolFee;\n    }\n\n    /* ===== MODIFIER ===== */\n\n    /// @dev The modifier for reentrancy guard.\n    modifier lock() {\n        require(locked == 1, 'E211');\n        locked = 2;\n        _;\n        locked = 1;\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc IPair\n    function mint(MintParam calldata param)\n        external\n        override\n        lock\n        returns (\n            uint256 assetIn,\n            uint256 liquidityOut,\n            uint256 id,\n            Due memory dueOut\n        )\n    {   \n        require(block.timestamp < param.maturity, 'E202');\n        unchecked { require(param.maturity - block.timestamp < 0x100000000, 'E208'); }\n        require(param.liquidityTo != address(0), 'E201');\n        require(param.dueTo != address(0), 'E201');\n        require(param.liquidityTo != address(this), 'E204');\n        require(param.dueTo != address(this), 'E204');\n        require(param.xIncrease != 0, 'E205');\n        require(param.yIncrease != 0, 'E205');\n        require(param.zIncrease != 0, 'E205');\n        \n        Pool storage pool = pools[param.maturity];\n\n        uint256 feeStoredIncrease;\n        (liquidityOut, dueOut, feeStoredIncrease) = TimeswapMath.mint(\n            param.maturity,\n            pool.state,\n            param.xIncrease,\n            param.yIncrease,\n            param.zIncrease\n        );\n\n        require(liquidityOut != 0, 'E212');\n        pool.state.totalLiquidity += liquidityOut;\n        pool.liquidities[param.liquidityTo] += liquidityOut;\n\n        pool.state.feeStored += feeStoredIncrease;\n\n\n        id = pool.dues[param.dueTo].insert(dueOut);\n\n        pool.state.reserves.asset += param.xIncrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x += param.xIncrease;\n        pool.state.y += param.yIncrease;\n        pool.state.z += param.zIncrease;\n\n        assetIn = param.xIncrease;\n        assetIn += feeStoredIncrease;\n        Callback.mint(asset, collateral, assetIn, dueOut.collateral, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Mint(\n            param.maturity, \n            msg.sender, \n            param.liquidityTo, \n            param.dueTo, \n            assetIn, \n            liquidityOut, \n            id, \n            dueOut,\n            feeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function burn(BurnParam calldata param) \n        external \n        override \n        lock \n        returns (\n            uint256 assetOut, \n            uint128 collateralOut\n        ) \n    {\n        require(block.timestamp >= param.maturity, 'E203');\n        require(param.assetTo != address(0), 'E201');\n        require(param.collateralTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.collateralTo != address(this), 'E204');\n        require(param.liquidityIn != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        require(pool.state.totalLiquidity > 0, 'E206');\n\n        uint128 _assetOut;\n        uint256 feeOut;\n        (_assetOut, collateralOut, feeOut) = TimeswapMath.burn(\n            pool.state,\n            param.liquidityIn\n        );\n\n        pool.state.totalLiquidity -= param.liquidityIn;\n\n        pool.liquidities[msg.sender] -= param.liquidityIn;\n\n        assetOut = _assetOut;\n        assetOut += feeOut;\n\n        if (assetOut != 0) {\n            pool.state.reserves.asset -= _assetOut;\n            pool.state.feeStored -= feeOut;\n            asset.safeTransfer(param.assetTo, assetOut);\n        }\n        if (collateralOut != 0) {\n            pool.state.reserves.collateral -= collateralOut;\n            collateral.safeTransfer(param.collateralTo, collateralOut);\n        }\n\n        emit Burn(\n            param.maturity,\n            msg.sender, \n            param.assetTo, \n            param.collateralTo, \n            param.liquidityIn, \n            assetOut, \n            collateralOut,\n            feeOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function lend(LendParam calldata param) \n        external \n        override \n        lock \n        returns (\n            uint256 assetIn,\n            Claims memory claimsOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.bondTo != address(0), 'E201');\n        require(param.insuranceTo != address(0), 'E201');\n        require(param.bondTo != address(this), 'E204');\n        require(param.insuranceTo != address(this), 'E204');\n        require(param.xIncrease != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        require(pool.state.totalLiquidity != 0, 'E206');\n\n        uint256 feeStoredIncrease;\n        uint256 protocolFeeStoredIncrease;\n        (claimsOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.lend(\n            param.maturity,\n            pool.state,\n            param.xIncrease,\n            param.yDecrease,\n            param.zDecrease,\n            fee,\n            protocolFee\n        );\n\n        pool.state.feeStored += feeStoredIncrease;\n        protocolFeeStored += protocolFeeStoredIncrease;\n\n        pool.state.totalClaims.bondPrincipal += claimsOut.bondPrincipal;\n        pool.state.totalClaims.bondInterest += claimsOut.bondInterest;\n        pool.state.totalClaims.insurancePrincipal += claimsOut.insurancePrincipal;\n        pool.state.totalClaims.insuranceInterest += claimsOut.insuranceInterest;\n\n        pool.claims[param.bondTo].bondPrincipal += claimsOut.bondPrincipal;\n        pool.claims[param.bondTo].bondInterest += claimsOut.bondInterest;\n        pool.claims[param.insuranceTo].insurancePrincipal += claimsOut.insurancePrincipal;\n        pool.claims[param.insuranceTo].insuranceInterest += claimsOut.insuranceInterest;\n\n        pool.state.reserves.asset += param.xIncrease;\n\n        pool.state.x += param.xIncrease;\n        pool.state.y -= param.yDecrease;\n        pool.state.z -= param.zDecrease;\n\n        assetIn = param.xIncrease;\n        assetIn += feeStoredIncrease;\n        assetIn += protocolFeeStoredIncrease;\n\n        Callback.lend(asset, assetIn, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Lend(\n            param.maturity,\n            msg.sender, \n            param.bondTo, \n            param.insuranceTo, \n            assetIn, \n            claimsOut,\n            feeStoredIncrease,\n            protocolFeeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function withdraw(WithdrawParam calldata param)\n        external \n        override \n        lock \n        returns (\n            Tokens memory tokensOut\n        ) \n    {\n        require(block.timestamp >= param.maturity, 'E203');\n        require(param.assetTo != address(0), 'E201');\n        require(param.collateralTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.collateralTo != address(this), 'E204');\n        require(\n            param.claimsIn.bondPrincipal != 0 || \n            param.claimsIn.bondInterest != 0 ||\n            param.claimsIn.insurancePrincipal != 0 ||\n            param.claimsIn.insuranceInterest != 0, \n            'E205'\n        );\n\n        Pool storage pool = pools[param.maturity];\n\n        tokensOut = TimeswapMath.withdraw(pool.state, param.claimsIn);\n\n        pool.state.totalClaims.bondPrincipal -= param.claimsIn.bondPrincipal;\n        pool.state.totalClaims.bondInterest -= param.claimsIn.bondInterest;\n        pool.state.totalClaims.insurancePrincipal -= param.claimsIn.insurancePrincipal;\n        pool.state.totalClaims.insuranceInterest -= param.claimsIn.insuranceInterest;\n\n        Claims storage sender = pool.claims[msg.sender];\n\n        sender.bondPrincipal -= param.claimsIn.bondPrincipal;\n        sender.bondInterest -= param.claimsIn.bondInterest;\n        sender.insurancePrincipal -= param.claimsIn.insurancePrincipal;\n        sender.insuranceInterest -= param.claimsIn.insuranceInterest;\n\n        if (tokensOut.asset != 0) {\n            pool.state.reserves.asset -= tokensOut.asset;\n            asset.safeTransfer(param.assetTo, tokensOut.asset);\n        }\n        if (tokensOut.collateral != 0) {\n            pool.state.reserves.collateral -= tokensOut.collateral;\n            collateral.safeTransfer(param.collateralTo, tokensOut.collateral);\n        }\n\n        emit Withdraw(\n            param.maturity,\n            msg.sender, \n            param.assetTo, \n            param.collateralTo, \n            param.claimsIn, \n            tokensOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function borrow(BorrowParam calldata param)\n        external \n        override \n        lock \n        returns (\n            uint256 assetOut,\n            uint256 id, \n            Due memory dueOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.assetTo != address(0), 'E201');\n        require(param.dueTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.dueTo != address(this), 'E204');\n        require(param.xDecrease != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        require(pool.state.totalLiquidity != 0, 'E206');\n\n        uint256 feeStoredIncrease;\n        uint256 protocolFeeStoredIncrease;\n        (dueOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.borrow(\n            param.maturity,\n            pool.state,\n            param.xDecrease,\n            param.yIncrease,\n            param.zIncrease,\n            fee,\n            protocolFee\n        );\n\n        pool.state.feeStored += feeStoredIncrease;\n        protocolFeeStored += protocolFeeStoredIncrease;\n\n        id = pool.dues[param.dueTo].insert(dueOut);\n\n        pool.state.reserves.asset -= param.xDecrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x -= param.xDecrease;\n        pool.state.y += param.yIncrease;\n        pool.state.z += param.zIncrease;\n\n        assetOut = param.xDecrease;\n        assetOut -= feeStoredIncrease;\n        assetOut -= protocolFeeStoredIncrease;\n\n        asset.safeTransfer(param.assetTo, assetOut);\n\n        Callback.borrow(collateral, dueOut.collateral, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Borrow(\n            param.maturity, \n            msg.sender, \n            param.assetTo, \n            param.dueTo, \n            assetOut, \n            id, \n            dueOut,\n            feeStoredIncrease,\n            protocolFeeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function pay(PayParam calldata param)\n        external \n        override \n        lock \n        returns (\n            uint128 assetIn, \n            uint128 collateralOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.owner != address(0), 'E201');\n        require(param.to != address(0), 'E201');\n        require(param.to != address(this), 'E204');\n        require(param.ids.length == param.assetsIn.length, 'E205');\n        require(param.ids.length == param.collateralsOut.length, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n\n        Due[] storage dues = pool.dues[param.owner];\n        require(dues.length >= param.ids.length, 'E205');\n\n        for (uint256 i; i < param.ids.length;) {\n            Due storage due = dues[param.ids[i]];\n            require(due.startBlock != BlockNumber.get(), 'E207');\n            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');\n            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');\n            due.debt -= param.assetsIn[i];\n            due.collateral -= param.collateralsOut[i];\n            assetIn += param.assetsIn[i];\n            collateralOut += param.collateralsOut[i];\n            unchecked { ++i; }\n        }\n\n        pool.state.reserves.asset += assetIn;\n        pool.state.reserves.collateral -= collateralOut;\n\n        if (collateralOut != 0) collateral.safeTransfer(param.to, collateralOut);\n\n        if (assetIn != 0) Callback.pay(asset, assetIn, param.data);\n\n        emit Pay(\n            param.maturity, \n            msg.sender, \n            param.to, \n            param.owner, \n            param.ids, \n            param.assetsIn, \n            param.collateralsOut, \n            assetIn, \n            collateralOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function collectProtocolFee(address to) external override lock returns (uint256 protocolFeeOut) {\n        require(msg.sender == factory.owner(), 'E216');\n\n        protocolFeeOut = protocolFeeStored;\n        protocolFeeStored = 0;\n\n        asset.safeTransfer(to, protocolFeeOut);\n\n        emit CollectProtocolFee(msg.sender, to, protocolFeeOut);\n    }\n}"
    }
  ]
}