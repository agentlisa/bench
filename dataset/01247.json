{
  "Title": "Changes in `dittoShorterRate` affect retroactively to accrued Ditto yield shares",
  "Content": "# Changes in `dittoShorterRate` affect retroactively to accrued Ditto yield shares\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/YieldFacet.sol#L135C17-L135C41\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/YieldFacet.sol#L135C17-L135C41</a>\n\n\n## Summary\n\nThe calculation of the Ditto rewards earned by shorters does not take into account that the changes in the Ditto shorter rate will impact retroactively, inflating or deflating the new Ditto rewards of the users.\n\n## Vulnerability Details\n\n`YieldFacet.sol:distributeYield()` calculates and credits ZETH and Ditto rewards earned from short records by `msg.sender`.\nThe distribution of the rewards is performed in the `_claimYield()` function:\n\n```solidity\n125     // Credit ZETH and Ditto rewards earned from shortRecords from all markets\n126     function _claimYield(uint256 vault, uint88 yield, uint256 dittoYieldShares) private {\n127         STypes.Vault storage Vault = s.vault[vault];\n128         STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n129         // Implicitly checks for a valid vault\n130         if (yield <= 1) revert Errors.NoYield();\n131         // Credit yield to ethEscrowed\n132         VaultUser.ethEscrowed += yield;\n133         // Ditto rewards earned for all shorters since inception\n134         uint256 protocolTime = LibOrders.getOffsetTime();\n135         uint256 dittoRewardShortersTotal = Vault.dittoShorterRate * protocolTime;\n136         // Ditto reward proportion from this yield distribution\n137         uint256 dittoYieldSharesTotal = Vault.zethCollateralReward;\n138         uint256 dittoReward =\n139             dittoYieldShares.mul(dittoRewardShortersTotal).div(dittoYieldSharesTotal);\n140         // Credit ditto reward to user\n141         if (dittoReward > type(uint80).max) revert Errors.InvalidAmount();\n142         VaultUser.dittoReward += uint80(dittoReward);\n143     }\n```\n\nFocusing on the Ditto rewards, we can see that the function receives the number of yield shares earned by the user (`dittoYieldShares`) and in line 138 calculates the Ditto reward by multiplying this amount by the total amount of rewards of the protocol (`dittoRewardShortersTotal`) and dividing it by the total amount of yield shares of the protocol (`dittoYieldSharesTotal`).\n\nIf we take a look in line 135 at how the `dittoRewardShortersTotal` is calculated, we can see that it is the product of the Ditto shorter rate and total time elapsed since the protocol deployment.\n\nThis last calculation is wrong, as it is assumed that the Ditto shorter rate is constant, but this parameter can be changed by the admin or the DAO. This means that the changes in the Ditto shorter rate will impact retroactively, inflating or deflating the new Ditto rewards of the users. Also, users that have yielded the same number of shares during the same period, will receive different rewards depending on whether they claim their rewards before or after the Ditto shorter rate change.\n\n## Proof of Concept\n\nAdd the following code snippet into `test/Yield.t.sol` and run `forge test --mt testYieldRateChange`.\n\n```solidity\n    function testYieldRateChange() public {\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        address[] memory assets = new address[](1);\n        assets[0] = asset;\n\n        fundLimitBid(DEFAULT_PRICE, 320000 ether, receiver);\n        fundLimitShort(DEFAULT_PRICE, 80000 ether, alice);\n        fundLimitShort(DEFAULT_PRICE, 80000 ether, bob);\n        generateYield();\n        skip(yieldEligibleTime);\n\n        // Alice and Bob have the same number of Ditto yield shares\n        assertEq(diamond.getDittoMatchedReward(vault, alice), diamond.getDittoMatchedReward(vault, alice));\n\n        // Alice's yield is distributed\n        vm.prank(alice);\n        diamond.distributeYield(assets);\n\n        // Ditto shorter rate is updated\n        vm.prank(owner);\n        diamond.setDittoShorterRate(vault, 2);\n\n        // Bob's yield is distributed\n        vm.prank(bob);\n        diamond.distributeYield(assets);\n\n        uint256 aliceDittoRewards = diamond.getDittoReward(vault, alice);\n        uint256 bobDittoRewards = diamond.getDittoReward(vault, bob);\n\n        // Bob receives more Ditto rewards than Alice, even both were entitled to the same amount\n        assertApproxEqAbs(aliceDittoRewards * 2, bobDittoRewards, 2);\n    }\n```\n\n## Impact\n\nChanges in the Ditto shorter rate will impact retroactively, inflating or deflating the new Ditto rewards of the users. Users might not be incentivized to claim their rewards, as they might receive more rewards if they wait for the Ditto shorter rate to change.\n\n## Tools Used \n\nManual review.\n\n## Recommendations\n\nCreate two new state variables that keep track of the timestamp of the last Ditto shorter rate update and the total Ditto rewards accrued at that time. Then the calculation of `dittoRewardShortersTotal` would be:\n\n```solidity\n    uint256 dittoRewardShortersTotal = lastSnapshotRewards + Vault.dittoShorterRate * (protocolTime - lastSnapshotTimestamp);\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/YieldFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IAsset} from \"interfaces/IAsset.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibVault} from \"contracts/libraries/LibVault.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract YieldFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n    using LibShortRecord for STypes.ShortRecord;\n    using LibVault for uint256;\n\n    IAsset private immutable DITTO;\n\n    constructor(address _ditto) {\n        DITTO = IAsset(_ditto);\n    }\n\n    /**\n     * @notice Updates the vault yield rate from staking rewards earned by bridge contracts holding LSD\n     * @dev Does not distribute yield to any individual owner of shortRecords\n     *\n     * @param vault The vault that will be impacted\n     */\n\n    function updateYield(uint256 vault) external nonReentrant {\n        vault.updateYield();\n        emit Events.UpdateYield(vault);\n    }\n\n    /**\n     * @notice Updates the vault yield rate from staking rewards earned by bridge contracts holding LSD\n     * @dev Can only distribute yield in markets that are part of the same vault\n     *\n     * @param assets Array of markets to evaluate when distributing yield from caller's shortRecords\n     */\n\n    function distributeYield(address[] calldata assets) external nonReentrant {\n        uint256 length = assets.length;\n        uint256 vault = s.asset[assets[0]].vault;\n\n        // distribute yield for the first order book\n        (uint88 yield, uint256 dittoYieldShares) = _distributeYield(assets[0]);\n\n        // distribute yield for remaining order books\n        for (uint256 i = 1; i < length;) {\n            if (s.asset[assets[i]].vault != vault) revert Errors.DifferentVaults();\n            (uint88 amtYield, uint256 amtDittoYieldShares) = _distributeYield(assets[i]);\n            yield += amtYield;\n            dittoYieldShares += amtDittoYieldShares;\n            unchecked {\n                ++i;\n            }\n        }\n        // claim all distributed yield\n        _claimYield(vault, yield, dittoYieldShares);\n        emit Events.DistributeYield(vault, msg.sender, yield, dittoYieldShares);\n    }\n\n    // Distributes yield earned from all of caller's shortRecords of this asset\n    function _distributeYield(address asset)\n        private\n        onlyValidAsset(asset)\n        returns (uint88 yield, uint256 dittoYieldShares)\n    {\n        uint256 vault = s.asset[asset].vault;\n        // Last updated zethYieldRate for this vault\n        uint80 zethYieldRate = s.vault[vault].zethYieldRate;\n        // Protocol time\n        uint256 timestamp = LibOrders.getOffsetTimeHours();\n        // Last saved oracle price\n        uint256 oraclePrice = LibOracle.getPrice(asset);\n        // CR of shortRecord collateralized at initialMargin for this asset\n        uint256 initialCR = LibAsset.initialMargin(asset) + 1 ether;\n        // Retrieve first non-HEAD short\n        uint8 id = s.shortRecords[asset][msg.sender][Constants.HEAD].nextId;\n        // Loop through all shorter's shorts of this asset\n        while (true) {\n            // One short of one shorter in this market\n            STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n            // To prevent flash loans or loans where they want to deposit to claim yield immediately\n            bool isNotRecentlyModified =\n                timestamp - short.updatedAt > Constants.YIELD_DELAY_HOURS;\n            // Check for cancelled short\n            if (short.status != SR.Cancelled && isNotRecentlyModified) {\n                uint88 shortYield =\n                    short.collateral.mulU88(zethYieldRate - short.zethYieldRate);\n                // Yield earned by this short\n                yield += shortYield;\n                // Update zethYieldRate for this short\n                short.zethYieldRate = zethYieldRate;\n                // Calculate CR to modify ditto rewards\n                uint256 cRatio = short.getCollateralRatioSpotPrice(oraclePrice);\n                if (cRatio <= initialCR) {\n                    dittoYieldShares += shortYield;\n                } else {\n                    // Reduce amount of yield credited for ditto rewards proportional to CR\n                    dittoYieldShares += shortYield.mul(initialCR).div(cRatio);\n                }\n            }\n            // Move to next short unless this is the last one\n            if (short.nextId > Constants.HEAD) {\n                id = short.nextId;\n            } else {\n                break;\n            }\n        }\n    }\n\n    // Credit ZETH and Ditto rewards earned from shortRecords from all markets\n    function _claimYield(uint256 vault, uint88 yield, uint256 dittoYieldShares) private {\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n        // Implicitly checks for a valid vault\n        if (yield <= 1) revert Errors.NoYield();\n        // Credit yield to ethEscrowed\n        VaultUser.ethEscrowed += yield;\n        // Ditto rewards earned for all shorters since inception\n        uint256 protocolTime = LibOrders.getOffsetTime();\n        uint256 dittoRewardShortersTotal = Vault.dittoShorterRate * protocolTime;\n        // Ditto reward proportion from this yield distribution\n        uint256 dittoYieldSharesTotal = Vault.zethCollateralReward;\n        uint256 dittoReward =\n            dittoYieldShares.mul(dittoRewardShortersTotal).div(dittoYieldSharesTotal);\n        // Credit ditto reward to user\n        if (dittoReward > type(uint80).max) revert Errors.InvalidAmount();\n        VaultUser.dittoReward += uint80(dittoReward);\n    }\n\n    /**\n     * @notice Credits ditto rewards earned from eligible limit orders from all markets\n     *\n     * @param vault The vault that will be impacted\n     */\n\n    function claimDittoMatchedReward(uint256 vault) external nonReentrant {\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n        // User's shares total\n        uint88 shares = VaultUser.dittoMatchedShares;\n        // Implicitly checks for a valid vault\n        if (shares <= 1) revert Errors.NoShares();\n        // Decrease by 1 wei to account for 1 wei gas saving technique\n        shares -= 1;\n        // Total token reward amount for limit orders\n        uint256 protocolTime = LibOrders.getOffsetTime() / 1 days;\n        uint256 elapsedTime = protocolTime - Vault.dittoMatchedTime;\n        uint256 totalReward =\n            Vault.dittoMatchedReward + elapsedTime * 1 days * Vault.dittoMatchedRate;\n        // User's proportion of the total token reward\n        uint256 sharesTotal = Vault.dittoMatchedShares;\n        uint256 userReward = shares.mul(totalReward).div(sharesTotal);\n        // Only update dittoMatchedTime when totalReward increases\n        if (elapsedTime > 0) {\n            Vault.dittoMatchedTime = uint16(protocolTime); // @dev(safe-cast)\n        }\n        // Update remaining records\n        Vault.dittoMatchedShares -= shares;\n        if ((totalReward - userReward) > type(uint96).max) revert Errors.InvalidAmount();\n        Vault.dittoMatchedReward = uint96(totalReward - userReward);\n        VaultUser.dittoMatchedShares = 1; // keep as non-zero to save gas\n        if (userReward > type(uint80).max) revert Errors.InvalidAmount();\n        VaultUser.dittoReward += uint80(userReward);\n        emit Events.ClaimDittoMatchedReward(vault, msg.sender);\n    }\n\n    /**\n     * @notice Mints claimed Ditto rewards\n     * @dev Includes claimed balances from shortRecords and limit orders\n     *\n     * @param vault The vault that will be impacted\n     */\n\n    function withdrawDittoReward(uint256 vault) external nonReentrant {\n        STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n        uint256 amt = VaultUser.dittoReward;\n        // Implicitly checks for a valid vault\n        if (amt <= 1) revert Errors.NoDittoReward();\n        // Decrease by 1 wei to account for 1 wei gas saving technique\n        amt -= 1;\n        VaultUser.dittoReward = 1; // keep as non-zero to save gas\n        DITTO.mint(msg.sender, amt);\n    }\n}"
    }
  ]
}