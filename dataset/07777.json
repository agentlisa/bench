{
  "Title": "[M-09] Variable balance ERC20 support",
  "Content": "# Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L94-L96\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L75-L79\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L273-L280\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L487-L493\n\n\n# Vulnerability details\n\n## Impact\n\nSome ERC20 may be tricky for the balance. Such as:\n- fee on transfer (STA, USDT also has this mode)\n- rebasing (aToken from AAVE)\n- variable balance (stETH, balance could go up and down)\n\nFor these tokens, the balance can change over time, even without `transfer()/transferFrom()`. But current accounting stores the spot balance of the asset. \n\nThe impacts include:\n- the calculation of collateral value could be inaccurate\n- protocol could lose fund due to the deposit/repay amount might be less than the actual transferred amount after fee\n- the amount user withdraw collateral when `_close()` will be inaccurate\n    - some users could lose fund due to under value\n    - some fund could be locked due to the balance inflation\n    - some fund might be locked due to the balance deflation\n\n\n## Proof of Concept\n\nThe spot new deposit amount is stored in the mapping `self.deposited[token].amount` and `credit.deposit`, and later used to calculate the collateral value and withdraw amount.\n```solidity\n// Line-of-Credit/contracts/utils/EscrowLib.sol\n    function addCollateral(EscrowState storage self, address oracle, uint256 amount, address token) {\n        // ...\n        LineLib.receiveTokenOrETH(token, msg.sender, amount);\n\n        self.deposited[token].amount += amount;\n        // ...\n    }\n\n    function _getCollateralValue(EscrowState storage self, address oracle) public returns (uint256) {\n            // ...\n            d = self.deposited[token];\n                // ...\n                collateralValue += CreditLib.calculateValue(\n                  o.getLatestAnswer(d.asset),\n                  deposit,\n                  d.assetDecimals\n                );\n            // ...\n    }\n\n// Line-of-Credit/contracts/modules/credit/LineOfCredit.sol\n    function increaseCredit(bytes32 id, uint256 amount) {\n        // ...\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        credit.deposit += amount;\n        \n        credits[id] = credit;\n\n        LineLib.receiveTokenOrETH(credit.token, credit.lender, amount);\n\n        // ...\n    }\n\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        // ...\n        if (credit.deposit + credit.interestRepaid > 0) {\n            LineLib.sendOutTokenOrETH(\n                credit.token,\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n```\n\nHowever, if the balance changed later, the returned collateral value will be inaccurate. And the amount used when withdraw collateral in `_close()` is also wrong.\n\n\n## Tools Used\nManual analysis.\n\n## Recommended Mitigation Steps\n\n- checking the before and after balance of token transfer\n- recording the relative shares of each user instead of specific amount\n- if necessary, call `ERC20(token).balanceOf()` to confirm the balance\n- disallow such kind of tokens\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-debt-dao-contest",
  "Code": [
    {
      "filename": "contracts/utils/EscrowLib.sol",
      "content": "pragma solidity 0.8.9;\n\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {IOracle} from \"../interfaces/IOracle.sol\";\nimport {ILineOfCredit} from \"../interfaces/ILineOfCredit.sol\";\nimport {IEscrow} from \"../interfaces/IEscrow.sol\";\nimport {CreditLib} from \"../utils/CreditLib.sol\";\nimport {LineLib} from \"../utils/LineLib.sol\";\n\nstruct EscrowState {\n    address line;\n    address[] collateralTokens;\n    /// if lenders allow token as collateral. ensures uniqueness in collateralTokens\n    mapping(address => bool) enabled;\n    /// tokens used as collateral (must be able to value with oracle)\n    mapping(address => IEscrow.Deposit) deposited;\n}\n\nlibrary EscrowLib {\n    using SafeERC20 for IERC20;\n\n    // return if have collateral but no debt\n    uint256 constant MAX_INT =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    /**\n     * @notice updates the cratio according to the collateral value vs line value\n     * @dev calls accrue interest on the line contract to update the latest interest payable\n     * @param oracle - address to call for collateral token prices\n     * @return cratio - the updated collateral ratio in 4 decimals\n    */\n    function _getLatestCollateralRatio(EscrowState storage self, address oracle) public returns (uint256) {\n        (uint256 principal, uint256 interest) = ILineOfCredit(self.line).updateOutstandingDebt();\n        uint256 debtValue =  principal + interest;\n        uint256 collateralValue = _getCollateralValue(self, oracle);\n        if (debtValue == 0) return MAX_INT;\n        if (collateralValue == 0) return 0;\n        \n\n        uint256 _numerator = collateralValue * 10**5; // scale to 4 decimals\n        return ((_numerator / debtValue) + 5) / 10;\n    }\n\n    /**\n    * @notice - Iterates over all enabled tokens and calculates the USD value of all deposited collateral\n    * @param oracle - address to call for collateral token prices\n    * @return totalCollateralValue - the collateral's USD value in 8 decimals\n    */\n    function _getCollateralValue(EscrowState storage self, address oracle) public returns (uint256) {\n        uint256 collateralValue;\n        // gas savings\n        uint256 length = self.collateralTokens.length;\n        IOracle o = IOracle(oracle); \n        IEscrow.Deposit memory d;\n        for (uint256 i; i < length; ++i) {\n            address token = self.collateralTokens[i];\n            d = self.deposited[token];\n             // new var so we don't override original deposit amount for 4626 tokens\n            uint256 deposit = d.amount;\n            if (deposit != 0) {\n                if (d.isERC4626) {\n                    // this conversion could shift, hence it is best to get it each time\n                    (bool success, bytes memory assetAmount) = token.call(\n                        abi.encodeWithSignature(\n                            \"previewRedeem(uint256)\",\n                            deposit\n                        )\n                    );\n                    if (!success) continue;\n                    deposit = abi.decode(assetAmount, (uint256));\n                }\n\n                collateralValue += CreditLib.calculateValue(\n                  o.getLatestAnswer(d.asset),\n                  deposit,\n                  d.assetDecimals\n                );\n            }\n        }\n\n        return collateralValue;\n    }\n\n    /** see Escrow.addCollateral */\n    function addCollateral(EscrowState storage self, address oracle, uint256 amount, address token)\n        external\n        returns (uint256)\n    {\n        require(amount > 0);\n        if(!self.enabled[token])  { revert InvalidCollateral(); }\n\n        LineLib.receiveTokenOrETH(token, msg.sender, amount);\n\n        self.deposited[token].amount += amount;\n\n        emit AddCollateral(token, amount);\n\n        return _getLatestCollateralRatio(self, oracle);\n    }\n\n    /** see Escrow.enableCollateral */\n    function enableCollateral(EscrowState storage self, address oracle, address token) external returns (bool) {\n        require(msg.sender == ILineOfCredit(self.line).arbiter());\n\n        bool isEnabled = self.enabled[token];\n        IEscrow.Deposit memory deposit = self.deposited[token]; // gas savings\n        if (!isEnabled) {\n            if (token == Denominations.ETH) {\n                // enable native eth support\n                deposit.asset = Denominations.ETH;\n                deposit.assetDecimals = 18;\n            } else {\n                (bool passed, bytes memory tokenAddrBytes) = token.call(\n                    abi.encodeWithSignature(\"asset()\")\n                );\n\n                bool is4626 = tokenAddrBytes.length > 0 && passed;\n                deposit.isERC4626 = is4626;\n                // if 4626 save the underlying token to use for oracle pricing\n                deposit.asset = !is4626\n                    ? token\n                    : abi.decode(tokenAddrBytes, (address));\n\n                int256 price = IOracle(oracle).getLatestAnswer(deposit.asset);\n                if (price <= 0) {\n                    revert InvalidCollateral();\n                }\n\n                (bool successDecimals, bytes memory decimalBytes) = deposit\n                    .asset\n                    .call(abi.encodeWithSignature(\"decimals()\"));\n                if (decimalBytes.length > 0 && successDecimals) {\n                    deposit.assetDecimals = abi.decode(decimalBytes, (uint8));\n                } else {\n                    deposit.assetDecimals = 18;\n                }\n            }\n\n            // update collateral settings\n            self.enabled[token] = true;\n            self.deposited[token] = deposit;\n            self.collateralTokens.push(token);\n            emit EnableCollateral(deposit.asset);\n        }\n\n        return true;\n    }\n\n    /** see Escrow.releaseCollateral */\n    function releaseCollateral(\n        EscrowState storage self,\n        address borrower,\n        address oracle,\n        uint256 minimumCollateralRatio,\n        uint256 amount,\n        address token,\n        address to\n    ) external returns (uint256) {\n        require(amount > 0);\n        if(msg.sender != borrower) { revert CallerAccessDenied(); }\n        if(self.deposited[token].amount < amount) { revert InvalidCollateral(); }\n        self.deposited[token].amount -= amount;\n        \n        LineLib.sendOutTokenOrETH(token, to, amount);\n\n        uint256 cratio = _getLatestCollateralRatio(self, oracle);\n        // fail if reduces cratio below min \n        // but allow borrower to always withdraw if fully repaid\n        if(\n          cratio < minimumCollateralRatio &&         // if undercollateralized, revert;\n          ILineOfCredit(self.line).status() != LineLib.STATUS.REPAID // if repaid, skip;\n        ) { revert UnderCollateralized(); }\n        \n        emit RemoveCollateral(token, amount);\n\n        return cratio;\n    }\n\n    /** see Escrow.getCollateralRatio */\n    function getCollateralRatio(EscrowState storage self, address oracle) external returns (uint256) {\n        return _getLatestCollateralRatio(self, oracle);\n    }\n\n    /** see Escrow.getCollateralValue */\n    function getCollateralValue(EscrowState storage self, address oracle) external returns (uint256) {\n        return _getCollateralValue(self, oracle);\n    }\n\n    /** see Escrow.liquidate */\n    function liquidate(\n        EscrowState storage self,\n        uint256 amount,\n        address token,\n        address to\n    ) external returns (bool) {\n        require(amount > 0);\n        if(msg.sender != self.line) { revert CallerAccessDenied(); }\n        if(self.deposited[token].amount < amount) { revert InvalidCollateral(); }\n\n        self.deposited[token].amount -= amount;\n        \n        LineLib.sendOutTokenOrETH(token, to, amount);\n\n        return true;\n    }\n\n    /** see Escrow.isLiquidatable */\n    function isLiquidatable(EscrowState storage self, address oracle, uint256 minimumCollateralRatio) external returns(bool) {\n      return _getLatestCollateralRatio(self, oracle) < minimumCollateralRatio;\n    }\n\n    /** see Escrow.updateLine */\n    function updateLine(EscrowState storage self, address _line) external returns(bool) {\n      require(msg.sender == self.line);\n      self.line = _line;\n      return true;\n    }\n\n    event AddCollateral(address indexed token, uint256 indexed amount);\n\n    event RemoveCollateral(address indexed token, uint256 indexed amount);\n\n    event EnableCollateral(address indexed token);\n    \n    event Liquidate(address indexed token, uint256 indexed amount);\n\n    error InvalidCollateral();\n\n    error CallerAccessDenied();\n\n    error UnderCollateralized();\n\n    error NotLiquidatable();\n}"
    },
    {
      "filename": "contracts/utils/EscrowLib.sol",
      "content": "pragma solidity 0.8.9;\n\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {IOracle} from \"../interfaces/IOracle.sol\";\nimport {ILineOfCredit} from \"../interfaces/ILineOfCredit.sol\";\nimport {IEscrow} from \"../interfaces/IEscrow.sol\";\nimport {CreditLib} from \"../utils/CreditLib.sol\";\nimport {LineLib} from \"../utils/LineLib.sol\";\n\nstruct EscrowState {\n    address line;\n    address[] collateralTokens;\n    /// if lenders allow token as collateral. ensures uniqueness in collateralTokens\n    mapping(address => bool) enabled;\n    /// tokens used as collateral (must be able to value with oracle)\n    mapping(address => IEscrow.Deposit) deposited;\n}\n\nlibrary EscrowLib {\n    using SafeERC20 for IERC20;\n\n    // return if have collateral but no debt\n    uint256 constant MAX_INT =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    /**\n     * @notice updates the cratio according to the collateral value vs line value\n     * @dev calls accrue interest on the line contract to update the latest interest payable\n     * @param oracle - address to call for collateral token prices\n     * @return cratio - the updated collateral ratio in 4 decimals\n    */\n    function _getLatestCollateralRatio(EscrowState storage self, address oracle) public returns (uint256) {\n        (uint256 principal, uint256 interest) = ILineOfCredit(self.line).updateOutstandingDebt();\n        uint256 debtValue =  principal + interest;\n        uint256 collateralValue = _getCollateralValue(self, oracle);\n        if (debtValue == 0) return MAX_INT;\n        if (collateralValue == 0) return 0;\n        \n\n        uint256 _numerator = collateralValue * 10**5; // scale to 4 decimals\n        return ((_numerator / debtValue) + 5) / 10;\n    }\n\n    /**\n    * @notice - Iterates over all enabled tokens and calculates the USD value of all deposited collateral\n    * @param oracle - address to call for collateral token prices\n    * @return totalCollateralValue - the collateral's USD value in 8 decimals\n    */\n    function _getCollateralValue(EscrowState storage self, address oracle) public returns (uint256) {\n        uint256 collateralValue;\n        // gas savings\n        uint256 length = self.collateralTokens.length;\n        IOracle o = IOracle(oracle); \n        IEscrow.Deposit memory d;\n        for (uint256 i; i < length; ++i) {\n            address token = self.collateralTokens[i];\n            d = self.deposited[token];\n             // new var so we don't override original deposit amount for 4626 tokens\n            uint256 deposit = d.amount;\n            if (deposit != 0) {\n                if (d.isERC4626) {\n                    // this conversion could shift, hence it is best to get it each time\n                    (bool success, bytes memory assetAmount) = token.call(\n                        abi.encodeWithSignature(\n                            \"previewRedeem(uint256)\",\n                            deposit\n                        )\n                    );\n                    if (!success) continue;\n                    deposit = abi.decode(assetAmount, (uint256));\n                }\n\n                collateralValue += CreditLib.calculateValue(\n                  o.getLatestAnswer(d.asset),\n                  deposit,\n                  d.assetDecimals\n                );\n            }\n        }\n\n        return collateralValue;\n    }\n\n    /** see Escrow.addCollateral */\n    function addCollateral(EscrowState storage self, address oracle, uint256 amount, address token)\n        external\n        returns (uint256)\n    {\n        require(amount > 0);\n        if(!self.enabled[token])  { revert InvalidCollateral(); }\n\n        LineLib.receiveTokenOrETH(token, msg.sender, amount);\n\n        self.deposited[token].amount += amount;\n\n        emit AddCollateral(token, amount);\n\n        return _getLatestCollateralRatio(self, oracle);\n    }\n\n    /** see Escrow.enableCollateral */\n    function enableCollateral(EscrowState storage self, address oracle, address token) external returns (bool) {\n        require(msg.sender == ILineOfCredit(self.line).arbiter());\n\n        bool isEnabled = self.enabled[token];\n        IEscrow.Deposit memory deposit = self.deposited[token]; // gas savings\n        if (!isEnabled) {\n            if (token == Denominations.ETH) {\n                // enable native eth support\n                deposit.asset = Denominations.ETH;\n                deposit.assetDecimals = 18;\n            } else {\n                (bool passed, bytes memory tokenAddrBytes) = token.call(\n                    abi.encodeWithSignature(\"asset()\")\n                );\n\n                bool is4626 = tokenAddrBytes.length > 0 && passed;\n                deposit.isERC4626 = is4626;\n                // if 4626 save the underlying token to use for oracle pricing\n                deposit.asset = !is4626\n                    ? token\n                    : abi.decode(tokenAddrBytes, (address));\n\n                int256 price = IOracle(oracle).getLatestAnswer(deposit.asset);\n                if (price <= 0) {\n                    revert InvalidCollateral();\n                }\n\n                (bool successDecimals, bytes memory decimalBytes) = deposit\n                    .asset\n                    .call(abi.encodeWithSignature(\"decimals()\"));\n                if (decimalBytes.length > 0 && successDecimals) {\n                    deposit.assetDecimals = abi.decode(decimalBytes, (uint8));\n                } else {\n                    deposit.assetDecimals = 18;\n                }\n            }\n\n            // update collateral settings\n            self.enabled[token] = true;\n            self.deposited[token] = deposit;\n            self.collateralTokens.push(token);\n            emit EnableCollateral(deposit.asset);\n        }\n\n        return true;\n    }\n\n    /** see Escrow.releaseCollateral */\n    function releaseCollateral(\n        EscrowState storage self,\n        address borrower,\n        address oracle,\n        uint256 minimumCollateralRatio,\n        uint256 amount,\n        address token,\n        address to\n    ) external returns (uint256) {\n        require(amount > 0);\n        if(msg.sender != borrower) { revert CallerAccessDenied(); }\n        if(self.deposited[token].amount < amount) { revert InvalidCollateral(); }\n        self.deposited[token].amount -= amount;\n        \n        LineLib.sendOutTokenOrETH(token, to, amount);\n\n        uint256 cratio = _getLatestCollateralRatio(self, oracle);\n        // fail if reduces cratio below min \n        // but allow borrower to always withdraw if fully repaid\n        if(\n          cratio < minimumCollateralRatio &&         // if undercollateralized, revert;\n          ILineOfCredit(self.line).status() != LineLib.STATUS.REPAID // if repaid, skip;\n        ) { revert UnderCollateralized(); }\n        \n        emit RemoveCollateral(token, amount);\n\n        return cratio;\n    }\n\n    /** see Escrow.getCollateralRatio */\n    function getCollateralRatio(EscrowState storage self, address oracle) external returns (uint256) {\n        return _getLatestCollateralRatio(self, oracle);\n    }\n\n    /** see Escrow.getCollateralValue */\n    function getCollateralValue(EscrowState storage self, address oracle) external returns (uint256) {\n        return _getCollateralValue(self, oracle);\n    }\n\n    /** see Escrow.liquidate */\n    function liquidate(\n        EscrowState storage self,\n        uint256 amount,\n        address token,\n        address to\n    ) external returns (bool) {\n        require(amount > 0);\n        if(msg.sender != self.line) { revert CallerAccessDenied(); }\n        if(self.deposited[token].amount < amount) { revert InvalidCollateral(); }\n\n        self.deposited[token].amount -= amount;\n        \n        LineLib.sendOutTokenOrETH(token, to, amount);\n\n        return true;\n    }\n\n    /** see Escrow.isLiquidatable */\n    function isLiquidatable(EscrowState storage self, address oracle, uint256 minimumCollateralRatio) external returns(bool) {\n      return _getLatestCollateralRatio(self, oracle) < minimumCollateralRatio;\n    }\n\n    /** see Escrow.updateLine */\n    function updateLine(EscrowState storage self, address _line) external returns(bool) {\n      require(msg.sender == self.line);\n      self.line = _line;\n      return true;\n    }\n\n    event AddCollateral(address indexed token, uint256 indexed amount);\n\n    event RemoveCollateral(address indexed token, uint256 indexed amount);\n\n    event EnableCollateral(address indexed token);\n    \n    event Liquidate(address indexed token, uint256 indexed amount);\n\n    error InvalidCollateral();\n\n    error CallerAccessDenied();\n\n    error UnderCollateralized();\n\n    error NotLiquidatable();\n}"
    },
    {
      "filename": "contracts/modules/credit/LineOfCredit.sol",
      "content": "pragma solidity ^0.8.9;\n\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LineLib} from \"../../utils/LineLib.sol\";\nimport {CreditLib} from \"../../utils/CreditLib.sol\";\nimport {CreditListLib} from \"../../utils/CreditListLib.sol\";\nimport {MutualConsent} from \"../../utils/MutualConsent.sol\";\nimport {InterestRateCredit} from \"../interest-rate/InterestRateCredit.sol\";\n\nimport {IOracle} from \"../../interfaces/IOracle.sol\";\nimport {ILineOfCredit} from \"../../interfaces/ILineOfCredit.sol\";\n\ncontract LineOfCredit is ILineOfCredit, MutualConsent {\n    using SafeERC20 for IERC20;\n\n    using CreditListLib for bytes32[];\n\n    uint256 public immutable deadline;\n\n    address public immutable borrower;\n\n    address public immutable arbiter;\n\n    IOracle public immutable oracle;\n\n    InterestRateCredit public immutable interestRate;\n\n    uint256 private count; // amount of open credit lines on a Line of Credit facility. ids.length includes null items\n\n    bytes32[] public ids; // all open credit lines\n\n    mapping(bytes32 => Credit) public credits; // id -> Reference ID for a credit line provided by a single Lender for a given token on a Line of Credit\n\n    // Line Financials aggregated accross all existing  Credit\n    LineLib.STATUS public status;\n\n    /**\n   * @notice            - How to deploy a Line of Credit\n   * @dev               - A Borrower and a first Lender agree on terms. Then the Borrower deploys the contract using the constructor below.\n   *                      Later, both Lender and Borrower must call _mutualConsent() during addCredit() to actually enable funds to be deposited.\n   * @param oracle_     - The price oracle to use for getting all token values.\n   * @param arbiter_    - A neutral party with some special priviliges on behalf of Borrower and Lender.\n   * @param borrower_   - The debitor for all credit lines in this contract.\n   * @param ttl_        - The time to live for all credit lines for the Line of Credit facility (sets the maturity/term of the Line of Credit)\n  */\n    constructor(\n        address oracle_,\n        address arbiter_,\n        address borrower_,\n        uint256 ttl_\n    ) {\n        oracle = IOracle(oracle_);\n        arbiter = arbiter_;\n        borrower = borrower_;\n        deadline = block.timestamp + ttl_;  //the deadline is the term/maturity/expiry date of the Line of Credit facility\n        interestRate = new InterestRateCredit();\n\n        emit DeployLine(oracle_, arbiter_, borrower_);\n    }\n\n    function init() external virtual returns(LineLib.STATUS) {\n      if(status != LineLib.STATUS.UNINITIALIZED) { revert AlreadyInitialized(); }\n      return _updateStatus(_init());\n    }\n\n    function _init() internal virtual returns(LineLib.STATUS) {\n       // If no collateral or Spigot then Line of Credit is immediately active\n      return LineLib.STATUS.ACTIVE;\n    }\n\n    ///////////////\n    // MODIFIERS //\n    ///////////////\n\n    modifier whileActive() {\n        if(status != LineLib.STATUS.ACTIVE) { revert NotActive(); }\n        _;\n    }\n\n    modifier whileBorrowing() {\n        if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n        _;\n    }\n\n    modifier onlyBorrower() {\n        if(msg.sender != borrower) { revert CallerAccessDenied(); }\n        _;\n    }\n\n    /**\n     * @notice - mutualConsent() but hardcodes borrower address and uses the position id to\n                 get Lender address instead of passing it in directly\n     * @param id - position to pull lender address from for mutual consent agreement\n    */\n    modifier mutualConsentById(bytes32 id) {\n      if(_mutualConsent(borrower, credits[id].lender))  {\n        // Run whatever code is needed for the 2/2 consent\n        _;\n      }\n    }\n\n    /**\n     * @notice - evaluates all covenants encoded in _healthcheck from different Line variants\n     * @dev - updates `status` variable in storage if current status is diferent from existing status\n     * @return - current health status of Line\n    */\n    function healthcheck() external returns (LineLib.STATUS) {\n        // can only check if the line has been initialized\n        require(uint(status) >= uint( LineLib.STATUS.ACTIVE));\n        return _updateStatus(_healthcheck());\n    }\n\n    /// see ILineOfCredit.counts\n    function counts() external view returns (uint256, uint256) {\n        return (count, ids.length);\n    }\n\n    function _healthcheck() internal virtual returns (LineLib.STATUS) {\n        // if line is in a final end state then do not run _healthcheck()\n        LineLib.STATUS s = status;\n        if (\n            s == LineLib.STATUS.REPAID ||               // end state - good\n            s == LineLib.STATUS.INSOLVENT               // end state - bad\n        ) {\n            return s;\n        }\n\n        // Liquidate if all credit lines aren't closed by deadline\n        if (block.timestamp >= deadline && count > 0) {\n            emit Default(ids[0]); // can query all defaulted positions offchain once event picked up\n            return LineLib.STATUS.LIQUIDATABLE;\n        }\n\n        // if nothing wrong, return to healthy ACTIVE state  \n        return LineLib.STATUS.ACTIVE;\n    }\n\n\n    /// see ILineOfCredit.declareInsolvent\n    function declareInsolvent() external whileBorrowing returns(bool) {\n        if(arbiter != msg.sender) { revert CallerAccessDenied(); }\n        if(LineLib.STATUS.LIQUIDATABLE != _updateStatus(_healthcheck())) {\n            revert NotLiquidatable();\n        }\n\n        if(_canDeclareInsolvent()) {\n            _updateStatus(LineLib.STATUS.INSOLVENT);\n            return true;\n        } else {\n          return false;\n        }\n    }\n\n    function _canDeclareInsolvent() internal virtual returns(bool) {\n        // logic updated in Spigoted and Escrowed lines\n        return true;\n    }\n\n    /// see ILineOfCredit.updateOutstandingDebt\n    function updateOutstandingDebt() external override returns (uint256, uint256) {\n        return _updateOutstandingDebt();\n    }\n\n    function _updateOutstandingDebt()\n        internal\n        returns (uint256 principal, uint256 interest)\n    {\n        // use full length not count because positions might not be packed in order\n        uint256 len = ids.length;\n        if (len == 0) return (0, 0);\n\n        bytes32 id;\n        address oracle_ = address(oracle);  // gas savings\n        address interestRate_ = address(interestRate); // gas savings\n        \n        for (uint256 i; i < len; ++i) {\n            id = ids[i];\n\n            // null element in array from closing a position. skip for gas savings\n            if(id == bytes32(0)) { continue; }\n\n            (Credit memory c, uint256 _p, uint256 _i) = CreditLib.getOutstandingDebt(\n              credits[id],\n              id,\n              oracle_,\n              interestRate_\n            );\n            // update total outstanding debt\n            principal += _p;\n            interest += _i;\n            // save changes to storage\n            credits[id] = c;\n        }\n    }\n\n    /// see ILineOfCredit.accrueInterest\n    function accrueInterest() external override returns(bool) {\n        uint256 len = ids.length;\n        bytes32 id;\n        for (uint256 i; i < len; ++i) {\n          id = ids[i];\n          Credit memory credit = credits[id];\n          credits[id] = _accrue(credit, id);\n        }\n        \n        return true;\n    }\n\n    /**\n      @notice - accrues token demoninated interest on a lender's position.\n      @dev MUST call any time a position balance or interest rate changes\n      @param credit - the lender position that is accruing interest\n      @param id - the position id for credit position\n    */\n    function _accrue(Credit memory credit, bytes32 id) internal returns(Credit memory) {\n      return CreditLib.accrue(credit, id, address(interestRate));\n    }\n\n    /// see ILineOfCredit.addCredit\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token,\n        address lender\n    )\n        external\n        payable\n        override\n        whileActive\n        mutualConsent(lender, borrower)\n        returns (bytes32)\n    {\n        LineLib.receiveTokenOrETH(token, lender, amount);\n\n        bytes32 id = _createCredit(lender, token, amount);\n\n        require(interestRate.setRate(id, drate, frate));\n        \n        return id;\n    }\n\n    /// see ILineOfCredit.setRates\n    function setRates(\n        bytes32 id,\n        uint128 drate,\n        uint128 frate\n    )\n      external\n      override\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credits[id] = _accrue(credit, id);\n        require(interestRate.setRate(id, drate, frate));\n        emit SetRates(id, drate, frate);\n        return true;\n    }\n\n    /// see ILineOfCredit.increaseCredit\n    function increaseCredit(bytes32 id, uint256 amount)\n      external\n      payable\n      override\n      whileActive\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        credit.deposit += amount;\n        \n        credits[id] = credit;\n\n        LineLib.receiveTokenOrETH(credit.token, credit.lender, amount);\n\n        emit IncreaseCredit(id, amount);\n\n        return true;\n    }\n\n    ///////////////\n    // REPAYMENT //\n    ///////////////\n\n    /// see ILineOfCredit.depositAndClose\n    function depositAndClose()\n        external\n        payable\n        override\n        whileBorrowing\n        onlyBorrower\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = _accrue(credits[id], id);\n\n        // Borrower deposits the outstanding balance not already repaid\n        uint256 totalOwed = credit.principal + credit.interestAccrued;\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, totalOwed);\n\n        // Borrower clears the debt then closes and deletes the credit line\n        _close(_repay(credit, id, totalOwed), id);\n\n        return true;\n    }\n\n\n    /// see ILineOfCredit.depositAndRepay\n    function depositAndRepay(uint256 amount)\n        external\n        payable\n        override\n        whileBorrowing\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        require(amount <= credit.principal + credit.interestAccrued);\n\n        credits[id] = _repay(credit, id, amount);\n\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, amount);\n\n        return true;\n    }\n\n    ////////////////////\n    // FUND TRANSFERS //\n    ////////////////////\n\n    /// see ILineOfCredit.borrow\n    function borrow(bytes32 id, uint256 amount)\n        external\n        override\n        whileActive\n        onlyBorrower\n        returns (bool)\n    {\n        Credit memory credit = _accrue(credits[id], id);\n\n        if(amount > credit.deposit - credit.principal) { revert NoLiquidity(); }\n\n        credit.principal += amount;\n\n        credits[id] = credit; // save new debt before healthcheck\n\n        // ensure that borrowing doesnt cause Line to be LIQUIDATABLE\n        if(_updateStatus(_healthcheck()) != LineLib.STATUS.ACTIVE) { \n            revert NotActive();\n        }\n\n        LineLib.sendOutTokenOrETH(credit.token, borrower, amount);\n\n        emit Borrow(id, amount);\n\n        _sortIntoQ(id);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.withdraw\n    function withdraw(bytes32 id, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        Credit memory credit = credits[id];\n\n        if(msg.sender != credit.lender) { revert CallerAccessDenied(); }\n\n        // accrues interest and transfers to Lender\n        credits[id] = CreditLib.withdraw(_accrue(credit, id), id, amount);\n\n        LineLib.sendOutTokenOrETH(credit.token, credit.lender, amount);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.close\n    function close(bytes32 id) external payable override returns (bool) {\n        Credit memory credit = credits[id];\n        address b = borrower; // gas savings\n        if(msg.sender != credit.lender && msg.sender != b) {\n          revert CallerAccessDenied();\n        }\n\n        // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off\n        credit = _accrue(credit, id);\n        uint256 facilityFee = credit.interestAccrued;\n        if(facilityFee > 0) {\n          // only allow repaying interest since they are skipping repayment queue.\n          // If principal still owed, _close() MUST fail\n          LineLib.receiveTokenOrETH(credit.token, b, facilityFee);\n\n          credit = _repay(credit, id, facilityFee);\n        }\n\n        _close(credit, id); // deleted; no need to save to storage\n\n        return true;\n    }\n\n    //////////////////////\n    //  Internal  funcs //\n    //////////////////////\n\n    /**\n      * @notice - updates `status` variable in storage if current status is diferent from existing status.\n      * @dev - privileged internal function. MUST check params and logic flow before calling\n      * @dev - does not save new status if it is the same as current status\n      * @return status - the current status of the line after updating\n     */\n    function _updateStatus(LineLib.STATUS status_) internal returns(LineLib.STATUS) {\n      if(status == status_) return status_;\n      emit UpdateStatus(uint256(status_));\n      return (status = status_);\n    }\n\n    /**\n     * @notice - Generates position id and stores lender's position\n     * @dev - positions have unique composite-index on [lineAddress, lenderAddress, tokenAddress]\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @param lender - address that will own and manage position\n     * @param token - ERC20 token that is being lent and borrower\n     * @param amount - amount of tokens lender will initially deposit\n    */\n    function _createCredit(\n        address lender,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (bytes32 id)\n    {\n        id = CreditLib.computeId(address(this), lender, token);\n        // MUST not double add the credit line. otherwise we can not _close()\n        if(credits[id].lender != address(0)) { revert PositionExists(); }\n\n        credits[id] = CreditLib.create(id, amount, lender, token, address(oracle));\n\n        ids.push(id); // add lender to end of repayment queue\n        \n        unchecked { ++count; }\n\n        return id;\n    }\n\n  /**\n   * @dev - Reduces `principal` and/or `interestAccrued` on a credit line.\n            Expects checks for conditions of repaying and param sanitizing before calling\n            e.g. early repayment of principal, tokens have actually been paid by borrower, etc.\n   * @dev - privileged internal function. MUST check params and logic flow before calling\n   * @param id - position id with all data pertaining to line\n   * @param amount - amount of Credit Token being repai"
    }
  ]
}