{
  "Title": "[M-01] Borrower can by mistake add own money to credit if credit is in ETH",
  "Content": "# Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L223-L244\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74\n\n\n# Vulnerability details\n\n## Impact\nBorrower can by mistake add own money to credit if credit is in ETH.\n\n## Proof of Concept\nFunction `LineOfCredit.addCredit` is used to create new credit.\nIt can be called only after contest of another party.\n```solidity\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token,\n        address lender\n    )\n        external\n        payable\n        override\n        whileActive\n        mutualConsent(lender, borrower)\n        returns (bytes32)\n    {\n        LineLib.receiveTokenOrETH(token, lender, amount);\n\n\n        bytes32 id = _createCredit(lender, token, amount);\n\n\n        require(interestRate.setRate(id, drate, frate));\n        \n        return id;\n    }\n```\n`LineLib.receiveTokenOrETH(token, lender, amount)` is responsible for getting payment.\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74\n```solidity\n    function receiveTokenOrETH(\n      address token,\n      address sender,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        if(token != Denominations.ETH) { // ERC20\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n            if(msg.value < amount) { revert TransferFailed(); }\n        }\n        return true;\n    }\n```\nAs you can see in case of native token payment, `sender` is not checked to be `msg.sender`, so this makes it's possible that borrower can by mistake pay instead of lender. It sounds funny, but it's possible. What is needed is that lender call `addCredit` first and then borrower calls `addCredit` and provides value.\n\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nCheck that if payment in ETH then `lender == msg.sender` in `addCredit` function.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-debt-dao-contest",
  "Code": [
    {
      "filename": "code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol",
      "content": "pragma solidity ^0.8.9;\n\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LineLib} from \"../../utils/LineLib.sol\";\nimport {CreditLib} from \"../../utils/CreditLib.sol\";\nimport {CreditListLib} from \"../../utils/CreditListLib.sol\";\nimport {MutualConsent} from \"../../utils/MutualConsent.sol\";\nimport {InterestRateCredit} from \"../interest-rate/InterestRateCredit.sol\";\n\nimport {IOracle} from \"../../interfaces/IOracle.sol\";\nimport {ILineOfCredit} from \"../../interfaces/ILineOfCredit.sol\";\n\ncontract LineOfCredit is ILineOfCredit, MutualConsent {\n    using SafeERC20 for IERC20;\n\n    using CreditListLib for bytes32[];\n\n    uint256 public immutable deadline;\n\n    address public immutable borrower;\n\n    address public immutable arbiter;\n\n    IOracle public immutable oracle;\n\n    InterestRateCredit public immutable interestRate;\n\n    uint256 private count; // amount of open credit lines on a Line of Credit facility. ids.length includes null items\n\n    bytes32[] public ids; // all open credit lines\n\n    mapping(bytes32 => Credit) public credits; // id -> Reference ID for a credit line provided by a single Lender for a given token on a Line of Credit\n\n    // Line Financials aggregated accross all existing  Credit\n    LineLib.STATUS public status;\n\n    /**\n   * @notice            - How to deploy a Line of Credit\n   * @dev               - A Borrower and a first Lender agree on terms. Then the Borrower deploys the contract using the constructor below.\n   *                      Later, both Lender and Borrower must call _mutualConsent() during addCredit() to actually enable funds to be deposited.\n   * @param oracle_     - The price oracle to use for getting all token values.\n   * @param arbiter_    - A neutral party with some special priviliges on behalf of Borrower and Lender.\n   * @param borrower_   - The debitor for all credit lines in this contract.\n   * @param ttl_        - The time to live for all credit lines for the Line of Credit facility (sets the maturity/term of the Line of Credit)\n  */\n    constructor(\n        address oracle_,\n        address arbiter_,\n        address borrower_,\n        uint256 ttl_\n    ) {\n        oracle = IOracle(oracle_);\n        arbiter = arbiter_;\n        borrower = borrower_;\n        deadline = block.timestamp + ttl_;  //the deadline is the term/maturity/expiry date of the Line of Credit facility\n        interestRate = new InterestRateCredit();\n\n        emit DeployLine(oracle_, arbiter_, borrower_);\n    }\n\n    function init() external virtual returns(LineLib.STATUS) {\n      if(status != LineLib.STATUS.UNINITIALIZED) { revert AlreadyInitialized(); }\n      return _updateStatus(_init());\n    }\n\n    function _init() internal virtual returns(LineLib.STATUS) {\n       // If no collateral or Spigot then Line of Credit is immediately active\n      return LineLib.STATUS.ACTIVE;\n    }\n\n    ///////////////\n    // MODIFIERS //\n    ///////////////\n\n    modifier whileActive() {\n        if(status != LineLib.STATUS.ACTIVE) { revert NotActive(); }\n        _;\n    }\n\n    modifier whileBorrowing() {\n        if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n        _;\n    }\n\n    modifier onlyBorrower() {\n        if(msg.sender != borrower) { revert CallerAccessDenied(); }\n        _;\n    }\n\n    /**\n     * @notice - mutualConsent() but hardcodes borrower address and uses the position id to\n                 get Lender address instead of passing it in directly\n     * @param id - position to pull lender address from for mutual consent agreement\n    */\n    modifier mutualConsentById(bytes32 id) {\n      if(_mutualConsent(borrower, credits[id].lender))  {\n        // Run whatever code is needed for the 2/2 consent\n        _;\n      }\n    }\n\n    /**\n     * @notice - evaluates all covenants encoded in _healthcheck from different Line variants\n     * @dev - updates `status` variable in storage if current status is diferent from existing status\n     * @return - current health status of Line\n    */\n    function healthcheck() external returns (LineLib.STATUS) {\n        // can only check if the line has been initialized\n        require(uint(status) >= uint( LineLib.STATUS.ACTIVE));\n        return _updateStatus(_healthcheck());\n    }\n\n    /// see ILineOfCredit.counts\n    function counts() external view returns (uint256, uint256) {\n        return (count, ids.length);\n    }\n\n    function _healthcheck() internal virtual returns (LineLib.STATUS) {\n        // if line is in a final end state then do not run _healthcheck()\n        LineLib.STATUS s = status;\n        if (\n            s == LineLib.STATUS.REPAID ||               // end state - good\n            s == LineLib.STATUS.INSOLVENT               // end state - bad\n        ) {\n            return s;\n        }\n\n        // Liquidate if all credit lines aren't closed by deadline\n        if (block.timestamp >= deadline && count > 0) {\n            emit Default(ids[0]); // can query all defaulted positions offchain once event picked up\n            return LineLib.STATUS.LIQUIDATABLE;\n        }\n\n        // if nothing wrong, return to healthy ACTIVE state  \n        return LineLib.STATUS.ACTIVE;\n    }\n\n\n    /// see ILineOfCredit.declareInsolvent\n    function declareInsolvent() external whileBorrowing returns(bool) {\n        if(arbiter != msg.sender) { revert CallerAccessDenied(); }\n        if(LineLib.STATUS.LIQUIDATABLE != _updateStatus(_healthcheck())) {\n            revert NotLiquidatable();\n        }\n\n        if(_canDeclareInsolvent()) {\n            _updateStatus(LineLib.STATUS.INSOLVENT);\n            return true;\n        } else {\n          return false;\n        }\n    }\n\n    function _canDeclareInsolvent() internal virtual returns(bool) {\n        // logic updated in Spigoted and Escrowed lines\n        return true;\n    }\n\n    /// see ILineOfCredit.updateOutstandingDebt\n    function updateOutstandingDebt() external override returns (uint256, uint256) {\n        return _updateOutstandingDebt();\n    }\n\n    function _updateOutstandingDebt()\n        internal\n        returns (uint256 principal, uint256 interest)\n    {\n        // use full length not count because positions might not be packed in order\n        uint256 len = ids.length;\n        if (len == 0) return (0, 0);\n\n        bytes32 id;\n        address oracle_ = address(oracle);  // gas savings\n        address interestRate_ = address(interestRate); // gas savings\n        \n        for (uint256 i; i < len; ++i) {\n            id = ids[i];\n\n            // null element in array from closing a position. skip for gas savings\n            if(id == bytes32(0)) { continue; }\n\n            (Credit memory c, uint256 _p, uint256 _i) = CreditLib.getOutstandingDebt(\n              credits[id],\n              id,\n              oracle_,\n              interestRate_\n            );\n            // update total outstanding debt\n            principal += _p;\n            interest += _i;\n            // save changes to storage\n            credits[id] = c;\n        }\n    }\n\n    /// see ILineOfCredit.accrueInterest\n    function accrueInterest() external override returns(bool) {\n        uint256 len = ids.length;\n        bytes32 id;\n        for (uint256 i; i < len; ++i) {\n          id = ids[i];\n          Credit memory credit = credits[id];\n          credits[id] = _accrue(credit, id);\n        }\n        \n        return true;\n    }\n\n    /**\n      @notice - accrues token demoninated interest on a lender's position.\n      @dev MUST call any time a position balance or interest rate changes\n      @param credit - the lender position that is accruing interest\n      @param id - the position id for credit position\n    */\n    function _accrue(Credit memory credit, bytes32 id) internal returns(Credit memory) {\n      return CreditLib.accrue(credit, id, address(interestRate));\n    }\n\n    /// see ILineOfCredit.addCredit\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token,\n        address lender\n    )\n        external\n        payable\n        override\n        whileActive\n        mutualConsent(lender, borrower)\n        returns (bytes32)\n    {\n        LineLib.receiveTokenOrETH(token, lender, amount);\n\n        bytes32 id = _createCredit(lender, token, amount);\n\n        require(interestRate.setRate(id, drate, frate));\n        \n        return id;\n    }\n\n    /// see ILineOfCredit.setRates\n    function setRates(\n        bytes32 id,\n        uint128 drate,\n        uint128 frate\n    )\n      external\n      override\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credits[id] = _accrue(credit, id);\n        require(interestRate.setRate(id, drate, frate));\n        emit SetRates(id, drate, frate);\n        return true;\n    }\n\n    /// see ILineOfCredit.increaseCredit\n    function increaseCredit(bytes32 id, uint256 amount)\n      external\n      payable\n      override\n      whileActive\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        credit.deposit += amount;\n        \n        credits[id] = credit;\n\n        LineLib.receiveTokenOrETH(credit.token, credit.lender, amount);\n\n        emit IncreaseCredit(id, amount);\n\n        return true;\n    }\n\n    ///////////////\n    // REPAYMENT //\n    ///////////////\n\n    /// see ILineOfCredit.depositAndClose\n    function depositAndClose()\n        external\n        payable\n        override\n        whileBorrowing\n        onlyBorrower\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = _accrue(credits[id], id);\n\n        // Borrower deposits the outstanding balance not already repaid\n        uint256 totalOwed = credit.principal + credit.interestAccrued;\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, totalOwed);\n\n        // Borrower clears the debt then closes and deletes the credit line\n        _close(_repay(credit, id, totalOwed), id);\n\n        return true;\n    }\n\n\n    /// see ILineOfCredit.depositAndRepay\n    function depositAndRepay(uint256 amount)\n        external\n        payable\n        override\n        whileBorrowing\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        require(amount <= credit.principal + credit.interestAccrued);\n\n        credits[id] = _repay(credit, id, amount);\n\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, amount);\n\n        return true;\n    }\n\n    ////////////////////\n    // FUND TRANSFERS //\n    ////////////////////\n\n    /// see ILineOfCredit.borrow\n    function borrow(bytes32 id, uint256 amount)\n        external\n        override\n        whileActive\n        onlyBorrower\n        returns (bool)\n    {\n        Credit memory credit = _accrue(credits[id], id);\n\n        if(amount > credit.deposit - credit.principal) { revert NoLiquidity(); }\n\n        credit.principal += amount;\n\n        credits[id] = credit; // save new debt before healthcheck\n\n        // ensure that borrowing doesnt cause Line to be LIQUIDATABLE\n        if(_updateStatus(_healthcheck()) != LineLib.STATUS.ACTIVE) { \n            revert NotActive();\n        }\n\n        LineLib.sendOutTokenOrETH(credit.token, borrower, amount);\n\n        emit Borrow(id, amount);\n\n        _sortIntoQ(id);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.withdraw\n    function withdraw(bytes32 id, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        Credit memory credit = credits[id];\n\n        if(msg.sender != credit.lender) { revert CallerAccessDenied(); }\n\n        // accrues interest and transfers to Lender\n        credits[id] = CreditLib.withdraw(_accrue(credit, id), id, amount);\n\n        LineLib.sendOutTokenOrETH(credit.token, credit.lender, amount);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.close\n    function close(bytes32 id) external payable override returns (bool) {\n        Credit memory credit = credits[id];\n        address b = borrower; // gas savings\n        if(msg.sender != credit.lender && msg.sender != b) {\n          revert CallerAccessDenied();\n        }\n\n        // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off\n        credit = _accrue(credit, id);\n        uint256 facilityFee = credit.interestAccrued;\n        if(facilityFee > 0) {\n          // only allow repaying interest since they are skipping repayment queue.\n          // If principal still owed, _close() MUST fail\n          LineLib.receiveTokenOrETH(credit.token, b, facilityFee);\n\n          credit = _repay(credit, id, facilityFee);\n        }\n\n        _close(credit, id); // deleted; no need to save to storage\n\n        return true;\n    }\n\n    //////////////////////\n    //  Internal  funcs //\n    //////////////////////\n\n    /**\n      * @notice - updates `status` variable in storage if current status is diferent from existing status.\n      * @dev - privileged internal function. MUST check params and logic flow before calling\n      * @dev - does not save new status if it is the same as current status\n      * @return status - the current status of the line after updating\n     */\n    function _updateStatus(LineLib.STATUS status_) internal returns(LineLib.STATUS) {\n      if(status == status_) return status_;\n      emit UpdateStatus(uint256(status_));\n      return (status = status_);\n    }\n\n    /**\n     * @notice - Generates position id and stores lender's position\n     * @dev - positions have unique composite-index on [lineAddress, lenderAddress, tokenAddress]\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @param lender - address that will own and manage position\n     * @param token - ERC20 token that is being lent and borrower\n     * @param amount - amount of tokens lender will initially deposit\n    */\n    function _createCredit(\n        address lender,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (bytes32 id)\n    {\n        id = CreditLib.computeId(address(this), lender, token);\n        // MUST not double add the credit line. otherwise we can not _close()\n        if(credits[id].lender != address(0)) { revert PositionExists(); }\n\n        credits[id] = CreditLib.create(id, amount, lender, token, address(oracle));\n\n        ids.push(id); // add lender to end of repayment queue\n        \n        unchecked { ++count; }\n\n        return id;\n    }\n\n  /**\n   * @dev - Reduces `principal` and/or `interestAccrued` on a credit line.\n            Expects checks for conditions of repaying and param sanitizing before calling\n            e.g. early repayment of principal, tokens have actually been paid by borrower, etc.\n   * @dev - privileged internal function. MUST check params and logic flow before calling\n   * @param id - position id with all data pertaining to line\n   * @param amount - amount of Credit Token being repaid on credit line\n   * @return credit - position struct in memory with updated values\n  */\n    function _repay(Credit memory credit, bytes32 id, uint256 amount)\n        internal\n        returns (Credit memory)\n    { \n        credit = CreditLib.repay(credit, id, amount);\n\n        // if credit line fully repaid then remove it from the repayment queue\n        if (credit.principal == 0) ids.stepQ();\n\n        return credit;\n    }\n\n    /**\n     * @notice - checks that a credit line is fully repaid and removes it\n     * @dev deletes credit storage. Store any data u might need later in call before _close()\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @return credit - position struct in memory with updated values\n     */\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n        // return the Lender's funds that are being repaid\n        if (credit.deposit + credit.interestRepaid > 0) {\n            LineLib.sendOutTokenOrETH(\n                credit.token,\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n\n        delete credits[id]; // gas refunds\n\n        // remove from active list\n        ids.removePosition(id);\n        unchecked { --count; }\n\n        // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n        if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n        emit CloseCreditPosition(id);\n\n        return true;\n    }\n\n    /**\n     * @notice - Insert `p` into the next availble FIFO position in the repayment queue\n               - once earliest slot is found, swap places with `p` and position in slot.\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @param p - position id that we are trying to find appropriate place for\n     * @return - if function executed successfully\n     */\n    function _sortIntoQ(bytes32 p) internal returns (bool) {\n        uint256 lastSpot = ids.length - 1;\n        uint256 nextQSpot = lastSpot;\n        bytes32 id;\n        for (uint256 i; i <= lastSpot; ++i) {\n            id = ids[i];\n            if (p != id) {\n                if (\n                  id == bytes32(0) ||       // deleted element. In the middle of the q because it was closed.\n                  nextQSpot != lastSpot ||  // position already found. skip to find `p` asap\n                  credits[id].principal > 0 //`id` should be placed before `p` \n                ) continue;\n                nextQSpot = i;              // index of first undrawn line found\n            } else {\n                if(nextQSpot == lastSpot) return true; // nothing to update\n                // swap positions\n                ids[i] = ids[nextQSpot];    // id put into old `p` position\n                ids[nextQSpot] = p;         // p put at target index\n                return true; \n            }\n          \n        }\n    }\n}"
    },
    {
      "filename": "code4rena-2022-11-03/contracts/utils/LineLib.sol",
      "content": "pragma solidity 0.8.9;\nimport { IInterestRateCredit } from \"../interfaces/IInterestRateCredit.sol\";\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { Denominations } from \"chainlink/Denominations.sol\";\n\n/**\n  * @title Debt DAO Line of Credit Library\n  * @author Kiba Gateaux\n  * @notice Core logic and variables to be reused across all Debt DAO Marketplace Line of Credit contracts\n */\nlibrary LineLib {\n    using SafeERC20 for IERC20;\n\n    error TransferFailed();\n    error BadToken();\n\n    enum STATUS {\n        UNINITIALIZED,\n        ACTIVE,\n        LIQUIDATABLE,\n        REPAID,\n        INSOLVENT\n    }\n\n    /**\n     * @notice - Send ETH or ERC20 token from this contract to an external contract\n     * @param token - address of token to send out. Denominations.ETH for raw ETH\n     * @param receiver - address to send tokens to\n     * @param amount - amount of tokens to send\n     */\n    function sendOutTokenOrETH(\n      address token,\n      address receiver,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        \n        // both branches revert if call failed\n        if(token!= Denominations.ETH) { // ERC20\n            IERC20(token).safeTransfer(receiver, amount);\n        } else { // ETH\n            payable(receiver).transfer(amount);\n        }\n        return true;\n    }\n\n    /**\n     * @notice - Receive ETH or ERC20 token at this contract from an external contract\n     * @param token - address of token to receive. Denominations.ETH for raw ETH\n     * @param sender - address that is sendingtokens/ETH\n     * @param amount - amount of tokens to send\n     */\n    function receiveTokenOrETH(\n      address token,\n      address sender,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        if(token != Denominations.ETH) { // ERC20\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n            if(msg.value < amount) { revert TransferFailed(); }\n        }\n        return true;\n    }\n\n    /**\n     * @notice - Helper function to get current balance of this contract for ERC20 or ETH\n     * @param token - address of token to check. Denominations.ETH for raw ETH\n    */\n    function getBalance(address token) external view returns (uint256) {\n        if(token == address(0)) return 0;\n        return token != Denominations.ETH ?\n            IERC20(token).balanceOf(address(this)) :\n            address(this).balance;\n    }\n\n}"
    }
  ]
}