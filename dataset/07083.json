{
  "Title": "[N-04]  Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)",
  "Content": "\nWhile the compiler knows to optimize away the exponentiation, it's still better coding practice to use idioms that do not require compiler optimization, if they exist\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/vault/adapter/yearn/YearnAdapter.sol\n\n25:       uint256 constant DEGRADATION_COEFFICIENT = 10**18;\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/yearn/YearnAdapter.sol#L25\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/vault/adapter/yearn/YearnAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {AdapterBase, ERC4626Upgradeable as ERC4626, IERC20, IERC20Metadata, ERC20, SafeERC20, Math, IStrategy, IAdapter} from \"../abstracts/AdapterBase.sol\";\nimport {VaultAPI, IYearnRegistry} from \"./IYearn.sol\";\n\n/**\n * @title   Yearn Adapter\n * @author  RedVeil\n * @notice  ERC4626 wrapper for Yearn Vaults.\n *\n * An ERC4626 compliant Wrapper for https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy.\n * Allows wrapping Yearn Vaults.\n */\ncontract YearnAdapter is AdapterBase {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    string internal _name;\n    string internal _symbol;\n\n    VaultAPI public yVault;\n    uint256 constant DEGRADATION_COEFFICIENT = 10**18;\n\n    /**\n     * @notice Initialize a new Yearn Adapter.\n     * @param adapterInitData Encoded data for the base adapter initialization.\n     * @param externalRegistry Yearn registry address.\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev The yearn registry will be used given the `asset` from `adapterInitData` to find the latest yVault.\n     */\n    function initialize(\n        bytes memory adapterInitData,\n        address externalRegistry,\n        bytes memory\n    ) external initializer {\n        (address _asset, , , , , ) = abi.decode(\n            adapterInitData,\n            (address, address, address, uint256, bytes4[8], bytes)\n        );\n        __AdapterBase_init(adapterInitData);\n\n        yVault = VaultAPI(IYearnRegistry(externalRegistry).latestVault(_asset));\n\n        _name = string.concat(\n            \"Popcorn Yearn\",\n            IERC20Metadata(asset()).name(),\n            \" Adapter\"\n        );\n        _symbol = string.concat(\"popY-\", IERC20Metadata(asset()).symbol());\n\n        IERC20(_asset).approve(address(yVault), type(uint256).max);\n    }\n\n    function name()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ACCOUNTING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emulate yearns total asset calculation to return the total assets of the vault.\n    function _totalAssets() internal view override returns (uint256) {\n        return _shareValue(underlyingBalance);\n    }\n\n    function _underlyingBalance() internal view override returns (uint256) {\n        return yVault.balanceOf(address(this));\n    }\n\n    /// @notice Determines the current value of `yShares` in assets\n    function _shareValue(uint256 yShares) internal view returns (uint256) {\n        if (yVault.totalSupply() == 0) return yShares;\n\n        return\n            yShares.mulDiv(\n                _freeFunds(),\n                yVault.totalSupply(),\n                Math.Rounding.Down\n            );\n    }\n\n    /// @notice The amount of assets that are free to be withdrawn from the yVault after locked profts.\n    function _freeFunds() internal view returns (uint256) {\n        return _yTotalAssets() - _calculateLockedProfit();\n    }\n\n    /**\n     * @notice Returns the total quantity of all assets under control of this Vault,\n     * whether they're loaned out to a Strategy, or currently held in the Vault.\n     */\n    function _yTotalAssets() internal view returns (uint256) {\n        return IERC20(asset()).balanceOf(address(yVault)) + yVault.totalDebt();\n    }\n\n    /// @notice Calculates how much profit is locked and cant be withdrawn.\n    function _calculateLockedProfit() internal view returns (uint256) {\n        uint256 lockedFundsRatio = (block.timestamp - yVault.lastReport()) *\n            yVault.lockedProfitDegradation();\n\n        if (lockedFundsRatio < DEGRADATION_COEFFICIENT) {\n            uint256 lockedProfit = yVault.lockedProfit();\n            return\n                lockedProfit -\n                ((lockedFundsRatio * lockedProfit) / DEGRADATION_COEFFICIENT);\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice The amount of yearn shares to withdraw given an amount of adapter shares\n    function convertToUnderlyingShares(uint256, uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            shares.mulDiv(underlyingBalance, totalSupply(), Math.Rounding.Up);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    DEPOSIT/WITHDRAWAL LIMIT LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Applies the yVault deposit limit to the adapter.\n    function maxDeposit(address) public view override returns (uint256) {\n        if (paused()) return 0;\n\n        VaultAPI _bestVault = yVault;\n        uint256 assets = _bestVault.totalAssets();\n        uint256 _depositLimit = _bestVault.depositLimit();\n        if (assets >= _depositLimit) return 0;\n        return _depositLimit - assets;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _protocolDeposit(uint256 amount, uint256)\n        internal\n        virtual\n        override\n    {\n        yVault.deposit(amount);\n    }\n\n    function _protocolWithdraw(uint256 assets, uint256 shares)\n        internal\n        virtual\n        override\n    {\n        yVault.withdraw(convertToUnderlyingShares(assets, shares));\n    }\n}"
    }
  ]
}