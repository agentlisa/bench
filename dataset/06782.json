{
  "Title": "[M-02] `MaxContribution` check can be bypassed to give a card high voting power",
  "Content": "\nReraiseETHCrowdfund tries limit the voting power of each card by doing a min/maxContribution check in claim and claimMultiple.\n\n                uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n                uint96 maxContribution_ = maxContribution;\n                // Check that the contribution equivalent of total pending voting\n                // power is not above the max contribution range. This can happen\n                // for contributors who contributed multiple times In this case, the\n                // `claimMultiple` function should be called instead. This is done\n                // so parties may use the minimum and maximum contribution values to\n                // limit the voting power of each card (e.g.  a party desiring a \"1\n                // card = 1 vote\"-like governance system where each card has equal\n                // voting power).\n                if (contribution > maxContribution_) {\n                    revert AboveMaximumContributionsError(contribution, maxContribution_);\n                }\n\n<https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol#L270-L282>\n\n                // Check that the contribution equivalent of voting power is within\n                // contribution range. This is done so parties may use the minimum\n                // and maximum contribution values to limit the voting power of each\n                // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n                // system where each card has equal voting power).\n                uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n                if (contribution < minContribution_) {\n                    revert BelowMinimumContributionsError(contribution, minContribution_);\n                }\n\n                if (contribution > maxContribution_) {\n                    revert AboveMaximumContributionsError(contribution, maxContribution_);\n                }\n\n<https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol#L357-L369>\n\nHowever, this check can be bypassed due to the following code segment\n\n            else if (party.ownerOf(tokenId) == contributor) {\n                // Increase voting power of contributor's existing party card.\n                party.addVotingPower(tokenId, votingPower);\n            } \n\n<https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol#L295-L298>\n\nConsider the following situation. Suppose ReraiseETHCrowdfund sets maximumContribution to only allow at most 3 units of voting power in each card. Some user X can contribute the maximum amount twice as 2 different contributor addresses A & B (both of which he controls). When the crowdfund has finalized, X can first call claim as A, then transfer the partyGovernanceNFT from A to B (note that while the crowdfundNFT can't be transferred, the partyGovernanceNFT can be transferred), and finally call claim as B to get a card with 6 units of voting power.\n\n### Impact\n\nThe degree of impact really depends on the use case of the party. Some parties would like each card to represent a single vote - this would obviously violate that. Generally, it's not a great idea to allow a single card to hold a high amount of votes, so I'll leave this as a medium for now.\n\n### Recommended Mitigation Steps\n\nOne solution is to restrict the maximum voting power on partyGovernanceNFT's side. It can check the votingPower of each card before [adding more votingPower](https://github.com/code-423n4/2023-04-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L169) to it.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/39#issuecomment-1512169729):**\n > @evan - Couldn't this also be mitigated by checking the voting power held by a card before adding voting power to it?\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/39#issuecomment-1515508786):**\n > Considering a refactor to only check `contribution > maxContribution` in `claim()` if `disableContributingForExistingCard` is true, which would mitigate this.\n> \n> The reasoning is the check was added for the case to support parties that wish to have a \"1 card, 1 vote\"-type governance system and must have fixed voting power per card. To do this we would expect `disableContributingForExistingCard` to be enabled. If it is not, the creator would be indicating it doesn't matter.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/39#issuecomment-1532059790):**\n > We've decided to refactor the way claiming works in the `ReraiseETHCrowdfund`, partially because a large number of findings like this being submitted around that one area that highlighted for us the need to rework its logic.\n> \n> The change will make it so (1) crowdfund NFTs are minted per contribution instead of per address and (2) claiming works more like a 1:1 conversion of your crowdfund NFT into a party card instead of how it works now. In the future we will also add the ability to split/merge party cards.\n> \n> This should mitigate this finding because the voting power transferred from crowdfund NFT to party card is known to be within the min/max contribution limit (otherwise the contribution that created the crowdfund NFT would have reverted) so there is no longer a min/max contribution check required when claiming.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/crowdfund/ReraiseETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./ETHCrowdfundBase.sol\";\nimport \"../crowdfund/CrowdfundNFT.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\n/// @notice A crowdfund for raising additional funds for an existing parties.\ncontract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    struct BatchContributeArgs {\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n        // Whether to revert if any individual contribution fails or continue.\n        bool revertOnFailure;\n    }\n\n    event Claimed(address indexed contributor, uint256 indexed tokenId, uint256 votingPower);\n    event Refunded(address indexed contributor, uint256 amount);\n\n    error RemainingVotingPowerAfterClaimError(uint256 remainingVotingPower);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The amount of voting power that will be received by a\n    ///         contributor after the crowdfund is won.\n    mapping(address => uint96) public pendingVotingPower;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts The options to initialize the crowdfund with.\n    function initialize(ETHCrowdfundOptions memory opts) external payable onlyConstructor {\n        // Initialize the crowdfund.\n        ETHCrowdfundBase._initialize(opts);\n\n        // Initialize the crowdfund NFT.\n        _initialize(\n            opts.party.name(),\n            opts.party.symbol(),\n            0 // Ignored. Will use customization preset from party.\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, \"\");\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    // Initialize name and symbol for crowdfund NFT.\n    function _initialize(string memory name_, string memory symbol_, uint256) internal override {\n        name = name_;\n        symbol = symbol_;\n\n        RendererStorage rendererStorage = RendererStorage(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\n        );\n\n        // Use the same customization preset as the party.\n        uint256 customizationPresetId = rendererStorage.getPresetFor(address(party));\n        if (customizationPresetId != 0) {\n            rendererStorage.useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.values.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(recipient, initialDelegate, msg.value.safeCastUint256ToUint96(), gateData);\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs memory args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.recipients.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n                abi.encodeCall(\n                    this.contributeFor,\n                    (args.recipients[i], args.initialDelegates[i], args.gateDatas[i])\n                )\n            );\n\n            if (!s) {\n                if (args.revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                votingPowers[i] = abi.decode(r, (uint96));\n            }\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    _gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        uint256 previousVotingPower = pendingVotingPower[contributor];\n\n        pendingVotingPower[contributor] += votingPower;\n\n        // Mint a crowdfund NFT if this is their first contribution.\n        if (previousVotingPower == 0) _mint(contributor);\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param contributor The contributor to claim for.\n    function claim(address contributor) external {\n        claim(\n            0, // Mint a new party card.\n            contributor\n        );\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param tokenId The ID of the party card to add voting power to. If 0, a\n    ///                new card will be minted.\n    /// @param contributor The contributor to claim for.\n    function claim(uint256 tokenId, address contributor) public {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint96 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        {\n            uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n            uint96 maxContribution_ = maxContribution;\n            // Check that the contribution equivalent of total pending voting\n            // power is not above the max contribution range. This can happen\n            // for contributors who contributed multiple times In this case, the\n            // `claimMultiple` function should be called instead. This is done\n            // so parties may use the minimum and maximum contribution values to\n            // limit the voting power of each card (e.g.  a party desiring a \"1\n            // card = 1 vote\"-like governance system where each card has equal\n            // voting power).\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n        }\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.addVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError();\n        }\n\n        emit Claimed(contributor, tokenId, votingPower);\n    }\n\n    /// @notice `claim()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0, a\n    ///                 new card will be minted.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaim(\n        uint256[] calldata tokenIds,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                // Using `abi.encodeWithSignature()` instead of `abi.encodeCall()`\n                // because `abi.encodeCall()` doesn't support overloaded functions.\n                abi.encodeWithSignature(\"claim(uint256,address)\", tokenIds[i], contributors[i])\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Claim multiple party cards for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param votingPowerByCard The voting power for each card claimed. Must add up to the\n    ///                          total pending voting power for the contributor.\n    /// @param contributor The contributor to claim for.\n    function claimMultiple(uint96[] memory votingPowerByCard, address contributor) external {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint256 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        address delegate = delegationsByContributor[contributor];\n        uint96 minContribution_ = minContribution;\n        uint96 maxContribution_ = maxContribution;\n        for (uint256 i; i < votingPowerByCard.length; ++i) {\n            if (votingPowerByCard[i] == 0) continue;\n\n            // Check that the contribution equivalent of voting power is within\n            // contribution range. This is done so parties may use the minimum\n            // and maximum contribution values to limit the voting power of each\n            // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n            // system where each card has equal voting power).\n            uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n            if (contribution < minContribution_) {\n                revert BelowMinimumContributionsError(contribution, minContribution_);\n            }\n\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n\n            votingPower -= votingPowerByCard[i];\n\n            // Mint contributor a new party card.\n            uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate);\n\n            emit Claimed(contributor, tokenId, votingPowerByCard[i]);\n        }\n\n        // Requires that all voting power is claimed because the contributor is\n        // expected to have burned their crowdfund NFT.\n        if (votingPower != 0) revert RemainingVotingPowerAfterClaimError(votingPower);\n    }\n\n    /// @notice `claimMultiple()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param votingPowerByCards The voting power for each card claimed for each\n    ///                           contributor. Must add up to the total pending\n    ///                           voting power for the contributor.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaimMultiple(\n        uint96[][] calldata votingPowerByCards,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.claimMultiple, (votingPowerByCards[i], contributors[i]))\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Refund the owner of a party card and burn it. Only available if\n    ///         the crowdfund lost. Can be called to refund for self or on\n    ///         another's behalf.\n    /// @param contributor The contributor to refund.\n    function refund(address payable contributor) external returns (uint96 amount) {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Lost) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Get amount to refund.\n        uint96 votingPower = pendingVotingPower[contributor];\n        amount = _calculateRefundAmount(votingPower);\n\n        if (amount == 0) return 0;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        // Refund contributor.\n        contributor.transferEth(amount);\n\n        emit Refunded(contributor, amount);\n    }\n\n    /// @notice `refund()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param contributors The contributors to refund.\n    /// @param revertOnFailure If true, revert if any refund fails.\n    /// @return amounts The amounts of ETH refunded for each refund.\n    function batchRefund(\n        address payable[] calldata contributors,\n        bool revertOnFailure\n    ) external returns (uint96[] memory amounts) {\n        uint256 numRefunds = contributors.length;\n        amounts = new uint96[](numRefunds);\n\n        for (uint256 i; i < numRefunds; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.refund, (contributors[i]))\n            );\n\n            if (!s) {\n                if (revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                amounts[i] = abi.decode(r, (uint96));\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/crowdfund/ReraiseETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./ETHCrowdfundBase.sol\";\nimport \"../crowdfund/CrowdfundNFT.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\n/// @notice A crowdfund for raising additional funds for an existing parties.\ncontract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    struct BatchContributeArgs {\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n        // Whether to revert if any individual contribution fails or continue.\n        bool revertOnFailure;\n    }\n\n    event Claimed(address indexed contributor, uint256 indexed tokenId, uint256 votingPower);\n    event Refunded(address indexed contributor, uint256 amount);\n\n    error RemainingVotingPowerAfterClaimError(uint256 remainingVotingPower);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The amount of voting power that will be received by a\n    ///         contributor after the crowdfund is won.\n    mapping(address => uint96) public pendingVotingPower;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts The options to initialize the crowdfund with.\n    function initialize(ETHCrowdfundOptions memory opts) external payable onlyConstructor {\n        // Initialize the crowdfund.\n        ETHCrowdfundBase._initialize(opts);\n\n        // Initialize the crowdfund NFT.\n        _initialize(\n            opts.party.name(),\n            opts.party.symbol(),\n            0 // Ignored. Will use customization preset from party.\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, \"\");\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    // Initialize name and symbol for crowdfund NFT.\n    function _initialize(string memory name_, string memory symbol_, uint256) internal override {\n        name = name_;\n        symbol = symbol_;\n\n        RendererStorage rendererStorage = RendererStorage(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\n        );\n\n        // Use the same customization preset as the party.\n        uint256 customizationPresetId = rendererStorage.getPresetFor(address(party));\n        if (customizationPresetId != 0) {\n            rendererStorage.useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.values.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(recipient, initialDelegate, msg.value.safeCastUint256ToUint96(), gateData);\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs memory args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.recipients.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n                abi.encodeCall(\n                    this.contributeFor,\n                    (args.recipients[i], args.initialDelegates[i], args.gateDatas[i])\n                )\n            );\n\n            if (!s) {\n                if (args.revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                votingPowers[i] = abi.decode(r, (uint96));\n            }\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    _gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        uint256 previousVotingPower = pendingVotingPower[contributor];\n\n        pendingVotingPower[contributor] += votingPower;\n\n        // Mint a crowdfund NFT if this is their first contribution.\n        if (previousVotingPower == 0) _mint(contributor);\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param contributor The contributor to claim for.\n    function claim(address contributor) external {\n        claim(\n            0, // Mint a new party card.\n            contributor\n        );\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param tokenId The ID of the party card to add voting power to. If 0, a\n    ///                new card will be minted.\n    /// @param contributor The contributor to claim for.\n    function claim(uint256 tokenId, address contributor) public {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint96 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        {\n            uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n            uint96 maxContribution_ = maxContribution;\n            // Check that the contribution equivalent of total pending voting\n            // power is not above the max contribution range. This can happen\n            // for contributors who contributed multiple times In this case, the\n            // `claimMultiple` function should be called instead. This is done\n            // so parties may use the minimum and maximum contribution values to\n            // limit the voting power of each card (e.g.  a party desiring a \"1\n            // card = 1 vote\"-like governance system where each card has equal\n            // voting power).\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n        }\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.addVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError();\n        }\n\n        emit Claimed(contributor, tokenId, votingPower);\n    }\n\n    /// @notice `claim()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0, a\n    ///                 new card will be minted.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaim(\n        uint256[] calldata tokenIds,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                // Using `abi.encodeWithSignature()` instead of `abi.encodeCall()`\n                // because `abi.encodeCall()` doesn't support overloaded functions.\n                abi.encodeWithSignature(\"claim(uint256,address)\", tokenIds[i], contributors[i])\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Claim multiple party cards for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param votingPowerByCard The voting power for each card claimed. Must add up to the\n    ///                          total pending voting power for the contributor.\n    /// @param contributor The contributor to claim for.\n    function claimMultiple(uint96[] memory votingPowerByCard, address contributor) external {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint256 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);"
    }
  ]
}