{
  "Title": "[M-03] Loss of Veto Power can Lead to 51% Attack",
  "Content": "_Submitted by TomJ, also found by 0xDjango, 0xSmartContract, Aymen0909, Ch&#95;301, and Deivitto_\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L156>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L150>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L839-L845>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L637-L643>\n\n### Impact\n\nThe veto power is import functionality for current NounsDAO in order to protect their treasury from malicious proposals.\nHowever there is lack of zero address check and lack of 2 step address changing process for vetoer address.\nThis might lead to Nounders losing their veto power unintentionally and open to 51% attack which can drain their entire treasury.\n\nRefrence from Nouns DAO contest documents:\n<https://dialectic.ch/editorial/nouns-governance-attack>\n<https://dialectic.ch/editorial/nouns-governance-attack-2>\n\n### Proof of Concept\n\nLack of 0-address check for vetoer address at `initialize()` and `\\_setVetoer()` of NounsDAOLogicV2.sol and NounsDAOLogicV1.sol.\nAlso it is better to make changing address process of vetoer at `\\_setVetoer()` into 2-step process to avoid accidently setting\nvetoer to zero address or any other arbitrary addresses and end up burning/losing veto power unintentionally.\n\n1.  Vetoer address of `initialize()` of NounsDAOLogicV2.sol, NounsDAOLogicV1.sol\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L156>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L150>\n\n2.  Vetoer address of `\\_setVetoer()` of NounsDAOLogicV2.sol, NounsDAOLogicV1.sol\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L839-L845>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L637-L643>\n\n### Recommended Mitigation Steps\n\nAdd zero address check for vetoer address at `initialize()`.\nAlso change `\\_setVetoer()` vetoer address changing process to 2-step process like explained below.\n\nFirst make the `\\_setVetoer()` function approve a new vetoer address as a pending vetoer.\nNext that pending vetoer has to claim the ownership in a separate transaction to be a new vetoer.\n\n**[eladmallel (Nouns DAO) confirmed and commented](https://github.com/code-423n4/2022-08-nounsdao-findings/issues/315#issuecomment-1232091787):**\n > We agree it's worth being extra safe here, planning to change it to a 2-step process.\n\n\n\n***\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-08-nounsdao",
  "Code": [
    {
      "filename": "contracts/governance/NounsDAOLogicV2.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO logic version 2\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsDAOLogicV2.sol is a modified version of Compound Lab's GovernorBravoDelegate.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoDelegate.sol\n//\n// GovernorBravoDelegate.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// See NounsDAOLogicV1 for initial GovernorBravoDelegate modifications.\n\n// NounsDAOLogicV2 adds:\n// - `quorumParamsCheckpoints`, which store dynamic quorum parameters checkpoints\n// to be used when calculating the dynamic quorum.\n// - `_setDynamicQuorumParams(DynamicQuorumParams memory params)`, which allows the\n// DAO to update the dynamic quorum parameters' values.\n// - `getDynamicQuorumParamsAt(uint256 blockNumber_)`\n// - Individual setters of the DynamicQuorumParams members:\n//    - `_setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS)`\n//    - `_setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS)`\n//    - `_setQuorumCoefficient(uint32 newQuorumCoefficient)`\n// - `minQuorumVotes` and `maxQuorumVotes`, which returns the current min and\n// max quorum votes using the current Noun supply.\n// - New `Proposal` struct member:\n//    - `totalSupply` used in dynamic quorum calculation.\n//    - `creationBlock` used for retrieving checkpoints of votes and dynamic quorum params. This now\n// allows changing `votingDelay` without affecting the checkpoints lookup.\n// - `quorumVotes(uint256 proposalId)`, which calculates and returns the dynamic\n// quorum for a specific proposal.\n// - `proposals(uint256 proposalId)` instead of the implicit getter, to avoid stack-too-deep error\n//\n// NounsDAOLogicV2 removes:\n// - `quorumVotes()` has been replaced by `quorumVotes(uint256 proposalId)`.\n\npragma solidity ^0.8.6;\n\nimport './NounsDAOInterfaces.sol';\n\ncontract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n    /// @notice The name of this contract\n    string public constant name = 'Nouns DAO';\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 5_760; // About 24 hours\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 80_640; // About 2 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 1;\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 40_320; // About 1 week\n\n    /// @notice The lower bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_LOWER_BOUND = 200; // 200 basis points or 2%\n\n    /// @notice The upper bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_UPPER_BOUND = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The upper bound of maximum quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS_UPPER_BOUND = 6_000; // 4,000 basis points or 60%\n\n    /// @notice The maximum setable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The maximum priority fee used to cap gas refunds in `castRefundableVote`\n    uint256 public constant MAX_REFUND_PRIORITY_FEE = 2 gwei;\n\n    /// @notice The vote refund gas overhead, including 7K for ETH transfer and 29K for general transaction overhead\n    uint256 public constant REFUND_BASE_GAS = 36000;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n    /// @dev Introduced these errors to reduce contract size, to avoid deployment failure\n    error AdminOnly();\n    error InvalidMinQuorumVotesBPS();\n    error InvalidMaxQuorumVotesBPS();\n    error MinQuorumBPSGreaterThanMaxQuorumBPS();\n    error UnsafeUint16Cast();\n\n    /**\n     * @notice Used to initialize the contract during delegator contructor\n     * @param timelock_ The address of the NounsDAOExecutor\n     * @param nouns_ The address of the NOUN tokens\n     * @param vetoer_ The address allowed to unilaterally veto proposals\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThresholdBPS_ The initial proposal threshold in basis points\n     * @param dynamicQuorumParams_ The initial dynamic quorum parameters\n     */\n    function initialize(\n        address timelock_,\n        address nouns_,\n        address vetoer_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThresholdBPS_,\n        DynamicQuorumParams calldata dynamicQuorumParams_\n    ) public virtual {\n        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n        require(msg.sender == admin, 'NounsDAO::initialize: admin only');\n        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n        require(\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n            'NounsDAO::initialize: invalid voting period'\n        );\n        require(\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n            'NounsDAO::initialize: invalid voting delay'\n        );\n        require(\n            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::initialize: invalid proposal threshold bps'\n        );\n\n        emit VotingPeriodSet(votingPeriod, votingPeriod_);\n        emit VotingDelaySet(votingDelay, votingDelay_);\n        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);\n\n        timelock = INounsDAOExecutor(timelock_);\n        nouns = NounsTokenLike(nouns_);\n        vetoer = vetoer_;\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThresholdBPS = proposalThresholdBPS_;\n        _setDynamicQuorumParams(\n            dynamicQuorumParams_.minQuorumVotesBPS,\n            dynamicQuorumParams_.maxQuorumVotesBPS,\n            dynamicQuorumParams_.quorumCoefficient\n        );\n    }\n\n    struct ProposalTemp {\n        uint256 totalSupply;\n        uint256 proposalThreshold;\n        uint256 latestProposalId;\n        uint256 startBlock;\n        uint256 endBlock;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        ProposalTemp memory temp;\n\n        temp.totalSupply = nouns.totalSupply();\n\n        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n        require(\n            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n            'NounsDAO::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'NounsDAO::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n\n        temp.latestProposalId = latestProposalIds[msg.sender];\n        if (temp.latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(temp.latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'NounsDAO::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        temp.startBlock = block.number + votingDelay;\n        temp.endBlock = temp.startBlock + votingPeriod;\n\n        proposalCount++;\n        Proposal storage newProposal = _proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.proposalThreshold = temp.proposalThreshold;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = temp.startBlock;\n        newProposal.endBlock = temp.endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n        newProposal.vetoed = false;\n        newProposal.totalSupply = temp.totalSupply;\n        newProposal.creationBlock = block.number;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        /// @notice Maintains backwards compatibility with GovernorBravo events\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            description\n        );\n\n        /// @notice Updated event with `proposalThreshold` and `minQuorumVotes`\n        /// @notice `minQuorumVotes` is always zero since V2 introduces dynamic quorum with checkpoints\n        emit ProposalCreatedWithRequirements(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            newProposal.proposalThreshold,\n            minQuorumVotes(),\n            description\n        );\n\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            'NounsDAO::execute: proposal can only be executed if it is queued'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::cancel: cannot cancel executed proposal');\n\n        Proposal storage proposal = _proposals[proposalId];\n        require(\n            msg.sender == proposal.proposer ||\n                nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the vetoer and the proposal has not been executed.\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        require(vetoer != address(0), 'NounsDAO::veto: veto power burned');\n        require(msg.sender == vetoer, 'NounsDAO::veto: only vetoer');\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::veto: cannot veto executed proposal');\n\n        Proposal storage proposal = _proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets\n     * @return values\n     * @return signatures\n     * @return calldatas\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = _proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return _proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId, 'NounsDAO::state: invalid proposal id');\n        Proposal storage proposal = _proposals[proposalId];\n        if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes(proposal.id)) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Returns the proposal details given a proposal id.\n     *     The `quorumVotes` member holds the *current* quorum, given the current votes.\n     * @param proposalId the proposal id to get the data for\n     * @return A `ProposalCondensed` struct with the proposal data\n     */\n    function proposals(uint256 proposalId) external view returns (ProposalCondensed memory) {\n        Proposal storage proposal = _proposals[proposalId];\n        return\n            ProposalCondensed({\n                id: proposal.id,\n                proposer: proposal.proposer,\n                proposalThreshold: proposal.proposalThreshold,\n                quorumVotes: quorumVotes(proposal.id),\n                eta: proposal.eta,\n                startBlock: proposal.startBlock,\n                endBlock: proposal.endBlock,\n                forVotes: proposal.forVotes,\n                againstVotes: proposal.againstVotes,\n                abstainVotes: proposal.abstainVotes,\n                canceled: proposal.canceled,\n                vetoed: proposal.vetoed,\n                executed: proposal.executed,\n                totalSupply: proposal.totalSupply,\n                creationBlock: proposal.creationBlock\n            });\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal, asking the DAO to refund gas costs.\n     * Users with > 0 votes receive refunds. Refunds are partial when using a gas priority fee higher than the DAO's cap.\n     * Refunds are partial when the DAO's balance is insufficient.\n     * No refund is sent when the DAO's balance is empty. No refund is sent to users with no votes.\n     * Voting takes place regardless of refund success.\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVote(uint256 proposalId, uint8 support) external {\n        castRefundableVoteInternal(proposalId, support, '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal, asking the DAO to refund gas costs.\n     * Users with > 0 votes receive refunds. Refunds are partial when using a gas priority fee higher than the DAO's cap.\n     * Refunds are partial when the DAO's balance is insufficient.\n     * No refund is sent when the DAO's balance is empty. No refund is sent to users with no votes.\n     * Voting takes place regardless of refund success.\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        castRefundableVoteInternal(proposalId, support, reason);\n    }\n\n    /**\n     * @notice Internal function that carries out refundable voting logic\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVoteInternal(\n        uint256 proposalId,\n        uint8 support,\n        string memory reason\n    ) internal {\n        uint256 startGas = gasleft();\n        uint96 votes = castVoteInternal(msg.sender, proposalId, support);\n        emit VoteCast(msg.sender, proposalId, support, votes, reason);\n        if (votes > 0) {\n            _refundGas(startGas);\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'NounsDAO::castVoteBySig: invalid signature');\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), '');\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address voter,\n        uint256 proposalId,\n        uint8 support\n    ) internal returns (uint96) {\n        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n        Proposal storage proposal = _proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, 'NounsDAO::castVoteInternal: voter already voted');\n\n        /// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created in order to normalize quorumVotes and proposalThreshold metrics\n        uint96 votes = nouns.getPriorVotes(voter, proposalCreationBlock(proposal));\n\n        if (support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n        require(\n            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n            'NounsDAO::_setVotingDelay: invalid voting delay'\n        );\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingPeriod: admin only');\n        require(\n            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n            'NounsDAO::_setVotingPeriod: invalid voting period'\n        );\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold basis points\n     * @dev newProposalThresholdBPS must be greater than the hardcoded min\n     * @param newProposalThresholdBPS new proposal threshold\n     */\n    function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setProposalThresholdBPS: admin only');\n        require(\n            newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n                newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::_setProposalThreshold: invalid proposal threshold bps'\n        );\n        uint256 oldProposalThresholdBPS = proposalThresholdBPS;\n        proposalThresholdBPS = newProposalThresholdBPS;\n\n        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, proposalThresholdBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the minimum quorum votes bps\n     * @param newMinQuorumVotesBPS minimum quorum votes bps\n     *     Must be between `MIN_QUORUM_VOTES_BPS_LOWER_BOUND` and `MIN_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be lower than or equal to maxQuorumVotesBPS\n     */\n    function _setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setMinQuorumVotesBPS: admin only');\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        require(\n            newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n                newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n            'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n        );\n        require(\n            newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n            'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n        );\n\n        uint16 oldMinQuorumVotesBPS = params.minQuorumVotesBPS;\n        params.minQuorumVotesBPS = newMinQuorumVotesBPS;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MinQuorumVotesBPSSet(oldMinQuorumVotesBPS, newMinQuorumVotesBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the maximum quorum votes bps\n     * @param newMaxQuorumVotesBPS maximum quorum votes bps\n     *     Must be lower than `MAX_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be higher than or equal to minQuorumVotesBPS\n     */\n    function _setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setMaxQuorumVotesBPS: admin only');\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        require(\n            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n        );\n        require(\n            params.minQuorumVotesBPS <= newMaxQuorumVotesBPS,\n            'NounsDAO::_setMaxQuorumVotesBPS: min quorum votes bps greater than max'\n        );\n\n        uint16 oldMaxQuorumVotesBPS = params.maxQuorumVotesBPS;\n        params.maxQuorumVotesBPS = newMaxQuorumVotesBPS;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MaxQuorumVotesBPSSet(oldMaxQuorumVotesBPS, newMaxQuorumVotesBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the dynamic quorum coefficient\n     * @param newQuorumCoefficient the new coefficient, as a fixed point integer with 6 decimals\n     */\n    function _setQuorumCoefficient(uint32 newQuorumCoefficient) external {\n        require(msg.sender == admin, 'NounsDAO::_setQuorumCoefficient: admin only');\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        uint32 oldQuorumCoefficient = params.quorumCoefficient;\n        params.quorumCoefficient = newQuorumCoefficient;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit QuorumCoefficientSet(oldQuorumCoefficient, newQuorumCoefficient);\n    }\n\n    /**\n     * @notice Admin function for setting all the dynamic quorum parameters\n     * @param newMinQuorumVotesBPS minimum quorum votes bps\n     *     Must be between `MIN_QUORUM_VOTES_BPS_LOWER_BOUND` and `MIN_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be lower than or equal to maxQuorumVotesBPS\n     * @param newMaxQuorumVotesBPS maximum quorum votes bps\n     *     Must be lower than `MAX_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be higher than or equal to minQuorumVotesBPS\n     * @param newQuorumCoefficient the new coefficient, as a fixed point integer with 6 decimals\n     */\n    function _setDynamicQuorumParams(\n        uint16 newMinQuorumVotesBPS,\n        uint16 newMaxQuorumVotesBPS,\n        uint32 newQuorumCoefficient\n    ) public {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        if (\n            newMinQuorumVotesBPS < MIN_QUORUM_VOTES_BPS_LOWER_BOUND ||\n            newMinQuorumVotesBPS > MIN_QUORUM_VOTES_BPS_UPPER_BOUND\n        ) {\n            revert InvalidMinQuorumVotesBPS();\n        }\n        if (newMaxQuorumVotesBPS > MAX_QUORUM_VOTES_BPS_UPPER_BOUND) {\n            revert InvalidMaxQuorumVotesBPS();\n        }\n        if (newMinQuorumVotesBPS > newMaxQuorumVotesBPS) {\n            revert MinQuorumBPSGreaterThanMaxQuorumBPS();\n        }\n\n        DynamicQuorumParams memory oldParams = getDynamicQuorumParamsAt(block.number);\n\n        DynamicQuorumParams memory params = DynamicQuorumParams({\n            minQuorumVotesBPS: newMinQuorumVotesBPS,\n            maxQuorumVotesBPS: newMaxQuorumVotesBPS,\n            quorumCoefficient: newQuorumCoefficient\n        });\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MinQuorumVotesBPSSet(oldParams.minQuorumVotesBPS, params.minQuorumVotesBPS);\n        emit MaxQuorumVotesBPSSet(oldParams.maxQuorumVotesBPS, params.maxQuorumVotesBPS);\n        emit QuorumCoefficientSet(oldParams.quorumCoefficient, params.quorumCoefficient);\n    }\n\n    function _withdraw() external {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n\n        uint256 amount = address(this).balance;\n        (bool sent, ) = msg.sender.call{ value: amount }('');\n\n        emit Withdraw(amount, sent);\n    }\n\n    /**\n     * @notice Be"
    }
  ]
}