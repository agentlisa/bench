{
  "Title": "[M-05] DOS possible while stopping a rental with erc777 tokens",
  "Content": "\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L265> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L100>\n\nIf an order involves erc777 token for a pay order then in the `tokensReceived` callback the renter can create DOS situation resulting in the lender's assets being stuck in the rental safe.\n\n### Proof of Concept\n\n[ERC777 token standard](https://eips.ethereum.org/EIPS/eip-777) which is backward compatible with `erc20` implies that on the transfer of the tokens the recipient can implement a `tokensReceived` hook to notify of any increment of the balance.\n\nNow suppose a pay order is created with an erc 777 consideration asset as there is no restriction on that and also the eip specifies that\n\n    The difference for new contracts implementing ERC-20 is that tokensToSend and tokensReceived hooks take precedence over ERC-20. Even with an ERC-20 transfer and transferFrom call, the token contract MUST check via ERC-1820 if the from and the to address implement tokensToSend and tokensReceived hook respectively. If any hook is implemented, it MUST be called. Note that when calling ERC-20 transfer on a contract, if the contract does not implement tokensReceived, the transfer call SHOULD still be accepted even if this means the tokens will probably be locked.\n\nSo the `tokensReceived` hook is optional for a `transfer/transferFrom` call. Hence sending the assets from the lender's wallet to the escrow contract shouldn't be an issue.\n\nNow when the rental period is over or in/between, the `stopRent` method in stop policy is called, which calls `settlePayment` in escrow module. Now on the token transfer\n\n            (bool success, bytes memory data) = token.call(\n                abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n            );\n\nThe `tokensReceived` hook if implemented by the renter, would be called and they could just `revert the tx` inside the `tokensReceived` hook which would mean that the assets lent by the lender are locked forever.\n\n### Recommended Mitigation Steps\n\nIt is recommended to prohibit erc777 tokens from being used as consideration items.\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/487#issuecomment-1917115475):**\n> Batching all the ERC777 token issues together.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/487#issuecomment-1922080633)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/7) - Implements a whitelist so only granted assets can be used in the protocol.<br>\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/17) - Implements batching functionality for whitelisting tokens so that multiple can be added at once.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/51), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/39) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/12).\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Stop.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Reclaimer} from \"@src/packages/Reclaimer.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {\n    Item,\n    RentalOrder,\n    Hook,\n    OrderType,\n    ItemType,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\n\n/**\n * @title Stop\n * @notice Acts as an interface for all behavior related to stoping a rental.\n */\ncontract Stop is Policy, Signer, Reclaimer, Accumulator {\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Reclaimer() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](4);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector);\n        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector);\n        requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector);\n        requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Helper function to emit an event which signals a rental order has stopped.\n     *\n     * @param seaportOrderHash Order hash of the seaport order.\n     * @param stopper Address which stopped the rental order.\n     */\n    function _emitRentalOrderStopped(bytes32 seaportOrderHash, address stopper) internal {\n        // Wmit the event.\n        emit Events.RentalOrderStopped(seaportOrderHash, stopper);\n    }\n\n    /**\n     * @dev Validates that a rental order can be stopped. Whether an order\n     *      can be stopped is dependent on the type of order. BASE orders can\n     *      be stopped only when the rental has expired. PAY orders can be stopped\n     *      by the lender at any point in the time.\n     *\n     * @param orderType Order type of the rental order to stop.\n     * @param endTimestamp Timestamp that the rental will end.\n     * @param expectedLender Address of the initial lender in the order.\n     */\n    function _validateRentalCanBeStoped(\n        OrderType orderType,\n        uint256 endTimestamp,\n        address expectedLender\n    ) internal view {\n        // Determine if the order has expired.\n        bool hasExpired = endTimestamp <= block.timestamp;\n\n        // Determine if the fulfiller is the lender of the order.\n        bool isLender = expectedLender == msg.sender;\n\n        // BASE orders processing.\n        if (orderType.isBaseOrder()) {\n            // check that the period for the rental order has expired.\n            if (!hasExpired) {\n                revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n            }\n        }\n        // PAY order processing.\n        else if (orderType.isPayOrder()) {\n            // If the stopper is the lender, then it doesnt matter whether the rental\n            // has expired. But if the stopper is not the lender, then the rental must have expired.\n            if (!isLender && (!hasExpired)) {\n                revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n            }\n        }\n        // Revert if given an invalid order type.\n        else {\n            revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n        }\n    }\n\n    /**\n     * @dev Since the stop policy is an enabled Gnosis Safe module on all rental safes, it\n     *      can be used to execute a transaction directly from the rental safe which retrieves\n     *      the rented assets. This call bypasses the guard that prevents the assets from being\n     *      transferred.\n     *\n     * @param order Rental order to reclaim the items for.\n     */\n    function _reclaimRentedItems(RentalOrder memory order) internal {\n        // Transfer ERC721s from the renter back to lender.\n        bool success = ISafe(order.rentalWallet).execTransactionFromModule(\n            // Stop policy inherits the reclaimer package.\n            address(this),\n            // value.\n            0,\n            // The encoded call to the `reclaimRentalOrder` function.\n            abi.encodeWithSelector(this.reclaimRentalOrder.selector, order),\n            // Safe must delegate call to the stop policy so that it is the msg.sender.\n            Enum.Operation.DelegateCall\n        );\n\n        // Assert that the transfer back to the lender was successful.\n        if (!success) {\n            revert Errors.StopPolicy_ReclaimFailed();\n        }\n    }\n\n    /**\n     * @dev When a rental order is stopped, process each hook one by one but only if\n     *      the hook's status is set to execute on a rental stop.\n     *\n     * @param hooks        Array of hooks to process for the order.\n     * @param rentalItems  Array of rental items which are referenced by the hooks\n     * @param rentalWallet Address of the rental wallet which is the current owner\n     *                     of the rented assets.\n     */\n    function _removeHooks(\n        Hook[] calldata hooks,\n        Item[] calldata rentalItems,\n        address rentalWallet\n    ) internal {\n        // Define hook target, item index, and item.\n        address target;\n        uint256 itemIndex;\n        Item memory item;\n\n        // Loop through each hook in the payload.\n        for (uint256 i = 0; i < hooks.length; ++i) {\n            // Get the hook address.\n            target = hooks[i].target;\n\n            // Check that the hook is reNFT-approved to execute on rental stop.\n            if (!STORE.hookOnStop(target)) {\n                revert Errors.Shared_DisabledHook(target);\n            }\n\n            // Get the rental item index for this hook.\n            itemIndex = hooks[i].itemIndex;\n\n            // Get the rental item for this hook.\n            item = rentalItems[itemIndex];\n\n            // Make sure the item is a rented item.\n            if (!item.isRental()) {\n                revert Errors.Shared_NonRentalHookItem(itemIndex);\n            }\n\n            // Call the hook with data about the rented item.\n            try\n                IHook(target).onStop(\n                    rentalWallet,\n                    item.token,\n                    item.identifier,\n                    item.amount,\n                    hooks[i].extraData\n                )\n            {} catch Error(string memory revertReason) {\n                // Revert with reason given.\n                revert Errors.Shared_HookFailString(revertReason);\n            } catch Panic(uint256 errorCode) {\n                // Convert solidity panic code to string.\n                string memory stringErrorCode = LibString.toString(errorCode);\n\n                // Revert with panic code.\n                revert Errors.Shared_HookFailString(\n                    string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n                );\n            } catch (bytes memory revertData) {\n                // Fallback to an error that returns the byte data.\n                revert Errors.Shared_HookFailBytes(revertData);\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Stops a rental by providing a `RentalOrder` struct. This data does not\n     *         exist in protocol storage, only the hash of the rental order. However,\n     *         during rental creation, all data needed to construct the rental order\n     *         is emitted as an event. A check is then made to ensure that the passed\n     *         in rental order matches the hash of a rental order in storage.\n     *\n     * @param order Rental order to stop.\n     */\n    function stopRent(RentalOrder calldata order) external {\n        // Check that the rental can be stopped.\n        _validateRentalCanBeStoped(order.orderType, order.endTimestamp, order.lender);\n\n        // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n        // the rented amount. From this point on, new memory cannot be safely allocated until the\n        // accumulator no longer needs to include elements.\n        bytes memory rentalAssetUpdates = new bytes(0);\n\n        // Check if each item in the order is a rental. If so, then generate the rental asset update.\n        // Memory will become safe again after this block.\n        for (uint256 i; i < order.items.length; ++i) {\n            if (order.items[i].isRental()) {\n                // Insert the rental asset update into the dynamic array.\n                _insert(\n                    rentalAssetUpdates,\n                    order.items[i].toRentalId(order.rentalWallet),\n                    order.items[i].amount\n                );\n            }\n        }\n\n        // Interaction: process hooks so they no longer exist for the renter.\n        if (order.hooks.length > 0) {\n            _removeHooks(order.hooks, order.items, order.rentalWallet);\n        }\n\n        // Interaction: Transfer rentals from the renter back to lender.\n        _reclaimRentedItems(order);\n\n        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n        ESCRW.settlePayment(order);\n\n        // Interaction: Remove rentals from storage by computing the order hash.\n        STORE.removeRentals(\n            _deriveRentalOrderHash(order),\n            _convertToStatic(rentalAssetUpdates)\n        );\n\n        // Emit rental order stopped.\n        _emitRentalOrderStopped(order.seaportOrderHash, msg.sender);\n    }\n\n    /**\n     * @notice Stops a batch of rentals by providing an array of `RentalOrder` structs.\n     *\n     * @param orders Array of rental orders to stop.\n     */\n    function stopRentBatch(RentalOrder[] calldata orders) external {\n        // Create an array of rental order hashes which will be removed from storage.\n        bytes32[] memory orderHashes = new bytes32[](orders.length);\n\n        // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n        // the rented amount. From this point on, new memory cannot be safely allocated until the\n        // accumulator no longer needs to include elements.\n        bytes memory rentalAssetUpdates = new bytes(0);\n\n        // Process each rental order.\n        // Memory will become safe after this block.\n        for (uint256 i = 0; i < orders.length; ++i) {\n            // Check that the rental can be stopped.\n            _validateRentalCanBeStoped(\n                orders[i].orderType,\n                orders[i].endTimestamp,\n                orders[i].lender\n            );\n\n            // Check if each item in the order is a rental. If so, then generate the rental asset update.\n            for (uint256 j = 0; j < orders[i].items.length; ++j) {\n                // Insert the rental asset update into the dynamic array.\n                if (orders[i].items[j].isRental()) {\n                    _insert(\n                        rentalAssetUpdates,\n                        orders[i].items[j].toRentalId(orders[i].rentalWallet),\n                        orders[i].items[j].amount\n                    );\n                }\n            }\n\n            // Add the order hash to an array.\n            orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n\n            // Interaction: Process hooks so they no longer exist for the renter.\n            if (orders[i].hooks.length > 0) {\n                _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n            }\n\n            // Interaction: Transfer rental assets from the renter back to lender.\n            _reclaimRentedItems(orders[i]);\n\n            // Emit rental order stopped.\n            _emitRentalOrderStopped(orderHashes[i], msg.sender);\n        }\n\n        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n        ESCRW.settlePaymentBatch(orders);\n\n        // Interaction: Remove all rentals from storage.\n        STORE.removeRentalsBatch(orderHashes, _convertToStatic(rentalAssetUpdates));\n    }\n}"
    },
    {
      "filename": "src/modules/PaymentEscrow.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\n\nimport {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\nimport {Proxiable} from \"@src/proxy/Proxiable.sol\";\nimport {\n    RentalOrder,\n    Item,\n    ItemType,\n    SettleTo,\n    OrderType\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\n\n/**\n * @title PaymentEscrowBase\n * @notice Storage exists in its own base contract to avoid storage slot mismatch during upgrades.\n */\ncontract PaymentEscrowBase {\n    // Keeps a record of the current token balances in the escrow.\n    mapping(address token => uint256 amount) public balanceOf;\n\n    // Fee percentage taken from payments.\n    uint256 public fee;\n}\n\n/**\n * @title PaymentEscrow\n * @notice Module dedicated to escrowing rental payments while rentals are active. When\n *         rentals are stopped, this module will determine payouts to all parties and a\n *         fee will be reserved to be withdrawn later by a protocol admin.\n */\ncontract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n    using RentalUtils for Item;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Module Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Instantiate this contract as a module. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /**\n     * @notice Instantiates this contract as a module via a proxy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    function MODULE_PROXY_INSTANTIATION(\n        Kernel kernel_\n    ) external onlyByProxy onlyUninitialized {\n        kernel = kernel_;\n        initialized = true;\n    }\n\n    /**\n     * @notice Specifies which version of a module is being implemented.\n     */\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /**\n     * @notice Defines the keycode for this module.\n     */\n    function KEYCODE() public pure override returns (Keycode) {\n        return Keycode.wrap(\"ESCRW\");\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Calculates the fee based on the fee numerator set by an admin.\n     *\n     * @param amount Amount for which to calculate the fee.\n     */\n    function _calculateFee(uint256 amount) internal view returns (uint256) {\n        // Uses 10,000 as a denominator for the fee.\n        return (amount * fee) / 10000;\n    }\n\n    /**\n     * @dev Safe transfer for ERC20 tokens that do not consistently renturn true/false.\n     *\n     * @param token Asset address which is being sent.\n     * @param to    Destination address for the transfer.\n     * @param value Amount of the asset being transferred.\n     */\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        // Call transfer() on the token.\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n\n        // Because both reverting and returning false are allowed by the ERC20 standard\n        // to indicate a failed transfer, we must handle both cases.\n        //\n        // If success is false, the ERC20 contract reverted.\n        //\n        // If success is true, we must check if return data was provided. If no return\n        // data is provided, then no revert occurred. But, if return data is provided,\n        // then it must be decoded into a bool which will indicate the success of the\n        // transfer.\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n        }\n    }\n\n    /**\n     * @dev Calculates the pro-rata split based on the amount of time that has elapsed in\n     *      a rental order. If there are not enough funds to split perfectly, rounding is\n     *      done to make the split as fair as possible.\n     *\n     * @param amount      Amount of tokens for which to calculate the split.\n     * @param elapsedTime Elapsed time since the rental started.\n     * @param totalTime   Total time window of the rental from start to end.\n     *\n     * @return renterAmount Payment amount to send to the renter.\n     * @return lenderAmount Payment amoutn to send to the lender.\n     */\n    function _calculatePaymentProRata(\n        uint256 amount,\n        uint256 elapsedTime,\n        uint256 totalTime\n    ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) {\n        // Calculate the numerator and adjust by a multiple of 1000.\n        uint256 numerator = (amount * elapsedTime) * 1000;\n\n        // Calculate the result, but bump by 500 to add a rounding adjustment. Then,\n        // reduce by a multiple of 1000.\n        renterAmount = ((numerator / totalTime) + 500) / 1000;\n\n        // Calculate lender amount from renter amount so no tokens are left behind.\n        lenderAmount = amount - renterAmount;\n    }\n\n    /**\n     * @dev Settles a payment via a pro-rata split. After payments are calculated, they\n     *      are transferred to their respective recipients.\n     *\n     * @param token       Token address for which to settle a payment.\n     * @param amount      Amount of the token to settle.\n     * @param lender      Lender account.\n     * @param renter      Renter accoutn.\n     * @param elapsedTime Elapsed time since the rental started.\n     * @param totalTime   Total time window of the rental from start to end.\n     */\n    function _settlePaymentProRata(\n        address token,\n        uint256 amount,\n        address lender,\n        address renter,\n        uint256 elapsedTime,\n        uint256 totalTime\n    ) internal {\n        // Calculate the pro-rata payment for renter and lender.\n        (uint256 renterAmount, uint256 lenderAmount) = _calculatePaymentProRata(\n            amount,\n            elapsedTime,\n            totalTime\n        );\n\n        // Send the lender portion of the payment.\n        _safeTransfer(token, lender, lenderAmount);\n\n        // Send the renter portion of the payment.\n        _safeTransfer(token, renter, renterAmount);\n    }\n\n    /**\n     * @dev Settles a payment by sending the full amount to one address.\n     *\n     * @param token    Token address for which to settle a payment.\n     * @param amount   Amount of the token to settle.\n     * @param settleTo Specifies whether to settle to the lender or the renter.\n     * @param lender   Lender account.\n     * @param renter   Renter account.\n     */\n    function _settlePaymentInFull(\n        address token,\n        uint256 amount,\n        SettleTo settleTo,\n        address lender,\n        address renter\n    ) internal {\n        // Determine the address that this payment will settle to.\n        address settleToAddress = settleTo == SettleTo.LENDER ? lender : renter;\n\n        // Send the payment.\n        _safeTransfer(token, settleToAddress, amount);\n    }\n\n    /**\n     * @dev Settles alls payments contained in the given item. Uses a pro-rata or in full\n     *      scheme depending on the order type and when the order was stopped.\n     *\n     * @param items     Items present in the order.\n     * @param orderType Type of the order.\n     * @param lender    Lender account.\n     * @param renter    Renter account.\n     * @param start     Timestamp that the rental began.\n     * @param end       Timestamp that the rental expires at.\n     */\n    function _settlePayment(\n        Item[] calldata items,\n        OrderType orderType,\n        address lender,\n        address renter,\n        uint256 start,\n        uint256 end\n    ) internal {\n        // Calculate the time values.\n        uint256 elapsedTime = block.timestamp - start;\n        uint256 totalTime = end - start;\n\n        // Determine whether the rental order has ended.\n        bool isRentalOver = elapsedTime >= totalTime;\n\n        // Loop through each item in the order.\n        for (uint256 i = 0; i < items.length; ++i) {\n            // Get the item.\n            Item memory item = items[i];\n\n            // Check that the item is a payment.\n            if (item.isERC20()) {\n                // Set a placeholder payment amount which can be reduced in the\n                // presence of a fee.\n                uint256 paymentAmount = item.amount;\n\n                // Take a fee on the payment amount if the fee is on.\n                if (fee != 0) {\n                    // Calculate the new fee.\n                    uint256 paymentFee = _calculateFee(paymentAmount);\n\n                    // Adjust the payment amount by the fee.\n                    paymentAmount -= paymentFee;\n                }\n\n                // Effect: Decrease the token balance. Use the payment amount pre-fee\n                // so that fees can be taken.\n                _decreaseDeposit(item.token, item.amount);\n\n                // If its a PAY order but the rental hasn't ended yet.\n                if (orderType.isPayOrder() && !isRentalOver) {\n                    // Interaction: a PAY order which hasnt ended yet. Payout is pro-rata.\n                    _settlePaymentProRata(\n                        item.token,\n                        paymentAmount,\n                        lender,\n                        renter,\n                        elapsedTime,\n                        totalTime\n                    );\n                }\n                // If its a PAY order and the rental is over, or, if its a BASE order.\n                else if (\n                    (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n                ) {\n                    // Interaction: a pay order or base order which has ended. Payout is in full.\n                    _settlePaymentInFull(\n                        item.token,\n                        paymentAmount,\n                        item.settleTo,\n                        lender,\n                        renter\n                    );\n                } else {\n                    revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Decreases the tracked token balance of a particular token on the payment\n     *      escrow contract.\n     *\n     * @param token  Token address.\n     * @param amount Amount to decrease the balance by.\n     */\n    function _decreaseDeposit(address token, uint256 amount) internal {\n        // Directly decrease the synced balance.\n        balanceOf[token] -= amount;\n    }\n\n    /**\n     * @dev Increases the tracked token balance of a particular token on the payment\n     *      escrow contract.\n     *\n     * @param token  Token address.\n     * @param amount Amount to increase the balance by.\n     */\n    function _increaseDeposit(address token, uint256 amount) internal {\n        // Directly increase the synced balance.\n        balanceOf[token] += amount;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Settles the payment for a rental order by transferring all items marked as\n     *         payments to their destination accounts. During the settlement process, if\n     *         active, a fee is taken on the payment.\n     *\n     * @param order Rental order for which to settle a payment.\n     */\n    function settlePayment(RentalOrder calldata order) external onlyByProxy permissioned {\n        // Settle all payments for the order.\n        _settlePayment(\n            order.items,\n            order.orderType,\n            order.lender,\n            order.renter,\n            order.startTimestamp,\n            order.endTimestamp\n        );\n    }\n\n    /**\n     * @notice Settles the payments for multiple orders by looping through each one.\n     *\n     * @param orders Rental ordesr for which to settle payments.\n     */\n    function settlePaymentBatch(\n        RentalOrder[] calldata orders\n    ) external onlyByProxy permissioned {\n        // Loop through each order.\n        for (uint256 i = 0; i < orders.length; ++i) {\n            // Settle all payments for the order.\n            _settlePayment(\n                orders[i].items,\n                orders[i].orderType,\n                orders[i].lender,\n                orders[i].renter,\n                orders[i].startTimestamp,\n                orders[i].endTimestamp\n            );\n        }\n    }\n\n    /**\n     * @notice When fungible tokens are transferred to the payment escrow contract,\n     *         their balances should be increased.\n     *\n     * @param token  Token address for the asset.\n     * @param amount Amount of the token transferred to the escrow\n     */\n    function increaseDeposit(\n        address token,\n        uint256 amount\n    ) external onlyByProxy permissioned {\n        // Cannot accept a payment of zero.\n        if (amount == 0) {\n            revert Errors.PaymentEscrow_ZeroPayment();\n        }\n\n        // Increase the deposit\n        _increaseDeposit(token, amount);\n    }\n\n    /**\n     * @notice Sets the numerator for the fee. The denominator will always be set at\n     *         10,000.\n     *\n     * @param feeNumerator Numerator of the fee.\n     */\n    function setFee(uint256 feeNumerator) external onlyByProxy permissioned {\n        // Cannot accept a fee numerator greater than 10000.\n        if (feeNumerator > 10000) {\n            revert Errors.PaymentEscrow_InvalidFeeNumerator();\n        }\n\n        // Set the fee.\n        fee = feeNumerator;\n    }\n\n    /**\n     * @notice Used to collect protocol fees. In addition, if funds are accidentally sent\n     *         to the payment escrow contract, this function can be used to skim them off.\n     *\n     * @param token Address of the token to skim.\n     * @param to    Address to send the collected tokens.\n     */\n    function skim(address token, address to) external onlyByProxy permissioned {\n        // Fetch the currently synced balance of the escrow.\n        uint256 syncedBalance = balanceOf[token];\n\n        // Fetch the true token balance of the escrow.\n        uint256 trueBalance = IERC20(token).balanceOf(address(this));\n\n        // Calculate the amount to skim.\n        uint256 skimmedBalance = trueBalance - syncedBalance;\n\n        // Send the difference to the specified address.\n        _safeTransfer(token, to, skimmedBalance);\n\n        // Emit event with fees taken.\n        emit Events.FeeTaken(token, skimmedBalance);\n    }\n\n    /**\n     * @notice Upgrades the contract to a different implementation. This implementation\n     *         contract must be compatible with ERC-1822 or else the upgrade will fail.\n     *\n     * @param newImplementation Address of the implementation contract to upgrade to.\n     */\n    function upgrade(address newImplementation) external onlyByProxy permissioned {\n        // _upgrade is implemented in the Proxiable contract.\n        _upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the contract which prevents upgrading the implementation contract.\n     *         There is no way to unfreeze once a contract has been frozen.\n     */\n    function freeze() external onlyByProxy permissioned {\n        // _freeze is implemented in the Proxiable contract.\n        _freeze();\n    }\n}"
    }
  ]
}