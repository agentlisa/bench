{
  "Title": "H-2: Invalid oracle versions can cause desync of global and local positions making protocol lose funds and being unable to pay back all users",
  "Content": "# Issue H-2: Invalid oracle versions can cause desync of global and local positions making protocol lose funds and being unable to pay back all users \n\nSource: https://github.com/sherlock-audit/2023-07-perennial-judging/issues/49 \n\n## Found by \npanprog\n\nWhen oracle version is skipped for any reason (marked as invalid), pending positions are invalidated (reset to previous latest position):\n```solidity\n    function _processPositionGlobal(Context memory context, uint256 newPositionId, Position memory newPosition) private {\n        Version memory version = _versions[context.latestPosition.global.timestamp].read();\n        OracleVersion memory oracleVersion = _oracleVersionAtPosition(context, newPosition);\n>        if (!oracleVersion.valid) newPosition.invalidate(context.latestPosition.global);\n...\n    function _processPositionLocal(\n        Context memory context,\n        address account,\n        uint256 newPositionId,\n        Position memory newPosition\n    ) private {\n        Version memory version = _versions[newPosition.timestamp].read();\n>        if (!version.valid) newPosition.invalidate(context.latestPosition.local);\n```\n\nThis invalidation is only temporary, until the next valid oracle version. The problem is that global and local positions can be settled with different next valid oracle version, leading to temporary desync of global and local positions, which in turn leads to incorrect accumulation of protocol values, mostly in profit and loss accumulation, breaking internal accounting: total collateral of all users can increase or decrease due to this while the funds deposited remain the same, possibly triggering a bank run, since the last user to withdraw will be unable to do so, or some users might get collateral reduced when it shouldn't (loss of funds for them).\n\n## Vulnerability Detail\n\nIn more details, if there are 2 pending positions with timestamps different by 2 oracle versions and the first of them has invalid oracle version at its timestamp, then there are 2 different position flows possible depending on the time when the position is settled (update transaction called):\n1. For earlier update the flow is: previous position (oracle v1) -> position 1 (oracle v2) -> position 2 (oracle v3)\n2. For later update position 1 is skipped completely (the fees for the position are also not taken) and the flow is: previous position (oracle v1) -> invalidated position 1 (in the other words: previous position again) (oracle v2) -> position 2 (oracle v3)\n\nWhile the end result (position 2) is the same, it's possible that pending global position is updated earlier (goes the 1st path), while the local position is updated later (goes the 2nd path). For a short time (between oracle versions 2 and 3), the global position will accumulate everything (including profit and loss) using the pending position 1 long/short/maker values, but local position will accumulate everything using the previous position with different values.\n\nConsider the following scenario:\nOracle uses granularity = 100. Initially user B opens position maker = 2 with collateral = 100.\nT=99:  User A opens long = 1 with collateral = 100 (pending position long=1 timestamp=100)\nT=100: Oracle fails to commit this version, thus it becomes invalid\nT=201: At this point oracle version at timestamp 200 is not yet commited, but the new positions are added with the next timestamp = 300:\nUser A closes his long position (update(0,0,0,0)) (pending position: long=1 timestamp=100; long=0 timestamp=300)\nAt this point, current global long position is still 0 (pending the same as user A local pending positions)\n\nT=215: Oracle commits version with timestamp = 200, price = $100\nT=220: User B settles (update(2,0,0,0) - keeping the same position).\nAt this point the latest oracle version is the one at timestamp = 200, so this update triggers update of global pending positions, and current latest global position is now long = 1.0 at timestamp = 200.\nT=315: Oracle commits version with timestamp = 300, price = $90\nafter settlement of both UserA and UserB, we have the following:\n\n1. Global position settlement. It accumulates position [maker = 2.0, long = 1.0] from timestamp = 200 (price=$100) to timestamp = 300 (price=$90). In particular:\nlongPnl = 1*($90-$100) = -$10\nmakerPnl = -longPnl = +$10\n2. User B local position settlement. It accumulates position [maker = 2.0] from timestamp = 200 to timestamp = 300, adding makerPnl ($10) to user B collateral. So user B collateral = $110\n3. User A local position settlement. When accumulating, pending position 1 (long = 1, timestamp = 100) is invalidated to previous position (long = 0) and also fees are set to 0 by invalidation. So user A local accumulates position [long = 0] from timestamp = 0 to timestamp = 300 (next pending position), this doesn't change collateral at all (remains $100). Then the next pending position [long = 0] becomes the latest position (basically position of long=1 was completely ignored as if it has not existed).\n\nResult:\nUser A deposited $100, User B deposited $100 (total $200 deposited)\nafter the scenario above:\nUser A has collateral $110, User B has collateral $100 (total $210 collateral withdrawable)\nHowever, protocol only has $200 deposited. This means that the last user will be unable to withdraw the last $10 since protocol doesn't have it, leading to a user loss of funds.\n\n## Impact\n\nAny time the oracle skips a version (invalid version), it's likely that global and local positions for different users who try to trade during this time will desync, leading to messed up accounting and loss of funds for users or protocol, potentially triggering a bank run with the last user being unable to withdraw all funds.\n\nThe severity of this issue is high, because while invalid versions are normally a rare event, however in the current state of the codebase there is a bug that pyth oracle requests are done using this block timestamp instead of granulated future time (as positions do), which leads to invalid oracle versions almost for all updates (that bug is reported separately). Due to this other bug, the situation described in this issue will arise very often by itself in a normal flow of the user requests, so it's almost 100% that internal accounting for any semi-active market will be broken and total user collateral will deviate away from real deposited funds, meaning the user funds loss.\n\nBut even with that other bug fixed, the invalid oracle version is a normal protocol event and even 1 such event might be enough to break internal market accounting.\n\n## Proof of concept\n\nThe scenario above is demonstrated in the test, add this to test/unit/market/Market.test.ts:\n```solidity\nit('panprog global-local desync', async () => {\n    const positionMaker = parse6decimal('2.000')\n    const positionLong = parse6decimal('1.000')\n    const collateral = parse6decimal('100')\n\n    const oracleVersion = {\n        price: parse6decimal('100'),\n        timestamp: TIMESTAMP,\n        valid: true,\n    }\n    oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion)\n    oracle.status.returns([oracleVersion, oracleVersion.timestamp + 100])\n    oracle.request.returns()\n\n    dsu.transferFrom.whenCalledWith(userB.address, market.address, collateral.mul(1e12)).returns(true)\n    await market.connect(userB).update(userB.address, positionMaker, 0, 0, collateral, false)\n\n    const oracleVersion2 = {\n        price: parse6decimal('100'),\n        timestamp: TIMESTAMP + 100,\n        valid: true,\n    }\n    oracle.at.whenCalledWith(oracleVersion2.timestamp).returns(oracleVersion2)\n    oracle.status.returns([oracleVersion2, oracleVersion2.timestamp + 100])\n    oracle.request.returns()\n\n    dsu.transferFrom.whenCalledWith(user.address, market.address, collateral.mul(1e12)).returns(true)\n    await market.connect(user).update(user.address, 0, positionLong, 0, collateral, false)\n\n    var info = await market.locals(userB.address);\n    console.log(\"collateral deposit maker: \" + info.collateral);\n    var info = await market.locals(user.address);\n    console.log(\"collateral deposit long: \" + info.collateral);\n\n    // invalid oracle version\n    const oracleVersion3 = {\n        price: 0,\n        timestamp: TIMESTAMP + 200,\n        valid: false,\n    }\n    oracle.at.whenCalledWith(oracleVersion3.timestamp).returns(oracleVersion3)\n\n    // next oracle version is valid\n    const oracleVersion4 = {\n        price: parse6decimal('100'),\n        timestamp: TIMESTAMP + 300,\n        valid: true,\n    }\n    oracle.at.whenCalledWith(oracleVersion4.timestamp).returns(oracleVersion4)\n\n    // still returns oracleVersion2, because nothing commited for version 3, and version 4 time has passed but not yet commited\n    oracle.status.returns([oracleVersion2, oracleVersion4.timestamp + 100])\n    oracle.request.returns()\n\n    // reset to 0\n    await market.connect(user).update(user.address, 0, 0, 0, 0, false)\n\n    // oracleVersion4 commited\n    oracle.status.returns([oracleVersion4, oracleVersion4.timestamp + 100])\n    oracle.request.returns()\n\n    // settle\n    await market.connect(userB).update(userB.address, positionMaker, 0, 0, 0, false)\n\n    const oracleVersion5 = {\n        price: parse6decimal('90'),\n        timestamp: TIMESTAMP + 400,\n        valid: true,\n    }\n    oracle.at.whenCalledWith(oracleVersion5.timestamp).returns(oracleVersion5)\n    oracle.status.returns([oracleVersion5, oracleVersion5.timestamp + 100])\n    oracle.request.returns()\n\n    // settle\n    await market.connect(userB).update(userB.address, positionMaker, 0, 0, 0, false)\n    await market.connect(user).update(user.address, 0, 0, 0, 0, false)\n\n    var info = await market.locals(userB.address);\n    console.log(\"collateral maker: \" + info.collateral);\n    var info = await market.locals(user.address);\n    console.log(\"collateral long: \" + info.collateral);\n})\n```\n\nConsole output for the code:\n```solidity\ncollateral deposit maker: 100000000\ncollateral deposit long: 100000000\ncollateral maker: 110000028\ncollateral long: 100000000\n```\nMaker has a bit more than $110 in the end, because he also earns funding and interest during the short time when ephemeral long position is active (but user A doesn't pay these fees).\n\n## Code Snippet\n\n`_processPositionGlobal` invalidates position if oracle version is invalid for its timestamp:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L390-L393\n\n`_processPositionLocal` does the same:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L430-L437\n\n`_settle` loops over global and local positions until the latest oracle version timestamp. In this loop each position is invalidated to previous latest if it has invalid oracle timestamp. So if `_settle` is called after the invalid timestamp, previous latest is accumulated for it:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L333-L347\n\nLater in the `_settle`, the latest global and local position are advanced to latestVersion timestamp, the difference from the loop is that since position timestamp is set to valid oracle version, `_processPositionGlobal` and `_processPositionLocal` here will be called with valid oracle and thus position (which is otherwise invalidated in the loop) will be valid and set as the latest position:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L349-L360\n\nThis means that for early timestamps, invalid version positions will become valid in the `sync` part of the `_settle`. But for late timestamps, invalid version position will be skipped completely in the loop before `sync`. This is the core reason of desync between local and global positions.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe issue is that positions with invalid oracle versions are ignored until the first valid oracle version, however the first valid version can be different for global and local positions. One of the solutions I see is to introduce a map of position timestamp -> oracle version to settle, which will be filled by global position processing. Local position processing will follow the same path as global using this map, which should eliminate possibility of different paths for global and local positions.\n\nIt might seem that the issue can only happen with exactly 1 oracle version between invalid and valid positions. However, it's also possible that some non-requested oracle versions are commited (at some random timestamps between normal oracle versions) and global position will go via the route like t100[pos0]->t125[pos1]->t144[pos1]->t200[pos2] while local one will go t100[pos0]->t200[pos2] OR it can also go straight to t300 instead of t200 etc. So the exact route can be anything, and local oracle will have to follow it, that's why I suggest a path map.\n\nThere might be some other solutions possible.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**__141345__** commented:\n> m\n\n\n\n**panprog**\n\nEscalate\n\nThis should be high, because:\n1. When the situation described in the issue happens, it causes serious internal accounting issue causing loss of funds by users and possibly causing bank run and then loss of funds by the last users.\n2. The condition for this to happen is invalid oracle version, which in the current state of the code will happen regularly (see #42)\n3. For the situation described to happen it's enough for 1 user to request to open position, oracle to be invalid for that position timestamp, and then the user to request any modification to this position (increase or decrease), then another user to do any action after the next oracle is commited. That's it, internal accounting is broken.\n4. The stated flow of events can happen by itself very regularly in any semi-active market, leading to worse and worse accounting broking up.\n5. **OR** malicious user can try to abuse this scenario to profit off it or just to break the protocol. Doing this is mostly free (except for some keeper fees). In such case the protocol will be broken very quickly.\n\nI don't know why it's judged medium, but this issue is very likely to happen and will cause a lot of damage to the market, thus it should be high.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should be high, because:\n> 1. When the situation described in the issue happens, it causes serious internal accounting issue causing loss of funds by users and possibly causing bank run and then loss of funds by the last users.\n> 2. The condition for this to happen is invalid oracle version, which in the current state of the code will happen regularly (see #42)\n> 3. For the situation described to happen it's enough for 1 user to request to open position, oracle to be invalid for that position timestamp, and then the user to request any modification to this position (increase or decrease), then another user to do any action after the next oracle is commited. That's it, internal accounting is broken.\n> 4. The stated flow of events can happen by itself very regularly in any semi-active market, leading to worse and worse accounting broking up.\n> 5. **OR** malicious user can try to abuse this scenario to profit off it or just to break the protocol. Doing this is mostly free (except for some keeper fees). In such case the protocol will be broken very quickly.\n> \n> I don't know why it's judged medium, but this issue is very likely to happen and will cause a lot of damage to the market, thus it should be high.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Emedudu**\n\nEscalate\n\n>When oracle version is skipped for any reason (marked as invalid), pending positions are invalidated (reset to previous latest position):\n\nThis is not HIGH because there is a limitation: \"When oracle version is skipped for any reason\"\nThis is a VERY unlikely event.\nSo by Sherlock rules, it is a [MEDIUM](https://docs.sherlock.xyz/audits/judging/judging):\n\"Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost.\"\n\n**panprog**\n\n> This is not HIGH because there is a limitation: \"When oracle version is skipped for any reason\"\n> This is a VERY unlikely event.\n\nWhile it is supposed to be a rare event, in the current state of the code, this is a **VERY LIKELY** event, see #42 \nIt should be judged based on the current code, not on assumptions of how it will work in the future.\n\n**Emedudu**\n\nSkipping of oracle versions is an unlikely event.\nThis was stated under the impact section of the issue:\n\"The severity of this issue is high, `because while invalid versions are normally a rare event`, however in the current state of the codebase there is a bug that pyth oracle requests are done using this block timestamp instead of granulated future time (as positions do), which leads to invalid oracle versions almost for all updates (that bug is reported separately).\"\n\nThis makes this issue to fall under MEDIUM severity according to Sherlock's classification rules.\n\n**Minh-Trng**\n\n> It should be judged based on the current code, not on assumptions of how it will work in the future.\n\nit should be treated like different submissions describing different impacts with the same root cause:\ndoes fixing that one root cause mitigate all described impacts? then all of them are considered duplicates.\n\nnow, clearly your submission is not a duplicate, but it builds on that same root cause. if this root cause were fixed, your impact would still hold, but with a much lower likelihood\n\n**panprog**\n\n> now, clearly your submission is not a duplicate, but it builds on that same root cause. if this root cause were fixed, your impact would still hold, but with a much lower likelihood\n\nYes, I chain 2 issues to demonstrate high impact. In this case both issues should be high. We can't start predicting future \"what happens if that one is fixed...\" The way it is now - existance of either issue creates a high impact for the protocol, and each issue is a separate one.\nI disagree that the issue should be \"isolated\" and impact considered as if the other issues are fixed.\nSherlock has the following judging rule:\n> Future issues: Issues that result out of a future integration/implementation that was not intended (mentioned in the docs/README) or because of a future change in the code (as a fix to another issue) are not valid issues.\n\nWhile it doesn't provide the same clear rule for the opposite, I believe it's a logical continuation of that rule to that impact shouldn't be decreased because of a future change in the code (as a fix to another issue).\n\n**sherlock-admin2**\n\n > Escalate\n> \n> >When oracle version is skipped for any reason (marked as invalid), pending positions are invalidated (reset to previous latest position):\n> \n> This is not HIGH because there is a limitation: \"When oracle version is skipped for any reason\"\n> This is a VERY unlikely event.\n> So by Sherlock rules, it is a [MEDIUM](https://docs.sherlock.xyz/audits/judging/judging):\n> \"Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost.\"\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Minh-Trng**\n\nThe judging rule explicitly talks about **unintended** future implementation. So your logical continuation would also only be applicable to unintended future implementations (which I would absolutely agree with). \n\nYour submission however even shows that you were aware of the correct **intended** future implementations and the change in likelihood that it would bring. \n\n**panprog**\n\n> The judging rule explicitly talks about **unintended** future implementation.\n\nIt says **OR**: so either unintended future implementation **OR** because of future fix of another issue.\n\nI still think this is high because\n1. Even by itself, it messes up accounting and causes loss of funds if oracle version is invalid. Invalid oracle versions are normal protocol operation, even if rare. This can be compared to liquidations - they're also rare but normal protocol operation, so issues in liquidations are considered high. Similarly, this issue due to invalid oracle version should also be high.\n2. In the current implementation, oracle versions are invalid very frequently due to another bug, so this should be high either way. I still think disregarding the other bugs when considering impact is incorrect. And the fact that I'm aware of the intended future implementation is irrelevant: the way it is right now, the issue in this report happens very frequently by itself.\n\n**141345**\n\nMedium severity seems more appropriate.\n\nBecause:\n- the likelihood that \"oracle version is skipped\" is not common scenario. \n- the loss is not significant.\n\nBased on sherlock's H/M [criteria](https://docs.sherlock.xyz/audits/judging/judging)\n> Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. \n\n**panprog**\n\n> * the likelihood that \"oracle version is skipped\" is not common scenario.\n\nIn the current state of the code it is **very likely** scenario (*expected* behavior is for this to be not common scenario, but currently it is common)\n\n> * the loss is not significant.\n\nThis depends. If malicious user want to cause damage (or comes up with a profitable scenario), the loss can be very significant. In the current state of the code - since it will happen often by itself, each instance will not be very significant (0.01-0.2% of the protocol funds depending on price volatility), but it will add up to large amounts over time.\n\n**141345**\n\nAlthough https://github.com/sherlock-audit/2023-07-perennial-judging/issues/42 points out the possibility of skipped version, it does not look like some common events.\n\n0.01-0.2% each time won't be considered material loss. Some normal operation can have even more profit than that, such as spot-futures arbitrage, cross exchange arbitrage.\n\nAnd the attacker need to control the conditions to perform the action. As such, the loss amount and requirements fall into the Med.\n\n**panprog**\n\nI've added a detailed response previously, but don't see it now, maybe it got deleted or not sent properly. Here it is again.\n\n> Although #42 points out the possibility of skipped version, it does not look like some common events.\n\nNo, it's very easy to have skipped versions in the current implementation. For example:\nt=24: user opens postiion (request timestamp = 25, position timestamp = 100)\nt=48: user closes position (request timestamp = 48, position timestamp = 100)\nt=96: user opens position (request timestamp = 96, position timestamp = 100)\nt=108: user closes position (request timestamp = 108, position timestamp = 200)\n...\nIf oracle is commited requested (in the normal operation of the protocol), the commited timestamps will be: 25, 48, 96, 108. Timestamp = 100 will be missing and all position at this timestamp will have invalid oracle version.\nIn order to have a valid oracle version for position, a request to open or close position must be made at exactly the timestamp of the previous positions (t=100 in example). However, a lot of times there won't be even a block with such timestamp. For example, in ethereum blocks are currently happening every 12 seconds and have odd timestamps, and in the other networks the time between blocks is random, so the probability to actually have the block timestamp divisible by granularity is low.\nEven if granularity and block timestamp align well, it still requires that request is made at exactly the granularity timestamp, so for example if granularity = 120 and time between blocks is 12, then every 10th block must have position open in order to request at the right timestamp.\nIt's still possible to commit unrequested, but first, this is not incentivized (as there is no reward to the keeper who commits unrequested) and second, there is still a time window when this has to be commited. So in the example above, commit unrequested for timestamp = 100 can only be done after timestamp = 96 is commited but before the timestamp = 108 is commited. So it's still easy to miss this time window to commit unrequested.\nSo in summary, the way it is now, it's easier to have invalid oracle version, than it is to have valid oracle version.\n\n> 0.01-0.2% each time won't be considered material loss. Some normal operation can have even more profit than that, such as spot-futures arbitrage, cross exchange arbitrage.\n\nI argue that this is actually a material loss - it's the percentage off the **protocol funds**. So if $100M are deposited into protocol, the loss can be like $100K per instance. And since it can happen almost every granularity, this will add up very quick.\n\n> And the attacker need to control the conditions to perform the action. As such, the loss amount and requirements.\n\nEven if there is no attacker, the loss will be smaller, but it will be continuous in time, so even if it's, say, $10K per instance (with $100M deposited), it will add up to tens of millions over less than a day.\n\n**panprog**\n\nRegarding the impact, I want to point that #62 is high and has similar impact (messed up internal accounting), however the real damage from it is:\n\n> The global account's assets and shares should be calculated with toAssetsGlobal and toSharesGlobal respectively, but now, they are calculated with toAssetsLocal and toSharesLocal.\n> toAssetsGlobal subtracts the globalKeeperFees from the global deposited assets, while toAssetsLocal subtracts globalKeeperFees/Checkpoint.count fees from the local account's assets.\n\nSo the real damage from #62 is reduction of deposited assets by (keeper fees / count) instead of (keeper fees). Since keeper fees are low (comparable to gas fees), the real damage is not that large compared to funds deposited (less than 0.001% likely).\n\nHowever, the issue from this report also causes messed up internal accounting, but the real damage depends on position size and price volatility and will be much higher than in #62 on average, even when happening by itself. If coming from malicious parties, this can be a very large amount.\n\nEven though damage in #62 is much easier to inflict, I believe that due to higher damage per instance of this issue, the overall damage over time from this issue will be higher than from #62. Something like:\n$5 per granilarity time from #62 (and still has to be executed by attacker - so the attack has a gas cost of similar amount)\n$10K-$100K per invalid oracle from this one - currently that's maybe once per 10-100 granularities by itself in the current state, so at least $100-$1000 per granularity time (and happens by itself).\n\nSo based on possible real overall damage caused, this issue should be high.\n\n**Emedudu**\n\nThis should be MEDIUM because skipped oracle versions is not a common event.\n\n>In the current state of the code it is very likely scenario (expected behavior is for this to be not common scenario, but currently it is common)\n\nSkipped oracle versions is unlikely, and the reason why it is a likely scenario in the current code is due to a bug, which has already been reported in [#42](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/42).\nFixing [issue 42](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/42) will cause the possibility of this to be unlikely.\nSo, this report is a combination of [issue 42](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/42)(which is already of high severity), and another bug, which is very unlikely by itself.\n\nSince different attack scenarios, with same fixes are considered duplicates, this issue should be a MEDIUM because [issue 42](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/42)(which allows this bug to be a likely scenario) when fixed, will make this issue unlikely\n\n**141345**\n\n1st, the scenario is conditional, not the kind on daily basis.\n2nd, loss magnitude like 0.01-0.2% is common, different exchanges could have that magnitude of price difference, (common arbitrage opportunity, future contracts of different terms can also have larger arbitrage than this).\n\nAs such, conditional loss and capped loss amount, will suggest medium severity.\n\n\n**panprog**\n\n> 1st, the scenario is conditional, not the kind on daily basis.\n\nI don't think high severity means unconditional. My understanding is that high severity is high impact which can happen with rather high probability. And high probability doesn't mean it can happen every transaction, it just means that it can reasonably happen within a week or a month. \nExample (from the other contest): liquidation can be frontrun to block it without spending funds: was judged high, even though liquidation is not very frequent (days can pass without single liquidation). \n\nAnd this issue probability to happen is high. \n\n> 2nd, loss magnitude like 0.01-0.2% is common, different exchanges could have that magnitude of price difference, (common arbitrage opportunity, future contracts of different terms can also have larger arbitrage than this).\n\nWhy do you only consider it as a 1 time event? The way it is now, that'll be like 0.1% per 1-10 minutes, this will add up to 10%+ in less than a day. \n\n> As such, conditional loss and capped loss amount, will suggest medium severity.\n\nI think there are no new arguments presented here, so I keep it up to Sherlock to decide. I think ultimately it comes down to:\n- this issue is high as is now due to the other bug.\n- if the other bug is fixed (and oracle versions work the way they're supposed to work), this one will be medium.\n\nSo my argument is that the way it is now, it's high and severity shouldn't be downgraded as if the other bug is fixed. \n\n**141345**\n\nI don't think it's one time, it's something intermittent, it happens every once in a while, but the frequency might not be as high as per 1-10 minutes.\n\nAnd even it happened, there could be loss, and also sometimes no loss.\n\nThat's why based on the probability of happending and loss, it is more suitable for conditional and capped loss.\n\n**panprog**\n\nI still think this is High, the way it is now - it can happen as often as once per each granularity if malicious user abuses it, or maybe once per 10 granularities with semi-active trading by itself. Either way it's very possible and causes loss of funds.\nAs I said earlier, I see this as medium only if #42 is disregarded, but I don't see any ground to ignore that bug when assessing severity of this one.\n\n**141345**\n\nWhat about the cross exchange price difference, the magnitude could be the same level. Also the spot and perpetual contract could deviates, those cases are not considered exchange's loss.\n\n**panprog**\n\n> What about the cross exchange price difference, the magnitude could be the same level. Also the spot and perpetual contract could deviates, those cases are not considered exchange's loss.\n\nIt's different, they're normal protocol operation and funds just changing hands. This issue leads to mismatch between funds protocol has and funds protocol owes (protocol has 100, but total collateral users can withdraw can be 200, so not all users can withdraw, which can trigger bank run with last users unable to withdraw) \n\n**kbrizzle**\n\nTo chime in here from our perspective -- this issue identified a pretty fundamental flaw in our accounting system that would have caused the markets to be completely out of sync (both w.r.t. positions as well as balances) in the event of an unfortunately timed invalid version.\n\nWhile ideally rare, occasional invalid versions are expected behavior. Invalid versions can occur for a number of reasons during the course of normal operation:\n- Underlying oracle does not have data available for any timestamp in the validity window (occurs in Pyth from time to time)\n- No keeper responds within grace period window\n- Future oracle integration / upgrade adds anomaly detection to invalidate versions via a number of metrics\n\nGiven that this bug would have likely surfaced in normal ope",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/106",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev The token that incentive rewards are paid in\n    Token18 public reward;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev The payoff function over the underlying oracle\n    IPayoffProvider public payoff;\n\n    /// @dev Beneficiary of the market, receives donations\n    address public beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address public coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev The global pending versions for each id\n    mapping(uint256 => PositionStorageGlobal) private _pendingPosition;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev The local pending versions for each id for each account\n    mapping(address => mapping(uint256 => PositionStorageLocal)) private _pendingPositions;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __UReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n        payoff = definition_.payoff;\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n        _settle(context, account);\n        _update(context, account, newMaker, newLong, newShort, collateral, protect);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates the beneficiary of the market\n    /// @param newBeneficiary The new beneficiary address\n    function updateBeneficiary(address newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n    }\n\n    /// @notice Updates the coordinator of the market\n    /// @param newCoordinator The new coordinator address\n    function updateCoordinator(address newCoordinator) external onlyOwner {\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n    }\n\n    /// @notice Updates the parameter set of the market\n    /// @param newParameter The new parameter set\n    function updateParameter(MarketParameter memory newParameter) external onlyOwner {\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter(), reward);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Updates the reward token of the market\n    /// @param newReward The new reward token\n    function updateReward(Token18 newReward) public onlyOwner {\n        if (!reward.eq(Token18Lib.ZERO)) revert MarketRewardAlreadySetError();\n        if (newReward.eq(token)) revert MarketInvalidRewardError();\n\n        reward = newReward;\n        emit RewardUpdated(newReward);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, and donation\n    function claimFee() external {\n        Global memory newGlobal = _global.read();\n\n        if (_claimFee(address(factory()), newGlobal.protocolFee)) newGlobal.protocolFee = UFixed6Lib.ZERO;\n        if (_claimFee(address(IMarketFactory(address(factory())).oracleFactory()), newGlobal.oracleFee))\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        if (_claimFee(coordinator, newGlobal.riskFee)) newGlobal.riskFee = UFixed6Lib.ZERO;\n        if (_claimFee(beneficiary, newGlobal.donation)) newGlobal.donation = UFixed6Lib.ZERO;\n\n        _global.store(newGlobal);\n    }\n\n    /// @notice Helper function to handle a singular fee claim\n    /// @param receiver The address to receive the fee\n    /// @param fee The amount of the fee to claim\n    function _claimFee(address receiver, UFixed6 fee) private returns (bool) {\n        if (msg.sender != receiver) return false;\n\n        token.push(receiver, UFixed18Lib.from(fee));\n        emit FeeClaimed(receiver, fee);\n        return true;\n    }\n\n    /// @notice Claims any available reward that the sender has accrued\n    function claimReward() external {\n        Local memory newLocal = _locals[msg.sender].read();\n\n        reward.push(msg.sender, UFixed18Lib.from(newLocal.reward));\n        emit RewardClaimed(msg.sender, newLocal.reward);\n\n        newLocal.reward = UFixed6Lib.ZERO;\n        _locals[msg.sender].store(newLocal);\n    }\n\n    /// @notice Returns the current parameter set\n    function parameter() external view returns (MarketParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the current risk parameter set\n    function riskParameter() external view returns (RiskParameter memory) {\n        return _riskParameter.read();\n    }\n\n    /// @notice Returns the current global position\n    function position() external view returns (Position memory) {\n        return _position.read();\n    }\n\n    /// @notice Returns the current local position for the account\n    /// @param account The account to query\n    function positions(address account) external view returns (Position memory) {\n        return _positions[account].read();\n    }\n\n    /// @notice Returns the current global state\n    function global() external view returns (Global memory) {\n        return _global.read();\n    }\n\n    /// @notice Returns the historical version snapshot at the given timestamp\n    /// @param timestamp The timestamp to query\n    function versions(uint256 timestamp) external view returns (Version memory) {\n        return _versions[timestamp].read();\n    }\n\n    /// @notice Returns the local state for the given account\n    /// @param account The account to query\n    function locals(address account) external view returns (Local memory) {\n        return _locals[account].read();\n    }\n\n    /// @notice Returns the global pending position for the given id\n    /// @param id The id to query\n    function pendingPosition(uint256 id) external view returns (Position memory) {\n        return _pendingPosition[id].read();\n    }\n\n    /// @notice Returns the local pending position for the given account and id\n    /// @param account The account to query\n    /// @param id The id to query\n    function pendingPositions(address account, uint256 id) external view returns (Position memory) {\n        return _pendingPositions[account][id].read();\n    }\n\n    /// @notice Loads the current position context for the given account\n    /// @param context The context to load to\n    /// @param account The account to query\n    function _loadCurrentPositionContext(\n        Context memory context,\n        address account\n    ) private view returns (PositionContext memory positionContext) {\n        positionContext.global = _pendingPosition[context.global.currentId].read();\n        positionContext.local = _pendingPositions[account][context.local.currentId].read();\n        if (context.global.currentId == context.global.latestId)\n            positionContext.global.invalidate(context.latestPosition.global);\n        if (context.local.currentId == context.local.latestId)\n            positionContext.local.invalidate(context.latestPosition.local);\n    }\n\n    /// @notice Updates the current position\n    /// @param context The context to use\n    /// @param account The account to update\n    /// @param newMaker The new maker position size\n    /// @param newLong The new long position size\n    /// @param newShort The new short position size\n    /// @param collateral The change in collateral\n    /// @param protect Whether to protect the position for liquidation\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) private {\n        // read\n        context.currentPosition = _loadCurrentPositionContext(context, account);\n\n        // magic values\n        if (collateral.eq(Fixed6Lib.MIN)) collateral = context.local.collateral.mul(Fixed6Lib.NEG_ONE);\n        if (newMaker.eq(UFixed6Lib.MAX)) newMaker = context.currentPosition.local.maker;\n        if (newLong.eq(UFixed6Lib.MAX)) newLong = context.currentPosition.local.long;\n        if (newShort.eq(UFixed6Lib.MAX)) newShort = context.currentPosition.local.short;\n\n        // advance to next id if applicable\n        if (context.currentTimestamp > context.currentPosition.local.timestamp) {\n            context.local.currentId++;\n            context.currentPosition.local.prepare();\n        }\n        if (context.currentTimestamp > context.currentPosition.global.timestamp) {\n            context.global.currentId++;\n            context.currentPosition.global.prepare();\n        }\n\n        // update position\n        Order memory newOrder =\n            context.currentPosition.local.update(context.currentTimestamp, newMaker, newLong, newShort);\n        context.currentPosition.global.update(context.currentTimestamp, newOrder, context.riskParameter);\n\n        // update fee\n        newOrder.registerFee(context.latestVersion, context.marketParameter, context.riskParameter);\n        context.currentPosition.local.registerFee(newOrder);\n        context.currentPosition.global.registerFee(newOrder);\n\n        // update collateral\n        context.local.update(collateral);\n        context.currentPosition.local.update(collateral);\n\n        // protect account\n        bool protected = context.local.protect(context.latestPosition.local, context.currentTimestamp, protect);\n\n        // request version\n        if (!newOrder.isEmpty()) oracle.request(account);\n\n        // after\n        _invariant(context, account, newOrder, collateral, protected);\n\n        // store\n        _pendingPosition[context.global.currentId].store(context.currentPosition.global);\n        _pendingPositions[account][context.local.currentId].store(context.currentPosition.local);\n\n        // fund\n        if (collateral.sign() == 1) token.pull(msg.sender, UFixed18Lib.from(collateral.abs()));\n        if (collateral.sign() == -1) token.push(msg.sender, UFixed18Lib.from(collateral.abs()));\n\n        // events\n        emit Updated(account, context.currentTimestamp, newMaker, newLong, newShort, collateral, protect);\n    }\n\n    function _loadContext(address account) private view returns (Context memory context) {\n        // parameters\n        context.protocolParameter = IMarketFactory(address(factory())).parameter();\n        context.marketParameter = _parameter.read();\n        context.riskParameter = _riskParameter.read();\n\n        // state\n        context.global = _global.read();\n        context.local = _locals[account].read();\n\n        // oracle\n        (context.latestVersion, context.currentTimestamp) = _oracleVersion();\n        context.positionVersion = _oracleVersionAtPosition(context, _position.read());\n    }\n\n    /// @notice Stores the given context\n    /// @param context The context to store\n    /// @param account The account to store for\n    function _saveContext(Context memory context, address account) private {\n        _global.store(context.global);\n        _locals[account].store(context.local);\n    }\n\n    /// @notice Settles the account position up to the latest version\n    /// @param context The context to use\n    /// @param account The account to settle\n    function _settle(Context memory context, address account) private {\n        context.latestPosition.global = _position.read();\n        context.latestPosition.local = _positions[account].read();\n\n        Position memory nextPosition;\n\n        // settle\n        while (\n            context.global.currentId != context.global.latestId &&\n            (nextPosition = _pendingPosition[context.global.latestId + 1].read()).ready(context.latestVersion)\n        ) _processPositionGlobal(context, context.global.latestId + 1, nextPosition);\n\n        while (\n            context.local.currentId != context.local.latestId &&\n            (nextPosition = _pendingPositions[account][context.local.latestId + 1].read())\n                .ready(context.latestVersion)\n        ) {\n            Fixed6 previousDelta = _pendingPositions[account][context.local.latestId].read().delta;\n            _processPositionLocal(context, account, context.local.latestId + 1, nextPosition);\n            _checkpointCollateral(context, account, previousDelta, nextPosition);\n        }\n\n        // sync\n        if (context.latestVersion.timestamp > context.latestPosition.global.timestamp) {\n            nextPosition = _pendingPosition[context.global.latestId].read();\n            nextPosition.sync(context.latestVersion);\n            _processPositionGlobal(context, context.global.latestId, nextPosition);\n        }\n\n        if (context.latestVersion.timestamp > context.latestPosition.local.timestamp) {\n            nextPosition = _pendingPositions[account][context.local.latestId].read();\n            nextPosition.sync(context.latestVersion);\n            _processPositionLocal(context, account, context.local.latestId, nextPosition);\n        }\n\n        _position.store(context.latestPosition.global);\n        _positions[account].store(context.latestPosition.local);\n    }\n\n    /// @notice Places a collateral checkpoint for the account on the given pending position\n    /// @param context The context to use\n    /// @param account The account to checkpoint for\n    /// @param previousDelta The previous pending position's delta value\n    /// @param nextPosition The next pending position\n    function _checkpointCollateral(\n        Context memory context,\n        address account,\n        Fixed6 previousDelta,\n        Position memory nextPosition\n    ) private {\n        Position memory latestAccountPosition = _pendingPositions[account][context.local.latestId].read();\n        Position memory currentAccountPosition = _pendingPositions[account][context.local.currentId].read();\n        latestAccountPosition.collateral = context.local.collateral\n            .sub(currentAccountPosition.delta.sub(previousDelta))         // deposits happen after snapshot point\n            .add(Fixed6Lib.from(nextPosition.fee))                        // position fee happens after snapshot point\n            .add(Fixed6Lib.from(nextPosition.keeper));                    // keeper fee happens after snapshot point\n        _pendingPositions[account][context.local.latestId].store(latestAccountPosition);\n    }\n\n    /// @notice Processes the given global pending position into the latest position\n    /// @param context The context to use\n    /// @param newPositionId The id of the pending position to process\n    /// @param newPosition The pending position to process\n    function _processPositionGlobal(Context memory context, uint256 newPositionId, Position memory newPosition) private {\n        Version memory version = _versions[context.latestPosition.global.timestamp].read();\n        OracleVersion memory oracleVersion = _oracleVersionAtPosition(context, newPosition);\n        if (!oracleVersion.valid) newPosition.invalidate(context.latestPosition.global);\n\n        (uint256 fromTimestamp, uint256 fromId) = (context.latestPosition.global.timestamp, context.global.latestId);\n        (VersionAccumulationResult memory accumulationResult, UFixed6 accumulatedFee) = version.accumulate(\n            context.global,\n            context.latestPosition.global,\n            newPosition,\n            context.positionVersion,\n            oracleVersion,\n            context.marketParameter,\n            context.riskParameter\n        );\n        context.latestPosition.global.update(newPosition);\n        context.global.update(newPositionId, oracleVersion.price);\n        context.global.incrementFees(\n            accumulatedFee,\n            newPosition.keeper,\n            context.marketParameter,\n            context.protocolParameter\n        );\n        context.positionVersion = oracleVersion;\n        _versions[newPosition.timestamp].store(version);\n\n        // events\n        emit PositionProcessed(\n            fromTimestamp,\n            newPosition.timestamp,\n            fromId,\n            accumulationResult\n        );\n    }\n\n    /// @notice Processes the given local pending position into the latest position\n    /// @param context The context to use\n    /// @param account The account to process for\n    /// @param newPositionId The id of the pending position to process\n    /// @param newPosition The pending position to process\n    function _processPositionLocal(\n        Context memory context,\n        address account,\n        uint256 newPositionId,\n        Position memory newPosition\n    ) private {\n        Version memory version = _versions[newPosition.timestamp].read();\n        if (!version.valid) newPosition.invalidate(context.latestPosition.local);\n\n        (uint256 fromTimestamp, uint256 fromId) = (context.latestPosition.local.timestamp, context.local.latestId);\n        LocalAccumulationResult memory accumulationResult = context.local.accumulate(\n            newPositionId,\n            context.latestPosition.local,\n            newPosition,\n            _versions[context.latestPosition.local.timestamp].read(),\n            version\n        );\n        context.latestPosition.local.update(newPosition);\n\n        // events\n        emit AccountPositionProcessed(\n            account,\n            fromTimestamp,\n            newPosition.timestamp,\n            fromId,\n            accumulationResult\n        );\n    }\n\n    /// @notice Verifies the invariant of the market\n    /// @param context The context to use\n    /// @param account The account to verify the invariant for\n    /// @param newOrder The order to verify the invariant for\n    /// @param collateral The collateral change to verify the invariant for\n    /// @param protected Whether the new position is protected\n    function _invariant(\n        Context memory context,\n        address account,\n        Order memory newOrder,\n        Fixed6 collateral,\n        bool protected\n    ) private view {\n        // load all pending state\n        (Position[] memory pendingLocalPositions, Fixed6 collateralAfterFees) = _loadPendingPositions(context, account);\n\n        if (protected && (\n            !context.currentPosition.local.magnitude().isZero() ||\n            context.latestPosition.local.collateralized(\n                context.latestVersion,\n                context.riskParameter,\n                collateralAfterFees.sub(collateral)\n            ) ||\n            collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context)))\n        )) revert MarketInvalidProtectionError();\n\n        if (context.currentTimestamp - context.latestVersion.timestamp >= context.riskParameter.staleAfter)\n            revert MarketStalePriceError();\n\n        if (context.marketParameter.closed && newOrder.increasesPosition())\n            revert MarketClosedError();\n\n        if (context.currentPosition.global.maker.gt(context.riskParameter.makerLimit))\n            revert MarketMakerOverLimitError();\n\n        if (!context.currentPosition.local.singleSided())\n            revert MarketNotSingleSidedError();\n\n        if (protected) return; // The following invariants do not apply to protected position updates (liquidations)\n\n        if (\n            msg.sender != account &&                                                                        // sender is operating on own account\n            !IMarketFactory(address(factory())).operators(account, msg.sender) &&                           // sender is operating on own account\n            !(newOrder.isEmpty() && collateralAfterFees.isZero() && collateral.gt(Fixed6Lib.ZERO))     // sender is repaying shortfall for this account\n        ) revert MarketOperatorNotAllowedError();\n\n        if (\n            context.global.currentId > context.global.latestId + context.marketParameter.maxPendingGlobal ||\n            context.local.currentId > context.local.latestId + context.marketParameter.maxPendingLocal\n        ) revert MarketExceedsPendingIdLimitError();\n\n        if (\n            !context.latestPosition.local.collateralized(context.latestVersion, context.riskParameter, collateralAfterFees)\n        ) revert MarketInsufficientCollateralizationError();\n\n        for (uint256 i; i < pendingLocalPositions.length; i++)\n            if (\n                !pendingLocalPositions[i].collateralized(context.latestVersion, context.riskParameter, collateralAfterFees)\n            ) revert MarketInsufficientCollateralizationError();\n\n        if (\n            (context.local.protection > context.latestPosition.local.timestamp) &&\n            !newOrder.isEmpty()\n        ) revert MarketProtectedError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            newOrder.efficiency.lt(Fixed6Lib.ZERO) &&\n            context.currentPosition.global.efficiency().lt(context.riskParameter.efficiencyLimit)\n        ) revert MarketEfficiencyUnderLimitError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            context.currentPosition.global.socialized() &&\n            newOrder.decreasesLiquidity()\n        ) revert MarketInsufficientLiquidityError();\n\n        if (collateral.lt(Fixed6Lib.ZERO) && collateralAfterFees.lt(Fixed6Lib.ZERO))\n            revert MarketInsufficientCollateralError();\n    }\n\n    /// @notice Loads data about all pending positions for the invariant check\n    /// @param context The context to use\n    /// @param account The account to load the pending positions for\n    /// @return pendingLocalPositions All pending positions for the account\n    /// @return collateralAfterFees The account's collateral after fees\n    function _loadPendingPositions(\n        Context memory context,\n        address account\n    ) private view returns (Position[] memory pendingLocalPositions, Fixed6 collateralAfterFees) {\n        collateralAfterFees = context.local.collateral;\n        pendingLocalPositions = new Position[](\n            context.local.currentId - Math.min(context.local.latestId, context.local.currentId)\n        );\n        for (uint256 i; i < pendingLocalPositions.length - 1; i++) {\n            pendingLocalPositions[i] = _pendingPositions[account][context.local.latestId + 1 + i].read();\n            collateralAfterFees = collateralAfterFees\n                .sub(Fixed6Lib.from(pendingLocalPositions[i].fee))\n                .sub(Fixed6Lib.from(pendingLocalPositions[i].keeper));\n        }\n        pendingLocalPositions[pendingLocalPositions.length - 1] = context.currentPosition.local; // current local position hasn't been stored yet\n    }\n\n    /// @notice Computes the liquidation fee for the current latest local position\n    /// @param context The context to use\n    /// @return The liquidation fee\n    function _liquidationFee(Context memory context) private view returns (UFixed6) {\n        return context.latestPosition.local\n            .liquidationFee(context.latestVersion, context.riskParameter)\n            .min(UFixed6Lib.from(token.balanceOf()));\n    }\n\n    /// @notice Computes the current oracle status with the market's payoff\n    /// @return latestVersion The latest oracle version with payoff applied\n    /// @return currentTimestamp The current oracle timestamp\n    function _oracleVersion() private view returns (OracleVersion memory latestVersion, uint256 currentTimestamp) {\n        (latestVersion, currentTimestamp) = oracle.status();\n        _transform(latestVersion);\n    }\n\n    /// @notice Computes the latest oracle version at a given timestamp with the market's payoff\n    /// @param timestamp The timestamp to use\n    /// @return oracleVersion The oracle version at the given timestamp with payoff applied\n    function _oracleVersionAt(uint256 timestamp) private view returns (OracleVersion memory oracleVersion) {\n        oracleVersion = oracle.at(timestamp);\n        _transform(oracleVersion);\n    }\n\n    /// @notice Computes the latest oracle version at a given position with the market's payoff\n    /// @dev applies the latest valid price when the version at position is invalid\n    /// @param context The context to use\n    /// @param toPosition The position to use\n    /// @return oracleVersion The oracle version at the given position\n    function _oracleVersionAtPosition(\n        Context memory context,\n        Position memory toPosition\n    ) private view returns (OracleVersion memory oracleVersion) {\n        oracleVersion = _oracleVersionAt(toPosition.timestamp);\n        if (!oracleVersion.valid) oracleVersion.price = context.global.latestPrice;\n    }\n\n    /// @notice Applies the market's payoff to an oracle version\n    /// @param oracleVersion The oracle version to transform\n    function _transform(OracleVersion memory oracleVersion) private view {\n        if (address(payoff) != address(0)) oracleVersion.price = payoff.payoff(oracleVersion.price);\n    }\n\n    /// @notice Only the coordinator or the owner can call\n    modifier onlyCoordinator {\n        if (msg.sender != coordinator && msg.sender != factory().owner()) revert MarketNotCoordinatorError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev The token that incentive rewards are paid in\n    Token18 public reward;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev The payoff function over the underlying oracle\n    IPayoffProvider public payoff;\n\n    /// @dev Beneficiary of the market, receives donations\n    address public beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address public coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev The global pending versions for each id\n    mapping(uint256 => PositionStorageGlobal) private _pendingPosition;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev The local pending versions for each id for each account\n    mapping(address => mapping(uint256 => PositionStorageLocal)) private _pendingPositions;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __UReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n        payoff = definition_.payoff;\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n        _settle(context, account);\n        _update(context, account, newMaker, newLong, newShort, collateral, protect);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates the beneficiary of the market\n    /// @param newBeneficiary The new beneficiary address\n    function updateBeneficiary(address newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n    }\n\n    /// @notice Updates the coordinator of the market\n    /// @param newCoordinator The new coordinator address\n    function updateCoordinator(address newCoordinator) external onlyOwner {\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n    }\n\n    /// @notice Updates the parameter set of the market\n    /// @param newParameter The new parameter set\n    function updateParameter(MarketParameter memory newParameter) external onlyOwner {\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter(), reward);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Updates the reward token of the market\n    /// @param newReward The new reward token\n    function updateReward(Token18 newReward) public onlyOwner {\n        if (!reward.eq(Token18Lib.ZERO)) revert MarketRewardAlreadySetError();\n        if (newReward.eq(token)) revert MarketInvalidRewardError();\n\n        reward = newReward;\n        emit RewardUpdated(newReward);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, and donation\n    function claimFee() external {\n        Global memory newGlobal = _global.read();\n\n        if (_claimFee(address(factory()), newGlobal.protocolFee)) newGlobal.protocolFee = UFixed6Lib.ZERO;\n        if (_claimFee(address(IMarketFactory(address(factory())).oracleFactory()), newGlobal.oracleFee))\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        if (_claimFee(coordinator, newGlobal.riskFee)) newGlobal.riskFee = UFixed6Lib.ZERO;\n        if (_claimFee(beneficiary, newGlobal.donat"
    }
  ]
}