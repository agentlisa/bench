{
  "Title": "M-7: Vault multihop swaps for any token pair will fail in one direction",
  "Content": "# Issue M-7: Vault multihop swaps for any token pair will fail in one direction \n\nSource: https://github.com/sherlock-audit/2023-06-unstoppable-judging/issues/108 \n\n## Found by \n0x00ffDa\n## Summary\nThe [`Unstoppable SwapRouter's add_path()`](https://github.com/Unstoppable-DeFi/unstoppable-dex-audit/blob/4153c3e67ccc080032ba0bbaffd9a0c56a573070/contracts/margin-dex/SwapRouter.vy#L130-L134) function stores the same swap path for swapping from \"token1\" to \"token2\" and from \"token2\" to \"token1\". If the swap path starts with the token1 address, swaps from token2 to token1 will fail, and vice versa.\n\n## Vulnerability Detail\nThe administrator must call `SwapRouter` `add_path()` to add support for swaps that use multiple Uniswap pools (multihop swaps). The path provided is a sequence of token addresses and pool fee amounts. The path is stored in the `self.paths` hashmap using the provided `token1` and `token2` addresses as the keys. The path is stored twice, once for each ordering of those keys such that the stored path can be accessed easily without sorting the keys. \n\n[When a path stored in the Unstoppable `Vault` is used for a swap](https://github.com/Unstoppable-DeFi/unstoppable-dex-audit/blob/4153c3e67ccc080032ba0bbaffd9a0c56a573070/contracts/margin-dex/SwapRouter.vy#L108), it is obtained by indexing the hashmap first with the address of the input token for the swap:\n```javascript\n    path: Bytes[66] = self.paths[_token_in][_token_out]\n```\nBut, because of the logic in `add_path()` described above, the first address in the obtained path could be either `_token_in` or `_token_out`. In the case that it is `_token_out`, the swap will fail as described below. \n\nThe stored path is passed along for use by the Uniswap V3 `SwapRouter` which assumes that the [first 2 addresses in the path define the first pool to use](https://github.com/Uniswap/v3-periphery/blob/6cce88e63e176af1ddb6cc56e029110289622317/contracts/SwapRouter.sol#L150). The `SwapRouter` uses [`Path.decodeFirstPool()` to extract the first address](https://github.com/Uniswap/v3-periphery/blob/6cce88e63e176af1ddb6cc56e029110289622317/contracts/libraries/Path.sol#L51), and it is the first return value thus interpreted as tokenIn for the swap:\n```javascript\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n```\nIn the case that the first token address in the path is actually the intended output token for this swap, the Uniswap V3 `SwapRouter` will attempt to transfer the input amount of the output token and fail because it does not have any allowance to access the Unstoppable `SwapRouter` contract's balance of the output token.\n\n## Impact\nThe planned margin trading functionality will not work as intended when multihop swaps are required between the margin/debt token and the position token. Since such swaps will work in one direction but fail in the other, traders would either be unable to obtain the desired position or, in the worst case, be unable to exit the position and recover their margin funds. Note that in the latter case, liquidators will also be unable to force exit of over-leveraged positions.\n\n## Code Snippet\nSwapRouter.add_path() at https://github.com/Unstoppable-DeFi/unstoppable-dex-audit/blob/4153c3e67ccc080032ba0bbaffd9a0c56a573070/contracts/margin-dex/SwapRouter.vy#L130-L134\n```javascript\n@external\ndef add_path(_token1: address, _token2: address, _path: Bytes[66]):\n    assert msg.sender == self.admin, \"unauthorized\"\n    self.paths[_token1][_token2] = _path\n    self.paths[_token2][_token1] = _path\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nModify the `SwapRouter` `add_path()` function:  remove the `_token1` and `_token2` parameters and instead infer them from the contents of `_path`. Make a reversed copy of the `_path` and store both versions in the paths hashmap with key ordering that matches the path being stored. Add Vault tests for multihop swaps.\n\n\n\n## Discussion\n\n**141345**\n\nThis one will inevitably result in user loss, high severity might be more appropriate.\n\n**twicek**\n\nEscalate for 10 USDC.\nAssuming this is true: `transfer the input amount of the output token`. There is no allowance given for the output token, it will always revert as said in the report.\nIf someone can find an example where it leads to loss of funds I agree that it should be high severity, otherwise it should be medium severity.\n\n**sherlock-admin2**\n\n > Escalate for 10 USDC.\n> Assuming this is true: `transfer the input amount of the output token`. There is no allowance given for the output token, it will always revert as said in the report.\n> If someone can find an example where it leads to loss of funds I agree that it should be high severity, otherwise it should be medium severity.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**141345**\n\nRecommendation: \nchange the original judging, to medium\n\n> Escalate for 10 USDC. Assuming this is true: `transfer the input amount of the output token`. There is no allowance given for the output token, it will always revert as said in the report. If someone can find an example where it leads to loss of funds I agree that it should be high severity, otherwise it should be medium severity.\n\nThe mentioned case is only 1 scenario. \nThe possible impactful scenario is, token1 is transferred in. But when close the position, the reverse process will revert, causing user fund locked.\n\nThen the admin can use add_path to rescue the funds by changing the path.\n\nBased on the above, I think medium is appropriate.\n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/unstoppable-dex-audit/pull/12\n\n**hrishibhat**\n\nResult:\nMedium\nUnique  \nConsidering this a valid medium based on the above comments  \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [twicek](https://github.com/sherlock-audit/2023-06-unstoppable-judging/issues/108/#issuecomment-1643777317): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/95",
  "Code": [
    {
      "filename": "contracts/margin-dex/SwapRouter.vy",
      "content": "# @version ^0.3.7\n\nfrom vyper.interfaces import ERC20\n\n# struct ExactInputSingleParams {\n#         address tokenIn;\n#         address tokenOut;\n#         uint24 fee;\n#         address recipient;\n#         uint256 deadline;\n#         uint256 amountIn;\n#         uint256 amountOutMinimum;\n#         uint160 sqrtPriceLimitX96;\n#     }\nstruct ExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    fee: uint24\n    recipient: address\n    deadline: uint256\n    amountIn: uint256\n    amountOutMinimum: uint256\n    sqrtPriceLimitX96: uint160\n\n# struct ExactInputParams {\n#     bytes path;\n#     address recipient;\n#     uint256 deadline;\n#     uint256 amountIn;\n#     uint256 amountOutMinimum;\n# }\nstruct ExactInputParams:\n    path: Bytes[66]\n    recipient: address\n    deadline: uint256\n    amountIn: uint256\n    amountOutMinimum: uint256\n\n\n# function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\ninterface UniswapV3SwapRouter:\n    def exactInputSingle(_params: ExactInputSingleParams) -> uint256: payable\n    def exactInput(_params: ExactInputParams) -> uint256: payable\n\nUNISWAP_ROUTER: constant(address) = 0xE592427A0AEce92De3Edee1F18E0157C05861564\n\n# token_in -> token_out -> fee\ndirect_route: public(HashMap[address, HashMap[address, uint24]])\npaths: public(HashMap[address, HashMap[address, Bytes[66]]])\n\nadmin: public(address)\n\n\n@nonpayable\n@external\ndef __init__():\n    self.admin = msg.sender\n\n\n@external\ndef swap(\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    ERC20(_token_in).transferFrom(msg.sender, self, _amount_in)\n    ERC20(_token_in).approve(UNISWAP_ROUTER, _amount_in)\n\n    if self.direct_route[_token_in][_token_out] != 0:\n        return self._direct_swap(_token_in, _token_out, _amount_in, _min_amount_out)\n    else:\n        return self._multi_hop_swap(_token_in, _token_out, _amount_in, _min_amount_out)\n\n\n@internal\ndef _direct_swap(\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    fee: uint24 = self.direct_route[_token_in][_token_out]\n    assert fee != 0, \"no direct route\"\n\n    params: ExactInputSingleParams = ExactInputSingleParams(\n        {\n            tokenIn: _token_in,\n            tokenOut: _token_out,\n            fee: fee,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: _amount_in,\n            amountOutMinimum: _min_amount_out,\n            sqrtPriceLimitX96: 0,\n        }\n    )\n    return UniswapV3SwapRouter(UNISWAP_ROUTER).exactInputSingle(params)\n\n\n@internal\ndef _multi_hop_swap(\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    path: Bytes[66] = self.paths[_token_in][_token_out]\n    assert path != empty(Bytes[66]), \"no path configured\"\n\n    uni_params: ExactInputParams = ExactInputParams(\n        {\n            path: path,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: _amount_in,\n            amountOutMinimum: _min_amount_out,\n        }\n    )\n    return UniswapV3SwapRouter(UNISWAP_ROUTER).exactInput(uni_params)\n\n\n@external\ndef add_direct_route(_token1: address, _token2: address, _fee: uint24):\n    assert msg.sender == self.admin, \"unauthorized\"\n    self.direct_route[_token1][_token2] = _fee\n    self.direct_route[_token2][_token1] = _fee\n\n\n@external\ndef add_path(_token1: address, _token2: address, _path: Bytes[66]):\n    assert msg.sender == self.admin, \"unauthorized\"\n    self.paths[_token1][_token2] = _path\n    self.paths[_token2][_token1] = _path"
    },
    {
      "filename": "contracts/margin-dex/SwapRouter.vy",
      "content": "# @version ^0.3.7\n\nfrom vyper.interfaces import ERC20\n\n# struct ExactInputSingleParams {\n#         address tokenIn;\n#         address tokenOut;\n#         uint24 fee;\n#         address recipient;\n#         uint256 deadline;\n#         uint256 amountIn;\n#         uint256 amountOutMinimum;\n#         uint160 sqrtPriceLimitX96;\n#     }\nstruct ExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    fee: uint24\n    recipient: address\n    deadline: uint256\n    amountIn: uint256\n    amountOutMinimum: uint256\n    sqrtPriceLimitX96: uint160\n\n# struct ExactInputParams {\n#     bytes path;\n#     address recipient;\n#     uint256 deadline;\n#     uint256 amountIn;\n#     uint256 amountOutMinimum;\n# }\nstruct ExactInputParams:\n    path: Bytes[66]\n    recipient: address\n    deadline: uint256\n    amountIn: uint256\n    amountOutMinimum: uint256\n\n\n# function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\ninterface UniswapV3SwapRouter:\n    def exactInputSingle(_params: ExactInputSingleParams) -> uint256: payable\n    def exactInput(_params: ExactInputParams) -> uint256: payable\n\nUNISWAP_ROUTER: constant(address) = 0xE592427A0AEce92De3Edee1F18E0157C05861564\n\n# token_in -> token_out -> fee\ndirect_route: public(HashMap[address, HashMap[address, uint24]])\npaths: public(HashMap[address, HashMap[address, Bytes[66]]])\n\nadmin: public(address)\n\n\n@nonpayable\n@external\ndef __init__():\n    self.admin = msg.sender\n\n\n@external\ndef swap(\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    ERC20(_token_in).transferFrom(msg.sender, self, _amount_in)\n    ERC20(_token_in).approve(UNISWAP_ROUTER, _amount_in)\n\n    if self.direct_route[_token_in][_token_out] != 0:\n        return self._direct_swap(_token_in, _token_out, _amount_in, _min_amount_out)\n    else:\n        return self._multi_hop_swap(_token_in, _token_out, _amount_in, _min_amount_out)\n\n\n@internal\ndef _direct_swap(\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    fee: uint24 = self.direct_route[_token_in][_token_out]\n    assert fee != 0, \"no direct route\"\n\n    params: ExactInputSingleParams = ExactInputSingleParams(\n        {\n            tokenIn: _token_in,\n            tokenOut: _token_out,\n            fee: fee,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: _amount_in,\n            amountOutMinimum: _min_amount_out,\n            sqrtPriceLimitX96: 0,\n        }\n    )\n    return UniswapV3SwapRouter(UNISWAP_ROUTER).exactInputSingle(params)\n\n\n@internal\ndef _multi_hop_swap(\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    path: Bytes[66] = self.paths[_token_in][_token_out]\n    assert path != empty(Bytes[66]), \"no path configured\"\n\n    uni_params: ExactInputParams = ExactInputParams(\n        {\n            path: path,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: _amount_in,\n            amountOutMinimum: _min_amount_out,\n        }\n    )\n    return UniswapV3SwapRouter(UNISWAP_ROUTER).exactInput(uni_params)\n\n\n@external\ndef add_direct_route(_token1: address, _token2: address, _fee: uint24):\n    assert msg.sender == self.admin, \"unauthorized\"\n    self.direct_route[_token1][_token2] = _fee\n    self.direct_route[_token2][_token1] = _fee\n\n\n@external\ndef add_path(_token1: address, _token2: address, _path: Bytes[66]):\n    assert msg.sender == self.admin, \"unauthorized\"\n    self.paths[_token1][_token2] = _path\n    self.paths[_token2][_token1] = _path"
    },
    {
      "filename": "contracts/SwapRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/libraries/SafeCast.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\nimport './interfaces/ISwapRouter.sol';\nimport './base/PeripheryImmutableState.sol';\nimport './base/PeripheryValidation.sol';\nimport './base/PeripheryPaymentsWithFee.sol';\nimport './base/Multicall.sol';\nimport './base/SelfPermit.sol';\nimport './libraries/Path.sol';\nimport './libraries/PoolAddress.sol';\nimport './libraries/CallbackValidation.sol';\nimport './interfaces/external/IWETH9.sol';\n\n/// @title Uniswap V3 Swap Router\n/// @notice Router for stateless execution of swaps against Uniswap V3\ncontract SwapRouter is\n    ISwapRouter,\n    PeripheryImmutableState,\n    PeripheryValidation,\n    PeripheryPaymentsWithFee,\n    Multicall,\n    SelfPermit\n{\n    using Path for bytes;\n    using SafeCast for uint256;\n\n    /// @dev Used as the placeholder value for amountInCached, because the computed amount in for an exact output swap\n    /// can never actually be this value\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\n\n    /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.\n    uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;\n\n    constructor(address _factory, address _WETH9) PeripheryImmutableState(_factory, _WETH9) {}\n\n    /// @dev Returns the pool for the given token pair and fee. The pool contract may or may not exist.\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) private view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(factory, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    /// @inheritdoc IUniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        CallbackValidation.verifyCallback(factory, tokenIn, tokenOut, fee);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\n            } else {\n                amountInCached = amountToPay;\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    /// @dev Performs a single exact input swap\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0, int256 amount1) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                amountIn.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n\n    /// @inheritdoc ISwapRouter\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        override\n        checkDeadline(params.deadline)\n        returns (uint256 amountOut)\n    {\n        amountOut = exactInputInternal(\n            params.amountIn,\n            params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\n        );\n        require(amountOut >= params.amountOutMinimum, 'Too little received');\n    }\n\n    /// @inheritdoc ISwapRouter\n    function exactInput(ExactInputParams memory params)\n        external\n        payable\n        override\n        checkDeadline(params.deadline)\n        returns (uint256 amountOut)\n    {\n        address payer = msg.sender; // msg.sender pays for the first hop\n\n        while (true) {\n            bool hasMultiplePools = params.path.hasMultiplePools();\n\n            // the outputs of prior swaps become the inputs to subsequent ones\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                hasMultiplePools ? address(this) : params.recipient, // for intermediate swaps, this contract custodies\n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(), // only the first pool in the path is necessary\n                    payer: payer\n                })\n            );\n\n            // decide whether to continue or terminate\n            if (hasMultiplePools) {\n                payer = address(this); // at this point, the caller has paid\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, 'Too little received');\n    }\n\n    /// @dev Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        (int256 amount0Delta, int256 amount1Delta) =\n            getPool(tokenIn, tokenOut, fee).swap(\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it's technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n    /// @inheritdoc ISwapRouter\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        override\n        checkDeadline(params.deadline)\n        returns (uint256 amountIn)\n    {\n        // avoid an SLOAD by using the swap return data\n        amountIn = exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            params.sqrtPriceLimitX96,\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\n        );\n\n        require(amountIn <= params.amountInMaximum, 'Too much requested');\n        // has to be reset even though we don't use it in the single hop case\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\n    }\n\n    /// @inheritdoc ISwapRouter\n    function exactOutput(ExactOutputParams calldata params)\n        external\n        payable\n        override\n        checkDeadline(params.deadline)\n        returns (uint256 amountIn)\n    {\n        // it's okay that the payer is fixed to msg.sender here, as they're only paying for the \"final\" exact output\n        // swap, which happens first, and subsequent swaps are paid for within nested callback frames\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            0,\n            SwapCallbackData({path: params.path, payer: msg.sender})\n        );\n\n        amountIn = amountInCached;\n        require(amountIn <= params.amountInMaximum, 'Too much requested');\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\n    }\n}"
    },
    {
      "filename": "contracts/margin-dex/SwapRouter.vy",
      "content": "# @version ^0.3.7\n\nfrom vyper.interfaces import ERC20\n\n# struct ExactInputSingleParams {\n#         address tokenIn;\n#         address tokenOut;\n#         uint24 fee;\n#         address recipient;\n#         uint256 deadline;\n#         uint256 amountIn;\n#         uint256 amountOutMinimum;\n#         uint160 sqrtPriceLimitX96;\n#     }\nstruct ExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    fee: uint24\n    recipient: address\n    deadline: uint256\n    amountIn: uint256\n    amountOutMinimum: uint256\n    sqrtPriceLimitX96: uint160\n\n# struct ExactInputParams {\n#     bytes path;\n#     address recipient;\n#     uint256 deadline;\n#     uint256 amountIn;\n#     uint256 amountOutMinimum;\n# }\nstruct ExactInputParams:\n    path: Bytes[66]\n    recipient: address\n    deadline: uint256\n    amountIn: uint256\n    amountOutMinimum: uint256\n\n\n# function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\ninterface UniswapV3SwapRouter:\n    def exactInputSingle(_params: ExactInputSingleParams) -> uint256: payable\n    def exactInput(_params: ExactInputParams) -> uint256: payable\n\nUNISWAP_ROUTER: constant(address) = 0xE592427A0AEce92De3Edee1F18E0157C05861564\n\n# token_in -> token_out -> fee\ndirect_route: public(HashMap[address, HashMap[address, uint24]])\npaths: public(HashMap[address, HashMap[address, Bytes[66]]])\n\nadmin: public(address)\n\n\n@nonpayable\n@external\ndef __init__():\n    self.admin = msg.sender\n\n\n@external\ndef swap(\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    ERC20(_token_in).transferFrom(msg.sender, self, _amount_in)\n    ERC20(_token_in).approve(UNISWAP_ROUTER, _amount_in)\n\n    if self.direct_route[_token_in][_token_out] != 0:\n        return self._direct_swap(_token_in, _token_out, _amount_in, _min_amount_out)\n    else:\n        return self._multi_hop_swap(_token_in, _token_out, _amount_in, _min_amount_out)\n\n\n@internal\ndef _direct_swap(\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    fee: uint24 = self.direct_route[_token_in][_token_out]\n    assert fee != 0, \"no direct route\"\n\n    params: ExactInputSingleParams = ExactInputSingleParams(\n        {\n            tokenIn: _token_in,\n            tokenOut: _token_out,\n            fee: fee,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: _amount_in,\n            amountOutMinimum: _min_amount_out,\n            sqrtPriceLimitX96: 0,\n        }\n    )\n    return UniswapV3SwapRouter(UNISWAP_ROUTER).exactInputSingle(params)\n\n\n@internal\ndef _multi_hop_swap(\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    path: Bytes[66] = self.paths[_token_in][_token_out]\n    assert path != empty(Bytes[66]), \"no path configured\"\n\n    uni_params: ExactInputParams = ExactInputParams(\n        {\n            path: path,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: _amount_in,\n            amountOutMinimum: _min_amount_out,\n        }\n    )\n    return UniswapV3SwapRouter(UNISWAP_ROUTER).exactInput(uni_params)\n\n\n@external\ndef add_direct_route(_token1: address, _token2: address, _fee: uint24):\n    assert msg.sender == self.admin, \"unauthorized\"\n    self.direct_route[_token1][_token2] = _fee\n    self.direct_route[_token2][_token1] = _fee\n\n\n@external\ndef add_path(_token1: address, _token2: address, _path: Bytes[66]):\n    assert msg.sender == self.admin, \"unauthorized\"\n    self.paths[_token1][_token2] = _path\n    self.paths[_token2][_token1] = _path"
    }
  ]
}