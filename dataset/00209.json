{
  "Title": "M-15: DAO unable to withdraw their funds due to Convex admin action",
  "Content": "# Issue M-15: DAO unable to withdraw their funds due to Convex admin action \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/657 \n\n## Found by \nAllTooWell, Bauchibred, BiasedMerc, BoRonGod, KingNFT, ZanyBonzy, rbserver, saidam017\n## Summary\n\nConvex admin action can lead to the fund of Zivoe protocol and its users being stuck, resulting in DAO being unable to push/pull assets from convex_lockers.\n\n## Vulnerability Detail\n\nPer the contest page, the admins of the protocols that Zivoe integrates with are considered \"RESTRICTED\". This means that any issue related to Convexâ€˜s admin action that could negatively affect Zivoe protocol/users will be considered valid in this audit contest.\n\n> Q: Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\n> \n> RESTRICTED\n\nIn current `BaseRewardPool.sol` used by convex, admin can add infinite `extraRewards`:\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns(bool){\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0),\"!reward setting\");\n\n        extraRewards.push(_reward);\n        return true;\n    }\n\nBy setting a malicious token or add a lot of tokens, it is easy to completely forbid Zivoe DAO to `pullFromLocker`, since claimRewards() is forced to call:\n\n    function pullFromLocker(address asset, bytes calldata data) external override onlyOwner {\n        require(asset == convexPoolToken, \"OCY_Convex_C::pullFromLocker() asset != convexPoolToken\");\n        \n        claimRewards(false);\n        ...\n\n## Impact\n\nThe fund of Zivoe protocol and its users will be stuck, resulting in users being unable to withdraw their assets.\n\n## Code Snippet\n\nhttps://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L109\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the protocol team and its users are aware of the risks of such an event and develop a contingency plan to manage it.\n\n\n\n## Discussion\n\n**pseudonaut**\n\nI suppose valid, not of concern though\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> invalid, while admins are restricted, they are still not supposed to harm their protocol, just do normal reasonable admin actions. Adding so many rewards tokens will definitely break their protocol for all users, so this is invalid assumption.\n\n\n\n**RealLTDingZhen**\n\nescalate \n\nThis is a valid medium per external admin is restricted and sponsor confirms this.\n\nPlease refer to https://github.com/sherlock-audit/2024-01-napier-judging/issues/95 and https://github.com/sherlock-audit/2024-01-napier-judging/issues/108\n\n**sherlock-admin3**\n\n> escalate \n> \n> This is a valid medium per external admin is restricted and sponsor confirms this.\n> \n> Please refer to https://github.com/sherlock-audit/2024-01-napier-judging/issues/95 and https://github.com/sherlock-audit/2024-01-napier-judging/issues/108\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nEven if this happens, there is nothing that can be done about it, so this is purely informational issue. It won't affect the other protocol functionality since this is just a separate locker with funds locked in it. \nI believe this is similar to USDC blacklisting protocol address, so such actions should be invalid as there is nothing that can be done to fix it.\n\n**WangSecurity**\n\nI agree with both the Lead Judge and escalating Watson, but according to README and external admins being restricted, these reports indeed should be valid. But, I believe the most fair option is to duplicate this report with other issues where external admin's actions are leading to a harm of Zivoe with Medium severity, due to extremely low likelihood.\n\nThe reports it will be duplicated with are #672, #692 and #697. Planning to accept the escalation and duplicate these reports.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [RealLTDingZhen](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/657/#issuecomment-2105684521): accepted\n\n**panprog**\n\nThe following issues appear to be dups to this one according to the @WangSecurity criteria of \"external admin's actions are leading to a harm of Zivoe\": #130, #160, #249, #648, #662, #666, #667, #672, #677, #692, #697, #699, #701, #704\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "contracts/contracts/BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/MathUtil.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\n\n\ncontract BaseRewardPool {\n     using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) public {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns(bool){\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0),\"!reward setting\");\n\n        extraRewards.push(_reward);\n        return true;\n    }\n    function clearExtraRewards() external{\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return MathUtil.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(_amount > 0, 'RewardPool : Cannot stake 0');\n        \n        //also stake to linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        \n        return true;\n    }\n\n    function stakeAll() external returns(bool){\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount)\n        public\n        updateReward(_for)\n        returns(bool)\n    {\n        require(_amount > 0, 'RewardPool : Cannot stake 0');\n        \n        //also stake to linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n        \n        return true;\n    }\n\n\n    function withdraw(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(amount > 0, 'RewardPool : Cannot withdraw 0');\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n     \n        if(claim){\n            getReward(msg.sender,true);\n        }\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external{\n        withdraw(_balances[msg.sender],claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) public updateReward(msg.sender) returns(bool){\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n        \n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid,amount,msg.sender);\n        emit Withdrawn(msg.sender, amount);\n\n        //get rewards too\n        if(claim){\n            getReward(msg.sender,true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external{\n        withdrawAndUnwrap(_balances[msg.sender],claim);\n    }\n\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    function getReward() external returns(bool){\n        getReward(msg.sender,true);\n        return true;\n    }\n\n    function donate(uint256 _amount) external returns(bool){\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        queuedRewards = queuedRewards.add(_amount);\n    }\n\n    function queueNewRewards(uint256 _rewards) external returns(bool){\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if(queuedRatio < newRewardRatio){\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        }else{\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    }
  ]
}