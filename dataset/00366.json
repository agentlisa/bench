{
  "Title": "M-2: When the amout of token acquired by a flash loan exceeds the expected value, the callback function will fail.",
  "Content": "# Issue M-2: When the amout of token acquired by a flash loan exceeds the expected value, the callback function will fail. \n\nSource: https://github.com/sherlock-audit/2024-03-wagmileverage-v2-judging/issues/9 \n\n## Found by \nzraxx\n## Summary\n\nWhen the amout of token acquired by a flash loan exceeds the expected value, the callback function will fail.\n\n## Vulnerability Detail\n\nThe function `wagmiLeverageFlashCallback` is used to handle the repayment operation after flash loan. After obtaining enough saleToken, it uses `_v3SwapExact` to convert the saleToken into holdToken. We know that the amount of holdTokens (`holdTokenAmtIn`) is proportional to the amount of saleTokens (`amountToPay`) obtained from flash loans. Later, the function will check the holdTokenAmtIn is no large than decodedData.holdTokenDebt. \n\n```solidity\n// Swap tokens to repay the flash loan\nuint256 holdTokenAmtIn = _v3SwapExact(\n    v3SwapExactParams({\n        isExactInput: false,\n        fee: decodedData.fee,\n        tokenIn: decodedData.holdToken,\n        tokenOut: decodedData.saleToken,\n        amount: amountToPay\n    })\n);\ndecodedData.holdTokenDebt -= decodedData.zeroForSaleToken\n    ? decodedData.amounts.amount1\n    : decodedData.amounts.amount0;\n\n// Check for strict route adherence, revert the transaction if conditions are not met\n(decodedData.routes.strict && holdTokenAmtIn > decodedData.holdTokenDebt).revertError(\n    ErrLib.ErrorCode.SWAP_AFTER_FLASH_LOAN_FAILED\n);\n```\n\nIn the function `_excuteCallback`, the amount of token finally obtained by the user through flash loan is `flashBalance`, which is the balance of the contract.\n\n```solidity\n// Transfer the flashBalance to the recipient\ndecodedData.saleToken.safeTransfer(decodedDataExt.recipient, flashBalance);\n// Invoke the WagmiLeverage callback function with updated parameters\nIWagmiLeverageFlashCallback(decodedDataExt.recipient).wagmiLeverageFlashCallback(\n    flashBalance,\n    interest,\n    decodedDataExt.originData\n);\n```\n\nNow let me describe how the attacker compromises the flash loans. \n\nFirst, the attacker makes a donation to the `FlashLoanAggregator` contract before the victim performs a flash loan (using front-run). Then victim performs a flash loan, and he/she will get much more flashBalance than expected. Finally, in the function `wagmiLeverageFlashCallback`, the holdTokenAmtIn is larger than experted, which leads to fail.\n\n## Impact\n\nDOS\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-wagmileverage-v2/blob/main/wagmi-leverage/contracts/FlashLoanAggregator.sol#L553-L560\n\nhttps://github.com/sherlock-audit/2024-03-wagmileverage-v2/blob/main/wagmi-leverage/contracts/abstract/LiquidityManager.sol#L460-L478\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn the function `_excuteCallback`, the amount of token finally obtained by the user through flash loan should be the the balance difference during the flash loan period.\n\n\n\n## Discussion\n\n**WangSecurity**\n\nseems to be working as expected since all these parameters are user supplied (I mean decodedData.routes.strict)\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/RealWagmi/wagmi-leverage/commit/37b0268ec936d63beee873dd61b096b47cd673c1.\n\n**WangSecurity**\n\nAfter additional discussions, we decided to make this a valid medium, cause it's a valid attack vector, but takes a lot of funding and additional external factors\n\n**spacegliderrrr**\n\nFix looks good, in case aggregator has extra funds, callback will not have to repay for them.\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/281",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/FlashLoanAggregator.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.8.23;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IFlashLoanAggregator.sol\";\nimport \"./interfaces/IWagmiLeverageFlashCallback.sol\";\nimport \"./interfaces/IUniswapV3FlashCallback.sol\";\nimport \"./interfaces/abstract/ILiquidityManager.sol\";\nimport \"./interfaces/IUniswapV3Pool.sol\";\nimport \"./vendor0.8/uniswap/FullMath.sol\";\nimport \"@aave/core-v3/contracts/flashloan/base/FlashLoanSimpleReceiverBase.sol\";\nimport \"@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol\";\nimport \"@aave/core-v3/contracts/protocol/libraries/configuration/ReserveConfiguration.sol\";\nimport { DataTypes } from \"@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol\";\nimport { TransferHelper } from \"./libraries/TransferHelper.sol\";\nimport { IAToken } from \"@aave/core-v3/contracts/interfaces/IAToken.sol\";\nimport { IFlashLoanSimpleReceiver } from \"@aave/core-v3/contracts/flashloan/interfaces/IFlashLoanSimpleReceiver.sol\";\nimport { IPoolAddressesProvider } from \"@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol\";\nimport { IPool } from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\n\n// import \"hardhat/console.sol\";\n\n/**\n * @title FlashLoanAggregator\n * @dev This contract serves as an aggregator for flash loans from different protocols.\n * It defines various data structures and modifiers used in the contract.\n */\ncontract FlashLoanAggregator is\n    Ownable,\n    IFlashLoanAggregator,\n    IFlashLoanSimpleReceiver,\n    IUniswapV3FlashCallback\n{\n    using TransferHelper for address;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n    enum Protocol {\n        UNKNOWN,\n        UNISWAP,\n        AAVE\n    }\n    struct Debt {\n        Protocol protocol;\n        address creditor;\n        uint256 body;\n        uint256 interest;\n    }\n\n    struct UniswapV3Identifier {\n        bool enabled;\n        address factoryV3;\n        bytes32 initCodeHash;\n        string name;\n    }\n\n    struct CallbackDataExt {\n        address recipient;\n        uint256 currentIndex;\n        uint256 amount;\n        uint256 prevBalance;\n        Debt[] debts;\n        bytes originData;\n    }\n\n    IPoolAddressesProvider public override ADDRESSES_PROVIDER;\n    IPool public override POOL;\n\n    UniswapV3Identifier[] public uniswapV3Dexes;\n    mapping(bytes32 => bool) public uniswapDexIsExists;\n    mapping(address => bool) public wagmiLeverageContracts;\n    /**\n     * @dev Modifier to restrict access to only contracts registered as Wagmi Leverage contracts.\n     */\n    modifier onlyWagmiLeverage() {\n        require(wagmiLeverageContracts[msg.sender], \"IC\");\n        _;\n    }\n    /**\n     * @dev Modifier to check if the provided index is within the range of the uniswapV3Dexes array.\n     * @param indx The index to check.\n     */\n    modifier correctIndx(uint256 indx) {\n        require(uniswapV3Dexes.length > indx, \"II\");\n        _;\n    }\n    event UniswapV3DexAdded(address factoryV3, bytes32 initCodeHash, string name);\n    event UniswapV3DexChanged(address factoryV3, bytes32 initCodeHash, string name);\n\n    error CollectedAmountIsNotEnough(uint256 desiredAmount, uint256 collectedAmount);\n    error FlashLoanZeroLiquidity(address pool);\n    error FlashLoanAaveZeroLiquidity();\n\n    /**\n     * @dev Constructor function that initializes the contract with a Uniswap V3 Dex.\n     * @param factoryV3 The address of the Uniswap V3 factory.\n     * @param initCodeHash The init code hash of the Uniswap V3 factory.\n     * @param name The name of the Uniswap V3 Dex.\n     */\n    constructor(\n        address aaveAddressProvider, //https://docs.aave.com/developers/deployed-contracts/v3-mainnet\n        address factoryV3,\n        bytes32 initCodeHash,\n        string memory name\n    ) {\n        bytes32 nameHash = keccak256(abi.encodePacked(name));\n        _addUniswapV3Dex(factoryV3, initCodeHash, nameHash, name);\n        if (aaveAddressProvider != address(0)) {\n            ADDRESSES_PROVIDER = IPoolAddressesProvider(aaveAddressProvider);\n            POOL = IPool(ADDRESSES_PROVIDER.getPool());\n        }\n    }\n\n    /**\n     * @dev Initializes the Aave protocol by setting the Aave address provider and the Aave pool.\n     * @param aaveAddressProvider The address of the Aave address provider contract.\n     * @notice This function can only be called by the contract owner.\n     * @notice The Aave address provider must not be the zero address.\n     * @notice The Aave pool must not have been initialized before.\n     */\n    function initAave(address aaveAddressProvider) external onlyOwner {\n        require(aaveAddressProvider != address(0));\n        require(address(POOL) == address(0));\n        ADDRESSES_PROVIDER = IPoolAddressesProvider(aaveAddressProvider);\n        POOL = IPool(ADDRESSES_PROVIDER.getPool());\n    }\n\n    /**\n     * @dev Sets the address of the Wagmi Leverage contract.\n     * @param _wagmiLeverageAddress The address of the Wagmi Leverage contract.\n     */\n    function setWagmiLeverageAddress(address _wagmiLeverageAddress) external onlyOwner {\n        wagmiLeverageContracts[_wagmiLeverageAddress] = true;\n    }\n\n    /**\n     * @dev Adds a Uniswap V3 DEX to the FlashLoanAggregator contract.\n     * @param factoryV3 The address of the Uniswap V3 factory contract.\n     * @param initCodeHash The init code hash of the Uniswap V3 factory contract.\n     * @param name The name of the Uniswap V3 DEX.\n     * Requirements:\n     * - Only the contract owner can call this function.\n     * - The Uniswap V3 DEX with the given name must not already exist.\n     */\n    function addUniswapV3Dex(\n        address factoryV3,\n        bytes32 initCodeHash,\n        string calldata name\n    ) external onlyOwner {\n        bytes32 nameHash = keccak256(abi.encodePacked(name));\n        require(!uniswapDexIsExists[nameHash], \"DE\");\n        _addUniswapV3Dex(factoryV3, initCodeHash, nameHash, name);\n    }\n\n    function _addUniswapV3Dex(\n        address factoryV3,\n        bytes32 initCodeHash,\n        bytes32 nameHash,\n        string memory name\n    ) private {\n        uniswapV3Dexes.push(\n            UniswapV3Identifier({\n                enabled: true,\n                factoryV3: factoryV3,\n                initCodeHash: initCodeHash,\n                name: name\n            })\n        );\n        uniswapDexIsExists[nameHash] = true;\n        emit UniswapV3DexAdded(factoryV3, initCodeHash, name);\n    }\n\n    /**\n     * @dev Edits the Uniswap V3 DEX configuration at the specified index.\n     * @param enabled Whether the DEX is enabled or not.\n     * @param factoryV3 The address of the Uniswap V3 factory contract.\n     * @param initCodeHash The init code hash of the Uniswap V3 pair contract.\n     * @param indx The index of the DEX in the `uniswapV3Dexes` array.\n     * Requirements:\n     * - The caller must be the contract owner.\n     * - The `indx` must be a valid index in the `uniswapV3Dexes` array.\n     */\n    function editUniswapV3Dex(\n        bool enabled,\n        address factoryV3,\n        bytes32 initCodeHash,\n        uint256 indx\n    ) external correctIndx(indx) onlyOwner {\n        UniswapV3Identifier storage dex = uniswapV3Dexes[indx];\n        dex.enabled = enabled;\n        dex.factoryV3 = factoryV3;\n        dex.initCodeHash = initCodeHash;\n        emit UniswapV3DexChanged(factoryV3, initCodeHash, dex.name);\n    }\n\n    /**\n     * @dev Executes a flash loan by interacting with different protocols based on the specified route.\n     * @param amount The amount of the flash loan.\n     * @param data Additional data for the flash loan.\n     * @notice Only callable by the `onlyWagmiLeverage` modifier.\n     * @notice Supports flash loans from Uniswap and Aave protocols.\n     * @notice Reverts if the specified route is not supported.\n     */\n    function flashLoan(uint256 amount, bytes calldata data) external onlyWagmiLeverage {\n        ILiquidityManager.CallbackData memory decodedData = abi.decode(\n            data,\n            (ILiquidityManager.CallbackData)\n        );\n        ILiquidityManager.FlashLoanParams[] memory flashLoanParams = decodedData\n            .routes\n            .flashLoanParams;\n\n        require(flashLoanParams.length > 0, \"FLP\");\n        Protocol protocol = Protocol(flashLoanParams[0].protocol);\n\n        Debt[] memory debts = new Debt[](flashLoanParams.length);\n\n        if (protocol == Protocol.UNISWAP) {\n            address pool = _getUniswapV3Pool(decodedData.saleToken, flashLoanParams[0].data);\n\n            (uint256 flashAmount0, uint256 flashAmount1) = _maxUniPoolFlashAmt(\n                decodedData.saleToken,\n                pool,\n                amount\n            );\n\n            IUniswapV3Pool(pool).flash(\n                address(this),\n                flashAmount0,\n                flashAmount1,\n                abi.encode(\n                    CallbackDataExt({\n                        recipient: msg.sender,\n                        amount: amount,\n                        currentIndex: 0,\n                        prevBalance: 0,\n                        debts: debts,\n                        originData: data\n                    })\n                )\n            );\n        } else if (protocol == Protocol.AAVE) {\n            require(address(POOL) != address(0), \"Aave not initialized\");\n            uint256 maxAmount = checkAaveFlashReserve(decodedData.saleToken);\n            if (maxAmount == 0) {\n                revert FlashLoanAaveZeroLiquidity();\n            }\n\n            POOL.flashLoanSimple(\n                address(this),\n                decodedData.saleToken,\n                amount > maxAmount ? maxAmount : amount,\n                abi.encode(\n                    CallbackDataExt({\n                        recipient: msg.sender,\n                        amount: amount,\n                        currentIndex: 0,\n                        prevBalance: 0,\n                        debts: debts,\n                        originData: data\n                    })\n                ),\n                0\n            );\n        } else {\n            revert(\"UFP\");\n        }\n    }\n\n    function checkAaveFlashReserve(address asset) public view returns (uint256 amount) {\n        DataTypes.ReserveData memory reserve = POOL.getReserveData(asset);\n        uint128 premium = POOL.FLASHLOAN_PREMIUM_TOTAL();\n        DataTypes.ReserveConfigurationMap memory configuration = reserve.configuration;\n        if (\n            premium > 100 ||\n            configuration.getPaused() ||\n            !configuration.getActive() ||\n            !configuration.getFlashLoanEnabled()\n        ) {\n            return 0;\n        }\n\n        amount = asset.getBalanceOf(reserve.aTokenAddress);\n    }\n\n    function executeOperation(\n        address /*asset*/,\n        uint256 /*amount*/,\n        uint256 premium,\n        address /*initiator*/,\n        bytes calldata data\n    ) external override returns (bool) {\n        _excuteCallback(premium, data);\n        return true;\n    }\n\n    function uniswapV3FlashCallback(uint256 fee0, uint256 fee1, bytes calldata data) external {\n        _excuteCallback(fee0 + fee1, data);\n    }\n\n    /**\n     * @dev Calculates the maximum flash loan amount for a given token and pool.\n     * @param token The address of the token.\n     * @param pool The address of the Uniswap V3 pool.\n     * @param amount The desired flash loan amount.\n     * @return flashAmount0 The maximum amount of token0 that can be borrowed.\n     * @return flashAmount1 The maximum amount of token1 that can be borrowed.\n     * @dev This function checks the liquidity of the pool and the balance of the token in the pool.\n     * If the pool has zero liquidity or the token balance is zero, it reverts with an error.\n     * Otherwise, it calculates the maximum flash loan amount based on the available token balance.\n     * If `zeroForSaleToken` is true, `flashAmount0` will be set to `flashAmt`, otherwise `flashAmount1` will be set to `flashAmt`.\n     */\n    function _maxUniPoolFlashAmt(\n        address token,\n        address pool,\n        uint256 amount\n    ) private view returns (uint256 flashAmount0, uint256 flashAmount1) {\n        uint256 flashAmt = token.getBalanceOf(pool);\n        if (flashAmt == 0 || IUniswapV3Pool(pool).liquidity() == 0) {\n            revert FlashLoanZeroLiquidity(pool);\n        }\n        address token0 = IUniswapV3Pool(pool).token0();\n        bool zeroForSaleToken = token0 == token;\n\n        flashAmt = flashAmt > amount ? amount : flashAmt;\n        (flashAmount0, flashAmount1) = zeroForSaleToken\n            ? (flashAmt, uint256(0))\n            : (uint256(0), flashAmt);\n    }\n\n    /**\n     * @dev Retrieves the address of a Uniswap V3 pool based on the provided parameters.\n     * @param saleToken The address of the token being sold.\n     * @param leverageData The encoded data containing the pool fee tiers, second token address, and DEX index.\n     * @return pool The address of the Uniswap V3 pool.\n     * @dev This function decodes the `leverageData` and retrieves the necessary information to compute the pool address.\n     * @dev It checks if the specified DEX is enabled before computing the pool address.\n     * @dev The pool address is computed using the `computePoolAddress` function with the provided parameters.\n     */\n    function _getUniswapV3Pool(\n        address saleToken,\n        bytes memory leverageData\n    ) private view returns (address pool) {\n        (uint24 poolfeeTiers, address secondToken, uint256 dexIndx) = abi.decode(\n            leverageData,\n            (uint24, address, uint256)\n        );\n        UniswapV3Identifier memory dex = uniswapV3Dexes[dexIndx];\n        require(dex.enabled, \"DXE\");\n\n        pool = _computePoolAddress(\n            poolfeeTiers,\n            saleToken,\n            secondToken,\n            dex.factoryV3,\n            dex.initCodeHash\n        );\n    }\n\n    /**\n     * @dev Computes the address of a Uniswap V3 pool based on the provided parameters.\n     * Not applicable for the zkSync.\n     *\n     * This function calculates the address of a Uniswap V3 pool contract using the token addresses and fee.\n     * It follows the same logic as Uniswap's pool initialization process.\n     *\n     * @param fee The fee level of the pool.\n     * @param tokenA The address of one of the tokens in the pair.\n     * @param tokenB The address of the other token in the pair.\n     * @param factoryV3 The address of the Uniswap V3 factory contract.\n     * @param initCodeHash The hash of the pool initialization code.\n     * @return pool The computed address of the Uniswap V3 pool.\n     */\n    function _computePoolAddress(\n        uint24 fee,\n        address tokenA,\n        address tokenB,\n        address factoryV3,\n        bytes32 initCodeHash\n    ) private pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factoryV3,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function _tryApprove(address token, uint256 amount) private returns (bool) {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, address(POOL), amount)\n        );\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n\n    function _aaveFlashApprove(address token, uint256 amount) internal {\n        if (!_tryApprove(token, amount)) {\n            require(_tryApprove(token, 0), \"AFA0\");\n            require(_tryApprove(token, amount), \"AFA\");\n        }\n    }\n\n    /**\n     * @dev Private function to repay flash loans after execution.\n     * This function handles the repayment of multiple debts that arose during flash loan operations.\n     * It ensures the correct amounts are repaid to the corresponding creditors, and performs approval\n     * for token transfer if needed. The function supports both AAVE and UNISWAP protocols and is designed\n     * to work with arrays of debt structs which contain information about debts from various protocols.\n     *\n     * If the last protocol used in the series of flash loans was AAVE, the function approves the AAVE\n     * lending pool to pull the repayment amount and settles UNISWAP debts directly by transferring funds.\n     *\n     * Conversely, if the last protocol was UNISWAP, the function directly transfers the needed funds to\n     * settle the debt and handles the AAVE debt separately by performing a token approval.\n     *\n     * Any protocols other than AAVE or UNISWAP will cause the transaction to revert.\n     *\n     * @param lastProto The protocol used in the last taken flash loan.\n     * @param token The ERC20 token address that was used for the flash loans.\n     * @param lastAmtWithPremium The cumulative flash loan amount including any premiums/fees from the last flash loan taken.\n     * @param debts An array of Debt structs containing details about each individual debt accrued through the flash loan sequence.\n     */\n    function _repayFlashLoans(\n        Protocol lastProto,\n        address token,\n        uint256 lastAmtWithPremium,\n        Debt[] memory debts\n    ) private {\n        // Check if the last flash loan was taken from the AAVE protocol\n        if (lastProto == Protocol.AAVE) {\n            // Approve the AAVE contract to pull the repayment amount including premiums\n            _aaveFlashApprove(token, lastAmtWithPremium);\n            // Iterate over the array of debts to process repayments\n            // if we have already processed the AAVE protocol we do not expect it\n            for (uint256 i = 0; i < debts.length; ) {\n                Debt memory debt = debts[i];\n                // Exit loop if creditor address is zero indicating no more debts\n                if (debt.creditor == address(0)) {\n                    break;\n                }\n                // Handle UNISWAP debt repayment by transferring tokens directly to creditor\n                if (debt.protocol == Protocol.UNISWAP) {\n                    token.safeTransfer(debt.creditor, debt.body + debt.interest);\n                } else {\n                    revert(\"REA\");\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n            // Check if the last flash loan was taken from the UNISWAP protocol\n        } else if (lastProto == Protocol.UNISWAP) {\n            // Directly transfer the loan amount plus premium to the sender for final UNISWAP loan settlement\n            token.safeTransfer(msg.sender, lastAmtWithPremium);\n\n            for (uint256 i = 0; i < debts.length; ) {\n                Debt memory debt = debts[i];\n                if (debt.creditor == address(0)) {\n                    break;\n                }\n                if (debt.protocol == Protocol.AAVE) {\n                    // Approve repayment for AAVE debts\n                    _aaveFlashApprove(token, debt.body + debt.interest);\n                } else if (debt.protocol == Protocol.UNISWAP) {\n                    // Transfer tokens directly for UNISWAP debts\n                    token.safeTransfer(debt.creditor, debt.body + debt.interest);\n                } else {\n                    revert(\"REU\");\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            revert(\"RE UFP\");\n        }\n    }\n\n    /**\n     * @dev Internal function that executes a flash loan callback.\n     * It processes the received data, performs checks based on the protocol,\n     * and handles repayment of debts or initiation of subsequent flash loans.\n     *\n     * The function decodes the `data` parameter to extract the callback details and then,\n     * depending on the state of the flash loan process (e.g., if this is an intermediary step\n     * in a sequence of flash loans, or the final callback), it either performs the necessary payouts\n     * and calls the user's callback function, or it encodes new data and triggers another flash loan.\n     *\n     * Additionally, the function enforces security by requiring that it is called only by the expected\n     * sources (like a specific Uniswap pool or the AAVE lending pool) according to the loan protocol used.\n     * It supports different protocols like Uniswap or AAVE for the execution of flash loans.\n     *\n     * @param premium The fee or interest amount associated with the flash loan.\n     * @param data Encoded data containing all relevant information to perform callbacks and repayments.\n     */\n    function _excuteCallback(uint256 premium, bytes calldata data) internal {\n        // Decode the extended callback data structure\n        CallbackDataExt memory decodedDataExt = abi.decode(data, (CallbackDataExt));\n        // Decode the original callback data sent by the user\n        ILiquidityManager.CallbackData memory decodedData = abi.decode(\n            decodedDataExt.originData,\n            (ILiquidityManager.CallbackData)\n        );\n        // Extract the current flash loan parameters from the route provided in the callback data\n        ILiquidityManager.FlashLoanParams memory flashParams = decodedData.routes.flashLoanParams[\n            decodedDataExt.currentIndex\n        ];\n        // Determine the protocol used for the current flash loan\n        Protocol protocol = Protocol(flashParams.protocol);\n\n        if (protocol == Protocol.UNISWAP) {\n            require(\n                msg.sender == _getUniswapV3Pool(decodedData.saleToken, flashParams.data),\n                \"IPC\"\n            );\n        } else if (protocol == Protocol.AAVE) {\n            require(msg.sender == address(POOL), \"IPC\");\n        } else {\n            revert(\"IPC UFP\");\n        }\n\n        uint256 flashBalance = decodedData.saleToken.getBalance();\n        // Check if enough funds were received to cover the loan or if this is the last loan step\n        if (\n            flashBalance >= decodedDataExt.amount ||\n            decodedDataExt.currentIndex == decodedData.routes.flashLoanParams.length - 1\n        ) {\n            // Compute total interest including premiums of intermediate steps\n            uint256 interest = premium;\n            // Process recorded debt information for each protocol involved in the loan series\n            uint256 debtsLength = decodedDataExt.debts.length;\n            for (uint256 i = 0; i < debtsLength; ) {\n                // Terminate early if we hit an empty creditor slot\n                if (decodedDataExt.debts[i].creditor == address(0)) {\n                    debtsLength = i;\n                    break;\n                }\n                unchecked {\n                    // Accumulate interest from each debt\n                    interest += decodedDataExt.debts[i].interest;\n                    ++i;\n                }\n            }\n            // Transfer the flashBalance to the recipient\n            decodedData.saleToken.safeTransfer(decodedDataExt.recipient, flashBalance);\n            // Invoke the WagmiLeverage callback function with updated parameters\n            IWagmiLeverageFlashCallback(decodedDataExt.recipient).wagmiLeverageFlashCallback(\n                flashBalance,\n                interest,\n                decodedDataExt.originData\n            );\n\n            uint256 lastPayment = flashBalance - decodedDataExt.prevBalance + premium;\n            // Repay all flash loans that have been taken out across different protocols\n            _repayFlashLoans(protocol, decodedData.saleToken, lastPayment, decodedDataExt.debts);\n        } else {\n            // If not enough funds, prepare for the next flash loan in the series\n            uint256 nextIndx = decodedDataExt.currentIndex + 1;\n            // Record the current debt for the ongoing protocol\n            decodedDataExt.debts[decodedDataExt.currentIndex] = Debt({\n                protocol: protocol,\n                creditor: msg.sender,\n                body: flashBalance - decodedDataExt.prevBalance,\n                interest: premium\n            });\n            // Encode data for the next flash loan callback\n            bytes memory nextData = abi.encode(\n                CallbackDataExt({\n                    recipient: decodedDataExt.recipient,\n                    amount: decodedDataExt.amount,\n                    currentIndex: nextIndx,\n                    prevBalance: flashBalance,\n                    debts: decodedDataExt.debts,\n                    originData: decodedDataExt.originData\n                })\n            );\n            // Set up next flash loan params\n            flashParams = decodedData.routes.flashLoanParams[nextIndx];\n            protocol = Protocol(flashParams.protocol);\n            // Trigger the next flash loan based on the protocol\n            if (protocol == Protocol.UNISWAP) {\n                address pool = _getUniswapV3Pool(decodedData.saleToken, flashParams.data);\n\n                (uint256 flashAmount0, uint256 flashAmount1) = _maxUniPoolFlashAmt(\n                    decodedData.saleToken,\n                    pool,\n                    decodedDataExt.amount - flashBalance\n                );\n\n                IUniswapV3Pool(pool).flash(address(this), flashAmount0, flashAmount1, nextData);\n            } else if (protocol == Protocol.AAVE) {\n                uint256 maxAmount = checkAaveFlashReserve(decodedData.saleToken);\n                if (maxAmount == 0) {\n                    revert FlashLoanAaveZeroLiquidity();\n                }\n                uint256 amount = decodedDataExt.amount - flashBalance;\n\n                POOL.flashLoanSimple(\n                    address(this),\n                    decodedData.saleToken,\n                    amount > maxAmount ? maxAmount : amount,\n                    nextData,\n                    0\n                );\n            } else {\n                revert(\"UFP\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "wagmi-leverage/contracts/abstract/LiquidityManager.sol",
      "content": "// SPDX-License-Identifier: SAL-1.0\npragma solidity 0.8.23;\nimport \"../vendor0.8/uniswap/LiquidityAmounts.sol\";\nimport \"../vendor0.8/uniswap/TickMath.sol\";\nimport \"./ApproveSwapAndPay.sol\";\nimport \"../Vault.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { ErrLib } from \"../libraries/ErrLib.sol\";\nimport { AmountsLiquidity } from \"../libraries/AmountsLiquidity.sol\";\nimport \"../interfaces/abstract/ILiquidityManager.sol\";\nimport \"../interfaces/IWagmiLeverageFlashCallback.sol\";\nimport \"../interfaces/IFlashLoanAggregator.sol\";\n\nabstract contract LiquidityManager is\n    ApproveSwapAndPay,\n    ILiquidityManager,\n    IWagmiLeverageFlashCallback\n{\n    using { ErrLib.revertError } for bool;\n\n    /**\n     * @notice The address of the vault contract.\n     */\n    address public immutable VAULT_ADDRESS;\n\n    address public flashLoanAggregatorAddress;\n    /**\n     * @notice The Nonfungible Position Manager contract.\n     */\n    INonfungiblePositionManager public immutable underlyingPositionManager;\n    /**\n     * @notice The Quoter contract.\n     */\n    address public lightQuoterV3Address;\n\n    ///  msg.sender => token => FeesAmt\n    mapping(address => mapping(address => uint256)) internal loansFeesInfo;\n    ///  token => FeesAmt\n    mapping(address => uint256) internal platformsFeesInfo;\n\n    /**\n     * @dev Contract constructor.\n     * @param _underlyingPositionManagerAddress Address of the underlying position manager contract.\n     * @param _lightQuoterV3 Address of the LightQuoterV3 contract.\n     * @param _underlyingV3Factory Address of the underlying V3 factory contract.\n     * @param _underlyingV3PoolInitCodeHash The init code hash of the underlying V3 pool.\n     */\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _flashLoanAggregator,\n        address _lightQuoterV3,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    ) ApproveSwapAndPay(_underlyingV3Factory, _underlyingV3PoolInitCodeHash) {\n        // Assign the underlying position manager contract address\n        underlyingPositionManager = INonfungiblePositionManager(_underlyingPositionManagerAddress);\n        // Assign the quoter contract address\n        lightQuoterV3Address = _lightQuoterV3;\n\n        flashLoanAggregatorAddress = _flashLoanAggregator;\n        // Generate a unique salt for the new Vault contract\n        bytes32 salt = keccak256(abi.encode(block.timestamp, address(this)));\n        // Deploy a new Vault contract using the generated salt and assign its address to VAULT_ADDRESS\n        VAULT_ADDRESS = address(new Vault{ salt: salt }(Constants.FLASH_LOAN_DEFAULT_VAULT_FEE));\n    }\n\n    modifier onlyTrustedCallers() {\n        (msg.sender != flashLoanAggregatorAddress && msg.sender != VAULT_ADDRESS).revertError(\n            ErrLib.ErrorCode.INVALID_CALLER\n        );\n        _;\n    }\n\n    error InvalidLiquidityAmount(uint256 tokenId, uint128 max, uint128 min, uint128 liquidity);\n    error InvalidTokens(uint256 tokenId);\n    error NotApproved(uint256 tokenId);\n    error InvalidRestoredLiquidity(\n        uint256 tokenId,\n        uint128 borrowedLiquidity,\n        uint128 restoredLiquidity\n    );\n\n    function _chargePlatformFees(address holdToken, uint256 feesAmt) internal {\n        unchecked {\n            platformsFeesInfo[holdToken] += feesAmt * Constants.COLLATERAL_BALANCE_PRECISION;\n        }\n    }\n\n    /**\n     * @dev Calculates the borrowed amount from a pool's single side position, rounding up if necessary.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param tickLower The lower tick value of the position range.\n     * @param tickUpper The upper tick value of the position range.\n     * @param liquidity The liquidity of the position.\n     * @return borrowedAmount The calculated borrowed amount.\n     */\n    function _getSingleSideRoundUpBorrowedAmount(\n        bool zeroForSaleToken,\n        uint24 feeTiers,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) private pure returns (uint256 borrowedAmount) {\n        borrowedAmount = (\n            zeroForSaleToken\n                ? AmountsLiquidity.getAmount1RoundingUpForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n                : AmountsLiquidity.getAmount0RoundingUpForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n        );\n        // Apply the fee tier to the borrowed amount\n        feeTiers += Constants.FLASH_LOAN_FEE_COMPENSATION;\n        borrowedAmount += FullMath.mulDivRoundingUp(borrowedAmount, feeTiers, 1e6 - feeTiers);\n    }\n\n    /**\n     * @dev Calculates the minimum liquidity amount for a given tick range.\n     * @param tickLower The lower tick of the range.\n     * @param tickUpper The upper tick of the range.\n     * @return minLiquidity The minimum liquidity amount.\n     */\n    function _getMinLiquidityAmt(\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (uint128 minLiquidity) {\n        uint128 liquidity0 = LiquidityAmounts.getLiquidityForAmount0(\n            TickMath.getSqrtRatioAtTick(tickUpper - 1),\n            TickMath.getSqrtRatioAtTick(tickUpper),\n            Constants.MINIMUM_EXTRACTED_AMOUNT\n        );\n        uint128 liquidity1 = LiquidityAmounts.getLiquidityForAmount1(\n            TickMath.getSqrtRatioAtTick(tickLower),\n            TickMath.getSqrtRatioAtTick(tickLower + 1),\n            Constants.MINIMUM_EXTRACTED_AMOUNT\n        );\n        minLiquidity = liquidity0 > liquidity1 ? liquidity0 : liquidity1;\n    }\n\n    /**\n     * @notice This function extracts liquidity from provided loans and calculates the total borrowed amount.\n     * @dev Iterates through an array of LoanInfo structs, validates loan parameters, and accumulates borrowed amounts.\n     * @param zeroForSaleToken A boolean indicating whether the token for sale is the 0th token in the pair.\n     * @param saleToken The address of the token being sold in the trading pair.\n     * @param holdToken The address of the token being held in the trading pair.\n     * @param loans An array of LoanInfo struct instances, each representing a loan from which to extract liquidity.\n     * @return borrowedAmount The total amount of the holdToken that has bee"
    }
  ]
}