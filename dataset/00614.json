{
  "Title": "Incomplete Resource ID Validations",
  "Content": "Resource IDs in the `World` are expected to encode [three components](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/WorldResourceId.sol#L30) (the type, namespace and name) that are used to ensure consistency between different table records. However, there are several instances of incomplete consistency checks:\n\n\n* It is possible to call [`transferOwnership`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/AccessManagementSystem.sol#L51) on any resource ID, provided the caller owns the corresponding namespace. This includes a table, system, an unknown resource ID, or an incorrectly specified resource ID.\n* It is possible to call [`transferBalanceToNamespace`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/BalanceTransferSystem.sol#L30C23-L30C23) with a `toNamespaceId` that has a non-zero \"name\" component. This will effectively transfer the funds to a new account in the destination namespace, which needs to be spent individually (i.e., it cannot be consumed by systems within the namespace unless they are explicitly designed to handle it).\n* It is possible to call [`registerFunctionSelector`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol#L171) with any resource ID, provided the caller owns the corresponding namespace. In practice, if it does not correspond to a valid system, it will be unusable.\n* It is possible to [`grantAccess`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/AccessManagementSystem.sol#L23) to an incorrectly specified resource ID, or a resource that does not exist.\n* It is possible to call [`registerNamespace`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol#L44) or [`registerNamespaceDelegation`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol#L272) with a `namespaceId` that has a non-zero \"name\" component.\n* It is possible to call [`registerSystemHook`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol#L72) with any resource ID, provided the caller owns the corresponding namespace.\n* It is possible to call [`registerStoreHook`](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/world/src/modules/core/implementations/StoreRegistrationSystem.sol#L88) with a non-existent `tableId`, provided the caller owns the corresponding namespace.\n\n\nIn the interest of predictability and limiting the attack surface, consider validating all three components of user-provided resource IDs and validating the existence of a resource wherever relevant throughout the codebase.\n\n\n***Update:** Resolved in [pull request #2142](https://github.com/latticexyz/mud/pull/2142) and [pull request #2195](https://github.com/latticexyz/mud/pull/2195).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/world/src/WorldResourceId.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Bytes } from \"@latticexyz/store/src/Bytes.sol\";\nimport { ResourceId, ResourceIdInstance, TYPE_BITS } from \"@latticexyz/store/src/ResourceId.sol\";\n\nimport { ROOT_NAMESPACE, ROOT_NAME } from \"./constants.sol\";\nimport { RESOURCE_NAMESPACE, MASK_RESOURCE_NAMESPACE } from \"./worldResourceTypes.sol\";\n\nuint256 constant NAMESPACE_BITS = 14 * 8;\nuint256 constant NAME_BITS = 16 * 8;\n\nbytes16 constant ROOT_NAMESPACE_STRING = bytes16(\"ROOT_NAMESPACE\");\nbytes16 constant ROOT_NAME_STRING = bytes16(\"ROOT_NAME\");\n\nbytes32 constant NAMESPACE_MASK = bytes32(~bytes14(\"\")) >> (TYPE_BITS);\n\n/**\n * @title WorldResourceIdLib\n * @notice A library for handling World Resource ID encoding and decoding.\n */\nlibrary WorldResourceIdLib {\n  /**\n   * @notice Encode a resource ID.\n   * @param typeId The resource type ID.\n   * @param namespace The namespace of the resource.\n   * @param name The name of the resource.\n   * @return A 32-byte resource ID.\n   */\n  function encode(bytes2 typeId, bytes14 namespace, bytes16 name) internal pure returns (ResourceId) {\n    return\n      ResourceId.wrap(\n        bytes32(typeId) | (bytes32(namespace) >> TYPE_BITS) | (bytes32(name) >> (TYPE_BITS + NAMESPACE_BITS))\n      );\n  }\n\n  /**\n   * @notice Encode a namespace to resource ID.\n   * @param namespace The namespace to be encoded.\n   * @return A 32-byte resource ID with the namespace encoded.\n   */\n  function encodeNamespace(bytes14 namespace) internal pure returns (ResourceId) {\n    return ResourceId.wrap(bytes32(RESOURCE_NAMESPACE) | (bytes32(namespace) >> (TYPE_BITS)));\n  }\n\n  /**\n   * @notice Convert a padded string to a trimmed string.\n   * @param paddedString The input string with potential padding.\n   * @return A string without trailing null ASCII characters.\n   */\n  function toTrimmedString(bytes16 paddedString) internal pure returns (string memory) {\n    uint256 length;\n    for (; length < 16; length++) if (Bytes.slice1(paddedString, length) == 0) break;\n    bytes memory packedSelector = abi.encodePacked(paddedString);\n    return string(Bytes.setLength(packedSelector, length));\n  }\n}\n\n/**\n * @title WorldResourceIdInstance\n * @notice A library for handling instances of World Resource IDs.\n */\nlibrary WorldResourceIdInstance {\n  /**\n   * @notice Get the namespace from a resource ID.\n   * @param resourceId The resource ID.\n   * @return A 14-byte namespace.\n   */\n  function getNamespace(ResourceId resourceId) internal pure returns (bytes14) {\n    return bytes14(ResourceId.unwrap(resourceId) << (TYPE_BITS));\n  }\n\n  /**\n   * @notice Get the namespace ID from a resource ID.\n   * @param resourceId The resource ID.\n   * @return A 32-byte namespace resource ID.\n   */\n  function getNamespaceId(ResourceId resourceId) internal pure returns (ResourceId) {\n    return ResourceId.wrap((ResourceId.unwrap(resourceId) & NAMESPACE_MASK) | MASK_RESOURCE_NAMESPACE);\n  }\n\n  /**\n   * @notice Get the name from a resource ID.\n   * @param resourceId The resource ID.\n   * @return A 16-byte name.\n   */\n  function getName(ResourceId resourceId) internal pure returns (bytes16) {\n    return bytes16(ResourceId.unwrap(resourceId) << (TYPE_BITS + NAMESPACE_BITS));\n  }\n\n  /**\n   * @notice Convert a resource ID to a string.\n   * @param resourceId The resource ID.\n   * @return A string representation of the resource ID.\n   */\n  function toString(ResourceId resourceId) internal pure returns (string memory) {\n    bytes2 resourceType = ResourceIdInstance.getType(resourceId);\n    bytes14 resourceNamespace = getNamespace(resourceId);\n    bytes16 resourceName = getName(resourceId);\n    return\n      string(\n        abi.encodePacked(\n          resourceType,\n          \":\",\n          resourceNamespace == ROOT_NAMESPACE ? ROOT_NAMESPACE_STRING : resourceNamespace,\n          \":\",\n          resourceName == ROOT_NAME ? ROOT_NAME_STRING : resourceName\n        )\n      );\n  }\n}"
    },
    {
      "filename": "packages/world/src/modules/core/implementations/AccessManagementSystem.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IModule } from \"../../../IModule.sol\";\nimport { System } from \"../../../System.sol\";\nimport { AccessControl } from \"../../../AccessControl.sol\";\nimport { ResourceId, WorldResourceIdLib } from \"../../../WorldResourceId.sol\";\nimport { ResourceAccess } from \"../../../codegen/tables/ResourceAccess.sol\";\nimport { InstalledModules } from \"../../../codegen/tables/InstalledModules.sol\";\nimport { NamespaceOwner } from \"../../../codegen/tables/NamespaceOwner.sol\";\n\n/**\n * @title Access Management System\n * @dev This contract manages the granting and revoking of access from/to resources.\n */\ncontract AccessManagementSystem is System {\n  /**\n   * @notice Grant access to the resource at the given resource ID.\n   * @dev Requires the caller to own the namespace.\n   * @param resourceId The ID of the resource to grant access to.\n   * @param grantee The address to which access should be granted.\n   */\n  function grantAccess(ResourceId resourceId, address grantee) public virtual {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(resourceId, _msgSender());\n\n    // Grant access to the given resource\n    ResourceAccess._set(resourceId, grantee, true);\n  }\n\n  /**\n   * @notice Revoke access from the resource at the given resource ID.\n   * @dev Requires the caller to own the namespace.\n   * @param resourceId The ID of the resource to revoke access from.\n   * @param grantee The address from which access should be revoked.\n   */\n  function revokeAccess(ResourceId resourceId, address grantee) public virtual {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(resourceId, _msgSender());\n\n    // Revoke access from the given resource\n    ResourceAccess._deleteRecord(resourceId, grantee);\n  }\n\n  /**\n   * @notice Transfer ownership of the given namespace to newOwner and manages the access.\n   * @dev Requires the caller to own the namespace. Revoke ResourceAccess for previous owner and grant to newOwner.\n   * @param namespaceId The ID of the namespace to transfer ownership.\n   * @param newOwner The address to which ownership should be transferred.\n   */\n  function transferOwnership(ResourceId namespaceId, address newOwner) public virtual {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(namespaceId, _msgSender());\n\n    // Set namespace new owner\n    NamespaceOwner._set(namespaceId, newOwner);\n\n    // Revoke access from old owner\n    ResourceAccess._deleteRecord(namespaceId, _msgSender());\n\n    // Grant access to new owner\n    ResourceAccess._set(namespaceId, newOwner, true);\n  }\n}"
    },
    {
      "filename": "packages/world/src/modules/core/implementations/BalanceTransferSystem.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { ResourceId, ResourceIdInstance } from \"@latticexyz/store/src/ResourceId.sol\";\n\nimport { System } from \"../../../System.sol\";\nimport { revertWithBytes } from \"../../../revertWithBytes.sol\";\nimport { WorldResourceIdLib, WorldResourceIdInstance } from \"../../../WorldResourceId.sol\";\nimport { AccessControl } from \"../../../AccessControl.sol\";\nimport { RESOURCE_NAMESPACE } from \"../../../worldResourceTypes.sol\";\nimport { IWorldErrors } from \"../../../IWorldErrors.sol\";\n\nimport { Balances } from \"../../../codegen/tables/Balances.sol\";\n\n/**\n * @title Balance Transfer System\n * @dev A system contract that facilitates balance transfers in the World and outside of the World.\n */\ncontract BalanceTransferSystem is System, IWorldErrors {\n  using ResourceIdInstance for ResourceId;\n  using WorldResourceIdInstance for ResourceId;\n\n  /**\n   * @notice Transfer balance to another namespace in the World.\n   * @dev Requires the caller to have access to the source namespace and ensures the destination namespace type is valid.\n   * @param fromNamespaceId The source namespace from which the balance will be deducted.\n   * @param toNamespaceId The target namespace where the balance will be added.\n   * @param amount The amount to transfer.\n   */\n  function transferBalanceToNamespace(\n    ResourceId fromNamespaceId,\n    ResourceId toNamespaceId,\n    uint256 amount\n  ) public virtual {\n    // Require the target ID to be a namespace ID\n    if (toNamespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, toNamespaceId, toNamespaceId.toString());\n    }\n\n    // Require caller to have access to the namespace\n    AccessControl.requireAccess(fromNamespaceId, _msgSender());\n\n    // Get current namespace balance\n    uint256 balance = Balances._get(fromNamespaceId);\n\n    // Require the balance balance to be greater or equal to the amount to transfer\n    if (amount > balance) revert World_InsufficientBalance(balance, amount);\n\n    // Update the balances\n    Balances._set(fromNamespaceId, balance - amount);\n    Balances._set(toNamespaceId, Balances._get(toNamespaceId) + amount);\n  }\n\n  /**\n   * @notice Transfer balance out of the World to a specific address.\n   * @dev Requires the caller to have access to the source namespace and ensures sufficient balance before transfer.\n   * @param fromNamespaceId The source namespace from which the balance will be deducted.\n   * @param toAddress The target address where the balance will be sent.\n   * @param amount The amount to transfer.\n   */\n  function transferBalanceToAddress(ResourceId fromNamespaceId, address toAddress, uint256 amount) public virtual {\n    // Require caller to have access to the namespace\n    AccessControl.requireAccess(fromNamespaceId, _msgSender());\n\n    // Get current namespace balance\n    uint256 balance = Balances._get(fromNamespaceId);\n\n    // Require the balance balance to be greater or equal to the amount to transfer\n    if (amount > balance) revert World_InsufficientBalance(balance, amount);\n\n    // Update the balances\n    Balances._set(fromNamespaceId, balance - amount);\n\n    // Transfer the balance to the given address, revert on failure\n    (bool success, bytes memory data) = payable(toAddress).call{ value: amount }(\"\");\n    if (!success) revertWithBytes(data);\n  }\n}"
    },
    {
      "filename": "packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Hook, HookLib } from \"@latticexyz/store/src/Hook.sol\";\nimport { ResourceId, ResourceIdInstance } from \"@latticexyz/store/src/ResourceId.sol\";\nimport { ResourceIds } from \"@latticexyz/store/src/codegen/tables/ResourceIds.sol\";\n\nimport { System } from \"../../../System.sol\";\nimport { WorldContextConsumer, WORLD_CONTEXT_CONSUMER_INTERFACE_ID } from \"../../../WorldContext.sol\";\nimport { WorldResourceIdLib, WorldResourceIdInstance } from \"../../../WorldResourceId.sol\";\nimport { SystemCall } from \"../../../SystemCall.sol\";\nimport { ROOT_NAMESPACE_ID, ROOT_NAME } from \"../../../constants.sol\";\nimport { RESOURCE_NAMESPACE, RESOURCE_SYSTEM } from \"../../../worldResourceTypes.sol\";\nimport { AccessControl } from \"../../../AccessControl.sol\";\nimport { Delegation } from \"../../../Delegation.sol\";\nimport { requireInterface } from \"../../../requireInterface.sol\";\nimport { NamespaceOwner } from \"../../../codegen/tables/NamespaceOwner.sol\";\nimport { ResourceAccess } from \"../../../codegen/tables/ResourceAccess.sol\";\nimport { UserDelegationControl } from \"../../../codegen/tables/UserDelegationControl.sol\";\nimport { NamespaceDelegationControl } from \"../../../codegen/tables/NamespaceDelegationControl.sol\";\nimport { ISystemHook, SYSTEM_HOOK_INTERFACE_ID } from \"../../../ISystemHook.sol\";\nimport { IWorldErrors } from \"../../../IWorldErrors.sol\";\nimport { IDelegationControl, DELEGATION_CONTROL_INTERFACE_ID } from \"../../../IDelegationControl.sol\";\n\nimport { SystemHooks, SystemHooksTableId } from \"../../../codegen/tables/SystemHooks.sol\";\nimport { SystemRegistry } from \"../../../codegen/tables/SystemRegistry.sol\";\nimport { Systems } from \"../../../codegen/tables/Systems.sol\";\nimport { FunctionSelectors } from \"../../../codegen/tables/FunctionSelectors.sol\";\nimport { FunctionSignatures } from \"../../../codegen/tables/FunctionSignatures.sol\";\n\n/**\n * @title WorldRegistrationSystem\n * @dev This contract provides functions related to registering resources other than tables in the World.\n */\ncontract WorldRegistrationSystem is System, IWorldErrors {\n  using ResourceIdInstance for ResourceId;\n  using WorldResourceIdInstance for ResourceId;\n\n  /**\n   * @notice Registers a new namespace\n   * @dev Creates a new namespace resource with the given ID\n   * @param namespaceId The unique identifier for the new namespace\n   */\n  function registerNamespace(ResourceId namespaceId) public virtual {\n    // Require the provided namespace ID to have type RESOURCE_NAMESPACE\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require namespace to not exist yet\n    if (ResourceIds._getExists(namespaceId)) {\n      revert World_ResourceAlreadyExists(namespaceId, namespaceId.toString());\n    }\n\n    // Register namespace resource ID\n    ResourceIds._setExists(namespaceId, true);\n\n    // Register caller as the namespace owner\n    NamespaceOwner._set(namespaceId, _msgSender());\n\n    // Give caller access to the new namespace\n    ResourceAccess._set(namespaceId, _msgSender(), true);\n  }\n\n  /**\n   * @notice Registers a new system hook\n   * @dev Adds a new hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being registered\n   * @param enabledHooksBitmap Bitmap indicating which hooks are enabled\n   */\n  function registerSystemHook(ResourceId systemId, ISystemHook hookAddress, uint8 enabledHooksBitmap) public virtual {\n    // Require the provided address to implement the ISystemHook interface\n    requireInterface(address(hookAddress), SYSTEM_HOOK_INTERFACE_ID);\n\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Register the hook\n    SystemHooks.push(systemId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * @notice Unregisters a system hook\n   * @dev Removes a hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being unregistered\n   */\n  function unregisterSystemHook(ResourceId systemId, ISystemHook hookAddress) public virtual {\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Remove the hook from the list of hooks for this system in the system hooks table\n    HookLib.filterListByAddress(SystemHooksTableId, systemId, address(hookAddress));\n  }\n\n  /**\n   * @notice Registers a system\n   * @dev Registers or upgrades a system at the given ID\n   * If the namespace doesn't exist yet, it is registered.\n   * The system is granted access to its namespace, so it can write to any\n   * table in the same namespace.\n   * If publicAccess is true, no access control check is performed for calling the system.\n   * This function doesn't check whether a system already exists at the given selector,\n   * making it possible to upgrade systems.\n   * @param systemId The unique identifier for the system\n   * @param system The system being registered\n   * @param publicAccess Flag indicating if access control check is bypassed\n   */\n  function registerSystem(ResourceId systemId, WorldContextConsumer system, bool publicAccess) public virtual {\n    // Require the provided system ID to have type RESOURCE_SYSTEM\n    if (systemId.getType() != RESOURCE_SYSTEM) {\n      revert World_InvalidResourceType(RESOURCE_SYSTEM, systemId, systemId.toString());\n    }\n\n    // Require the provided address to implement the WorldContextConsumer interface\n    requireInterface(address(system), WORLD_CONTEXT_CONSUMER_INTERFACE_ID);\n\n    // Require the name to not be the namespace's root name\n    if (systemId.getName() == ROOT_NAME) revert World_InvalidResourceId(systemId, systemId.toString());\n\n    // Require this system to not be registered at a different system ID yet\n    ResourceId existingSystemId = SystemRegistry._get(address(system));\n    if (\n      ResourceId.unwrap(existingSystemId) != 0 && ResourceId.unwrap(existingSystemId) != ResourceId.unwrap(systemId)\n    ) {\n      revert World_SystemAlreadyExists(address(system));\n    }\n\n    // If the namespace doesn't exist yet, register it\n    ResourceId namespaceId = systemId.getNamespaceId();\n    if (!ResourceIds._getExists(namespaceId)) {\n      registerNamespace(namespaceId);\n    } else {\n      // otherwise require caller to own the namespace\n      AccessControl.requireOwner(namespaceId, _msgSender());\n    }\n\n    // Check if a system already exists at this system ID\n    address existingSystem = Systems._getSystem(systemId);\n\n    // If there is an existing system with this system ID, remove it\n    if (existingSystem != address(0)) {\n      // Remove the existing system from the system registry\n      SystemRegistry._deleteRecord(existingSystem);\n\n      // Remove the existing system's access to its namespace\n      ResourceAccess._deleteRecord(namespaceId, existingSystem);\n    } else {\n      // Otherwise, this is a new system, so register its resource ID\n      ResourceIds._setExists(systemId, true);\n    }\n\n    // Systems = mapping from system ID to system address and public access flag\n    Systems._set(systemId, address(system), publicAccess);\n\n    // SystemRegistry = mapping from system address to system ID\n    SystemRegistry._set(address(system), systemId);\n\n    // Grant the system access to its namespace\n    ResourceAccess._set(namespaceId, address(system), true);\n  }\n\n  /**\n   * @notice Registers a new World function selector\n   * @dev Creates a mapping between a World function and its associated system function\n   * @param systemId The system ID\n   * @param systemFunctionSignature The signature of the system function\n   * @return worldFunctionSelector The selector of the World function\n   */\n  function registerFunctionSelector(\n    ResourceId systemId,\n    string memory systemFunctionSignature\n  ) public returns (bytes4 worldFunctionSelector) {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Compute global function selector\n    string memory namespaceString = WorldResourceIdLib.toTrimmedString(systemId.getNamespace());\n    string memory nameString = WorldResourceIdLib.toTrimmedString(systemId.getName());\n    bytes memory worldFunctionSignature = abi.encodePacked(\n      namespaceString,\n      \"_\",\n      nameString,\n      \"_\",\n      systemFunctionSignature\n    );\n    worldFunctionSelector = bytes4(keccak256(worldFunctionSignature));\n\n    // Require the function selector to be globally unique\n    ResourceId existingSystemId = FunctionSelectors._getSystemId(worldFunctionSelector);\n\n    if (ResourceId.unwrap(existingSystemId) != 0) revert World_FunctionSelectorAlreadyExists(worldFunctionSelector);\n\n    // Register the function selector\n    bytes4 systemFunctionSelector = bytes4(keccak256(bytes(systemFunctionSignature)));\n    FunctionSelectors._set(worldFunctionSelector, systemId, systemFunctionSelector);\n\n    // Register the function signature for offchain use\n    FunctionSignatures._set(worldFunctionSelector, string(worldFunctionSignature));\n  }\n\n  /**\n   * @notice Registers a root World function selector\n   * @dev Creates a mapping for a root World function without namespace or name prefix\n   * @param systemId The system ID\n   * @param worldFunctionSignature The signature of the World function\n   * @param systemFunctionSelector The selector of the system function\n   * @return worldFunctionSelector The selector of the World function\n   */\n  function registerRootFunctionSelector(\n    ResourceId systemId,\n    string memory worldFunctionSignature,\n    bytes4 systemFunctionSelector\n  ) public returns (bytes4 worldFunctionSelector) {\n    // Require the caller to own the root namespace\n    AccessControl.requireOwner(ROOT_NAMESPACE_ID, _msgSender());\n\n    // Compute the function selector from the provided signature\n    worldFunctionSelector = bytes4(keccak256(bytes(worldFunctionSignature)));\n\n    // Require the function selector to be globally unique\n    ResourceId existingSystemId = FunctionSelectors._getSystemId(worldFunctionSelector);\n\n    if (ResourceId.unwrap(existingSystemId) != 0) revert World_FunctionSelectorAlreadyExists(worldFunctionSelector);\n\n    // Register the function selector\n    FunctionSelectors._set(worldFunctionSelector, systemId, systemFunctionSelector);\n\n    // Register the function signature for offchain use\n    FunctionSignatures._set(worldFunctionSelector, worldFunctionSignature);\n  }\n\n  /**\n   * @notice Registers a delegation for the caller\n   * @dev Creates a new delegation from the caller to the specified delegatee\n   * @param delegatee The address of the delegatee\n   * @param delegationControlId The ID controlling the delegation\n   * @param initCallData The initialization data for the delegation\n   */\n  function registerDelegation(address delegatee, ResourceId delegationControlId, bytes memory initCallData) public {\n    // Store the delegation control contract address\n    UserDelegationControl._set({\n      delegator: _msgSender(),\n      delegatee: delegatee,\n      delegationControlId: delegationControlId\n    });\n\n    // If the delegation is limited...\n    if (Delegation.isLimited(delegationControlId) && initCallData.length > 0) {\n      // Require the delegationControl contract to implement the IDelegationControl interface\n      (address delegationControl, ) = Systems._get(delegationControlId);\n      requireInterface(delegationControl, DELEGATION_CONTROL_INTERFACE_ID);\n\n      // Call the delegation control contract's init function\n      SystemCall.callWithHooksOrRevert({\n        caller: _msgSender(),\n        systemId: delegationControlId,\n        callData: initCallData,\n        value: 0\n      });\n    }\n  }\n\n  /**\n   * @notice Registers a delegation for a namespace\n   * @dev Sets up a new delegation control for a specific namespace\n   * @param namespaceId The ID of the namespace\n   * @param delegationControlId The ID controlling the delegation\n   * @param initCallData The initialization data for the delegation\n   */\n  function registerNamespaceDelegation(\n    ResourceId namespaceId,\n    ResourceId delegationControlId,\n    bytes memory initCallData\n  ) public {\n    // Require the namespaceId to be a valid namespace ID\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require the delegation to not be unlimited\n    if (!Delegation.isLimited(delegationControlId)) {\n      revert World_UnlimitedDelegationNotAllowed();\n    }\n\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(namespaceId, _msgSender());\n\n    // Require the delegationControl contract to implement the IDelegationControl interface\n    (address delegationControl, ) = Systems._get(delegationControlId);\n    requireInterface(delegationControl, DELEGATION_CONTROL_INTERFACE_ID);\n\n    // Register the delegation control\n    NamespaceDelegationControl._set(namespaceId, delegationControlId);\n\n    // Call the delegation control contract's init function\n    if (initCallData.length > 0) {\n      SystemCall.callWithHooksOrRevert({\n        caller: _msgSender(),\n        systemId: delegationControlId,\n        callData: initCallData,\n        value: 0\n      });\n    }\n  }\n}"
    },
    {
      "filename": "packages/world/src/modules/core/implementations/AccessManagementSystem.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { IModule } from \"../../../IModule.sol\";\nimport { System } from \"../../../System.sol\";\nimport { AccessControl } from \"../../../AccessControl.sol\";\nimport { ResourceId, WorldResourceIdLib } from \"../../../WorldResourceId.sol\";\nimport { ResourceAccess } from \"../../../codegen/tables/ResourceAccess.sol\";\nimport { InstalledModules } from \"../../../codegen/tables/InstalledModules.sol\";\nimport { NamespaceOwner } from \"../../../codegen/tables/NamespaceOwner.sol\";\n\n/**\n * @title Access Management System\n * @dev This contract manages the granting and revoking of access from/to resources.\n */\ncontract AccessManagementSystem is System {\n  /**\n   * @notice Grant access to the resource at the given resource ID.\n   * @dev Requires the caller to own the namespace.\n   * @param resourceId The ID of the resource to grant access to.\n   * @param grantee The address to which access should be granted.\n   */\n  function grantAccess(ResourceId resourceId, address grantee) public virtual {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(resourceId, _msgSender());\n\n    // Grant access to the given resource\n    ResourceAccess._set(resourceId, grantee, true);\n  }\n\n  /**\n   * @notice Revoke access from the resource at the given resource ID.\n   * @dev Requires the caller to own the namespace.\n   * @param resourceId The ID of the resource to revoke access from.\n   * @param grantee The address from which access should be revoked.\n   */\n  function revokeAccess(ResourceId resourceId, address grantee) public virtual {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(resourceId, _msgSender());\n\n    // Revoke access from the given resource\n    ResourceAccess._deleteRecord(resourceId, grantee);\n  }\n\n  /**\n   * @notice Transfer ownership of the given namespace to newOwner and manages the access.\n   * @dev Requires the caller to own the namespace. Revoke ResourceAccess for previous owner and grant to newOwner.\n   * @param namespaceId The ID of the namespace to transfer ownership.\n   * @param newOwner The address to which ownership should be transferred.\n   */\n  function transferOwnership(ResourceId namespaceId, address newOwner) public virtual {\n    // Require the caller to own the namespace\n    AccessControl.requireOwner(namespaceId, _msgSender());\n\n    // Set namespace new owner\n    NamespaceOwner._set(namespaceId, newOwner);\n\n    // Revoke access from old owner\n    ResourceAccess._deleteRecord(namespaceId, _msgSender());\n\n    // Grant access to new owner\n    ResourceAccess._set(namespaceId, newOwner, true);\n  }\n}"
    },
    {
      "filename": "packages/world/src/modules/core/implementations/WorldRegistrationSystem.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { Hook, HookLib } from \"@latticexyz/store/src/Hook.sol\";\nimport { ResourceId, ResourceIdInstance } from \"@latticexyz/store/src/ResourceId.sol\";\nimport { ResourceIds } from \"@latticexyz/store/src/codegen/tables/ResourceIds.sol\";\n\nimport { System } from \"../../../System.sol\";\nimport { WorldContextConsumer, WORLD_CONTEXT_CONSUMER_INTERFACE_ID } from \"../../../WorldContext.sol\";\nimport { WorldResourceIdLib, WorldResourceIdInstance } from \"../../../WorldResourceId.sol\";\nimport { SystemCall } from \"../../../SystemCall.sol\";\nimport { ROOT_NAMESPACE_ID, ROOT_NAME } from \"../../../constants.sol\";\nimport { RESOURCE_NAMESPACE, RESOURCE_SYSTEM } from \"../../../worldResourceTypes.sol\";\nimport { AccessControl } from \"../../../AccessControl.sol\";\nimport { Delegation } from \"../../../Delegation.sol\";\nimport { requireInterface } from \"../../../requireInterface.sol\";\nimport { NamespaceOwner } from \"../../../codegen/tables/NamespaceOwner.sol\";\nimport { ResourceAccess } from \"../../../codegen/tables/ResourceAccess.sol\";\nimport { UserDelegationControl } from \"../../../codegen/tables/UserDelegationControl.sol\";\nimport { NamespaceDelegationControl } from \"../../../codegen/tables/NamespaceDelegationControl.sol\";\nimport { ISystemHook, SYSTEM_HOOK_INTERFACE_ID } from \"../../../ISystemHook.sol\";\nimport { IWorldErrors } from \"../../../IWorldErrors.sol\";\nimport { IDelegationControl, DELEGATION_CONTROL_INTERFACE_ID } from \"../../../IDelegationControl.sol\";\n\nimport { SystemHooks, SystemHooksTableId } from \"../../../codegen/tables/SystemHooks.sol\";\nimport { SystemRegistry } from \"../../../codegen/tables/SystemRegistry.sol\";\nimport { Systems } from \"../../../codegen/tables/Systems.sol\";\nimport { FunctionSelectors } from \"../../../codegen/tables/FunctionSelectors.sol\";\nimport { FunctionSignatures } from \"../../../codegen/tables/FunctionSignatures.sol\";\n\n/**\n * @title WorldRegistrationSystem\n * @dev This contract provides functions related to registering resources other than tables in the World.\n */\ncontract WorldRegistrationSystem is System, IWorldErrors {\n  using ResourceIdInstance for ResourceId;\n  using WorldResourceIdInstance for ResourceId;\n\n  /**\n   * @notice Registers a new namespace\n   * @dev Creates a new namespace resource with the given ID\n   * @param namespaceId The unique identifier for the new namespace\n   */\n  function registerNamespace(ResourceId namespaceId) public virtual {\n    // Require the provided namespace ID to have type RESOURCE_NAMESPACE\n    if (namespaceId.getType() != RESOURCE_NAMESPACE) {\n      revert World_InvalidResourceType(RESOURCE_NAMESPACE, namespaceId, namespaceId.toString());\n    }\n\n    // Require namespace to not exist yet\n    if (ResourceIds._getExists(namespaceId)) {\n      revert World_ResourceAlreadyExists(namespaceId, namespaceId.toString());\n    }\n\n    // Register namespace resource ID\n    ResourceIds._setExists(namespaceId, true);\n\n    // Register caller as the namespace owner\n    NamespaceOwner._set(namespaceId, _msgSender());\n\n    // Give caller access to the new namespace\n    ResourceAccess._set(namespaceId, _msgSender(), true);\n  }\n\n  /**\n   * @notice Registers a new system hook\n   * @dev Adds a new hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being registered\n   * @param enabledHooksBitmap Bitmap indicating which hooks are enabled\n   */\n  function registerSystemHook(ResourceId systemId, ISystemHook hookAddress, uint8 enabledHooksBitmap) public virtual {\n    // Require the provided address to implement the ISystemHook interface\n    requireInterface(address(hookAddress), SYSTEM_HOOK_INTERFACE_ID);\n\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Register the hook\n    SystemHooks.push(systemId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * @notice Unregisters a system hook\n   * @dev Removes a hook for the system at the provided system ID\n   * @param systemId The ID of the system\n   * @param hookAddress The address of the hook being unregistered\n   */\n  function unregisterSystemHook(ResourceId systemId, ISystemHook hookAddress) public virtual {\n    // Require caller to own the namespace\n    AccessControl.requireOwner(systemId, _msgSender());\n\n    // Remove the hook from the list of hooks for this system in the system hooks table\n    HookLib.filterListByAddress(SystemHooksTableId, systemId, address(hookAddress));\n  }\n\n  /**\n   * @notice Registers a system\n   * @dev Registers or upgrades a system at the given ID\n   * If the namespace doesn't exist yet, it is registered.\n   * The system is granted access to its namespace, so it can write to any\n   * table in the same namespace.\n   * If publicAccess is true, no access control check is performed for calling the system.\n   * This function doesn't check whether a system already exists at the given selector,\n   * making it possible to upgrade systems.\n   * @param systemId The unique identifier for the system\n   * @param system The system being registered\n   * @param publicAccess Flag indicating if access control check is bypassed\n   */\n  function registerSystem(ResourceId systemId, WorldContextConsumer system, bool publicAccess) public virtual {\n    // Require the provided system ID to have type RESOURCE_SYSTEM\n    if (systemId.getType() != RESOURCE_SYSTEM) {\n      revert World_InvalidResourceType(RESOURCE_SYSTEM, systemId, systemId.toString());\n    }\n\n    // Require the provided address to implement the WorldContextConsumer interface\n    requireInterface(address(system), WORLD_CONTEXT_CONSUMER_INTERFACE_ID);\n\n    // Require the name to not be the namespace's root name\n    if (systemId.getName() == ROOT_NAME) revert World_InvalidResourceId(systemId, systemId.toString());\n\n    // Require this system to not be registered at a different system ID yet\n    ResourceId existingSystemId = SystemRegistry._get(address(system));\n    if (\n      ResourceId.unwrap(existingSystemId) != 0 && ResourceId.unwrap(existingSystemId) != ResourceId.unwrap(systemId)\n    ) {\n      revert World_SystemAlreadyExists(address(system));\n    }\n\n    // If the namespace doesn't exist yet, register it"
    }
  ]
}