{
  "Title": "M-2: Fee on transfer tokens will break the withdrawing process",
  "Content": "# Issue M-2: Fee on transfer tokens will break the withdrawing process \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/34 \n\n## Found by \nmstpr-brainbot\n## Summary\n If a currency has a built-in transfer fee, withdrawing prime cash may be impossible due to accounting discrepancies.\n## Vulnerability Detail\nExample: Alice has 100 pUSDT, equivalent to 105 USDT, and assume that all the underlying USDT is in Compound V3 (in form of cUSDT), earning interest.\n\nWhen Alice withdraws the prime cash using the `withdraw()` function in `AccountsAction.sol`, the function checks if the corresponding underlying (105 USDT) is available in the contract. Since all the USDT is lent out in Compound, Notional initiates the redemption process. The redemption process attempts to withdraw 105 USDT worth of cUSDT from Compound. However, due to transfer fees on USDT, redeeming 105 USDT worth of cUSDT results in approximately 104.9 USDT. The require check ensures that Notional must withdraw 105 USDT or more, but in reality, only 104.9 USDT is withdrawn, causing the function to revert consistently.\n## Impact\nSince this is an unlikely scenario I'll label it as medium.\n\nHowever, if fee on transfer tokens will be used this can be a high finding since withdrawals will not go through at all. USDT can open it's transfer functionality so that should be also taken into consideration if such thing happens.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/AccountAction.sol#L173\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/balances/TokenHandler.sol#L220-L247\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/balances/TokenHandler.sol#L249-L278\n\nrevert lines\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/balances/TokenHandler.sol#L383\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/balances/TokenHandler.sol#L277\n## Tool used\n\nManual Review\n\n## Recommendation\nInstead of promising the underlying amount on withdrawals, just return the withdrawn pcashs corresponding yield tokens underlying amount and let users endorse the loss\n\n\n\n## Discussion\n\n**jeffywu**\n\nThis is somewhat true, although if this really happened and we needed to manage it the PrimeCashHoldingsOracle could return a lower external balance to account for the transfer fee.\n\n**Jiaren-tang**\n\nEscalate for 10 USDC. fee on transfer is not in scope and this issue should not be a seperate medium\n\nthe onchain context is:\n\n> DEPLOYMENT: Currently Mainnet, considering Arbitrum and Optimisim in the near future.\n> ERC20:  Any Non-Rebasing token. ex. USDC, DAI, USDT (future), wstETH, WETH, WBTC, FRAX, CRV, etc.\n> ERC721: None\n> ERC777: None\n> FEE-ON-TRANSFER: None planned, some support for fee on transfer\n\nclearly none of the supported ERC20 token is fee-on-transfer token\n\nand the protocol clearly indicate \n\n> FEE-ON-TRANSFER: None planned, some support for fee on transfer\n\n**sherlock-admin**\n\n > Escalate for 10 USDC. fee on transfer is not in scope and this issue should not be a seperate medium\n> \n> the onchain context is:\n> \n> > DEPLOYMENT: Currently Mainnet, considering Arbitrum and Optimisim in the near future.\n> > ERC20:  Any Non-Rebasing token. ex. USDC, DAI, USDT (future), wstETH, WETH, WBTC, FRAX, CRV, etc.\n> > ERC721: None\n> > ERC777: None\n> > FEE-ON-TRANSFER: None planned, some support for fee on transfer\n> \n> clearly none of the supported ERC20 token is fee-on-transfer token\n> \n> and the protocol clearly indicate \n> \n> > FEE-ON-TRANSFER: None planned, some support for fee on transfer\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid issue as the readme indicates support of Fee-on-Transfer token is intended. \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ShadowForce](https://github.com/sherlock-audit/2023-03-notional-judging/issues/34/#issuecomment-1570509437): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/external/actions/AccountAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    BalanceState,\n    AccountContext,\n    PortfolioAsset,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\n\nimport {TransferAssets} from \"../../internal/portfolio/TransferAssets.sol\";\nimport {BalanceHandler} from \"../../internal/balances/BalanceHandler.sol\";\nimport {nTokenHandler} from \"../../internal/nToken/nTokenHandler.sol\";\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {AccountContextHandler} from \"../../internal/AccountContextHandler.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {nTokenRedeemAction} from \"./nTokenRedeemAction.sol\";\nimport {SettleAssetsExternal} from \"../SettleAssetsExternal.sol\";\nimport {FreeCollateralExternal} from \"../FreeCollateralExternal.sol\";\nimport {MigrateIncentives} from \"../MigrateIncentives.sol\";\n\ncontract AccountAction is ActionGuards {\n    using BalanceHandler for BalanceState;\n    using AccountContextHandler for AccountContext;\n    using PrimeRateLib for PrimeRate;\n    using SafeInt256 for int256;\n\n    /// @notice A per account setting that allows it to borrow prime cash (i.e. incur negative cash)\n    /// as a result of account initiated actions. Accounts can still incur negative cash as a result of\n    /// fCash settlement regardless of this setting.\n    /// @param allowPrimeBorrow true if the account can borrow prime cash\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    function enablePrimeBorrow(bool allowPrimeBorrow) external {\n        require(msg.sender != address(this)); // dev: no internal call\n        requireValidAccount(msg.sender);\n        (AccountContext memory accountContext, /* didSettle */) = _settleAccountIfRequired(msg.sender);\n        accountContext.allowPrimeBorrow = allowPrimeBorrow;\n        accountContext.setAccountContext(msg.sender);\n    }\n\n    /// @notice Enables a bitmap currency for msg.sender, account cannot have any assets when this call\n    /// occurs. Will revert if the account already has a bitmap currency set.\n    /// @param currencyId the currency to enable the bitmap for.\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    function enableBitmapCurrency(uint16 currencyId) external {\n        require(msg.sender != address(this)); // dev: no internal call to enableBitmapCurrency\n        require(currencyId <= maxCurrencyId); // dev: invalid currency id\n        address account = msg.sender;\n        (AccountContext memory accountContext, /* didSettle */) = _settleAccountIfRequired(account);\n        accountContext.enableBitmapForAccount(currencyId, block.timestamp);\n        accountContext.setAccountContext(account);\n    }\n\n    /// @notice Method for manually settling an account, generally should not be called because other\n    /// methods will check if an account needs to be settled automatically. If a bitmap account has debt\n    /// and is settled via this method, the hasDebt flag will not be cleared until a free collateral check\n    /// is performed on the account.\n    /// @param account the account to settle\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:none\n    /// @return returns true if account has been settled\n    function settleAccount(address account) external returns (bool) {\n        requireValidAccount(account);\n        (AccountContext memory accountContext, bool didSettle) = _settleAccountIfRequired(account);\n        if (didSettle) accountContext.setAccountContext(account);\n        return didSettle;\n    }\n\n    /// @notice Deposits and wraps the underlying token for a particular cToken. Does not settle assets or check free\n    /// collateral, idea is to be as gas efficient as possible during potential liquidation events.\n    /// @param account the account to deposit into\n    /// @param currencyId currency id of the asset token that wraps this underlying\n    /// @param amountExternalPrecision the amount of underlying tokens in its native decimal precision\n    /// (i.e. 18 decimals for DAI or 6 decimals for USDC). This will be converted to 8 decimals during transfer.\n    /// @return asset tokens minted and deposited to the account in internal decimals (8)\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:none\n    function depositUnderlyingToken(\n        address account,\n        uint16 currencyId,\n        uint256 amountExternalPrecision\n    ) external payable nonReentrant returns (uint256) {\n        require(msg.sender != address(this)); // dev: no internal call to deposit underlying\n        requireValidAccount(account);\n\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(account, currencyId, accountContext);\n\n        // NOTE: using msg.sender here allows for a different sender to deposit tokens into\n        // the specified account. This may be useful for on-demand collateral top ups from a\n        // third party.\n        int256 primeCashReceived = balanceState.depositUnderlyingToken(\n            msg.sender,\n            SafeInt256.toInt(amountExternalPrecision),\n            false // there should never be excess ETH here by definition\n        );\n\n        require(primeCashReceived > 0); // dev: asset tokens negative or zero\n\n        balanceState.finalizeNoWithdraw(account, accountContext);\n        accountContext.setAccountContext(account);\n\n        // Check the supply cap after all balances have been finalized\n        balanceState.primeRate.checkSupplyCap(currencyId);\n\n        // NOTE: no free collateral checks required for depositing\n        return primeCashReceived.toUint();\n    }\n\n    /// @notice DEPRECATED: deposits deprecated cTokens tokens as collateral into an account that\n    /// were listed prior to the migration to prime cash. Future listed tokens will not have asset\n    /// tokens and will revert in this method.\n    /// @param account the account to deposit into\n    /// @param currencyId currency id of the asset token\n    /// @param amountExternalPrecision the amount of asset tokens in its native decimal precision\n    /// (i.e. 8 decimals for cTokens).\n    /// @return asset tokens minted and deposited to the account in internal decimals (8)\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:none\n    function depositAssetToken(\n        address account,\n        uint16 currencyId,\n        uint256 amountExternalPrecision\n    ) external nonReentrant returns (uint256) {\n        require(msg.sender != address(this)); // dev: no internal call to deposit asset\n        requireValidAccount(account);\n\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(account, currencyId, accountContext);\n\n        // Int conversion overflow check done inside this method call. msg.sender\n        // is used as the account in deposit to allow for other accounts to deposit\n        // on behalf of the given account. This always does an immediate transfer\n        // and marks the net prime cash change on the balance state.\n        int256 primeCashReceived = balanceState.depositDeprecatedAssetToken(\n            msg.sender,\n            SafeInt256.toInt(amountExternalPrecision)\n        );\n\n        require(primeCashReceived > 0); // dev: asset tokens negative or zero\n\n        balanceState.finalizeNoWithdraw(account, accountContext);\n        accountContext.setAccountContext(account);\n\n        // Check the supply cap after all balances have been finalized\n        balanceState.primeRate.checkSupplyCap(currencyId);\n\n        // NOTE: no free collateral checks required for depositing\n        return primeCashReceived.toUint();\n    }\n\n    /// @notice Withdraws balances from Notional, may also redeem to underlying tokens on user request. Will settle\n    /// and do free collateral checks if required. Can only be called by msg.sender, operators who want to withdraw for\n    /// an account must do an authenticated call via ERC1155Action `safeTransferFrom` or `safeBatchTransferFrom`\n    /// @param currencyId currency id of the asset token\n    /// @param amountInternalPrecision the amount of cash balance in internal 8 decimal precision to withdraw,\n    /// this is be denominated in prime cash. If set to uint88 max, will withdraw an entire cash balance.\n    /// @param redeemToUnderlying DEPRECATED except for ETH balances. Prior to the prime cash upgrade, accounts could withdraw\n    /// cTokens directly. However, post prime cash migration this is no longer the case. If withdrawing ETH, setting redeemToUnderlying\n    /// to false will redeem ETH as WETH.\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    /// @return the amount of tokens received by the account denominated in the destination token precision (if\n    // redeeming to underlying the amount will be the underlying amount received in that token's native precision)\n    function withdraw(\n        uint16 currencyId,\n        uint88 amountInternalPrecision,\n        bool redeemToUnderlying\n    ) external nonReentrant returns (uint256) {\n        if (currencyId != Constants.ETH_CURRENCY_ID) {\n            require(redeemToUnderlying, \"Deprecated: Redeem to cToken\");\n        }\n        // This happens before reading the balance state to get the most up to date cash balance\n        (AccountContext memory accountContext, /* didSettle */) = _settleAccountIfRequired(msg.sender);\n\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(msg.sender, currencyId, accountContext);\n        if (amountInternalPrecision == type(uint88).max) {\n            // if set to uint88 max, withdraw the full stored balance. This feature only\n            // works if there is a positive balance\n            require(balanceState.storedCashBalance > 0);\n            balanceState.primeCashWithdraw = balanceState.storedCashBalance.neg();\n        } else {\n            // Overflow is not possible due to uint88\n            balanceState.primeCashWithdraw = int256(amountInternalPrecision).neg();\n        }\n\n        int256 underlyingWithdrawnExternal = balanceState.finalizeWithWithdraw(\n            msg.sender, accountContext, !redeemToUnderlying\n        );\n\n        accountContext.setAccountContext(msg.sender);\n\n        if (accountContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(msg.sender);\n        }\n\n        require(underlyingWithdrawnExternal <= 0);\n\n        // No need to check supply caps\n        return underlyingWithdrawnExternal.neg().toUint();\n    }\n\n    /// @notice Allows accounts to redeem nTokens into constituent assets and then absorb the assets\n    /// into their portfolio. Due to the complexity here, it is not allowed to be called during a batch trading\n    /// operation and must be done separately.\n    /// @param redeemer the address that holds the nTokens to redeem\n    /// @param currencyId the currency associated the nToken\n    /// @param tokensToRedeem_ the amount of nTokens to convert to cash\n    /// @param sellTokenAssets attempt to sell residual fCash and convert to cash\n    /// @param acceptResidualAssets if true, will place any residual fCash that could not be sold (either due to slippage\n    /// or because it was idiosyncratic) into the account's portfolio\n    /// @dev auth:msg.sender auth:ERC1155\n    /// @return total amount of asset cash redeemed\n    /// @return true or false if there were residuals that were placed into the portfolio\n    function nTokenRedeem(\n        address redeemer,\n        uint16 currencyId,\n        uint96 tokensToRedeem_,\n        bool sellTokenAssets,\n        bool acceptResidualAssets\n    ) external nonReentrant returns (int256, bool) {\n        // ERC1155 can call this method during a post transfer event\n        require(msg.sender == redeemer || msg.sender == address(this), \"Unauthorized caller\");\n        int256 tokensToRedeem = int256(tokensToRedeem_);\n\n        (AccountContext memory context, /* didSettle */) = _settleAccountIfRequired(redeemer);\n\n        BalanceState memory balance;\n        balance.loadBalanceState(redeemer, currencyId, context);\n\n        require(balance.storedNTokenBalance >= tokensToRedeem, \"Insufficient tokens\");\n        balance.netNTokenSupplyChange = tokensToRedeem.neg();\n\n        (int256 totalPrimeCash, PortfolioAsset[] memory assets) = nTokenRedeemAction.redeem(\n            redeemer, currencyId, tokensToRedeem, sellTokenAssets, acceptResidualAssets\n        );\n\n        // Set balances before transferring assets\n        balance.netCashChange = totalPrimeCash;\n        balance.finalizeNoWithdraw(redeemer, context);\n\n        // The hasResidual flag is only set to true if selling residuals has failed, checking\n        // if the length of assets is greater than zero will detect the presence of ifCash\n        // assets that have not been sold.\n        if (assets.length > 0) {\n            // This method will store assets and return the memory location of the new account\n            // context.\n            address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n            context = SettleAssetsExternal.placeAssetsInAccount(redeemer, nTokenAddress, context, assets);\n        }\n\n        context.setAccountContext(redeemer);\n        if (context.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(redeemer);\n        }\n\n        // Do not check supply caps during nToken redemption, no deposits are taken during \n        // redemption so the supply should not change.\n\n        return (totalPrimeCash, assets.length > 0);\n    }\n\n    /// @notice Settle the account if required, returning a reference to the account context. Also\n    /// returns a boolean to indicate if it did settle.\n    function _settleAccountIfRequired(address account)\n        private\n        returns (AccountContext memory, bool)\n    {\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        if (accountContext.mustSettleAssets()) {\n            return (SettleAssetsExternal.settleAccount(account, accountContext), true);\n        } else {\n            return (accountContext, false);\n        }\n    }\n\n    /// @notice Get a list of deployed library addresses (sorted by library name)\n    function getLibInfo() external pure returns (address, address, address, address) {\n        return (\n            address(FreeCollateralExternal),\n            address(MigrateIncentives), \n            address(SettleAssetsExternal), \n            address(nTokenRedeemAction)\n        );\n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/internal/balances/TokenHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    TokenType,\n    TokenStorage,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\n\nimport {CompoundHandler} from \"./protocols/CompoundHandler.sol\";\nimport {GenericToken} from \"./protocols/GenericToken.sol\";\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {IPrimeCashHoldingsOracle, RedeemData} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n    using PrimeRateLib for PrimeRate;\n\n    function getDeprecatedAssetToken(uint256 currencyId) internal view returns (Token memory) {\n        return _getToken(currencyId, false);\n    }\n\n    function getUnderlyingToken(uint256 currencyId) internal view returns (Token memory) {\n        return _getToken(currencyId, true);\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function _getToken(uint256 currencyId, bool underlying) private view returns (Token memory) {\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\n        TokenStorage storage tokenStorage = store[currencyId][underlying];\n\n        return\n            Token({\n                tokenAddress: tokenStorage.tokenAddress,\n                hasTransferFee: tokenStorage.hasTransferFee,\n                // No overflow, restricted on storage\n                decimals: int256(10**tokenStorage.decimalPlaces),\n                tokenType: tokenStorage.tokenType,\n                deprecated_maxCollateralBalance: 0\n            });\n    }\n\n    /// @notice Sets a token for a currency id. After the prime cash migration, only\n    /// underlying tokens may be set by this method.\n    function setToken(uint256 currencyId, TokenStorage memory tokenStorage) internal {\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Hardcoded parameters for ETH just to make sure we don't get it wrong.\n            TokenStorage storage ts = store[currencyId][true];\n            ts.tokenAddress = address(0);\n            ts.hasTransferFee = false;\n            ts.tokenType = TokenType.Ether;\n            ts.decimalPlaces = Constants.ETH_DECIMAL_PLACES;\n\n            return;\n        }\n\n        // Check token address\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = _getToken(currencyId, true);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        require(0 < tokenStorage.decimalPlaces \n            && tokenStorage.decimalPlaces <= Constants.MAX_DECIMAL_PLACES, \"TH: invalid decimals\");\n\n        // Validate token type\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        // Only underlying tokens allowed after migration\n        require(tokenStorage.tokenType == TokenType.UnderlyingToken); // dev: only underlying token\n\n        // Underlying is always true.\n        store[currencyId][true] = tokenStorage;\n    }\n\n    /**\n     * @notice Transfers a deprecated asset token into Notional and redeems it for underlying,\n     * updates prime cash supply and returns the total prime cash to add to the account.\n     * @param assetToken asset token to redeem\n     * @param currencyId the currency id of the token\n     * @param assetAmountExternal the amount to transfer in asset token denomination and external precision\n     * @param primeRate the prime rate for the given currency\n     * @param account the address of the account to transfer from\n     * @return primeCashDeposited the amount of prime cash to mint back to the account\n     */\n    function depositDeprecatedAssetToken(\n        Token memory assetToken,\n        uint16 currencyId,\n        uint256 assetAmountExternal,\n        address account,\n        PrimeRate memory primeRate\n    ) internal returns (int256 primeCashDeposited) {\n        // Transfer the asset token into the contract\n        assetAmountExternal = GenericToken.safeTransferIn(\n            assetToken.tokenAddress, account, assetAmountExternal\n        );\n\n        Token memory underlyingToken = getUnderlyingToken(currencyId);\n        int256 underlyingExternalAmount;\n        // Only cTokens will be listed at the time of the migration. Redeem\n        // those cTokens to underlying (to be held by the Notional contract)\n        // and then run the post transfer update\n        if (assetToken.tokenType == TokenType.cETH) {\n            underlyingExternalAmount = CompoundHandler.redeemCETH(\n                assetToken, assetAmountExternal\n            ).toInt();\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            underlyingExternalAmount = CompoundHandler.redeem(\n                assetToken, underlyingToken, assetAmountExternal\n            ).toInt();\n        } else {\n            // No other asset token variants can be called here.\n            revert();\n        }\n        \n        primeCashDeposited = _postTransferPrimeCashUpdate(\n            account, currencyId, underlyingExternalAmount, underlyingToken, primeRate\n        );\n    }\n\n    /// @notice Deposits an exact amount of underlying tokens to mint the specified amount of prime cash.\n    /// @param account account to transfer tokens from\n    /// @param currencyId the associated currency id\n    /// @param primeCashToMint the amount of prime cash to mint\n    /// @param primeRate the current accrued prime rate\n    /// @param returnNativeTokenWrapped if true, return excess msg.value ETH payments as WETH\n    /// @return actualTransferExternal the actual amount of tokens transferred in external precision\n    function depositExactToMintPrimeCash(\n        address account,\n        uint16 currencyId,\n        int256 primeCashToMint,\n        PrimeRate memory primeRate,\n        bool returnNativeTokenWrapped\n    ) internal returns (int256 actualTransferExternal) {\n        if (primeCashToMint == 0) return 0;\n        require(primeCashToMint > 0);\n        Token memory underlying = getUnderlyingToken(currencyId);\n        int256 netTransferExternal = convertToUnderlyingExternalWithAdjustment(\n            underlying, \n            primeRate.convertToUnderlying(primeCashToMint) \n        );\n\n        (actualTransferExternal, /* */) = depositUnderlyingExternal(\n            account, currencyId, netTransferExternal, primeRate, returnNativeTokenWrapped\n        );\n    }\n\n    /// @notice Deposits an amount of underlying tokens to mint prime cash\n    /// @param account account to transfer tokens from\n    /// @param currencyId the associated currency id\n    /// @param _underlyingExternalDeposit the amount of underlying tokens to deposit\n    /// @param primeRate the current accrued prime rate\n    /// @param returnNativeTokenWrapped if true, return excess msg.value ETH payments as WETH\n    /// @return actualTransferExternal the actual amount of tokens transferred in external precision\n    /// @return netPrimeSupplyChange the amount of prime supply created\n    function depositUnderlyingExternal(\n        address account,\n        uint16 currencyId,\n        int256 _underlyingExternalDeposit,\n        PrimeRate memory primeRate,\n        bool returnNativeTokenWrapped\n    ) internal returns (int256 actualTransferExternal, int256 netPrimeSupplyChange) {\n        uint256 underlyingExternalDeposit = _underlyingExternalDeposit.toUint();\n        if (underlyingExternalDeposit == 0) return (0, 0);\n\n        Token memory underlying = getUnderlyingToken(currencyId);\n        if (underlying.tokenType == TokenType.Ether) {\n            // Underflow checked above\n            if (underlyingExternalDeposit < msg.value) {\n                // Transfer any excess ETH back to the account\n                GenericToken.transferNativeTokenOut(\n                    account, msg.value - underlyingExternalDeposit, returnNativeTokenWrapped\n                );\n            } else {\n                require(underlyingExternalDeposit == msg.value, \"ETH Balance\");\n            }\n\n            actualTransferExternal = _underlyingExternalDeposit;\n        } else {\n            // In the case of deposits, we use a balance before and after check\n            // to ensure that we record the proper balance change.\n            actualTransferExternal = GenericToken.safeTransferIn(\n                underlying.tokenAddress, account, underlyingExternalDeposit\n            ).toInt();\n        }\n\n        netPrimeSupplyChange = _postTransferPrimeCashUpdate(\n            account, currencyId, actualTransferExternal, underlying, primeRate\n        );\n    }\n\n    /// @notice Withdraws an amount of prime cash and returns it to the account as underlying tokens\n    /// @param account account to transfer tokens to\n    /// @param currencyId the associated currency id\n    /// @param primeCashToWithdraw the amount of prime cash to burn\n    /// @param primeRate the current accrued prime rate\n    /// @param withdrawWrappedNativeToken if true, return ETH as WETH\n    /// @return netTransferExternal the amount of underlying tokens withdrawn in native precision, this is\n    /// negative to signify that tokens have left the protocol\n    function withdrawPrimeCash(\n        address account,\n        uint16 currencyId,\n        int256 primeCashToWithdraw,\n        PrimeRate memory primeRate,\n        bool withdrawWrappedNativeToken\n    ) internal returns (int256 netTransferExternal) {\n        if (primeCashToWithdraw == 0) return 0;\n        require(primeCashToWithdraw < 0);\n\n        Token memory underlying = getUnderlyingToken(currencyId);\n        netTransferExternal = convertToExternal(\n            underlying, \n            primeRate.convertToUnderlying(primeCashToWithdraw) \n        );\n\n        // Overflow not possible due to int256\n        uint256 withdrawAmount = uint256(netTransferExternal.neg());\n        _redeemMoneyMarketIfRequired(currencyId, underlying, withdrawAmount);\n\n        if (underlying.tokenType == TokenType.Ether) {\n            GenericToken.transferNativeTokenOut(account, withdrawAmount, withdrawWrappedNativeToken);\n        } else {\n            GenericToken.safeTransferOut(underlying.tokenAddress, account, withdrawAmount);\n        }\n\n        _postTransferPrimeCashUpdate(account, currencyId, netTransferExternal, underlying, primeRate);\n    }\n\n    /// @notice Prime cash holdings may be in underlying tokens or they may be held in other money market\n    /// protocols like Compound, Aave or Euler. If there is insufficient underlying tokens to withdraw on\n    /// the contract, this method will redeem money market tokens in order to gain sufficient underlying\n    /// to withdraw from the contract.\n    /// @param currencyId associated currency id\n    /// @param underlying underlying token information\n    /// @param withdrawAmountExternal amount of underlying to withdraw in external token precision\n    function _redeemMoneyMarketIfRequired(\n        uint16 currencyId,\n        Token memory underlying,\n        uint256 withdrawAmountExternal\n    ) private {\n        // If there is sufficient balance of the underlying to withdraw from the contract\n        // immediately, just return.\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\n        uint256 currentBalance = store[underlying.tokenAddress];\n        if (withdrawAmountExternal <= currentBalance) return;\n\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        // Redemption data returns an array of contract calls to make from the Notional proxy (which\n        // is holding all of the money market tokens).\n        (RedeemData[] memory data) = oracle.getRedemptionCalldata(withdrawAmountExternal);\n\n        // This is the total expected underlying that we should redeem after all redemption calls\n        // are executed.\n        uint256 totalUnderlyingRedeemed = executeMoneyMarketRedemptions(underlying, data);\n\n        // Ensure that we have sufficient funds before we exit\n        require(withdrawAmountExternal <= currentBalance.add(totalUnderlyingRedeemed)); // dev: insufficient redeem\n    }\n\n    /// @notice Every time tokens are transferred into or out of the protocol, the prime supply\n    /// and total underlying held must be updated.\n    function _postTransferPrimeCashUpdate(\n        address account,\n        uint16 currencyId,\n        int256 netTransferUnderlyingExternal,\n        Token memory underlyingToken,\n        PrimeRate memory primeRate\n    ) private returns (int256 netPrimeSupplyChange) {\n        int256 netUnderlyingChange = convertToInternal(underlyingToken, netTransferUnderlyingExternal);\n\n        netPrimeSupplyChange = primeRate.convertFromUnderlying(netUnderlyingChange);\n\n        Emitter.emitMintOrBurnPrimeCash(account, currencyId, netPrimeSupplyChange);\n        PrimeCashExchangeRate.updateTotalPrimeSupply(currencyId, netPrimeSupplyChange, netUnderlyingChange);\n\n        _updateNetStoredTokenBalance(underlyingToken.tokenAddress, netTransferUnderlyingExternal);\n    }\n\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\n        // If token decimals > INTERNAL_TOKEN_PRECISION:\n        //  on deposit: resulting dust will accumulate to protocol\n        //  on withdraw: protocol may lose dust amount. However, withdraws are only calculated based\n        //    on a conversion from internal token precision to external token precision so therefore dust\n        //    amounts cannot be specified for withdraws.\n        // If token decimals < INTERNAL_TOKEN_PRECISION then this will add zeros to the\n        // end of amount and will not result in dust.\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\n    }\n\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        // If token decimals > INTERNAL_TOKEN_PRECISION then this will increase amount\n        // by adding a number of zeros to the end and will not result in dust.\n        // If token decimals < INTERNAL_TOKEN_PRECISION:\n        //  on deposit: Deposits are specified in external token precision and there is no loss of precision when\n        //      tokens are converted from external to internal precision\n        //  on withdraw: this calculation will round down such that the protocol retains the residual cash balance\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    /// @notice Converts a token to an underlying external amount with adjustments for rounding errors when depositing\n    function convertToUnderlyingExternalWithAdjustment(\n        Token memory token,\n        int256 underlyingInternalAmount\n    ) internal pure returns (int256 underlyingExternalAmount) {\n        if (token.decimals < Constants.INTERNAL_TOKEN_PRECISION) {\n            // If external < 8, we could truncate down and cause an off by one error, for example we need\n            // 1.00000011 cash and we deposit only 1.000000, missing 11 units. Therefore, we add a unit at the\n            // lower precision (external) to get around off by one errors\n            underlyingExternalAmount = convertToExternal(token, underlyingInternalAmount).add(1);\n        } else {\n            // If external > 8, we may not mint enough asset tokens because in the case of 1e18 precision \n            // an off by 1 error at 1e8 precision is 1e10 units of the underlying token. In this case we\n            // add 1 at the internal precision which has the effect of rounding up by 1e10\n            underlyingExternalAmount = convertToExternal(token, underlyingInternalAmount.add(1));\n        }\n    }\n\n    /// @notice Convenience method for getting the balance using a token object\n    function balanceOf(Token memory token, address account) internal view returns (uint256) {\n        if (token.tokenType == TokenType.Ether) {\n            return account.balance;\n        } else {\n            return IERC20(token.tokenAddress).balanceOf(account);\n        }\n    }\n\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\n        GenericToken.safeTransferOut(Deployments.NOTE_TOKEN_ADDRESS, account, tokensToTransfer);\n    }\n\n    /// @notice It is critical that this method measures and records the balanceOf changes before and after\n    /// every token change. If not, then external donations can affect the valuation of pCash and pDebt\n    /// tokens which may be exploitable.\n    /// @param redeemData parameters from the prime cash holding oracle\n    function executeMoneyMarketRedemptions(\n        Token memory underlyi"
    }
  ]
}