{
  "Title": "[22] Alpha period code is still in production despite the period ending in April 2023",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/common/Config.sol#L35-L39\n\n```solidity\n/// @dev The amount of time in seconds the validator has to process the priority transaction\n/// NOTE: The constant is set to zero for the Alpha release period\n//@audit this is still 0?\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n\n```\n\nEvidently, the PRIORITY_EXPIRATION is set to zero, but this is meant for the Alpha release period which ended in April, now consider https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L258-L287\n\n```solidity\n    function _requestL2Transaction(\n        uint256 _mintValue,\n        WritePriorityOpParams memory _params,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n\n\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, _params.l2GasPricePerPubdata);\n        uint256 baseCost = _params.l2GasPrice * _params.l2GasLimit;\n        require(_mintValue >= baseCost + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _params.refundRecipient == address(0) ? _params.sender : _params.refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n        _params.refundRecipient = refundRecipient;\n\n\n        // populate missing fields\n        //@audit\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        _params.valueToMint = _mintValue;\n\n\n        canonicalTxHash = _writePriorityOp(_params, _calldata, _factoryDeps);\n    }\n```\n\nWe can see that the deadline parameter uses this value \"PRIORITY_EXPIRATION\" to determine the deadline for the validators to process this transaction, but the value being 0 would mean that all transaction would use the timestamp the transaction was requested, which would be logically flawed.\n\n### Impact\n\nOutdated code still in production.\n\n### Recommended Mitigation Steps\n\nSince the Alpha release period has passed, the necessary value for `PRIORITY_EXPIRATION`should be passed and stored in `Config.sol`\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/common/Config.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\n/// @dev `keccak256(\"\")`\nbytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n/// @dev Bytes in raw L2 log\n/// @dev Equal to the bytes size of the tuple - (uint8 ShardId, bool isService, uint16 txNumberInBatch, address sender,\n/// bytes32 key, bytes32 value)\nuint256 constant L2_TO_L1_LOG_SERIALIZE_SIZE = 88;\n\n/// @dev The maximum length of the bytes array with L2 -> L1 logs\nuint256 constant MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512;\n\n/// @dev The value of default leaf hash for L2 -> L1 logs Merkle tree\n/// @dev An incomplete fixed-size tree is filled with this value to be a full binary tree\n/// @dev Actually equal to the `keccak256(new bytes(L2_TO_L1_LOG_SERIALIZE_SIZE))`\nbytes32 constant L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH = 0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba;\n\n// TODO: change constant to the real root hash of empty Merkle tree (SMA-184)\nbytes32 constant DEFAULT_L2_LOGS_TREE_ROOT_HASH = bytes32(0);\n\n/// @dev Denotes the type of the zkSync transaction that came from L1.\nuint256 constant PRIORITY_OPERATION_L2_TX_TYPE = 255;\n\n/// @dev Denotes the type of the zkSync transaction that is used for system upgrades.\nuint256 constant SYSTEM_UPGRADE_L2_TX_TYPE = 254;\n\n/// @dev The maximal allowed difference between protocol versions in an upgrade. The 100 gap is needed\n/// in case a protocol version has been tested on testnet, but then not launched on mainnet, e.g.\n/// due to a bug found.\nuint256 constant MAX_ALLOWED_PROTOCOL_VERSION_DELTA = 100;\n\n/// @dev The amount of time in seconds the validator has to process the priority transaction\n/// NOTE: The constant is set to zero for the Alpha release period\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n\n/// @dev Timestamp - seconds since unix epoch.\nuint256 constant COMMIT_TIMESTAMP_NOT_OLDER = 3 days;\n\n/// @dev Maximum available error between real commit batch timestamp and analog used in the verifier (in seconds)\n/// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 12 seconds)\nuint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 1 hours;\n\n/// @dev Shift to apply to verify public input before verifying.\nuint256 constant PUBLIC_INPUT_SHIFT = 32;\n\n/// @dev The maximum number of L2 gas that a user can request for an L2 transaction\nuint256 constant MAX_GAS_PER_TRANSACTION = $(MAX_GAS_PER_TRANSACTION);\n\n/// @dev Even though the price for 1 byte of pubdata is 16 L1 gas, we have a slightly increased\n/// value.\nuint256 constant L1_GAS_PER_PUBDATA_BYTE = $(L1_GAS_PER_PUBDATA_BYTE);\n\n/// @dev The intrinsic cost of the L1->l2 transaction in computational L2 gas\nuint256 constant L1_TX_INTRINSIC_L2_GAS = $(L1_TX_INTRINSIC_L2_GAS);\n\n/// @dev The intrinsic cost of the L1->l2 transaction in pubdata\nuint256 constant L1_TX_INTRINSIC_PUBDATA = $(L1_TX_INTRINSIC_PUBDATA);\n\n/// @dev The minimal base price for L1 transaction\nuint256 constant L1_TX_MIN_L2_GAS_BASE = $(L1_TX_MIN_L2_GAS_BASE);\n\n/// @dev The number of L2 gas the transaction starts costing more with each 544 bytes of encoding\nuint256 constant L1_TX_DELTA_544_ENCODING_BYTES = $(L1_TX_DELTA_544_ENCODING_BYTES);\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_L2_GAS = $(L1_TX_DELTA_FACTORY_DEPS_L2_GAS);\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_PUBDATA = $(L1_TX_DELTA_FACTORY_DEPS_PUBDATA);\n\n/// @dev The number of pubdata an L1->L2 transaction requires with each new factory dependency\nuint256 constant MAX_NEW_FACTORY_DEPS = $(MAX_NEW_FACTORY_DEPS);\n\n/// @dev The L2 gasPricePerPubdata required to be used in bridges.\nuint256 constant REQUIRED_L2_GAS_PRICE_PER_PUBDATA = $(REQUIRED_L2_GAS_PRICE_PER_PUBDATA);\n\n/// @dev The mask which should be applied to the packed batch and L2 block timestamp in order\n/// to obtain the L2 block timestamp. Applying this mask is equivalent to calculating modulo 2**128\nuint256 constant PACKED_L2_BLOCK_TIMESTAMP_MASK = 0xffffffffffffffffffffffffffffffff;\n\n/// @dev Address of the point evaluation precompile used for EIP-4844 blob verification.\naddress constant POINT_EVALUATION_PRECOMPILE_ADDR = address(0x0A);\n\n/// @dev The overhead for a transaction slot in L2 gas.\n/// It is roughly equal to 80kk/MAX_TRANSACTIONS_IN_BATCH, i.e. how many gas would an L1->L2 transaction\n/// need to pay to compensate for the batch being closed.\n/// @dev It is expected that the L1 contracts will enforce that the L2 gas price will be high enough to compensate\n/// the operator in case the batch is closed because of tx slots filling up.\nuint256 constant TX_SLOT_OVERHEAD_L2_GAS = 10000;\n\n/// @dev The overhead for each byte of the bootloader memory that the encoding of the transaction.\n/// It is roughly equal to 80kk/BOOTLOADER_MEMORY_FOR_TXS, i.e. how many gas would an L1->L2 transaction\n/// need to pay to compensate for the batch being closed.\n/// @dev It is expected that the L1 contracts will enforce that the L2 gas price will be high enough to compensate\n/// the operator in case the batch is closed because of the memory for transactions being filled up.\nuint256 constant MEMORY_OVERHEAD_GAS = 10;\n\naddress constant ETH_TOKEN_ADDRESS = address(1);\n\n/// @dev Era's chainID\nuint256 constant ERA_CHAIN_ID = $(ERA_CHAIN_ID);\n\n/// @dev The address of legacy L1 ERC20 bridge.\naddress constant ERA_ERC20_BRIDGE_ADDRESS = $(ERA_ERC20_BRIDGE_ADDRESS);\n\n/// @dev The address of zkSync Era diamond proxy contract.\naddress constant ERA_DIAMOND_PROXY = $(ERA_DIAMOND_PROXY);\n\nbytes32 constant TWO_BRIDGES_MAGIC_VALUE = bytes32(uint256(keccak256(\"TWO_BRIDGES_MAGIC_VALUE\")) - 1);\n\n/// @dev https://eips.ethereum.org/EIPS/eip-1352\naddress constant BRIDGEHUB_MIN_SECOND_BRIDGE_ADDRESS = address(uint160(type(uint16).max));"
    },
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IMailbox} from \"../../chain-interfaces/IMailbox.sol\";\nimport {Merkle} from \"../../libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../../libraries/PriorityQueue.sol\";\nimport {TransactionValidator} from \"../../libraries/TransactionValidator.sol\";\nimport {WritePriorityOpParams, L2CanonicalTransaction, L2Message, L2Log, TxStatus, BridgehubL2TransactionRequest} from \"../../../common/Messaging.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../ZkSyncStateTransitionStorage.sol\";\nimport {UncheckedMath} from \"../../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../../common/libraries/UnsafeBytes.sol\";\nimport {L2ContractHelper} from \"../../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../../vendor/AddressAliasHelper.sol\";\nimport {ZkSyncStateTransitionBase} from \"./ZkSyncStateTransitionBase.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, L1_GAS_PER_PUBDATA_BYTE, L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, PRIORITY_OPERATION_L2_TX_TYPE, PRIORITY_EXPIRATION, MAX_NEW_FACTORY_DEPS, ETH_TOKEN_ADDRESS, ERA_CHAIN_ID} from \"../../../common/Config.sol\";\nimport {L2_BOOTLOADER_ADDRESS, L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR, L2_BASE_TOKEN_SYSTEM_CONTRACT_ADDR} from \"../../../common/L2ContractAddresses.sol\";\n\nimport {IBridgehub} from \"../../../bridgehub/IBridgehub.sol\";\nimport {IL1SharedBridge} from \"../../../bridge/interfaces/IL1SharedBridge.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZkSyncStateTransitionBase} from \"../../chain-interfaces/IZkSyncStateTransitionBase.sol\";\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is ZkSyncStateTransitionBase, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @inheritdoc IZkSyncStateTransitionBase\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @inheritdoc IMailbox\n    function transferEthToSharedBridge() external onlyBaseTokenBridge {\n        require(s.chainId == ERA_CHAIN_ID, \"transferEthToSharedBridge only available for Era on mailbox\");\n\n        uint256 amount = address(this).balance;\n        address sharedBridgeAddress = s.baseTokenBridge;\n        IL1SharedBridge(sharedBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n    }\n\n    /// @notice when requesting transactions through the bridgehub\n    function bridgehubRequestL2Transaction(\n        BridgehubL2TransactionRequest memory _request\n    ) external payable onlyBridgehub returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2TransactionSender(_request);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @inheritdoc IMailbox\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @inheritdoc IMailbox\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public view returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in ETH to be paid.\n    /// @param _l1GasPrice The gas price on L1\n    /// @param _gasPerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in ETH\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPerPubdata) internal view returns (uint256) {\n        FeeParams memory feeParams = s.feeParams;\n        require(s.baseTokenGasPriceMultiplierDenominator > 0, \"Mailbox: baseTokenGasPriceDenominator not set\");\n        uint256 l1GasPriceConverted = (_l1GasPrice * s.baseTokenGasPriceMultiplierNominator) /\n            s.baseTokenGasPriceMultiplierDenominator;\n        uint256 pubdataPriceBaseToken;\n        if (feeParams.pubdataPricingMode == PubdataPricingMode.Rollup) {\n            pubdataPriceBaseToken = L1_GAS_PER_PUBDATA_BYTE * l1GasPriceConverted;\n        }\n\n        uint256 batchOverheadBaseToken = uint256(feeParams.batchOverheadL1Gas) * l1GasPriceConverted;\n        uint256 fullPubdataPriceBaseToken = pubdataPriceBaseToken +\n            batchOverheadBaseToken /\n            uint256(feeParams.maxPubdataPerBatch);\n\n        uint256 l2GasPrice = feeParams.minimalL2GasPrice + batchOverheadBaseToken / uint256(feeParams.maxL2GasPerBatch);\n        uint256 minL2GasPriceBaseToken = (fullPubdataPriceBaseToken + _gasPerPubdata - 1) / _gasPerPubdata;\n\n        return Math.max(l2GasPrice, minL2GasPriceBaseToken);\n    }\n\n    /// @inheritdoc IMailbox\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(s.chainId == ERA_CHAIN_ID, \"finalizeEthWithdrawal only available for Era on mailbox\");\n        IL1SharedBridge(s.baseTokenBridge).finalizeWithdrawal(\n            ERA_CHAIN_ID,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _message,\n            _merkleProof\n        );\n    }\n\n    ///  @inheritdoc IMailbox\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, \"legacy interface only available for era token\");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n    function _requestL2TransactionSender(\n        BridgehubL2TransactionRequest memory _request\n    ) internal nonReentrant returns (bytes32 canonicalTxHash) {\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        address l2Sender = _request.sender;\n        if (l2Sender != tx.origin) {\n            l2Sender = AddressAliasHelper.applyL1ToL2Alias(_request.sender);\n        }\n\n        // Enforcing that `_request.l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using \"exotic\" numbers for _request.l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_request.l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_request.l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, \"qp\");\n\n        // Here we manually assign fields for the struct to prevent \"stack too deep\" error\n        WritePriorityOpParams memory params;\n\n        params.sender = l2Sender;\n        params.l2Value = _request.l2Value;\n        params.contractAddressL2 = _request.contractL2;\n        params.l2GasLimit = _request.l2GasLimit;\n        params.l2GasPricePerPubdata = _request.l2GasPerPubdataByteLimit;\n        params.refundRecipient = _request.refundRecipient;\n\n        canonicalTxHash = _requestL2Transaction(_request.mintValue, params, _request.l2Calldata, _request.factoryDeps);\n    }\n\n    function _requestL2Transaction(\n        uint256 _mintValue,\n        WritePriorityOpParams memory _params,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, _params.l2GasPricePerPubdata);\n        uint256 baseCost = _params.l2GasPrice * _params.l2GasLimit;\n        require(_mintValue >= baseCost + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _params.refundRecipient == address(0) ? _params.sender : _params.refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n        _params.refundRecipient = refundRecipient;\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        _params.valueToMint = _mintValue;\n\n        canonicalTxHash = _writePriorityOp(_params, _calldata, _factoryDeps);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(_priorityOpParams.sender)),\n            to: uint256(uint160(_priorityOpParams.contractAddressL2)),\n            gasLimit: _priorityOpParams.l2GasLimit,\n            gasPerPubdataByteLimit: _priorityOpParams.l2GasPricePerPubdata,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: _priorityOpParams.l2Value,\n            reserved: [_priorityOpParams.valueToMint, uint256(uint160(_priorityOpParams.refundRecipient)), 0, 0],\n            data: _calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(_factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams, _calldata, _factoryDeps);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            transaction,\n            transactionEncoding,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] memory _factoryDeps) internal pure returns (uint256[] memory hashedFactoryDeps) {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}"
    }
  ]
}