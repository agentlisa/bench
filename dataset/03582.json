{
  "Title": "[C01] Instant withdrawals can disable essential vault functionality",
  "Content": "When users deposit some amount of asset into a vault, their newly deposited asset are considered *pending* until the beginning of the vault’s next round. While pending, deposits are not being actively managed by the vault, and they are, appropriately, intentionally disregarded for many of the vaults internal accounting purposes. Pending deposits do not share in profits or losses of the vault while pending and they should not be included in the determination of the vault’s price per share. Vaults keep a running count of the total pending asset in the [`vaultState.totalPending`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/Vault.sol#L43) state variable so that they can actively disregard all of the pending asset where appropriate, and also so that they can mark all of the pending asset as active when the next round starts.\n\n\nDelta vaults provide a [`withdrawInstantly`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L194) function, which permits users to withdraw asset, including any pending asset, at any time. However, this function fails to update `vaultState.totalPending`, even after the user has withdrawn some amount of pending asset. As a consequence, for any sequence of deposits that are followed by instant withdrawals during the same round, `vaultState.totalPending` will only ever increase. This results in a mismatch between the number that is stored in `vaultState.totalPending` and the actual amount of pending asset the vault possesses.\n\n\nThis has far-reaching ramifications, because so many of the calculations in the vault are affected, including:\n\n\n* The [`balance`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L620) calculation within the [`pricePerShare`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L619) function of `RibbonVault`\n* The [`pps`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L573) calculation in `accountVaultBalance` of `RibbonVault`\n* The [`roundStartBalance`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L121) calculation in the `rollover` function of `VaultLifecycle`\n\n\nIn many cases, [OpenZeppelin’s `SafeMath`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.2/contracts/math/SafeMath.sol) is used to subtract the value of `vaultState.totalPending` from the *total* asset balance held by the vault, to exclude the former from being counted as active. This approach is reasonable and accurate, as long as `vaultState.totalPending` reflects the *actual* amount of pending asset in the vault. However, since `vaultState.totalPending` is never decremented when pending asset is withdrawn, it can become larger than the total balance. When this happens, many of the internal arithmetic operations of the vault overflow and then revert.\n\n\nIn this scenario, users can still withdraw funds, but the vault cannot carry out many other essential functions, including rolling to the next option. The only way to recover complete functionality would be to replace the logic of the Delta vault via an upgrade.\n\n\nIt is important to note that this critical loss of functionality can easily arise as a result of normal vault activity.\n\n\nHowever, there is another scenario that could play out that stems from the failure to decrement `vaultState.totalPending` correctly. That scenario would probably be less likely to happen during the normal operation of the vault, but it can result in all user funds being locked in the vault. It would be trivial for a malicious party to put the vault in such a state.\n\n\nIn fact, this state can easily be achieved by performing the following steps immediately after an `oToken` auction ends:\n\n\n1. Deposit an amount of asset equal to the current balance held by the vault (using a flash loan if needed).\n2. Perform an instant withdrawal of all the funds that were just deposited. Then, because of the failure to decrement, `vaultState.totalPending` would be equal to the current balance of the vault.\n3. Call the [`claimAuctionOtokens`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L308) function, which would force a reevaluation of the price per share because of its [`updatePPS`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L136) modifier.\n\n\nWhile updating the price per share, the `roundStartBalance` would incorrectly be set to `0` because of the [subtraction of `pendingAmount` from the `currentBalance`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L148) of the vault. When the modifier calls the [`getPPS`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L510) function in `VaultLifecycle`, the price per share is derived from [a multiplication of the `roundStartBalance`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L517), always returning `0` under these conditions.\n\n\nWhenever `roundPricePerShare` is equal to `0`, withdrawals will fail due to `require` statements in the `ShareMath` library’s [`underlyingToShares`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/ShareMath.sol#L21) and [`sharesToUnderlying`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/ShareMath.sol#L38) functions that are called as part of every withdrawal. All user funds will be locked in the vault.\n\n\nConsider decrementing `vaultState.totalPending` correctly whenever any amount of pending asset is withdrawn from a vault. Also consider expanding the test suite to cover more complicated deposit and withdrawal scenarios.\n\n\n**Update**: *Fixed in commit [`f882323642c23f02965adfa378a6b062e0ca65ce` of PR#79](https://github.com/ribbon-finance/ribbon-v2/pull/79/commits/f882323642c23f02965adfa378a6b062e0ca65ce).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\n\nlibrary Vault {\n    struct VaultParams {\n        // Option type the vault is selling\n        bool isPut;\n        // Token decimals for vault shares\n        uint8 decimals;\n        // Asset used in Theta / Delta Vault\n        address asset;\n        // Underlying asset of the options sold by vault\n        address underlying;\n        // Minimum supply of the vault shares issued, for ETH it's 10**10\n        uint56 minimumSupply;\n        // Vault cap\n        uint104 cap;\n        // If migrating from existing vault, allows for smooth migration\n        uint256 initialSharePrice;\n    }\n\n    struct OptionState {\n        // Option that the vault is shorting / longing in the next cycle\n        address nextOption;\n        // Option that the vault is currently shorting / longing\n        address currentOption;\n        // The timestamp when the `nextOption` can be used by the vault\n        uint32 nextOptionReadyAt;\n    }\n\n    struct VaultState {\n        // 32 byte slot 1\n        //  Current round number. `round` represents the number of `period`s elapsed.\n        uint16 round;\n        // Amount that is currently locked for selling options\n        uint104 lockedAmount;\n        // Amount that was locked for selling options in the previous round\n        // used for calculating performance fee deduction\n        uint104 lastLockedAmount;\n        // 32 byte slot 2\n        // Stores the total tally of how much of collateral there is\n        // to be used to mint rTHETA tokens\n        uint128 totalPending;\n        // Amount locked for scheduled withdrawals;\n        uint128 queuedWithdrawShares;\n    }\n\n    struct DepositReceipt {\n        // Flag to mark if processed or not\n        bool processed;\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\n        uint16 round;\n        // Deposit amount, max 20,282,409,603,651 or 20 trillion ETH deposit\n        uint104 amount;\n        // Unredeemed shares balance\n        uint128 unredeemedShares;\n    }\n\n    struct Withdrawal {\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\n        uint16 round;\n        // Number of shares withdrawn\n        uint128 shares;\n    }\n\n    struct AuctionSellOrder {\n        // Amount of `asset` token offered in auction\n        uint96 sellAmount;\n        // Amount of oToken requested in auction\n        uint96 buyAmount;\n        // User Id of delta vault in latest gnosis auction\n        uint64 userId;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/RibbonDeltaVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {DSMath} from \"../vendor/DSMath.sol\";\nimport {GnosisAuction} from \"../libraries/GnosisAuction.sol\";\nimport {OptionsDeltaVaultStorage} from \"../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\nimport {IRibbonThetaVault} from \"../interfaces/IRibbonThetaVault.sol\";\nimport {IGnosisAuction} from \"../interfaces/IGnosisAuction.sol\";\n\ncontract RibbonDeltaVault is RibbonVault, DSMath, OptionsDeltaVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenLong(\n        address indexed options,\n        uint256 purchaseAmount,\n        uint256 premium,\n        address manager\n    );\n\n    event CloseLong(\n        address indexed options,\n        uint256 profitAmount,\n        address manager\n    );\n\n    event NewOptionAllocationSet(\n        uint256 optionAllocationPct,\n        uint256 newOptionAllocationPct\n    );\n\n    event InstantWithdraw(address indexed account, uint256 share, uint16 round);\n\n    event PlaceAuctionBid(\n        uint256 auctionId,\n        address auctioningToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        address bidder\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction\n        )\n    {}\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function initialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        address _counterpartyThetaVault,\n        uint256 _optionAllocationPct,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n        require(\n            _counterpartyThetaVault != address(0),\n            \"!_counterpartyThetaVault\"\n        );\n        require(\n            IRibbonThetaVault(_counterpartyThetaVault).vaultParams().asset ==\n                vaultParams.asset,\n            \"!_counterpartyThetaVault: asset\"\n        );\n        require(\n            _optionAllocationPct > 0 && _optionAllocationPct < 10000,\n            \"!_optionAllocationPct\"\n        );\n        counterpartyThetaVault = IRibbonThetaVault(_counterpartyThetaVault);\n        optionAllocationPct = _optionAllocationPct;\n    }\n\n    /**\n     * @notice Updates the price per share of the current round. The current round\n     * pps will change right after call rollToNextOption as the gnosis auction contract\n     * takes custody of a % of `asset` tokens, and right after we claim the tokens from\n     * the action as we may recieve some of `asset` tokens back alongside the oToken,\n     * depending on the gnosis auction outcome. Finally it will change at the end of the week\n     * if the oTokens are ITM\n     */\n    modifier updatePPS(bool isWithdraw) {\n        if (!isWithdraw) {\n            _;\n        }\n\n        if (\n            !isWithdraw ||\n            roundPricePerShare[vaultState.round] <= PLACEHOLDER_UINT\n        ) {\n            uint256 pendingAmount = uint256(vaultState.totalPending);\n            uint256 currentBalance =\n                IERC20(vaultParams.asset).balanceOf(address(this));\n            uint256 roundStartBalance = currentBalance.sub(pendingAmount);\n\n            uint256 singleShare = 10**uint256(vaultParams.decimals);\n            roundPricePerShare[vaultState.round] = VaultLifecycle.getPPS(\n                totalSupply(),\n                roundStartBalance,\n                singleShare,\n                vaultParams.initialSharePrice\n            );\n        }\n\n        if (isWithdraw) {\n            _;\n        }\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new % allocation of funds towards options purchases ( 3 decimals. ex: 55 * 10 ** 2 is 55%)\n     * @param newOptionAllocationPct is the option % allocation\n     */\n    function setOptionAllocation(uint16 newOptionAllocationPct)\n        external\n        onlyOwner\n    {\n        // Needs to be less than 10%\n        require(\n            newOptionAllocationPct > 0 && newOptionAllocationPct < 1000,\n            \"Invalid allocation\"\n        );\n\n        emit NewOptionAllocationSet(\n            optionAllocationPct,\n            newOptionAllocationPct\n        );\n\n        optionAllocationPct = newOptionAllocationPct;\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param share is the amount of shares to withdraw\n     */\n    function withdrawInstantly(uint256 share)\n        external\n        updatePPS(true)\n        nonReentrant\n    {\n        require(share > 0, \"!shares\");\n\n        uint256 sharesLeftForWithdrawal = _withdrawFromNewDeposit(share);\n\n        uint16 currentRound = vaultState.round;\n\n        // If we need to withdraw beyond current round deposit\n        if (sharesLeftForWithdrawal > 0) {\n            (uint256 heldByAccount, uint256 heldByVault) =\n                shareBalances(msg.sender);\n\n            require(\n                sharesLeftForWithdrawal <= heldByAccount.add(heldByVault),\n                \"Insufficient balance\"\n            );\n\n            if (heldByAccount < sharesLeftForWithdrawal) {\n                // Redeem all shares custodied by vault to user\n                _redeem(0, true);\n            }\n\n            // Burn shares\n            _burn(msg.sender, sharesLeftForWithdrawal);\n        }\n\n        emit InstantWithdraw(msg.sender, share, currentRound);\n\n        uint256 sharesToUnderlying =\n            ShareMath.sharesToUnderlying(\n                share,\n                roundPricePerShare[vaultState.round],\n                vaultParams.decimals\n            );\n        transferAsset(msg.sender, sharesToUnderlying);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Closes the existing long position for the vault.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external onlyOwner updatePPS(true) nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        address counterpartyNextOption =\n            counterpartyThetaVault.optionState().nextOption;\n        require(counterpartyNextOption != address(0), \"!thetavaultclosed\");\n        optionState.nextOption = counterpartyNextOption;\n        optionState.nextOptionReadyAt = uint32(block.timestamp.add(delay));\n\n        optionState.currentOption = address(0);\n        vaultState.lastLockedAmount = balanceBeforePremium;\n\n        // redeem\n        if (oldOption != address(0)) {\n            uint256 profitAmount =\n                VaultLifecycle.settleLong(\n                    GAMMA_CONTROLLER,\n                    oldOption,\n                    vaultParams.asset\n                );\n            emit CloseLong(oldOption, profitAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new long position.\n     * @param optionPremium is the premium per token to pay in `asset`.\n       Same decimals as `asset` (ex: 1 * 10 ** 8 means 1 WBTC per oToken)\n     */\n    function rollToNextOption(uint256 optionPremium)\n        external\n        onlyOwner\n        updatePPS(false)\n        nonReentrant\n    {\n        (address newOption, uint256 lockedBalance) = _rollToNextOption();\n\n        balanceBeforePremium = uint104(lockedBalance);\n\n        GnosisAuction.BidDetails memory bidDetails;\n\n        bidDetails.auctionId = counterpartyThetaVault.optionAuctionID();\n        bidDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        bidDetails.oTokenAddress = newOption;\n        bidDetails.asset = vaultParams.asset;\n        bidDetails.assetDecimals = vaultParams.decimals;\n        bidDetails.lockedBalance = lockedBalance;\n        bidDetails.optionAllocationPct = optionAllocationPct;\n        bidDetails.optionPremium = optionPremium;\n        bidDetails.bidder = msg.sender;\n\n        // place bid\n        (uint256 sellAmount, uint256 buyAmount, uint64 userId) =\n            VaultLifecycle.placeBid(bidDetails);\n\n        auctionSellOrder.sellAmount = uint96(sellAmount);\n        auctionSellOrder.buyAmount = uint96(buyAmount);\n        auctionSellOrder.userId = userId;\n\n        emit OpenLong(newOption, buyAmount, sellAmount, msg.sender);\n    }\n\n    /**\n     * @notice Claims the delta vault's oTokens from latest auction\n     */\n    function claimAuctionOtokens() external updatePPS(false) nonReentrant {\n        VaultLifecycle.claimAuctionOtokens(\n            auctionSellOrder,\n            GNOSIS_EASY_AUCTION,\n            address(counterpartyThetaVault)\n        );\n    }\n\n    /**\n     * @notice Withdraws from the most recent deposit which has not been processed\n     * @param share is how many shares to withdraw in total\n     * @return the shares left to withdraw\n     */\n    function _withdrawFromNewDeposit(uint256 share) private returns (uint256) {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        // Immediately get what is in the pending deposits, without need for checking pps\n        if (\n            depositReceipt.round == vaultState.round &&\n            depositReceipt.amount > 0\n        ) {\n            uint256 receiptShares =\n                ShareMath.underlyingToShares(\n                    depositReceipt.amount,\n                    roundPricePerShare[depositReceipt.round],\n                    vaultParams.decimals\n                );\n            uint256 sharesWithdrawn = min(receiptShares, share);\n            // Subtraction underflow checks already ensure it is smaller than uint104\n            depositReceipt.amount = uint104(\n                ShareMath.sharesToUnderlying(\n                    uint256(receiptShares).sub(sharesWithdrawn),\n                    roundPricePerShare[depositReceipt.round],\n                    vaultParams.decimals\n                )\n            );\n            return share.sub(sharesWithdrawn);\n        }\n\n        return share;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/base/RibbonVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {OptionsVaultStorage} from \"../../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {IOtoken} from \"../../interfaces/GammaInterface.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IGnosisAuction} from \"../../interfaces/IGnosisAuction.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../../interfaces/IRibbon.sol\";\n\ncontract RibbonVault is OptionsVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    address public immutable WETH;\n    address public immutable USDC;\n\n    uint256 public constant delay = 1 hours;\n\n    uint256 public constant period = 7 days;\n\n    uint128 internal constant PLACEHOLDER_UINT = 1;\n\n    // Number of weeks per year = 52.142857 weeks * 10**6 = 52142857\n    // Dividing by weeks per year requires doing num.mul(10**6).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(address account, uint256 shares, uint256 round);\n\n    event Redeem(address indexed account, uint256 share, uint16 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap, address manager);\n\n    event Withdraw(address account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    ) {\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_gnosisEasyAuction != address(0), \"!_gnosisEasyAuction\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n\n        WETH = _weth;\n        USDC = _usdc;\n        GAMMA_CONTROLLER = _gammaController;\n        MARGIN_POOL = _marginPool;\n        GNOSIS_EASY_AUCTION = _gnosisEasyAuction;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function baseInitialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) internal initializer {\n        VaultLifecycle.verifyConstructorParams(\n            _owner,\n            _feeRecipient,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(tokenName, tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n\n        feeRecipient = _feeRecipient;\n        performanceFee = _performanceFee;\n        managementFee = _managementFee.mul(10**6).div(WEEKS_PER_YEAR);\n        vaultParams = _vaultParams;\n        vaultState.lastLockedAmount = uint104(\n            IERC20(vaultParams.asset).balanceOf(address(this))\n        );\n\n        vaultState.round = 1;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(newManagementFee < 100 * 10**6, \"Invalid management fee\");\n\n        emit ManagementFeeSet(managementFee, newManagementFee);\n\n        // We are dividing annualized management fee by num weeks in a year\n        managementFee = newManagementFee.mul(10**6).div(WEEKS_PER_YEAR);\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(newPerformanceFee < 100 * 10**6, \"Invalid performance fee\");\n\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint104 newCap) external onlyOwner {\n        require(newCap > 0, \"!newCap\");\n        uint256 oldCap = vaultParams.cap;\n        vaultParams.cap = newCap;\n        emit CapSet(oldCap, newCap, msg.sender);\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Deposits ETH into the contract and mint vault shares. Reverts if the asset is not WETH.\n     */\n    function depositETH() external payable nonReentrant {\n        require(vaultParams.asset == WETH, \"!WETH\");\n        require(msg.value > 0, \"!value\");\n\n        _depositFor(msg.value, msg.sender);\n\n        IWETH(WETH).deposit{value: msg.value}();\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        _depositFor(amount, msg.sender);\n\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function depositFor(uint256 amount, address creditor)\n        external\n        nonReentrant\n    {\n        require(amount > 0, \"!amount\");\n        require(creditor != address(0));\n\n        _depositFor(amount, creditor);\n\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function _depositFor(uint256 amount, address creditor) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount = totalBalance().add(amount);\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"Exceed cap\");\n        require(\n            totalWithDepositedAmount >= vaultParams.minimumSupply,\n            \"Insufficient balance\"\n        );\n\n        emit Deposit(creditor, amount, currentRound);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        uint256 depositAmount = uint104(amount);\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount).add(amount);\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            processed: false,\n            round: uint16(currentRound),\n            amount: uint104(depositAmount),\n            unredeemedShares: unredeemedShares\n        });\n\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).add(amount)\n        );\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param shares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint128 shares) external nonReentrant {\n        require(shares > 0, \"!shares\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        bool topup = withdrawal.round == currentRound;\n\n        emit InitiateWithdraw(msg.sender, shares, currentRound);\n\n        uint256 withdrawalShares = uint256(withdrawal.shares);\n\n        if (topup) {\n            uint256 increasedShares = withdrawalShares.add(shares);\n            ShareMath.assertUint128(increasedShares);\n            withdrawals[msg.sender].shares = uint128(increasedShares);\n        } else if (withdrawalShares == 0) {\n            withdrawals[msg.sender].shares = shares;\n            withdrawals[msg.sender].round = uint16(currentRound);\n        } else {\n            // If we have an old withdrawal, we revert\n            // The user has to process the withdrawal\n            revert(\"Existing withdraw\");\n        }\n\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).add(shares)\n        );\n\n        _transfer(msg.sender, address(this), shares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"Not initiated\");\n\n        require(withdrawalRound < vaultState.round, \"Round not closed\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawals[msg.sender].shares = 0;\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).sub(withdrawalShares)\n        );\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToUnderlying(\n                withdrawalShares,\n                roundPricePerShare[uint16(withdrawalRound)],\n                vaultParams.decimals\n            );\n\n        emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        require(withdrawAmount > 0, \"!withdrawAmount\");\n        transferAsset(msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param shares is the number of shares to redeem\n     */\n    function redeem(uint256 shares) external nonReentrant {\n        require(shares > 0, \"!shares\");\n        _redeem(shares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param shares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 shares, bool isMax) internal {\n        ShareMath.assertUint104(shares);\n\n        Vault.DepositReceipt memory depositReceipt =\n            depositReceipts[msg.sender];\n\n        // This handles the null case when depositReceipt.round = 0\n        // Because we start with round = 1 at `initialize`\n        uint16 currentRound = vaultState.round;\n        require(depositReceipt.round < currentRound, \"Round not closed\");\n\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        shares = isMax ? unredeemedShares : shares;\n        require(shares > 0, \"!shares\");\n        require(shares <= unredeemedShares, \"Exceeds available\");\n\n        // This zeroes out any pending amount from depositReceipt\n        depositReceipts[msg.sender].amount = 0;\n        depositReceipts[msg.sender].processed = true;\n        depositReceipts[msg.sender].unredeemedShares = uint128(\n            uint256(unredeemedShares).sub(shares)\n        );\n\n        emit Redeem(msg.sender, shares, depositReceipt.round);\n\n        _transfer(address(this), msg.sender, shares);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /*\n     * @notice Helper function that helps to save gas for writing values into the roundPricePerShare map.\n     *         Writing `1` into the map makes subsequent writes warm, reducing the gas from 20k to 5k.\n     *         Having 1 initialized beforehand will not be an issue as long as we round down share calculations to 0.\n     * @param numRounds is the number of rounds to initialize in the map\n     */\n    function initRounds(uint256 numRounds) external nonReentrant {\n        require(numRounds < 52, \"numRounds >= 52\");\n\n        uint16 _round = vaultState.round;\n        for (uint16 i = 0; i < numRounds; i++) {\n            uint16 index = _round + i;\n            require(index >= _round, \"Overflow\");\n            require(roundPricePerShare[index] == 0, \"Initialized\"); // AVOID OVERWRITING ACTUAL VALUES\n            roundPricePerShare[index] = PLACEHOLDER_UINT;\n        }\n    }\n\n    /*\n     * @notice Helper function that performs most administrative tasks\n     * such as setting next option, minting new shares, getting vault fees, etc.\n     * @return newOption is the new option address\n     * @return lockedBalance is the new balance used to calculate next option purchase size or collateral size\n     */\n    function _rollToNextOption() internal returns (address, uint256) {\n        require(block.timestamp >= optionState.nextOptionReadyAt, \"!ready\");\n\n        address newOption = optionState.nextOption;\n        require(newOption != address(0), \"!nextOption\");\n\n        (uint256 lockedBalance, uint256 newPricePerShare, uint256 mintShares) =\n            VaultLifecycle.rollover(\n                totalSupply(),\n                vaultParams.asset,\n                vaultParams.decimals,\n                vaultParams.initialSharePrice,\n                uint256(vaultState.totalPending),\n                vaultState.queuedWithdrawShares\n            );\n\n        optionState.currentOption = newOption;\n        optionState.nextOption = address(0);\n\n        // Finalize the pricePerShare at the end of the round\n        uint16 currentRound = vaultState.round;\n        roundPricePerShare[currentRound] = newPricePerShare;\n\n        // Take management / performance fee from previous round and deduct\n        lockedBalance = lockedBalance.sub(_collectVaultFees(lockedBalance));\n\n        vaultState.totalPending = 0;\n        vaultState.round = currentRound + 1;\n\n        _mint(address(this), mintShares);\n\n        return (newOption, lockedBalance);\n    }\n\n    /*\n     * @notice Helper function that transfers management fees and performance f"
    }
  ]
}