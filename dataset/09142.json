{
  "Title": "[L-04] `pragma experimental ABIEncoderV2` is deprecated",
  "Content": "\nUse `pragma abicoder v2` [instead](https://github.com/ethereum/solidity/blob/69411436139acf5dbcfc5828446f18b9fcfee32c/docs/080-breaking-changes.rst#silent-changes-of-the-semantics)\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/AuraLocker.sol   #1\n\n3:   pragma experimental ABIEncoderV2;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L3>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "docs/080-breaking-changes.rst",
      "content": "********************************\nSolidity v0.8.0 Breaking Changes\n********************************\n\nThis section highlights the main breaking changes introduced in Solidity\nversion 0.8.0.\nFor the full list check\n`the release changelog <https://github.com/ethereum/solidity/releases/tag/v0.8.0>`_.\n\nSilent Changes of the Semantics\n===============================\n\nThis section lists changes where existing code changes its behaviour without\nthe compiler notifying you about it.\n\n* Arithmetic operations revert on underflow and overflow. You can use ``unchecked { ... }`` to use\n  the previous wrapping behaviour.\n\n  Checks for overflow are very common, so we made them the default to increase readability of code,\n  even if it comes at a slight increase of gas costs.\n\n* ABI coder v2 is activated by default.\n\n  You can choose to use the old behaviour using ``pragma abicoder v1;``.\n  The pragma ``pragma experimental ABIEncoderV2;`` is still valid, but it is deprecated and has no effect.\n  If you want to be explicit, please use ``pragma abicoder v2;`` instead.\n\n  Note that ABI coder v2 supports more types than v1 and performs more sanity checks on the inputs.\n  ABI coder v2 makes some function calls more expensive and it can also make contract calls\n  revert that did not revert with ABI coder v1 when they contain data that does not conform to the\n  parameter types.\n\n* Exponentiation is right associative, i.e., the expression ``a**b**c`` is parsed as ``a**(b**c)``.\n  Before 0.8.0, it was parsed as ``(a**b)**c``.\n\n  This is the common way to parse the exponentiation operator.\n\n* Failing assertions and other internal checks like division by zero or arithmetic overflow do\n  not use the invalid opcode but instead the revert opcode.\n  More specifically, they will use error data equal to a function call to ``Panic(uint256)`` with an error code specific\n  to the circumstances.\n\n  This will save gas on errors while it still allows static analysis tools to distinguish\n  these situations from a revert on invalid input, like a failing ``require``.\n\n* If a byte array in storage is accessed whose length is encoded incorrectly, a panic is caused.\n  A contract cannot get into this situation unless inline assembly is used to modify the raw representation of storage byte arrays.\n\n* If constants are used in array length expressions, previous versions of Solidity would use arbitrary precision\n  in all branches of the evaluation tree. Now, if constant variables are used as intermediate expressions,\n  their values will be properly rounded in the same way as when they are used in run-time expressions.\n\n* The type ``byte`` has been removed. It was an alias of ``bytes1``.\n\nNew Restrictions\n================\n\nThis section lists changes that might cause existing contracts to not compile anymore.\n\n* There are new restrictions related to explicit conversions of literals. The previous behaviour in\n  the following cases was likely ambiguous:\n\n  1. Explicit conversions from negative literals and literals larger than ``type(uint160).max`` to\n     ``address`` are disallowed.\n  2. Explicit conversions between literals and an integer type ``T`` are only allowed if the literal\n     lies between ``type(T).min`` and ``type(T).max``. In particular, replace usages of ``uint(-1)``\n     with ``type(uint).max``.\n  3. Explicit conversions between literals and enums are only allowed if the literal can\n     represent a value in the enum.\n  4. Explicit conversions between literals and ``address`` type (e.g. ``address(literal)``) have the\n     type ``address`` instead of ``address payable``. One can get a payable address type by using an\n     explicit conversion, i.e., ``payable(literal)``.\n\n* :ref:`Address literals<address_literals>` have the type ``address`` instead of ``address\n  payable``. They can be converted to ``address payable`` by using an explicit conversion, e.g.\n  ``payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)``.\n\n* There are new restrictions on explicit type conversions. The conversion is only allowed when there\n  is at most one change in sign, width or type-category (``int``, ``address``, ``bytesNN``, etc.).\n  To perform multiple changes, use multiple conversions.\n\n  Let us use the notation ``T(S)`` to denote the explicit conversion ``T(x)``, where, ``T`` and\n  ``S`` are types, and ``x`` is any arbitrary variable of type ``S``. An example of such a\n  disallowed conversion would be ``uint16(int8)`` since it changes both width (8 bits to 16 bits)\n  and sign (signed integer to unsigned integer). In order to do the conversion, one has to go\n  through an intermediate type. In the previous example, this would be ``uint16(uint8(int8))`` or\n  ``uint16(int16(int8))``. Note that the two ways to convert will produce different results e.g.,\n  for ``-1``. The following are some examples of conversions that are disallowed by this rule.\n\n  - ``address(uint)`` and ``uint(address)``: converting both type-category and width. Replace this by\n    ``address(uint160(uint))`` and ``uint(uint160(address))`` respectively.\n  - ``payable(uint160)``, ``payable(bytes20)`` and ``payable(integer-literal)``: converting both\n    type-category and state-mutability. Replace this by ``payable(address(uint160))``,\n    ``payable(address(bytes20))`` and ``payable(address(integer-literal))`` respectively. Note that\n    ``payable(0)`` is valid and is an exception to the rule.\n  - ``int80(bytes10)`` and ``bytes10(int80)``: converting both type-category and sign. Replace this by\n    ``int80(uint80(bytes10))`` and ``bytes10(uint80(int80)`` respectively.\n  - ``Contract(uint)``: converting both type-category and width. Replace this by\n    ``Contract(address(uint160(uint)))``.\n\n  These conversions were disallowed to avoid ambiguity. For example, in the expression ``uint16 x =\n  uint16(int8(-1))``, the value of ``x`` would depend on whether the sign or the width conversion\n  was applied first.\n\n* Function call options can only be given once, i.e. ``c.f{gas: 10000}{value: 1}()`` is invalid and has to be changed to ``c.f{gas: 10000, value: 1}()``.\n\n* The global functions ``log0``, ``log1``, ``log2``, ``log3`` and ``log4`` have been removed.\n\n  These are low-level functions that were largely unused. Their behaviour can be accessed from inline assembly.\n\n* ``enum`` definitions cannot contain more than 256 members.\n\n  This will make it safe to assume that the underlying type in the ABI is always ``uint8``.\n\n* Declarations with the name ``this``, ``super`` and ``_`` are disallowed, with the exception of\n  public functions and events. The exception is to make it possible to declare interfaces of contracts\n  implemented in languages other than Solidity that do permit such function names.\n\n* Remove support for the ``\\b``, ``\\f``, and ``\\v`` escape sequences in code.\n  They can still be inserted via hexadecimal escapes, e.g. ``\\x08``, ``\\x0c``, and ``\\x0b``, respectively.\n\n* The global variables ``tx.origin`` and ``msg.sender`` have the type ``address`` instead of\n  ``address payable``. One can convert them into ``address payable`` by using an explicit\n  conversion, i.e., ``payable(tx.origin)`` or ``payable(msg.sender)``.\n\n  This change was done since the compiler cannot determine whether or not these addresses\n  are payable or not, so it now requires an explicit conversion to make this requirement visible.\n\n* Explicit conversion into ``address`` type always returns a non-payable ``address`` type. In\n  particular, the following explicit conversions have the type ``address`` instead of ``address\n  payable``:\n\n  - ``address(u)`` where ``u`` is a variable of type ``uint160``. One can convert ``u``\n    into the type ``address payable`` by using two explicit conversions, i.e.,\n    ``payable(address(u))``.\n  - ``address(b)`` where ``b`` is a variable of type ``bytes20``. One can convert ``b``\n    into the type ``address payable`` by using two explicit conversions, i.e.,\n    ``payable(address(b))``.\n  - ``address(c)`` where ``c`` is a contract. Previously, the return type of this\n    conversion depended on whether the contract can receive Ether (either by having a receive\n    function or a payable fallback function). The conversion ``payable(c)`` has the type ``address\n    payable`` and is only allowed when the contract ``c`` can receive Ether. In general, one can\n    always convert ``c`` into the type ``address payable`` by using the following explicit\n    conversion: ``payable(address(c))``. Note that ``address(this)`` falls under the same category\n    as ``address(c)`` and the same rules apply for it.\n\n* The ``chainid`` builtin in inline assembly is now considered ``view`` instead of ``pure``.\n\n* Unary negation cannot be used on unsigned integers anymore, only on signed integers.\n\nInterface Changes\n=================\n\n* The output of ``--combined-json`` has changed: JSON fields ``abi``, ``devdoc``, ``userdoc`` and\n  ``storage-layout`` are sub-objects now. Before 0.8.0 they used to be serialised as strings.\n\n* The \"legacy AST\" has been removed (``--ast-json`` on the commandline interface and ``legacyAST`` for standard JSON).\n  Use the \"compact AST\" (``--ast-compact--json`` resp. ``AST``) as replacement.\n\n* The old error reporter (``--old-reporter``) has been removed.\n\n\nHow to update your code\n=======================\n\n- If you rely on wrapping arithmetic, surround each operation with ``unchecked { ... }``.\n- Optional: If you use SafeMath or a similar library, change ``x.add(y)`` to ``x + y``, ``x.mul(y)`` to ``x * y`` etc.\n- Add ``pragma abicoder v1;`` if you want to stay with the old ABI coder.\n- Optionally remove ``pragma experimental ABIEncoderV2`` or ``pragma abicoder v2`` since it is redundant.\n- Change ``byte`` to ``bytes1``.\n- Add intermediate explicit type conversions if required.\n- Combine ``c.f{gas: 10000}{value: 1}()`` to ``c.f{gas: 10000, value: 1}()``.\n- Change ``msg.sender.transfer(x)`` to ``payable(msg.sender).transfer(x)`` or use a stored variable of ``address payable`` type.\n- Change ``x**y**z`` to ``(x**y)**z``.\n- Use inline assembly as a replacement for ``log0``, ..., ``log4``.\n- Negate unsigned integers by subtracting them from the maximum value of the type and adding 1 (e.g. ``type(uint256).max - x + 1``, while ensuring that `x` is not zero)"
    },
    {
      "filename": "contracts/AuraLocker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\nimport { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from \"./AuraMath.sol\";\nimport \"./Interfaces.sol\";\n\ninterface IRewardStaking {\n    function stakeFor(address, uint256) external;\n}\n\n/**\n * @title   AuraLocker\n * @author  ConvexFinance\n * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available\n *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes\n *          to depositors.\n * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.\n */\ncontract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {\n    using AuraMath for uint256;\n    using AuraMath224 for uint224;\n    using AuraMath112 for uint112;\n    using AuraMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    /* ==========     STRUCTS     ========== */\n\n    struct RewardData {\n        /// Timestamp for current period finish\n        uint32 periodFinish;\n        /// Last time any user took action\n        uint32 lastUpdateTime;\n        /// RewardRate for the rest of the period\n        uint96 rewardRate;\n        /// Ever increasing rewardPerToken rate, based on % of total supply\n        uint96 rewardPerTokenStored;\n    }\n    struct UserData {\n        uint128 rewardPerTokenPaid;\n        uint128 rewards;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Balances {\n        uint112 locked;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint32 unlockTime;\n    }\n    struct Epoch {\n        uint224 supply;\n        uint32 date; //epoch start date\n    }\n    struct DelegateeCheckpoint {\n        uint224 votes;\n        uint32 epochStart;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Rewards\n    address[] public rewardTokens;\n    uint256 public queuedCvxCrvRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    //     Core reward data\n    mapping(address => RewardData) public rewardData;\n    //     Reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n    //     User -> reward token -> amount\n    mapping(address => mapping(address => UserData)) public userData;\n    //     Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n    //     Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // Balances\n    //     Supplies and historic supply\n    uint256 public lockedSupply;\n    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply\n    Epoch[] public epochs;\n    //     Mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    // Voting\n    //     Stored delegations\n    mapping(address => address) private _delegates;\n    //     Checkpointed votes\n    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;\n    //     Delegatee balances (user -> unlock timestamp -> amount)\n    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;\n\n    // Config\n    //     Tokens\n    IERC20 public immutable stakingToken;\n    address public immutable cvxCrv;\n    //     Denom for calcs\n    uint256 public constant denominator = 10000;\n    //     Staking cvxCrv\n    address public immutable cvxcrvStaking;\n    //     Incentives\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 3;\n    //     Shutdown\n    bool public isShutdown = false;\n\n    // Basic token data\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== EVENTS ========== */\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateCheckpointed(address indexed delegate);\n\n    event Recovered(address _token, uint256 _amount);\n    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);\n    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);\n    event RewardAdded(address indexed _token, uint256 _reward);\n\n    event KickIncentiveSet(uint256 rate, uint256 delay);\n    event Shutdown();\n\n    /***************************************\n                    CONSTRUCTOR\n    ****************************************/\n\n    /**\n     * @param _nameArg          Token name, simples\n     * @param _symbolArg        Token symbol\n     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)\n     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)\n     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)\n     */\n    constructor(\n        string memory _nameArg,\n        string memory _symbolArg,\n        address _stakingToken,\n        address _cvxCrv,\n        address _cvxCrvStaking\n    ) Ownable() {\n        _name = _nameArg;\n        _symbol = _symbolArg;\n        _decimals = 18;\n\n        stakingToken = IERC20(_stakingToken);\n        cvxCrv = _cvxCrv;\n        cvxcrvStaking = _cvxCrvStaking;\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));\n    }\n\n    /***************************************\n                    MODIFIER\n    ****************************************/\n\n    modifier updateReward(address _account) {\n        {\n            Balances storage userBalance = balances[_account];\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i = 0; i < rewardTokensLength; i++) {\n                address token = rewardTokens[i];\n                uint256 newRewardPerToken = _rewardPerToken(token);\n                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();\n                if (_account != address(0)) {\n                    userData[_account][token] = UserData({\n                        rewardPerTokenPaid: newRewardPerToken.to128(),\n                        rewards: _earned(_account, token, userBalance.locked).to128()\n                    });\n                }\n            }\n        }\n        _;\n    }\n\n    /***************************************\n                    ADMIN\n    ****************************************/\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(address _rewardsToken, address _distributor) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0, \"Reward already exists\");\n        require(_rewardsToken != address(stakingToken), \"Cannot add StakingToken as reward\");\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0, \"Reward does not exist\");\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n\n        emit KickIncentiveSet(_rate, _delay);\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[_tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    // Set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);\n    }\n\n    /***************************************\n                    ACTIONS\n    ****************************************/\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount);\n    }\n\n    //lock tokens\n    function _lock(address _account, uint256 _amount) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //add user balances\n        uint112 lockAmount = _amount.to112();\n        bal.locked = bal.locked.add(lockAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(_amount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n        }\n\n        address delegatee = delegates(_account);\n        if (delegatee != address(0)) {\n            delegateeUnlocks[delegatee][unlockTime] += lockAmount;\n            _checkpointDelegate(delegatee, lockAmount, 0);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(lockAmount);\n\n        emit Staked(_account, lockAmount, lockAmount);\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i < rewardTokensLength; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = userData[_account][_rewardsToken].rewards;\n            if (reward > 0) {\n                userData[_account][_rewardsToken].rewards = 0;\n                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n        //check to add\n        if (epochs[epochindex - 1].date < currentEpoch) {\n            //fill any epoch gaps until the next epoch date.\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);\n                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));\n            }\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));\n    }\n\n    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown\n    function emergencyWithdraw() external nonReentrant {\n        require(isShutdown, \"Must be shutdown\");\n\n        LockedBalance[] memory locks = userLocks[msg.sender];\n        Balances storage userBalance = balances[msg.sender];\n\n        uint256 amt = userBalance.locked;\n        require(amt > 0, \"Nothing locked\");\n\n        userBalance.locked = 0;\n        userBalance.nextUnlockIndex = locks.length.to32();\n        lockedSupply -= amt;\n\n        emit Withdrawn(msg.sender, amt, false);\n\n        stakingToken.safeTransfer(msg.sender, amt);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n        uint256 expiryTime = _checkDelay == 0 && _relock\n            ? block.timestamp.add(rewardsDuration)\n            : block.timestamp.sub(_checkDelay);\n        require(length > 0, \"no locks\");\n        // e.g. now = 16\n        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)\n        // e.g. 17 <= (16 + 1)\n        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay > 0) {\n                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);\n                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i < length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime > expiryTime) break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay > 0) {\n                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);\n                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked > 0, \"no exp locks\");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        lockedSupply = lockedSupply.sub(locked);\n\n        //checkpoint the delegatee\n        _checkpointDelegate(delegates(_account), 0, 0);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward > 0) {\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            stakingToken.safeTransfer(_rewardAddress, reward);\n            emit KickReward(_rewardAddress, _account, reward);\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_account, locked);\n        } else {\n            stakingToken.safeTransfer(_account, locked);\n        }\n    }\n\n    /***************************************\n            DELEGATION & VOTE BALANCE\n    ****************************************/\n\n    /**\n     * @dev Delegate votes from the sender to `newDelegatee`.\n     */\n    function delegate(address newDelegatee) external virtual nonReentrant {\n        // Step 1: Get lock data\n        LockedBalance[] storage locks = userLocks[msg.sender];\n        uint256 len = locks.length;\n        require(len > 0, \"Nothing to delegate\");\n        require(newDelegatee != address(0), \"Must delegate to someone\");\n\n        // Step 2: Update delegatee storage\n        address oldDelegatee = delegates(msg.sender);\n        require(newDelegatee != oldDelegatee, \"Must choose new delegatee\");\n        _delegates[msg.sender] = newDelegatee;\n\n        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);\n\n        // Step 3: Move balances around\n        //         Delegate for the upcoming epoch\n        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);\n        uint256 i = len - 1;\n        uint256 futureUnlocksSum = 0;\n        LockedBalance memory currentLock = locks[i];\n        // Step 3.1: Add future unlocks and sum balances\n        while (currentLock.unlockTime > upcomingEpoch) {\n            futureUnlocksSum += currentLock.amount;\n\n            if (oldDelegatee != address(0)) {\n                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;\n            }\n            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;\n\n            if (i > 0) {\n                i--;\n                currentLock = locks[i];\n            } else {\n                break;\n            }\n        }\n\n        // Step 3.2: Checkpoint old delegatee\n        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);\n\n        // Step 3.3: Checkpoint new delegatee\n        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);\n    }\n\n    function _checkpointDelegate(\n        address _account,\n        uint256 _upcomingAddition,\n        uint256 _upcomingDeduction\n    ) internal {\n        // This would only skip on first checkpointing\n        if (_account != address(0)) {\n            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);\n            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];\n            if (ckpts.length > 0) {\n                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];\n                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks\n                if (prevCkpt.epochStart == upcomingEpoch) {\n                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({\n                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),\n                        epochStart: upcomingEpoch.to32()\n                    });\n                }\n                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired\n                // e.g. week 1 + 17 <= 18\n                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {\n                    ckpts.push(\n                        DelegateeCheckpoint({\n                            votes: (_upcomingAddition - _upcomingDeduction).to224(),\n                            epochStart: upcomingEpoch.to32()\n                        })\n                    );\n                } else {\n                    uint256 nextEpoch = upcomingEpoch;\n                    uint256 unlocksSinceLatestCkpt = 0;\n                    // Should be maximum 18 iterations\n                    while (nextEpoch > prevCkpt.epochStart) {\n                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];\n                        nextEpoch -= rewardsDuration;\n                    }\n                    ckpts.push(\n                        DelegateeCheckpoint({\n                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)\n                                .to224(),"
    }
  ]
}