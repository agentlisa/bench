{
  "Title": "M-23: `deleverageAccount` can still be called when a vault is paused",
  "Content": "# Issue M-23: `deleverageAccount` can still be called when a vault is paused \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/17 \n\n## Found by \nArbitrary-Execution\n\n## Summary\n`deleverageAccount` can still be called when a vault is paused\n\n## Vulnerability Detail\nEvery vault has an `ENABLED` flag that can be toggled on an off, and is used to prevent certain vault account functions from being called in `VaultAccountAction.sol` when a vault is 'Paused'; these functions include: `enterVault` and `rollVaultPosition`. However, `deleverageAccount` is still able to be called even when a vault is paused.\n\n## Impact\nWhen the `ENABLED` flag is not set, meaning a vault is paused, liquidators will still be able to liquidate vault account positions. However, users are still able to call `exitVault` to either fully exit their position or lower their collateral ratio if necessary to avoid liquidation.\n\n## Code Snippet\nhttps://github.com/notional-finance/contracts-v2/blob/cf05d8e3e4e4feb0b0cef2c3f188c91cdaac38e0/contracts/external/actions/VaultAccountAction.sol#L261\n\nFailing test (add to `tests/stateful/vaults/test_vault_deleverage.py`):\n```python3\ndef test_deleverage_paused(environment, accounts, vault):\n    environment.notional.updateVault(\n        vault.address,\n        get_vault_config(currencyId=2, flags=set_flags(0, ENABLED=False)),\n        100_000_000e8,\n    )\n    maturity = environment.notional.getActiveMarkets(1)[0][1]\n\n    environment.notional.enterVault(\n        accounts[1], vault.address, 25_000e18, maturity, 100_000e8, 0, \"\", {\"from\": accounts[1]}\n    )\n    vault.setExchangeRate(0.85e18)\n    (cr, _, _) = environment.notional.getVaultAccountCollateralRatio(accounts[1], vault)\n    assert cr < 0.2e9\n\n    # would expect this call to revert when a vault is paused\n    with brownie.reverts(\"Cannot Enter\"):\n        environment.notional.deleverageAccount(\n            accounts[1], vault.address, accounts[2], 25_000e18, False, \"\", {\"from\": accounts[2]}\n        )\n```\n\n## Tool used\nManual Review\n\n## Recommendation\nConsider adding the following require statement to `deleverageAccount`:\n\n```solidity\nrequire(vaultConfig.getFlag(VaultConfiguration.ENABLED), \"Cannot Enter\");\n```\n\n## Discussion\n\n**jeffywu**\n\n@T-Woodward we can consider adding this, in general we like to allow liquidations to occur regardless but it's possible that we may need to disable deleverage due to some potential vulnerability.\n\n**T-Woodward**\n\nYes I still think it's riskier to disable deleveraging in a pause scenario. I suppose we could add a third state \"pause with no liquidations\" or something if you want to @jeffywu .\n\n**jeffywu**\n\nYes, I think adding a separate pause state will be worthwhile.\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "contracts/external/actions/VaultAccountAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {IVaultAccountAction} from \"../../../interfaces/notional/IVaultController.sol\";\nimport \"../../internal/vaults/VaultConfiguration.sol\";\nimport \"../../internal/vaults/VaultAccount.sol\";\nimport {VaultStateLib, VaultState} from \"../../internal/vaults/VaultState.sol\";\nimport {TokenHandler, Token, AaveHandler} from \"../../internal/balances/TokenHandler.sol\";\n\ncontract VaultAccountAction is ActionGuards, IVaultAccountAction {\n    using VaultConfiguration for VaultConfig;\n    using VaultAccountLib for VaultAccount;\n    using VaultStateLib for VaultState;\n    using AssetRate for AssetRateParameters;\n    using TokenHandler for Token;\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n\n    /// @notice Borrows a specified amount of fCash in the vault's borrow currency and deposits it\n    /// all plus the depositAmountExternal into the vault to mint strategy tokens.\n    /// @param account the address that will enter the vault\n    /// @param vault the vault to enter\n    /// @param depositAmountExternal some amount of additional collateral in the borrowed currency\n    /// to be transferred to vault\n    /// @param maturity the maturity to borrow at\n    /// @param fCash amount to borrow\n    /// @param maxBorrowRate maximum interest rate to borrow at\n    /// @param vaultData additional data to pass to the vault contract\n    /// @return strategyTokensAdded the total strategy tokens added to the maturity, including any tokens\n    /// from settlement. Allows enterVault to be used by off-chain methods to get an accurate simulation\n    /// of the strategy tokens minted.\n    function enterVault(\n        address account,\n        address vault,\n        uint256 depositAmountExternal,\n        uint256 maturity,\n        uint256 fCash,\n        uint32 maxBorrowRate,\n        bytes calldata vaultData\n    ) external payable override nonReentrant returns (uint256 strategyTokensAdded) { \n        // Ensure that system level accounts cannot enter vaults\n        requireValidAccount(account);\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        vaultConfig.authorizeCaller(account, VaultConfiguration.ONLY_VAULT_ENTRY);\n\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        // Vaults cannot be entered if they are paused or matured\n        require(vaultConfig.getFlag(VaultConfiguration.ENABLED), \"Cannot Enter\");\n        require(block.timestamp < maturity, \"Cannot Enter\");\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vault);\n\n        uint256 strategyTokens;\n        if (vaultAccount.maturity != 0 && vaultAccount.maturity <= block.timestamp) {\n            // These strategy tokens will be transferred to the new maturity\n            strategyTokens = vaultAccount.settleVaultAccount(vaultConfig, block.timestamp);\n        }\n\n        // Deposits some amount of underlying tokens into the vault directly to serve as additional collateral when\n        // entering the vault.\n        uint256 additionalUnderlyingExternal = vaultConfig.transferUnderlyingToVaultDirect(account, depositAmountExternal);\n        strategyTokensAdded = vaultAccount.borrowAndEnterVault(\n            vaultConfig, maturity, fCash, maxBorrowRate, vaultData, strategyTokens, additionalUnderlyingExternal\n        );\n\n        emit VaultEnterPosition(vault, account, maturity, fCash);\n    }\n\n    /// @notice Re-enters the vault at a longer dated maturity. The account's existing borrow position will be closed\n    /// and a new borrow position at the specified maturity will be opened. Strategy token holdings will transfer to\n    /// the longer dated maturity.\n    /// @param account the address that will reenter the vault\n    /// @param vault the vault to reenter\n    /// @param fCashToBorrow amount of fCash to borrow in the next maturity\n    /// @param maturity new maturity to borrow at\n    /// @param depositAmountExternal amount to deposit into the new maturity\n    /// @param minLendRate slippage protection for repaying debts\n    /// @param maxBorrowRate slippage protection for new borrow position\n    /// @return strategyTokensAdded the total strategy tokens added to the maturity, including any tokens\n    /// rolled from the previous maturity.. Allows rollVaultPosition to be used by off-chain methods to get\n    /// an accurate simulation of the strategy tokens minted.\n    function rollVaultPosition(\n        address account,\n        address vault,\n        uint256 fCashToBorrow,\n        uint256 maturity,\n        uint256 depositAmountExternal,\n        uint32 minLendRate,\n        uint32 maxBorrowRate,\n        bytes calldata enterVaultData\n    ) external payable override nonReentrant returns (uint256 strategyTokensAdded) {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        vaultConfig.authorizeCaller(account, VaultConfiguration.ONLY_VAULT_ROLL);\n\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vault);\n        // Cannot roll unless all of these requirements are met\n        require(\n            vaultConfig.getFlag(VaultConfiguration.ENABLED) &&\n            vaultConfig.getFlag(VaultConfiguration.ALLOW_ROLL_POSITION) &&\n            block.timestamp < vaultAccount.maturity && // cannot have matured yet\n            vaultAccount.maturity < maturity && // new maturity must be forward in time\n            fCashToBorrow > 0, // must borrow into the next maturity, if not, then they should just exit\n            \"No Roll Allowed\"\n        );\n\n        VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig.vault, vaultAccount.maturity);\n        // Exit the maturity pool by removing all the vault shares. All of the strategy tokens will be\n        // re-deposited into the new maturity\n        uint256 strategyTokens = vaultState.exitMaturity(vaultAccount, vaultAccount.vaultShares);\n\n        // Exit the vault first and debit the temporary cash balance with the cost to exit\n        vaultAccount.lendToExitVault(\n            vaultConfig,\n            vaultState,\n            vaultAccount.fCash.neg(), // must fully exit the fCash position\n            minLendRate,\n            block.timestamp\n        );\n\n        // This should never be the case for a healthy vault account due to the mechanics of exiting the vault\n        // above but we check it for safety here.\n        require(vaultAccount.fCash == 0, \"Failed Lend\");\n        vaultState.setVaultState(vaultConfig.vault);\n\n        // Takes a deposit from the user as repayment for the lending, allows an account to roll their position\n        // even if they are close to the max borrow capacity.\n        if (depositAmountExternal > 0) {\n            vaultAccount.depositForRollPosition(vaultConfig, depositAmountExternal);\n        }\n\n        // Enters the vault at the longer dated maturity\n        strategyTokensAdded = vaultAccount.borrowAndEnterVault(\n            vaultConfig,\n            maturity, // This is the new maturity to enter\n            fCashToBorrow,\n            maxBorrowRate,\n            enterVaultData,\n            strategyTokens,\n            0 // No additional tokens deposited in this method\n        );\n\n        emit VaultRollPosition(vault, account, maturity, fCashToBorrow);\n    }\n\n    /// @notice Prior to maturity, allows an account to withdraw their position from the vault. Will\n    /// redeem some number of vault shares to the borrow currency and close the borrow position by\n    /// lending `fCashToLend`. Any shortfall in cash from lending will be transferred from the account,\n    /// any excess profits will be transferred to the account.\n    /// Post maturity, will net off the account's debt against vault cash balances and redeem all remaining\n    /// strategy tokens back to the borrowed currency and transfer the profits to the account.\n    /// @param account the address that will exit the vault\n    /// @param vault the vault to enter\n    /// @param receiver the address that will receive profits\n    /// @param vaultSharesToRedeem amount of vault tokens to exit, only relevant when exiting pre-maturity\n    /// @param fCashToLend amount of fCash to lend\n    /// @param minLendRate the minimum rate to lend at\n    /// @param exitVaultData passed to the vault during exit\n    /// @return underlyingToReceiver amount of underlying tokens returned to the receiver on exit\n    function exitVault(\n        address account,\n        address vault,\n        address receiver,\n        uint256 vaultSharesToRedeem,\n        uint256 fCashToLend,\n        uint32 minLendRate,\n        bytes calldata exitVaultData\n    ) external payable override nonReentrant returns (uint256 underlyingToReceiver) {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        vaultConfig.authorizeCaller(account, VaultConfiguration.ONLY_VAULT_EXIT);\n\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vault);\n\n        if (vaultAccount.maturity <= block.timestamp) {\n            // Save this off because settleVaultAccount will clear the maturity\n            uint256 maturity = vaultAccount.maturity;\n            // Past maturity, an account will be settled instead\n            uint256 strategyTokens = vaultAccount.settleVaultAccount(vaultConfig, block.timestamp);\n\n            if (vaultAccount.tempCashBalance > 0) {\n                // Transfer asset cash back to the account\n                VaultConfiguration.transferFromNotional(\n                    receiver, vaultConfig.borrowCurrencyId, vaultAccount.tempCashBalance\n                );\n                vaultAccount.tempCashBalance = 0;\n            }\n\n            // Redeems all strategy tokens and any profits are sent back to the account, it is possible for temp\n            // cash balance to be negative here if the account is insolvent\n            underlyingToReceiver = vaultConfig.redeemWithDebtRepayment(\n                vaultAccount, receiver, strategyTokens, maturity, exitVaultData\n            );\n            emit VaultExitPostMaturity(vault, account, maturity, underlyingToReceiver);\n        } else {\n            VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig.vault, vaultAccount.maturity);\n            // Puts a negative cash balance on the vault's temporary cash balance\n            vaultAccount.lendToExitVault(\n                vaultConfig, vaultState, fCashToLend.toInt(), minLendRate, block.timestamp\n            );\n\n            uint256 strategyTokens = vaultState.exitMaturity(vaultAccount, vaultSharesToRedeem);\n\n            if (vaultAccount.tempCashBalance > 0) {\n                // Transfer asset cash back to the account, this is possible if there is asset cash\n                // when the vault exits the maturity\n                VaultConfiguration.transferFromNotional(\n                    receiver, vaultConfig.borrowCurrencyId, vaultAccount.tempCashBalance\n                );\n                vaultAccount.tempCashBalance = 0;\n            }\n\n            if (strategyTokens > 0) {\n                underlyingToReceiver = vaultConfig.redeemWithDebtRepayment(\n                    vaultAccount, receiver, strategyTokens, vaultState.maturity, exitVaultData\n                );\n            }\n\n            if (vaultAccount.fCash < 0) {\n                // It's possible that the user redeems more vault shares than they lend (it is not always the case\n                // that they will be increasing their collateral ratio here, so we check that this is the case).\n                vaultConfig.checkCollateralRatio(vaultState, vaultAccount);\n            }\n\n            // Set the vault state after redemption completes\n            vaultState.setVaultState(vaultConfig.vault);\n            emit VaultExitPreMaturity(vault, account, vaultState.maturity, fCashToLend, vaultSharesToRedeem, underlyingToReceiver);\n        }\n\n        if (vaultAccount.fCash == 0 && vaultAccount.vaultShares == 0) {\n            // If the account has no position in the vault at this point, set the maturity to zero as well\n            vaultAccount.maturity = 0;\n        }\n        vaultAccount.setVaultAccount(vaultConfig);\n    }\n\n    /// @notice If an account is below the minimum collateral ratio, this method wil deleverage (liquidate)\n    /// that account. `depositAmountExternal` in the borrow currency will be transferred from the liquidator\n    /// and used to offset the account's debt position. The liquidator will receive either vaultShares or\n    /// cash depending.\n    /// @param account the address that will exit the vault\n    /// @param vault the vault to enter\n    /// @param liquidator the address that will receive profits from liquidation\n    /// @param depositAmountExternal amount of asset cash to deposit\n    /// @param transferSharesToLiquidator transfers the shares to the liquidator instead of redeeming them\n    /// @param redeemData calldata sent to the vault when redeeming liquidator profits\n    /// @return profitFromLiquidation amount of vaultShares or cash received from liquidation\n    function deleverageAccount(\n        address account,\n        address vault,\n        address liquidator,\n        uint256 depositAmountExternal,\n        bool transferSharesToLiquidator,\n        bytes calldata redeemData\n    ) external nonReentrant override returns (uint256 profitFromLiquidation) {\n        VaultConfig memory vaultConfig = _authenticateDeleverage(account, vault, liquidator);\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vault);\n        VaultState memory vaultState = VaultStateLib.getVaultState(vault, vaultAccount.maturity);\n\n        // Check that the account has an active position. After maturity, accounts will be settled instead.\n        require(block.timestamp < vaultAccount.maturity);\n\n        // Check that the collateral ratio is below the minimum allowed\n        (int256 collateralRatio, int256 vaultShareValue) = vaultConfig.calculateCollateralRatio(\n            vaultState, account, vaultAccount.vaultShares, vaultAccount.fCash\n        );\n        require(collateralRatio < vaultConfig.minCollateralRatio , \"Sufficient Collateral\");\n\n        Token memory assetToken = TokenHandler.getAssetToken(vaultConfig.borrowCurrencyId);\n        // This will deposit some amount of cash into vaultAccount.tempCashBalance\n        _depositLiquidatorAmount(\n            liquidator, assetToken, vaultAccount, vaultConfig, depositAmountExternal, vaultShareValue\n        );\n\n        // The liquidator will purchase vault shares from the vault account at discount. The calculation is:\n        // (cashDeposited / assetCashValueOfShares) * liquidationRate * vaultShares\n        //      where cashDeposited / assetCashValueOfShares represents the share of the total vault share\n        //      value the liquidator has deposited\n        //      and liquidationRate is a percentage greater than 100% that represents their bonus\n        uint256 vaultSharesToLiquidator;\n        {\n            vaultSharesToLiquidator = vaultAccount.tempCashBalance.toUint()\n                .mul(vaultConfig.liquidationRate.toUint())\n                .mul(vaultAccount.vaultShares)\n                .div(vaultShareValue.toUint())\n                .div(uint256(Constants.RATE_PRECISION));\n        }\n\n        vaultAccount.vaultShares = vaultAccount.vaultShares.sub(vaultSharesToLiquidator);\n        // The liquidated account will lend to exit their position at a zero interest rate and forgo any future interest\n        // from asset tokens. Trading on the AMM during liquidation is risky and lending at a zero interest rate is more\n        // costly to the the liquidated account but is safer from a protocol perspective. This can be seen as a protocol\n        // level liquidation fee.\n        {\n            int256 fCashToReduce = vaultConfig.assetRate.convertToUnderlying(vaultAccount.tempCashBalance);\n            vaultAccount.updateAccountfCash(vaultConfig, vaultState, fCashToReduce, vaultAccount.tempCashBalance.neg());\n            // _calculateLiquidatorDeposit should ensure that we only ever lend up to a zero balance, but in the\n            // case of any off by one issues we clear the fCash balance by down to zero.\n            if (vaultAccount.fCash > 0) vaultAccount.fCash = 0;\n            emit VaultDeleverageAccount(vault, account, vaultSharesToLiquidator, fCashToReduce);\n        }\n\n        // Sets the liquidated account account\n        vaultAccount.setVaultAccount(vaultConfig);\n\n        // Redeems the vault shares for asset cash and transfers it to the designated address\n        emit VaultLiquidatorProfit(vault, account, liquidator, vaultSharesToLiquidator, transferSharesToLiquidator);\n        if (transferSharesToLiquidator) {\n            vaultState.setVaultState(vaultConfig.vault);\n            profitFromLiquidation = _transferLiquidatorProfits(liquidator, vaultConfig, vaultSharesToLiquidator, vaultAccount.maturity);\n        } else {\n            profitFromLiquidation = _redeemLiquidatorProfits(\n                liquidator, vaultConfig, vaultState, vaultSharesToLiquidator, redeemData, assetToken\n            );\n        }\n    }\n\n    /// @notice Authenticates a call to the deleverage method\n    function _authenticateDeleverage(\n        address account,\n        address vault,\n        address liquidator\n    ) private returns (VaultConfig memory vaultConfig) {\n        vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        // Authorization rules for deleveraging\n        if (vaultConfig.getFlag(VaultConfiguration.ONLY_VAULT_DELEVERAGE)) {\n            require(msg.sender == vault, \"Unauthorized\");\n        } else {\n            require(msg.sender == liquidator, \"Unauthorized\");\n        }\n\n        // Cannot liquidate self, if a vault needs to deleverage itself as a whole it has other methods \n        // in VaultAction to do so.\n        require(account != msg.sender && account != liquidator, \"Unauthorized\");\n    }\n\n    /// @notice Calculates the amount the liquidator must deposit and then transfers it into Notional,\n    /// crediting the account's temporary cash balance. Deposits must be in the form of asset cash.\n    function _depositLiquidatorAmount(\n        address liquidator,\n        Token memory assetToken,\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        uint256 _depositAmountExternal,\n        int256 vaultShareValue\n    ) private {\n        int256 depositAmountExternal = _depositAmountExternal.toInt();\n        if (assetToken.tokenType == TokenType.aToken) {\n            // Handles special accounting requirements for aTokens\n            depositAmountExternal = AaveHandler.convertToScaledBalanceExternal(\n                vaultConfig.borrowCurrencyId, depositAmountExternal\n            );\n        }\n\n        // Calculates the maximum deleverage amount\n        (\n            int256 maxLiquidatorDepositAssetCash,\n            int256 debtOutstandingAboveMinBorrow\n        ) = vaultAccount.calculateDeleverageAmount(vaultConfig, vaultShareValue);\n        // Catch potential edge cases where this is negative due to insolvency inside the vault itself\n        require(maxLiquidatorDepositAssetCash > 0);\n        // For aTokens this amount is in scaled balance external precision (the same as depositAmountExternal)\n        int256 maxLiquidatorDepositExternal = assetToken.convertToExternal(maxLiquidatorDepositAssetCash);\n\n        // NOTE: deposit amount external is always positive in this method\n        if (depositAmountExternal < maxLiquidatorDepositExternal) {\n            // If liquidating past the debt outstanding above the min borrow, then the entire debt outstanding\n            // must be liquidated (that is set to maxLiquidatorDepositExternal)\n            require(depositAmountExternal < assetToken.convertToExternal(debtOutstandingAboveMinBorrow), \"Must Liquidate All Debt\");\n        } else {\n            // In the other case, limit the deposited amount to the maximum\n            depositAmountExternal = maxLiquidatorDepositExternal;\n        }\n\n        // Transfers the amount of asset tokens into Notional and credit it to the account's temp cash balance\n        int256 assetAmountExternalTransferred = assetToken.transfer(\n            liquidator, vaultConfig.borrowCurrencyId, depositAmountExternal\n        );\n\n        vaultAccount.tempCashBalance = vaultAccount.tempCashBalance.add(\n            assetToken.convertToInternal(assetAmountExternalTransferred)\n        );\n    }\n\n    /// @notice Transfers liquidator profits in the form of vault shares to be returned to the liquidator\n    function _transferLiquidatorProfits(\n        address receiver,\n        VaultConfig memory vaultConfig,\n        uint256 vaultSharesToLiquidator,\n        uint256 maturity\n    ) private returns (uint256) {\n        // Liquidator will receive vault shares that they can redeem by calling exitVault. If the liquidator has a\n        // leveraged position on then their collateral ratio will increase\n        VaultAccount memory liquidator = VaultAccountLib.getVaultAccount(receiver, vaultConfig.vault);\n        // The liquidator must be able to receive the vault shares (i.e. not be in the vault at all or be in the\n        // vault at the same maturity). If the liquidator has fCash in the current maturity then their collateral\n        // ratio will increase as a result of the liquidation, no need to check their collateral position.\n        require(liquidator.maturity == 0 || liquidator.maturity == maturity, \"Vault Shares Mismatch\"); // dev: has vault shares\n        liquidator.maturity = maturity;\n        liquidator.vaultShares = liquidator.vaultShares.add(vaultSharesToLiquidator);\n        liquidator.setVaultAccount(vaultConfig);\n\n        return vaultSharesToLiquidator;\n    }\n\n    /// @notice Redeems liquidator profits back to asset cash and transfers it to the liquidator\n    function _redeemLiquidatorProfits(\n        address liquidator,\n        VaultConfig memory vaultConfig,\n        VaultState memory vaultState,\n        uint256 vaultShares,\n        bytes calldata redeemData,\n        Token memory assetToken\n    ) private returns (uint256 underlyingToReceiver) {\n        (uint256 assetCash, uint256 strategyTokens) = vaultState.exitMaturityDirect(vaultShares);\n        (/* */, underlyingToReceiver) = vaultConfig.redeemWithoutDebtRepayment(\n            liquidator, strategyTokens, vaultState.maturity, redeemData\n        );\n\n        // Set the vault state after redemption completes\n        vaultState.setVaultState(vaultConfig.vault);\n\n        if (assetCash > 0) {\n            // Represents the amount of asset cash returned to the liquidator in underlying terms\n            uint256 underlyingRedeemed = assetToken.redeem(\n                vaultConfig.borrowCurrencyId, liquidator, assetToken.convertToExternal(assetCash.toInt()).toUint()\n            ).neg().toUint();\n            underlyingToReceiver = underlyingToReceiver.add(underlyingRedeemed);\n        }\n    }\n\n    /** View Methods **/\n    function getVaultAccount(address account, address vault) external override view returns (VaultAccount memory) {\n        return VaultAccountLib.getVaultAccount(account, vault);\n    }\n\n    function getVaultAccountDebtShares(\n        address account,\n        address vault\n    ) external override view returns (\n        uint256 debtSharesMaturity,\n        uint256[2] memory accountDebtShares,\n        uint256 accountStrategyTokens\n    ) {\n        VaultAccountSecondaryDebtShareStorage storage s = \n            LibStorage.getVaultAccountSecondaryDebtShare()[account][vault];\n        debtSharesMaturity = s.maturity;\n        accountDebtShares[0] = s.accountDebtSharesOne;\n        accountDebtShares[1] = s.accountDebtSharesTwo;\n\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vault);\n        VaultState memory vaultState = VaultStateLib.getVaultState(vault, vaultAccount.maturity);\n        (/* */, accountStrategyTokens) = vaultState.getPoolShare(vaultAccount.vaultShares);\n    }\n\n    function getVaultAccountCollateralRatio(address account, address vault) external override view returns (\n        int256 collateralRatio,\n        int256 minCollateralRatio,\n        int256 maxLiquidatorDepositAssetCash\n    ) {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigView(vault);\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vault);\n        VaultState memory vaultState = VaultStateLib.getVaultState(vault, vaultAccount.maturity);\n        minCollateralRatio = vaultConfig.minCollateralRatio;\n\n        if (vaultState.isSettled) {\n            // In this case, the maturity has been settled and although the vault account says that it has\n            // some fCash balance it does not actually owe any debt anymore.\n            collateralRatio = type(int256).max;\n        } else {\n            int256 vaultShareValue;\n            (collateralRatio, vaultShareValue) = vaultConfig.calculateCollateralRatio(\n                vaultState, account, vaultAccount.vaultShares, vaultAccount.fCash\n            );\n\n            // Calculates liquidation factors if the account is eligible\n            if (collateralRatio < minCollateralRatio && vaultShareValue > 0) {\n                (maxLiquidatorDepositAssetCash, /* */) = vaultAccount.calculateDeleverageAmount(\n                    vaultConfig, vaultShareValue\n                );\n            }\n        }\n    }\n\n    function getLibInfo() external pure returns (address) {\n        return address(TradingAction);\n    }\n}"
    }
  ]
}