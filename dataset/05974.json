{
  "Title": "[M-01] `RemoteOwner` circular dependency at deployment time",
  "Content": "\n<https://github.com/GenerationSoftware/remote-owner/blob/9c093dbd36c1f18ab7083549d10ac601d91630df/src/RemoteOwner.sol#L58><br>\n<https://github.com/GenerationSoftware/remote-owner/blob/9c093dbd36c1f18ab7083549d10ac601d91630df/src/RemoteOwner.sol#L120><br>\n<https://github.com/GenerationSoftware/remote-owner/blob/9c093dbd36c1f18ab7083549d10ac601d91630df/src/RemoteOwner.sol#L96-L99><br>\n<https://github.com/GenerationSoftware/pt-v5-draw-auction/blob/f1c6d14a1772d6609de1870f8713fb79977d51c1/src/RngAuctionRelayerRemoteOwner.sol#L47><br>\n<https://github.com/GenerationSoftware/pt-v5-draw-auction/blob/f1c6d14a1772d6609de1870f8713fb79977d51c1/src/RngAuctionRelayerRemoteOwner.sol#L64>\n\nThe `RemoteOwner.sol` contract has a security measure that ensures the sender from the remote/origin chain was the origin chain owner (i.e. a `RngAuctionRelayerRemoteOwner.sol` deployment), and this address is set at deployment time in the constructor. The `RngAuctionRelayerRemoteOwner` contract also has a security measure to ensure that messages are only dispatched across chain to the `RemoteOwner` contract deployed in the destination chain, and this address is set at deployment time in the constructor.\n\nClearly there is a circular dependency here that means the deployment phase will fail. There is a `setOriginChainOwner` method on the `RemoteOwner` contract, however this can only be called by the address on the origin chain specified in the constructor. This method is never called from the origin chain either. In summary, the circular dependency prevents the contracts from being deployed and ever initialised properly.\n\nIt is possible that there is an intermediary `__originChainOwner` used in the constructor when deploying `RemoteOwner`, but since I couldn't find any deployment scripts to verify this I have assumed that this is an unintended bug. The severity of this report depends on whether or not this was intended.\n\n### Proof of Concept\n\nIn the `RemoteOwner.sol` contract, the origin chain owner is set in the constructor:\n\n      constructor(\n        uint256 originChainId_,\n        address executor_,\n        address __originChainOwner\n      ) ExecutorAware(executor_) {\n        if (originChainId_ == 0) revert OriginChainIdZero();\n        _originChainId = originChainId_;\n        _setOriginChainOwner(__originChainOwner);\n      }\n\nAny calls to the `RemoteOwner` contract are protected by the `_checkSender` view:\n\n      function _checkSender() internal view {\n        if (!isTrustedExecutor(msg.sender)) revert LocalSenderNotExecutor(msg.sender);\n        if (_fromChainId() != _originChainId) revert OriginChainIdUnsupported(_fromChainId());\n        if (_msgSender() != address(_originChainOwner)) revert OriginSenderNotOwner(_msgSender());\n      }\n\nNow, if we have a look at the `RngAuctionRelayerRemoteOwner.sol` contract, we can see that the remote owner address is also specified in the constructor:\n\n        constructor(\n            RngAuction _rngAuction,\n            ISingleMessageDispatcher _messageDispatcher,\n            RemoteOwner _remoteOwner,\n            uint256 _toChainId\n        ) RngAuctionRelayer(_rngAuction) {\n            messageDispatcher = _messageDispatcher;\n            account = _remoteOwner;\n            toChainId = _toChainId;\n        }\n\nThis `account` address is now hard-coded and used with any calls to `relay`:\n\n    function relay(\n            IRngAuctionRelayListener _remoteRngAuctionRelayListener,\n            address rewardRecipient\n        ) external returns (bytes32) {\n            bytes memory listenerCalldata = encodeCalldata(rewardRecipient);\n            bytes32 messageId = messageDispatcher.dispatchMessage(\n                toChainId,\n                address(account),\n                RemoteOwnerCallEncoder.encodeCalldata(address(_remoteRngAuctionRelayListener), 0, listenerCalldata)\n            );\n            emit RelayedToDispatcher(rewardRecipient, messageId);\n            return messageId;\n        }\n\nThere is a circular dependency here due to the reliance on specifying the relevant addresses in the constructor.\n\n### Recommended Mitigation Steps\n\nTo remove the circular dependency and reliance on a very specific deployment pipeline that requires a specific call from a remote chain address, I would make the following change to the `RemoteOwner` contract:\n\n```\ndiff --git a/src/RemoteOwner.sol b/src/RemoteOwner.sol\nindex 7c1de6d..a6cb8f1 100644\n--- a/src/RemoteOwner.sol\n+++ b/src/RemoteOwner.sol\n@@ -55,7 +55,6 @@ contract RemoteOwner is ExecutorAware {\n   ) ExecutorAware(executor_) {\n     if (originChainId_ == 0) revert OriginChainIdZero();\n     _originChainId = originChainId_;\n-    _setOriginChainOwner(__originChainOwner);\n   }\n \n   /* ============ External Functions ============ */\n@@ -94,7 +93,7 @@ contract RemoteOwner is ExecutorAware {\n    *      If the transaction get front-run at deployment, we can always re-deploy the contract.\n    */\n   function setOriginChainOwner(address _newOriginChainOwner) external {\n-    _checkSender();\n+    require(_originChainOwner == address(0), \"Already initialized\");\n     _setOriginChainOwner(_newOriginChainOwner);\n   }\n \n```\n\nHowever I can understand how the current deployment pipeline functionality would make it harder to frontrun `setOriginChainOwner` if this was done deliberately, so alternatively you could keep the functionality the same but just provide better comments.\n\n**[asselstine (PoolTogether) confirmed and commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/147#issuecomment-1673825441):**\n > Interesting. We haven't deployed the `RemoteOwner` yet so we didn't run into this issue.\n> \n> It looks like the simplest solution is to pass the `RemoteOwner` as an argument to the `RngAuctionRelayerRemoteOwner#relay` call.\n> \n> This also makes deploying to new L2s more convenient, because we won't need to redeploy a `RngAuctionRelayerRemoteOwner` contract.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/RemoteOwner.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { ExecutorAware } from \"erc5164/abstract/ExecutorAware.sol\";\n\n/* ============ Custom Errors ============ */\n\n/// @notice Thrown when the originChainId passed to the constructor is zero.\nerror OriginChainIdZero();\n\n/// @notice Thrown when the OriginChainOwner address passed to the constructor is zero address.\nerror OriginChainOwnerZeroAddress();\n\n/// @notice Thrown when the message was dispatched from an unsupported chain ID.\nerror OriginChainIdUnsupported(uint256 fromChainId);\n\n/// @notice Thrown when the message was not executed by the executor.\nerror LocalSenderNotExecutor(address sender);\n\n/// @notice Thrown when the message was not dispatched by the OriginChainOwner on the origin chain.\nerror OriginSenderNotOwner(address sender);\n\n/// @notice Thrown when the call to the target contract failed.\nerror CallFailed(bytes returnData);\n\n/// @title RemoteOwner\n/// @author G9 Software Inc.\n/// @notice RemoteOwner is a contract \ncontract RemoteOwner is ExecutorAware {\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when the OriginChainOwner has been set.\n   * @param owner Address of the OriginChainOwner\n   */\n  event OriginChainOwnerSet(address owner);\n\n  /* ============ Variables ============ */\n\n  /// @notice ID of the origin chain that dispatches the auction auction results and random number.\n  uint256 internal immutable _originChainId;\n\n  /// @notice Address of the OriginChainOwner on the origin chain that dispatches the auction auction results and random number.\n  address internal _originChainOwner;\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice ownerReceiver constructor.\n   */\n  constructor(\n    uint256 originChainId_,\n    address executor_,\n    address __originChainOwner\n  ) ExecutorAware(executor_) {\n    if (originChainId_ == 0) revert OriginChainIdZero();\n    _originChainId = originChainId_;\n    _setOriginChainOwner(__originChainOwner);\n  }\n\n  /* ============ External Functions ============ */\n\n  function execute(address target, uint256 value, bytes calldata data) external returns (bytes memory) {\n    // console2.log(\"EXECUTE\");\n    // console2.logBytes(data);\n    _checkSender();\n    (bool success, bytes memory returnData) = target.call{ value: value }(data);\n    // console2.log(\"success?\", success);\n    // console2.logBytes(returnData);\n    // console2.log(abi.decode(returnData, (uint256)));\n    if (!success) revert CallFailed(returnData);\n    assembly {\n      return (add(returnData, 0x20), mload(returnData))\n    }\n  }\n\n  /**\n   * @notice Get the ID of the origin chain.\n   * @return ID of the origin chain\n   */\n  function originChainId() external view returns (uint256) {\n    return _originChainId;\n  }\n\n  function originChainOwner() external view returns (address) {\n    return _originChainOwner;\n  }\n\n  /* ============ Setters ============ */\n\n  /**\n   * @notice Set the OriginChainOwner address.\n   * @dev Can only be called once.\n   *      If the transaction get front-run at deployment, we can always re-deploy the contract.\n   */\n  function setOriginChainOwner(address _newOriginChainOwner) external {\n    _checkSender();\n    _setOriginChainOwner(_newOriginChainOwner);\n  }\n\n  /* ============ Internal Functions ============ */\n\n  function _setOriginChainOwner(address _newOriginChainOwner) internal {\n    if (_newOriginChainOwner == address(0)) revert OriginChainOwnerZeroAddress();\n\n    _originChainOwner = _newOriginChainOwner;\n\n    emit OriginChainOwnerSet(_newOriginChainOwner);\n  }\n\n  /**\n   * @notice Checks that:\n   *          - the call has been dispatched from the supported chain\n   *          - the sender on the receiving chain is the executor\n   *          - the sender on the origin chain is the DrawMangerAdapter\n   */\n  function _checkSender() internal view {\n    if (!isTrustedExecutor(msg.sender)) revert LocalSenderNotExecutor(msg.sender);\n    if (_fromChainId() != _originChainId) revert OriginChainIdUnsupported(_fromChainId());\n    if (_msgSender() != address(_originChainOwner)) revert OriginSenderNotOwner(_msgSender());\n  }\n}"
    },
    {
      "filename": "src/RemoteOwner.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { ExecutorAware } from \"erc5164/abstract/ExecutorAware.sol\";\n\n/* ============ Custom Errors ============ */\n\n/// @notice Thrown when the originChainId passed to the constructor is zero.\nerror OriginChainIdZero();\n\n/// @notice Thrown when the OriginChainOwner address passed to the constructor is zero address.\nerror OriginChainOwnerZeroAddress();\n\n/// @notice Thrown when the message was dispatched from an unsupported chain ID.\nerror OriginChainIdUnsupported(uint256 fromChainId);\n\n/// @notice Thrown when the message was not executed by the executor.\nerror LocalSenderNotExecutor(address sender);\n\n/// @notice Thrown when the message was not dispatched by the OriginChainOwner on the origin chain.\nerror OriginSenderNotOwner(address sender);\n\n/// @notice Thrown when the call to the target contract failed.\nerror CallFailed(bytes returnData);\n\n/// @title RemoteOwner\n/// @author G9 Software Inc.\n/// @notice RemoteOwner is a contract \ncontract RemoteOwner is ExecutorAware {\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when the OriginChainOwner has been set.\n   * @param owner Address of the OriginChainOwner\n   */\n  event OriginChainOwnerSet(address owner);\n\n  /* ============ Variables ============ */\n\n  /// @notice ID of the origin chain that dispatches the auction auction results and random number.\n  uint256 internal immutable _originChainId;\n\n  /// @notice Address of the OriginChainOwner on the origin chain that dispatches the auction auction results and random number.\n  address internal _originChainOwner;\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice ownerReceiver constructor.\n   */\n  constructor(\n    uint256 originChainId_,\n    address executor_,\n    address __originChainOwner\n  ) ExecutorAware(executor_) {\n    if (originChainId_ == 0) revert OriginChainIdZero();\n    _originChainId = originChainId_;\n    _setOriginChainOwner(__originChainOwner);\n  }\n\n  /* ============ External Functions ============ */\n\n  function execute(address target, uint256 value, bytes calldata data) external returns (bytes memory) {\n    // console2.log(\"EXECUTE\");\n    // console2.logBytes(data);\n    _checkSender();\n    (bool success, bytes memory returnData) = target.call{ value: value }(data);\n    // console2.log(\"success?\", success);\n    // console2.logBytes(returnData);\n    // console2.log(abi.decode(returnData, (uint256)));\n    if (!success) revert CallFailed(returnData);\n    assembly {\n      return (add(returnData, 0x20), mload(returnData))\n    }\n  }\n\n  /**\n   * @notice Get the ID of the origin chain.\n   * @return ID of the origin chain\n   */\n  function originChainId() external view returns (uint256) {\n    return _originChainId;\n  }\n\n  function originChainOwner() external view returns (address) {\n    return _originChainOwner;\n  }\n\n  /* ============ Setters ============ */\n\n  /**\n   * @notice Set the OriginChainOwner address.\n   * @dev Can only be called once.\n   *      If the transaction get front-run at deployment, we can always re-deploy the contract.\n   */\n  function setOriginChainOwner(address _newOriginChainOwner) external {\n    _checkSender();\n    _setOriginChainOwner(_newOriginChainOwner);\n  }\n\n  /* ============ Internal Functions ============ */\n\n  function _setOriginChainOwner(address _newOriginChainOwner) internal {\n    if (_newOriginChainOwner == address(0)) revert OriginChainOwnerZeroAddress();\n\n    _originChainOwner = _newOriginChainOwner;\n\n    emit OriginChainOwnerSet(_newOriginChainOwner);\n  }\n\n  /**\n   * @notice Checks that:\n   *          - the call has been dispatched from the supported chain\n   *          - the sender on the receiving chain is the executor\n   *          - the sender on the origin chain is the DrawMangerAdapter\n   */\n  function _checkSender() internal view {\n    if (!isTrustedExecutor(msg.sender)) revert LocalSenderNotExecutor(msg.sender);\n    if (_fromChainId() != _originChainId) revert OriginChainIdUnsupported(_fromChainId());\n    if (_msgSender() != address(_originChainOwner)) revert OriginSenderNotOwner(_msgSender());\n  }\n}"
    },
    {
      "filename": "src/RemoteOwner.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { ExecutorAware } from \"erc5164/abstract/ExecutorAware.sol\";\n\n/* ============ Custom Errors ============ */\n\n/// @notice Thrown when the originChainId passed to the constructor is zero.\nerror OriginChainIdZero();\n\n/// @notice Thrown when the OriginChainOwner address passed to the constructor is zero address.\nerror OriginChainOwnerZeroAddress();\n\n/// @notice Thrown when the message was dispatched from an unsupported chain ID.\nerror OriginChainIdUnsupported(uint256 fromChainId);\n\n/// @notice Thrown when the message was not executed by the executor.\nerror LocalSenderNotExecutor(address sender);\n\n/// @notice Thrown when the message was not dispatched by the OriginChainOwner on the origin chain.\nerror OriginSenderNotOwner(address sender);\n\n/// @notice Thrown when the call to the target contract failed.\nerror CallFailed(bytes returnData);\n\n/// @title RemoteOwner\n/// @author G9 Software Inc.\n/// @notice RemoteOwner is a contract \ncontract RemoteOwner is ExecutorAware {\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when the OriginChainOwner has been set.\n   * @param owner Address of the OriginChainOwner\n   */\n  event OriginChainOwnerSet(address owner);\n\n  /* ============ Variables ============ */\n\n  /// @notice ID of the origin chain that dispatches the auction auction results and random number.\n  uint256 internal immutable _originChainId;\n\n  /// @notice Address of the OriginChainOwner on the origin chain that dispatches the auction auction results and random number.\n  address internal _originChainOwner;\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice ownerReceiver constructor.\n   */\n  constructor(\n    uint256 originChainId_,\n    address executor_,\n    address __originChainOwner\n  ) ExecutorAware(executor_) {\n    if (originChainId_ == 0) revert OriginChainIdZero();\n    _originChainId = originChainId_;\n    _setOriginChainOwner(__originChainOwner);\n  }\n\n  /* ============ External Functions ============ */\n\n  function execute(address target, uint256 value, bytes calldata data) external returns (bytes memory) {\n    // console2.log(\"EXECUTE\");\n    // console2.logBytes(data);\n    _checkSender();\n    (bool success, bytes memory returnData) = target.call{ value: value }(data);\n    // console2.log(\"success?\", success);\n    // console2.logBytes(returnData);\n    // console2.log(abi.decode(returnData, (uint256)));\n    if (!success) revert CallFailed(returnData);\n    assembly {\n      return (add(returnData, 0x20), mload(returnData))\n    }\n  }\n\n  /**\n   * @notice Get the ID of the origin chain.\n   * @return ID of the origin chain\n   */\n  function originChainId() external view returns (uint256) {\n    return _originChainId;\n  }\n\n  function originChainOwner() external view returns (address) {\n    return _originChainOwner;\n  }\n\n  /* ============ Setters ============ */\n\n  /**\n   * @notice Set the OriginChainOwner address.\n   * @dev Can only be called once.\n   *      If the transaction get front-run at deployment, we can always re-deploy the contract.\n   */\n  function setOriginChainOwner(address _newOriginChainOwner) external {\n    _checkSender();\n    _setOriginChainOwner(_newOriginChainOwner);\n  }\n\n  /* ============ Internal Functions ============ */\n\n  function _setOriginChainOwner(address _newOriginChainOwner) internal {\n    if (_newOriginChainOwner == address(0)) revert OriginChainOwnerZeroAddress();\n\n    _originChainOwner = _newOriginChainOwner;\n\n    emit OriginChainOwnerSet(_newOriginChainOwner);\n  }\n\n  /**\n   * @notice Checks that:\n   *          - the call has been dispatched from the supported chain\n   *          - the sender on the receiving chain is the executor\n   *          - the sender on the origin chain is the DrawMangerAdapter\n   */\n  function _checkSender() internal view {\n    if (!isTrustedExecutor(msg.sender)) revert LocalSenderNotExecutor(msg.sender);\n    if (_fromChainId() != _originChainId) revert OriginChainIdUnsupported(_fromChainId());\n    if (_msgSender() != address(_originChainOwner)) revert OriginSenderNotOwner(_msgSender());\n  }\n}"
    },
    {
      "filename": "src/RngAuctionRelayerRemoteOwner.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { RemoteOwner } from \"remote-owner/RemoteOwner.sol\";\nimport { RemoteOwnerCallEncoder } from \"remote-owner/libraries/RemoteOwnerCallEncoder.sol\";\nimport { ISingleMessageDispatcher } from \"erc5164/interfaces/ISingleMessageDispatcher.sol\";\n\nimport {\n    RngAuctionRelayer,\n    RngAuction,\n    IRngAuctionRelayListener\n} from \"./abstract/RngAuctionRelayer.sol\";\n\n/// @title RngAuctionRelayerRemoteOwner\n/// @author G9 Software Inc.\n/// @notice This contract allows anyone to relay RNG results to an IRngAuctionRelayListener on another chain.\n/// @dev This contract uses a Remote Owner, which allows a contract on one chain to operate an address on another chain.\ncontract RngAuctionRelayerRemoteOwner is RngAuctionRelayer {\n\n    /// @notice Emitted when the relay was successfully dispatched to the ERC-5164 Dispatcher\n    /// @param rewardRecipient The address that shall receive the RNG relay reward.\n    /// @param messageId The message ID of the dispatched message.\n    event RelayedToDispatcher(address indexed rewardRecipient, bytes32 indexed messageId);\n\n    /// @notice The ERC-5164 Dispatcher to use to bridge messages\n    ISingleMessageDispatcher public immutable messageDispatcher;\n\n    /// @notice The address of the Remote Owner that this contract is attached to.\n    /// @dev Note: the Remote Owner lives on the destination chain, not the chain on which the relayer lives.\n    RemoteOwner public immutable account;\n\n    /// @notice The chain ID that the Remote Owner is deployed to.\n    uint256 public immutable toChainId;\n\n    /// @notice Constructs a new contract\n    /// @param _rngAuction The RNG auction to pull results from.\n    /// @param _messageDispatcher The ERC-5164 Dispatcher to use to bridge messages\n    /// @param _remoteOwner The address of the Remote Owner that this contract is attached to.\n    /// @param _toChainId The chain ID that the Remote Owner is deployed to.\n    constructor(\n        RngAuction _rngAuction,\n        ISingleMessageDispatcher _messageDispatcher,\n        RemoteOwner _remoteOwner,\n        uint256 _toChainId\n    ) RngAuctionRelayer(_rngAuction) {\n        messageDispatcher = _messageDispatcher;\n        account = _remoteOwner;\n        toChainId = _toChainId;\n    }\n\n    /// @notice Relays the RNG results through the 5164 message dispatcher to the remote rngAuctionRelayListener on the other chain.\n    /// @dev Note that some bridges require an additional transaction to bridge the message.\n    /// For example, both Arbitrum and zkSync require off-chain information to accomplish this. See ERC-5164 implementations for more details.\n    /// @param _remoteRngAuctionRelayListener The address of the IRngAuctionRelayListener to relay to on the other chain.\n    /// @param rewardRecipient The address that shall receive the RngAuctionRelay reward. Note that this address must be able to receive rewards on the other chain.\n    /// @return The message ID of the dispatched message.\n    function relay(\n        IRngAuctionRelayListener _remoteRngAuctionRelayListener,\n        address rewardRecipient\n    ) external returns (bytes32) {\n        bytes memory listenerCalldata = encodeCalldata(rewardRecipient);\n        bytes32 messageId = messageDispatcher.dispatchMessage(\n            toChainId,\n            address(account),\n            RemoteOwnerCallEncoder.encodeCalldata(address(_remoteRngAuctionRelayListener), 0, listenerCalldata)\n        );\n        emit RelayedToDispatcher(rewardRecipient, messageId);\n        return messageId;\n    }\n}"
    },
    {
      "filename": "src/RngAuctionRelayerRemoteOwner.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { RemoteOwner } from \"remote-owner/RemoteOwner.sol\";\nimport { RemoteOwnerCallEncoder } from \"remote-owner/libraries/RemoteOwnerCallEncoder.sol\";\nimport { ISingleMessageDispatcher } from \"erc5164/interfaces/ISingleMessageDispatcher.sol\";\n\nimport {\n    RngAuctionRelayer,\n    RngAuction,\n    IRngAuctionRelayListener\n} from \"./abstract/RngAuctionRelayer.sol\";\n\n/// @title RngAuctionRelayerRemoteOwner\n/// @author G9 Software Inc.\n/// @notice This contract allows anyone to relay RNG results to an IRngAuctionRelayListener on another chain.\n/// @dev This contract uses a Remote Owner, which allows a contract on one chain to operate an address on another chain.\ncontract RngAuctionRelayerRemoteOwner is RngAuctionRelayer {\n\n    /// @notice Emitted when the relay was successfully dispatched to the ERC-5164 Dispatcher\n    /// @param rewardRecipient The address that shall receive the RNG relay reward.\n    /// @param messageId The message ID of the dispatched message.\n    event RelayedToDispatcher(address indexed rewardRecipient, bytes32 indexed messageId);\n\n    /// @notice The ERC-5164 Dispatcher to use to bridge messages\n    ISingleMessageDispatcher public immutable messageDispatcher;\n\n    /// @notice The address of the Remote Owner that this contract is attached to.\n    /// @dev Note: the Remote Owner lives on the destination chain, not the chain on which the relayer lives.\n    RemoteOwner public immutable account;\n\n    /// @notice The chain ID that the Remote Owner is deployed to.\n    uint256 public immutable toChainId;\n\n    /// @notice Constructs a new contract\n    /// @param _rngAuction The RNG auction to pull results from.\n    /// @param _messageDispatcher The ERC-5164 Dispatcher to use to bridge messages\n    /// @param _remoteOwner The address of the Remote Owner that this contract is attached to.\n    /// @param _toChainId The chain ID that the Remote Owner is deployed to.\n    constructor(\n        RngAuction _rngAuction,\n        ISingleMessageDispatcher _messageDispatcher,\n        RemoteOwner _remoteOwner,\n        uint256 _toChainId\n    ) RngAuctionRelayer(_rngAuction) {\n        messageDispatcher = _messageDispatcher;\n        account = _remoteOwner;\n        toChainId = _toChainId;\n    }\n\n    /// @notice Relays the RNG results through the 5164 message dispatcher to the remote rngAuctionRelayListener on the other chain.\n    /// @dev Note that some bridges require an additional transaction to bridge the message.\n    /// For example, both Arbitrum and zkSync require off-chain information to accomplish this. See ERC-5164 implementations for more details.\n    /// @param _remoteRngAuctionRelayListener The address of the IRngAuctionRelayListener to relay to on the other chain.\n    /// @param rewardRecipient The address that shall receive the RngAuctionRelay reward. Note that this address must be able to receive rewards on the other chain.\n    /// @return The message ID of the dispatched message.\n    function relay(\n        IRngAuctionRelayListener _remoteRngAuctionRelayListener,\n        address rewardRecipient\n    ) external returns (bytes32) {\n        bytes memory listenerCalldata = encodeCalldata(rewardRecipient);\n        bytes32 messageId = messageDispatcher.dispatchMessage(\n            toChainId,\n            address(account),\n            RemoteOwnerCallEncoder.encodeCalldata(address(_remoteRngAuctionRelayListener), 0, listenerCalldata)\n        );\n        emit RelayedToDispatcher(rewardRecipient, messageId);\n        return messageId;\n    }\n}"
    }
  ]
}