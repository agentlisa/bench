{
  "Title": "[G-26] Multiple `if`-statements with mutually-exclusive conditions should be changed to `if`-`else` statements",
  "Content": "\nIf two conditions are the same, their blocks should be combined\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol   #1\n\n87        if (tokenPrice == 0) {\n88          tokenPrice = getPriceFromOracle(tokenAddress);\n89        }\n90        if (tokenPrice == 0) {\n91          tokenPrice = getPriceFromDex(tokenAddress);\n92:       }\n```\n\n<https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L87-L92>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Extended} from \"../interfaces/IERC20Extended.sol\";\n\nimport {PriceOracle} from \"./PriceOracle.sol\";\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\ncontract ConnextPriceOracle is PriceOracle {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20Extended;\n\n  address public admin;\n  address public wrapped;\n  address public v1PriceOracle;\n\n  /// @notice Chainlink Aggregators\n  mapping(address => AggregatorV3Interface) public aggregators;\n\n  struct PriceInfo {\n    address token; // Address of token contract, TOKEN\n    address baseToken; // Address of base token contract, BASETOKEN\n    address lpToken; // Address of TOKEN-BASETOKEN pair contract\n    bool active; // Active status of price record 0\n  }\n\n  mapping(address => PriceInfo) public priceRecords;\n  mapping(address => uint256) public assetPrices;\n\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event PriceRecordUpdated(address token, address baseToken, address lpToken, bool _active);\n  event DirectPriceUpdated(address token, uint256 oldPrice, uint256 newPrice);\n  event AggregatorUpdated(address tokenAddress, address source);\n  event V1PriceOracleUpdated(address oldAddress, address newAddress);\n\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"caller is not the admin\");\n    _;\n  }\n\n  constructor(address _wrapped) {\n    wrapped = _wrapped;\n    admin = msg.sender;\n  }\n\n  function getTokenPrice(address _tokenAddress) public view override returns (uint256) {\n    address tokenAddress = _tokenAddress;\n    if (_tokenAddress == address(0)) {\n      tokenAddress = wrapped;\n    }\n    uint256 tokenPrice = assetPrices[tokenAddress];\n    if (tokenPrice == 0) {\n      tokenPrice = getPriceFromOracle(tokenAddress);\n    }\n    if (tokenPrice == 0) {\n      tokenPrice = getPriceFromDex(tokenAddress);\n    }\n    if (tokenPrice == 0 && v1PriceOracle != address(0)) {\n      tokenPrice = IPriceOracle(v1PriceOracle).getTokenPrice(tokenAddress);\n    }\n    return tokenPrice;\n  }\n\n  function getPriceFromDex(address _tokenAddress) public view returns (uint256) {\n    PriceInfo storage priceInfo = priceRecords[_tokenAddress];\n    if (priceInfo.active) {\n      uint256 rawTokenAmount = IERC20Extended(priceInfo.token).balanceOf(priceInfo.lpToken);\n      uint256 tokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.token).decimals());\n      uint256 tokenAmount = rawTokenAmount.mul(10**tokenDecimalDelta);\n      uint256 rawBaseTokenAmount = IERC20Extended(priceInfo.baseToken).balanceOf(priceInfo.lpToken);\n      uint256 baseTokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.baseToken).decimals());\n      uint256 baseTokenAmount = rawBaseTokenAmount.mul(10**baseTokenDecimalDelta);\n      uint256 baseTokenPrice = getTokenPrice(priceInfo.baseToken);\n      uint256 tokenPrice = baseTokenPrice.mul(baseTokenAmount).div(tokenAmount);\n\n      return tokenPrice;\n    } else {\n      return 0;\n    }\n  }\n\n  function getPriceFromOracle(address _tokenAddress) public view returns (uint256) {\n    uint256 chainLinkPrice = getPriceFromChainlink(_tokenAddress);\n    return chainLinkPrice;\n  }\n\n  function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {\n    AggregatorV3Interface aggregator = aggregators[_tokenAddress];\n    if (address(aggregator) != address(0)) {\n      (, int256 answer, , , ) = aggregator.latestRoundData();\n\n      // It's fine for price to be 0. We have two price feeds.\n      if (answer == 0) {\n        return 0;\n      }\n\n      // Extend the decimals to 1e18.\n      uint256 retVal = uint256(answer);\n      uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));\n\n      return price;\n    }\n\n    return 0;\n  }\n\n  function setDexPriceInfo(\n    address _token,\n    address _baseToken,\n    address _lpToken,\n    bool _active\n  ) external onlyAdmin {\n    PriceInfo storage priceInfo = priceRecords[_token];\n    uint256 baseTokenPrice = getTokenPrice(_baseToken);\n    require(baseTokenPrice > 0, \"invalid base token\");\n    priceInfo.token = _token;\n    priceInfo.baseToken = _baseToken;\n    priceInfo.lpToken = _lpToken;\n    priceInfo.active = _active;\n    emit PriceRecordUpdated(_token, _baseToken, _lpToken, _active);\n  }\n\n  function setDirectPrice(address _token, uint256 _price) external onlyAdmin {\n    emit DirectPriceUpdated(_token, assetPrices[_token], _price);\n    assetPrices[_token] = _price;\n  }\n\n  function setV1PriceOracle(address _v1PriceOracle) external onlyAdmin {\n    emit V1PriceOracleUpdated(v1PriceOracle, _v1PriceOracle);\n    v1PriceOracle = _v1PriceOracle;\n  }\n\n  function setAdmin(address newAdmin) external onlyAdmin {\n    address oldAdmin = admin;\n    admin = newAdmin;\n\n    emit NewAdmin(oldAdmin, newAdmin);\n  }\n\n  function setAggregators(address[] calldata tokenAddresses, address[] calldata sources) external onlyAdmin {\n    for (uint256 i = 0; i < tokenAddresses.length; i++) {\n      aggregators[tokenAddresses[i]] = AggregatorV3Interface(sources[i]);\n      emit AggregatorUpdated(tokenAddresses[i], sources[i]);\n    }\n  }\n}"
    }
  ]
}