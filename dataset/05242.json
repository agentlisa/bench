{
  "Title": "[M-08] PriceFeed is likely to be disabled in times of volatility, causing liquidations and borrows to freeze",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/price_feed/PriceAggregator.sol#L142> \n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/price_feed/PriceAggregator.sol#L183> \n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/price_feed/PriceAggregator.sol#L195>\n\n1.  The price feed aggregator relies on three feeds (Chainlink feeds, Uniswap 30 minute TWAP and Salty spot price) to report pricing. The aggregation logic is to average the closest two feed prices, and if the price difference between them exceeds maximumPriceFeedPercentDifferenceTimes1000 (default value: 3%), the aggregator reverts. Since liquidation and borrowing operations rely on price feed reporting, these will revert as well when the minimum price disparity between the three oracles exceeds maximumPriceFeedPercentDifferenceTimes1000.\n\n2.  In times of price volatility for the reported pairs (ETH/USD, BTC/USD) the three oracles used are likely to diverge by more than the 3% limit. To understand why, consider the following traits of each of the three feed sources:\n\n*   Uniswap 30 minutes TWAP reports the time weighed average over the last 30 minutes.\n*   Chainlink uses multiple sources (onchain Dexes, Cexes) and reports immediately on price changes larger than 0.5% (the Chainlink update trigger setting for the two feeds used.)\n*   Salty reports the immediate price taken from the relevant pools on Salty at the time (block) of price aggragation.\n*   When volatility is high, the 30 minutes TWAP is likely to diverge from spot oracles such as Chainlink feeds and Salty's pools. If for example the market price shifts drastically within 5 minutes, Uniswap's TWAP will only weigh the change at 20% and the previous price at 80%, while Chainlink and Salty will report the most recent price. In such conditions, a 3% price difference is likely to happen.\n*   Since Salty's liquidity is likely to be much smaller than the Uniswap pools used (Weth/Wbtc and Weth/Usdc) its reported price is likely to diverge from Uniswap's price, especially when sharp price shifts occur. This is because large pools such as Uniswaps are likely to be arbitraged sooner (to match centralized exchanges where price discovery typically happens) and smaller pools take longer to catch up to the new price.\n\n3.  The result is that is times of high volatility, Salty's price feed is likely to enter a state of >3% disparity between the feeds, effetively blocking liquidations at the time they are most crucial.\n4.  The maximumPriceFeedPercentDifferenceTimes1000 parameter can be extended up to 7% through a DAO vote, but given that every 0.5% increase requires a vote duration of 10 days at least, the DAO is not likely to react it time to adjust for market volatility.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThe common behavior for DeFi price feed aggregators is to fallback to the most trustworthy oracle rather than abort. Typically, Chainlink is selected as the preferred fallback due to the diversity of its sources and reputation of stability. It is recommended to follow this principle and fallback to Chainlink's price instead of reverting when prices diverge by more than the max.\n\n**[othernet-global (Salty.IO) acknowledged and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/809#issuecomment-1960683594):**\n > The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:\n\n> https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9\n\n**Status:** Mitigation confirmed. Full details in reports from [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/54), [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/74), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/13).\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/price_feed/PriceAggregator.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"./interfaces/IPriceAggregator.sol\";\n\n\n// Compares three different price feeds to provide prices for BTC and ETH\n// The three price feeds are used so that if one fails to work properly, the other two can still correctly report price (the outlier is discarded).\n// setPriceFeed can only be called once every 35 days by default (to allow time to review performance of the most recently upgraded PriceFeed before setting another).\n// priceFeed1, priceFeed2, and priceFeed3 are updateable using DAO.proposeSetContractAddress( \"priceFeed1\" ), etc\ncontract PriceAggregator is IPriceAggregator, Ownable\n    {\n    event PriceFeedSet(uint256 indexed priceFeedNum, IPriceFeed indexed newPriceFeed);\n    event MaximumPriceFeedPercentDifferenceChanged(uint256 newMaxDifference);\n    event SetPriceFeedCooldownChanged(uint256 newCooldown);\n\n\tIPriceFeed public priceFeed1; // CoreUniswapFeed by default\n\tIPriceFeed public priceFeed2; // CoreChainlinkFeed by default\n\tIPriceFeed public priceFeed3; // CoreSaltyFeed by default\n\n\t// The next time at which setPriceFeed can be called\n\tuint256 public priceFeedModificationCooldownExpiration;\n\n\t// The maximum percent difference between two non-zero PriceFeed prices when aggregating price.\n\t// When the two closest PriceFeeds (out of the three) have prices further apart than this the aggregated price is considered invalid.\n\t// Range: 1% to 7% with an adjustment of .50%\n\tuint256 public maximumPriceFeedPercentDifferenceTimes1000 = 3000; // Defaults to 3.0% with a 1000x multiplier\n\n\t// The required cooldown between calls to setPriceFeed.\n\t// Allows time to evaluate the performance of the recently updatef PriceFeed before further updates are made.\n\t// Range: 30 to 45 days with an adjustment of 5 days\n\tuint256 public priceFeedModificationCooldown = 35 days;\n\n\n\tfunction setInitialFeeds( IPriceFeed _priceFeed1, IPriceFeed _priceFeed2, IPriceFeed _priceFeed3 ) public onlyOwner\n\t\t{\n\t\trequire( address(priceFeed1) == address(0), \"setInitialFeeds() can only be called once\" );\n\n\t\tpriceFeed1 = _priceFeed1;\n\t\tpriceFeed2 = _priceFeed2;\n\t\tpriceFeed3 = _priceFeed3;\n\t\t}\n\n\n\tfunction setPriceFeed( uint256 priceFeedNum, IPriceFeed newPriceFeed ) public onlyOwner\n\t\t{\n\t\t// If the required cooldown is not met, simply return without reverting so that the original proposal can be finalized and new setPriceFeed proposals can be made.\n\t\tif ( block.timestamp < priceFeedModificationCooldownExpiration )\n\t\t\treturn;\n\n\t\tif ( priceFeedNum == 1 )\n\t\t\tpriceFeed1 = newPriceFeed;\n\t\telse if ( priceFeedNum == 2 )\n\t\t\tpriceFeed2 = newPriceFeed;\n\t\telse if ( priceFeedNum == 3 )\n\t\t\tpriceFeed3 = newPriceFeed;\n\n\t\tpriceFeedModificationCooldownExpiration = block.timestamp + priceFeedModificationCooldown;\n\t\temit PriceFeedSet(priceFeedNum, newPriceFeed);\n\t\t}\n\n\n\tfunction changeMaximumPriceFeedPercentDifferenceTimes1000(bool increase) public onlyOwner\n\t\t{\n        if (increase)\n            {\n            if (maximumPriceFeedPercentDifferenceTimes1000 < 7000)\n                maximumPriceFeedPercentDifferenceTimes1000 += 500;\n            }\n        else\n            {\n            if (maximumPriceFeedPercentDifferenceTimes1000 > 1000)\n                maximumPriceFeedPercentDifferenceTimes1000 -= 500;\n            }\n\n\t\temit MaximumPriceFeedPercentDifferenceChanged(maximumPriceFeedPercentDifferenceTimes1000);\n\t\t}\n\n\n\tfunction changePriceFeedModificationCooldown(bool increase) public onlyOwner\n\t\t{\n        if (increase)\n            {\n            if (priceFeedModificationCooldown < 45 days)\n                priceFeedModificationCooldown += 5 days;\n            }\n        else\n            {\n            if (priceFeedModificationCooldown > 30 days)\n                priceFeedModificationCooldown -= 5 days;\n            }\n\n\t\temit SetPriceFeedCooldownChanged(priceFeedModificationCooldown);\n\t\t}\n\n\n\tfunction _absoluteDifference( uint256 x, uint256 y ) internal pure returns (uint256)\n\t\t{\n\t\tif ( x > y )\n\t\t\treturn x - y;\n\n\t\treturn y - x;\n\t\t}\n\n\n\tfunction _aggregatePrices( uint256 price1, uint256 price2, uint256 price3 ) internal view returns (uint256)\n\t\t{\n\t\tuint256 numNonZero;\n\n\t\tif (price1 > 0)\n\t\t\tnumNonZero++;\n\n\t\tif (price2 > 0)\n\t\t\tnumNonZero++;\n\n\t\tif (price3 > 0)\n\t\t\tnumNonZero++;\n\n\t\t// If less than two price sources then return zero to indicate failure\n\t\tif ( numNonZero < 2 )\n\t\t\treturn 0;\n\n\t\tuint256 diff12 = _absoluteDifference(price1, price2);\n\t\tuint256 diff13 = _absoluteDifference(price1, price3);\n\t\tuint256 diff23 = _absoluteDifference(price2, price3);\n\n\t\tuint256 priceA;\n\t\tuint256 priceB;\n\n\t\tif ( ( diff12 <= diff13 ) && ( diff12 <= diff23 ) )\n\t\t\t(priceA, priceB) = (price1, price2);\n\t\telse if ( ( diff13 <= diff12 ) && ( diff13 <= diff23 ) )\n\t\t\t(priceA, priceB) = (price1, price3);\n\t\telse if ( ( diff23 <= diff12 ) && ( diff23 <= diff13 ) )\n\t\t\t(priceA, priceB) = (price2, price3);\n\n\t\tuint256 averagePrice = ( priceA + priceB ) / 2;\n\n\t\t// If price sources are too far apart then return zero to indicate failure\n\t\tif (  (_absoluteDifference(priceA, priceB) * 100000) / averagePrice > maximumPriceFeedPercentDifferenceTimes1000 )\n\t\t\treturn 0;\n\n\t\treturn averagePrice;\n\t\t}\n\n\n\tfunction _getPriceBTC(IPriceFeed priceFeed) internal view returns (uint256 price)\n\t\t{\n \t\ttry priceFeed.getPriceBTC() returns (uint256 _price)\n\t\t\t{\n\t\t\tprice = _price;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// price remains 0\n\t\t\t}\n\t\t}\n\n\n\tfunction _getPriceETH(IPriceFeed priceFeed) internal view returns (uint256 price)\n\t\t{\n \t\ttry priceFeed.getPriceETH() returns (uint256 _price)\n\t\t\t{\n\t\t\tprice = _price;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// price remains 0\n\t\t\t}\n\t\t}\n\n\n\t// Return the current BTC price (with 18 decimals)\n\tfunction getPriceBTC() external view returns (uint256 price)\n\t\t{\n\t\tuint256 price1 = _getPriceBTC(priceFeed1);\n\t\tuint256 price2 = _getPriceBTC(priceFeed2);\n\t\tuint256 price3 = _getPriceBTC(priceFeed3);\n\n\t\tprice = _aggregatePrices(price1, price2, price3);\n\t\trequire (price != 0, \"Invalid BTC price\" );\n\t\t}\n\n\n\t// Return the current ETH price (with 18 decimals)\n\tfunction getPriceETH() external view returns (uint256 price)\n\t\t{\n\t\tuint256 price1 = _getPriceETH(priceFeed1);\n\t\tuint256 price2 = _getPriceETH(priceFeed2);\n\t\tuint256 price3 = _getPriceETH(priceFeed3);\n\n\t\tprice = _aggregatePrices(price1, price2, price3);\n\t\trequire (price != 0, \"Invalid ETH price\" );\n\t\t}\n    }"
    },
    {
      "filename": "src/price_feed/PriceAggregator.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"./interfaces/IPriceAggregator.sol\";\n\n\n// Compares three different price feeds to provide prices for BTC and ETH\n// The three price feeds are used so that if one fails to work properly, the other two can still correctly report price (the outlier is discarded).\n// setPriceFeed can only be called once every 35 days by default (to allow time to review performance of the most recently upgraded PriceFeed before setting another).\n// priceFeed1, priceFeed2, and priceFeed3 are updateable using DAO.proposeSetContractAddress( \"priceFeed1\" ), etc\ncontract PriceAggregator is IPriceAggregator, Ownable\n    {\n    event PriceFeedSet(uint256 indexed priceFeedNum, IPriceFeed indexed newPriceFeed);\n    event MaximumPriceFeedPercentDifferenceChanged(uint256 newMaxDifference);\n    event SetPriceFeedCooldownChanged(uint256 newCooldown);\n\n\tIPriceFeed public priceFeed1; // CoreUniswapFeed by default\n\tIPriceFeed public priceFeed2; // CoreChainlinkFeed by default\n\tIPriceFeed public priceFeed3; // CoreSaltyFeed by default\n\n\t// The next time at which setPriceFeed can be called\n\tuint256 public priceFeedModificationCooldownExpiration;\n\n\t// The maximum percent difference between two non-zero PriceFeed prices when aggregating price.\n\t// When the two closest PriceFeeds (out of the three) have prices further apart than this the aggregated price is considered invalid.\n\t// Range: 1% to 7% with an adjustment of .50%\n\tuint256 public maximumPriceFeedPercentDifferenceTimes1000 = 3000; // Defaults to 3.0% with a 1000x multiplier\n\n\t// The required cooldown between calls to setPriceFeed.\n\t// Allows time to evaluate the performance of the recently updatef PriceFeed before further updates are made.\n\t// Range: 30 to 45 days with an adjustment of 5 days\n\tuint256 public priceFeedModificationCooldown = 35 days;\n\n\n\tfunction setInitialFeeds( IPriceFeed _priceFeed1, IPriceFeed _priceFeed2, IPriceFeed _priceFeed3 ) public onlyOwner\n\t\t{\n\t\trequire( address(priceFeed1) == address(0), \"setInitialFeeds() can only be called once\" );\n\n\t\tpriceFeed1 = _priceFeed1;\n\t\tpriceFeed2 = _priceFeed2;\n\t\tpriceFeed3 = _priceFeed3;\n\t\t}\n\n\n\tfunction setPriceFeed( uint256 priceFeedNum, IPriceFeed newPriceFeed ) public onlyOwner\n\t\t{\n\t\t// If the required cooldown is not met, simply return without reverting so that the original proposal can be finalized and new setPriceFeed proposals can be made.\n\t\tif ( block.timestamp < priceFeedModificationCooldownExpiration )\n\t\t\treturn;\n\n\t\tif ( priceFeedNum == 1 )\n\t\t\tpriceFeed1 = newPriceFeed;\n\t\telse if ( priceFeedNum == 2 )\n\t\t\tpriceFeed2 = newPriceFeed;\n\t\telse if ( priceFeedNum == 3 )\n\t\t\tpriceFeed3 = newPriceFeed;\n\n\t\tpriceFeedModificationCooldownExpiration = block.timestamp + priceFeedModificationCooldown;\n\t\temit PriceFeedSet(priceFeedNum, newPriceFeed);\n\t\t}\n\n\n\tfunction changeMaximumPriceFeedPercentDifferenceTimes1000(bool increase) public onlyOwner\n\t\t{\n        if (increase)\n            {\n            if (maximumPriceFeedPercentDifferenceTimes1000 < 7000)\n                maximumPriceFeedPercentDifferenceTimes1000 += 500;\n            }\n        else\n            {\n            if (maximumPriceFeedPercentDifferenceTimes1000 > 1000)\n                maximumPriceFeedPercentDifferenceTimes1000 -= 500;\n            }\n\n\t\temit MaximumPriceFeedPercentDifferenceChanged(maximumPriceFeedPercentDifferenceTimes1000);\n\t\t}\n\n\n\tfunction changePriceFeedModificationCooldown(bool increase) public onlyOwner\n\t\t{\n        if (increase)\n            {\n            if (priceFeedModificationCooldown < 45 days)\n                priceFeedModificationCooldown += 5 days;\n            }\n        else\n            {\n            if (priceFeedModificationCooldown > 30 days)\n                priceFeedModificationCooldown -= 5 days;\n            }\n\n\t\temit SetPriceFeedCooldownChanged(priceFeedModificationCooldown);\n\t\t}\n\n\n\tfunction _absoluteDifference( uint256 x, uint256 y ) internal pure returns (uint256)\n\t\t{\n\t\tif ( x > y )\n\t\t\treturn x - y;\n\n\t\treturn y - x;\n\t\t}\n\n\n\tfunction _aggregatePrices( uint256 price1, uint256 price2, uint256 price3 ) internal view returns (uint256)\n\t\t{\n\t\tuint256 numNonZero;\n\n\t\tif (price1 > 0)\n\t\t\tnumNonZero++;\n\n\t\tif (price2 > 0)\n\t\t\tnumNonZero++;\n\n\t\tif (price3 > 0)\n\t\t\tnumNonZero++;\n\n\t\t// If less than two price sources then return zero to indicate failure\n\t\tif ( numNonZero < 2 )\n\t\t\treturn 0;\n\n\t\tuint256 diff12 = _absoluteDifference(price1, price2);\n\t\tuint256 diff13 = _absoluteDifference(price1, price3);\n\t\tuint256 diff23 = _absoluteDifference(price2, price3);\n\n\t\tuint256 priceA;\n\t\tuint256 priceB;\n\n\t\tif ( ( diff12 <= diff13 ) && ( diff12 <= diff23 ) )\n\t\t\t(priceA, priceB) = (price1, price2);\n\t\telse if ( ( diff13 <= diff12 ) && ( diff13 <= diff23 ) )\n\t\t\t(priceA, priceB) = (price1, price3);\n\t\telse if ( ( diff23 <= diff12 ) && ( diff23 <= diff13 ) )\n\t\t\t(priceA, priceB) = (price2, price3);\n\n\t\tuint256 averagePrice = ( priceA + priceB ) / 2;\n\n\t\t// If price sources are too far apart then return zero to indicate failure\n\t\tif (  (_absoluteDifference(priceA, priceB) * 100000) / averagePrice > maximumPriceFeedPercentDifferenceTimes1000 )\n\t\t\treturn 0;\n\n\t\treturn averagePrice;\n\t\t}\n\n\n\tfunction _getPriceBTC(IPriceFeed priceFeed) internal view returns (uint256 price)\n\t\t{\n \t\ttry priceFeed.getPriceBTC() returns (uint256 _price)\n\t\t\t{\n\t\t\tprice = _price;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// price remains 0\n\t\t\t}\n\t\t}\n\n\n\tfunction _getPriceETH(IPriceFeed priceFeed) internal view returns (uint256 price)\n\t\t{\n \t\ttry priceFeed.getPriceETH() returns (uint256 _price)\n\t\t\t{\n\t\t\tprice = _price;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// price remains 0\n\t\t\t}\n\t\t}\n\n\n\t// Return the current BTC price (with 18 decimals)\n\tfunction getPriceBTC() external view returns (uint256 price)\n\t\t{\n\t\tuint256 price1 = _getPriceBTC(priceFeed1);\n\t\tuint256 price2 = _getPriceBTC(priceFeed2);\n\t\tuint256 price3 = _getPriceBTC(priceFeed3);\n\n\t\tprice = _aggregatePrices(price1, price2, price3);\n\t\trequire (price != 0, \"Invalid BTC price\" );\n\t\t}\n\n\n\t// Return the current ETH price (with 18 decimals)\n\tfunction getPriceETH() external view returns (uint256 price)\n\t\t{\n\t\tuint256 price1 = _getPriceETH(priceFeed1);\n\t\tuint256 price2 = _getPriceETH(priceFeed2);\n\t\tuint256 price3 = _getPriceETH(priceFeed3);\n\n\t\tprice = _aggregatePrices(price1, price2, price3);\n\t\trequire (price != 0, \"Invalid ETH price\" );\n\t\t}\n    }"
    },
    {
      "filename": "src/price_feed/PriceAggregator.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"./interfaces/IPriceAggregator.sol\";\n\n\n// Compares three different price feeds to provide prices for BTC and ETH\n// The three price feeds are used so that if one fails to work properly, the other two can still correctly report price (the outlier is discarded).\n// setPriceFeed can only be called once every 35 days by default (to allow time to review performance of the most recently upgraded PriceFeed before setting another).\n// priceFeed1, priceFeed2, and priceFeed3 are updateable using DAO.proposeSetContractAddress( \"priceFeed1\" ), etc\ncontract PriceAggregator is IPriceAggregator, Ownable\n    {\n    event PriceFeedSet(uint256 indexed priceFeedNum, IPriceFeed indexed newPriceFeed);\n    event MaximumPriceFeedPercentDifferenceChanged(uint256 newMaxDifference);\n    event SetPriceFeedCooldownChanged(uint256 newCooldown);\n\n\tIPriceFeed public priceFeed1; // CoreUniswapFeed by default\n\tIPriceFeed public priceFeed2; // CoreChainlinkFeed by default\n\tIPriceFeed public priceFeed3; // CoreSaltyFeed by default\n\n\t// The next time at which setPriceFeed can be called\n\tuint256 public priceFeedModificationCooldownExpiration;\n\n\t// The maximum percent difference between two non-zero PriceFeed prices when aggregating price.\n\t// When the two closest PriceFeeds (out of the three) have prices further apart than this the aggregated price is considered invalid.\n\t// Range: 1% to 7% with an adjustment of .50%\n\tuint256 public maximumPriceFeedPercentDifferenceTimes1000 = 3000; // Defaults to 3.0% with a 1000x multiplier\n\n\t// The required cooldown between calls to setPriceFeed.\n\t// Allows time to evaluate the performance of the recently updatef PriceFeed before further updates are made.\n\t// Range: 30 to 45 days with an adjustment of 5 days\n\tuint256 public priceFeedModificationCooldown = 35 days;\n\n\n\tfunction setInitialFeeds( IPriceFeed _priceFeed1, IPriceFeed _priceFeed2, IPriceFeed _priceFeed3 ) public onlyOwner\n\t\t{\n\t\trequire( address(priceFeed1) == address(0), \"setInitialFeeds() can only be called once\" );\n\n\t\tpriceFeed1 = _priceFeed1;\n\t\tpriceFeed2 = _priceFeed2;\n\t\tpriceFeed3 = _priceFeed3;\n\t\t}\n\n\n\tfunction setPriceFeed( uint256 priceFeedNum, IPriceFeed newPriceFeed ) public onlyOwner\n\t\t{\n\t\t// If the required cooldown is not met, simply return without reverting so that the original proposal can be finalized and new setPriceFeed proposals can be made.\n\t\tif ( block.timestamp < priceFeedModificationCooldownExpiration )\n\t\t\treturn;\n\n\t\tif ( priceFeedNum == 1 )\n\t\t\tpriceFeed1 = newPriceFeed;\n\t\telse if ( priceFeedNum == 2 )\n\t\t\tpriceFeed2 = newPriceFeed;\n\t\telse if ( priceFeedNum == 3 )\n\t\t\tpriceFeed3 = newPriceFeed;\n\n\t\tpriceFeedModificationCooldownExpiration = block.timestamp + priceFeedModificationCooldown;\n\t\temit PriceFeedSet(priceFeedNum, newPriceFeed);\n\t\t}\n\n\n\tfunction changeMaximumPriceFeedPercentDifferenceTimes1000(bool increase) public onlyOwner\n\t\t{\n        if (increase)\n            {\n            if (maximumPriceFeedPercentDifferenceTimes1000 < 7000)\n                maximumPriceFeedPercentDifferenceTimes1000 += 500;\n            }\n        else\n            {\n            if (maximumPriceFeedPercentDifferenceTimes1000 > 1000)\n                maximumPriceFeedPercentDifferenceTimes1000 -= 500;\n            }\n\n\t\temit MaximumPriceFeedPercentDifferenceChanged(maximumPriceFeedPercentDifferenceTimes1000);\n\t\t}\n\n\n\tfunction changePriceFeedModificationCooldown(bool increase) public onlyOwner\n\t\t{\n        if (increase)\n            {\n            if (priceFeedModificationCooldown < 45 days)\n                priceFeedModificationCooldown += 5 days;\n            }\n        else\n            {\n            if (priceFeedModificationCooldown > 30 days)\n                priceFeedModificationCooldown -= 5 days;\n            }\n\n\t\temit SetPriceFeedCooldownChanged(priceFeedModificationCooldown);\n\t\t}\n\n\n\tfunction _absoluteDifference( uint256 x, uint256 y ) internal pure returns (uint256)\n\t\t{\n\t\tif ( x > y )\n\t\t\treturn x - y;\n\n\t\treturn y - x;\n\t\t}\n\n\n\tfunction _aggregatePrices( uint256 price1, uint256 price2, uint256 price3 ) internal view returns (uint256)\n\t\t{\n\t\tuint256 numNonZero;\n\n\t\tif (price1 > 0)\n\t\t\tnumNonZero++;\n\n\t\tif (price2 > 0)\n\t\t\tnumNonZero++;\n\n\t\tif (price3 > 0)\n\t\t\tnumNonZero++;\n\n\t\t// If less than two price sources then return zero to indicate failure\n\t\tif ( numNonZero < 2 )\n\t\t\treturn 0;\n\n\t\tuint256 diff12 = _absoluteDifference(price1, price2);\n\t\tuint256 diff13 = _absoluteDifference(price1, price3);\n\t\tuint256 diff23 = _absoluteDifference(price2, price3);\n\n\t\tuint256 priceA;\n\t\tuint256 priceB;\n\n\t\tif ( ( diff12 <= diff13 ) && ( diff12 <= diff23 ) )\n\t\t\t(priceA, priceB) = (price1, price2);\n\t\telse if ( ( diff13 <= diff12 ) && ( diff13 <= diff23 ) )\n\t\t\t(priceA, priceB) = (price1, price3);\n\t\telse if ( ( diff23 <= diff12 ) && ( diff23 <= diff13 ) )\n\t\t\t(priceA, priceB) = (price2, price3);\n\n\t\tuint256 averagePrice = ( priceA + priceB ) / 2;\n\n\t\t// If price sources are too far apart then return zero to indicate failure\n\t\tif (  (_absoluteDifference(priceA, priceB) * 100000) / averagePrice > maximumPriceFeedPercentDifferenceTimes1000 )\n\t\t\treturn 0;\n\n\t\treturn averagePrice;\n\t\t}\n\n\n\tfunction _getPriceBTC(IPriceFeed priceFeed) internal view returns (uint256 price)\n\t\t{\n \t\ttry priceFeed.getPriceBTC() returns (uint256 _price)\n\t\t\t{\n\t\t\tprice = _price;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// price remains 0\n\t\t\t}\n\t\t}\n\n\n\tfunction _getPriceETH(IPriceFeed priceFeed) internal view returns (uint256 price)\n\t\t{\n \t\ttry priceFeed.getPriceETH() returns (uint256 _price)\n\t\t\t{\n\t\t\tprice = _price;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// price remains 0\n\t\t\t}\n\t\t}\n\n\n\t// Return the current BTC price (with 18 decimals)\n\tfunction getPriceBTC() external view returns (uint256 price)\n\t\t{\n\t\tuint256 price1 = _getPriceBTC(priceFeed1);\n\t\tuint256 price2 = _getPriceBTC(priceFeed2);\n\t\tuint256 price3 = _getPriceBTC(priceFeed3);\n\n\t\tprice = _aggregatePrices(price1, price2, price3);\n\t\trequire (price != 0, \"Invalid BTC price\" );\n\t\t}\n\n\n\t// Return the current ETH price (with 18 decimals)\n\tfunction getPriceETH() external view returns (uint256 price)\n\t\t{\n\t\tuint256 price1 = _getPriceETH(priceFeed1);\n\t\tuint256 price2 = _getPriceETH(priceFeed2);\n\t\tuint256 price3 = _getPriceETH(priceFeed3);\n\n\t\tprice = _aggregatePrices(price1, price2, price3);\n\t\trequire (price != 0, \"Invalid ETH price\" );\n\t\t}\n    }"
    }
  ]
}