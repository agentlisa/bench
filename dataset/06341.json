{
  "Title": "[M-06] Interest is not accrued before parameters are updated in `SavingsVest`",
  "Content": "\nStablecoin holders can receive wrongly calculated yield in the `SavingsVest` contract. Also, wrong vesting profit can be slashed when the protocol is under-collateralized.\n\n### Proof of Concept\n\nThe [SavingsVest](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L15) contract lets users deposit their stablecoins and earn vested yield when the stablecoin in the Transmuter protocol is over-collateralized. The interest is accrued via calls to the [SavingsVest.accrue](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L103) function.\n\nThere are two parameters that affect the profit of depositors:\n\n1.  [protocolSafetyFee](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L115) is the fees paid to the protocol;\n2.  [vestingPeriod](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L149) is the period when the yield remains locked.\n\nThe two parameters can be changed via the [setParams](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L196) function. However, before they're changed, the current interest is not accrued. E.g. this may lead to:\n\n1.  If `protocolSafetyFee` is increased without accruing interest, the next accrual will happen at the increased fees, which will reduce the rewards for the depositors.\n2.  If `vestingPeriod` is increased without accruing interest, the yield will be [locked for a longer period](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L161) and the next accrual may [slash more vested yield](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L130-L141).\n\nThus, users can lose a portion of the yield that was earned at a lower protocol fee after the fee was increased. Likewise, increasing the vesting period may result in slashing yield that was earned before the period was increased.\n\n### Recommended Mitigation Steps\n\nIn the `SavingsVest.setParams` function, consider accruing interest with the current parameters before setting new `protocolSafetyFee` and `vestingPeriod`.\n\n**[Picodes (Angle) confirmed and commented](https://github.com/code-423n4/2023-06-angle-findings/issues/13#issuecomment-1628680724):**\n > Confirmed. The worst scenario is that when modifying the `vestingPeriod` it can lead to a jump in [`lockedProfit`](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L161), so to a jump in `totalAssets()`. So eventually someone could sandwich attack the update for a profit.\n\n**[Angle mitigated](https://github.com/code-423n4/2023-07-angle-mitigation/blob/main/README.md#mitigations-to-be-reviewed):**\n> PR: https://github.com/AngleProtocol/angle-transmuter/commit/94c4e51ae3400a63532e85f04f4081152adc97db<br>\n> Calls `accrues`` before updating sensible parameters.\n\n**Status:** Mitigation confirmed. Full details in report from [Jeiwan](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/20).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/savings/SavingsVest.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { ITransmuter } from \"interfaces/ITransmuter.sol\";\n\nimport \"./BaseSavings.sol\";\n\n/// @title SavingsVest\n/// @author Angle Labs, Inc.\n/// @notice In this implementation, yield is distributed to stablecoin holders whenever the Transmuter starts to\n/// get over-collateralized\n/// @dev This implementation is typically applicable to an ETH stablecoin backed by liquid staking tokens and\n/// where the yield of the LST is distributed to stablecoin holders\ncontract SavingsVest is BaseSavings {\n    using SafeERC20 for IERC20;\n    using MathUpgradeable for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                PARAMETERS / REFERENCES                                             \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Address handling protocol surplus\n    address public surplusManager;\n\n    /// @notice Amount of profit that needs to be vested\n    uint256 public vestingProfit;\n\n    /// @notice Reference to the Transmuter contract\n    ITransmuter public transmuter;\n\n    /// @notice Last time rewards were accrued\n    uint64 public lastUpdate;\n\n    /// @notice Share of the surplus going to the protocol\n    uint64 public protocolSafetyFee;\n\n    /// @notice The period in seconds over which locked profit is unlocked\n    /// @dev Cannot be 0 as it opens the system to sandwich attacks\n    uint32 public vestingPeriod;\n\n    /// @notice Minimum time between two calls to the `accrue` function\n    uint32 public updateDelay;\n\n    /// @notice Whether the contract is paused or not\n    uint8 public paused;\n\n    uint256[46] private __gap;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        EVENTS                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    event FiledUint64(uint64 param, bytes32 what);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    INITIALIZATION                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Initializes the contract\n    /// @param _accessControlManager Reference to the `AccessControlManager` contract\n    /// @param name_ Name of the savings contract\n    /// @param symbol_ Symbol of the savings contract\n    /// @param divizer Quantifies the first initial deposit (should be typically 1 for tokens like agEUR)\n    /// @dev A first deposit is done at initialization to protect for the classical issue of ERC4626 contracts\n    /// where the the first user of the contract tries to steal everyone else's tokens\n    function initialize(\n        IAccessControlManager _accessControlManager,\n        IERC20MetadataUpgradeable asset_,\n        ITransmuter _transmuter,\n        string memory name_,\n        string memory symbol_,\n        uint256 divizer\n    ) public initializer {\n        if (address(_accessControlManager) == address(0) || address(_transmuter) == address(0)) revert ZeroAddress();\n        __ERC4626_init(asset_);\n        __ERC20_init(name_, symbol_);\n        transmuter = _transmuter;\n        accessControlManager = _accessControlManager;\n        uint8 numDecimals = asset_.decimals();\n        _deposit(msg.sender, address(this), 10 ** numDecimals / divizer, BASE_18 / divizer);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                       MODIFIER                                                     \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ERC20Upgradeable\n    function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // Lets transfer freely even when paused but no mint or burn\n        if ((from == address(0) || to == address(0)) && paused > 0) revert Paused();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    CONTRACT LOGIC                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Accrues interest to this contract by minting agTokens if the protocol is over-collateralized\n    /// or burning some if it is not collateralized\n    function accrue() external returns (uint256 minted) {\n        if (block.timestamp - lastUpdate < updateDelay && !accessControlManager.isGovernorOrGuardian(msg.sender))\n            revert NotAllowed();\n        ITransmuter _transmuter = transmuter;\n        IAgToken _agToken = IAgToken(asset());\n        (uint64 collatRatio, uint256 stablecoinsIssued) = _transmuter.getCollateralRatio();\n        // It needs to deviate significantly (>0.1%) from the target in order to accrue\n        if (collatRatio > BASE_9 + BASE_6) {\n            // The surplus of profit minus a fee is distributed through this contract\n            minted = (collatRatio * stablecoinsIssued) / BASE_9 - stablecoinsIssued;\n            // Updating normalizer in order not to double count profits\n            _transmuter.updateNormalizer(minted, true);\n            uint256 surplusForProtocol = (minted * protocolSafetyFee) / BASE_9;\n            address _surplusManager = surplusManager;\n            _surplusManager = _surplusManager == address(0) ? address(_transmuter) : _surplusManager;\n            _agToken.mint(_surplusManager, surplusForProtocol);\n            uint256 surplus = minted - surplusForProtocol;\n            if (surplus != 0) {\n                // Adding new profits relaunches to zero the vesting period for the profits that were\n                // previously being vested\n                vestingProfit = (lockedProfit() + surplus);\n                lastUpdate = uint64(block.timestamp);\n                _agToken.mint(address(this), surplus);\n            }\n        } else if (collatRatio < BASE_9 - BASE_6) {\n            // If the protocol is under-collateralized, slashing the profits that are still being vested\n            uint256 missing = stablecoinsIssued - (collatRatio * stablecoinsIssued) / BASE_9;\n            uint256 currentLockedProfit = lockedProfit();\n            if (missing > currentLockedProfit) {\n                vestingProfit = 0;\n                missing = currentLockedProfit;\n            } else {\n                vestingProfit = currentLockedProfit - missing;\n                lastUpdate = uint64(block.timestamp);\n            }\n            if (missing > 0) {\n                _agToken.burnSelf(missing, address(this));\n                _transmuter.updateNormalizer(missing, false);\n            }\n        }\n    }\n\n    /// @notice Amount of profit that are still vesting\n    function lockedProfit() public view virtual returns (uint256) {\n        // Get the last update and vesting delay.\n        uint256 _lastUpdate = lastUpdate;\n        uint256 _vestingPeriod = vestingPeriod;\n\n        unchecked {\n            // If the vesting period has passed, there is no locked profit.\n            // This cannot overflow on human timescales\n            if (block.timestamp >= _lastUpdate + _vestingPeriod) return 0;\n\n            // Get the maximum amount we could return.\n            uint256 currentlyVestingProfit = vestingProfit;\n\n            // Compute how much profit remains locked based on the last time a profit was acknowledged\n            // and the vesting period. It's impossible for an update to be in the future, so this will never underflow.\n            return currentlyVestingProfit - (currentlyVestingProfit * (block.timestamp - _lastUpdate)) / _vestingPeriod;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                ERC4626 VIEW FUNCTIONS                                              \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ERC4626Upgradeable\n    function totalAssets() public view override returns (uint256) {\n        return super.totalAssets() - lockedProfit();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        HELPER                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Provides an estimated Annual Percentage Rate for base depositors on this contract\n    function estimatedAPR() external view returns (uint256 apr) {\n        uint256 currentlyVestingProfit = vestingProfit;\n        uint256 weightedAssets = vestingPeriod * totalAssets();\n        if (currentlyVestingProfit != 0 && weightedAssets != 0)\n            apr = (currentlyVestingProfit * 3600 * 24 * 365 * BASE_18) / weightedAssets;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                      GOVERNANCE                                                    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the `surplusManager` address which handles protocol fees\n    function setSurplusManager(address _surplusManager) external onlyGuardian {\n        surplusManager = _surplusManager;\n    }\n\n    /// @notice Changes the contract parameters\n    function setParams(bytes32 what, uint64 param) external onlyGuardian {\n        if (param > BASE_9) revert InvalidParam();\n        else if (what == \"PF\") protocolSafetyFee = param;\n        else if (what == \"VP\") vestingPeriod = uint32(param);\n        else if (what == \"UD\") updateDelay = uint32(param);\n        else if (what == \"P\") paused = uint8(param);\n        else revert InvalidParam();\n        emit FiledUint64(param, what);\n    }\n}"
    },
    {
      "filename": "contracts/savings/SavingsVest.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { ITransmuter } from \"interfaces/ITransmuter.sol\";\n\nimport \"./BaseSavings.sol\";\n\n/// @title SavingsVest\n/// @author Angle Labs, Inc.\n/// @notice In this implementation, yield is distributed to stablecoin holders whenever the Transmuter starts to\n/// get over-collateralized\n/// @dev This implementation is typically applicable to an ETH stablecoin backed by liquid staking tokens and\n/// where the yield of the LST is distributed to stablecoin holders\ncontract SavingsVest is BaseSavings {\n    using SafeERC20 for IERC20;\n    using MathUpgradeable for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                PARAMETERS / REFERENCES                                             \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Address handling protocol surplus\n    address public surplusManager;\n\n    /// @notice Amount of profit that needs to be vested\n    uint256 public vestingProfit;\n\n    /// @notice Reference to the Transmuter contract\n    ITransmuter public transmuter;\n\n    /// @notice Last time rewards were accrued\n    uint64 public lastUpdate;\n\n    /// @notice Share of the surplus going to the protocol\n    uint64 public protocolSafetyFee;\n\n    /// @notice The period in seconds over which locked profit is unlocked\n    /// @dev Cannot be 0 as it opens the system to sandwich attacks\n    uint32 public vestingPeriod;\n\n    /// @notice Minimum time between two calls to the `accrue` function\n    uint32 public updateDelay;\n\n    /// @notice Whether the contract is paused or not\n    uint8 public paused;\n\n    uint256[46] private __gap;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        EVENTS                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    event FiledUint64(uint64 param, bytes32 what);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    INITIALIZATION                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Initializes the contract\n    /// @param _accessControlManager Reference to the `AccessControlManager` contract\n    /// @param name_ Name of the savings contract\n    /// @param symbol_ Symbol of the savings contract\n    /// @param divizer Quantifies the first initial deposit (should be typically 1 for tokens like agEUR)\n    /// @dev A first deposit is done at initialization to protect for the classical issue of ERC4626 contracts\n    /// where the the first user of the contract tries to steal everyone else's tokens\n    function initialize(\n        IAccessControlManager _accessControlManager,\n        IERC20MetadataUpgradeable asset_,\n        ITransmuter _transmuter,\n        string memory name_,\n        string memory symbol_,\n        uint256 divizer\n    ) public initializer {\n        if (address(_accessControlManager) == address(0) || address(_transmuter) == address(0)) revert ZeroAddress();\n        __ERC4626_init(asset_);\n        __ERC20_init(name_, symbol_);\n        transmuter = _transmuter;\n        accessControlManager = _accessControlManager;\n        uint8 numDecimals = asset_.decimals();\n        _deposit(msg.sender, address(this), 10 ** numDecimals / divizer, BASE_18 / divizer);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                       MODIFIER                                                     \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ERC20Upgradeable\n    function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // Lets transfer freely even when paused but no mint or burn\n        if ((from == address(0) || to == address(0)) && paused > 0) revert Paused();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    CONTRACT LOGIC                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Accrues interest to this contract by minting agTokens if the protocol is over-collateralized\n    /// or burning some if it is not collateralized\n    function accrue() external returns (uint256 minted) {\n        if (block.timestamp - lastUpdate < updateDelay && !accessControlManager.isGovernorOrGuardian(msg.sender))\n            revert NotAllowed();\n        ITransmuter _transmuter = transmuter;\n        IAgToken _agToken = IAgToken(asset());\n        (uint64 collatRatio, uint256 stablecoinsIssued) = _transmuter.getCollateralRatio();\n        // It needs to deviate significantly (>0.1%) from the target in order to accrue\n        if (collatRatio > BASE_9 + BASE_6) {\n            // The surplus of profit minus a fee is distributed through this contract\n            minted = (collatRatio * stablecoinsIssued) / BASE_9 - stablecoinsIssued;\n            // Updating normalizer in order not to double count profits\n            _transmuter.updateNormalizer(minted, true);\n            uint256 surplusForProtocol = (minted * protocolSafetyFee) / BASE_9;\n            address _surplusManager = surplusManager;\n            _surplusManager = _surplusManager == address(0) ? address(_transmuter) : _surplusManager;\n            _agToken.mint(_surplusManager, surplusForProtocol);\n            uint256 surplus = minted - surplusForProtocol;\n            if (surplus != 0) {\n                // Adding new profits relaunches to zero the vesting period for the profits that were\n                // previously being vested\n                vestingProfit = (lockedProfit() + surplus);\n                lastUpdate = uint64(block.timestamp);\n                _agToken.mint(address(this), surplus);\n            }\n        } else if (collatRatio < BASE_9 - BASE_6) {\n            // If the protocol is under-collateralized, slashing the profits that are still being vested\n            uint256 missing = stablecoinsIssued - (collatRatio * stablecoinsIssued) / BASE_9;\n            uint256 currentLockedProfit = lockedProfit();\n            if (missing > currentLockedProfit) {\n                vestingProfit = 0;\n                missing = currentLockedProfit;\n            } else {\n                vestingProfit = currentLockedProfit - missing;\n                lastUpdate = uint64(block.timestamp);\n            }\n            if (missing > 0) {\n                _agToken.burnSelf(missing, address(this));\n                _transmuter.updateNormalizer(missing, false);\n            }\n        }\n    }\n\n    /// @notice Amount of profit that are still vesting\n    function lockedProfit() public view virtual returns (uint256) {\n        // Get the last update and vesting delay.\n        uint256 _lastUpdate = lastUpdate;\n        uint256 _vestingPeriod = vestingPeriod;\n\n        unchecked {\n            // If the vesting period has passed, there is no locked profit.\n            // This cannot overflow on human timescales\n            if (block.timestamp >= _lastUpdate + _vestingPeriod) return 0;\n\n            // Get the maximum amount we could return.\n            uint256 currentlyVestingProfit = vestingProfit;\n\n            // Compute how much profit remains locked based on the last time a profit was acknowledged\n            // and the vesting period. It's impossible for an update to be in the future, so this will never underflow.\n            return currentlyVestingProfit - (currentlyVestingProfit * (block.timestamp - _lastUpdate)) / _vestingPeriod;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                ERC4626 VIEW FUNCTIONS                                              \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ERC4626Upgradeable\n    function totalAssets() public view override returns (uint256) {\n        return super.totalAssets() - lockedProfit();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        HELPER                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Provides an estimated Annual Percentage Rate for base depositors on this contract\n    function estimatedAPR() external view returns (uint256 apr) {\n        uint256 currentlyVestingProfit = vestingProfit;\n        uint256 weightedAssets = vestingPeriod * totalAssets();\n        if (currentlyVestingProfit != 0 && weightedAssets != 0)\n            apr = (currentlyVestingProfit * 3600 * 24 * 365 * BASE_18) / weightedAssets;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                      GOVERNANCE                                                    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the `surplusManager` address which handles protocol fees\n    function setSurplusManager(address _surplusManager) external onlyGuardian {\n        surplusManager = _surplusManager;\n    }\n\n    /// @notice Changes the contract parameters\n    function setParams(bytes32 what, uint64 param) external onlyGuardian {\n        if (param > BASE_9) revert InvalidParam();\n        else if (what == \"PF\") protocolSafetyFee = param;\n        else if (what == \"VP\") vestingPeriod = uint32(param);\n        else if (what == \"UD\") updateDelay = uint32(param);\n        else if (what == \"P\") paused = uint8(param);\n        else revert InvalidParam();\n        emit FiledUint64(param, what);\n    }\n}"
    },
    {
      "filename": "contracts/savings/SavingsVest.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { ITransmuter } from \"interfaces/ITransmuter.sol\";\n\nimport \"./BaseSavings.sol\";\n\n/// @title SavingsVest\n/// @author Angle Labs, Inc.\n/// @notice In this implementation, yield is distributed to stablecoin holders whenever the Transmuter starts to\n/// get over-collateralized\n/// @dev This implementation is typically applicable to an ETH stablecoin backed by liquid staking tokens and\n/// where the yield of the LST is distributed to stablecoin holders\ncontract SavingsVest is BaseSavings {\n    using SafeERC20 for IERC20;\n    using MathUpgradeable for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                PARAMETERS / REFERENCES                                             \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Address handling protocol surplus\n    address public surplusManager;\n\n    /// @notice Amount of profit that needs to be vested\n    uint256 public vestingProfit;\n\n    /// @notice Reference to the Transmuter contract\n    ITransmuter public transmuter;\n\n    /// @notice Last time rewards were accrued\n    uint64 public lastUpdate;\n\n    /// @notice Share of the surplus going to the protocol\n    uint64 public protocolSafetyFee;\n\n    /// @notice The period in seconds over which locked profit is unlocked\n    /// @dev Cannot be 0 as it opens the system to sandwich attacks\n    uint32 public vestingPeriod;\n\n    /// @notice Minimum time between two calls to the `accrue` function\n    uint32 public updateDelay;\n\n    /// @notice Whether the contract is paused or not\n    uint8 public paused;\n\n    uint256[46] private __gap;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        EVENTS                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    event FiledUint64(uint64 param, bytes32 what);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    INITIALIZATION                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Initializes the contract\n    /// @param _accessControlManager Reference to the `AccessControlManager` contract\n    /// @param name_ Name of the savings contract\n    /// @param symbol_ Symbol of the savings contract\n    /// @param divizer Quantifies the first initial deposit (should be typically 1 for tokens like agEUR)\n    /// @dev A first deposit is done at initialization to protect for the classical issue of ERC4626 contracts\n    /// where the the first user of the contract tries to steal everyone else's tokens\n    function initialize(\n        IAccessControlManager _accessControlManager,\n        IERC20MetadataUpgradeable asset_,\n        ITransmuter _transmuter,\n        string memory name_,\n        string memory symbol_,\n        uint256 divizer\n    ) public initializer {\n        if (address(_accessControlManager) == address(0) || address(_transmuter) == address(0)) revert ZeroAddress();\n        __ERC4626_init(asset_);\n        __ERC20_init(name_, symbol_);\n        transmuter = _transmuter;\n        accessControlManager = _accessControlManager;\n        uint8 numDecimals = asset_.decimals();\n        _deposit(msg.sender, address(this), 10 ** numDecimals / divizer, BASE_18 / divizer);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                       MODIFIER                                                     \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ERC20Upgradeable\n    function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // Lets transfer freely even when paused but no mint or burn\n        if ((from == address(0) || to == address(0)) && paused > 0) revert Paused();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    CONTRACT LOGIC                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Accrues interest to this contract by minting agTokens if the protocol is over-collateralized\n    /// or burning some if it is not collateralized\n    function accrue() external returns (uint256 minted) {\n        if (block.timestamp - lastUpdate < updateDelay && !accessControlManager.isGovernorOrGuardian(msg.sender))\n            revert NotAllowed();\n        ITransmuter _transmuter = transmuter;\n        IAgToken _agToken = IAgToken(asset());\n        (uint64 collatRatio, uint256 stablecoinsIssued) = _transmuter.getCollateralRatio();\n        // It needs to deviate significantly (>0.1%) from the target in order to accrue\n        if (collatRatio > BASE_9 + BASE_6) {\n            // The surplus of profit minus a fee is distributed through this contract\n            minted = (collatRatio * stablecoinsIssued) / BASE_9 - stablecoinsIssued;\n            // Updating normalizer in order not to double count profits\n            _transmuter.updateNormalizer(minted, true);\n            uint256 surplusForProtocol = (minted * protocolSafetyFee) / BASE_9;\n            address _surplusManager = surplusManager;\n            _surplusManager = _surplusManager == address(0) ? address(_transmuter) : _surplusManager;\n            _agToken.mint(_surplusManager, surplusForProtocol);\n            uint256 surplus = minted - surplusForProtocol;\n            if (surplus != 0) {\n                // Adding new profits relaunches to zero the vesting period for the profits that were\n                // previously being vested\n                vestingProfit = (lockedProfit() + surplus);\n                lastUpdate = uint64(block.timestamp);\n                _agToken.mint(address(this), surplus);\n            }\n        } else if (collatRatio < BASE_9 - BASE_6) {\n            // If the protocol is under-collateralized, slashing the profits that are still being vested\n            uint256 missing = stablecoinsIssued - (collatRatio * stablecoinsIssued) / BASE_9;\n            uint256 currentLockedProfit = lockedProfit();\n            if (missing > currentLockedProfit) {\n                vestingProfit = 0;\n                missing = currentLockedProfit;\n            } else {\n                vestingProfit = currentLockedProfit - missing;\n                lastUpdate = uint64(block.timestamp);\n            }\n            if (missing > 0) {\n                _agToken.burnSelf(missing, address(this));\n                _transmuter.updateNormalizer(missing, false);\n            }\n        }\n    }\n\n    /// @notice Amount of profit that are still vesting\n    function lockedProfit() public view virtual returns (uint256) {\n        // Get the last update and vesting delay.\n        uint256 _lastUpdate = lastUpdate;\n        uint256 _vestingPeriod = vestingPeriod;\n\n        unchecked {\n            // If the vesting period has passed, there is no locked profit.\n            // This cannot overflow on human timescales\n            if (block.timestamp >= _lastUpdate + _vestingPeriod) return 0;\n\n            // Get the maximum amount we could return.\n            uint256 currentlyVestingProfit = vestingProfit;\n\n            // Compute how much profit remains locked based on the last time a profit was acknowledged\n            // and the vesting period. It's impossible for an update to be in the future, so this will never underflow.\n            return currentlyVestingProfit - (currentlyVestingProfit * (block.timestamp - _lastUpdate)) / _vestingPeriod;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                ERC4626 VIEW FUNCTIONS                                              \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ERC4626Upgradeable\n    function totalAssets() public view override returns (uint256) {\n        return super.totalAssets() - lockedProfit();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        HELPER                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Provides an estimated Annual Percentage Rate for base depositors on this contract\n    function estimatedAPR() external view returns (uint256 apr) {\n        uint256 currentlyVestingProfit = vestingProfit;\n        uint256 weightedAssets = vestingPeriod * totalAssets();\n        if (currentlyVestingProfit != 0 && weightedAssets != 0)\n            apr = (currentlyVestingProfit * 3600 * 24 * 365 * BASE_18) / weightedAssets;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                      GOVERNANCE                                                    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the `surplusManager` address which handles protocol fees\n    function setSurplusManager(address _surplusManager) external onlyGuardian {\n        surplusManager = _surplusManager;\n    }\n\n    /// @notice Changes the contract parameters\n    function setParams(bytes32 what, uint64 param) external onlyGuardian {\n        if (param > BASE_9) revert InvalidParam();\n        else if (what == \"PF\") protocolSafetyFee = param;\n        else if (what == \"VP\") vestingPeriod = uint32(param);\n        else if (what == \"UD\") updateDelay = uint32(param);\n        else if (what == \"P\") paused = uint8(param);\n        else revert InvalidParam();\n        emit FiledUint64(param, what);\n    }\n}"
    },
    {
      "filename": "contracts/savings/SavingsVest.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { ITransmuter } from \"interfaces/ITransmuter.sol\";\n\nimport \"./BaseSavings.sol\";\n\n/// @title SavingsVest\n/// @author Angle Labs, Inc.\n/// @notice In this implementation, yield is distributed to stablecoin holders whenever the Transmuter starts to\n///"
    }
  ]
}