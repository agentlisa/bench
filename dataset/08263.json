{
  "Title": "[H-03] Registry.sol fails to deliver expected functionality",
  "Content": "_Submitted by byndooa, also found by arcoun, cccz, Lambda, and thebensams_\n\n<https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L40-L58>\n\n<https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L39-L59>\n\n### Impact\n\nThe description of Registry.sol is following:\n\n/// Deploys new proxies via the factory and keeps a registry of owners to proxies. Owners can only\n/// have one proxy at a time.\nBut it is not.\nThere are multiple problems:\n\n1.  Proxy owner can change and will not be registered\n2.  There many ways for an owner to have many proxies:\n\n*   A few other proxy owners transferOwnership() to one address.\n*   Registry tracks last deployments and does not guarantee ownership.\n*   Factory.sol allows calling deployFor() to anyone, without any checks and registrations.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyFactory.sol#L40-L58>\n\n<https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L39-L59>\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nDelete `Proxy.transfetOwnership()`.\n\nDisallow anyone to call `deploy()` and `deployFor()` in `Factory()`.\n\n**[RnkSngh (Mimo) confirmed and commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/78#issuecomment-1210585639):**\n > We agree that this is an issue and intend to fix this.\n\n**[gzeoneth (judge) increased severity to High and commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/78#issuecomment-1221553605):**\n > I believe this is High Risk due to the unexpected ownership behavior.\n\n**[m19 (Mimo) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/78#issuecomment-1223658600):**\n > While the Registry indeed does not work as advertised, I am not sure if high risk is the correct here? As per [the definition](https://docs.code4rena.com/awarding/judging-criteria#estimating-risk) \"Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\" I don't think that applies here.\n >\n> We also see no way `Proxy owner can change and will not be registered` actually can happen which would be the only scenario there is a loss of funds.\n\n**[gzeoneth (judge) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/78#issuecomment-1223956313):**\n> I am quite sure asset can be lost if the owner cannot do owner stuff and a non-owner can do owner stuff. Also see related PoC in e.g. [#154](https://github.com/code-423n4/2022-08-mimo-findings/issues/154), [#67](https://github.com/code-423n4/2022-08-mimo-findings/issues/67), [#69](https://github.com/code-423n4/2022-08-mimo-findings/issues/69)\n\n**[m19 (Mimo) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/78#issuecomment-1224011441):**\n > @gzeoneth Thanks, I get it now, [#154](https://github.com/code-423n4/2022-08-mimo-findings/issues/154) describes it much better. Yes, this is definitely a high-risk issue then.\n\n**horsefacts (warden) reviewed mitigation:**\n> **Status:** âœ… Resolved\n\n> **Finding:** Wardens identified that both `MIMOProxy` and `MIMOProxyRegistry` stored proxy ownership data, but ownership transfers were not propagated from `MIMOProxy` to the `MIMOProxyRegistry`. This would cause new owners to lose access to vault funds and old owners to retain privileged access to automation configuration.\n\n> **What changed:** The Mimo team removed the `owner` state variable and `transferOwner` function from `MIMOProxy`. Additionally, they removed `MIMOProxyRegistry` altogether and moved its functionality to `MIMOProxyFactory`. Ownership data is now stored only in `MIMOProxyFactory`, and all ownership transfers must now be performed by calling `MIMOProxyFactory#transferOwnership` rather than interacting with `MIMOProxy`.\n\n> `MIMOProxyFactory` now stores [a mapping](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/contracts/proxy/MIMOProxyFactory.sol#L20) of proxy address to `ProxyState`, a struct that includes the current owner address. The `claimOwnership` function updates both [the owner address](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/contracts/proxy/MIMOProxyFactory.sol#L105)  and the [current proxy](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/contracts/proxy/MIMOProxyFactory.sol#L104) when a new user accepts ownership. A [unit test](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/test/01_unit/proxy/MIMOProxyFactory.test.ts#L89) demonstrates this behavior.\n\n> An [integration test](https://github.com/mimo-capital/2022-08-mimo/blob/51a3092e4dd62f36de8fb16d15f5dec756cc9ae0/test/02_integration/proxy/MIMOProxyGuard.test.ts) demonstrates that proxy permissions are cleared after ownership transfers.\n\n> In its authorization check in the `execute` function, `MIMOProxy` [reads from the proxy factory](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/contracts/proxy/MIMOProxy.sol#L38) to determine the [current owner address](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/contracts/proxy/MIMOProxy.sol#L41). Client contracts [MIMOEmptyVault](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/contracts/actions/MIMOEmptyVault.sol#L74), [MIMOLeverage](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/contracts/actions/MIMOLeverage.sol#L79), [MIMORebalance](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/contracts/actions/MIMORebalance.sol#L76), [MIMOAutoAction](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/contracts/actions/automated/MIMOAutoAction.sol#L37), and [MIMOManagedAction](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/contracts/actions/managed/MIMOManagedAction.sol#L36) now read the current proxy from `MIMOProxyFactory`. \n\n> **Why it works:** Since `MIMOProxyFactory` is now the single source of truth for `MIMOProxy` ownership, this data cannot fall out of sync across contracts. Since client contracts call `MIMOProxyFactory#getCurrentProxy`, they will correctly read the current proxy address.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/proxy/MIMOProxyFactory.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"./interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./MIMOProxy.sol\";\n\n/// @title MIMOProxyFactory\n/// @notice Used to make clones of MIMOProxy for each user\ncontract MIMOProxyFactory is IMIMOProxyFactory {\n  using Clones for address;\n  /// PUBLIC STORAGE ///\n\n  address public immutable mimoProxyBase;\n\n  /// @inheritdoc IMIMOProxyFactory\n  uint256 public constant override VERSION = 1;\n\n  /// INTERNAL STORAGE ///\n\n  /// @dev Internal mapping to track all deployed proxies.\n  mapping(address => bool) internal _proxies;\n\n  constructor(address _mimoProxyBase) {\n    mimoProxyBase = _mimoProxyBase;\n  }\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyFactory\n  function isProxy(address proxy) external view override returns (bool result) {\n    result = _proxies[proxy];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyFactory\n  function deploy() external override returns (IMIMOProxy proxy) {\n    proxy = deployFor(msg.sender);\n  }\n\n  /// @inheritdoc IMIMOProxyFactory\n  function deployFor(address owner) public override returns (IMIMOProxy proxy) {\n    proxy = IMIMOProxy(mimoProxyBase.clone());\n    proxy.initialize();\n\n    // Transfer the ownership from this factory contract to the specified owner.\n    proxy.transferOwnership(owner);\n\n    // Mark the proxy as deployed.\n    _proxies[address(proxy)] = true;\n\n    // Log the proxy via en event.\n    emit DeployProxy(msg.sender, owner, address(proxy));\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxyRegistry.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./interfaces/IMIMOProxyRegistry.sol\";\nimport \"../core/interfaces/IAddressProvider.sol\";\nimport \"../core/interfaces/IAccessController.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxyRegistry\ncontract MIMOProxyRegistry is IMIMOProxyRegistry {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  IMIMOProxyFactory public override factory;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Internal mapping of owners to current proxies.\n  mapping(address => IMIMOProxy) internal _currentProxies;\n\n  /// CONSTRUCTOR ///\n\n  /// @param factory_ The base contract of the factory\n  constructor(IMIMOProxyFactory factory_) {\n    factory = factory_;\n  }\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function getCurrentProxy(address owner) external view override returns (IMIMOProxy proxy) {\n    proxy = _currentProxies[owner];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function deploy() external override returns (IMIMOProxy proxy) {\n    proxy = deployFor(msg.sender);\n  }\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function deployFor(address owner) public override returns (IMIMOProxy proxy) {\n    IMIMOProxy currentProxy = _currentProxies[owner];\n\n    // Do not deploy if the proxy already exists and the owner is the same.\n    if (address(currentProxy) != address(0) && currentProxy.owner() == owner) {\n      revert CustomErrors.PROXY_ALREADY_EXISTS(owner);\n    }\n\n    // Deploy the proxy via the factory.\n    proxy = factory.deployFor(owner);\n\n    // Set or override the current proxy for the owner.\n    _currentProxies[owner] = IMIMOProxy(proxy);\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxyFactory.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"./interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./MIMOProxy.sol\";\n\n/// @title MIMOProxyFactory\n/// @notice Used to make clones of MIMOProxy for each user\ncontract MIMOProxyFactory is IMIMOProxyFactory {\n  using Clones for address;\n  /// PUBLIC STORAGE ///\n\n  address public immutable mimoProxyBase;\n\n  /// @inheritdoc IMIMOProxyFactory\n  uint256 public constant override VERSION = 1;\n\n  /// INTERNAL STORAGE ///\n\n  /// @dev Internal mapping to track all deployed proxies.\n  mapping(address => bool) internal _proxies;\n\n  constructor(address _mimoProxyBase) {\n    mimoProxyBase = _mimoProxyBase;\n  }\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyFactory\n  function isProxy(address proxy) external view override returns (bool result) {\n    result = _proxies[proxy];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyFactory\n  function deploy() external override returns (IMIMOProxy proxy) {\n    proxy = deployFor(msg.sender);\n  }\n\n  /// @inheritdoc IMIMOProxyFactory\n  function deployFor(address owner) public override returns (IMIMOProxy proxy) {\n    proxy = IMIMOProxy(mimoProxyBase.clone());\n    proxy.initialize();\n\n    // Transfer the ownership from this factory contract to the specified owner.\n    proxy.transferOwnership(owner);\n\n    // Mark the proxy as deployed.\n    _proxies[address(proxy)] = true;\n\n    // Log the proxy via en event.\n    emit DeployProxy(msg.sender, owner, address(proxy));\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxyRegistry.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./interfaces/IMIMOProxyRegistry.sol\";\nimport \"../core/interfaces/IAddressProvider.sol\";\nimport \"../core/interfaces/IAccessController.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxyRegistry\ncontract MIMOProxyRegistry is IMIMOProxyRegistry {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  IMIMOProxyFactory public override factory;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Internal mapping of owners to current proxies.\n  mapping(address => IMIMOProxy) internal _currentProxies;\n\n  /// CONSTRUCTOR ///\n\n  /// @param factory_ The base contract of the factory\n  constructor(IMIMOProxyFactory factory_) {\n    factory = factory_;\n  }\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function getCurrentProxy(address owner) external view override returns (IMIMOProxy proxy) {\n    proxy = _currentProxies[owner];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function deploy() external override returns (IMIMOProxy proxy) {\n    proxy = deployFor(msg.sender);\n  }\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function deployFor(address owner) public override returns (IMIMOProxy proxy) {\n    IMIMOProxy currentProxy = _currentProxies[owner];\n\n    // Do not deploy if the proxy already exists and the owner is the same.\n    if (address(currentProxy) != address(0) && currentProxy.owner() == owner) {\n      revert CustomErrors.PROXY_ALREADY_EXISTS(owner);\n    }\n\n    // Deploy the proxy via the factory.\n    proxy = factory.deployFor(owner);\n\n    // Set or override the current proxy for the owner.\n    _currentProxies[owner] = IMIMOProxy(proxy);\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxyFactory.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./MIMOProxy.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title MIMOProxyFactory\ncontract MIMOProxyFactory is IMIMOProxyFactory {\n  using Clones for address;\n\n  address public immutable mimoProxyGuardBase;\n\n  /// @inheritdoc IMIMOProxyFactory\n  uint256 public constant override VERSION = 1;\n\n  /// @notice proxy => proxy state\n  mapping(address => ProxyState) private _proxyStates;\n\n  /// @notice owner => proxy\n  mapping(address => IMIMOProxy) private _currentProxies;\n\n  /// @notice proxy => pending owner\n  mapping(address => address) private _pendingOwners;\n\n  modifier onlyOwner(address proxy) {\n    if (address(_currentProxies[msg.sender]) != proxy) {\n      revert Errors.NOT_OWNER(_proxyStates[proxy].owner, msg.sender);\n    }\n    _;\n  }\n\n  constructor(address _mimoProxyGuardBase) {\n    if (_mimoProxyGuardBase == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    mimoProxyGuardBase = _mimoProxyGuardBase;\n  }\n\n  /**\n    @notice Deploys a new MIMOProxy and MIMOProxyGuard\n    @dev Sets \"msg.sender\" as the owner of the MIMOProxy.\n\n   */\n  function deploy() external override {\n    address currentProxy = address(_currentProxies[msg.sender]);\n    if (address(currentProxy) != address(0)) {\n      revert Errors.ALREADY_OWNER(msg.sender, currentProxy);\n    }\n    MIMOProxy proxy = new MIMOProxy(address(this));\n    IMIMOProxyGuard proxyGuard = IMIMOProxyGuard(mimoProxyGuardBase.clone());\n\n    proxyGuard.initialize(address(this), address(proxy));\n\n    ProxyState memory proxyState = ProxyState({ owner: msg.sender, proxyGuard: proxyGuard, minGas: 5000 });\n\n    _currentProxies[msg.sender] = IMIMOProxy(proxy);\n    _proxyStates[address(proxy)] = proxyState;\n\n    emit ProxyDeployed(msg.sender, address(proxy), proxyState);\n  }\n\n  /**\n    @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    Can only be invoked by the current MIMOProxy `owner`\n    @param proxy Address ot the MIMOProxy to transfer\n    @param newOwner Address of the new owner\n   */\n  function transferOwnership(address proxy, address newOwner) external override onlyOwner(proxy) {\n    // Checks\n    if (newOwner == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    if (address(_currentProxies[newOwner]) != address(0)) {\n      revert Errors.ALREADY_OWNER(newOwner, address(_currentProxies[newOwner]));\n    }\n    // Effects\n    _pendingOwners[proxy] = newOwner;\n    emit OwnershipTransferred(proxy, msg.sender, newOwner);\n  }\n\n  /**\n    @notice Needs to be called by `pendingOwner` to claim ownership\n    @param proxy Address of the MIMOProxy to claim\n    @param clear Clear existing proxy permissions if true and maintain them if false\n   */\n  function claimOwnership(address proxy, bool clear) external override {\n    address pendingOwner = _pendingOwners[proxy];\n\n    // Checks\n    if (msg.sender != pendingOwner) {\n      revert Errors.CALLER_NOT_PENDING_OWNER(msg.sender, pendingOwner);\n    }\n\n    if (address(_currentProxies[pendingOwner]) != address(0)) {\n      revert Errors.ALREADY_OWNER(pendingOwner, address(_currentProxies[pendingOwner]));\n    }\n\n    // Effects\n    address oldOwner = _proxyStates[proxy].owner;\n    delete _currentProxies[oldOwner];\n    _currentProxies[msg.sender] = IMIMOProxy(proxy);\n    _proxyStates[proxy].owner = msg.sender;\n    delete _pendingOwners[proxy];\n    emit OwnershipClaimed(proxy, msg.sender);\n\n    if (clear) {\n      _clearPermissions(proxy);\n    }\n  }\n\n  /**\n    @notice Clear all permissions from the MIMOProxy by deploying a new MIMOProxyGuard\n    Can only be called by the MIMOProxy `owner`\n    @param proxy Addess of the MIMOProxy to clear\n   */\n  function clearPermissions(address proxy) external override onlyOwner(proxy) {\n    _clearPermissions(proxy);\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy\n    @param minGas Gas to reserve for running the remainder of the \"execute\" function after the DELEGATECALL in the \n    MIMOProxy. Prevents the proxy from becoming unusable if EVM opcode gas costs change in the future.\n   */\n  function setMinGas(address proxy, uint256 minGas) external override onlyOwner(proxy) {\n    _proxyStates[proxy].minGas = minGas;\n    emit MinGasSet(proxy, minGas);\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy to check\n    @return result equals true if proxy has been deployed and false if not\n   */\n  function isProxy(address proxy) external view override returns (bool result) {\n    result = _proxyStates[proxy].owner != address(0);\n  }\n\n  /**\n    @notice Returns a MIMOProxy state\n    @dev MIMOProxy state management is outsourced to this contract to prevent storage collisions\n    @param proxy Address of the MIMOProxy\n    @return proxyState as a ProxyState struct containing a MIMOProxy state variables\n   */\n  function getProxyState(address proxy) external view override returns (ProxyState memory proxyState) {\n    proxyState = _proxyStates[proxy];\n  }\n\n  /**\n    @notice Gets the current MIMOProxy of the given owner.\n    @param owner The address of the owner of the current MIMOProxy.\n   */\n  function getCurrentProxy(address owner) external view override returns (IMIMOProxy proxy) {\n    proxy = _currentProxies[owner];\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy\n    @return pendingOwner that has yet to claim his ownership\n   */\n  function getPendingOwner(address proxy) external view override returns (address pendingOwner) {\n    pendingOwner = _pendingOwners[proxy];\n  }\n\n  function _clearPermissions(address proxy) internal {\n    IMIMOProxyGuard proxyGuard = IMIMOProxyGuard(mimoProxyGuardBase.clone());\n    proxyGuard.initialize(address(this), proxy);\n    _proxyStates[proxy].proxyGuard = proxyGuard;\n\n    emit PermissionsCleared(proxy, address(proxyGuard));\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title MIMOProxy\ncontract MIMOProxy is IMIMOProxy, BoringBatchable {\n  /// PUBLIC STORAGE ///\n  IMIMOProxyFactory public immutable override proxyFactory;\n\n  /// CONSTRUCTOR ///\n  constructor(address _proxyFactory) {\n    proxyFactory = IMIMOProxyFactory(_proxyFactory);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /**\n    @notice Delegate calls to the target contract by forwarding the call data. Returns the data it gets back,\n    including when the contract call reverts with a reason or custom error\n    @dev Requirements:\n      - The caller must be either an owner or an envoy\n      - `target` must be a deployed contract\n      - The owner cannot be changed during the DELEGATECALL\n    @param target The address of the target contract\n    @param data Function selector plus ABI encoded data\n    @return response The response received from the target contract\n   */\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    IMIMOProxyFactory.ProxyState memory state = proxyFactory.getProxyState(address(this));\n\n    // Check that the caller is either the owner or an envoy.\n    if (state.owner != msg.sender) {\n      bytes4 selector = bytes4(data[:4]);\n      if (!state.proxyGuard.getPermission(msg.sender, target, selector)) {\n        revert Errors.EXECUTION_NOT_AUTHORIZED(state.owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert Errors.TARGET_INVALID(target);\n    }\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - state.minGas;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert Errors.EXECUTION_REVERTED();\n      }\n    }\n  }\n}"
    }
  ]
}