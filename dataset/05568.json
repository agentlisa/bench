{
  "Title": "[L-07] Consider using enum values instead of numbers",
  "Content": "https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L826\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L831\n\n`status == ICdpManagerData.Status.active`\n\n`status == ICdpManagerData.Status.nonExistent`\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/BorrowerOperations.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ICdpManager.sol\";\nimport \"./Interfaces/ICdpManagerData.sol\";\nimport \"./Interfaces/IEBTCToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedCdps.sol\";\nimport \"./Dependencies/EbtcBase.sol\";\nimport \"./Dependencies/ReentrancyGuard.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/AuthNoOwner.sol\";\nimport \"./Dependencies/ERC3156FlashLender.sol\";\nimport \"./Dependencies/PermitNonce.sol\";\n\n/// @title BorrowerOperations is mainly in charge of all end user interactions like Cdp open, adjust, close etc\n/// @notice End users could approve delegate via IPositionManagers for authorized actions on their behalf\n/// @dev BorrowerOperations also allows ERC3156 compatible flashmint of eBTC token\ncontract BorrowerOperations is\n    EbtcBase,\n    ReentrancyGuard,\n    IBorrowerOperations,\n    ERC3156FlashLender,\n    AuthNoOwner,\n    PermitNonce\n{\n    string public constant NAME = \"BorrowerOperations\";\n\n    // keccak256(\"permitPositionManagerApproval(address borrower,address positionManager,uint8 status,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _PERMIT_POSITION_MANAGER_TYPEHASH =\n        keccak256(\n            \"PermitPositionManagerApproval(address borrower,address positionManager,uint8 status,uint256 nonce,uint256 deadline)\"\n        );\n\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant _TYPE_HASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    string internal constant _VERSION = \"1\";\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n\n    // --- Connected contract declarations ---\n\n    ICdpManager public immutable cdpManager;\n\n    ICollSurplusPool public immutable collSurplusPool;\n\n    address public feeRecipientAddress;\n\n    IEBTCToken public immutable ebtcToken;\n\n    // A doubly linked list of Cdps, sorted by their collateral ratios\n    ISortedCdps public immutable sortedCdps;\n\n    // Mapping of borrowers to approved position managers, by approval status: cdpOwner(borrower) -> positionManager -> PositionManagerApproval (None, OneTime, Persistent)\n    mapping(address => mapping(address => PositionManagerApproval)) public positionManagers;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct AdjustCdpLocals {\n        uint256 price;\n        uint256 collSharesChange;\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 debt;\n        uint256 collShares;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 newDebt;\n        uint256 newCollShares;\n        uint256 stake;\n    }\n\n    struct OpenCdpLocals {\n        uint256 price;\n        uint256 debt;\n        uint256 netStEthBalance;\n        uint256 ICR;\n        uint256 NICR;\n        uint256 stake;\n        uint256 arrayIndex;\n    }\n\n    struct MoveTokensParams {\n        address user;\n        uint256 collSharesChange;\n        uint256 collAddUnderlying; // ONLY for isCollIncrease=true\n        bool isCollIncrease;\n        uint256 netDebtChange;\n        bool isDebtIncrease;\n    }\n\n    // --- Dependency setters ---\n    constructor(\n        address _cdpManagerAddress,\n        address _activePoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedCdpsAddress,\n        address _ebtcTokenAddress,\n        address _feeRecipientAddress,\n        address _collTokenAddress\n    ) EbtcBase(_activePoolAddress, _priceFeedAddress, _collTokenAddress) {\n        cdpManager = ICdpManager(_cdpManagerAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedCdps = ISortedCdps(_sortedCdpsAddress);\n        ebtcToken = IEBTCToken(_ebtcTokenAddress);\n        feeRecipientAddress = _feeRecipientAddress;\n\n        address _authorityAddress = address(AuthNoOwner(_cdpManagerAddress).authority());\n        if (_authorityAddress != address(0)) {\n            _initializeAuthority(_authorityAddress);\n        }\n\n        bytes32 hashedName = keccak256(bytes(NAME));\n        bytes32 hashedVersion = keccak256(bytes(_VERSION));\n\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _chainID();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);\n\n        emit FeeRecipientAddressChanged(_feeRecipientAddress);\n    }\n\n    /**\n        @notice BorrowerOperations and CdpManager share reentrancy status by confirming the other's locked flag before beginning operation\n        @dev This is an alternative to the more heavyweight solution of both being able to set the reentrancy flag on a 3rd contract.\n        @dev Prevents multi-contract reentrancy between these two contracts\n     */\n    modifier nonReentrantSelfAndCdpM() {\n        require(locked == OPEN, \"BorrowerOperations: Reentrancy in nonReentrant call\");\n        require(\n            ReentrancyGuard(address(cdpManager)).locked() == OPEN,\n            \"CdpManager: Reentrancy in nonReentrant call\"\n        );\n\n        locked = LOCKED;\n\n        _;\n\n        locked = OPEN;\n    }\n\n    // --- Borrower Cdp Operations ---\n\n    /// @notice Function that creates a Cdp for the caller with the requested debt, and the stETH received as collateral.\n    /// @notice Successful execution is conditional mainly on the resulting collateralization ratio which must exceed minimum requirement, e.g., MCR.\n    /// @notice Upon Cdp open, a separate gas stipend (denominated in stETH) will be allocated for possible liquidation.\n    /// @param _debt The expected debt for this new Cdp\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _stEthBalance The total stETH collateral amount deposited for the specified Cdp\n    /// @return The CdpId for this newly created Cdp\n    function openCdp(\n        uint256 _debt,\n        bytes32 _upperHint,\n        bytes32 _lowerHint,\n        uint256 _stEthBalance\n    ) external override nonReentrantSelfAndCdpM returns (bytes32) {\n        return _openCdp(_debt, _upperHint, _lowerHint, _stEthBalance, msg.sender);\n    }\n\n    /// @notice Function that creates a Cdp for the specified _borrower by caller with the requested debt, and the stETH received as collateral.\n    /// @dev Caller will need approval from _borrower via IPositionManagers if they are different address\n    /// @notice Successful execution is conditional mainly on the resulting collateralization ratio which must exceed minimum requirement, e.g., MCR.\n    /// @notice Upon Cdp open, a separate gas stipend (denominated in stETH) will be allocated for possible liquidation.\n    /// @param _debt The expected debt for this new Cdp\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _stEthBalance The total stETH collateral amount deposited for the specified Cdp\n    /// @param _borrower The Cdp owner for this new Cdp.\n    /// @return The CdpId for this newly created Cdp\n    function openCdpFor(\n        uint256 _debt,\n        bytes32 _upperHint,\n        bytes32 _lowerHint,\n        uint256 _stEthBalance,\n        address _borrower\n    ) external override nonReentrantSelfAndCdpM returns (bytes32) {\n        return _openCdp(_debt, _upperHint, _lowerHint, _stEthBalance, _borrower);\n    }\n\n    /// @notice Function that adds the received stETH to the specified Cdp.\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\n    /// @param _cdpId The CdpId on which this operation is operated\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _stEthBalanceIncrease The total stETH collateral amount deposited (added) for the specified Cdp\n    function addColl(\n        bytes32 _cdpId,\n        bytes32 _upperHint,\n        bytes32 _lowerHint,\n        uint256 _stEthBalanceIncrease\n    ) external override nonReentrantSelfAndCdpM {\n        _adjustCdpInternal(_cdpId, 0, 0, false, _upperHint, _lowerHint, _stEthBalanceIncrease);\n    }\n\n    /// @notice Function that withdraws `_stEthBalanceDecrease` amount of collateral from the specified Cdp\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\n    /// @notice Successful execution is conditional on whether the withdrawal would bring down the ICR or TCR to the minimum requirement, e.g., MCR or CCR\n    /// @param _cdpId The CdpId on which this operation is operated\n    /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn (reduced) for the specified Cdp\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\n    function withdrawColl(\n        bytes32 _cdpId,\n        uint256 _stEthBalanceDecrease,\n        bytes32 _upperHint,\n        bytes32 _lowerHint\n    ) external override nonReentrantSelfAndCdpM {\n        _adjustCdpInternal(_cdpId, _stEthBalanceDecrease, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    /// @notice Function that withdraws `_debt` amount of eBTC token from the specified Cdp, thus increasing its debt accounting\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\n    /// @notice Successful execution is conditional on whether the withdrawal would bring down the ICR or TCR to the minimum requirement, e.g., MCR or CCR\n    /// @param _cdpId The CdpId on which this operation is operated\n    /// @param _debt The total debt collateral amount increased for the specified Cdp\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\n    function withdrawDebt(\n        bytes32 _cdpId,\n        uint256 _debt,\n        bytes32 _upperHint,\n        bytes32 _lowerHint\n    ) external override nonReentrantSelfAndCdpM {\n        _adjustCdpInternal(_cdpId, 0, _debt, true, _upperHint, _lowerHint, 0);\n    }\n\n    /// @notice Function that repays the received eBTC token to the specified Cdp, thus reducing its debt accounting.\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\n    /// @param _cdpId The CdpId on which this operation is operated\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _debt The total eBTC debt amount repaid for the specified Cdp\n    function repayDebt(\n        bytes32 _cdpId,\n        uint256 _debt,\n        bytes32 _upperHint,\n        bytes32 _lowerHint\n    ) external override nonReentrantSelfAndCdpM {\n        _adjustCdpInternal(_cdpId, 0, _debt, false, _upperHint, _lowerHint, 0);\n    }\n\n    /// @notice Function that allows various operations which might change both collateral and debt\n    /// @notice like taking more risky position (withdraws eBTC token and reduces stETH collateral)\n    /// @notice or holding more safer position (repays eBTC token) with the specified Cdp.\n    /// @notice If end user want to add collateral and change debt at the same time, use adjustCdpWithColl() instead\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\n    /// @param _cdpId The CdpId on which this operation is operated\n    /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp\n    /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp\n    /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\n    function adjustCdp(\n        bytes32 _cdpId,\n        uint256 _stEthBalanceDecrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        bytes32 _upperHint,\n        bytes32 _lowerHint\n    ) external override nonReentrantSelfAndCdpM {\n        _adjustCdpInternal(\n            _cdpId,\n            _stEthBalanceDecrease,\n            _debtChange,\n            _isDebtIncrease,\n            _upperHint,\n            _lowerHint,\n            0\n        );\n    }\n\n    /// @notice Function that allows various operations which might change both collateral and debt\n    /// @notice like taking more risky position (withdraws eBTC token and reduces stETH collateral)\n    /// @notice or holding more safer position (repays eBTC token and adds stETH collateral) with the specified Cdp.\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\n    /// @param _cdpId The CdpId on which this operation is operated\n    /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp\n    /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp\n    /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\n    /// @param _stEthBalanceIncrease The total stETH collateral amount deposited (added) for the specified Cdp\n    function adjustCdpWithColl(\n        bytes32 _cdpId,\n        uint256 _stEthBalanceDecrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        bytes32 _upperHint,\n        bytes32 _lowerHint,\n        uint256 _stEthBalanceIncrease\n    ) external override nonReentrantSelfAndCdpM {\n        _adjustCdpInternal(\n            _cdpId,\n            _stEthBalanceDecrease,\n            _debtChange,\n            _isDebtIncrease,\n            _upperHint,\n            _lowerHint,\n            _stEthBalanceIncrease\n        );\n    }\n\n    /*\n     * _adjustCdpInternal(): Alongside a debt change, this function can perform either\n     * a collateral top-up or a collateral withdrawal.\n     *\n     * It therefore expects either a positive _stEthBalanceIncrease, or a positive _stEthBalanceDecrease argument.\n     *\n     * If both are positive, it will revert.\n     */\n    function _adjustCdpInternal(\n        bytes32 _cdpId,\n        uint256 _stEthBalanceDecrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        bytes32 _upperHint,\n        bytes32 _lowerHint,\n        uint256 _stEthBalanceIncrease\n    ) internal {\n        // Confirm the operation is the borrower or approved position manager adjusting its own cdp\n        address _borrower = sortedCdps.getOwnerAddress(_cdpId);\n        _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);\n\n        _requireCdpisActive(cdpManager, _cdpId);\n\n        cdpManager.syncAccounting(_cdpId);\n\n        AdjustCdpLocals memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n\n        if (_isDebtIncrease) {\n            _requireNonZeroDebtChange(_debtChange);\n        }\n        _requireSingularCollChange(_stEthBalanceIncrease, _stEthBalanceDecrease);\n        _requireNonZeroAdjustment(_stEthBalanceIncrease, _stEthBalanceDecrease, _debtChange);\n\n        // Get the collSharesChange based on the collateral value transferred in the transaction\n        (vars.collSharesChange, vars.isCollIncrease) = _getCollSharesChangeFromStEthChange(\n            _stEthBalanceIncrease,\n            _stEthBalanceDecrease\n        );\n\n        vars.netDebtChange = _debtChange;\n\n        vars.debt = cdpManager.getCdpDebt(_cdpId);\n        vars.collShares = cdpManager.getCdpCollShares(_cdpId);\n\n        // Get the cdp's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        uint256 _cdpStEthBalance = collateral.getPooledEthByShares(vars.collShares);\n        require(\n            _stEthBalanceDecrease <= _cdpStEthBalance,\n            \"BorrowerOperations: Cannot withdraw greater stEthBalance than the value in Cdp\"\n        );\n        vars.oldICR = EbtcMath._computeCR(_cdpStEthBalance, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromCdpChange(\n            vars.collShares,\n            vars.debt,\n            vars.collSharesChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease,\n            vars.price\n        );\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        bool isRecoveryMode = _checkRecoveryModeForTCR(_getCachedTCR(vars.price));\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            _stEthBalanceDecrease,\n            _isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it's a valid amount, that the caller has enough EBTC, and that the resulting debt is >0\n        if (!_isDebtIncrease && _debtChange > 0) {\n            _requireValidDebtRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientEbtcTokenBalance(msg.sender, vars.netDebtChange);\n            _requireNonZeroDebt(vars.debt - vars.netDebtChange);\n        }\n\n        (vars.newCollShares, vars.newDebt) = _getNewCdpAmounts(\n            vars.collShares,\n            vars.debt,\n            vars.collSharesChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease\n        );\n\n        _requireAtLeastMinNetStEthBalance(collateral.getPooledEthByShares(vars.newCollShares));\n\n        cdpManager.updateCdp(\n            _cdpId,\n            _borrower,\n            vars.collShares,\n            vars.debt,\n            vars.newCollShares,\n            vars.newDebt\n        );\n\n        // Re-insert cdp in to the sorted list\n        {\n            uint256 newNICR = _getNewNominalICRFromCdpChange(vars, _isDebtIncrease);\n            sortedCdps.reInsert(_cdpId, newNICR, _upperHint, _lowerHint);\n        }\n\n        // CEI: Process token movements\n        {\n            MoveTokensParams memory _varMvTokens = MoveTokensParams(\n                msg.sender,\n                vars.collSharesChange,\n                (vars.isCollIncrease ? _stEthBalanceIncrease : 0),\n                vars.isCollIncrease,\n                _debtChange,\n                _isDebtIncrease\n            );\n            _processTokenMovesFromAdjustment(_varMvTokens);\n        }\n    }\n\n    function _openCdp(\n        uint256 _debt,\n        bytes32 _upperHint,\n        bytes32 _lowerHint,\n        uint256 _stEthBalance,\n        address _borrower\n    ) internal returns (bytes32) {\n        _requireNonZeroDebt(_debt);\n        _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);\n\n        OpenCdpLocals memory vars;\n\n        // ICR is based on the net stEth balance, i.e. the specified stEth balance amount - fixed liquidator incentive gas comp.\n        vars.netStEthBalance = _calcNetStEthBalance(_stEthBalance);\n\n        _requireAtLeastMinNetStEthBalance(vars.netStEthBalance);\n\n        // Update global pending index before any operations\n        cdpManager.syncGlobalAccounting();\n\n        vars.price = priceFeed.fetchPrice();\n        vars.debt = _debt;\n\n        // Sanity check\n        require(vars.netStEthBalance > 0, \"BorrowerOperations: zero collateral for openCdp()!\");\n\n        uint256 _netCollAsShares = collateral.getSharesByPooledEth(vars.netStEthBalance);\n        uint256 _liquidatorRewardShares = collateral.getSharesByPooledEth(LIQUIDATOR_REWARD);\n\n        // ICR is based on the net coll, i.e. the requested coll amount - fixed liquidator incentive gas comp.\n        vars.ICR = EbtcMath._computeCR(vars.netStEthBalance, vars.debt, vars.price);\n\n        // NICR uses shares to normalize NICR across Cdps opened at different pooled ETH / shares ratios\n        vars.NICR = EbtcMath._computeNominalCR(_netCollAsShares, vars.debt);\n\n        /**\n            In recovery move, ICR must be greater than CCR\n            CCR > MCR (125% vs 110%)\n\n            In normal mode, ICR must be greater thatn MCR\n            Additionally, the new system TCR after the Cdps addition must be >CCR\n        */\n        bool isRecoveryMode = _checkRecoveryModeForTCR(_getCachedTCR(vars.price));\n        uint256 newTCR = _getNewTCRFromCdpChange(\n            vars.netStEthBalance,\n            true,\n            vars.debt,\n            true,\n            vars.price\n        );\n        if (isRecoveryMode) {\n            _requireICRisNotBelowCCR(vars.ICR);\n\n            // == Grace Period == //\n            // We are in RM, Edge case is Depositing Coll could exit RM\n            // We check with newTCR\n            if (newTCR < CCR) {\n                // Notify RM\n                cdpManager.notifyStartGracePeriod(newTCR);\n            } else {\n                // Notify Back to Normal Mode\n                cdpManager.notifyEndGracePeriod(newTCR);\n            }\n        } else {\n            _requireICRisNotBelowMCR(vars.ICR);\n            _requireNewTCRisNotBelowCCR(newTCR);\n\n            // == Grace Period == //\n            // We are not in RM, no edge case, we always stay above RM\n            // Always Notify Back to Normal Mode\n            cdpManager.notifyEndGracePeriod(newTCR);\n        }\n\n        // Set the cdp struct's properties\n        bytes32 _cdpId = sortedCdps.insert(_borrower, vars.NICR, _upperHint, _lowerHint);\n\n        // Collision check: collisions should never occur\n        // Explicitly prevent it by checking for `nonExistent`\n        _requireCdpIsNonExistent(_cdpId);\n\n        // Collateral is stored in shares form for normalization\n        cdpManager.initializeCdp(\n            _cdpId,\n            vars.debt,\n            _netCollAsShares,\n            _liquidatorRewardShares,\n            _borrower\n        );\n\n        // CEI: Mint the full debt amount, in eBTC tokens, to the caller\n        _withdrawDebt(msg.sender, _debt);\n\n        /**\n            Note that only NET stEth balance (as shares) is considered part of the Cdp.\n            The static liqudiation incentive is stored in the gas pool and can be considered a deposit / voucher to be returned upon Cdp close, to the closer.\n            The close can happen from the borrower closing their own Cdp, a full liquidation, or a redemption.\n        */\n\n        // CEI: Move the collateral and liquidator gas compensation to the Active Pool. Track only net collateral for TCR purposes.\n        _activePoolAddColl(_stEthBalance, _netCollAsShares);\n\n        // Invariant check\n        require(\n            vars.netStEthBalance + LIQUIDATOR_REWARD == _stEthBalance,\n            \"BorrowerOperations: deposited collateral mismatch!\"\n        );\n\n        return _cdpId;\n    }\n\n    /// @notice Function that allows the caller to repay all debt, withdraw collateral, and close the specified Cdp\n    /// @notice Caller should have enough eBTC token to repay off the debt fully for specified Cdp\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\n    /// @param _cdpId The CdpId on which this operation is operated\n    function closeCdp(bytes32 _cdpId) external override {\n        address _borrower = sortedCdps.getOwnerAddress(_cdpId);\n        _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);\n\n        _requireCdpisActive(cdpManager, _cdpId);\n\n        cdpManager.syncAccounting(_cdpId);\n\n        uint256 price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(_getCachedTCR(price));\n\n        uint256 collShares = cdpManager.getCdpCollShares(_cdpId);\n        uint256 debt = cdpManager.getCdpDebt(_cdpId);\n        uint256 liquidatorRewardShares = cdpManager.getCdpLiquidatorRewardShares(_cdpId);\n\n        _requireSufficientEbtcTokenBalance(msg.sender, debt);\n\n        uint256 newTCR = _getNewTCRFromCdpChange(\n            collateral.getPooledEthByShares(collShares),\n            false,\n            debt,\n            false,\n            price\n        );\n        _requireNewTCRisNotBelowCCR(newTCR);\n\n        // == Grace Period == //\n        // By definition we are not in RM, notify CDPManager to ensure \"Glass is on\"\n        cdpManager.notifyEndGracePeriod(newTCR);\n\n        cdpManager.closeCdp(_cdpId, _borrower, debt, collShares);\n\n        // Burn the repaid EBTC from the user's balance\n        _repayDebt(msg.sender, debt);\n\n        // CEI: Send the collateral and liquidator reward shares back to the user\n        activePool.transferSystemCollSharesAndLiquidatorReward(\n            msg.sender,\n            collShares,\n            liquidatorRewardShares\n        );\n    }\n\n    /// @notice Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n    /// @notice when a Cdp has been fully redeemed from and closed, or liquidated in Recovery Mode with a collateralization ratio higher enough (like over MCR)\n    /// @notice the borrower is allowed to claim their stETH collateral surplus that remains in the system if any\n    function claimSurplusCollShares() external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimSurplusCollShares(msg.sender);\n    }\n\n    /// @notice Returns true if the borrower is allowing position manager to act on their behalf\n    /// @return PositionManagerApproval (None/OneTime/Persistent) status for given _borrower and _positionManager\n    /// @param _borrower The Cdp owner who use eBTC\n    /// @param _positionManager The position manager address in question whether it gets valid approval from _borrower\n    function getPositionManagerApproval(\n        address _borrower,\n        address _positionManager\n    ) external view override returns (PositionManagerApproval) {\n        return _getPositionManagerApproval(_borrower, _positionManager);\n    }\n\n    function _getPositionManagerApproval(\n        address _borrower,\n        address _positionManager\n    ) internal view returns (PositionManagerApproval) {\n        return positionManagers[_borrower][_positionManager];\n    }\n\n    /// @notice Approve an account (_positionManager) to take arbitrary actions on your Cdps.\n    /// @notice Position managers with 'Persistent' status will be able to take actions indefinitely\n    /// @notice Position managers with 'OneTIme' status will be able to take a single action on one Cdp. Approval will be automatically revoked after one Cdp-related action.\n    /// @notice Similar to approving tokens, approving a position manager allows _stealing of all positions_ if given to a malicious account.\n    /// @param _positionManager The position manager address which will get the specified approval from caller\n    /// @param _approval PositionManagerApproval (None/OneTime/Persistent) status set to the specified _positionManager for caller's Cdp\n    function setPositionManagerApproval(\n        address _positionManager,\n        PositionManagerApproval _approval\n    ) external override {\n        _setPositionManagerApproval(msg.sender, _positionManager, _approval);\n    }\n\n    function _setPositionManagerApproval(\n        address _borrower,\n        address _positionManager,\n        PositionManagerApproval _approval\n    ) internal {\n        positionManagers[_borrower][_positionManager] = _approval;\n        emit PositionManagerApprovalSet(_borrower, _positionManager, _approval);\n    }\n\n    /// @notice Revoke a position manager from taking further actions on your Cdps\n    /// @notice Similar to approving tokens, approving a position manager allows _stealing of all positions_ if given to a malicious account.\n    /// @param _positionManager The position manager address which will get all approval revoked by caller (a Cdp owner)\n    function revokePositionManagerApproval(address _positionManager) external override {\n        _setPositionManagerApproval(msg.sender, _positionManager, PositionManagerApproval.None);\n    }\n\n    /// @notice Allows recipient of delegation to renounce it\n    /// @param _borrower The Cdp owner address which will have all approval to the caller (a PositionManager) revoked.\n    function renouncePositionManagerApproval(address _borrower) external override {\n        _setPositionManagerApproval(_borrower, msg.sender, PositionManagerApproval.None);\n    }\n\n    /// @notice This function returns the domain separator for current chain\n    /// @return EIP712 compatible Domain definition\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return domainSeparator();\n    }\n\n    /// @notice This function returns the domain separator for current chain\n    /// @return EIP712 compatible Domain definition\n    function domainSeparator() public view override returns (bytes32) {\n        if (_chainID() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _chainID() private view returns (uint256) {\n        return block.chainid;\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 name,\n        bytes32 version\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, name, version, _chainID(), address(this)));\n    }\n\n    /// @notice This function returns the version parameter for the EIP712 domain\n    /// @return EIP712 compatible version parameter\n    function version() external pure override returns (string memory) {\n        return _VERSION;\n    }\n\n    /// @notice This function returns hash of the fully encoded EIP712 message for the permitPositionManagerApproval.\n    /// @return EIP712 compatible hash of Positon Manager permit\n    function permitTypeHash() external pure override returns (bytes32) {\n        return _PERMIT_POSITION_MANAGER_TYPEHASH;\n    }\n\n    /// @notice This function set given _approval for specified _borrower and _positionManager\n    /// @notice by verifying the validity of given deadline and signature parameters (v, r, s).\n    /// @param _borrower The Cdp owner\n    /// @param _positionManager The delegate to which _borrower want to grant approval\n    /// @param _approval The PositionManagerApproval (None/OneTime/Persistent) status to be set\n    /// @param _deadline The permit valid deadline\n    /// @param v The v part of signature from _borrower\n    /// @param r The r part of signature from _borrower\n    /// @param s The s part of signature from _borrower\n    function permitPositionManagerApproval(\n        address _borrower,\n        address _positionManager,\n        PositionManagerApproval _approval,\n        uint256 _deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(_deadline >= block.timestamp, \"BorrowerOperations: Position manager permit expired\");\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _PERMIT_POSITION_MANAGER_TYPEHASH,\n                        _borrower,\n                        _positionManager,\n                        _approval,\n                        _nonces[_borrower]++,\n                        _deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require("
    }
  ]
}