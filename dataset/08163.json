{
  "Title": "[N-03] RANGE, PRICE: unused import of `FullMath`",
  "Content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L18>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L23>\n\nThe modules `RANGE` and `PRICE` imports `FullMath`, but it is not used.\n\n```solidity\n// modules/PRICE.sol\n 22 contract OlympusPrice is Module {\n 23     using FullMath for uint256;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-olympus",
  "Code": [
    {
      "filename": "src/modules/RANGE.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport \"src/Kernel.sol\";\n\nerror RANGE_InvalidParams();\n\n/// @notice Olympus Range data storage module\n/// @dev    The Olympus Range contract stores information about the Olympus Range market operations status.\n///         It provides a standard interface for Range data, including range prices and capacities of each range side.\n///         The data provided by this contract is used by the Olympus Range Operator to perform market operations.\n///         The Olympus Range Data is updated each epoch by the Olympus Range Operator contract.\ncontract OlympusRange is Module {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    event WallUp(bool high_, uint256 timestamp_, uint256 capacity_);\n    event WallDown(bool high_, uint256 timestamp_, uint256 capacity_);\n    event CushionUp(bool high_, uint256 timestamp_, uint256 capacity_);\n    event CushionDown(bool high_, uint256 timestamp_);\n    event PricesChanged(\n        uint256 wallLowPrice_,\n        uint256 cushionLowPrice_,\n        uint256 cushionHighPrice_,\n        uint256 wallHighPrice_\n    );\n    event SpreadsChanged(uint256 cushionSpread_, uint256 wallSpread_);\n    event ThresholdFactorChanged(uint256 thresholdFactor_);\n\n    struct Line {\n        uint256 price; // Price for the specified level\n    }\n\n    struct Band {\n        Line high; // Price of the high side of the band\n        Line low; // Price of the low side of the band\n        uint256 spread; // Spread of the band (increase/decrease from the moving average to set the band prices), percent with 2 decimal places (i.e. 1000 = 10% spread)\n    }\n\n    struct Side {\n        bool active; // Whether or not the side is active (i.e. the Operator is performing market operations on this side, true = active, false = inactive)\n        uint48 lastActive; // Unix timestamp when the side was last active (in seconds)\n        uint256 capacity; // Amount of tokens that can be used to defend the side of the range. Specified in OHM tokens on the high side and Reserve tokens on the low side.\n        uint256 threshold; // Amount of tokens under which the side is taken down. Specified in OHM tokens on the high side and Reserve tokens on the low side.\n        uint256 market; // Market ID of the cushion bond market for the side. If no market is active, the market ID is set to max uint256 value.\n    }\n\n    struct Range {\n        Side low; // Data specific to the low side of the range\n        Side high; // Data specific to the high side of the range\n        Band cushion; // Data relevant to cushions on both sides of the range\n        Band wall; // Data relevant to walls on both sides of the range\n    }\n\n    // Range data singleton. See range().\n    Range internal _range;\n\n    /// @notice Threshold factor for the change, a percent in 2 decimals (i.e. 1000 = 10%). Determines how much of the capacity must be spent before the side is taken down.\n    /// @dev    A threshold is required so that a wall is not \"active\" with a capacity near zero, but unable to be depleted practically (dust).\n    uint256 public thresholdFactor;\n\n    uint256 public constant FACTOR_SCALE = 1e4;\n\n    /// @notice OHM token contract address\n    ERC20 public immutable ohm;\n\n    /// @notice Reserve token contract address\n    ERC20 public immutable reserve;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        ERC20[2] memory tokens_,\n        uint256[3] memory rangeParams_ // [thresholdFactor, cushionSpread, wallSpread]\n    ) Module(kernel_) {\n        _range = Range({\n            low: Side({\n                active: false,\n                lastActive: uint48(block.timestamp),\n                capacity: 0,\n                threshold: 0,\n                market: type(uint256).max\n            }),\n            high: Side({\n                active: false,\n                lastActive: uint48(block.timestamp),\n                capacity: 0,\n                threshold: 0,\n                market: type(uint256).max\n            }),\n            cushion: Band({low: Line({price: 0}), high: Line({price: 0}), spread: rangeParams_[1]}),\n            wall: Band({low: Line({price: 0}), high: Line({price: 0}), spread: rangeParams_[2]})\n        });\n\n        thresholdFactor = rangeParams_[0];\n        ohm = tokens_[0];\n        reserve = tokens_[1];\n\n        emit SpreadsChanged(rangeParams_[1], rangeParams_[2]);\n        emit ThresholdFactorChanged(rangeParams_[0]);\n    }\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"RANGE\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Update the capacity for a side of the range.\n    /// @notice Access restricted to activated policies.\n    /// @param  high_ - Specifies the side of the range to update capacity for (true = high side, false = low side).\n    /// @param  capacity_ - Amount to set the capacity to (OHM tokens for high side, Reserve tokens for low side).\n    function updateCapacity(bool high_, uint256 capacity_) external permissioned {\n        if (high_) {\n            // Update capacity\n            _range.high.capacity = capacity_;\n\n            // If the new capacity is below the threshold, deactivate the wall if they are currently active\n            if (capacity_ < _range.high.threshold && _range.high.active) {\n                // Set wall to inactive\n                _range.high.active = false;\n                _range.high.lastActive = uint48(block.timestamp);\n\n                emit WallDown(true, block.timestamp, capacity_);\n            }\n        } else {\n            // Update capacity\n            _range.low.capacity = capacity_;\n\n            // If the new capacity is below the threshold, deactivate the wall if they are currently active\n            if (capacity_ < _range.low.threshold && _range.low.active) {\n                // Set wall to inactive\n                _range.low.active = false;\n                _range.low.lastActive = uint48(block.timestamp);\n\n                emit WallDown(false, block.timestamp, capacity_);\n            }\n        }\n    }\n\n    /// @notice Update the prices for the low and high sides.\n    /// @notice Access restricted to activated policies.\n    /// @param  movingAverage_ - Current moving average price to set range prices from.\n    function updatePrices(uint256 movingAverage_) external permissioned {\n        // Cache the spreads\n        uint256 wallSpread = _range.wall.spread;\n        uint256 cushionSpread = _range.cushion.spread;\n\n        // Calculate new wall and cushion values from moving average and spread\n        _range.wall.low.price = (movingAverage_ * (FACTOR_SCALE - wallSpread)) / FACTOR_SCALE;\n        _range.wall.high.price = (movingAverage_ * (FACTOR_SCALE + wallSpread)) / FACTOR_SCALE;\n\n        _range.cushion.low.price = (movingAverage_ * (FACTOR_SCALE - cushionSpread)) / FACTOR_SCALE;\n        _range.cushion.high.price =\n            (movingAverage_ * (FACTOR_SCALE + cushionSpread)) /\n            FACTOR_SCALE;\n\n        emit PricesChanged(\n            _range.wall.low.price,\n            _range.cushion.low.price,\n            _range.cushion.high.price,\n            _range.wall.high.price\n        );\n    }\n\n    /// @notice Regenerate a side of the range to a specific capacity.\n    /// @notice Access restricted to activated policies.\n    /// @param  high_ - Specifies the side of the range to regenerate (true = high side, false = low side).\n    /// @param  capacity_ - Amount to set the capacity to (OHM tokens for high side, Reserve tokens for low side).\n    function regenerate(bool high_, uint256 capacity_) external permissioned {\n        uint256 threshold = (capacity_ * thresholdFactor) / FACTOR_SCALE;\n\n        if (high_) {\n            // Re-initialize the high side\n            _range.high = Side({\n                active: true,\n                lastActive: uint48(block.timestamp),\n                capacity: capacity_,\n                threshold: threshold,\n                market: _range.high.market\n            });\n        } else {\n            // Reinitialize the low side\n            _range.low = Side({\n                active: true,\n                lastActive: uint48(block.timestamp),\n                capacity: capacity_,\n                threshold: threshold,\n                market: _range.low.market\n            });\n        }\n\n        emit WallUp(high_, block.timestamp, capacity_);\n    }\n\n    /// @notice Update the market ID (cushion) for a side of the range.\n    /// @notice Access restricted to activated policies.\n    /// @param  high_ - Specifies the side of the range to update market for (true = high side, false = low side).\n    /// @param  market_ - Market ID to set for the side.\n    /// @param  marketCapacity_ - Amount to set the last market capacity to (OHM tokens for high side, Reserve tokens for low side).\n    function updateMarket(\n        bool high_,\n        uint256 market_,\n        uint256 marketCapacity_\n    ) public permissioned {\n        // If market id is max uint256, then marketCapacity must be 0\n        if (market_ == type(uint256).max && marketCapacity_ != 0) revert RANGE_InvalidParams();\n\n        // Store updated state\n        if (high_) {\n            _range.high.market = market_;\n        } else {\n            _range.low.market = market_;\n        }\n\n        if (market_ == type(uint256).max) {\n            emit CushionDown(high_, block.timestamp);\n        } else {\n            emit CushionUp(high_, block.timestamp, marketCapacity_);\n        }\n    }\n\n    /// @notice Set the wall and cushion spreads.\n    /// @notice Access restricted to activated policies.\n    /// @param  cushionSpread_ - Percent spread to set the cushions at above/below the moving average, assumes 2 decimals (i.e. 1000 = 10%).\n    /// @param  wallSpread_ - Percent spread to set the walls at above/below the moving average, assumes 2 decimals (i.e. 1000 = 10%).\n    /// @dev    The new spreads will not go into effect until the next time updatePrices() is called.\n    function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {\n        // Confirm spreads are within allowed values\n        if (\n            wallSpread_ > 10000 ||\n            wallSpread_ < 100 ||\n            cushionSpread_ > 10000 ||\n            cushionSpread_ < 100 ||\n            cushionSpread_ > wallSpread_\n        ) revert RANGE_InvalidParams();\n\n        // Set spreads\n        _range.wall.spread = wallSpread_;\n        _range.cushion.spread = cushionSpread_;\n\n        emit SpreadsChanged(wallSpread_, cushionSpread_);\n    }\n\n    /// @notice Set the threshold factor for when a wall is considered \"down\".\n    /// @notice Access restricted to activated policies.\n    /// @param  thresholdFactor_ - Percent of capacity that the wall should close below, assumes 2 decimals (i.e. 1000 = 10%).\n    /// @dev    The new threshold factor will not go into effect until the next time regenerate() is called for each side of the wall.\n    function setThresholdFactor(uint256 thresholdFactor_) external permissioned {\n        if (thresholdFactor_ > 10000 || thresholdFactor_ < 100) revert RANGE_InvalidParams();\n        thresholdFactor = thresholdFactor_;\n\n        emit ThresholdFactorChanged(thresholdFactor_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the full Range data in a struct.\n    function range() external view returns (Range memory) {\n        return _range;\n    }\n\n    /// @notice Get the capacity for a side of the range.\n    /// @param  high_ - Specifies the side of the range to get capacity for (true = high side, false = low side).\n    function capacity(bool high_) external view returns (uint256) {\n        if (high_) {\n            return _range.high.capacity;\n        } else {\n            return _range.low.capacity;\n        }\n    }\n\n    /// @notice Get the status of a side of the range (whether it is active or not).\n    /// @param  high_ - Specifies the side of the range to get status for (true = high side, false = low side).\n    function active(bool high_) external view returns (bool) {\n        if (high_) {\n            return _range.high.active;\n        } else {\n            return _range.low.active;\n        }\n    }\n\n    /// @notice Get the price for the wall or cushion for a side of the range.\n    /// @param  wall_ - Specifies the band to get the price for (true = wall, false = cushion).\n    /// @param  high_ - Specifies the side of the range to get the price for (true = high side, false = low side).\n    function price(bool wall_, bool high_) external view returns (uint256) {\n        if (wall_) {\n            if (high_) {\n                return _range.wall.high.price;\n            } else {\n                return _range.wall.low.price;\n            }\n        } else {\n            if (high_) {\n                return _range.cushion.high.price;\n            } else {\n                return _range.cushion.low.price;\n            }\n        }\n    }\n\n    /// @notice Get the spread for the wall or cushion band.\n    /// @param  wall_ - Specifies the band to get the spread for (true = wall, false = cushion).\n    function spread(bool wall_) external view returns (uint256) {\n        if (wall_) {\n            return _range.wall.spread;\n        } else {\n            return _range.cushion.spread;\n        }\n    }\n\n    /// @notice Get the market ID for a side of the range.\n    /// @param  high_ - Specifies the side of the range to get market for (true = high side, false = low side).\n    function market(bool high_) external view returns (uint256) {\n        if (high_) {\n            return _range.high.market;\n        } else {\n            return _range.low.market;\n        }\n    }\n\n    /// @notice Get the timestamp when the range was last active.\n    /// @param  high_ - Specifies the side of the range to get timestamp for (true = high side, false = low side).\n    function lastActive(bool high_) external view returns (uint256) {\n        if (high_) {\n            return _range.high.lastActive;\n        } else {\n            return _range.low.lastActive;\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/PRICE.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {AggregatorV2V3Interface} from \"interfaces/AggregatorV2V3Interface.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport \"src/Kernel.sol\";\n\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n// ERRORS\nerror Price_InvalidParams();\nerror Price_NotInitialized();\nerror Price_AlreadyInitialized();\nerror Price_BadFeed(address priceFeed);\n\n/// @notice Price oracle data storage contract\n/// @dev    The Olympus Price Oracle contract provides a standard interface for OHM price data against a reserve asset.\n///         It also implements a moving average price calculation (same as a TWAP) on the price feed data over a configured\n///         duration and observation frequency. The data provided by this contract is used by the Olympus Range Operator to\n///         perform market operations. The Olympus Price Oracle is updated each epoch by the Olympus Heart contract.\ncontract OlympusPrice is Module {\n    using FullMath for uint256;\n\n    /* ========== EVENTS =========== */\n    event NewObservation(uint256 timestamp_, uint256 price_, uint256 movingAverage_);\n    event MovingAverageDurationChanged(uint48 movingAverageDuration_);\n    event ObservationFrequencyChanged(uint48 observationFrequency_);\n    /* ========== STATE VARIABLES ========== */\n\n    /// @dev    Price feeds. Chainlink typically provides price feeds for an asset in ETH. Therefore, we use two price feeds against ETH, one for OHM and one for the Reserve asset, to calculate the relative price of OHM in the Reserve asset.\n    AggregatorV2V3Interface internal immutable _ohmEthPriceFeed;\n    AggregatorV2V3Interface internal immutable _reserveEthPriceFeed;\n\n    /// @dev Moving average data\n    uint256 internal _movingAverage; /// See getMovingAverage()\n\n    /// @notice Array of price observations. Check nextObsIndex to determine latest data point.\n    /// @dev    Observations are stored in a ring buffer where the moving average is the sum of all observations divided by the number of observations.\n    ///         Observations can be cleared by changing the movingAverageDuration or observationFrequency and must be re-initialized.\n    uint256[] public observations;\n\n    /// @notice Index of the next observation to make. The current value at this index is the oldest observation.\n    uint32 public nextObsIndex;\n\n    /// @notice Number of observations used in the moving average calculation. Computed from movingAverageDuration / observationFrequency.\n    uint32 public numObservations;\n\n    /// @notice Frequency (in seconds) that observations should be stored.\n    uint48 public observationFrequency;\n\n    /// @notice Duration (in seconds) over which the moving average is calculated.\n    uint48 public movingAverageDuration;\n\n    /// @notice Unix timestamp of last observation (in seconds).\n    uint48 public lastObservationTime;\n\n    /// @notice Number of decimals in the price values provided by the contract.\n    uint8 public constant decimals = 18;\n\n    /// @notice Whether the price module is initialized (and therefore active).\n    bool public initialized;\n\n    // Scale factor for converting prices, calculated from decimal values.\n    uint256 internal immutable _scaleFactor;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        AggregatorV2V3Interface ohmEthPriceFeed_,\n        AggregatorV2V3Interface reserveEthPriceFeed_,\n        uint48 observationFrequency_,\n        uint48 movingAverageDuration_\n    ) Module(kernel_) {\n        /// @dev Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency_ != 0)\n            revert Price_InvalidParams();\n\n        // Set price feeds, decimals, and scale factor\n        _ohmEthPriceFeed = ohmEthPriceFeed_;\n        uint8 ohmEthDecimals = _ohmEthPriceFeed.decimals();\n\n        _reserveEthPriceFeed = reserveEthPriceFeed_;\n        uint8 reserveEthDecimals = _reserveEthPriceFeed.decimals();\n\n        uint256 exponent = decimals + reserveEthDecimals - ohmEthDecimals;\n        if (exponent > 38) revert Price_InvalidParams();\n        _scaleFactor = 10**exponent;\n\n        // Set parameters and calculate number of observations\n        observationFrequency = observationFrequency_;\n        movingAverageDuration = movingAverageDuration_;\n\n        numObservations = uint32(movingAverageDuration_ / observationFrequency_);\n\n        // Store blank observations array\n        observations = new uint256[](numObservations);\n        /// nextObsIndex is initialized to 0\n\n        emit MovingAverageDurationChanged(movingAverageDuration_);\n        emit ObservationFrequencyChanged(observationFrequency_);\n    }\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"PRICE\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /* ========== POLICY FUNCTIONS ========== */\n\n    /// @notice Trigger an update of the moving average. Permissioned.\n    /// @dev    This function does not have a time-gating on the observationFrequency on this contract. It is set on the Heart policy contract.\n    ///         The Heart beat frequency should be set to the same value as the observationFrequency.\n    function updateMovingAverage() external permissioned {\n        // Revert if not initialized\n        if (!initialized) revert Price_NotInitialized();\n\n        // Cache numbe of observations to save gas.\n        uint32 numObs = numObservations;\n\n        // Get earliest observation in window\n        uint256 earliestPrice = observations[nextObsIndex];\n\n        uint256 currentPrice = getCurrentPrice();\n\n        // Calculate new moving average\n        if (currentPrice > earliestPrice) {\n            _movingAverage += (currentPrice - earliestPrice) / numObs;\n        } else {\n            _movingAverage -= (earliestPrice - currentPrice) / numObs;\n        }\n\n        // Push new observation into storage and store timestamp taken at\n        observations[nextObsIndex] = currentPrice;\n        lastObservationTime = uint48(block.timestamp);\n        nextObsIndex = (nextObsIndex + 1) % numObs;\n\n        emit NewObservation(block.timestamp, currentPrice, _movingAverage);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the current price of OHM in the Reserve asset from the price feeds\n    function getCurrentPrice() public view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n\n        // Get prices from feeds\n        uint256 ohmEthPrice;\n        uint256 reserveEthPrice;\n        {\n            (, int256 ohmEthPriceInt, , uint256 updatedAt, ) = _ohmEthPriceFeed.latestRoundData();\n            // Use a multiple of observation frequency to determine what is too old to use.\n            // Price feeds will not provide an updated answer if the data doesn't change much.\n            // This would be similar to if the feed just stopped updating; therefore, we need a cutoff.\n            if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))\n                revert Price_BadFeed(address(_ohmEthPriceFeed));\n            ohmEthPrice = uint256(ohmEthPriceInt);\n\n            int256 reserveEthPriceInt;\n            (, reserveEthPriceInt, , updatedAt, ) = _reserveEthPriceFeed.latestRoundData();\n            if (updatedAt < block.timestamp - uint256(observationFrequency))\n                revert Price_BadFeed(address(_reserveEthPriceFeed));\n            reserveEthPrice = uint256(reserveEthPriceInt);\n        }\n\n        // Convert to OHM/RESERVE price\n        uint256 currentPrice = (ohmEthPrice * _scaleFactor) / reserveEthPrice;\n\n        return currentPrice;\n    }\n\n    /// @notice Get the last stored price observation of OHM in the Reserve asset\n    function getLastPrice() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;\n        return observations[lastIndex];\n    }\n\n    /// @notice Get the moving average of OHM in the Reserve asset over the defined window (see movingAverageDuration and observationFrequency).\n    function getMovingAverage() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n        return _movingAverage;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initialize the price module\n    /// @notice Access restricted to activated policies\n    /// @param  startObservations_ - Array of observations to initialize the moving average with. Must be of length numObservations.\n    /// @param  lastObservationTime_ - Unix timestamp of last observation being provided (in seconds).\n    /// @dev    This function must be called after the Price module is deployed to activate it and after updating the observationFrequency\n    ///         or movingAverageDuration (in certain cases) in order for the Price module to function properly.\n    function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)\n        external\n        permissioned\n    {\n        if (initialized) revert Price_AlreadyInitialized();\n\n        // Cache numObservations to save gas.\n        uint256 numObs = observations.length;\n\n        // Check that the number of start observations matches the number expected\n        if (startObservations_.length != numObs || lastObservationTime_ > uint48(block.timestamp))\n            revert Price_InvalidParams();\n\n        // Push start observations into storage and total up observations\n        uint256 total;\n        for (uint256 i; i < numObs; ) {\n            if (startObservations_[i] == 0) revert Price_InvalidParams();\n            total += startObservations_[i];\n            observations[i] = startObservations_[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Set moving average, last observation time, and initialized flag\n        _movingAverage = total / numObs;\n        lastObservationTime = lastObservationTime_;\n        initialized = true;\n    }\n\n    /// @notice Change the moving average window (duration)\n    /// @param  movingAverageDuration_ - Moving average duration in seconds, must be a multiple of observation frequency\n    /// @dev    Changing the moving average duration will erase the current observations array\n    ///         and require the initialize function to be called again. Ensure that you have saved\n    ///         the existing data and can re-populate before calling this function.\n    function changeMovingAverageDuration(uint48 movingAverageDuration_) external permissioned {\n        // Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0)\n            revert Price_InvalidParams();\n\n        // Calculate the new number of observations\n        uint256 newObservations = uint256(movingAverageDuration_ / observationFrequency);\n\n        // Store blank observations array of new size\n        observations = new uint256[](newObservations);\n\n        // Set initialized to false and update state variables\n        initialized = false;\n        lastObservationTime = 0;\n        _movingAverage = 0;\n        nextObsIndex = 0;\n        movingAverageDuration = movingAverageDuration_;\n        numObservations = uint32(newObservations);\n\n        emit MovingAverageDurationChanged(movingAverageDuration_);\n    }\n\n    /// @notice   Change the observation frequency of the moving average (i.e. how often a new observation is taken)\n    /// @param    observationFrequency_ - Observation frequency in seconds, must be a divisor of the moving average duration\n    /// @dev      Changing the observation frequency clears existing observation data since it will not be taken at the right time intervals.\n    ///           Ensure that you have saved the existing data and/or can re-populate before calling this function.\n    function changeObservationFrequency(uint48 observationFrequency_) external permissioned {\n        // Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0)\n            revert Price_InvalidParams();\n\n        // Calculate the new number of observations\n        uint256 newObservations = uint256(movingAverageDuration / observationFrequency_);\n\n        // Since the old observations will not be taken at the right intervals,\n        // the observations array will need to be reinitialized.\n        // Although, there are a handful of situations that could be handled\n        // (e.g. clean multiples of the old frequency),\n        // it is easier to do so off-chain and reinitialize the array.\n\n        // Store blank observations array of new size\n        observations = new uint256[](newObservations);\n\n        // Set initialized to false and update state variables\n        initialized = false;\n        lastObservationTime = 0;\n        _movingAverage = 0;\n        nextObsIndex = 0;\n        observationFrequency = observationFrequency_;\n        numObservations = uint32(newObservations);\n\n        emit ObservationFrequencyChanged(observationFrequency_);\n    }\n}"
    }
  ]
}