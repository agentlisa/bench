{
  "Title": "[M-15] Locked splits can be updated",
  "Content": "# Lines of code\n\nhttps://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSplitsStore.sol#L213-L220\n\n\n# Vulnerability details\n\n## Impact\n\nThe check if the newly provided project splits contain the currently locked splits does not check the `JBSplit` struct properties `preferClaimed` and `preferAddToBalance`.\n\nAccording to the docs in `JBSplit.sol`, _\"...if the split should be unchangeable until the specified time, with the exception of extending the locked period.\"_, locked sets are unchangeable.\n\nHowever, locked sets with either `preferClaimed` or `preferAddToBalance` set to true can have their bool values overwritten by supplying the same split just with different bool values.\n\n## Proof of Concept\n\n[JBSplitsStore.sol#L213-L220](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSplitsStore.sol#L213-L220)\n\n```solidity\n// Check for sameness.\nif (\n    _splits[_j].percent == _currentSplits[_i].percent &&\n    _splits[_j].beneficiary == _currentSplits[_i].beneficiary &&\n    _splits[_j].allocator == _currentSplits[_i].allocator &&\n    _splits[_j].projectId == _currentSplits[_i].projectId &&\n    // Allow lock extention.\n    _splits[_j].lockedUntil >= _currentSplits[_i].lockedUntil\n) _includesLocked = true;\n```\n\nThe check for sameness does not check the equality of the struct properties `preferClaimed` and `preferAddToBalance`.\n\n## Tools Used\n\nManual review\n\n## Recommended mitigation steps\n\nAdd two additional sameness checks for `preferClaimed` and `preferAddToBalance`:\n\n```solidity\n// Check for sameness.\nif (\n    _splits[_j].percent == _currentSplits[_i].percent &&\n    _splits[_j].beneficiary == _currentSplits[_i].beneficiary &&\n    _splits[_j].allocator == _currentSplits[_i].allocator &&\n    _splits[_j].projectId == _currentSplits[_i].projectId &&\n    _splits[_j].preferClaimed == _currentSplits[_i].preferClaimed && // @audit-info add check for sameness for property `preferClaimed`\n    _splits[_j].preferAddToBalance == _currentSplits[_i].preferAddToBalance && // @audit-info add check for sameness for property `preferAddToBalance`\n    // Allow lock extention.\n    _splits[_j].lockedUntil >= _currentSplits[_i].lockedUntil\n) _includesLocked = true;\n```\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-juicebox-v2-contest",
  "Code": [
    {
      "filename": "contracts/JBSplitsStore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport './abstract/JBOperatable.sol';\nimport './interfaces/IJBDirectory.sol';\nimport './interfaces/IJBSplitsStore.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBOperations.sol';\n\n/**\n  @notice\n  Stores splits for each project.\n\n  @dev\n  Adheres to -\n  IJBSplitsStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n*/\ncontract JBSplitsStore is IJBSplitsStore, JBOperatable {\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n  error INVALID_LOCKED_UNTIL();\n  error INVALID_PROJECT_ID();\n  error INVALID_SPLIT_PERCENT();\n  error INVALID_TOTAL_PERCENT();\n  error PREVIOUS_LOCKED_SPLITS_NOT_INCLUDED();\n\n  //*********************************************************************//\n  // --------------------- private stored properties ------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    The number of splits currently set for each project ID's configurations.\n\n    _projectId The ID of the project to get the split count for.\n    _domain An identifier within which the returned splits should be considered active.\n    _group The identifying group of the splits.\n  */\n  mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) private _splitCountOf;\n\n  /** \n    @notice\n    Packed data of splits for each project ID's configurations.\n\n    _projectId The ID of the project to get packed splits data for.\n    _domain An identifier within which the returned splits should be considered active.\n    _group The identifying group of the splits.\n    _index The indexed order that the split was set at.\n  */\n  mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))))\n    private _packedSplitParts1Of;\n\n  /** \n    @notice\n    More packed data of splits for each project ID's configurations.\n\n    @dev\n    This packed data is often 0.\n\n    _projectId The ID of the project to get packed splits data for.\n    _domain An identifier within which the returned splits should be considered active.\n    _group The identifying group of the splits.\n    _index The indexed order that the split was set at.\n  */\n  mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))))\n    private _packedSplitParts2Of;\n\n  //*********************************************************************//\n  // ---------------- public immutable stored properties --------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    Mints ERC-721's that represent project ownership and transfers.\n  */\n  IJBProjects public immutable override projects;\n\n  /** \n    @notice \n    The directory of terminals and controllers for projects.\n  */\n  IJBDirectory public immutable override directory;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n  @notice \n  Get all splits for the specified project ID, within the specified domain, for the specified group.\n\n  @param _projectId The ID of the project to get splits for.\n  @param _domain An identifier within which the returned splits should be considered active.\n  @param _group The identifying group of the splits.\n\n  @return An array of all splits for the project.\n*/\n  function splitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group\n  ) external view override returns (JBSplit[] memory) {\n    return _getStructsFor(_projectId, _domain, _group);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /** \n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n  */\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    Sets a project's splits.\n\n    @dev\n    Only the owner or operator of a project, or the current controller contract of the project, can set its splits.\n\n    @dev\n    The new splits must include any currently set splits that are locked.\n\n    @param _projectId The ID of the project for which splits are being added.\n    @param _domain An identifier within which the splits should be considered active.\n    @param _groupedSplits An array of splits to set for any number of groups. \n  */\n  function set(\n    uint256 _projectId,\n    uint256 _domain,\n    JBGroupedSplits[] calldata _groupedSplits\n  )\n    external\n    override\n    requirePermissionAllowingOverride(\n      projects.ownerOf(_projectId),\n      _projectId,\n      JBOperations.SET_SPLITS,\n      address(directory.controllerOf(_projectId)) == msg.sender\n    )\n  {\n    // Push array length in stack\n    uint256 _groupedSplitsLength = _groupedSplits.length;\n\n    // Set each grouped splits.\n    for (uint256 _i = 0; _i < _groupedSplitsLength; ) {\n      // Get a reference to the grouped split being iterated on.\n      JBGroupedSplits memory _groupedSplit = _groupedSplits[_i];\n\n      // Set the splits for the group.\n      _set(_projectId, _domain, _groupedSplit.group, _groupedSplit.splits);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  //*********************************************************************//\n  // --------------------- private helper functions -------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    Sets a project's splits.\n\n    @dev\n    The new splits must include any currently set splits that are locked.\n\n    @param _projectId The ID of the project for which splits are being added.\n    @param _domain An identifier within which the splits should be considered active.\n    @param _group An identifier between of splits being set. All splits within this _group must add up to within 100%.\n    @param _splits The splits to set.\n  */\n  function _set(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    JBSplit[] memory _splits\n  ) internal {\n    // Get a reference to the project's current splits.\n    JBSplit[] memory _currentSplits = _getStructsFor(_projectId, _domain, _group);\n\n    // Check to see if all locked splits are included.\n    for (uint256 _i = 0; _i < _currentSplits.length; _i++) {\n      // If not locked, continue.\n      if (block.timestamp >= _currentSplits[_i].lockedUntil) continue;\n\n      // Keep a reference to whether or not the locked split being iterated on is included.\n      bool _includesLocked = false;\n\n      for (uint256 _j = 0; _j < _splits.length; _j++) {\n        // Check for sameness.\n        if (\n          _splits[_j].percent == _currentSplits[_i].percent &&\n          _splits[_j].beneficiary == _currentSplits[_i].beneficiary &&\n          _splits[_j].allocator == _currentSplits[_i].allocator &&\n          _splits[_j].projectId == _currentSplits[_i].projectId &&\n          // Allow lock extention.\n          _splits[_j].lockedUntil >= _currentSplits[_i].lockedUntil\n        ) _includesLocked = true;\n      }\n\n      if (!_includesLocked) revert PREVIOUS_LOCKED_SPLITS_NOT_INCLUDED();\n    }\n\n    // Add up all the percents to make sure they cumulative are under 100%.\n    uint256 _percentTotal = 0;\n\n    for (uint256 _i = 0; _i < _splits.length; _i++) {\n      // The percent should be greater than 0.\n      if (_splits[_i].percent == 0) revert INVALID_SPLIT_PERCENT();\n\n      // ProjectId should be within a uint56\n      if (_splits[_i].projectId > type(uint56).max) revert INVALID_PROJECT_ID();\n\n      // Add to the total percents.\n      _percentTotal = _percentTotal + _splits[_i].percent;\n\n      // Validate the total does not exceed the expected value.\n      if (_percentTotal > JBConstants.SPLITS_TOTAL_PERCENT) revert INVALID_TOTAL_PERCENT();\n\n      uint256 _packedSplitParts1;\n\n      // prefer claimed in bit 0.\n      if (_splits[_i].preferClaimed) _packedSplitParts1 = 1;\n      // prefer add to balance in bit 1.\n      if (_splits[_i].preferAddToBalance) _packedSplitParts1 |= 1 << 1;\n      // percent in bits 2-33.\n      _packedSplitParts1 |= _splits[_i].percent << 2;\n      // projectId in bits 32-89.\n      _packedSplitParts1 |= _splits[_i].projectId << 34;\n      // beneficiary in bits 90-249.\n      _packedSplitParts1 |= uint256(uint160(address(_splits[_i].beneficiary))) << 90;\n\n      // Store the first spit part.\n      _packedSplitParts1Of[_projectId][_domain][_group][_i] = _packedSplitParts1;\n\n      // If there's data to store in the second packed split part, pack and store.\n      if (_splits[_i].lockedUntil > 0 || _splits[_i].allocator != IJBSplitAllocator(address(0))) {\n        // Locked until should be within a uint48\n        if (_splits[_i].lockedUntil > type(uint48).max) revert INVALID_LOCKED_UNTIL();\n\n        // lockedUntil in bits 0-47.\n        uint256 _packedSplitParts2 = uint48(_splits[_i].lockedUntil);\n        // allocator in bits 48-207.\n        _packedSplitParts2 |= uint256(uint160(address(_splits[_i].allocator))) << 48;\n\n        // Store the second split part.\n        _packedSplitParts2Of[_projectId][_domain][_group][_i] = _packedSplitParts2;\n\n        // Otherwise if there's a value stored in the indexed position, delete it.\n      } else if (_packedSplitParts2Of[_projectId][_domain][_group][_i] > 0)\n        delete _packedSplitParts2Of[_projectId][_domain][_group][_i];\n\n      emit SetSplit(_projectId, _domain, _group, _splits[_i], msg.sender);\n    }\n\n    // Set the new length of the splits.\n    _splitCountOf[_projectId][_domain][_group] = _splits.length;\n  }\n\n  /**\n    @notice \n    Unpack splits' packed stored values into easy-to-work-with spit structs.\n\n    @param _projectId The ID of the project to which the split belongs.\n    @param _domain The identifier within which the returned splits should be considered active.\n    @param _group The identifying group of the splits.\n\n    @return splits The split structs.\n  */\n  function _getStructsFor(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group\n  ) private view returns (JBSplit[] memory) {\n    // Get a reference to the number of splits that need to be added to the returned array.\n    uint256 _splitCount = _splitCountOf[_projectId][_domain][_group];\n\n    // Initialize an array to be returned that has the set length.\n    JBSplit[] memory _splits = new JBSplit[](_splitCount);\n\n    // Loop through each split and unpack the values into structs.\n    for (uint256 _i = 0; _i < _splitCount; _i++) {\n      // Get a reference to the fist packed data.\n      uint256 _packedSplitPart1 = _packedSplitParts1Of[_projectId][_domain][_group][_i];\n\n      // Populate the split struct.\n      JBSplit memory _split;\n\n      // prefer claimed in bit 0.\n      _split.preferClaimed = _packedSplitPart1 & 1 == 1;\n      // prefer add to balance in bit 1.\n      _split.preferAddToBalance = (_packedSplitPart1 >> 1) & 1 == 1;\n      // percent in bits 2-33.\n      _split.percent = uint256(uint32(_packedSplitPart1 >> 2));\n      // projectId in bits 32-89.\n      _split.projectId = uint256(uint56(_packedSplitPart1 >> 34));\n      // beneficiary in bits 90-249.\n      _split.beneficiary = payable(address(uint160(_packedSplitPart1 >> 90)));\n\n      // Get a reference to the second packed data.\n      uint256 _packedSplitPart2 = _packedSplitParts2Of[_projectId][_domain][_group][_i];\n\n      // If there's anything in it, unpack.\n      if (_packedSplitPart2 > 0) {\n        // lockedUntil in bits 0-47.\n        _split.lockedUntil = uint256(uint48(_packedSplitPart2));\n        // allocator in bits 48-207.\n        _split.allocator = IJBSplitAllocator(address(uint160(_packedSplitPart2 >> 48)));\n      }\n\n      // Add the split to the value being returned.\n      _splits[_i] = _split;\n    }\n\n    return _splits;\n  }\n}"
    }
  ]
}