{
  "Title": "[M-01] The logic in `_handleVoteOverride` to determine if an account is the transcoder is not consistent with the logic in the `BondManager.sol`",
  "Content": "\nIn the current implementation, when voting, the function [\\_countVote is triggered](https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L151), this function is overridden in the function GovernorCountingOverridable.sol\n\n```solidity\n    _weight = _handleVoteOverrides(_proposalId, tally, voter, _account, _weight);\n```\n\nThis is calling:\n\n```solidity\n   function _handleVoteOverrides(\n        uint256 _proposalId,\n        ProposalTally storage _tally,\n        ProposalVoterState storage _voter,\n        address _account,\n        uint256 _weight\n    ) internal returns (uint256) {\n\n        uint256 timepoint = proposalSnapshot(_proposalId);\n\n        address delegate = votes().delegatedAt(_account, timepoint);\n\n        // @audit\n        // is transcoder?\n        bool isTranscoder = _account == delegate;\n    \n        if (isTranscoder) {\n            // deduce weight from any previous delegators for this transcoder to\n            // make a vote\n            return _weight - _voter.deductions;\n        }\n```\n\nThe logic to determine if an account is the transcoder is too simple in this [line of code](https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L184):\n\n```solidity\n// @audit\n// is transcoder?\nbool isTranscoder = _account == delegate;\n```\n\nAnd does not match the logic that determine if the address is an registered transcorder and an active transcoder in the bondManager.sol.\n\nIn BondManager.sol, the function that used to check if a transcoder is registered is in this [line of code](https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1156):\n\n```solidity\n    /**\n     * @notice Return whether a transcoder is registered\n     * @param _transcoder Transcoder address\n     * @return true if transcoder is self-bonded\n     */\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\n        Delegator storage d = delegators[_transcoder];\n        return d.delegateAddress == _transcoder && d.bondedAmount > 0;\n    }\n```\n\nThe function that is used to check if a transcoder is active is in [this line of code](https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1145).\n\n```solidity\n    function isActiveTranscoder(address _transcoder) public view returns (bool) {\n        Transcoder storage t = transcoders[_transcoder];\n        uint256 currentRound = roundsManager().currentRound();\n        return t.activationRound <= currentRound && currentRound < t.deactivationRound;\n    }\n```\n\nMissing the check in the delegator's bond amount (delegators\\[\\_transcoder].bondeAmount > 0).\n\nThe code incorrectedly counts regular delegator as transcoder and does not update the deduction power correctly.\n\n### Recommended Mitigation Steps\n\nReuse the function isRegisteredTranscoder and isActiveTranscoder to determine if an account is a registered and active transcoder when counting the voting power.\n\n### Assessed type\n\nGovernance\n\n**[victorges (Livepeer) confirmed and commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/206#issuecomment-1721637789):**\n > There is in fact an issue with the inconsistency with the `isRegisteredTranscodeer` function. This report didn't manage to go specifically into that issue, but still pointed a valid problem which is in a sense the root cause there. FTR There is no problem with `isActiveTranscoder` though, since we don't give voting power only to active transcoders. That part of this report is invalid.\n\n**[victorges (Livepeer) mitigated](https://github.com/code-423n4/2023-08-livepeer-findings/issues/206):**\n > https://github.com/livepeer/protocol/pull/626\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-livepeer",
  "Code": [
    {
      "filename": "contracts/treasury/GovernorCountingOverridable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC5805Upgradeable.sol\";\n\nimport \"../bonding/libraries/EarningsPool.sol\";\nimport \"../bonding/libraries/EarningsPoolLIP36.sol\";\n\nimport \"../Manager.sol\";\nimport \"../IController.sol\";\nimport \"../rounds/IRoundsManager.sol\";\nimport \"./IVotes.sol\";\n\n/**\n * @title GovernorCountingOverridable\n * @notice Implements the Counting module from OpenZeppelin Governor with support for delegators overriding their\n * delegated transcoder's vote. This module is used through inheritance by the Governor contract.\n */\nabstract contract GovernorCountingOverridable is Initializable, GovernorUpgradeable {\n    error InvalidVoteType(uint8 voteType);\n    error VoteAlreadyCast();\n\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    /**\n     * @dev Tracks state of specicic voters in a single proposal.\n     */\n    struct ProposalVoterState {\n        bool hasVoted;\n        VoteType support;\n        // This vote deductions state is only necessary to support the case where a delegator might vote before their\n        // transcoder. When that happens, we need to deduct the delegator(s) votes before tallying the transcoder vote.\n        uint256 deductions;\n    }\n\n    /**\n     * @dev Tracks the tallying state for a proposal vote counting logic.\n     */\n    struct ProposalTally {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => ProposalVoterState) voters;\n    }\n\n    // Maps proposal IDs to their corresponding vote tallies.\n    mapping(uint256 => ProposalTally) private _proposalTallies;\n\n    /**\n     * @notice The required percentage of \"for\" votes in relation to the total opinionated votes (for and abstain) for\n     * a proposal to succeed. Represented as a MathUtils percentage value (e.g. 6 decimal places).\n     */\n    uint256 public quota;\n\n    function __GovernorCountingOverridable_init(uint256 _quota) internal onlyInitializing {\n        __GovernorCountingOverridable_init_unchained(_quota);\n    }\n\n    function __GovernorCountingOverridable_init_unchained(uint256 _quota) internal onlyInitializing {\n        quota = _quota;\n    }\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain,against\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 _proposalId, address _account) public view virtual override returns (bool) {\n        return _proposalTallies[_proposalId].voters[_account].hasVoted;\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(uint256 _proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalTally storage tally = _proposalTallies[_proposalId];\n        return (tally.againstVotes, tally.forVotes, tally.abstainVotes);\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(uint256 _proposalId) internal view virtual override returns (bool) {\n        (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) = proposalVotes(_proposalId);\n\n        uint256 totalVotes = againstVotes + forVotes + abstainVotes;\n\n        return totalVotes >= quorum(proposalSnapshot(_proposalId));\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be at least QUOTA of the total votes.\n     */\n    function _voteSucceeded(uint256 _proposalId) internal view virtual override returns (bool) {\n        (uint256 againstVotes, uint256 forVotes, ) = proposalVotes(_proposalId);\n\n        // we ignore abstain votes for vote succeeded calculation\n        uint256 opinionatedVotes = againstVotes + forVotes;\n\n        return forVotes >= MathUtils.percOf(opinionatedVotes, quota);\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 _proposalId,\n        address _account,\n        uint8 _supportInt,\n        uint256 _weight,\n        bytes memory // params\n    ) internal virtual override {\n        if (_supportInt > uint8(VoteType.Abstain)) {\n            revert InvalidVoteType(_supportInt);\n        }\n        VoteType support = VoteType(_supportInt);\n\n        ProposalTally storage tally = _proposalTallies[_proposalId];\n        ProposalVoterState storage voter = tally.voters[_account];\n\n        if (voter.hasVoted) {\n            revert VoteAlreadyCast();\n        }\n        voter.hasVoted = true;\n        voter.support = support;\n\n        _weight = _handleVoteOverrides(_proposalId, tally, voter, _account, _weight);\n\n        if (support == VoteType.Against) {\n            tally.againstVotes += _weight;\n        } else if (support == VoteType.For) {\n            tally.forVotes += _weight;\n        } else {\n            tally.abstainVotes += _weight;\n        }\n    }\n\n    /**\n     * @notice Handles vote overrides that delegators can make to their\n     * corresponding delegated transcoder votes. Usually only the transcoders\n     * vote on proposals, but any delegator can change their part of the vote.\n     * This tracks past votes and deduction on separate mappings in order to\n     * calculate the effective voting power of each vote.\n     * @param _proposalId ID of the proposal being voted on\n     * @param _tally struct where the vote totals are tallied on\n     * @param _voter struct where the specific voter state is tracked\n     * @param _account current user making a vote\n     * @param _weight voting weight of the user making the vote\n     */\n    function _handleVoteOverrides(\n        uint256 _proposalId,\n        ProposalTally storage _tally,\n        ProposalVoterState storage _voter,\n        address _account,\n        uint256 _weight\n    ) internal returns (uint256) {\n        uint256 timepoint = proposalSnapshot(_proposalId);\n        address delegate = votes().delegatedAt(_account, timepoint);\n\n        bool isTranscoder = _account == delegate;\n        if (isTranscoder) {\n            // deduce weight from any previous delegators for this transcoder to\n            // make a vote\n            return _weight - _voter.deductions;\n        }\n\n        // this is a delegator, so add a deduction to the delegated transcoder\n        ProposalVoterState storage delegateVoter = _tally.voters[delegate];\n        delegateVoter.deductions += _weight;\n\n        if (delegateVoter.hasVoted) {\n            // this is a delegator overriding its delegated transcoder vote,\n            // we need to update the current totals to move the weight of\n            // the delegator vote to the right outcome.\n            VoteType delegateSupport = delegateVoter.support;\n\n            if (delegateSupport == VoteType.Against) {\n                _tally.againstVotes -= _weight;\n            } else if (delegateSupport == VoteType.For) {\n                _tally.forVotes -= _weight;\n            } else {\n                assert(delegateSupport == VoteType.Abstain);\n                _tally.abstainVotes -= _weight;\n            }\n        }\n\n        return _weight;\n    }\n\n    /**\n     * @dev Implement in inheriting contract to provide the voting power provider.\n     */\n    function votes() public view virtual returns (IVotes);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "contracts/treasury/GovernorCountingOverridable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC5805Upgradeable.sol\";\n\nimport \"../bonding/libraries/EarningsPool.sol\";\nimport \"../bonding/libraries/EarningsPoolLIP36.sol\";\n\nimport \"../Manager.sol\";\nimport \"../IController.sol\";\nimport \"../rounds/IRoundsManager.sol\";\nimport \"./IVotes.sol\";\n\n/**\n * @title GovernorCountingOverridable\n * @notice Implements the Counting module from OpenZeppelin Governor with support for delegators overriding their\n * delegated transcoder's vote. This module is used through inheritance by the Governor contract.\n */\nabstract contract GovernorCountingOverridable is Initializable, GovernorUpgradeable {\n    error InvalidVoteType(uint8 voteType);\n    error VoteAlreadyCast();\n\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    /**\n     * @dev Tracks state of specicic voters in a single proposal.\n     */\n    struct ProposalVoterState {\n        bool hasVoted;\n        VoteType support;\n        // This vote deductions state is only necessary to support the case where a delegator might vote before their\n        // transcoder. When that happens, we need to deduct the delegator(s) votes before tallying the transcoder vote.\n        uint256 deductions;\n    }\n\n    /**\n     * @dev Tracks the tallying state for a proposal vote counting logic.\n     */\n    struct ProposalTally {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => ProposalVoterState) voters;\n    }\n\n    // Maps proposal IDs to their corresponding vote tallies.\n    mapping(uint256 => ProposalTally) private _proposalTallies;\n\n    /**\n     * @notice The required percentage of \"for\" votes in relation to the total opinionated votes (for and abstain) for\n     * a proposal to succeed. Represented as a MathUtils percentage value (e.g. 6 decimal places).\n     */\n    uint256 public quota;\n\n    function __GovernorCountingOverridable_init(uint256 _quota) internal onlyInitializing {\n        __GovernorCountingOverridable_init_unchained(_quota);\n    }\n\n    function __GovernorCountingOverridable_init_unchained(uint256 _quota) internal onlyInitializing {\n        quota = _quota;\n    }\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain,against\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 _proposalId, address _account) public view virtual override returns (bool) {\n        return _proposalTallies[_proposalId].voters[_account].hasVoted;\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(uint256 _proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalTally storage tally = _proposalTallies[_proposalId];\n        return (tally.againstVotes, tally.forVotes, tally.abstainVotes);\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(uint256 _proposalId) internal view virtual override returns (bool) {\n        (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) = proposalVotes(_proposalId);\n\n        uint256 totalVotes = againstVotes + forVotes + abstainVotes;\n\n        return totalVotes >= quorum(proposalSnapshot(_proposalId));\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be at least QUOTA of the total votes.\n     */\n    function _voteSucceeded(uint256 _proposalId) internal view virtual override returns (bool) {\n        (uint256 againstVotes, uint256 forVotes, ) = proposalVotes(_proposalId);\n\n        // we ignore abstain votes for vote succeeded calculation\n        uint256 opinionatedVotes = againstVotes + forVotes;\n\n        return forVotes >= MathUtils.percOf(opinionatedVotes, quota);\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 _proposalId,\n        address _account,\n        uint8 _supportInt,\n        uint256 _weight,\n        bytes memory // params\n    ) internal virtual override {\n        if (_supportInt > uint8(VoteType.Abstain)) {\n            revert InvalidVoteType(_supportInt);\n        }\n        VoteType support = VoteType(_supportInt);\n\n        ProposalTally storage tally = _proposalTallies[_proposalId];\n        ProposalVoterState storage voter = tally.voters[_account];\n\n        if (voter.hasVoted) {\n            revert VoteAlreadyCast();\n        }\n        voter.hasVoted = true;\n        voter.support = support;\n\n        _weight = _handleVoteOverrides(_proposalId, tally, voter, _account, _weight);\n\n        if (support == VoteType.Against) {\n            tally.againstVotes += _weight;\n        } else if (support == VoteType.For) {\n            tally.forVotes += _weight;\n        } else {\n            tally.abstainVotes += _weight;\n        }\n    }\n\n    /**\n     * @notice Handles vote overrides that delegators can make to their\n     * corresponding delegated transcoder votes. Usually only the transcoders\n     * vote on proposals, but any delegator can change their part of the vote.\n     * This tracks past votes and deduction on separate mappings in order to\n     * calculate the effective voting power of each vote.\n     * @param _proposalId ID of the proposal being voted on\n     * @param _tally struct where the vote totals are tallied on\n     * @param _voter struct where the specific voter state is tracked\n     * @param _account current user making a vote\n     * @param _weight voting weight of the user making the vote\n     */\n    function _handleVoteOverrides(\n        uint256 _proposalId,\n        ProposalTally storage _tally,\n        ProposalVoterState storage _voter,\n        address _account,\n        uint256 _weight\n    ) internal returns (uint256) {\n        uint256 timepoint = proposalSnapshot(_proposalId);\n        address delegate = votes().delegatedAt(_account, timepoint);\n\n        bool isTranscoder = _account == delegate;\n        if (isTranscoder) {\n            // deduce weight from any previous delegators for this transcoder to\n            // make a vote\n            return _weight - _voter.deductions;\n        }\n\n        // this is a delegator, so add a deduction to the delegated transcoder\n        ProposalVoterState storage delegateVoter = _tally.voters[delegate];\n        delegateVoter.deductions += _weight;\n\n        if (delegateVoter.hasVoted) {\n            // this is a delegator overriding its delegated transcoder vote,\n            // we need to update the current totals to move the weight of\n            // the delegator vote to the right outcome.\n            VoteType delegateSupport = delegateVoter.support;\n\n            if (delegateSupport == VoteType.Against) {\n                _tally.againstVotes -= _weight;\n            } else if (delegateSupport == VoteType.For) {\n                _tally.forVotes -= _weight;\n            } else {\n                assert(delegateSupport == VoteType.Abstain);\n                _tally.abstainVotes -= _weight;\n            }\n        }\n\n        return _weight;\n    }\n\n    /**\n     * @dev Implement in inheriting contract to provide the voting power provider.\n     */\n    function votes() public view virtual returns (IVotes);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "contracts/bonding/BondingManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../ManagerProxyTarget.sol\";\nimport \"./IBondingManager.sol\";\nimport \"../libraries/SortedDoublyLL.sol\";\nimport \"../libraries/MathUtils.sol\";\nimport \"../libraries/PreciseMathUtils.sol\";\nimport \"./libraries/EarningsPool.sol\";\nimport \"./libraries/EarningsPoolLIP36.sol\";\nimport \"../token/ILivepeerToken.sol\";\nimport \"../token/IMinter.sol\";\nimport \"../rounds/IRoundsManager.sol\";\nimport \"../snapshots/IMerkleSnapshot.sol\";\nimport \"./IBondingVotes.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title BondingManager\n * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol\n */\ncontract BondingManager is ManagerProxyTarget, IBondingManager {\n    using SafeMath for uint256;\n    using SortedDoublyLL for SortedDoublyLL.Data;\n    using EarningsPool for EarningsPool.Data;\n    using EarningsPoolLIP36 for EarningsPool.Data;\n\n    // Constants\n    // Occurances are replaced at compile time\n    // and computed to a single value if possible by the optimizer\n    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;\n\n    // Time between unbonding and possible withdrawl in rounds\n    uint64 public unbondingPeriod;\n\n    // Represents a transcoder's current state\n    struct Transcoder {\n        uint256 lastRewardRound; // Last round that the transcoder called reward\n        uint256 rewardCut; // % of reward paid to transcoder by a delegator\n        uint256 feeShare; // % of fees paid to delegators by transcoder\n        mapping(uint256 => EarningsPool.Data) earningsPoolPerRound; // Mapping of round => earnings pool for the round\n        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active\n        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive\n        uint256 deactivationRound; // Round in which the transcoder will become inactive\n        uint256 activeCumulativeRewards; // The transcoder's cumulative rewards that are active in the current round\n        uint256 cumulativeRewards; // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).\n        uint256 cumulativeFees; // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)\n        uint256 lastFeeRound; // Latest round in which the transcoder received fees\n    }\n\n    // The various states a transcoder can be in\n    enum TranscoderStatus {\n        NotRegistered,\n        Registered\n    }\n\n    // Represents a delegator's current state\n    struct Delegator {\n        uint256 bondedAmount; // The amount of bonded tokens\n        uint256 fees; // The amount of fees collected\n        address delegateAddress; // The address delegated to\n        uint256 delegatedAmount; // The amount of tokens delegated to the delegator\n        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone\n        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings\n        uint256 nextUnbondingLockId; // ID for the next unbonding lock created\n        mapping(uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock\n    }\n\n    // The various states a delegator can be in\n    enum DelegatorStatus {\n        Pending,\n        Bonded,\n        Unbonded\n    }\n\n    // Represents an amount of tokens that are being unbonded\n    struct UnbondingLock {\n        uint256 amount; // Amount of tokens being unbonded\n        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn\n    }\n\n    // Keep track of the known transcoders and delegators\n    mapping(address => Delegator) private delegators;\n    mapping(address => Transcoder) private transcoders;\n\n    // The total active stake (sum of the stake of active set members) for the current round\n    uint256 public currentRoundTotalActiveStake;\n    // The total active stake (sum of the stake of active set members) for the next round\n    uint256 public nextRoundTotalActiveStake;\n\n    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.\n    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders\n    // in the pool are locked into the active set for round N + 1\n    SortedDoublyLL.Data private transcoderPool;\n\n    // The % of newly minted rewards to be routed to the treasury. Represented as a PreciseMathUtils percPoint value.\n    uint256 public treasuryRewardCutRate;\n    // The value for `treasuryRewardCutRate` to be set on the next round initialization.\n    uint256 public nextRoundTreasuryRewardCutRate;\n\n    // If the balance of the treasury in LPT is above this value, automatic treasury contributions will halt.\n    uint256 public treasuryBalanceCeiling;\n\n    // Check if sender is TicketBroker\n    modifier onlyTicketBroker() {\n        _onlyTicketBroker();\n        _;\n    }\n\n    // Check if sender is RoundsManager\n    modifier onlyRoundsManager() {\n        _onlyRoundsManager();\n        _;\n    }\n\n    // Check if sender is Verifier\n    modifier onlyVerifier() {\n        _onlyVerifier();\n        _;\n    }\n\n    // Check if current round is initialized\n    modifier currentRoundInitialized() {\n        _currentRoundInitialized();\n        _;\n    }\n\n    // Automatically claim earnings from lastClaimRound through the current round\n    modifier autoClaimEarnings(address _delegator) {\n        _autoClaimEarnings(_delegator);\n        _;\n    }\n\n    modifier autoCheckpoint(address _account) {\n        _;\n        _checkpointBondingState(_account, delegators[_account], transcoders[_account]);\n    }\n\n    /**\n     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\n     * should be used to initialize state variables post-deployment:\n     * - setUnbondingPeriod()\n     * - setNumActiveTranscoders()\n     * - setMaxEarningsClaimsRounds()\n     * @param _controller Address of Controller that this contract will be registered with\n     */\n    constructor(address _controller) Manager(_controller) {}\n\n    /**\n     * @notice Set unbonding period. Only callable by Controller owner\n     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal\n     */\n    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\n        unbondingPeriod = _unbondingPeriod;\n\n        emit ParameterUpdate(\"unbondingPeriod\");\n    }\n\n    /**\n     * @notice Set treasury reward cut rate. Only callable by Controller owner. Notice that the change will only be\n     * effective on the next round.\n     * @param _cutRate Percentage of newly minted rewards to route to the treasury. Must be a valid PreciseMathUtils\n     * percentage (<100% specified with 27-digits precision).\n     */\n    function setTreasuryRewardCutRate(uint256 _cutRate) external onlyControllerOwner {\n        _setTreasuryRewardCutRate(_cutRate);\n    }\n\n    /**\n     * @notice Set treasury balance ceiling. Only callable by Controller owner\n     * @param _ceiling Balance at which treasury reward contributions should halt. Specified in LPT fractional units\n     * (18-digit precision).\n     */\n    function setTreasuryBalanceCeiling(uint256 _ceiling) external onlyControllerOwner {\n        treasuryBalanceCeiling = _ceiling;\n\n        emit ParameterUpdate(\"treasuryBalanceCeiling\");\n    }\n\n    /**\n     * @notice Set maximum number of active transcoders. Only callable by Controller owner\n     * @param _numActiveTranscoders Number of active transcoders\n     */\n    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\n        transcoderPool.setMaxSize(_numActiveTranscoders);\n\n        emit ParameterUpdate(\"numActiveTranscoders\");\n    }\n\n    /**\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     */\n    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {\n        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));\n    }\n\n    /**\n     * @notice Delegate stake towards a specific address\n     * @param _amount The amount of tokens to stake\n     * @param _to The address of the transcoder to stake towards\n     */\n    function bond(uint256 _amount, address _to) external {\n        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));\n    }\n\n    /**\n     * @notice Unbond an amount of the delegator's bonded stake\n     * @param _amount Amount of tokens to unbond\n     */\n    function unbond(uint256 _amount) external {\n        unbondWithHint(_amount, address(0), address(0));\n    }\n\n    /**\n     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     */\n    function rebond(uint256 _unbondingLockId) external {\n        rebondWithHint(_unbondingLockId, address(0), address(0));\n    }\n\n    /**\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status\n     * @param _to Address of delegate\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     */\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {\n        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));\n    }\n\n    /**\n     * @notice Checkpoints the bonding state for a given account.\n     * @dev This is to allow checkpointing an account that has an inconsistent checkpoint with its current state.\n     * @param _account The account to make the checkpoint for\n     */\n    function checkpointBondingState(address _account) external {\n        _checkpointBondingState(_account, delegators[_account], transcoders[_account]);\n    }\n\n    /**\n     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period\n     * @param _unbondingLockId ID of unbonding lock to withdraw with\n     */\n    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {\n        Delegator storage del = delegators[msg.sender];\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n        require(isValidUnbondingLock(msg.sender, _unbondingLockId), \"invalid unbonding lock ID\");\n        require(\n            lock.withdrawRound <= roundsManager().currentRound(),\n            \"withdraw round must be before or equal to the current round\"\n        );\n\n        uint256 amount = lock.amount;\n        uint256 withdrawRound = lock.withdrawRound;\n        // Delete unbonding lock\n        delete del.unbondingLocks[_unbondingLockId];\n\n        // Tell Minter to transfer stake (LPT) to the delegator\n        minter().trustedTransferTokens(msg.sender, amount);\n\n        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);\n    }\n\n    /**\n     * @notice Withdraws fees to the caller\n     */\n    function withdrawFees(address payable _recipient, uint256 _amount)\n        external\n        whenSystemNotPaused\n        currentRoundInitialized\n        autoClaimEarnings(msg.sender)\n    {\n        require(_recipient != address(0), \"invalid recipient\");\n        uint256 fees = delegators[msg.sender].fees;\n        require(fees >= _amount, \"insufficient fees to withdraw\");\n        delegators[msg.sender].fees = fees.sub(_amount);\n\n        // Tell Minter to transfer fees (ETH) to the address\n        minter().trustedWithdrawETH(_recipient, _amount);\n\n        emit WithdrawFees(msg.sender, _recipient, _amount);\n    }\n\n    /**\n     * @notice Mint token rewards for an active transcoder and its delegators\n     */\n    function reward() external {\n        rewardWithHint(address(0), address(0));\n    }\n\n    /**\n     * @notice Update transcoder's fee pool. Only callable by the TicketBroker\n     * @param _transcoder Transcoder address\n     * @param _fees Fees to be added to the fee pool\n     */\n    function updateTranscoderWithFees(\n        address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external whenSystemNotPaused onlyTicketBroker {\n        // Silence unused param compiler warning\n        _round;\n\n        require(isRegisteredTranscoder(_transcoder), \"transcoder must be registered\");\n\n        uint256 currentRound = roundsManager().currentRound();\n\n        Transcoder storage t = transcoders[_transcoder];\n\n        uint256 lastRewardRound = t.lastRewardRound;\n        uint256 activeCumulativeRewards = t.activeCumulativeRewards;\n\n        // LIP-36: Add fees for the current round instead of '_round'\n        // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n        EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));\n\n        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'\n        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected\n        // for cumulative fee calculation this would result in division by zero.\n        if (currentRound > lastRewardRound) {\n            earningsPool.setCommission(t.rewardCut, t.feeShare);\n\n            uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\n            if (lastUpdateRound < currentRound) {\n                earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\n            }\n\n            // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not\n            // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its\n            // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become\n            // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round\n            activeCumulativeRewards = t.cumulativeRewards;\n        }\n\n        uint256 totalStake = earningsPool.totalStake;\n        if (prevEarningsPool.cumulativeRewardFactor == 0 && lastRewardRound == currentRound) {\n            // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)\n            // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)\n            // based on rewards for currentRound\n            IMinter mtr = minter();\n            uint256 rewards = PreciseMathUtils.percOf(\n                mtr.currentMintableTokens().add(mtr.currentMintedTokens()),\n                totalStake,\n                currentRoundTotalActiveStake\n            );\n\n            // Deduct what would have been the treasury rewards\n            uint256 treasuryRewards = MathUtils.percOf(rewards, treasuryRewardCutRate);\n            rewards = rewards.sub(treasuryRewards);\n\n            uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);\n            uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);\n\n            prevEarningsPool.cumulativeRewardFactor = PreciseMathUtils.percOf(\n                earningsPool.cumulativeRewardFactor,\n                totalStake,\n                delegatorsRewards.add(totalStake)\n            );\n        }\n\n        uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);\n        uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);\n        // Calculate the fees earned by the transcoder's earned rewards\n        uint256 transcoderRewardStakeFees = PreciseMathUtils.percOf(\n            delegatorsFees,\n            activeCumulativeRewards,\n            totalStake\n        );\n        // Track fees earned by the transcoder based on its earned rewards and feeShare\n        t.cumulativeFees = t.cumulati"
    }
  ]
}