{
  "Title": "[M-08] Attacker can lock every trove withdrawals",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2024-01-opus/blob/main/src/core/abbot.cairo#L210><br>\n<https://github.com/code-423n4/2024-01-opus/blob/main/src/core/sentinel.cairo#L159><br>\n<https://github.com/code-423n4/2024-01-opus/blob/main/src/core/sentinel.cairo#L288>\n\n### Description\n\nDuring `withdraw`, the `convert_to_yang` function of sentinel is called. This function converts an asset amount to a Yang amount.\n\n`convert_to_yang` then calls `assert_can_enter` to ensure that `current_total + enter_amt <= max_amt`. This check is incorrect in the case of a withdrawal, as a subtraction should be made instead of an addition.\n\nAn attacker can deposit an asset amount such that `current_total == max_amt`. In such condition, withdrawing assets will be impossible because of the incorrect check.\n\n### Impact\n\nIn every Gate for which a maximum amount of asset is set in Sentinel,\nan attacker can lock asset withdrawals for every users.\n\n### Proof of Concept\n\nThe following test can be added to `src/tests/abbot/test_abbot.cairo` to show:\n\n```rust\n    #[test]\n    #[should_panic(expected: ('SE: Exceeds max amount allowed',))]\n    fn test_zigtur_exploit_withdraw_exceeds_asset_cap_fail() {\n        let (_, sentinel, abbot, yangs, gates, trove_owner, trove_id, _, _) = abbot_utils::deploy_abbot_and_open_trove(\n            Option::None, Option::None, Option::None, Option::None, Option::None\n        );\n\n        let asset_addr: ContractAddress = *yangs.at(0);\n        let gate_addr: ContractAddress = *gates.at(0).contract_address;\n        let gate_bal = IERC20Dispatcher { contract_address: asset_addr }.balance_of(gate_addr);\n\n        // Set the maximum to current value, which means `current_total == max_amt`\n        start_prank(CheatTarget::One(sentinel.contract_address), sentinel_utils::admin());\n        let new_asset_max: u128 = gate_bal.try_into().unwrap();\n        sentinel.set_yang_asset_max(asset_addr, new_asset_max);\n        stop_prank(CheatTarget::One(sentinel.contract_address));\n\n        // User withdraws, so the max should not be reached.\n        // But `assert_can_enter()` in sentinel uses addition even if withdrawing, so it reverts.\n        let amount: u128 = 1;\n        start_prank(CheatTarget::One(abbot.contract_address), trove_owner);\n        abbot.withdraw(trove_id, AssetBalance { address: asset_addr, amount });\n    }\n```\n\n*Note: The PoC doesn't show the attacker adding Yang asset to make withdrawals impossible. It only shows that the withdrawals are impossible,\nbut the attack vector is clearly identifiable.*\n\n### Tools Used\n\nUnit testing\n\n### Recommended Mitigation Steps\n\nDuring withdrawals, a `withdraw_to_yang()` function could be used instead of `convert_to_yang()`. This new function would not call `assert_can_enter`.\n\nThe following patch fixes this issue by implementing a `withdraw_to_yang` function, which calculates the amount of Yang without reverting:\n\n```diff\ndiff --git a/src/core/abbot.cairo b/src/core/abbot.cairo\nindex 1f0a589..1ededa4 100644\n--- a/src/core/abbot.cairo\n+++ b/src/core/abbot.cairo\n@@ -207,7 +207,7 @@ mod abbot {\n             let user = get_caller_address();\n             self.assert_trove_owner(user, trove_id);\n \n-            let yang_amt: Wad = self.sentinel.read().convert_to_yang(yang_asset.address, yang_asset.amount);\n+            let yang_amt: Wad = self.sentinel.read().withdraw_to_yang(yang_asset.address, yang_asset.amount);\n             self.withdraw_helper(trove_id, user, yang_asset.address, yang_amt);\n         }\n \ndiff --git a/src/core/sentinel.cairo b/src/core/sentinel.cairo\nindex b18edde..644bb85 100644\n--- a/src/core/sentinel.cairo\n+++ b/src/core/sentinel.cairo\n@@ -160,6 +160,15 @@ mod sentinel {\n             gate.convert_to_yang(asset_amt)\n         }\n \n+        fn withdraw_to_yang(self: @ContractState, yang: ContractAddress, asset_amt: u128) -> Wad {\n+            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n+            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n+            assert(self.yang_is_live.read(yang), 'SE: Gate is not live');\n+            let suspension_status: YangSuspensionStatus = self.shrine.read().get_yang_suspension_status(yang);\n+            assert(suspension_status == YangSuspensionStatus::None, 'SE: Yang suspended');\n+            gate.convert_to_yang(asset_amt)\n+        }\n+\n         // This can be used to simulate the effects of `exit`.\n         fn convert_to_assets(self: @ContractState, yang: ContractAddress, yang_amt: Wad) -> u128 {\n             let gate: IGateDispatcher = self.yang_to_gate.read(yang);\ndiff --git a/src/interfaces/ISentinel.cairo b/src/interfaces/ISentinel.cairo\nindex 4149a38..04d0d04 100644\n--- a/src/interfaces/ISentinel.cairo\n+++ b/src/interfaces/ISentinel.cairo\n@@ -33,5 +33,6 @@ trait ISentinel<TContractState> {\n     fn unsuspend_yang(ref self: TContractState, yang: ContractAddress);\n     // view\n     fn convert_to_yang(self: @TContractState, yang: ContractAddress, asset_amt: u128) -> Wad;\n+    fn withdraw_to_yang(self: @TContractState, yang: ContractAddress, asset_amt: u128) -> Wad;\n     fn convert_to_assets(self: @TContractState, yang: ContractAddress, yang_amt: Wad) -> u128;\n }\n```\n\n*Note: Unit tests are all passing with the fix. To apply the patch, import the content in a `fix.patch` file, then execute `git apply fix.patch`.*\n\n### Assessed type\n\nDoS\n\n**[0xsomeone (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-opus-findings/issues/29#issuecomment-1964704524):**\n > The warden has demonstrated how the withdrawal flow in the Abbot contract an incorrect conversion will occur that will enforce a deposit limitation assuming the withdrawn amount is newly deposited.\n> \n> This behavior will result in the withdrawal not going through and its equality case can be exploited to force all positions of the Yang to not be withdrawable until the limit is updated. I consider a medium-risk better suited for this submission as:\n> \n> - The funds will not be permanently lost and a reconfiguration can recover them.\n> - The attacker would have sacrificed their funds (as they wouldn't be able to withdraw either), and those funds would be substantial.\n> \n> It is, however, a flaw that needs to be remediated by the Opus team.\n\n**[milancermak (Opus) confirmed and commented](https://github.com/code-423n4/2024-01-opus-findings/issues/29#issuecomment-1983833239):**\n> We mitigated this issue based on this report. Thanks!\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/abbot.cairo",
      "content": "#[starknet::contract]\nmod abbot {\n    use opus::interfaces::IAbbot::IAbbot;\n    use opus::interfaces::ISentinel::{ISentinelDispatcher, ISentinelDispatcherTrait};\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::types::AssetBalance;\n    use opus::utils::reentrancy_guard::reentrancy_guard_component;\n    use starknet::{ContractAddress, get_caller_address};\n    use wadray::{BoundedWad, Wad};\n\n    // \n    // Components \n    // \n\n    component!(path: reentrancy_guard_component, storage: reentrancy_guard, event: ReentrancyGuardEvent);\n\n    impl ReentrancyGuardHelpers = reentrancy_guard_component::ReentrancyGuardHelpers<ContractState>;\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        reentrancy_guard: reentrancy_guard_component::Storage,\n        // Shrine associated with this Abbot\n        shrine: IShrineDispatcher,\n        // Sentinel associated with this Abbot\n        sentinel: ISentinelDispatcher,\n        // total number of troves in a Shrine; monotonically increasing\n        // also used to calculate the next ID (count+1) when opening a new trove\n        // in essence, it serves as an index / primary key in a SQL table\n        troves_count: u64,\n        // the total number of troves of a particular address;\n        // used to build the tuple key of `user_troves` variable\n        // (user) -> (number of troves opened)\n        user_troves_count: LegacyMap<ContractAddress, u64>,\n        // a mapping of an address and index to a trove ID\n        // belonging to this address; the index is a number from 0\n        // up to `user_troves_count` for that address\n        // (user, idx) -> (trove ID)\n        user_troves: LegacyMap<(ContractAddress, u64), u64>,\n        // a mapping of a trove ID to the contract address which\n        // was used to open the trove\n        // (trove ID) -> (owner)\n        trove_owner: LegacyMap<u64, ContractAddress>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        TroveOpened: TroveOpened,\n        TroveClosed: TroveClosed,\n        // Component events\n        ReentrancyGuardEvent: reentrancy_guard_component::Event\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TroveOpened {\n        #[key]\n        user: ContractAddress,\n        #[key]\n        trove_id: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TroveClosed {\n        #[key]\n        trove_id: u64\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(ref self: ContractState, shrine: ContractAddress, sentinel: ContractAddress) {\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n        self.sentinel.write(ISentinelDispatcher { contract_address: sentinel });\n    }\n\n    //\n    // External Abbot functions\n    //\n\n    #[abi(embed_v0)]\n    impl IAbbotImpl of IAbbot<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_trove_owner(self: @ContractState, trove_id: u64) -> Option<ContractAddress> {\n            let owner = self.trove_owner.read(trove_id);\n            if owner.is_zero() {\n                Option::None\n            } else {\n                Option::Some(owner)\n            }\n        }\n\n        fn get_user_trove_ids(self: @ContractState, user: ContractAddress) -> Span<u64> {\n            let mut trove_ids: Array<u64> = ArrayTrait::new();\n            let user_troves_count: u64 = self.user_troves_count.read(user);\n            let mut idx: u64 = 0;\n\n            loop {\n                if idx == user_troves_count {\n                    break trove_ids.span();\n                }\n                trove_ids.append(self.user_troves.read((user, idx)));\n                idx += 1;\n            }\n        }\n\n        fn get_troves_count(self: @ContractState) -> u64 {\n            self.troves_count.read()\n        }\n\n        fn get_trove_asset_balance(self: @ContractState, trove_id: u64, yang: ContractAddress) -> u128 {\n            self.sentinel.read().convert_to_assets(yang, self.shrine.read().get_deposit(yang, trove_id))\n        }\n\n        //\n        // Core functions\n        //\n\n        // create a new trove in the system with Yang deposits,\n        // optionally forging Yin in the same operation (if `forge_amount` is 0, no Yin is created)\n        fn open_trove(\n            ref self: ContractState, mut yang_assets: Span<AssetBalance>, forge_amount: Wad, max_forge_fee_pct: Wad\n        ) -> u64 {\n            assert(yang_assets.len().is_non_zero(), 'ABB: No yangs');\n\n            let troves_count: u64 = self.troves_count.read();\n            self.troves_count.write(troves_count + 1);\n\n            let user = get_caller_address();\n            let user_troves_count: u64 = self.user_troves_count.read(user);\n            self.user_troves_count.write(user, user_troves_count + 1);\n\n            let new_trove_id: u64 = troves_count + 1;\n            self.user_troves.write((user, user_troves_count), new_trove_id);\n            self.trove_owner.write(new_trove_id, user);\n\n            // deposit all requested Yangs into the system\n            loop {\n                match yang_assets.pop_front() {\n                    Option::Some(yang_asset) => { self.deposit_helper(new_trove_id, user, *yang_asset); },\n                    Option::None => { break; }\n                };\n            };\n\n            // forge Yin\n            self.shrine.read().forge(user, new_trove_id, forge_amount, max_forge_fee_pct);\n\n            self.emit(TroveOpened { user, trove_id: new_trove_id });\n\n            new_trove_id\n        }\n\n        // close a trove, repaying its debt in full and withdrawing all the Yangs\n        fn close_trove(ref self: ContractState, trove_id: u64) {\n            let user = get_caller_address();\n            self.assert_trove_owner(user, trove_id);\n\n            let shrine = self.shrine.read();\n            // melting \"max Wad\" to instruct Shrine to melt *all* of trove's debt\n            shrine.melt(user, trove_id, BoundedWad::max());\n\n            let mut yangs: Span<ContractAddress> = self.sentinel.read().get_yang_addresses();\n            // withdraw each and every Yang belonging to the trove from the system\n            loop {\n                match yangs.pop_front() {\n                    Option::Some(yang) => {\n                        let yang_amount: Wad = shrine.get_deposit(*yang, trove_id);\n                        if yang_amount.is_zero() {\n                            continue;\n                        }\n                        self.withdraw_helper(trove_id, user, *yang, yang_amount);\n                    },\n                    Option::None => { break; }\n                };\n            };\n\n            self.emit(TroveClosed { trove_id });\n        }\n\n        // add Yang (an asset) to a trove\n        fn deposit(ref self: ContractState, trove_id: u64, yang_asset: AssetBalance) {\n            // There is no need to check the yang address is non-zero because the\n            // Sentinel does not allow a zero address yang to be added.\n\n            assert(trove_id != 0, 'ABB: Trove ID cannot be 0');\n            assert(trove_id <= self.troves_count.read(), 'ABB: Non-existent trove');\n            // note that caller does not need to be the trove's owner to deposit\n\n            self.deposit_helper(trove_id, get_caller_address(), yang_asset);\n        }\n\n        // remove Yang (an asset) from a trove\n        fn withdraw(ref self: ContractState, trove_id: u64, yang_asset: AssetBalance) {\n            // There is no need to check the yang address is non-zero because the\n            // Sentinel does not allow a zero address yang to be added.\n\n            let user = get_caller_address();\n            self.assert_trove_owner(user, trove_id);\n\n            let yang_amt: Wad = self.sentinel.read().convert_to_yang(yang_asset.address, yang_asset.amount);\n            self.withdraw_helper(trove_id, user, yang_asset.address, yang_amt);\n        }\n\n        // create Yin in a trove\n        fn forge(ref self: ContractState, trove_id: u64, amount: Wad, max_forge_fee_pct: Wad) {\n            let user = get_caller_address();\n            self.assert_trove_owner(user, trove_id);\n            self.shrine.read().forge(user, trove_id, amount, max_forge_fee_pct);\n        }\n\n        // destroy Yin from a trove\n        fn melt(ref self: ContractState, trove_id: u64, amount: Wad) {\n            // note that caller does not need to be the trove's owner to melt\n            self.shrine.read().melt(get_caller_address(), trove_id, amount);\n        }\n    }\n\n    //\n    // Internal Abbot functions\n    //\n\n    #[generate_trait]\n    impl AbbotHelpers of AbbotHelpersTrait {\n        #[inline(always)]\n        fn assert_trove_owner(self: @ContractState, user: ContractAddress, trove_id: u64) {\n            assert(user == self.trove_owner.read(trove_id), 'ABB: Not trove owner')\n        }\n\n        #[inline(always)]\n        fn deposit_helper(ref self: ContractState, trove_id: u64, user: ContractAddress, yang_asset: AssetBalance) {\n            // reentrancy guard is used as a precaution\n            self.reentrancy_guard.start();\n\n            let yang_amt: Wad = self.sentinel.read().enter(yang_asset.address, user, trove_id, yang_asset.amount);\n            self.shrine.read().deposit(yang_asset.address, trove_id, yang_amt);\n\n            self.reentrancy_guard.end();\n        }\n\n        #[inline(always)]\n        fn withdraw_helper(\n            ref self: ContractState, trove_id: u64, user: ContractAddress, yang: ContractAddress, yang_amt: Wad\n        ) {\n            // reentrancy guard is used as a precaution\n            self.reentrancy_guard.start();\n\n            self.sentinel.read().exit(yang, user, trove_id, yang_amt);\n            self.shrine.read().withdraw(yang, trove_id, yang_amt);\n\n            self.reentrancy_guard.end();\n        }\n    }\n}"
    },
    {
      "filename": "src/core/sentinel.cairo",
      "content": "#[starknet::contract]\nmod sentinel {\n    use access_control::access_control_component;\n    use opus::core::roles::sentinel_roles;\n    use opus::interfaces::IERC20::{IERC20Dispatcher, IERC20DispatcherTrait};\n    use opus::interfaces::IGate::{IGateDispatcher, IGateDispatcherTrait};\n    use opus::interfaces::ISentinel::ISentinel;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::types::YangSuspensionStatus;\n    use opus::utils::math::fixed_point_to_wad;\n    use starknet::contract_address::{ContractAddress, ContractAddressZeroable};\n    use starknet::{get_block_timestamp, get_caller_address};\n    use wadray::{Ray, Wad, WadZeroable};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Helper constant to set the starting index for iterating over the\n    // yangs in the order they were added\n    const LOOP_START: u64 = 1;\n\n    const INITIAL_DEPOSIT_AMT: u128 = 1000;\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // mapping between a yang address and our deployed Gate\n        yang_to_gate: LegacyMap::<ContractAddress, IGateDispatcher>,\n        // length of the yang_addresses array\n        yang_addresses_count: u64,\n        // 0-based array of yang addresses added to the Shrine via this Sentinel\n        yang_addresses: LegacyMap::<u64, ContractAddress>,\n        // The Shrine associated with this Sentinel\n        shrine: IShrineDispatcher,\n        // mapping between a yang address and the cap on the yang's asset in the\n        // asset's decimals\n        yang_asset_max: LegacyMap::<ContractAddress, u128>,\n        // mapping between a yang address and whether its Gate is live\n        yang_is_live: LegacyMap::<ContractAddress, bool>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        YangAdded: YangAdded,\n        YangAssetMaxUpdated: YangAssetMaxUpdated,\n        GateKilled: GateKilled,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangAdded {\n        #[key]\n        yang: ContractAddress,\n        gate: ContractAddress\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangAssetMaxUpdated {\n        #[key]\n        yang: ContractAddress,\n        old_max: u128,\n        new_max: u128\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct GateKilled {\n        #[key]\n        yang: ContractAddress,\n        gate: ContractAddress\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(ref self: ContractState, admin: ContractAddress, shrine: ContractAddress) {\n        self.access_control.initializer(admin, Option::Some(sentinel_roles::default_admin_role()));\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n    }\n\n    //\n    // External Sentinel functions\n    //\n\n    #[abi(embed_v0)]\n    impl ISentinelImpl of ISentinel<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_gate_address(self: @ContractState, yang: ContractAddress) -> ContractAddress {\n            self.yang_to_gate.read(yang).contract_address\n        }\n\n        fn get_gate_live(self: @ContractState, yang: ContractAddress) -> bool {\n            self.yang_is_live.read(yang)\n        }\n\n        fn get_yang_addresses(self: @ContractState) -> Span<ContractAddress> {\n            let mut idx: u64 = LOOP_START;\n            let loop_end: u64 = self.yang_addresses_count.read() + LOOP_START;\n            let mut addresses: Array<ContractAddress> = ArrayTrait::new();\n            loop {\n                if idx == loop_end {\n                    break addresses.span();\n                }\n                addresses.append(self.yang_addresses.read(idx));\n                idx += 1;\n            }\n        }\n\n        fn get_yang_addresses_count(self: @ContractState) -> u64 {\n            self.yang_addresses_count.read()\n        }\n\n        fn get_yang(self: @ContractState, idx: u64) -> ContractAddress {\n            self.yang_addresses.read(idx)\n        }\n\n        fn get_yang_asset_max(self: @ContractState, yang: ContractAddress) -> u128 {\n            self.yang_asset_max.read(yang)\n        }\n\n        fn get_asset_amt_per_yang(self: @ContractState, yang: ContractAddress) -> Wad {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            gate.get_asset_amt_per_yang()\n        }\n\n        //\n        // View functions\n        //\n\n        // This can be used to simulate the effects of `enter`.\n        fn convert_to_yang(self: @ContractState, yang: ContractAddress, asset_amt: u128) -> Wad {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            self.assert_can_enter(yang, gate, asset_amt);\n            gate.convert_to_yang(asset_amt)\n        }\n\n        // This can be used to simulate the effects of `exit`.\n        fn convert_to_assets(self: @ContractState, yang: ContractAddress, yang_amt: Wad) -> u128 {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n            gate.convert_to_assets(yang_amt)\n        }\n\n        //\n        // Setters\n        //\n\n        fn add_yang(\n            ref self: ContractState,\n            yang: ContractAddress,\n            yang_asset_max: u128,\n            yang_threshold: Ray,\n            yang_price: Wad,\n            yang_rate: Ray,\n            gate: ContractAddress\n        ) {\n            self.access_control.assert_has_role(sentinel_roles::ADD_YANG);\n            assert(yang.is_non_zero(), 'SE: Yang cannot be zero address');\n            assert(gate.is_non_zero(), 'SE: Gate cannot be zero address');\n            assert(self.yang_to_gate.read(yang).contract_address.is_zero(), 'SE: Yang already added');\n\n            let gate = IGateDispatcher { contract_address: gate };\n            assert(gate.get_asset() == yang, 'SE: Asset of gate is not yang');\n\n            let index: u64 = self.yang_addresses_count.read() + 1;\n            self.yang_addresses_count.write(index);\n            self.yang_addresses.write(index, yang);\n            self.yang_to_gate.write(yang, gate);\n            self.yang_is_live.write(yang, true);\n            self.yang_asset_max.write(yang, yang_asset_max);\n\n            // Require an initial deposit when adding a yang to prevent first depositor from front-running\n            let yang_erc20 = IERC20Dispatcher { contract_address: yang };\n            // scale `asset_amt` up by the difference to match `Wad` precision of yang\n            let initial_yang_amt: Wad = fixed_point_to_wad(INITIAL_DEPOSIT_AMT, yang_erc20.decimals());\n            let initial_deposit_amt: u256 = INITIAL_DEPOSIT_AMT.into();\n\n            let caller: ContractAddress = get_caller_address();\n            let success: bool = yang_erc20.transfer_from(caller, gate.contract_address, initial_deposit_amt);\n            assert(success, 'SE: Yang transfer failed');\n\n            let shrine: IShrineDispatcher = self.shrine.read();\n            shrine.add_yang(yang, yang_threshold, yang_price, yang_rate, initial_yang_amt);\n\n            // Events\n            self.emit(YangAdded { yang, gate: gate.contract_address });\n            self.emit(YangAssetMaxUpdated { yang, old_max: 0, new_max: yang_asset_max });\n        }\n\n        fn set_yang_asset_max(ref self: ContractState, yang: ContractAddress, new_asset_max: u128) {\n            self.access_control.assert_has_role(sentinel_roles::SET_YANG_ASSET_MAX);\n\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n\n            let old_asset_max: u128 = self.yang_asset_max.read(yang);\n            self.yang_asset_max.write(yang, new_asset_max);\n\n            self.emit(YangAssetMaxUpdated { yang, old_max: old_asset_max, new_max: new_asset_max });\n        }\n\n        fn kill_gate(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::KILL_GATE);\n\n            self.yang_is_live.write(yang, false);\n\n            self.emit(GateKilled { yang, gate: self.yang_to_gate.read(yang).contract_address });\n        }\n\n        fn suspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::UPDATE_YANG_SUSPENSION);\n            self.shrine.read().suspend_yang(yang);\n        }\n\n        fn unsuspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::UPDATE_YANG_SUSPENSION);\n            self.shrine.read().unsuspend_yang(yang);\n        }\n\n        //\n        // Core functions\n        //\n\n        fn enter(\n            ref self: ContractState, yang: ContractAddress, user: ContractAddress, trove_id: u64, asset_amt: u128\n        ) -> Wad {\n            self.access_control.assert_has_role(sentinel_roles::ENTER);\n\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n\n            self.assert_can_enter(yang, gate, asset_amt);\n            gate.enter(user, trove_id, asset_amt)\n        }\n\n        fn exit(\n            ref self: ContractState, yang: ContractAddress, user: ContractAddress, trove_id: u64, yang_amt: Wad\n        ) -> u128 {\n            self.access_control.assert_has_role(sentinel_roles::EXIT);\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n\n            gate.exit(user, trove_id, yang_amt)\n        }\n    }\n\n    //\n    // Internal Sentinel functions\n    //\n\n    #[generate_trait]\n    impl SentinelHelpers of SentinelHelpersTrait {\n        // Helper function to check that `enter` is a valid operation at the current\n        // on-chain conditions\n        #[inline(always)]\n        fn assert_can_enter(self: @ContractState, yang: ContractAddress, gate: IGateDispatcher, enter_amt: u128) {\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n            assert(self.yang_is_live.read(yang), 'SE: Gate is not live');\n            let suspension_status: YangSuspensionStatus = self.shrine.read().get_yang_suspension_status(yang);\n            assert(suspension_status == YangSuspensionStatus::None, 'SE: Yang suspended');\n            let current_total: u128 = gate.get_total_assets();\n            let max_amt: u128 = self.yang_asset_max.read(yang);\n            assert(current_total + enter_amt <= max_amt, 'SE: Exceeds max amount allowed');\n        }\n    }\n}"
    },
    {
      "filename": "src/core/sentinel.cairo",
      "content": "#[starknet::contract]\nmod sentinel {\n    use access_control::access_control_component;\n    use opus::core::roles::sentinel_roles;\n    use opus::interfaces::IERC20::{IERC20Dispatcher, IERC20DispatcherTrait};\n    use opus::interfaces::IGate::{IGateDispatcher, IGateDispatcherTrait};\n    use opus::interfaces::ISentinel::ISentinel;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::types::YangSuspensionStatus;\n    use opus::utils::math::fixed_point_to_wad;\n    use starknet::contract_address::{ContractAddress, ContractAddressZeroable};\n    use starknet::{get_block_timestamp, get_caller_address};\n    use wadray::{Ray, Wad, WadZeroable};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Helper constant to set the starting index for iterating over the\n    // yangs in the order they were added\n    const LOOP_START: u64 = 1;\n\n    const INITIAL_DEPOSIT_AMT: u128 = 1000;\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // mapping between a yang address and our deployed Gate\n        yang_to_gate: LegacyMap::<ContractAddress, IGateDispatcher>,\n        // length of the yang_addresses array\n        yang_addresses_count: u64,\n        // 0-based array of yang addresses added to the Shrine via this Sentinel\n        yang_addresses: LegacyMap::<u64, ContractAddress>,\n        // The Shrine associated with this Sentinel\n        shrine: IShrineDispatcher,\n        // mapping between a yang address and the cap on the yang's asset in the\n        // asset's decimals\n        yang_asset_max: LegacyMap::<ContractAddress, u128>,\n        // mapping between a yang address and whether its Gate is live\n        yang_is_live: LegacyMap::<ContractAddress, bool>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        YangAdded: YangAdded,\n        YangAssetMaxUpdated: YangAssetMaxUpdated,\n        GateKilled: GateKilled,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangAdded {\n        #[key]\n        yang: ContractAddress,\n        gate: ContractAddress\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangAssetMaxUpdated {\n        #[key]\n        yang: ContractAddress,\n        old_max: u128,\n        new_max: u128\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct GateKilled {\n        #[key]\n        yang: ContractAddress,\n        gate: ContractAddress\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(ref self: ContractState, admin: ContractAddress, shrine: ContractAddress) {\n        self.access_control.initializer(admin, Option::Some(sentinel_roles::default_admin_role()));\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n    }\n\n    //\n    // External Sentinel functions\n    //\n\n    #[abi(embed_v0)]\n    impl ISentinelImpl of ISentinel<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_gate_address(self: @ContractState, yang: ContractAddress) -> ContractAddress {\n            self.yang_to_gate.read(yang).contract_address\n        }\n\n        fn get_gate_live(self: @ContractState, yang: ContractAddress) -> bool {\n            self.yang_is_live.read(yang)\n        }\n\n        fn get_yang_addresses(self: @ContractState) -> Span<ContractAddress> {\n            let mut idx: u64 = LOOP_START;\n            let loop_end: u64 = self.yang_addresses_count.read() + LOOP_START;\n            let mut addresses: Array<ContractAddress> = ArrayTrait::new();\n            loop {\n                if idx == loop_end {\n                    break addresses.span();\n                }\n                addresses.append(self.yang_addresses.read(idx));\n                idx += 1;\n            }\n        }\n\n        fn get_yang_addresses_count(self: @ContractState) -> u64 {\n            self.yang_addresses_count.read()\n        }\n\n        fn get_yang(self: @ContractState, idx: u64) -> ContractAddress {\n            self.yang_addresses.read(idx)\n        }\n\n        fn get_yang_asset_max(self: @ContractState, yang: ContractAddress) -> u128 {\n            self.yang_asset_max.read(yang)\n        }\n\n        fn get_asset_amt_per_yang(self: @ContractState, yang: ContractAddress) -> Wad {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            gate.get_asset_amt_per_yang()\n        }\n\n        //\n        // View functions\n        //\n\n        // This can be used to simulate the effects of `enter`.\n        fn convert_to_yang(self: @ContractState, yang: ContractAddress, asset_amt: u128) -> Wad {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            self.assert_can_enter(yang, gate, asset_amt);\n            gate.convert_to_yang(asset_amt)\n        }\n\n        // This can be used to simulate the effects of `exit`.\n        fn convert_to_assets(self: @ContractState, yang: ContractAddress, yang_amt: Wad) -> u128 {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n            gate.convert_to_assets(yang_amt)\n        }\n\n        //\n        // Setters\n        //\n\n        fn add_yang(\n            ref self: ContractState,\n            yang: ContractAddress,\n            yang_asset_max: u128,\n            yang_threshold: Ray,\n            yang_price: Wad,\n            yang_rate: Ray,\n            gate: ContractAddress\n        ) {\n            self.access_control.assert_has_role(sentinel_roles::ADD_YANG);\n            assert(yang.is_non_zero(), 'SE: Yang cannot be zero address');\n            assert(gate.is_non_zero(), 'SE: Gate cannot be zero address');\n            assert(self.yang_to_gate.read(yang).contract_address.is_zero(), 'SE: Yang already added');\n\n            let gate = IGateDispatcher { contract_address: gate };\n            assert(gate.get_asset() == yang, 'SE: Asset of gate is not yang');\n\n            let index: u64 = self.yang_addresses_count.read() + 1;\n            self.yang_addresses_count.write(index);\n            self.yang_addresses.write(index, yang);\n            self.yang_to_gate.write(yang, gate);\n            self.yang_is_live.write(yang, true);\n            self.yang_asset_max.write(yang, yang_asset_max);\n\n            // Require an initial deposit when adding a yang to prevent first depositor from front-running\n            let yang_erc20 = IERC20Dispatcher { contract_address: yang };\n            // scale `asset_amt` up by the difference to match `Wad` precision of yang\n            let initial_yang_amt: Wad = fixed_point_to_wad(INITIAL_DEPOSIT_AMT, yang_erc20.decimals());\n            let initial_deposit_amt: u256 = INITIAL_DEPOSIT_AMT.into();\n\n            let caller: ContractAddress = get_caller_address();\n            let success: bool = yang_erc20.transfer_from(caller, gate.contract_address, initial_deposit_amt);\n            assert(success, 'SE: Yang transfer failed');\n\n            let shrine: IShrineDispatcher = self.shrine.read();\n            shrine.add_yang(yang, yang_threshold, yang_price, yang_rate, initial_yang_amt);\n\n            // Events\n            self.emit(YangAdded { yang, gate: gate.contract_address });\n            self.emit(YangAssetMaxUpdated { yang, old_max: 0, new_max: yang_asset_max });\n        }\n\n        fn set_yang_asset_max(ref self: ContractState, yang: ContractAddress, new_asset_max: u128) {\n            self.access_control.assert_has_role(sentinel_roles::SET_YANG_ASSET_MAX);\n\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n\n            let old_asset_max: u128 = self.yang_asset_max.read(yang);\n            self.yang_asset_max.write(yang, new_asset_max);\n\n            self.emit(YangAssetMaxUpdated { yang, old_max: old_asset_max, new_max: new_asset_max });\n        }\n\n        fn kill_gate(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::KILL_GATE);\n\n            self.yang_is_live.write(yang, false);\n\n            self.emit(GateKilled { yang, gate: self.yang_to_gate.read(yang).contract_address });\n        }\n\n        fn suspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::UPDATE_YANG_SUSPENSION);\n            self.shrine.read().suspend_yang(yang);\n        }\n\n        fn unsuspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::UPDATE_YANG_SUSPENSION);\n            self.shrine.read().unsuspend_yang(yang);\n        }\n\n        //\n        // Core functions\n        //\n\n        fn enter(\n            ref self: ContractState, yang: ContractAddress, user: ContractAddress, trove_id: u64, asset_amt: u128\n        ) -> Wad {\n            self.access_control.assert_has_role(sentinel_roles::ENTER);\n\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n\n            self.assert_can_enter(yang, gate, asset_amt);\n            gate.enter(user, trove_id, asset_amt)\n        }\n\n        fn exit(\n            ref self: ContractState, yang: ContractAddress, user: ContractAddress, trove_id: u64, yang_amt: Wad\n        ) -> u128 {\n            self.access_control.assert_has_role(sentinel_roles::EXIT);\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n\n            gate.exit(user, trove_id, yang_amt)\n        }\n    }\n\n    //\n    // Internal Sentinel functions\n    //\n\n    #[generate_trait]\n    impl SentinelHelpers of SentinelHelpersTrait {\n        // Helper function to check that `enter` is a valid operation at the current\n        // on-chain conditions\n        #[inline(always)]\n        fn assert_can_enter(self: @ContractState, yang: ContractAddress, gate: IGateDispatcher, enter_amt: u128) {\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n            assert(self.yang_is_live.read(yang), 'SE: Gate is not live');\n            let suspension_status: YangSuspensionStatus = self.shrine.read().get_yang_suspension_status(yang);\n            assert(suspension_status == YangSuspensionStatus::None, 'SE: Yang suspended');\n            let current_total: u128 = gate.get_total_assets();\n            let max_amt: u128 = self.yang_asset_max.read(yang);\n            assert(current_total + enter_amt <= max_amt, 'SE: Exceeds max amount allowed');\n        }\n    }\n}"
    }
  ]
}