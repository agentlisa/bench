{
  "Title": "[M-09] `Guard::checkTransaction` restricts native ETH transfer from user's safes",
  "Content": "\nThe `Guard::checkTransaction` function's current design unintentionally restricts native ETH transfers from the safe. This limitation originates from a data length check that requires transaction data to be at least `4 bytes` long, aiming to validate the presence of a function selector.\n\nHowever, since native ETH transfers have empty data fields, they fail this, leading to an inability to execute such transfers.\n\nThis results in a significant functional restriction, as users are unable to execute standard ETH transfers from their safes.\n\nThe Safe contracts contains `receive` function which by default enables them to receive native ETH. These native tokens can be transferred to safe by protocol users or current/future protocol hooks.\n\n```solidity\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n```\n\n### Proof of Concept\n\nThe `Guard::checkTransaction` is designed to validate transactions initiated by a rental safe. Its role is to ascertain whether a transaction meets the set criteria based on its destination, value, data and operation type. This function is a critical component in ensuring that transactions are executed in accordance with the protocol's rule.\n\nA notable issue within the `Guard::checkTransaction` function is its requirement for transaction data to be at least 4 bytes long, as indicated by this code:\n\nIn `src/policies/Guard.sol`\n\n```solidity\n328        // Require that a function selector exists.\n329        if (data.length < 4) {\n330            revert Errors.GuardPolicy_FunctionSelectorRequired();\n331        }\n```\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L328C1-L331C10>\n\nThis condition is ideal for transactions involving function calls where a function selector is necessary.\n\nHowever, this becomes problematic for native ETH transfers, which are characteristically simple transactions without any data payload. As these transactions have a data length of zero bytes, failing the imposed condition.\n\nSuch transactions are automatically rejected by the `Guard::checkTransaction` function due to not meeting the 4-byte data length requirement.\n\nThe inability to transfer native ETH not only reduces the safe's practicality but also poses a severe limitation on user operations, affecting trust and reliability in the system.\n\nThe following foundry test shows the process described above. Copy and paste it into test folder to run.\n\n<details>\n<summary>\nClick to expand Foundry Test\n</summary>\n\n```javascript\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {BaseTest} from \"@test/BaseTest.sol\";\nimport {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\";\nimport {SafeL2} from \"@safe-contracts/SafeL2.sol\";\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\ncontract SafeStuckEth is BaseTest {\n\n    // In this test case we'll see how ETH transfers works fine for normal Gnosis Safes\n    // But doesn't work for ReNFT Safes\n    function test_poc() public {\n        vm.startPrank(alice.addr);\n\n        // Create a new safe by directly interacting with Gnosis safe factory\n        SafeProxyFactory safeFactory = factory.safeProxyFactory();\n        SafeL2 safeSingleton = factory.safeSingleton();\n        address[] memory owners = new address[](1);\n        owners[0] = alice.addr;\n        bytes memory initializerPayload = abi.encodeCall(\n            ISafe.setup,\n            (\n                owners,\n                1,\n                address(0),\n                new bytes(0),\n                address(0),\n                address(0),\n                0,\n                payable(address(0))\n            )\n        );\n        // new safe is created\n        address newSafe = address(\n            safeFactory.createProxyWithNonce(\n                address(safeSingleton),\n                initializerPayload,\n                uint256(keccak256(\"\"))\n            )\n        );\n        address receiver = address(0x1010101);\n\n        // Transfer some ETH to the freshly deployed safe\n        vm.deal(newSafe, 1 ether);\n        assertEq(newSafe.balance, 1 ether);\n        assertEq(receiver.balance, 0);\n\n        // Pull out the sent ETH from the safe\n        bytes memory transactionSignature = _signTransaction(\n            address(newSafe),\n            Enum.Operation.Call,\n            alice.privateKey,\n            address(receiver),\n            1 ether,\n            new bytes(0)\n        );\n        _executeTransaction(\n            address(newSafe),\n            Enum.Operation.Call,\n            address(receiver),\n            1 ether,\n            new bytes(0),\n            transactionSignature,\n            new bytes(0)\n        );\n        // ETH succesfully pulled out from the safe\n        assertEq(newSafe.balance, 0);\n        assertEq(receiver.balance, 1 ether);\n\n        /// Now replicate same scenario for a ReNFT safe\n\n        // Send some ETH to an existing ReNFT safe of Alice\n        vm.deal(address(alice.safe), 1 ether);\n        assertEq(address(alice.safe).balance, 1 ether);\n        assertEq(receiver.balance, 1 ether);\n\n        transactionSignature = _signTransaction(\n            address(alice.safe),\n            Enum.Operation.Call,\n            alice.privateKey,\n            address(receiver),\n            1 ether,\n            new bytes(0)\n        );\n        // Try to pull out ETH\n        // Txn reverts with error `GuardPolicy_FunctionSelectorRequired`\n        vm.expectRevert(abi.encodeWithSelector(Errors.GuardPolicy_FunctionSelectorRequired.selector));\n        _executeTransaction(\n            address(alice.safe),\n            Enum.Operation.Call,\n            address(receiver),\n            1 ether,\n            new bytes(0),\n            transactionSignature,\n            new bytes(0)\n        );\n        // ETH remains stuck in Alice's ReNFT safe\n        assertEq(address(alice.safe).balance, 1 ether);\n        assertEq(receiver.balance, 1 ether);\n    }\n\n    function _signTransaction(\n        address safe,\n        Enum.Operation operation,\n        uint256 ownerPrivateKey,\n        address to,\n        uint256 value,\n        bytes memory transaction\n    ) private view returns (bytes memory transactionSignature) {\n        // get the safe nonce\n        uint256 nonce = ISafe(safe).nonce();\n\n        // get the eip712 compatible transaction hash that the safe owner will sign\n        bytes32 transactionHash = ISafe(safe).getTransactionHash(\n            to,\n            value,\n            transaction,\n            operation,\n            0 ether,\n            0 ether,\n            0 ether,\n            address(0),\n            payable(address(0)),\n            nonce\n        );\n\n        // sign the transaction\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, transactionHash);\n        transactionSignature = abi.encodePacked(r, s, v);\n    }\n    function _executeTransaction(\n        address safe,\n        Enum.Operation operation,\n        address to,\n        uint256 value,\n        bytes memory transaction,\n        bytes memory signature,\n        bytes memory expectedError\n    ) private {\n        // expect an error if error data was provided\n        if (expectedError.length != 0) {\n            vm.expectRevert(expectedError);\n        }\n\n        // execute the transaction\n        ISafe(safe).execTransaction(\n            to,\n            value,\n            transaction,\n            operation,\n            0 ether,\n            0 ether,\n            0 ether,\n            address(0),\n            payable(address(0)),\n            signature\n        );\n    }\n}\n\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nConsider allowing `data.length` to be `0` as that will be used for performing native ETH transfers.\n\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/292#issuecomment-1913746798):**\n > See comment on [issue 261](https://github.com/code-423n4/2024-01-renft-findings/issues/261#issuecomment-1913746141).\n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/292#issuecomment-1915464362):**\n > Agree that this is a valid M vulnerability.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/6) - Allows native ETH to be transferred out of a rental safe.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/54) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/56).\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Guard.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {BaseGuard} from \"@safe-contracts/base/GuardManager.sol\";\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {\n    shared_set_approval_for_all_selector,\n    e721_approve_selector,\n    e721_safe_transfer_from_1_selector,\n    e721_safe_transfer_from_2_selector,\n    e721_transfer_from_selector,\n    e721_approve_token_id_offset,\n    e721_safe_transfer_from_1_token_id_offset,\n    e721_safe_transfer_from_2_token_id_offset,\n    e721_transfer_from_token_id_offset,\n    e1155_safe_transfer_from_selector,\n    e1155_safe_batch_transfer_from_selector,\n    e1155_safe_transfer_from_token_id_offset,\n    e1155_safe_batch_transfer_from_token_id_offset,\n    gnosis_safe_set_guard_selector,\n    gnosis_safe_enable_module_selector,\n    gnosis_safe_disable_module_selector,\n    gnosis_safe_enable_module_offset,\n    gnosis_safe_disable_module_offset\n} from \"@src/libraries/RentalConstants.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Guard\n * @notice Acts as an interface for all behavior related to guarding transactions\n *         that originate from a rental wallet.\n */\ncontract Guard is Policy, BaseGuard {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](1);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);\n        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Loads a `bytes32` value from calldata.\n     *\n     * @param data   Calldata of the transaction to execute.\n     * @param offset Byte offset where the value starts.\n     *\n     * @return value The value retrieved from the data.\n     */\n    function _loadValueFromCalldata(\n        bytes memory data,\n        uint256 offset\n    ) private pure returns (bytes32 value) {\n        // Load the `uint256` from calldata at the offset.\n        assembly {\n            value := mload(add(data, offset))\n        }\n    }\n\n    /**\n     * @dev Reverts if the token is actively rented.\n     *\n     * @param selector Function selector which cannot be called\n     * @param safe     Address of the safe that originated the call\n     * @param token    Address of the token which is actively rented.\n     * @param tokenId  ID of the token which is actively rented.\n     */\n    function _revertSelectorOnActiveRental(\n        bytes4 selector,\n        address safe,\n        address token,\n        uint256 tokenId\n    ) private view {\n        // Check if the selector is allowed.\n        if (STORE.isRentedOut(safe, token, tokenId)) {\n            revert Errors.GuardPolicy_UnauthorizedSelector(selector);\n        }\n    }\n\n    /**\n     * @dev Reverts if the extension is not whitelisted.\n     *\n     * @param extension Address of the extension.\n     */\n    function _revertNonWhitelistedExtension(address extension) private view {\n        // Check if the extension is whitelisted.\n        if (!STORE.whitelistedExtensions(extension)) {\n            revert Errors.GuardPolicy_UnauthorizedExtension(extension);\n        }\n    }\n\n    /**\n     * @dev Forwards a gnosis safe call to a hook contract for further processing.\n     *\n     * @param hook  Address of the hook contract.\n     * @param safe  Address of the rental wallet that originated the call.\n     * @param to    Address that the call is directed to.\n     * @param value Value of ether sent with the call.\n     * @param data  Calldata to execute.\n     */\n    function _forwardToHook(\n        address hook,\n        address safe,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) private {\n        // Call the `onTransaction` hook function.\n        try IHook(hook).onTransaction(safe, to, value, data) {} catch Error(\n            string memory revertReason\n        ) {\n            // Revert with reason given.\n            revert Errors.Shared_HookFailString(revertReason);\n        } catch Panic(uint256 errorCode) {\n            // Convert solidity panic code to string.\n            string memory stringErrorCode = LibString.toString(errorCode);\n\n            // Revert with panic code.\n            revert Errors.Shared_HookFailString(\n                string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n            );\n        } catch (bytes memory revertData) {\n            // Fallback to an error that returns the byte data.\n            revert Errors.Shared_HookFailBytes(revertData);\n        }\n    }\n\n    /**\n     * @dev Prevent transactions that involve transferring an ERC721 or ERC1155 in any\n     *      way, and prevent transactions that involve changing the modules or the\n     *      guard contract.\n     *\n     * @param from Rental safe address that initiated the transaction.\n     * @param to Address that the data is targetted to.\n     * @param data Calldata of the transaction.\n     */\n    function _checkTransaction(address from, address to, bytes memory data) private view {\n        bytes4 selector;\n\n        // Load in the function selector.\n        assembly {\n            selector := mload(add(data, 0x20))\n        }\n\n        if (selector == e721_safe_transfer_from_1_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_safe_transfer_from_1_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_safe_transfer_from_2_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_safe_transfer_from_2_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e721_approve_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e721_approve_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n        } else if (selector == gnosis_safe_enable_module_selector) {\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n                        _loadValueFromCalldata(data, gnosis_safe_enable_module_offset)\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n            _revertNonWhitelistedExtension(extension);\n        } else if (selector == gnosis_safe_disable_module_selector) {\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n                        _loadValueFromCalldata(data, gnosis_safe_disable_module_offset)\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n            _revertNonWhitelistedExtension(extension);\n        } else {\n            // Revert if the `setApprovalForAll` selector is specified. This selector is\n            // shared between ERC721 and ERC1155 tokens.\n            if (selector == shared_set_approval_for_all_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    shared_set_approval_for_all_selector\n                );\n            }\n\n            // Revert if the `safeBatchTransferFrom` selector is specified. There's no\n            // cheap way to check if individual items in the batch are rented out.\n            // Each token ID would require a call to the storage contract to check\n            // its rental status.\n            if (selector == e1155_safe_batch_transfer_from_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    e1155_safe_batch_transfer_from_selector\n                );\n            }\n\n            // Revert if the `setGuard` selector is specified.\n            if (selector == gnosis_safe_set_guard_selector) {\n                revert Errors.GuardPolicy_UnauthorizedSelector(\n                    gnosis_safe_set_guard_selector\n                );\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /** @notice Checks a transaction initiated by a rental safe to decide whether\n     *          it can be allowed or not. During this check, execution control flow\n     *          will be passed to an external hook contract if one exists for the\n     *          target contract.\n     *\n     * @param to             Destination address of Safe transaction.\n     * @param value          Ether value of Safe transaction.\n     * @param data           Data payload of Safe transaction.\n     * @param operation      Operation type of Safe transaction.\n     */\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        address payable,\n        bytes memory,\n        address\n    ) external override {\n        // Disallow transactions that use delegate call, unless explicitly\n        // permitted by the protocol.\n        if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n            revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n        }\n\n        // Require that a function selector exists.\n        if (data.length < 4) {\n            revert Errors.GuardPolicy_FunctionSelectorRequired();\n        }\n\n        // Fetch the hook to interact with for this transaction.\n        address hook = STORE.contractToHook(to);\n        bool isActive = STORE.hookOnTransaction(hook);\n\n        // If a hook exists and is enabled, forward the control flow to the hook.\n        if (hook != address(0) && isActive) {\n            _forwardToHook(hook, msg.sender, to, value, data);\n        }\n        // If no hook exists, use basic tx check.\n        else {\n            _checkTransaction(msg.sender, to, data);\n        }\n    }\n\n    /**\n     * @notice Performs any checks after execution. This is left unimplemented.\n     *\n     * @param txHash Hash of the transaction.\n     * @param success Whether the transaction succeeded.\n     */\n    function checkAfterExecution(bytes32 txHash, bool success) external override {}\n\n    /**\n     * @notice Connects a target contract to a hook.\n     *\n     * @param to   The destination contract of a call.\n     * @param hook The hook middleware contract to sit between the call\n     *             and the destination.\n     */\n    function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") {\n        STORE.updateHookPath(to, hook);\n    }\n\n    /**\n     * @notice Toggle the status of a hook contract, which defines the functionality\n     *         that the hook supports.\n     *\n     * @param hook The hook contract address.\n     * @param bitmap Bitmap of the status.\n     */\n    function updateHookStatus(\n        address hook,\n        uint8 bitmap\n    ) external onlyRole(\"GUARD_ADMIN\") {\n        STORE.updateHookStatus(hook, bitmap);\n    }\n}"
    }
  ]
}