{
  "Title": "Organizers are not incentivized to deploy and distribute to winners causing that winners may not to be rewarded for a long time and force the protocol owner to manage the distribution",
  "Content": "# Organizers are not incentivized to deploy and distribute to winners causing that winners may not to be rewarded for a long time and force the protocol owner to manage the distribution\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L127\">https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L127</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L152\">https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L152</a>\n\n\n## Summary\n\nThe organizer can deploy and distribute to winners at any time without restriction about the contest expiration time `EXPIRATION_TIME` causing that the winners to be unable to receive their rewards for a long time.\n\n## Vulnerability Details\n\nThe organizer can execute the [deployProxyAndDistribute()](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L127C14-L127C38) function to deploy the `distribute` contract and execute the [distribution](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L136) to winners. The only restriction is that the current time should be [greater than contest close time](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L134) (code line 134).\n\n```solidity\nFile: ProxyFactory.sol\n127:     function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n128:         public\n129:         returns (address)\n130:     {\n131:         bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n132:         if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n133:         // can set close time to current time and end it immediately if organizer wish\n134:         if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n...\n...\n```\n\nIn the other hand, the `owner` can execute [deployProxyAndDistributeByOwner()](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L179C14-L179C45) function after the [contest expiration time](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L187) (code line [187](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L187)).\n\n```solidity\nFile: ProxyFactory.sol\n179:     function deployProxyAndDistributeByOwner(\n180:         address organizer,\n181:         bytes32 contestId,\n182:         address implementation,\n183:         bytes calldata data\n184:     ) public onlyOwner returns (address) {\n185:         bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n186:         if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n187:         if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n...\n...\n```\n\nThe problem is that the `organizer` can execute the [deployProxyAndDistribute()](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L127C14-L127C38) function after the [contest close time](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L134) without restriction of time. The `organizer` can wait indefinitely causing the winners not to be rewarded for a long time and force the owner to execute the distribution manually via `deployProxyAndDistributeByOwner()`.\n\nAdditionally, the `organizers` are not incentivized to deploy and distribute to winners.\n\n## Impact\n\nThe malicious organizer can wait indefinitely until the `owner` calls [deployProxyAndDistributeByOwner()](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L179C14-L179C45). The bad/malicious behaivour of the `organizer` can cause the winners to be unable receive rewards for a long time AND force the `owner` to execute manually `deployProxyAndDistributeByOwner()`. That affects the protocol because rewards are not assigned in time AND the protocol owner needs to manage manually the deploy and distribution in order to not affect the protocol's reputation and winners.\n\nAdditionally the `organizers` are not incentivized to deploy and distribute to winners causing to the protocol owner to execute manually the `deployProxyAndDistributeByOwner()`.\n\n## Tools used\n\nManual review\n\n## Recommendations\n\nAdd a validation that the `organizer` distribution must be between the `saltToCloseTime` and the `EXPIRATION_TIME`. Same in [deployProxyAndDistributeBySignature()](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L152C14-L152C49)\n\n```diff\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n++      if (saltToCloseTime[salt] + EXPIRATION_TIME < block.timestamp) revert();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n```\n\nAdditionally, there should be a penalization to the `organizer` or an incentive to deploy and distribute in time to winners.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
  "Code": [
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy address\n    function getProxyAddress(bytes32 salt, address implementation) public view returns (address proxy) {\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(uint160(implementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        proxy = address(uint160(uint256(hash)));\n    }\n\n    ///////////////////////////////////\n    /////// Internal functions ////////\n    ///////////////////////////////////\n    /// @dev Deploy proxy and return the proxy address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _deployProxy(address organizer, bytes32 contestId, address implementation) internal returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        address proxy = address(new Proxy{salt: salt}(implementation));\n        return proxy;\n    }\n\n    /// @dev The internal function to be used to call proxy to distribute prizes to the winners\n    /// @dev the data passed in should be the calling data of the distributing logic\n    /// @param proxy The proxy address\n    /// @param data The prize distribution data\n    function _distribute(address proxy, bytes calldata data) internal {\n        (bool success,) = proxy.call(data);\n        if (!success) revert ProxyFactory__DelegateCallFailed();\n        emit Distributed(proxy, data);\n    }\n\n    /// @dev Calculate salt using contest organizer address and contestId, implementation address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _calculateSalt(address organizer, bytes32 contestId, address implementation)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(organizer, contestId, implementation));\n    }\n}"
    },
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy address\n    function getProxyAddress(bytes32 salt, address implementation) public view returns (address proxy) {\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(uint160(implementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        proxy = address(uint160(uint256(hash)));\n    }\n\n    ///////////////////////////////////\n    /////// Internal functions ////////\n    ///////////////////////////////////\n    /// @dev Deploy proxy and return the proxy address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _deployProxy(address organizer, bytes32 contestId, address implementation) internal returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        address proxy = address(new Proxy{salt: salt}(implementation));\n        return proxy;\n    }\n\n    /// @dev The internal function to be used to call proxy to distribute prizes to the winners\n    /// @dev the data passed in should be the calling data of the distributing logic\n    /// @param proxy The proxy address\n    /// @param data The prize distribution data\n    function _distribute(address proxy, bytes calldata data) internal {\n        (bool success,) = proxy.call(data);\n        if (!success) revert ProxyFactory__DelegateCallFailed();\n        emit Distributed(proxy, data);\n    }\n\n    /// @dev Calculate salt using contest organizer address and contestId, implementation address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _calculateSalt(address organizer, bytes32 contestId, address implementation)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(organizer, contestId, implementation));\n    }\n}"
    },
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy a"
    }
  ]
}