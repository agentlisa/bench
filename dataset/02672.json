{
  "Title": "Testcode in production",
  "Content": "The [`ProposerV2`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/ProposerV2.sol#L17) and [`GovernorV2`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/GovernorV2.sol#L18)contracts inherit the [`Testable`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/common/implementation/Testable.sol) contract, which is meant to allow setting and providing the time via an additional external contract. During deployment to a production environment the inheritance of `Testable` is meant to be kept while disabling the external time setter [by passing the zero address](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/common/implementation/Testable.sol#L17) to the testable constructor.\n\n\nThis testing methodology increases both the code size and the risk of deployment mistakes. Further, it allows multiple time sources for different contracts within the project’s test cases, thereby increasing the likelihood of erroneous tests.\n\n\nConsider replacing the `Testable` contract with equivalent functionality provided by the project’s test framework. For example, consider using `evm_setNextBlockTimestamp` in Hardhat or `vm.warp` in Foundry.\n\n\nIf maintaining a dedicated function for time setting in the contract code is desired, consider reversing the order of inheritance by implementing a virtual function `getCurrentTime` which returns `block.timestamp` in the production versions of `ProposerV2` and `GovernorV2`, and deriving specialized testing contracts that override `getCurrentTime` to implement the time setting capabilities of `Testable`.\n\n\n**Update:** *Fixed as of commit [`90b6634f6daebf02100f4a1b8aa6bca22bc64cc8`](https://github.com/UMAprotocol/protocol/pull/4095/commits/90b6634f6daebf02100f4a1b8aa6bca22bc64cc8) in [pull request #4095](https://github.com/UMAprotocol/protocol/pull/4095).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/ProposerV2.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./Finder.sol\";\nimport \"./GovernorV2.sol\";\nimport \"./Constants.sol\";\nimport \"./Voting.sol\";\nimport \"./AdminIdentifierLib.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Proposer contract that allows anyone to make governance proposals with a bond.\n */\ncontract ProposerV2 is Ownable, Testable, Lockable {\n    using SafeERC20 for IERC20;\n    IERC20 public token;\n    uint256 public bond;\n    GovernorV2 public governor;\n    Finder public finder;\n\n    struct BondedProposal {\n        address sender;\n        // 64 bits to save a storage slot.\n        uint64 time;\n        uint256 lockedBond;\n        bytes ancillaryData;\n    }\n    mapping(uint256 => BondedProposal) public bondedProposals;\n\n    event BondSet(uint256 bond);\n    event ProposalResolved(uint256 indexed id, bool success);\n\n    /**\n     * @notice Construct the Proposer contract.\n     * @param _token the ERC20 token that the bond is paid in.\n     * @param _bond the bond amount.\n     * @param _governor the governor contract that this contract makes proposals to.\n     * @param _finder the finder contract used to look up addresses.\n     * @param _timer the timer contract to control the output of getCurrentTime(). Set to 0x0 if in production.\n     */\n    constructor(\n        IERC20 _token,\n        uint256 _bond,\n        GovernorV2 _governor,\n        Finder _finder,\n        address _timer\n    ) Testable(_timer) {\n        token = _token;\n        governor = _governor;\n        finder = _finder;\n        setBond(_bond);\n        transferOwnership(address(_governor));\n    }\n\n    /**\n     * @notice Propose a new set of governance transactions for vote.\n     * @dev Pulls bond from the caller.\n     * @param transactions list of transactions for the governor to execute.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return id the id of the governor proposal.\n     */\n    function propose(GovernorV2.Transaction[] memory transactions, bytes memory ancillaryData)\n        external\n        nonReentrant()\n        returns (uint256 id)\n    {\n        id = governor.numProposals();\n        token.safeTransferFrom(msg.sender, address(this), bond);\n        bondedProposals[id] = BondedProposal({\n            sender: msg.sender,\n            lockedBond: bond,\n            time: uint64(getCurrentTime()),\n            ancillaryData: ancillaryData\n        });\n        governor.propose(transactions, ancillaryData);\n    }\n\n    /**\n     * @notice Resolves a proposal by checking the status of the request in the Voting contract.\n     * @dev For the resolution to work correctly, this contract must be a registered contract in the DVM.\n     * @param id proposal id.\n     */\n    function resolveProposal(uint256 id) external nonReentrant() {\n        BondedProposal memory bondedProposal = bondedProposals[id];\n        Voting voting = Voting(finder.getImplementationAddress(OracleInterfaces.Oracle));\n        require(\n            voting.hasPrice(\n                AdminIdentifierLib._constructIdentifier(id),\n                bondedProposal.time,\n                bondedProposal.ancillaryData\n            ),\n            \"No price resolved\"\n        );\n        if (\n            voting.getPrice(\n                AdminIdentifierLib._constructIdentifier(id),\n                bondedProposal.time,\n                bondedProposal.ancillaryData\n            ) != 0\n        ) {\n            token.safeTransfer(bondedProposal.sender, bondedProposal.lockedBond);\n            emit ProposalResolved(id, true);\n        } else {\n            token.safeTransfer(finder.getImplementationAddress(OracleInterfaces.Store), bondedProposal.lockedBond);\n            emit ProposalResolved(id, false);\n        }\n        delete bondedProposals[id];\n    }\n\n    /**\n     * @notice Admin method to set the bond amount.\n     * @dev Admin is intended to be the governance system, itself.\n     * @param _bond the new bond.\n     */\n    function setBond(uint256 _bond) public nonReentrant() onlyOwner() {\n        bond = _bond;\n        emit BondSet(_bond);\n    }\n}"
    }
  ]
}