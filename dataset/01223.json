{
  "Title": "Possible DOS on deposit(), withdraw() and unstake() for BridgeReth, leading to user loss of funds",
  "Content": "# Possible DOS on deposit(), withdraw() and unstake() for BridgeReth, leading to user loss of funds\n\n### Severity\nMedium Risk\n\n## Summary\nFuture changes on deposit delay on rETH tokens would prevent DittoETH users to use deposit(), withdraw() and unstake() for BridgeReth, which would make its transfering and burning impractical, leading to user funds losses.\n## Vulnerability Details\nRocketPool rETH tokens has a [deposit delay](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/token/RocketTokenRETH.sol#L157-L172) that prevents any user who has recently deposited to transfer or burn tokens. In the past this delay was set to 5760 blocks mined (aprox. 19h, considering one block per 12s). This delay can prevent DittoETH users from transfering if another user staked recently.\n\nFile: RocketTokenRETH.sol\n``` solidity\n  // This is called by the base ERC20 contract before all transfer, mint, and burns\n    function _beforeTokenTransfer(address from, address, uint256) internal override {\n        // Don't run check if this is a mint transaction\n        if (from != address(0)) {\n            // Check which block the user's last deposit was\n            bytes32 key = keccak256(abi.encodePacked(\"user.deposit.block\", from));\n            uint256 lastDepositBlock = getUint(key);\n            if (lastDepositBlock > 0) {\n                // Ensure enough blocks have passed\n                uint256 depositDelay = getUint(keccak256(abi.encodePacked(keccak256(\"dao.protocol.setting.network\"), \"network.reth.deposit.delay\")));\n                uint256 blocksPassed = block.number.sub(lastDepositBlock);\n                require(blocksPassed > depositDelay, \"Not enough time has passed since deposit\");\n                // Clear the state as it's no longer necessary to check this until another deposit is made\n                deleteUint(key);\n            }\n        }\n    }\n```\n\nAny future changes made to this delay by the admins could potentially lead to a denial-of-service attack on the `BridgeRouterFacet::deposit` and `BridgeRouterFacet::withdraw` mechanism for the rETH bridge.\n## Impact\nCurrently, the delay is set to zero, but if RocketPool admins decide to change this value in the future, it could cause issues. Specifically, protocol users staking actions could prevent other users from unstaking for a few hours. Given that many users call the stake function throughout the day, the delay would constantly reset, making the unstaking mechanism unusable. It's important to note that this only occurs when stake() is used through the rocketDepositPool route. If rETH is obtained from the Uniswap pool, the delay is not affected.   \nAll the ETH swapped for rETH calling `BridgeReth::depositEth` would become irrecuperable, leading to a user bank run on DittoETH to not be perjudicated of this protocol externalization to all the users that have deposited.\n## Tools Used\nManual review.\n## Recommendations\nConsider modifying Reth bridge to obtain rETH only through the UniswapV3 pool, on average users will get less rETH due to the slippage, but will avoid any future issues with the deposit delay mechanism.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/contract/token/RocketTokenRETH.sol",
      "content": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../RocketBase.sol\";\nimport \"../../interface/deposit/RocketDepositPoolInterface.sol\";\nimport \"../../interface/network/RocketNetworkBalancesInterface.sol\";\nimport \"../../interface/token/RocketTokenRETHInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\n\n// rETH is a tokenised stake in the Rocket Pool network\n// rETH is backed by ETH (subject to liquidity) at a variable exchange rate\n\ncontract RocketTokenRETH is RocketBase, ERC20, RocketTokenRETHInterface {\n\n    // Libs\n    using SafeMath for uint;\n\n    // Events\n    event EtherDeposited(address indexed from, uint256 amount, uint256 time);\n    event TokensMinted(address indexed to, uint256 amount, uint256 ethAmount, uint256 time);\n    event TokensBurned(address indexed from, uint256 amount, uint256 ethAmount, uint256 time);\n\n    // Construct with our token details\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) ERC20(\"Rocket Pool ETH\", \"rETH\") {\n        // Version\n        version = 1;\n    }\n\n    // Receive an ETH deposit from a minipool or generous individual\n    receive() external payable {\n        // Emit ether deposited event\n        emit EtherDeposited(msg.sender, msg.value, block.timestamp);\n    }\n\n    // Calculate the amount of ETH backing an amount of rETH\n    function getEthValue(uint256 _rethAmount) override public view returns (uint256) {\n        // Get network balances\n        RocketNetworkBalancesInterface rocketNetworkBalances = RocketNetworkBalancesInterface(getContractAddress(\"rocketNetworkBalances\"));\n        uint256 totalEthBalance = rocketNetworkBalances.getTotalETHBalance();\n        uint256 rethSupply = rocketNetworkBalances.getTotalRETHSupply();\n        // Use 1:1 ratio if no rETH is minted\n        if (rethSupply == 0) { return _rethAmount; }\n        // Calculate and return\n        return _rethAmount.mul(totalEthBalance).div(rethSupply);\n    }\n\n    // Calculate the amount of rETH backed by an amount of ETH\n    function getRethValue(uint256 _ethAmount) override public view returns (uint256) {\n        // Get network balances\n        RocketNetworkBalancesInterface rocketNetworkBalances = RocketNetworkBalancesInterface(getContractAddress(\"rocketNetworkBalances\"));\n        uint256 totalEthBalance = rocketNetworkBalances.getTotalETHBalance();\n        uint256 rethSupply = rocketNetworkBalances.getTotalRETHSupply();\n        // Use 1:1 ratio if no rETH is minted\n        if (rethSupply == 0) { return _ethAmount; }\n        // Check network ETH balance\n        require(totalEthBalance > 0, \"Cannot calculate rETH token amount while total network balance is zero\");\n        // Calculate and return\n        return _ethAmount.mul(rethSupply).div(totalEthBalance);\n    }\n\n    // Get the current ETH : rETH exchange rate\n    // Returns the amount of ETH backing 1 rETH\n    function getExchangeRate() override external view returns (uint256) {\n        return getEthValue(1 ether);\n    }\n\n    // Get the total amount of collateral available\n    // Includes rETH contract balance & excess deposit pool balance\n    function getTotalCollateral() override public view returns (uint256) {\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        return rocketDepositPool.getExcessBalance().add(address(this).balance);\n    }\n\n    // Get the current ETH collateral rate\n    // Returns the portion of rETH backed by ETH in the contract as a fraction of 1 ether\n    function getCollateralRate() override public view returns (uint256) {\n        uint256 totalEthValue = getEthValue(totalSupply());\n        if (totalEthValue == 0) { return calcBase; }\n        return calcBase.mul(address(this).balance).div(totalEthValue);\n    }\n\n    // Deposit excess ETH from deposit pool\n    // Only accepts calls from the RocketDepositPool contract\n    function depositExcess() override external payable onlyLatestContract(\"rocketDepositPool\", msg.sender) {\n        // Emit ether deposited event\n        emit EtherDeposited(msg.sender, msg.value, block.timestamp);\n    }\n\n    // Mint rETH\n    // Only accepts calls from the RocketDepositPool contract\n    function mint(uint256 _ethAmount, address _to) override external onlyLatestContract(\"rocketDepositPool\", msg.sender) {\n        // Get rETH amount\n        uint256 rethAmount = getRethValue(_ethAmount);\n        // Check rETH amount\n        require(rethAmount > 0, \"Invalid token mint amount\");\n        // Update balance & supply\n        _mint(_to, rethAmount);\n        // Emit tokens minted event\n        emit TokensMinted(_to, rethAmount, _ethAmount, block.timestamp);\n    }\n\n    // Burn rETH for ETH\n    function burn(uint256 _rethAmount) override external {\n        // Check rETH amount\n        require(_rethAmount > 0, \"Invalid token burn amount\");\n        require(balanceOf(msg.sender) >= _rethAmount, \"Insufficient rETH balance\");\n        // Get ETH amount\n        uint256 ethAmount = getEthValue(_rethAmount);\n        // Get & check ETH balance\n        uint256 ethBalance = getTotalCollateral();\n        require(ethBalance >= ethAmount, \"Insufficient ETH balance for exchange\");\n        // Update balance & supply\n        _burn(msg.sender, _rethAmount);\n        // Withdraw ETH from deposit pool if required\n        withdrawDepositCollateral(ethAmount);\n        // Transfer ETH to sender\n        msg.sender.transfer(ethAmount);\n        // Emit tokens burned event\n        emit TokensBurned(msg.sender, _rethAmount, ethAmount, block.timestamp);\n    }\n\n    // Withdraw ETH from the deposit pool for collateral if required\n    function withdrawDepositCollateral(uint256 _ethRequired) private {\n        // Check rETH contract balance\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance >= _ethRequired) { return; }\n        // Withdraw\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        rocketDepositPool.withdrawExcessBalance(_ethRequired.sub(ethBalance));\n    }\n\n    // Sends any excess ETH from this contract to the deposit pool (as determined by target collateral rate)\n    function depositExcessCollateral() external override {\n        // Load contracts\n        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress(\"rocketDAOProtocolSettingsNetwork\"));\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        // Get collateral and target collateral rate\n        uint256 collateralRate = getCollateralRate();\n        uint256 targetCollateralRate = rocketDAOProtocolSettingsNetwork.getTargetRethCollateralRate();\n        // Check if we are in excess\n        if (collateralRate > targetCollateralRate) {\n            // Calculate our target collateral in ETH\n            uint256 targetCollateral = address(this).balance.mul(targetCollateralRate).div(collateralRate);\n            // If we have excess\n            if (address(this).balance > targetCollateral) {\n                // Send that excess to deposit pool\n                uint256 excessCollateral = address(this).balance.sub(targetCollateral);\n                rocketDepositPool.recycleExcessCollateral{value: excessCollateral}();\n            }\n        }\n    }\n\n    // This is called by the base ERC20 contract before all transfer, mint, and burns\n    function _beforeTokenTransfer(address from, address, uint256) internal override {\n        // Don't run check if this is a mint transaction\n        if (from != address(0)) {\n            // Check which block the user's last deposit was\n            bytes32 key = keccak256(abi.encodePacked(\"user.deposit.block\", from));\n            uint256 lastDepositBlock = getUint(key);\n            if (lastDepositBlock > 0) {\n                // Ensure enough blocks have passed\n                uint256 depositDelay = getUint(keccak256(abi.encodePacked(keccak256(\"dao.protocol.setting.network\"), \"network.reth.deposit.delay\")));\n                uint256 blocksPassed = block.number.sub(lastDepositBlock);\n                require(blocksPassed > depositDelay, \"Not enough time has passed since deposit\");\n                // Clear the state as it's no longer necessary to check this until another deposit is made\n                deleteUint(key);\n            }\n        }\n    }\n}"
    }
  ]
}