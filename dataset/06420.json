{
  "Title": "[M-04] `updatePoolAddress` functions always revert when updating existing `poolId`",
  "Content": "\nThe purpose of the `updatePoolAddress` function is to update the pool address associated with an existing `poolId`. However, due to its internal invocation of the `verifyNewPool` function, the `updatePoolAddress` function always reverts. This occurs because the `verifyNewPool` function itself reverts when the specified `poolId` already exists. Consequently, it is not possible to update the pool address for an existing `poolId`.\n\n### Proof of Concept\n\nThe issue occurs in the `updatePoolAddress` function below :\n\nFile: PoolUtils.sol [Line 55-65](https://github.com/code-423n4/2023-06-stader/blob/main/contracts/PoolUtils.sol#L55-L65)\n\n```solidity\nfunction updatePoolAddress(\n    uint8 _poolId,\n    address _newPoolAddress\n) external override onlyExistingPoolId(_poolId) onlyRole(DEFAULT_ADMIN_ROLE) {\n    UtilLib.checkNonZeroAddress(_newPoolAddress);\n    // @audit always revert on exsiting poolId\n    verifyNewPool(_poolId, _newPoolAddress); \n    poolAddressById[_poolId] = _newPoolAddress;\n    emit PoolAddressUpdated(_poolId, _newPoolAddress);\n}\n```\n\nAs it can be seen from the code above, the `updatePoolAddress` function contains the `onlyExistingPoolId` modifier which means it can only be called for updating the pool address of an already exiting `poolId`.\n\nBefore updating the pool address, the `updatePoolAddress` function calls the `verifyNewPool` function below:\n\n```solidity\nfunction verifyNewPool(uint8 _poolId, address _poolAddress) internal view {\n    if (\n        INodeRegistry(IStaderPoolBase(_poolAddress).getNodeRegistry()).POOL_ID() != _poolId ||\n        isExistingPoolId(_poolId)\n    ) {\n        revert ExistingOrMismatchingPoolId();\n    }\n}\n```\n\nIt's clear that the function reverts when the `poolId` already exists meaning `isExistingPoolId(_poolId) == true`.\n\nTo summarize, the `updatePoolAddress` function reverts when the `poolId` does not exist and the `verifyNewPool` function reverts when the `poolId` exists. These two functions work on opposite conditions, which means when the `verifyNewPool` function is called inside the `updatePoolAddress` function it will automatically revert and the pool address of already existing `poolId` can never be updated.\n\n### Recommended Mitigation Steps\n\nRemove the `verifyNewPool` call inside the `updatePoolAddress` function and replace it with the following:\n\n```solidity\nfunction updatePoolAddress(\n    uint8 _poolId,\n    address _newPoolAddress\n) external override onlyExistingPoolId(_poolId) onlyRole(DEFAULT_ADMIN_ROLE) {\n    UtilLib.checkNonZeroAddress(_newPoolAddress);\n    // @audit revert only when mismatch in poolId\n    if (INodeRegistry(IStaderPoolBase(_poolAddress).getNodeRegistry()).POOL_ID() != _poolId) {\n        revert MismatchingPoolId();\n    }\n    poolAddressById[_poolId] = _newPoolAddress;\n    emit PoolAddressUpdated(_poolId, _newPoolAddress);\n}\n```\n\n### Assessed type\n\nError\n\n**[Picodes (judge) decreased severity to Medium](https://github.com/code-423n4/2022-06-stader-findings/issues/341#issuecomment-1585685615)**\n\n**[manoj9april (Stader) confirmed and commented](https://github.com/code-423n4/2022-06-stader-findings/issues/341#issuecomment-1598325548):**\n > Thanks!\n> We will fix this.\n\n**[sanjay-staderlabs (Stader) commented](https://github.com/code-423n4/2023-06-stader-findings/issues/341#issuecomment-1633520863):**\n>This is fixed.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-stader",
  "Code": [
    {
      "filename": "contracts/PoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport './interfaces/IPoolUtils.sol';\nimport './interfaces/IStaderPoolBase.sol';\nimport './interfaces/IStaderConfig.sol';\n\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\n\ncontract PoolUtils is IPoolUtils, Initializable, AccessControlUpgradeable {\n    uint64 private constant PUBKEY_LENGTH = 48;\n    uint64 private constant SIGNATURE_LENGTH = 96;\n    IStaderConfig public staderConfig;\n\n    mapping(uint8 => address) public override poolAddressById;\n    uint8[] public override poolIdArray;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) public initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        __AccessControl_init_unchained();\n        staderConfig = IStaderConfig(_staderConfig);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n\n    /**\n     * @notice Add a new pool.\n     * @dev This function should only be called by the `MANAGER` role\n     * @param _poolId Id of the pool.\n     * @param _poolAddress The address of the new pool contract.\n     */\n    function addNewPool(uint8 _poolId, address _poolAddress) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        UtilLib.checkNonZeroAddress(_poolAddress);\n        verifyNewPool(_poolId, _poolAddress);\n        poolIdArray.push(_poolId);\n        poolAddressById[_poolId] = _poolAddress;\n        emit PoolAdded(_poolId, _poolAddress);\n    }\n\n    /**\n     * @notice Update the address of a pool.\n     * @dev This function should only be called by the `DEFAULT_ADMIN_ROLE` role\n     * @param _poolId The Id of the pool to update.\n     * @param _newPoolAddress The updated address of the pool.\n     */\n    function updatePoolAddress(uint8 _poolId, address _newPoolAddress)\n        external\n        override\n        onlyExistingPoolId(_poolId)\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        UtilLib.checkNonZeroAddress(_newPoolAddress);\n        verifyNewPool(_poolId, _newPoolAddress);\n        poolAddressById[_poolId] = _newPoolAddress;\n        emit PoolAddressUpdated(_poolId, _newPoolAddress);\n    }\n\n    /**\n     * @notice validator pubkey list to exit for fulfilling user withdraw requests\n     * @param _pubkeys list of validator pubkeys to exit\n     * @dev emit an event containing validator pubkey for offchain to exit the validator\n     */\n    function processValidatorExitList(bytes[] calldata _pubkeys) external override {\n        UtilLib.onlyOperatorRole(msg.sender, staderConfig);\n        uint256 exitValidatorCount = _pubkeys.length;\n        for (uint256 i; i < exitValidatorCount; ) {\n            emit ExitValidator(_pubkeys[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    //update the address of staderConfig\n    function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    /// @inheritdoc IPoolUtils\n    function getProtocolFee(uint8 _poolId) public view override onlyExistingPoolId(_poolId) returns (uint256) {\n        return IStaderPoolBase(poolAddressById[_poolId]).protocolFee();\n    }\n\n    /// @inheritdoc IPoolUtils\n    function getOperatorFee(uint8 _poolId) public view override onlyExistingPoolId(_poolId) returns (uint256) {\n        return IStaderPoolBase(poolAddressById[_poolId]).operatorFee();\n    }\n\n    /// @inheritdoc IPoolUtils\n    function getTotalActiveValidatorCount() external view override returns (uint256) {\n        uint256 totalActiveValidatorCount;\n        uint256 poolCount = getPoolCount();\n        for (uint256 i = 0; i < poolCount; i++) {\n            totalActiveValidatorCount += getActiveValidatorCountByPool(poolIdArray[i]);\n        }\n\n        return totalActiveValidatorCount;\n    }\n\n    /// @inheritdoc IPoolUtils\n    function getQueuedValidatorCountByPool(uint8 _poolId)\n        external\n        view\n        override\n        onlyExistingPoolId(_poolId)\n        returns (uint256)\n    {\n        address nodeRegistry = getNodeRegistry(_poolId);\n        return INodeRegistry(nodeRegistry).getTotalQueuedValidatorCount();\n    }\n\n    /// @inheritdoc IPoolUtils\n    function getActiveValidatorCountByPool(uint8 _poolId)\n        public\n        view\n        override\n        onlyExistingPoolId(_poolId)\n        returns (uint256)\n    {\n        address nodeRegistry = getNodeRegistry(_poolId);\n        return INodeRegistry(nodeRegistry).getTotalActiveValidatorCount();\n    }\n\n    /// @inheritdoc IPoolUtils\n    function getSocializingPoolAddress(uint8 _poolId)\n        public\n        view\n        override\n        onlyExistingPoolId(_poolId)\n        returns (address)\n    {\n        return IStaderPoolBase(poolAddressById[_poolId]).getSocializingPoolAddress();\n    }\n\n    /// @inheritdoc IPoolUtils\n    function getOperatorTotalNonTerminalKeys(\n        uint8 _poolId,\n        address _nodeOperator,\n        uint256 _startIndex,\n        uint256 _endIndex\n    ) public view override onlyExistingPoolId(_poolId) returns (uint256) {\n        address nodeRegistry = getNodeRegistry(_poolId);\n        return INodeRegistry(nodeRegistry).getOperatorTotalNonTerminalKeys(_nodeOperator, _startIndex, _endIndex);\n    }\n\n    function getCollateralETH(uint8 _poolId) public view override onlyExistingPoolId(_poolId) returns (uint256) {\n        address nodeRegistry = getNodeRegistry(_poolId);\n        return INodeRegistry(nodeRegistry).getCollateralETH();\n    }\n\n    function getNodeRegistry(uint8 _poolId) public view override onlyExistingPoolId(_poolId) returns (address) {\n        return IStaderPoolBase(poolAddressById[_poolId]).getNodeRegistry();\n    }\n\n    function isExistingPubkey(bytes calldata _pubkey) public view override returns (bool) {\n        uint256 poolCount = getPoolCount();\n        for (uint256 i = 0; i < poolCount; i++) {\n            address nodeRegistry = getNodeRegistry(poolIdArray[i]);\n            if (INodeRegistry(nodeRegistry).isExistingPubkey(_pubkey)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isExistingOperator(address _operAddr) external view override returns (bool) {\n        uint256 poolCount = getPoolCount();\n        for (uint256 i = 0; i < poolCount; i++) {\n            address nodeRegistry = getNodeRegistry(poolIdArray[i]);\n            if (INodeRegistry(nodeRegistry).isExistingOperator(_operAddr)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getOperatorPoolId(address _operAddr) external view override returns (uint8) {\n        uint256 poolCount = getPoolCount();\n        for (uint256 i = 0; i < poolCount; i++) {\n            address nodeRegistry = getNodeRegistry(poolIdArray[i]);\n            if (INodeRegistry(nodeRegistry).isExistingOperator(_operAddr)) {\n                return poolIdArray[i];\n            }\n        }\n        revert OperatorIsNotOnboarded();\n    }\n\n    function getValidatorPoolId(bytes calldata _pubkey) external view override returns (uint8) {\n        uint256 poolCount = getPoolCount();\n        for (uint256 i = 0; i < poolCount; i++) {\n            address nodeRegistry = getNodeRegistry(poolIdArray[i]);\n            if (INodeRegistry(nodeRegistry).isExistingPubkey(_pubkey)) {\n                return poolIdArray[i];\n            }\n        }\n        revert PubkeyDoesNotExit();\n    }\n\n    function getPoolIdArray() external view override returns (uint8[] memory) {\n        return poolIdArray;\n    }\n\n    // only valid name with string length limit\n    function onlyValidName(string calldata _name) external view {\n        if (bytes(_name).length == 0) {\n            revert EmptyNameString();\n        }\n        if (bytes(_name).length > staderConfig.getOperatorMaxNameLength()) {\n            revert NameCrossedMaxLength();\n        }\n    }\n\n    // checks for keys lengths, and if pubkey is already present in stader protocol\n    function onlyValidKeys(\n        bytes calldata _pubkey,\n        bytes calldata _preDepositSignature,\n        bytes calldata _depositSignature\n    ) external view {\n        if (_pubkey.length != PUBKEY_LENGTH) {\n            revert InvalidLengthOfPubkey();\n        }\n        if (_preDepositSignature.length != SIGNATURE_LENGTH) {\n            revert InvalidLengthOfSignature();\n        }\n        if (_depositSignature.length != SIGNATURE_LENGTH) {\n            revert InvalidLengthOfSignature();\n        }\n        if (isExistingPubkey(_pubkey)) {\n            revert PubkeyAlreadyExist();\n        }\n    }\n\n    //compute the share of rewards between user, protocol and operator\n    function calculateRewardShare(uint8 _poolId, uint256 _totalRewards)\n        external\n        view\n        override\n        returns (\n            uint256 userShare,\n            uint256 operatorShare,\n            uint256 protocolShare\n        )\n    {\n        uint256 TOTAL_STAKED_ETH = staderConfig.getStakedEthPerNode();\n        uint256 collateralETH = getCollateralETH(_poolId);\n        uint256 usersETH = TOTAL_STAKED_ETH - collateralETH;\n        uint256 protocolFeeBps = getProtocolFee(_poolId);\n        uint256 operatorFeeBps = getOperatorFee(_poolId);\n\n        uint256 _userShareBeforeCommision = (_totalRewards * usersETH) / TOTAL_STAKED_ETH;\n\n        protocolShare = (protocolFeeBps * _userShareBeforeCommision) / staderConfig.getTotalFee();\n\n        operatorShare = (_totalRewards * collateralETH) / TOTAL_STAKED_ETH;\n        operatorShare += (operatorFeeBps * _userShareBeforeCommision) / staderConfig.getTotalFee();\n\n        userShare = _totalRewards - protocolShare - operatorShare;\n    }\n\n    function isExistingPoolId(uint8 _poolId) public view override returns (bool) {\n        uint256 poolCount = getPoolCount();\n        for (uint256 i = 0; i < poolCount; i++) {\n            if (poolIdArray[i] == _poolId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function verifyNewPool(uint8 _poolId, address _poolAddress) internal view {\n        if (\n            INodeRegistry(IStaderPoolBase(_poolAddress).getNodeRegistry()).POOL_ID() != _poolId ||\n            isExistingPoolId(_poolId)\n        ) {\n            revert ExistingOrMismatchingPoolId();\n        }\n    }\n\n    function getPoolCount() internal view returns (uint256) {\n        return poolIdArray.length;\n    }\n\n    // Modifiers\n    modifier onlyExistingPoolId(uint8 _poolId) {\n        if (!isExistingPoolId(_poolId)) {\n            revert PoolIdNotPresent();\n        }\n        _;\n    }\n}"
    }
  ]
}