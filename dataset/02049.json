{
  "Title": "M-3: Controller doesn't send treasury funds to the vault's treasury address",
  "Content": "# Issue M-3: Controller doesn't send treasury funds to the vault's treasury address \n\nSource: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/110 \n\n## Found by \nDug, Ruhum, bin2chen, nobody2018, roguereddwarf\n\n## Summary\nThe Controller contract sends treasury funds to its own immutable `treasury` address instead of sending the funds to the one stored in the respective vault contract.\n\n## Vulnerability Detail\nEach vault has a treasury address that is assigned on deployment which can also be updated through the factory contract:\n```sol\n    constructor(\n        // ...\n        address _treasury\n    ) SemiFungibleVault(IERC20(_assetAddress), _name, _symbol, _tokenURI) {\n        // ...\n        treasury = _treasury;\n        whitelistedAddresses[_treasury] = true;\n    }\n\n    function setTreasury(address _treasury) public onlyFactory {\n        if (_treasury == address(0)) revert AddressZero();\n        treasury = _treasury;\n    }\n```\n\nBut, the Controller, responsible for sending the fees to the treasury, uses the immutable treasury address that it was initialized with:\n```sol\n    constructor(\n        // ...\n        address _treasury\n    ) {\n        // ...\n        treasury = _treasury;\n    }\n\n    // @audit just one example. Search for `treasury` in the Controller contract to find the others\n    function triggerEndEpoch(uint256 _marketId, uint256 _epochId) public {\n        // ...\n        \n        // send premium fees to treasury and remaining TVL to collateral vault\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        // strike price reached so collateral is entitled to collateralTVLAfterFee\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVLAfterFee,\n            address(collateralVault)\n        );\n\n        // ...\n    }\n```\n\n## Impact\nIt's not possible to have different treasury addresses for different vaults. It's also not possible to update the treasury address of a vault although it has a function to do that. Funds will always be sent to the address the Controller was initialized with.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/VaultV2.sol#L79\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/VaultV2.sol#L265-L268\n\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L186\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L40\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe Controller should query the Vault to get the correct treasury address, e.g.:\n\n```sol\ncollateralVault.sendTokens(_epochId, collateralFee, collateralVault.treasury());\n```\n\n\n\n## Discussion\n\n**3xHarry**\n\nwill use one location for the treasury address which will be on the factory. \n\n**3xHarry**\n\nfixed in https://github.com/Y2K-Finance/Earthquake/pull/137\n\n**IAm0x52**\n\nNeeds additional changes. Controller still sends to it's immutable address and not treasury address on factory\n\n**IAm0x52**\n\nFix looks good. Controller has been updated to use treasury address from factory\n\n**jacksanford1**\n\nNote: 0x52 is referring to this specific commit in the last message:\n\nhttps://github.com/Y2K-Finance/Earthquake/pull/137/commits/272199687465252d1da8cb1af624e90c12315953\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/57",
  "Code": [
    {
      "filename": "Earthquake/src/v2/VaultV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./SemiFungibleVault.sol\";\nimport {IVaultV2} from \"./interfaces/IVaultV2.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract VaultV2 is IVaultV2, SemiFungibleVault, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    // Earthquake parameters\n    address public immutable token;\n    uint256 public immutable strike;\n    // Earthquake bussiness logic\n    bool public immutable isWETH;\n    address public treasury;\n    address public counterPartyVault;\n    address public factory;\n    address public controller;\n    uint256[] public epochs;\n\n    mapping(uint256 => uint256) public finalTVL;\n    mapping(uint256 => uint256) public claimTVL;\n    mapping(uint256 => uint256) public epochAccounting;\n    mapping(uint256 => EpochConfig) public epochConfig;\n    mapping(uint256 => bool) public epochResolved;\n    mapping(uint256 => bool) public epochExists;\n    mapping(uint256 => bool) public epochNull;\n    mapping(address => bool) public whitelistedAddresses;\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice constructor\n        @param _assetAddress  address of the asset that will be used as collateral;\n        @param _name  string representing the name of the vault;\n        @param _symbol  string representing the symbol of the vault;\n        @param _tokenURI  string representing the tokenURI of the vault;\n        @param _token  address of the token that will be used as collateral;\n        @param _strike  uint256 representing the strike price of the vault;\n        @param _controller  address of the controller of the vault;\n        @param _treasury  address of the treasury of the vault;\n     */\n    constructor(\n        bool _isWETH,\n        address _assetAddress,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        address _token,\n        uint256 _strike,\n        address _controller,\n        address _treasury\n    ) SemiFungibleVault(IERC20(_assetAddress), _name, _symbol, _tokenURI) {\n        if (_controller == address(0)) revert AddressZero();\n        if (_token == address(0)) revert AddressZero();\n        if (_assetAddress == address(0)) revert AddressZero();\n        if (_treasury == address(0)) revert AddressZero();\n        token = _token;\n        strike = _strike;\n        factory = msg.sender;\n        controller = _controller;\n        treasury = _treasury;\n        whitelistedAddresses[_treasury] = true;\n        isWETH = _isWETH;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @param  _id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param  _assets  uint256 representing how many assets the user wants to deposit, a fee will be taken from this value;\n        @param _receiver  address of the receiver of the assets provided by this function, that represent the ownership of the deposited asset;\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver\n    )\n        public\n        virtual\n        override(SemiFungibleVault)\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        nonReentrant\n    {\n        if (_receiver == address(0)) revert AddressZero();\n        SemiFungibleVault.asset.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _assets\n        );\n\n        _mint(_receiver, _id, _assets, EMPTY);\n\n        emit Deposit(msg.sender, _receiver, _id, _assets);\n    }\n\n    /**\n        @notice Deposit ETH function\n        @param  _id  uint256 representing the id of the epoch;\n        @param _receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n     */\n    function depositETH(uint256 _id, address _receiver)\n        external\n        payable\n        virtual\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        nonReentrant\n    {\n        if (!isWETH) revert CanNotDepositETH();\n        require(msg.value > 0, \"ZeroValue\");\n        if (_receiver == address(0)) revert AddressZero();\n\n        IWETH(address(asset)).deposit{value: msg.value}();\n        _mint(_receiver, _id, msg.value, EMPTY);\n\n        emit Deposit(msg.sender, _receiver, _id, msg.value);\n    }\n\n    /**\n    @notice Withdraw entitled deposited assets, checking if a depeg event\n    @param  _id uint256 identifier of the epoch you want to withdraw from;\n    @param _assets   uint256 of how many assets you want to withdraw, this value will be used to calculate how many assets you are entitle to according the vaults claimTVL;\n    @param _receiver  Address of the receiver of the assets provided by this function, that represent the ownership of the transfered asset;\n    @param _owner    Address of the owner of these said assets;\n    @return shares How many shares the owner is entitled to, according to the conditions;\n     */\n    function withdraw(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver,\n        address _owner\n    )\n        external\n        virtual\n        override(SemiFungibleVault)\n        epochIdExists(_id)\n        epochHasEnded(_id)\n        nonReentrant\n        returns (uint256 shares)\n    {\n        if (_receiver == address(0)) revert AddressZero();\n\n        if (\n            msg.sender != _owner &&\n            isApprovedForAll(_owner, msg.sender) == false\n        ) revert OwnerDidNotAuthorize(msg.sender, _owner);\n\n        _burn(_owner, _id, _assets);\n\n        uint256 entitledShares;\n\n        if (epochNull[_id] == false) {\n            entitledShares = previewWithdraw(_id, _assets);\n        } else {\n            entitledShares = _assets;\n        }\n        if (entitledShares > 0) {\n            SemiFungibleVault.asset.safeTransfer(_receiver, entitledShares);\n        }\n\n        emit Withdraw(\n            msg.sender,\n            _receiver,\n            _owner,\n            _id,\n            _assets,\n            entitledShares\n        );\n\n        return entitledShares;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice returns total assets for the id of given epoch\n        @param  _id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n     */\n    function totalAssets(uint256 _id)\n        public\n        view\n        override(SemiFungibleVault, IVaultV2)\n        returns (uint256)\n    {\n        // epochIdExists(_id)\n        return totalSupply(_id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           FACTORY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function to set the epoch, only the factory can call this function\n    @param  _epochBegin uint40 in UNIX timestamp, representing the begin date of the epoch\n    @param  _epochEnd uint40 in UNIX timestamp, representing the end date of the epoch\n    @param  _epochId uint256 id representing the epoch\n     */\n    function setEpoch(\n        uint40 _epochBegin,\n        uint40 _epochEnd,\n        uint256 _epochId\n    ) external onlyFactory {\n        if (_epochId == 0 || _epochBegin == 0 || _epochEnd == 0)\n            revert InvalidEpoch();\n        if (epochExists[_epochId] == true) revert EpochAlreadyExists();\n\n        if (_epochBegin >= _epochEnd) revert EpochEndMustBeAfterBegin();\n\n        epochExists[_epochId] = true;\n\n        epochConfig[_epochId] = EpochConfig({\n            epochBegin: _epochBegin,\n            epochEnd: _epochEnd,\n            epochCreation: uint40(block.timestamp)\n        });\n        epochs.push(_epochId);\n    }\n\n    /**\n    @notice Factory function, changes controller address\n    @param _controller New controller address\n     */\n    function changeController(address _controller) public onlyFactory {\n        if (_controller == address(0)) revert AddressZero();\n        controller = _controller;\n    }\n\n    /**\n    @notice Factory function, whitelist address\n    @param _wAddress New treasury address\n     */\n    function whiteListAddress(address _wAddress) public onlyFactory {\n        if (_wAddress == address(0)) revert AddressZero();\n        whitelistedAddresses[_wAddress] = !whitelistedAddresses[_wAddress];\n    }\n\n    /**\n    @notice Factory function, changes treasury address\n    @param _treasury New treasury address\n     */\n    function setTreasury(address _treasury) public onlyFactory {\n        if (_treasury == address(0)) revert AddressZero();\n        treasury = _treasury;\n    }\n\n    /**\n    @notice Factory function, changes _counterPartyVault address\n    @param _counterPartyVault New _counterPartyVault address\n     */\n    function setCounterPartyVault(address _counterPartyVault)\n        external\n        onlyFactory\n    {\n        if (_counterPartyVault == address(0)) revert AddressZero();\n        counterPartyVault = _counterPartyVault;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         CONTROLLER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Controller can call this function to resolve the epoch, this function will set the epoch as ended and store the deposited TVL of the epoch\n    @param  _id identifier of the epoch\n     */\n    function resolveEpoch(uint256 _id)\n        external\n        onlyController\n        epochIdExists(_id)\n        epochHasStarted(_id)\n    {\n        if (epochResolved[_id]) revert EpochAlreadyEnded();\n        epochResolved[_id] = true;\n        finalTVL[_id] = totalAssets(_id);\n    }\n\n    /**\n    solhint-disable-next-line max-line-length\n    @notice Controller can call after the epoch has ended, this function allows the transfer of tokens to the counterparty vault or treasury. Controller is trusted to do correct accounting. \n    @param  _id uint256 identifier of the epoch\n    @param _amount amount that is send to destination\n    @param _receiver address of counterparty vault or treasury\n    */\n    function sendTokens(\n        uint256 _id,\n        uint256 _amount,\n        address _receiver\n    ) external onlyController epochIdExists(_id) epochHasEnded(_id) {\n        if (_amount > finalTVL[_id]) revert AmountExceedsTVL();\n        if (epochAccounting[_id] + _amount > finalTVL[_id])\n            revert AmountExceedsTVL();\n        if (!whitelistedAddresses[_receiver] && _receiver != counterPartyVault)\n            revert DestinationNotAuthorized(_receiver);\n        epochAccounting[_id] += _amount;\n        SemiFungibleVault.asset.safeTransfer(_receiver, _amount);\n    }\n\n    /**\n    @notice Controller can call after the epoch has ended, this function stores the value that the holders of the epoch are entiteld to. The value is determined on the controller side\n    @param  _id uint256 identifier of the epoch\n    @param _claimTVL uint256 representing the TVL the vault has, storing this value in a mapping\n     */\n    function setClaimTVL(uint256 _id, uint256 _claimTVL)\n        external\n        onlyController\n        epochIdExists(_id)\n        epochHasEnded(_id)\n    {\n        claimTVL[_id] = _claimTVL;\n    }\n\n    /**\n    @notice This function is called by the controller if the epoch has started, but the counterparty vault has no value. In this case the users can withdraw their deposit.\n    @param  _id uint256 identifier of the epoch\n     */\n    function setEpochNull(uint256 _id)\n        public\n        onlyController\n        epochIdExists(_id)\n        epochHasEnded(_id)\n    {\n        epochNull[_id] = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         LOOKUP FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n        @notice Shows assets conversion output from withdrawing assets\n        @param  _id uint256 epoch identifier\n        @param _assets amount of user shares to withdraw\n     */\n    function previewWithdraw(uint256 _id, uint256 _assets)\n        public\n        view\n        override(SemiFungibleVault)\n        returns (uint256 entitledAmount)\n    {\n        // entitledAmount amount is derived from the claimTVL and the finalTVL\n        // if user deposited 1000 assets and the claimTVL is 50% lower than finalTVL, the user is entitled to 500 assets\n        // if user deposited 1000 assets and the claimTVL is 50% higher than finalTVL, the user is entitled to 1500 assets\n        entitledAmount = _assets.mulDivDown(claimTVL[_id], finalTVL[_id]);\n    }\n\n    /** @notice Lookup total epochs length\n     */\n    function getEpochsLength() public view returns (uint256) {\n        return epochs.length;\n    }\n\n    /** @notice Lookup all set epochs\n     */\n    function getAllEpochs() public view returns (uint256[] memory) {\n        return epochs;\n    }\n\n    /** @notice Lookup epoch begin and end\n        @param _id id hashed from marketIndex, epoch begin and end and casted to uint256;\n     */\n    function getEpochConfig(uint256 _id)\n        public\n        view\n        returns (\n            uint40 epochBegin,\n            uint40 epochEnd,\n            uint40 epochCreation\n        )\n    {\n        epochBegin = epochConfig[_id].epochBegin;\n        epochEnd = epochConfig[_id].epochEnd;\n        epochCreation = epochConfig[_id].epochCreation;\n    }\n\n    function _asset() internal view returns (IERC20) {\n        return asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    struct EpochConfig {\n        uint40 epochBegin;\n        uint40 epochEnd;\n        uint40 epochCreation;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only factory addresses can call functions that use this modifier\n     */\n    modifier onlyFactory() {\n        if (msg.sender != factory) revert AddressNotFactory(msg.sender);\n        _;\n    }\n\n    /** @notice Only controller addresses can call functions that use this modifier\n     */\n    modifier onlyController() {\n        if (msg.sender != controller) revert AddressNotController(msg.sender);\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier before the epoch has started\n     */\n    modifier epochHasNotStarted(uint256 _id) {\n        if (block.timestamp > epochConfig[_id].epochBegin)\n            revert EpochAlreadyStarted();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier after the epoch has started\n     */\n    modifier epochHasStarted(uint256 _id) {\n        if (block.timestamp < epochConfig[_id].epochBegin)\n            revert EpochNotStarted();\n        _;\n    }\n\n    /** @notice Check if epoch exists\n     */\n    modifier epochIdExists(uint256 id) {\n        if (!epochExists[id]) revert EpochDoesNotExist();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier after the epoch has ended\n     */\n    modifier epochHasEnded(uint256 id) {\n        if (!epochResolved[id]) revert EpochNotResolved();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error AddressZero();\n    error AddressNotFactory(address _contract);\n    error AddressNotController(address _contract);\n    error EpochDoesNotExist();\n    error EpochAlreadyStarted();\n    error EpochNotResolved();\n    error EpochAlreadyEnded();\n    error EpochNotStarted();\n    error ZeroValue();\n    error OwnerDidNotAuthorize(address _sender, address _owner);\n    error EpochEndMustBeAfterBegin();\n    error EpochAlreadyExists();\n    error DestinationNotAuthorized(address _counterparty);\n    error AmountExceedsTVL();\n    error AlreadyInitialized();\n    error InvalidEpoch();\n    error CanNotDepositETH();\n}"
    },
    {
      "filename": "Earthquake/src/v2/VaultV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./SemiFungibleVault.sol\";\nimport {IVaultV2} from \"./interfaces/IVaultV2.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract VaultV2 is IVaultV2, SemiFungibleVault, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    // Earthquake parameters\n    address public immutable token;\n    uint256 public immutable strike;\n    // Earthquake bussiness logic\n    bool public immutable isWETH;\n    address public treasury;\n    address public counterPartyVault;\n    address public factory;\n    address public controller;\n    uint256[] public epochs;\n\n    mapping(uint256 => uint256) public finalTVL;\n    mapping(uint256 => uint256) public claimTVL;\n    mapping(uint256 => uint256) public epochAccounting;\n    mapping(uint256 => EpochConfig) public epochConfig;\n    mapping(uint256 => bool) public epochResolved;\n    mapping(uint256 => bool) public epochExists;\n    mapping(uint256 => bool) public epochNull;\n    mapping(address => bool) public whitelistedAddresses;\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice constructor\n        @param _assetAddress  address of the asset that will be used as collateral;\n        @param _name  string representing the name of the vault;\n        @param _symbol  string representing the symbol of the vault;\n        @param _tokenURI  string representing the tokenURI of the vault;\n        @param _token  address of the token that will be used as collateral;\n        @param _strike  uint256 representing the strike price of the vault;\n        @param _controller  address of the controller of the vault;\n        @param _treasury  address of the treasury of the vault;\n     */\n    constructor(\n        bool _isWETH,\n        address _assetAddress,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        address _token,\n        uint256 _strike,\n        address _controller,\n        address _treasury\n    ) SemiFungibleVault(IERC20(_assetAddress), _name, _symbol, _tokenURI) {\n        if (_controller == address(0)) revert AddressZero();\n        if (_token == address(0)) revert AddressZero();\n        if (_assetAddress == address(0)) revert AddressZero();\n        if (_treasury == address(0)) revert AddressZero();\n        token = _token;\n        strike = _strike;\n        factory = msg.sender;\n        controller = _controller;\n        treasury = _treasury;\n        whitelistedAddresses[_treasury] = true;\n        isWETH = _isWETH;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @param  _id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param  _assets  uint256 representing how many assets the user wants to deposit, a fee will be taken from this value;\n        @param _receiver  address of the receiver of the assets provided by this function, that represent the ownership of the deposited asset;\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver\n    )\n        public\n        virtual\n        override(SemiFungibleVault)\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        nonReentrant\n    {\n        if (_receiver == address(0)) revert AddressZero();\n        SemiFungibleVault.asset.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _assets\n        );\n\n        _mint(_receiver, _id, _assets, EMPTY);\n\n        emit Deposit(msg.sender, _receiver, _id, _assets);\n    }\n\n    /**\n        @notice Deposit ETH function\n        @param  _id  uint256 representing the id of the epoch;\n        @param _receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n     */\n    function depositETH(uint256 _id, address _receiver)\n        external\n        payable\n        virtual\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        nonReentrant\n    {\n        if (!isWETH) revert CanNotDepositETH();\n        require(msg.value > 0, \"ZeroValue\");\n        if (_receiver == address(0)) revert AddressZero();\n\n        IWETH(address(asset)).deposit{value: msg.value}();\n        _mint(_receiver, _id, msg.value, EMPTY);\n\n        emit Deposit(msg.sender, _receiver, _id, msg.value);\n    }\n\n    /**\n    @notice Withdraw entitled deposited assets, checking if a depeg event\n    @param  _id uint256 identifier of the epoch you want to withdraw from;\n    @param _assets   uint256 of how many assets you want to withdraw, this value will be used to calculate how many assets you are entitle to according the vaults claimTVL;\n    @param _receiver  Address of the receiver of the assets provided by this function, that represent the ownership of the transfered asset;\n    @param _owner    Address of the owner of these said assets;\n    @return shares How many shares the owner is entitled to, according to the conditions;\n     */\n    function withdraw(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver,\n        address _owner\n    )\n        external\n        virtual\n        override(SemiFungibleVault)\n        epochIdExists(_id)\n        epochHasEnded(_id)\n        nonReentrant\n        returns (uint256 shares)\n    {\n        if (_receiver == address(0)) revert AddressZero();\n\n        if (\n            msg.sender != _owner &&\n            isApprovedForAll(_owner, msg.sender) == false\n        ) revert OwnerDidNotAuthorize(msg.sender, _owner);\n\n        _burn(_owner, _id, _assets);\n\n        uint256 entitledShares;\n\n        if (epochNull[_id] == false) {\n            entitledShares = previewWithdraw(_id, _assets);\n        } else {\n            entitledShares = _assets;\n        }\n        if (entitledShares > 0) {\n            SemiFungibleVault.asset.safeTransfer(_receiver, entitledShares);\n        }\n\n        emit Withdraw(\n            msg.sender,\n            _receiver,\n            _owner,\n            _id,\n            _assets,\n            entitledShares\n        );\n\n        return entitledShares;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice returns total assets for the id of given epoch\n        @param  _id uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n     */\n    function totalAssets(uint256 _id)\n        public\n        view\n        override(SemiFungibleVault, IVaultV2)\n        returns (uint256)\n    {\n        // epochIdExists(_id)\n        return totalSupply(_id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           FACTORY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function to set the epoch, only the factory can call this function\n    @param  _epochBegin uint40 in UNIX timestamp, representing the begin date of the epoch\n    @param  _epochEnd uint40 in UNIX timestamp, representing the end date of the epoch\n    @param  _epochId uint256 id representing the epoch\n     */\n    function setEpoch(\n        uint40 _epochBegin,\n        uint40 _epochEnd,\n        uint256 _epochId\n    ) external onlyFactory {\n        if (_epochId == 0 || _epochBegin == 0 || _epochEnd == 0)\n            revert InvalidEpoch();\n        if (epochExists[_epochId] == true) revert EpochAlreadyExists();\n\n        if (_epochBegin >= _epochEnd) revert EpochEndMustBeAfterBegin();\n\n        epochExists[_epochId] = true;\n\n        epochConfig[_epochId] = EpochConfig({\n            epochBegin: _epochBegin,\n            epochEnd: _epochEnd,\n            epochCreation: uint40(block.timestamp)\n        });\n        epochs.push(_epochId);\n    }\n\n    /**\n    @notice Factory function, changes controller address\n    @param _controller New controller address\n     */\n    function changeController(address _controller) public onlyFactory {\n        if (_controller == address(0)) revert AddressZero();\n        controller = _controller;\n    }\n\n    /**\n    @notice Factory function, whitelist address\n    @param _wAddress New treasury address\n     */\n    function whiteListAddress(address _wAddress) public onlyFactory {\n        if (_wAddress == address(0)) revert AddressZero();\n        whitelistedAddresses[_wAddress] = !whitelistedAddresses[_wAddress];\n    }\n\n    /**\n    @notice Factory function, changes treasury address\n    @param _treasury New treasury address\n     */\n    function setTreasury(address _treasury) public onlyFactory {\n        if (_treasury == address(0)) revert AddressZero();\n        treasury = _treasury;\n    }\n\n    /**\n    @notice Factory function, changes _counterPartyVault address\n    @param _counterPartyVault New _counterPartyVault address\n     */\n    function setCounterPartyVault(address _counterPartyVault)\n        external\n        onlyFactory\n    {\n        if (_counterPartyVault == address(0)) revert AddressZero();\n        counterPartyVault = _counterPartyVault;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         CONTROLLER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Controller can call this function to resolve the epoch, this function will set the epoch as ended and store the deposited TVL of the epoch\n    @param  _id identifier of the epoch\n     */\n    function resolveEpoch(uint256 _id)\n        external\n        onlyController\n        epochIdExists(_id)\n        epochHasStarted(_id)\n    {\n        if (epochResolved[_id]) revert EpochAlreadyEnded();\n        epochResolved[_id] = true;\n        finalTVL[_id] = totalAssets(_id);\n    }\n\n    /**\n    solhint-disable-next-line max-line-length\n    @notice Controller can call after the epoch has ended, this function allows the transfer of tokens to the counterparty vault or treasury. Controller is trusted to do correct accounting. \n    @param  _id uint256 identifier of the epoch\n    @param _amount amount that is send to destination\n    @param _receiver address of counterparty vault or treasury\n    */\n    function sendTokens(\n        uint256 _id,\n        uint256 _amount,\n        address _receiver\n    ) external onlyController epochIdExists(_id) epochHasEnded(_id) {\n        if (_amount > finalTVL[_id]) revert AmountExceedsTVL();\n        if (epochAccounting[_id] + _amount > finalTVL[_id])\n            revert AmountExceedsTVL();\n        if (!whitelistedAddresses[_receiver] && _receiver != counterPartyVault)\n            revert DestinationNotAuthorized(_receiver);\n        epochAccounting[_id] += _amount;\n        SemiFungibleVault.asset.safeTransfer(_receiver, _amount);\n    }\n\n    /**\n    @notice Controller can call after the epoch has ended, this function stores the value that the holders of the epoch are entiteld to. The value is determined on the controller side\n    @param  _id uint256 identifier of the epoch\n    @param _claimTVL uint256 representing the TVL the vault has, storing this value in a mapping\n     */\n    function setClaimTVL(uint256 _id, uint256 _claimTVL)\n        external\n        onlyController\n        epochIdExists(_id)\n        epochHasEnded(_id)\n    {\n        claimTVL[_id] = _claimTVL;\n    }\n\n    /**\n    @notice This function is called by the controller if the epoch has started, but the counterparty vault has no value. In this case the users can withdraw their deposit.\n    @param  _id uint256 identifier of the epoch\n     */\n    function setEpochNull(uint256 _id)\n        public\n        onlyController\n        epochIdExists(_id)\n        epochHasEnded(_id)\n    {\n        epochNull[_id] = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         LOOKUP FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n        @notice Shows assets conversion output from withdrawing assets\n        @param  _id uint256 epoch identifier\n        @param _assets amount of user shares to withdraw\n     */\n    function previewWithdraw(uint256 _id, uint256 _assets)\n        public\n        view\n        override(SemiFungibleVault)\n        returns (uint256 entitledAmount)\n    {\n        // entitledAmount amount is derived from the claimTVL and the finalTVL\n        // if user deposited 1000 assets and the claimTVL is 50% lower than finalTVL, the user is entitled to 500 assets\n        // if user deposited 1000 assets and the claimTVL is 50% higher than finalTVL, the user is entitled to 1500 assets\n        entitledAmount = _assets.mulDivDown(claimTVL[_id], finalTVL[_id]);\n    }\n\n    /** @notice Lookup total epochs length\n     */\n    function getEpochsLength() public view returns (uint256) {\n        return epochs.length;\n    }\n\n    /** @notice Lookup all set epochs\n     */\n    function getAllEpochs() public view returns (uint256[] memory) {\n        return epochs;\n    }\n\n    /** @notice Lookup epoch begin and end\n        @param _id id hashed from marketIndex, epoch begin and end and casted to uint256;\n     */\n    function getEpochConfig(uint256 _id)\n        public\n        view\n        returns (\n            uint40 epochBegin,\n            uint40 epochEnd,\n            uint40 epochCreation\n        )\n    {\n        epochBegin = epochConfig[_id].epochBegin;\n        epochEnd = epochConfig[_id].epochEnd;\n        epochCreation = epochConfig[_id].epochCreation;\n    }\n\n    function _asset() internal view returns (IERC20) {\n        return asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    struct EpochConfig {\n        uint40 epochBegin;\n        uint40 epochEnd;\n        uint40 epochCreation;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only factory addresses can call functions that use this modifier\n     */\n    modifier onlyFactory() {\n        if (msg.sender != factory) revert AddressNotFactory(msg.sender);\n        _;\n    }\n\n    /** @notice Only controller addresses can call functions that use this modifier\n     */\n    modifier onlyController() {\n        if (msg.sender != controller) revert AddressNotController(msg.sender);\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier before the epoch has started\n     */\n    modifier epochHasNotStarted(uint256 _id) {\n        if (block.timestamp > epochConfig[_id].epochBegin)\n            revert EpochAlreadyStarted();\n        _;\n    }\n\n    /** @notice You can only call functions that use this modifier after the epoch has"
    }
  ]
}