{
  "Title": "M-6: `computePoolAddress()` will not work on ZkSync Era",
  "Content": "# Issue M-6: `computePoolAddress()` will not work on ZkSync Era \n\nSource: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/104 \n\n## Found by \n0x52, HHK, shogoki\n\nWhen using the wagmi protocol, multiple swap can happen when borrowing or repaying a position. When the swap uses Uniswap v3 it checks that the callback is a pool by computing the address but the computation won't match on ZkSync Era.\n\n## Vulnerability Detail\n\nWhen borrowing or repaying a position a user can either use a custom router that was approved by the wagmi team to make the swaps required or can use Uniswap v3 as a fallback.\n\nWhen using the Uniswap v3 as a fallback the [`_v3SwapExactInput()`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/abstract/ApproveSwapAndPay.sol#L204) internal function is being called. This function uses [`computePoolAddress()`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/abstract/ApproveSwapAndPay.sol#L271) to find the pool address to use. [`computePoolAddress()`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/abstract/ApproveSwapAndPay.sol#L271) is also used during the [`uniswapV3SwapCallback()`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/abstract/ApproveSwapAndPay.sol#L242) to make sure the `msg.sender` is a valid pool.\n\nOn ZkSync Era the `create2` addresses are not computed the same way see [here](https://era.zksync.io/docs/reference/architecture/differences-with-ethereum.html#address-derivation).\n\nThis will result in the swaps on Uniswapv3 to revert. If a user was able to open a position using a custom router but the custom router is removed later on by the team or if the liquidity was one sided so no swap happened. The borrower and liquidators could find themself not able to close the positions until a new router is whitelisted.\n\nThe borrower could be forced to pay collateral for a longer time as he won't be able to close his position.\n\n## Impact\n\nMedium. Unlikely to happen but would result in short-term DOS and more fees paid by the borrower.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/abstract/ApproveSwapAndPay.sol#L146\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/abstract/ApproveSwapAndPay.sol#L204\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/abstract/ApproveSwapAndPay.sol#L271\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider calling the Uniswap factory getter `getPool()` to get the address of the pool.\n\n\n\n## Discussion\n\n**fann95**\n\nThis is too obvious a problem with which this project simply will not work. We know about this, so we will make changes before deployment in ZkSync Era.\n\n**Czar102**\n\nAs the contest readme states, watsons were to consider zkSync as one of the chains the code in scope was to be deployed on. If watsons couldn't have known that a modification of the code in scope would be deployed on zkSync, I don't see a reason to invalidate this issue, even if it was previously considered by the protocol team and/or is trivial.\n\n**fann95**\n\nI’m pasting the solution for Sherlock, but we don’t plan to make any fixes to this issue right now.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/118",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/abstract/ApproveSwapAndPay.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { SafeCast } from \"@uniswap/v3-core/contracts/libraries/SafeCast.sol\";\nimport \"../libraries/ExternalCall.sol\";\nimport \"../libraries/ErrLib.sol\";\n\nabstract contract ApproveSwapAndPay {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using { ExternalCall._patchAmountAndCall } for address;\n    using { ExternalCall._readFirstBytes4 } for bytes;\n    using { ErrLib.revertError } for bool;\n\n    /// @notice Struct representing the parameters for a Uniswap V3 exact input swap.\n    struct v3SwapExactInputParams {\n        /// @dev The fee tier to be used for the swap.\n        uint24 fee;\n        /// @dev The address of the token to be swapped from.\n        address tokenIn;\n        /// @dev The address of the token to be swapped to.\n        address tokenOut;\n        /// @dev The amount of `tokenIn` to be swapped.\n        uint256 amountIn;\n        /// @dev The minimum amount of `tokenOut` expected to receive from the swap.\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Struct to hold parameters for swapping tokens\n    struct SwapParams {\n        /// @notice Address of the aggregator's router\n        address swapTarget;\n        /// @notice The index in the `swapData` array where the swap amount in is stored\n        uint256 swapAmountInDataIndex;\n        /// @notice The maximum gas limit for the swap call\n        uint256 maxGasForCall;\n        /// @notice The aggregator's data that stores paths and amounts for swapping through\n        bytes swapData;\n    }\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    address public immutable UNDERLYING_V3_FACTORY_ADDRESS;\n    bytes32 public immutable UNDERLYING_V3_POOL_INIT_CODE_HASH;\n\n    ///     swapTarget   => (func.selector => is allowed)\n    mapping(address => mapping(bytes4 => bool)) public whitelistedCall;\n\n    error SwapSlippageCheckError(uint256 expectedOut, uint256 receivedOut);\n\n    constructor(\n        address _UNDERLYING_V3_FACTORY_ADDRESS,\n        bytes32 _UNDERLYING_V3_POOL_INIT_CODE_HASH\n    ) {\n        UNDERLYING_V3_FACTORY_ADDRESS = _UNDERLYING_V3_FACTORY_ADDRESS;\n        UNDERLYING_V3_POOL_INIT_CODE_HASH = _UNDERLYING_V3_POOL_INIT_CODE_HASH;\n    }\n\n    /**\n     * @dev This internal function attempts to approve a specific amount of tokens for a spender.\n     * It performs a call to the `approve` function on the token contract using the provided parameters,\n     * and returns a boolean indicating whether the approval was successful or not.\n     * @param token The address of the token contract.\n     * @param spender The address of the spender.\n     * @param amount The amount of tokens to be approved.\n     * @return A boolean indicating whether the approval was successful or not.\n     */\n    function _tryApprove(address token, address spender, uint256 amount) private returns (bool) {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, spender, amount)\n        );\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n\n    /**\n     * @dev This internal function ensures that the allowance for a spender is at least the specified amount.\n     * If the current allowance is less than the specified amount, it attempts to approve the maximum possible value,\n     * and if that fails, it retries with the maximum possible value minus one. If both attempts fail,\n     * it reverts with an error indicating that the approval did not succeed.\n     * @param token The address of the token contract.\n     * @param spender The address of the spender.\n     * @param amount The minimum required allowance.\n     */\n    function _maxApproveIfNecessary(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) < amount) {\n            if (!_tryApprove(token, spender, type(uint256).max)) {\n                if (!_tryApprove(token, spender, type(uint256).max - 1)) {\n                    require(_tryApprove(token, spender, 0));\n                    if (!_tryApprove(token, spender, type(uint256).max)) {\n                        if (!_tryApprove(token, spender, type(uint256).max - 1)) {\n                            true.revertError(ErrLib.ErrorCode.ERC20_APPROVE_DID_NOT_SUCCEED);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev This internal view function retrieves the balance of the contract for a specific token.\n     * It performs a staticcall to the `balanceOf` function on the token contract using the provided parameter,\n     * and returns the balance as a uint256 value.\n     * @param token The address of the token contract.\n     * @return balance The balance of the contract for the specified token.\n     */\n    function _getBalance(address token) internal view returns (uint256 balance) {\n        bytes memory callData = abi.encodeWithSelector(IERC20.balanceOf.selector, address(this));\n        (bool success, bytes memory data) = token.staticcall(callData);\n        require(success && data.length >= 32);\n        balance = abi.decode(data, (uint256));\n    }\n\n    /**\n     * @dev Retrieves the balance of two tokens in the contract.\n     * @param tokenA The address of the first token.\n     * @param tokenB The address of the second token.\n     * @return balanceA The balance of the first token in the contract.\n     * @return balanceB The balance of the second token in the contract.\n     */\n    function _getPairBalance(\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 balanceA, uint256 balanceB) {\n        balanceA = _getBalance(tokenA);\n        balanceB = _getBalance(tokenB);\n    }\n\n    /**\n     * @dev Executes a swap between two tokens using an external contract.\n     * @param tokenIn The address of the token to be swapped.\n     * @param tokenOut The address of the token to receive in the swap.\n     * @param externalSwap The swap parameters from the external contract.\n     * @param amountIn The amount of `tokenIn` to be swapped.\n     * @param amountOutMin The minimum amount of `tokenOut` expected to receive from the swap.\n     * @return amountOut The actual amount of `tokenOut` received from the swap.\n     * @notice This function will revert if the swap target is not approved or the resulting amountOut\n     * is zero or below the specified minimum amountOut.\n     */\n    function _patchAmountsAndCallSwap(\n        address tokenIn,\n        address tokenOut,\n        SwapParams calldata externalSwap,\n        uint256 amountIn,\n        uint256 amountOutMin\n    ) internal returns (uint256 amountOut) {\n        bytes4 funcSelector = externalSwap.swapData._readFirstBytes4();\n        // Verifying if the swap target is whitelisted for the specified function selector\n        (!whitelistedCall[externalSwap.swapTarget][funcSelector]).revertError(\n            ErrLib.ErrorCode.SWAP_TARGET_NOT_APPROVED\n        );\n        // Maximizing approval if necessary\n        _maxApproveIfNecessary(tokenIn, externalSwap.swapTarget, amountIn);\n        uint256 balanceOutBefore = _getBalance(tokenOut);\n        // Patching the amount and calling the external swap\n        externalSwap.swapTarget._patchAmountAndCall(\n            externalSwap.swapData,\n            externalSwap.maxGasForCall,\n            externalSwap.swapAmountInDataIndex,\n            amountIn\n        );\n        // Calculating the actual amount of output tokens received\n        amountOut = _getBalance(tokenOut) - balanceOutBefore;\n        // Checking if the received amount satisfies the minimum requirement\n        if (amountOut == 0 || amountOut < amountOutMin) {\n            revert SwapSlippageCheckError(amountOutMin, amountOut);\n        }\n    }\n\n    /**\n     * @dev Transfers a specified amount of tokens from the `payer` to the `recipient`.\n     * @param token The address of the token to be transferred.\n     * @param payer The address from which the tokens will be transferred.\n     * @param recipient The address that will receive the tokens.\n     * @param value The amount of tokens to be transferred.\n     * @notice If the specified `value` is greater than zero, this function will transfer the tokens either by calling `safeTransfer`\n     * if the `payer` is equal to `address(this)`, or by calling `safeTransferFrom` otherwise.\n     */\n    function _pay(address token, address payer, address recipient, uint256 value) internal {\n        if (value > 0) {\n            if (payer == address(this)) {\n                IERC20(token).safeTransfer(recipient, value);\n            } else {\n                IERC20(token).safeTransferFrom(payer, recipient, value);\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a token swap using Uniswap V3 with exact input.\n     * @param params The struct containing all swap parameters.\n     * @return amountOut The amount of tokens received as output from the swap.\n     * @notice This internal function swaps the exact amount of `params.amountIn` tokens from `params.tokenIn` to `params.tokenOut`.\n     * The swapped amount is calculated based on the current pool ratio between `params.tokenIn` and `params.tokenOut`.\n     * If the resulting `amountOut` is less than `params.amountOutMinimum`, the function will revert with a `SwapSlippageCheckError`\n     * indicating the minimum expected amount was not met.\n     */\n    function _v3SwapExactInput(\n        v3SwapExactInputParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if tokenIn has a 0th token\n        bool zeroForTokenIn = params.tokenIn < params.tokenOut;\n        // Compute the address of the Uniswap V3 pool based on tokenIn, tokenOut, and fee\n        // Call the swap function on the Uniswap V3 pool contract\n        (int256 amount0Delta, int256 amount1Delta) = IUniswapV3Pool(\n            computePoolAddress(params.tokenIn, params.tokenOut, params.fee)\n        ).swap(\n                address(this), //recipient\n                zeroForTokenIn,\n                params.amountIn.toInt256(),\n                (zeroForTokenIn ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n                abi.encode(params.fee, params.tokenIn, params.tokenOut)\n            );\n        // Calculate the actual amount of output tokens received\n        amountOut = uint256(-(zeroForTokenIn ? amount1Delta : amount0Delta));\n        // Check if the received amount satisfies the minimum requirement\n        if (amountOut < params.amountOutMinimum) {\n            revert SwapSlippageCheckError(params.amountOutMinimum, amountOut);\n        }\n    }\n\n    /**\n     * @dev Callback function invoked by Uniswap V3 swap.\n     *\n     * This function is called when a swap is executed on a Uniswap V3 pool. It performs the necessary validations\n     * and payment processing.\n     *\n     * Requirements:\n     * - The swap must not entirely fall within 0-liquidity regions, as it is not supported.\n     * - The caller must be the expected Uniswap V3 pool contract.\n     *\n     * @param amount0Delta The change in token0 balance resulting from the swap.\n     * @param amount1Delta The change in token1 balance resulting from the swap.\n     * @param data Additional data required for processing the swap, encoded as `(uint24, address, address)`.\n     */\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        (amount0Delta <= 0 && amount1Delta <= 0).revertError(ErrLib.ErrorCode.INVALID_SWAP); // swaps entirely within 0-liquidity regions are not supported\n\n        (uint24 fee, address tokenIn, address tokenOut) = abi.decode(\n            data,\n            (uint24, address, address)\n        );\n        (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender).revertError(\n            ErrLib.ErrorCode.INVALID_CALLER\n        );\n        uint256 amountToPay = amount0Delta > 0 ? uint256(amount0Delta) : uint256(amount1Delta);\n        _pay(tokenIn, address(this), msg.sender, amountToPay);\n    }\n\n    /**\n     * @dev Computes the address of a Uniswap V3 pool based on the provided parameters.\n     *\n     * This function calculates the address of a Uniswap V3 pool contract using the token addresses and fee.\n     * It follows the same logic as Uniswap's pool initialization process.\n     *\n     * @param tokenA The address of one of the tokens in the pair.\n     * @param tokenB The address of the other token in the pair.\n     * @param fee The fee level of the pool.\n     * @return pool The computed address of the Uniswap V3 pool.\n     */\n    function computePoolAddress(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            UNDERLYING_V3_FACTORY_ADDRESS,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            UNDERLYING_V3_POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}"
    },
    {
      "filename": "wagmi-leverage/contracts/abstract/ApproveSwapAndPay.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { SafeCast } from \"@uniswap/v3-core/contracts/libraries/SafeCast.sol\";\nimport \"../libraries/ExternalCall.sol\";\nimport \"../libraries/ErrLib.sol\";\n\nabstract contract ApproveSwapAndPay {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using { ExternalCall._patchAmountAndCall } for address;\n    using { ExternalCall._readFirstBytes4 } for bytes;\n    using { ErrLib.revertError } for bool;\n\n    /// @notice Struct representing the parameters for a Uniswap V3 exact input swap.\n    struct v3SwapExactInputParams {\n        /// @dev The fee tier to be used for the swap.\n        uint24 fee;\n        /// @dev The address of the token to be swapped from.\n        address tokenIn;\n        /// @dev The address of the token to be swapped to.\n        address tokenOut;\n        /// @dev The amount of `tokenIn` to be swapped.\n        uint256 amountIn;\n        /// @dev The minimum amount of `tokenOut` expected to receive from the swap.\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Struct to hold parameters for swapping tokens\n    struct SwapParams {\n        /// @notice Address of the aggregator's router\n        address swapTarget;\n        /// @notice The index in the `swapData` array where the swap amount in is stored\n        uint256 swapAmountInDataIndex;\n        /// @notice The maximum gas limit for the swap call\n        uint256 maxGasForCall;\n        /// @notice The aggregator's data that stores paths and amounts for swapping through\n        bytes swapData;\n    }\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    address public immutable UNDERLYING_V3_FACTORY_ADDRESS;\n    bytes32 public immutable UNDERLYING_V3_POOL_INIT_CODE_HASH;\n\n    ///     swapTarget   => (func.selector => is allowed)\n    mapping(address => mapping(bytes4 => bool)) public whitelistedCall;\n\n    error SwapSlippageCheckError(uint256 expectedOut, uint256 receivedOut);\n\n    constructor(\n        address _UNDERLYING_V3_FACTORY_ADDRESS,\n        bytes32 _UNDERLYING_V3_POOL_INIT_CODE_HASH\n    ) {\n        UNDERLYING_V3_FACTORY_ADDRESS = _UNDERLYING_V3_FACTORY_ADDRESS;\n        UNDERLYING_V3_POOL_INIT_CODE_HASH = _UNDERLYING_V3_POOL_INIT_CODE_HASH;\n    }\n\n    /**\n     * @dev This internal function attempts to approve a specific amount of tokens for a spender.\n     * It performs a call to the `approve` function on the token contract using the provided parameters,\n     * and returns a boolean indicating whether the approval was successful or not.\n     * @param token The address of the token contract.\n     * @param spender The address of the spender.\n     * @param amount The amount of tokens to be approved.\n     * @return A boolean indicating whether the approval was successful or not.\n     */\n    function _tryApprove(address token, address spender, uint256 amount) private returns (bool) {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, spender, amount)\n        );\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n\n    /**\n     * @dev This internal function ensures that the allowance for a spender is at least the specified amount.\n     * If the current allowance is less than the specified amount, it attempts to approve the maximum possible value,\n     * and if that fails, it retries with the maximum possible value minus one. If both attempts fail,\n     * it reverts with an error indicating that the approval did not succeed.\n     * @param token The address of the token contract.\n     * @param spender The address of the spender.\n     * @param amount The minimum required allowance.\n     */\n    function _maxApproveIfNecessary(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) < amount) {\n            if (!_tryApprove(token, spender, type(uint256).max)) {\n                if (!_tryApprove(token, spender, type(uint256).max - 1)) {\n                    require(_tryApprove(token, spender, 0));\n                    if (!_tryApprove(token, spender, type(uint256).max)) {\n                        if (!_tryApprove(token, spender, type(uint256).max - 1)) {\n                            true.revertError(ErrLib.ErrorCode.ERC20_APPROVE_DID_NOT_SUCCEED);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev This internal view function retrieves the balance of the contract for a specific token.\n     * It performs a staticcall to the `balanceOf` function on the token contract using the provided parameter,\n     * and returns the balance as a uint256 value.\n     * @param token The address of the token contract.\n     * @return balance The balance of the contract for the specified token.\n     */\n    function _getBalance(address token) internal view returns (uint256 balance) {\n        bytes memory callData = abi.encodeWithSelector(IERC20.balanceOf.selector, address(this));\n        (bool success, bytes memory data) = token.staticcall(callData);\n        require(success && data.length >= 32);\n        balance = abi.decode(data, (uint256));\n    }\n\n    /**\n     * @dev Retrieves the balance of two tokens in the contract.\n     * @param tokenA The address of the first token.\n     * @param tokenB The address of the second token.\n     * @return balanceA The balance of the first token in the contract.\n     * @return balanceB The balance of the second token in the contract.\n     */\n    function _getPairBalance(\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 balanceA, uint256 balanceB) {\n        balanceA = _getBalance(tokenA);\n        balanceB = _getBalance(tokenB);\n    }\n\n    /**\n     * @dev Executes a swap between two tokens using an external contract.\n     * @param tokenIn The address of the token to be swapped.\n     * @param tokenOut The address of the token to receive in the swap.\n     * @param externalSwap The swap parameters from the external contract.\n     * @param amountIn The amount of `tokenIn` to be swapped.\n     * @param amountOutMin The minimum amount of `tokenOut` expected to receive from the swap.\n     * @return amountOut The actual amount of `tokenOut` received from the swap.\n     * @notice This function will revert if the swap target is not approved or the resulting amountOut\n     * is zero or below the specified minimum amountOut.\n     */\n    function _patchAmountsAndCallSwap(\n        address tokenIn,\n        address tokenOut,\n        SwapParams calldata externalSwap,\n        uint256 amountIn,\n        uint256 amountOutMin\n    ) internal returns (uint256 amountOut) {\n        bytes4 funcSelector = externalSwap.swapData._readFirstBytes4();\n        // Verifying if the swap target is whitelisted for the specified function selector\n        (!whitelistedCall[externalSwap.swapTarget][funcSelector]).revertError(\n            ErrLib.ErrorCode.SWAP_TARGET_NOT_APPROVED\n        );\n        // Maximizing approval if necessary\n        _maxApproveIfNecessary(tokenIn, externalSwap.swapTarget, amountIn);\n        uint256 balanceOutBefore = _getBalance(tokenOut);\n        // Patching the amount and calling the external swap\n        externalSwap.swapTarget._patchAmountAndCall(\n            externalSwap.swapData,\n            externalSwap.maxGasForCall,\n            externalSwap.swapAmountInDataIndex,\n            amountIn\n        );\n        // Calculating the actual amount of output tokens received\n        amountOut = _getBalance(tokenOut) - balanceOutBefore;\n        // Checking if the received amount satisfies the minimum requirement\n        if (amountOut == 0 || amountOut < amountOutMin) {\n            revert SwapSlippageCheckError(amountOutMin, amountOut);\n        }\n    }\n\n    /**\n     * @dev Transfers a specified amount of tokens from the `payer` to the `recipient`.\n     * @param token The address of the token to be transferred.\n     * @param payer The address from which the tokens will be transferred.\n     * @param recipient The address that will receive the tokens.\n     * @param value The amount of tokens to be transferred.\n     * @notice If the specified `value` is greater than zero, this function will transfer the tokens either by calling `safeTransfer`\n     * if the `payer` is equal to `address(this)`, or by calling `safeTransferFrom` otherwise.\n     */\n    function _pay(address token, address payer, address recipient, uint256 value) internal {\n        if (value > 0) {\n            if (payer == address(this)) {\n                IERC20(token).safeTransfer(recipient, value);\n            } else {\n                IERC20(token).safeTransferFrom(payer, recipient, value);\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a token swap using Uniswap V3 with exact input.\n     * @param params The struct containing all swap parameters.\n     * @return amountOut The amount of tokens received as output from the swap.\n     * @notice This internal function swaps the exact amount of `params.amountIn` tokens from `params.tokenIn` to `params.tokenOut`.\n     * The swapped amount is calculated based on the current pool ratio between `params.tokenIn` and `params.tokenOut`.\n     * If the resulting `amountOut` is less than `params.amountOutMinimum`, the function will revert with a `SwapSlippageCheckError`\n     * indicating the minimum expected amount was not met.\n     */\n    function _v3SwapExactInput(\n        v3SwapExactInputParams memory params\n    ) internal returns (uint256 amountOut) {\n        // Determine if tokenIn has a 0th token\n        bool zeroForTokenIn = params.tokenIn < params.tokenOut;\n        // Compute the address of the Uniswap V3 pool based on tokenIn, tokenOut, and fee\n        // Call the swap function on the Uniswap V3 pool contract\n        (int256 amount0Delta, int256 amount1Delta) = IUniswapV3Pool(\n            computePoolAddress(params.tokenIn, params.tokenOut, params.fee)\n        ).swap(\n                address(this), //recipient\n                zeroForTokenIn,\n                params.amountIn.toInt256(),\n                (zeroForTokenIn ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n                abi.encode(params.fee, params.tokenIn, params.tokenOut)\n            );\n        // Calculate the actual amount of output tokens received\n        amountOut = uint256(-(zeroForTokenIn ? amount1Delta : amount0Delta));\n        // Check if the received amount satisfies the minimum requirement\n        if (amountOut < params.amountOutMinimum) {\n            revert SwapSlippageCheckError(params.amountOutMinimum, amountOut);\n        }\n    }\n\n    /**\n     * @dev Callback function invoked by Uniswap V3 swap.\n     *\n     * This function is called when a swap is executed on a Uniswap V3 pool. It performs the necessary validations\n     * and payment processing.\n     *\n     * Requirements:\n     * - The swap must not entirely fall within 0-liquidity regions, as it is not supported.\n     * - The caller must be the expected Uniswap V3 pool contract.\n     *\n     * @param amount0Delta The change in token0 balance resulting from the swap.\n     * @param amount1Delta The change in token1 balance resulting from the swap.\n     * @param data Additional data required for processing the swap, encoded as `(uint24, address, address)`.\n     */\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external {\n        (amount0Delta <= 0 && amount1Delta <= 0).revertError(ErrLib.ErrorCode.INVALID_SWAP); // swaps entirely within 0-liquidity regions are not supported\n\n        (uint24 fee, address tokenIn, address tokenOut) = abi.decode(\n            data,\n            (uint24, address, address)\n        );\n        (computePoolAddress(tokenIn, tokenOut, fee) != msg.sender).revertError(\n            ErrLib.ErrorCode.INVALID_CALLER\n        );\n        uint256 amountToPay = amount0Delta > 0 ? uint256(amount0Delta) : uint256(amount1Delta);\n        _pay(tokenIn, address(this), msg.sender, amountToPay);\n    }\n\n    /**\n     * @dev Computes the address of a Uniswap V3 pool based on the provided parameters.\n     *\n     * This function calculates the address of a Uniswap V3 pool contract using the token addresses and fee.\n     * It follows the same logic as Uniswap's pool initialization process.\n     *\n     * @param tokenA The address of one of the tokens in the pair.\n     * @param tokenB The address of the other token in the pair.\n     * @param fee The fee level of the pool.\n     * @return pool The computed address of the Uniswap V3 pool.\n     */\n    function computePoolAddress(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) public view returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            UNDERLYING_V3_FACTORY_ADDRESS,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            UNDERLYING_V3_POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}"
    },
    {
      "filename": "wagmi-leverage/contracts/abstract/ApproveSwapAndPay.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { SafeCast } from \"@uniswap/v3-core/contracts/libraries/SafeCast.sol\";\nimport \"../libraries/ExternalCall.sol\";\nimport \"../libraries/ErrLib.sol\";\n\nabstract contract ApproveSwapAndPay {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using { ExternalCall._patchAmountAndCall } for address;\n    using { ExternalCall._readFirstBytes4 } for bytes;\n    using { ErrLib.revertError } for bool;\n\n    /// @notice Struct representing the parameters for a Uniswap V3 exact input swap.\n    struct v3SwapExactInputParams {\n        /// @dev The fee tier to be used for the swap.\n        uint24 fee;\n        /// @dev The address of the token to be swapped from.\n        address tokenIn;\n        /// @dev The address of the token to be swapped to.\n        address tokenOut;\n        /// @dev The amount of `tokenIn` to be swapped.\n        uint256 amountIn;\n        /// @dev The minimum amount of `tokenOut` expected to receive from the swap.\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Struct to hold parameters for swapping tokens\n    struct SwapParams {\n        /// @notice Address of the aggregator's router\n        address swapTarget;\n        /// @notice The index in the `swapData` array where the swap amount in is stored\n        uint256 swapAmountInDataIndex;\n        /// @notice The maximum gas limit for the swap call\n        uint256 maxGasForCall;\n        /// @notice The aggregator's data that stores paths and amounts for swapping through\n        bytes swapData;\n    }\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    address public immutable UNDERLYING_V3_FACTORY_ADDRESS;\n    bytes32 public immutable UNDERLYING_V3_POOL_INIT_CODE_HASH;\n\n    ///     swapTarget   => (func.selector => is allowed)\n    mapping(address => mapping(bytes4 => bool)) public whitelistedCall;\n\n    error SwapSlippageCheckError(uint256 expectedOut, uint256 receivedOut);\n\n    constructor(\n        address _UNDERLYING_V3_FACTORY_ADDRESS,\n        bytes32 _UNDERLYING_V3_POOL_INIT_CODE_HASH\n    ) {\n        UNDERLYING_V3_FACTORY_ADDRESS = _UNDERLYING_V3_FACTORY_ADDRESS;\n        UNDERLYING_V3_POOL_INIT_CODE_HASH = _UNDERLYING_V3_POOL_INIT_CODE_HASH;\n    }\n\n    /**\n     * @dev This internal function attempts to approve a specific amount of tokens for a spender.\n     * It performs a call to the `approve` function on the token contract using the provided parameters,\n     * and returns a boolean indicating whether the approval was successful or not.\n     * @param token The address of the token contract.\n     * @param spender The address of the spender.\n     * @param amount The amount of tokens to be approved.\n     * @return A boolean indicating whether the approval was successful or not.\n     */\n    function _tryApprove(address token, address spender, uint256 amount) private returns (bool) {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, spender, amount)\n        );\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n\n    /**\n     * @dev This internal function ensures that the allowance for a spender is at least the specified amount.\n     * If the current allowance is less than the specified amount, it attempts to approve the maximum possible value,\n     * and if that fails, it retries with the maximum possible value minus one. If both attempts fail,\n     * it reverts with an error indicating that the approval did not succeed.\n     * @param token The address of the token contract.\n     * @param spender The address of the spender.\n     * @param amount The minimum required allowance.\n     */\n    function _maxApproveIfNecessary(address token, address spender, uint256 amount) internal {\n        if (IERC20(token).allowance(address(this), spender) < amount) {\n            if (!_tryApprove(token, spender, type(uint256).max)) {\n                if (!_tryApprove(token, spender, type(uint256).max - 1)) {\n                    require(_tryApprove(token, spender, 0));\n                    if (!_tryApprove(token, spender, type(uint256).max)) {\n                        if (!_tryApprove(token, spender, type(uint256).max - 1)) {\n                            true.revertError(ErrLib.ErrorCode.ERC20_APPROVE_DID_NOT_SUCCEED);\n                        }\n                    }\n                }\n            }"
    }
  ]
}