{
  "Title": "Unnecessary token allowance",
  "Content": "The ConvexEthMetaStrategy contract [grants an allowance](https://github.com/OriginProtocol/origin-dollar/blob/757ad13fa07ecdff058e55d9beff3c98d5d186a2/contracts/contracts/strategies/ConvexEthMetaStrategy.sol#L352) for the Curve pool to spend all WETH tokens. This allowance can also be [renewed](https://github.com/OriginProtocol/origin-dollar/blob/757ad13fa07ecdff058e55d9beff3c98d5d186a2/contracts/contracts/strategies/ConvexEthMetaStrategy.sol#L334) by the governor. However, the pool [accepts ETH directly](https://github.com/OriginProtocol/origin-dollar/blob/757ad13fa07ecdff058e55d9beff3c98d5d186a2/contracts/contracts/strategies/ConvexEthMetaStrategy.sol#L153) and never interacts with the WETH token.\n\n\nIn the interest of limiting the attack surface, consider removing this unnecessary allowance.\n\n\n***Update:** Resolved in [pull request #1494](https://github.com/OriginProtocol/origin-dollar/pull/1494) at commit [1be6d8](https://github.com/OriginProtocol/origin-dollar/pull/1494/commits/1be6d8d1798c4321b23adbdf394354d4b02e20f0).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/strategies/ConvexEthMetaStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Curve 3Pool Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ICurveETHPoolV1 } from \"./ICurveETHPoolV1.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\nimport { IConvexDeposits } from \"./IConvexDeposits.sol\";\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\n\ncontract ConvexEthMetaStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant MAX_SLIPPAGE = 1e16; // 1%, same as the Curve UI\n    address internal constant ETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address internal cvxDepositorAddress;\n    IRewardStaking public cvxRewardStaker;\n    uint256 internal cvxDepositorPTokenId;\n    ICurveETHPoolV1 internal curvePool;\n    IERC20 internal lpToken;\n    IERC20 internal oeth;\n    IWETH9 internal weth;\n    // Ordered list of pool assets\n    uint128 internal oethCoinIndex;\n    uint128 internal ethCoinIndex;\n\n    // used to circumvent the stack too deep issue\n    struct InitialiseConfig {\n        address curvePoolAddress; //Address of the Curve pool\n        address vaultAddress; //Address of the vault\n        address cvxDepositorAddress; //Address of the Convex depositor(AKA booster) for this pool\n        address oethAddress; //Address of OETH token\n        address wethAddress; //Address of WETH token\n        address cvxRewardStakerAddress; //Address of the CVX rewards staker\n        address curvePoolLpToken; //Address of metapool LP token\n        uint256 cvxDepositorPTokenId; //Pid of the pool referred to by Depositor and staker\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                WETH\n     * @param initConfig Various addresses and info for initialization state\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        InitialiseConfig calldata initConfig\n    ) external onlyGovernor initializer {\n        require(_assets.length == 1, \"Must have exactly one asset\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        cvxDepositorAddress = initConfig.cvxDepositorAddress;\n        cvxRewardStaker = IRewardStaking(initConfig.cvxRewardStakerAddress);\n        cvxDepositorPTokenId = initConfig.cvxDepositorPTokenId;\n        lpToken = IERC20(initConfig.curvePoolLpToken);\n        curvePool = ICurveETHPoolV1(initConfig.curvePoolAddress);\n        oeth = IERC20(initConfig.oethAddress);\n        weth = IWETH9(initConfig.wethAddress);\n        ethCoinIndex = uint128(_getCoinIndex(ETH_ADDRESS));\n        oethCoinIndex = uint128(_getCoinIndex(initConfig.oethAddress));\n\n        super._initialize(\n            initConfig.curvePoolAddress,\n            initConfig.vaultAddress,\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n\n        /* needs to be called after super._initialize so that the platformAddress\n         * is correctly set\n         */\n        _approveBase();\n    }\n\n    /**\n     * @dev Deposit asset into the Curve ETH pool\n     * @param _weth Address of WETH\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _weth, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_weth, _amount);\n    }\n\n    function _deposit(address _weth, uint256 _wethAmount) internal {\n        require(_wethAmount > 0, \"Must deposit something\");\n        require(_weth == address(weth), \"Can only deposit WETH\");\n        weth.withdraw(_wethAmount);\n\n        emit Deposit(_weth, address(lpToken), _wethAmount);\n\n        // safe to cast since min value is at least 0\n        uint256 oethToAdd = uint256(\n            _max(\n                0,\n                int256(curvePool.balances(ethCoinIndex)) +\n                    int256(_wethAmount) -\n                    int256(curvePool.balances(oethCoinIndex))\n            )\n        );\n\n        /* Add so much OETH so that the pool ends up being balanced. And at minimum\n         * add as much OETH as WETH and at maximum twice as much OETH.\n         */\n        oethToAdd = Math.max(oethToAdd, _wethAmount);\n        oethToAdd = Math.min(oethToAdd, _wethAmount * 2);\n\n        /* Mint OETH with a strategy that attempts to contribute to stability of OETH/WETH pool. Try\n         * to mint so much OETH that after deployment of liquidity pool ends up being balanced.\n         *\n         * To manage unpredictability minimal OETH minted will always be at least equal or greater\n         * to WETH amount deployed. And never larger than twice the WETH amount deployed even if\n         * it would have a further beneficial effect on pool stability.\n         */\n        IVault(vaultAddress).mintForStrategy(oethToAdd);\n\n        uint256[2] memory _amounts;\n        _amounts[ethCoinIndex] = _wethAmount;\n        _amounts[oethCoinIndex] = oethToAdd;\n\n        uint256 valueInLpTokens = (_wethAmount + oethToAdd).divPrecisely(\n            curvePool.get_virtual_price()\n        );\n        uint256 minMintAmount = valueInLpTokens.mulTruncate(\n            uint256(1e18) - MAX_SLIPPAGE\n        );\n\n        uint256 balance = oeth.balanceOf(address(this));\n        // Do the deposit to Curve ETH pool\n        uint256 lpDeposited = curvePool.add_liquidity{ value: _wethAmount }(\n            _amounts,\n            minMintAmount\n        );\n\n        require(\n            IConvexDeposits(cvxDepositorAddress).deposit(\n                cvxDepositorPTokenId,\n                lpDeposited,\n                true // Deposit with staking\n            ),\n            \"Depositing LP to Convex not successful\"\n        );\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into the Curve 3pool\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = weth.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(weth), balance);\n        }\n    }\n\n    /**\n     * @dev Withdraw asset from Curve ETH pool\n     * @param _recipient Address to receive withdrawn asset\n     * @param _weth Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _weth,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Invalid amount\");\n        require(_weth == address(weth), \"Can only withdraw WETH\");\n\n        emit Withdrawal(_weth, address(lpToken), _amount);\n\n        uint256 requiredLpTokens = calcTokenToBurn(_amount);\n\n        _lpWithdraw(requiredLpTokens);\n\n        /* math in requiredLpTokens should correctly calculate the amount of LP to remove\n         * in that the strategy receives enough WETH on balanced removal\n         */\n        uint256[2] memory _minWithdrawalAmounts = [uint256(0), uint256(0)];\n        _minWithdrawalAmounts[ethCoinIndex] = _amount;\n        curvePool.remove_liquidity(requiredLpTokens, _minWithdrawalAmounts);\n\n        // Burn OETH\n        IVault(vaultAddress).burnForStrategy(oeth.balanceOf(address(this)));\n        // Transfer WETH\n        weth.deposit{ value: _amount }();\n        weth.transfer(_recipient, _amount);\n    }\n\n    function calcTokenToBurn(uint256 _wethAmount)\n        internal\n        view\n        returns (uint256 lpToBurn)\n    {\n        /* The rate between coins in the pool determines the rate at which pool returns\n         * tokens when doing balanced removal (remove_liquidity call). And by knowing how much WETH\n         * we want we can determine how much of OETH we receive by removing liquidity.\n         *\n         * Because we are doing balanced removal we should be making profit when removing liquidity in a\n         * pool tilted to either side.\n         *\n         * Important: A downside is that the Strategist / Governor needs to be\n         * cognisant of not removing too much liquidity. And while the proposal to remove liquidity\n         * is being voted on the pool tilt might change so much that the proposal that has been valid while\n         * created is no longer valid.\n         */\n\n        uint256 poolWETHBalance = curvePool.balances(ethCoinIndex);\n        /* K is multiplied by 1e36 which is used for higher precision calculation of required\n         * pool LP tokens. Without it the end value can have rounding errors up to precision of\n         * 10 digits. This way we move the decimal point by 36 places when doing the calculation\n         * and again by 36 places when we are done with it.\n         */\n        uint256 k = (1e36 * lpToken.totalSupply()) / poolWETHBalance;\n        // simplifying below to: `uint256 diff = (_wethAmount - 1) * k` causes loss of precision\n        // prettier-ignore\n        // slither-disable-next-line divide-before-multiply\n        uint256 diff = poolWETHBalance * k -\n            (poolWETHBalance - _wethAmount - 1) * k;\n        lpToBurn = diff / 1e36;\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 gaugeTokens = cvxRewardStaker.balanceOf(address(this));\n        _lpWithdraw(gaugeTokens);\n\n        // Withdraws are proportional to assets held by 3Pool\n        uint256[2] memory minWithdrawAmounts = [uint256(0), uint256(0)];\n\n        // Remove liquidity\n        curvePool.remove_liquidity(\n            lpToken.balanceOf(address(this)),\n            minWithdrawAmounts\n        );\n\n        // Burn all OETH\n        uint256 oethBalance = oeth.balanceOf(address(this));\n        IVault(vaultAddress).burnForStrategy(oethBalance);\n\n        // Send all ETH and WETH on the contract, including extra\n        weth.deposit{ value: address(this).balance }();\n        weth.transfer(vaultAddress, weth.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Collect accumulated CRV and CVX and send to Harvester.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        cvxRewardStaker.getReward();\n        _collectRewardTokens();\n    }\n\n    function _lpWithdraw(uint256 _wethAmount) internal {\n        // withdraw and unwrap with claim takes back the lpTokens\n        // and also collects the rewards for deposit\n        cvxRewardStaker.withdrawAndUnwrap(_wethAmount, true);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(weth), \"Unsupported asset\");\n\n        // Eth balance needed here for the balance check that happens from vault during depositing.\n        balance += address(this).balance;\n        uint256 lpTokens = cvxRewardStaker.balanceOf(address(this));\n        if (lpTokens > 0) {\n            balance += (lpTokens * curvePool.get_virtual_price()) / 1e18;\n        }\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _asset == address(weth);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        _approveAsset(address(weth));\n        _approveAsset(address(oeth));\n    }\n\n    /**\n     * @dev Accept unwrapped WETH\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Call the necessary approvals for the Curve pool and gauge\n     * @param _asset Address of the asset\n     */\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        _approveAsset(_asset);\n    }\n\n    function _approveAsset(address _asset) internal {\n        // approve curve pool for asset (required for adding liquidity)\n        IERC20(_asset).approve(platformAddress, type(uint256).max);\n    }\n\n    function _approveBase() internal {\n        // WETH was approved as a supported asset,\n        // so we need seperate OETH approve\n        _approveAsset(address(oeth));\n        lpToken.approve(cvxDepositorAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Get the index of the coin\n     */\n    function _getCoinIndex(address _asset) internal view returns (uint256) {\n        for (uint256 i = 0; i < 2; i++) {\n            if (curvePool.coins(i) == _asset) return i;\n        }\n        revert(\"Invalid curve pool asset\");\n    }\n\n    /**\n     * @dev Returns the largest of two numbers int256 version\n     */\n    function _max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n}"
    }
  ]
}