{
  "Title": "MarmoStork does not check the size of the implementation contract address explicitly",
  "Content": "The [constructor of the MarmoStork contract](https://github.com/ripio/marmo-contracts/blob/d3fb5922a4f01e47d585343d08cccfad659b3584/contracts/MarmoStork.sol#L44) takes an array of bytes in the `_source` argument, and uses it as the destination address for a `delegatecall`. An ethereum address has 20 bytes, but the size of this array is not checked at the beginning of the function.\n\n\nThe length of this `_source` argument is then used to generate the bytecode of the contract that will delegate the calls. If an array that is not a valid address is passed to this constructor, the resulting bytecode will have an unintended behavior. The part generated from the length of the array is surrounded by other hardcoded bytecode, so it would be very difficult to craft an attack just by manipulating the length. But, for example, taking the [part that generates the opcode that should push the address to the stack](https://github.com/ripio/marmo-contracts/blob/d3fb5922a4f01e47d585343d08cccfad659b3584/contracts/MarmoStork.sol#L50) when the `_source` array length is bigger than that of a valid address, it can even result in the `selfdestruct` opcode instead of the expected `push20`.\n\n\nLater in the constructor, [this argument is converted to an address](https://github.com/ripio/marmo-contracts/blob/d3fb5922a4f01e47d585343d08cccfad659b3584/contracts/MarmoStork.sol#L59) calling the [`toAddress`](https://github.com/ripio/marmo-contracts/blob/d3fb5922a4f01e47d585343d08cccfad659b3584/contracts/commons/Bytes.sol#L61) function which does require the length to be 20 or less. So a bigger array will end up reverting the constructor, but this does not happen explicitly and because of that it has the risk of being removed by mistake.\n\n\nConsider changing the type of the `_source` parameter to `address`. This will make the expectations clear and prevent any issues derived from invalid addresses. Alternatively, consider requiring the array to be 20 bytes at the start of the constructor, following [best practices](https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702) to fail early and to structure your functions starting with the conditions. Both options have an added benefit: a fixed size would simplify the bytecode generation because more terms can be replaced by constants.\n\n\n***Update:*** *Fixed in* [*pull request #30*](https://github.com/ripio/marmo-contracts/pull/30/files)*. The* [*constructor of MarmoStork*](https://github.com/ripio/marmo-contracts/blob/master/contracts/MarmoStork.sol#L34) *now takes and address as parameter.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/MarmoStork.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Marmo.sol\";\nimport \"./commons/Bytes.sol\";\n\n// MarmoStork creates all Marmo wallets\n// every address has a designated marmo wallet\n// and can send transactions by signing Meta-Tx (Intents)\n//\n// All wallets are proxies pointing to a single\n// source contract, to make deployment costs viable\ncontract MarmoStork {\n    using Bytes for address;\n    using Bytes for bytes1;\n    using Bytes for bytes;\n\n    // Minimal proxy contract\n    // by Agusx1211\n    bytes constant CODE1 = hex\"60\"; // + <size>                                   // Copy code to memory\n    bytes constant CODE2 = hex\"80600b6000396000f3\";                               // Return and deploy contract\n    bytes constant CODE3 = hex\"3660008037600080366000\";   // + <pushx> + <source> // Proxy, copy calldata and start delegatecall\n    bytes constant CODE4 = hex\"5af43d6000803e60003d9160\"; // + <return jump>      // Do delegatecall and return jump\n    bytes constant CODE5 = hex\"57fd5bf3\";                                         // Return proxy\n\n    bytes1 constant BASE_SIZE = 0x1d;\n    bytes1 constant PUSH_1 = 0x60;\n    bytes1 constant BASE_RETURN_JUMP = 0x1b;\n\n    // Bytecode to deploy marmo wallets\n    bytes public bytecode;\n\n    // Hash of the bytecode\n    // used to calculate create2 result\n    bytes32 public hash;\n\n    // Marmo Source contract\n    // all proxies point here\n    address public marmo;\n\n    // Creates a new MarmoStork (Marmo wallet Factory)\n    // with wallets pointing to the _source contract reference\n    // notice: _source may contain less than 20 bytes\n    // the difference will be filled with 0s at the beginning of the address\n    constructor(bytes memory _source) public {\n        // Generate and save wallet creator bytecode using the provided '_source'\n        bytecode = Bytes.concat(\n            CODE1,\n            BASE_SIZE.plus(_source.length).toBytes(),\n            CODE2,\n            CODE3.concat(PUSH_1.plus(_source.length - 1)).concat(_source),\n            CODE4.concat(BASE_RETURN_JUMP.plus(_source.length)),\n            CODE5\n        );\n\n        // Precalculate init_code hash\n        hash = keccak256(bytecode);\n        \n        // Destroy the '_source' provided, if is not destroyed\n        Marmo marmoc = Marmo(_source.toAddress());\n        if (marmoc.signer() == address(0)) {\n            marmoc.init(address(65536));\n        }\n\n        // Validate, the signer of _source should be \"INVALID_ADDRESS\" (destroyed)\n        require(marmoc.signer() == address(65536), \"Error init Marmo source\");\n\n        // Save the _source address, casting to address (160 bits)\n        marmo = address(marmoc);\n    }\n    \n    // Calculates the Marmo wallet for a given signer\n    // the wallet contract will be deployed in a deterministic manner\n    function marmoOf(address _signer) external view returns (address) {\n        // CREATE2 address\n        return address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        byte(0xff),\n                        address(this),\n                        bytes32(uint256(_signer)),\n                        hash\n                    )\n                )\n            )\n        );\n    }\n\n    // Deploys the Marmo wallet of a given _signer\n    // all ETH sent will be forwarded to the wallet\n    function reveal(address _signer) external payable {\n        // Load init code from storage\n        bytes memory proxyCode = bytecode;\n\n        // Create wallet proxy using CREATE2\n        // use _signer as salt\n        Marmo p;\n        assembly {\n            p := create2(0, add(proxyCode, 0x20), mload(proxyCode), _signer)\n        }\n\n        // Init wallet with provided _signer\n        // and forward all Ether\n        p.init.value(msg.value)(_signer);\n    }\n}"
    },
    {
      "filename": "contracts/MarmoStork.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Marmo.sol\";\nimport \"./commons/Bytes.sol\";\n\n// MarmoStork creates all Marmo wallets\n// every address has a designated marmo wallet\n// and can send transactions by signing Meta-Tx (Intents)\n//\n// All wallets are proxies pointing to a single\n// source contract, to make deployment costs viable\ncontract MarmoStork {\n    using Bytes for address;\n    using Bytes for bytes1;\n    using Bytes for bytes;\n\n    // Minimal proxy contract\n    // by Agusx1211\n    bytes constant CODE1 = hex\"60\"; // + <size>                                   // Copy code to memory\n    bytes constant CODE2 = hex\"80600b6000396000f3\";                               // Return and deploy contract\n    bytes constant CODE3 = hex\"3660008037600080366000\";   // + <pushx> + <source> // Proxy, copy calldata and start delegatecall\n    bytes constant CODE4 = hex\"5af43d6000803e60003d9160\"; // + <return jump>      // Do delegatecall and return jump\n    bytes constant CODE5 = hex\"57fd5bf3\";                                         // Return proxy\n\n    bytes1 constant BASE_SIZE = 0x1d;\n    bytes1 constant PUSH_1 = 0x60;\n    bytes1 constant BASE_RETURN_JUMP = 0x1b;\n\n    // Bytecode to deploy marmo wallets\n    bytes public bytecode;\n\n    // Hash of the bytecode\n    // used to calculate create2 result\n    bytes32 public hash;\n\n    // Marmo Source contract\n    // all proxies point here\n    address public marmo;\n\n    // Creates a new MarmoStork (Marmo wallet Factory)\n    // with wallets pointing to the _source contract reference\n    // notice: _source may contain less than 20 bytes\n    // the difference will be filled with 0s at the beginning of the address\n    constructor(bytes memory _source) public {\n        // Generate and save wallet creator bytecode using the provided '_source'\n        bytecode = Bytes.concat(\n            CODE1,\n            BASE_SIZE.plus(_source.length).toBytes(),\n            CODE2,\n            CODE3.concat(PUSH_1.plus(_source.length - 1)).concat(_source),\n            CODE4.concat(BASE_RETURN_JUMP.plus(_source.length)),\n            CODE5\n        );\n\n        // Precalculate init_code hash\n        hash = keccak256(bytecode);\n        \n        // Destroy the '_source' provided, if is not destroyed\n        Marmo marmoc = Marmo(_source.toAddress());\n        if (marmoc.signer() == address(0)) {\n            marmoc.init(address(65536));\n        }\n\n        // Validate, the signer of _source should be \"INVALID_ADDRESS\" (destroyed)\n        require(marmoc.signer() == address(65536), \"Error init Marmo source\");\n\n        // Save the _source address, casting to address (160 bits)\n        marmo = address(marmoc);\n    }\n    \n    // Calculates the Marmo wallet for a given signer\n    // the wallet contract will be deployed in a deterministic manner\n    function marmoOf(address _signer) external view returns (address) {\n        // CREATE2 address\n        return address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        byte(0xff),\n                        address(this),\n                        bytes32(uint256(_signer)),\n                        hash\n                    )\n                )\n            )\n        );\n    }\n\n    // Deploys the Marmo wallet of a given _signer\n    // all ETH sent will be forwarded to the wallet\n    function reveal(address _signer) external payable {\n        // Load init code from storage\n        bytes memory proxyCode = bytecode;\n\n        // Create wallet proxy using CREATE2\n        // use _signer as salt\n        Marmo p;\n        assembly {\n            p := create2(0, add(proxyCode, 0x20), mload(proxyCode), _signer)\n        }\n\n        // Init wallet with provided _signer\n        // and forward all Ether\n        p.init.value(msg.value)(_signer);\n    }\n}"
    },
    {
      "filename": "contracts/MarmoStork.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Marmo.sol\";\nimport \"./commons/Bytes.sol\";\n\n// MarmoStork creates all Marmo wallets\n// every address has a designated marmo wallet\n// and can send transactions by signing Meta-Tx (Intents)\n//\n// All wallets are proxies pointing to a single\n// source contract, to make deployment costs viable\ncontract MarmoStork {\n    using Bytes for address;\n    using Bytes for bytes1;\n    using Bytes for bytes;\n\n    // Minimal proxy contract\n    // by Agusx1211\n    bytes constant CODE1 = hex\"60\"; // + <size>                                   // Copy code to memory\n    bytes constant CODE2 = hex\"80600b6000396000f3\";                               // Return and deploy contract\n    bytes constant CODE3 = hex\"3660008037600080366000\";   // + <pushx> + <source> // Proxy, copy calldata and start delegatecall\n    bytes constant CODE4 = hex\"5af43d6000803e60003d9160\"; // + <return jump>      // Do delegatecall and return jump\n    bytes constant CODE5 = hex\"57fd5bf3\";                                         // Return proxy\n\n    bytes1 constant BASE_SIZE = 0x1d;\n    bytes1 constant PUSH_1 = 0x60;\n    bytes1 constant BASE_RETURN_JUMP = 0x1b;\n\n    // Bytecode to deploy marmo wallets\n    bytes public bytecode;\n\n    // Hash of the bytecode\n    // used to calculate create2 result\n    bytes32 public hash;\n\n    // Marmo Source contract\n    // all proxies point here\n    address public marmo;\n\n    // Creates a new MarmoStork (Marmo wallet Factory)\n    // with wallets pointing to the _source contract reference\n    // notice: _source may contain less than 20 bytes\n    // the difference will be filled with 0s at the beginning of the address\n    constructor(bytes memory _source) public {\n        // Generate and save wallet creator bytecode using the provided '_source'\n        bytecode = Bytes.concat(\n            CODE1,\n            BASE_SIZE.plus(_source.length).toBytes(),\n            CODE2,\n            CODE3.concat(PUSH_1.plus(_source.length - 1)).concat(_source),\n            CODE4.concat(BASE_RETURN_JUMP.plus(_source.length)),\n            CODE5\n        );\n\n        // Precalculate init_code hash\n        hash = keccak256(bytecode);\n        \n        // Destroy the '_source' provided, if is not destroyed\n        Marmo marmoc = Marmo(_source.toAddress());\n        if (marmoc.signer() == address(0)) {\n            marmoc.init(address(65536));\n        }\n\n        // Validate, the signer of _source should be \"INVALID_ADDRESS\" (destroyed)\n        require(marmoc.signer() == address(65536), \"Error init Marmo source\");\n\n        // Save the _source address, casting to address (160 bits)\n        marmo = address(marmoc);\n    }\n    \n    // Calculates the Marmo wallet for a given signer\n    // the wallet contract will be deployed in a deterministic manner\n    function marmoOf(address _signer) external view returns (address) {\n        // CREATE2 address\n        return address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        byte(0xff),\n                        address(this),\n                        bytes32(uint256(_signer)),\n                        hash\n                    )\n                )\n            )\n        );\n    }\n\n    // Deploys the Marmo wallet of a given _signer\n    // all ETH sent will be forwarded to the wallet\n    function reveal(address _signer) external payable {\n        // Load init code from storage\n        bytes memory proxyCode = bytecode;\n\n        // Create wallet proxy using CREATE2\n        // use _signer as salt\n        Marmo p;\n        assembly {\n            p := create2(0, add(proxyCode, 0x20), mload(proxyCode), _signer)\n        }\n\n        // Init wallet with provided _signer\n        // and forward all Ether\n        p.init.value(msg.value)(_signer);\n    }\n}"
    }
  ]
}