{
  "Title": "[M-01] `removeWrapping` can be called when there are still wrapped tokens",
  "Content": "_Submitted by Lambda, also found by 0x52 and cryptphi_\n\n[XC20Wrapper.sol#L66](https://github.com/code-423n4/2022-07-axelar/blob/a1205d2ba78e0db583d136f8563e8097860a110f/xc20/contracts/XC20Wrapper.sol#L66)<br>\n\nAn owner can call `removeWrapping`, even if there are still circulating wrapped tokens. This will cause the unwrapping of those tokens to fail, as `unwrapped[wrappedToken]` will be `addres(0)`.\n\n### Recommended Mitigation Steps\n\nTrack how many wrapped tokens are in circulation, only allow the removal of a wrapped tokens when there are 0 to ensure for users that they will always be able to unwrap.\n\n**[re1ro (Axelar) confirmed and commented](https://github.com/code-423n4/2022-07-axelar-findings/issues/23#issuecomment-1205933537):**\n > Valid observation. We will consider a different approach.\n> \n> **Mitigation**<br>\n> `removeWrapping` method was removed<br>\n> https://github.com/axelarnetwork/axelar-xc20-wrapper/pull/4\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-07-axelar-findings/issues/23#issuecomment-1229574297):**\n > The warden has shown how the Admin can remove the mapping that allows to redeem bridged tokens, because this will cause the inability to unwrap, and can be operated by the admin, I agree with Medium Severity.\n> \n> The sponsor has confirmed and they have mitigated by removing the function.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-07-axelar",
  "Code": [
    {
      "filename": "xc20/contracts/XC20Wrapper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { AxelarExecutable } from '@axelar-network/axelar-utils-solidity/contracts/executables/AxelarExecutable.sol';\nimport { IAxelarGateway } from '@axelar-network/axelar-utils-solidity/contracts/interfaces/IAxelarGateway.sol';\nimport './Upgradable.sol';\nimport { LocalAsset } from './interfaces/LocalAsset.sol';\n\ncontract XC20Wrapper is AxelarExecutable, Upgradable {\n    error TransferFailed();\n    error NotAxelarToken();\n    error NotXc20Token();\n    error InsufficientBalance();\n    error AlreadyWrappingAxelarToken();\n    error AlreadyWrappingXC20Token();\n    error NotOwnerOfXc20();\n\n    mapping(address => address) public wrapped;\n    mapping(address => address) public unwrapped;\n\n    bytes32 public xc20Codehash;\n    address public immutable gatewayAddress;\n\n    constructor(address gatewayAddress_) {\n        gatewayAddress = gatewayAddress_;\n    }\n\n    function gateway() public view override returns (IAxelarGateway) {\n        return IAxelarGateway(gatewayAddress);\n    }\n\n    function _setup(bytes calldata data) internal override {\n        (address owner_, bytes32 codehash_) = abi.decode(data, (address, bytes32));\n        _transferOwnership(owner_);\n        xc20Codehash = codehash_;\n    }\n\n    function contractId() public pure returns (bytes32) {\n        return keccak256('xc20-wrapper');\n    }\n\n    function setXc20Codehash(bytes32 newCodehash) external onlyOwner {\n        xc20Codehash = newCodehash;\n    }\n\n    function addWrapping(\n        string calldata symbol,\n        address xc20Token,\n        string memory newName,\n        string memory newSymbol\n    ) external payable onlyOwner {\n        address axelarToken = gateway().tokenAddresses(symbol);\n        if (axelarToken == address(0)) revert('NotAxelarToken()');\n        if (xc20Token.codehash != xc20Codehash) revert('NotXc20Token()');\n        if (wrapped[axelarToken] != address(0)) revert('AlreadyWrappingAxelarToken()');\n        if (unwrapped[xc20Token] != address(0)) revert('AlreadyWrappingXC20Token()');\n        wrapped[axelarToken] = xc20Token;\n        unwrapped[xc20Token] = axelarToken;\n        if (!LocalAsset(xc20Token).set_team(address(this), address(this), address(this))) revert('NotOwner()');\n        if (!LocalAsset(xc20Token).set_metadata(newName, newSymbol, IERC20(axelarToken).decimals())) revert('CannotSetMetadata()');\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function removeWrapping(string calldata symbol) external onlyOwner {\n        address axelarToken = gateway().tokenAddresses(symbol);\n        if (axelarToken == address(0)) revert('NotAxelarToken()');\n        address xc20Token = wrapped[axelarToken];\n        if (xc20Token == address(0)) revert('NotWrappingToken()');\n        wrapped[axelarToken] = address(0);\n        unwrapped[xc20Token] = address(0);\n    }\n\n    function wrap(address axelarToken, uint256 amount) external {\n        _safeTransferFrom(axelarToken, msg.sender, amount);\n        address wrappedToken = wrapped[axelarToken];\n        if (wrappedToken == address(0)) revert('NotAxelarToken()');\n        if (!LocalAsset(wrappedToken).mint(msg.sender, amount)) revert('CannotMint()');\n    }\n\n    function unwrap(address wrappedToken, uint256 amount) external {\n        address axelarToken = unwrapped[wrappedToken];\n        if (axelarToken == address(0)) revert('NotXc20Token()');\n        if (IERC20(wrappedToken).balanceOf(msg.sender) < amount) revert('InsufficientBalance()');\n        if (!LocalAsset(wrappedToken).burn(msg.sender, amount)) revert('CannotBurn()');\n        _safeTransfer(axelarToken, msg.sender, amount);\n    }\n\n    function _safeTransfer(\n        address tokenAddress,\n        address receiver,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert('TransferFailed()');\n    }\n\n    function _safeTransferFrom(\n        address tokenAddress,\n        address from,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert('TransferFailed()');\n    }\n\n    function _executeWithToken(\n        string calldata,\n        string calldata,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal override {\n        address receiver = abi.decode(payload, (address));\n        address tokenAddress = gateway().tokenAddresses(tokenSymbol);\n        address xc20 = wrapped[tokenAddress];\n        if (xc20 == address(0) || !LocalAsset(xc20).mint(receiver, amount)) {\n            _safeTransfer(tokenAddress, receiver, amount);\n        }\n    }\n}"
    }
  ]
}