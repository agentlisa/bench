{
  "Title": "[M-02] DoS and gas griefing of calls to Prime.updateScores()",
  "Content": "\n<https://github.com/code-423n4/2023-09-venus/blob/main/contracts/Tokens/Prime/Prime.sol#L200-L230> \n\n<https://github.com/code-423n4/2023-09-venus/blob/main/tests/hardhat/Prime/Prime.ts#L294-L301>\n\n`updateScores()` is meant to be called to update the scores of many users after reward alpha is changed or reward multipliers are changed. An attacker can cause calls to `Prime.updateScores()` to out-of-gas revert, delaying score updates. Rewards will be distributed incorrectly until scores are properly updated.\n\n### Proof of Concept\n\n`updateScores()` will run out of gas and revert if any of the `users` passed in the argument array have already been updated. This is due to the `continue` statement and the incrementing location of `i`:\n\n        function updateScores(address[] memory users) external {\n            if (pendingScoreUpdates == 0) revert NoScoreUpdatesRequired();\n            if (nextScoreUpdateRoundId == 0) revert NoScoreUpdatesRequired();\n\n            for (uint256 i = 0; i < users.length; ) {\n                address user = users[i];\n\n                if (!tokens[user].exists) revert UserHasNoPrimeToken();\n                if (isScoreUpdated[nextScoreUpdateRoundId][user]) continue;\n                ...\n                unchecked {\n                    i++;\n                }\n\n                emit UserScoreUpdated(user);\n            }\n        }\n\nAn attacker can frontrun calls to `updateScores()` with a call to `updateScores()`, passing in a 1-member array of one of the addresses in the frontran call's argument array. The frontran call will run out of gas and revert, and only one of the users intended to be updated will actually be updated.\n\n### Test\n\nPaste and run the below test in the 'mint and burn' scenario in Prime.ts (line 302)\n\n        it(\"dos_updateScores\", async () => {\n          //setup 3 users\n          await prime.issue(true, [user1.getAddress(), user2.getAddress(), user3.getAddress()]);\n          await xvs.connect(user1).approve(xvsVault.address, bigNumber18.mul(1000));\n          await xvsVault.connect(user1).deposit(xvs.address, 0, bigNumber18.mul(1000));\n          await xvs.connect(user2).approve(xvsVault.address, bigNumber18.mul(1000));\n          await xvsVault.connect(user2).deposit(xvs.address, 0, bigNumber18.mul(1000));\n          await xvs.connect(user3).approve(xvsVault.address, bigNumber18.mul(1000));\n          await xvsVault.connect(user3).deposit(xvs.address, 0, bigNumber18.mul(1000));\n          //change alpha\n          await prime.updateAlpha(1, 5);\n          //user 1 frontruns updateScores([many users]) with updateScores([solely user3])\n          await prime.connect(user1).updateScores([user3.getAddress()])\n          //frontran call should revert\n          await expect(prime.updateScores([user1.getAddress(), user2.getAddress(), user3.getAddress()])).to.be.reverted;\n        });\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nIncrement `i` such that `continue` doesn't result in infinite looping:\n\n```diff\n    function updateScores(address[] memory users) external {\n        ...\n+       for (uint256 i = 0; i < users.length; ++i} ) {\n-       for (uint256 i = 0; i < users.length; ) {\n            ...\n-           unchecked {\n-               i++;\n-           }\n            ...\n        }\n    }\n```\n\n**[0xRobocop (Lookout) commented](https://github.com/code-423n4/2023-09-venus-findings/issues/556#issuecomment-1747724530):**\n > Finding is correct. The function `updateScore` will unsuccessfully increment `i` and hence will not skip the user, causing the call to revert.\n> \n> Consider QA, since the function can be called again.\n> \n> Marking as primary for sponsor review anyways.\n\n**[chechu (Venus) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-09-venus-findings/issues/556#issuecomment-1777561604):**\n > Consider QA.\n> \n> `updateScores` could be invoked again.\n\n**[0xDjango (Judge) commented](https://github.com/code-423n4/2023-09-venus-findings/issues/556#issuecomment-1787703933):**\n > I agree with medium severity. Take the scenario where each user update costs 10\\_000 gas.\n> \n> - 100 users need to be updated = `10_000 * 100` = 1\\_000\\_000 gas.\n> - Attacker frontruns as described above, costing themselves ~10,000 gas.\n> - OOG error will cause original caller to spend 1\\_000\\_000 gas.\n> - Original caller tries again.\n> - Attacker frontruns again.\n> - OOG error will cause original caller to spend another 1\\_000\\_000 gas.\n> \n> This griefing attack can cause a significant amount of required spending. \n\n**[chechu (Venus) commented](https://github.com/code-423n4/2023-09-venus-findings/issues/556#issuecomment-1828139845):**\n > Fixed [here](https://github.com/VenusProtocol/venus-protocol/commit/fc6a76e29c6b59a03a9ca8f5b4072aa2b9492fa7).\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-venus",
  "Code": [
    {
      "filename": "contracts/Tokens/Prime/Prime.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable, IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { ResilientOracleInterface } from \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { MaxLoopsLimitHelper } from \"@venusprotocol/isolated-pools/contracts/MaxLoopsLimitHelper.sol\";\n\nimport { PrimeStorageV1 } from \"./PrimeStorage.sol\";\nimport { Scores } from \"./libs/Scores.sol\";\n\nimport { IPrimeLiquidityProvider } from \"./Interfaces/IPrimeLiquidityProvider.sol\";\nimport { IXVSVault } from \"./Interfaces/IXVSVault.sol\";\nimport { IVToken } from \"./Interfaces/IVToken.sol\";\nimport { IProtocolShareReserve } from \"./Interfaces/IProtocolShareReserve.sol\";\nimport { IIncomeDestination } from \"./Interfaces/IIncomeDestination.sol\";\nimport { InterfaceComptroller } from \"./Interfaces/InterfaceComptroller.sol\";\n\nerror MarketNotSupported();\nerror InvalidLimit();\nerror IneligibleToClaim();\nerror WaitMoreTime();\nerror UserHasNoPrimeToken();\nerror InvalidCaller();\nerror InvalidComptroller();\nerror NoScoreUpdatesRequired();\nerror MarketAlreadyExists();\nerror InvalidAddress();\nerror InvalidBlocksPerYear();\nerror InvalidAlphaArguments();\nerror InvalidVToken();\n\n/// @custom:security-contact https://github.com/VenusProtocol/venus-protocol\ncontract Prime is IIncomeDestination, AccessControlledV8, PausableUpgradeable, MaxLoopsLimitHelper, PrimeStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice total blocks per year\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint256 public immutable BLOCKS_PER_YEAR;\n\n    /// @notice address of WBNB contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable WBNB;\n\n    /// @notice address of VBNB contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable VBNB;\n\n    /// @notice Emitted when prime token is minted\n    event Mint(address indexed user, bool isIrrevocable);\n\n    /// @notice Emitted when prime token is burned\n    event Burn(address indexed user);\n\n    /// @notice Emitted asset state is update by protocol share reserve\n    event UpdatedAssetsState(address indexed comptroller, address indexed asset);\n\n    /// @notice Emitted when a market is added to prime program\n    event MarketAdded(address indexed market, uint256 indexed supplyMultiplier, uint256 indexed borrowMultiplier);\n\n    /// @notice Emitted when mint limits are updated\n    event MintLimitsUpdated(\n        uint256 indexed oldIrrevocableLimit,\n        uint256 indexed oldRevocableLimit,\n        uint256 indexed newIrrevocableLimit,\n        uint256 newRevocableLimit\n    );\n\n    /// @notice Emitted when user score is updated\n    event UserScoreUpdated(address indexed user);\n\n    /// @notice Emitted when alpha is updated\n    event AlphaUpdated(\n        uint128 indexed oldNumerator,\n        uint128 indexed oldDenominator,\n        uint128 indexed newNumerator,\n        uint128 newDenominator\n    );\n\n    /// @notice Emitted when multiplier is updated\n    event MultiplierUpdated(\n        address indexed market,\n        uint256 indexed oldSupplyMultiplier,\n        uint256 indexed oldBorrowMultiplier,\n        uint256 newSupplyMultiplier,\n        uint256 newBorrowMultiplier\n    );\n\n    /// @notice Emitted when interest is claimed\n    event InterestClaimed(address indexed user, address indexed market, uint256 amount);\n\n    /// @notice Emitted when revocable token is upgraded to irrevocable token\n    event TokenUpgraded(address indexed user);\n\n    /**\n     * @notice Prime constructor\n     * @param _wbnb Address of WBNB\n     * @param _vbnb Address of VBNB\n     * @param _blocksPerYear total blocks per year\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _wbnb, address _vbnb, uint256 _blocksPerYear) {\n        if (_wbnb == address(0)) revert InvalidAddress();\n        if (_vbnb == address(0)) revert InvalidAddress();\n        if (_blocksPerYear == 0) revert InvalidBlocksPerYear();\n        WBNB = _wbnb;\n        VBNB = _vbnb;\n        BLOCKS_PER_YEAR = _blocksPerYear;\n\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Prime initializer\n     * @param _xvsVault Address of XVSVault\n     * @param _xvsVaultRewardToken Address of XVSVault reward token\n     * @param _xvsVaultPoolId Pool id of XVSVault\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\n     * @param _accessControlManager Address of AccessControlManager\n     * @param _protocolShareReserve Address of ProtocolShareReserve\n     * @param _primeLiquidityProvider Address of PrimeLiquidityProvider\n     * @param _comptroller Address of Comptroller\n     * @param _oracle Address of Oracle\n     * @param _loopsLimit Maximum number of loops allowed in a single transaction\n     */\n    function initialize(\n        address _xvsVault,\n        address _xvsVaultRewardToken,\n        uint256 _xvsVaultPoolId,\n        uint128 _alphaNumerator,\n        uint128 _alphaDenominator,\n        address _accessControlManager,\n        address _protocolShareReserve,\n        address _primeLiquidityProvider,\n        address _comptroller,\n        address _oracle,\n        uint256 _loopsLimit\n    ) external virtual initializer {\n        if (_xvsVault == address(0)) revert InvalidAddress();\n        if (_xvsVaultRewardToken == address(0)) revert InvalidAddress();\n        if (_protocolShareReserve == address(0)) revert InvalidAddress();\n        if (_comptroller == address(0)) revert InvalidAddress();\n        if (_oracle == address(0)) revert InvalidAddress();\n        if (_primeLiquidityProvider == address(0)) revert InvalidAddress();\n        _checkAlphaArguments(_alphaNumerator, _alphaDenominator);\n\n        alphaNumerator = _alphaNumerator;\n        alphaDenominator = _alphaDenominator;\n        xvsVaultRewardToken = _xvsVaultRewardToken;\n        xvsVaultPoolId = _xvsVaultPoolId;\n        xvsVault = _xvsVault;\n        nextScoreUpdateRoundId = 0;\n        protocolShareReserve = _protocolShareReserve;\n        primeLiquidityProvider = _primeLiquidityProvider;\n        comptroller = _comptroller;\n        oracle = ResilientOracleInterface(_oracle);\n\n        __AccessControlled_init(_accessControlManager);\n        __Pausable_init();\n        _setMaxLoopsLimit(_loopsLimit);\n\n        _pause();\n    }\n\n    /**\n     * @notice Returns boosted pending interest accrued for a user for all markets\n     * @param user the account for which to get the accrued interests\n     * @return pendingInterests the number of underlying tokens accrued by the user for all markets\n     */\n    function getPendingInterests(address user) external returns (PendingInterest[] memory pendingInterests) {\n        address[] storage _allMarkets = allMarkets;\n        PendingInterest[] memory pendingInterests = new PendingInterest[](_allMarkets.length);\n\n        for (uint256 i = 0; i < _allMarkets.length; ) {\n            address market = _allMarkets[i];\n            uint256 interestAccrued = getInterestAccrued(market, user);\n            uint256 accrued = interests[market][user].accrued;\n\n            pendingInterests[i] = PendingInterest({\n                market: IVToken(market).underlying(),\n                amount: interestAccrued + accrued\n            });\n\n            unchecked {\n                i++;\n            }\n        }\n\n        return pendingInterests;\n    }\n\n    /**\n     * @notice Update total score of multiple users and market\n     * @param users accounts for which we need to update score\n     */\n    function updateScores(address[] memory users) external {\n        if (pendingScoreUpdates == 0) revert NoScoreUpdatesRequired();\n        if (nextScoreUpdateRoundId == 0) revert NoScoreUpdatesRequired();\n\n        for (uint256 i = 0; i < users.length; ) {\n            address user = users[i];\n\n            if (!tokens[user].exists) revert UserHasNoPrimeToken();\n            if (isScoreUpdated[nextScoreUpdateRoundId][user]) continue;\n\n            address[] storage _allMarkets = allMarkets;\n            for (uint256 j = 0; j < _allMarkets.length; ) {\n                address market = _allMarkets[j];\n                _executeBoost(user, market);\n                _updateScore(user, market);\n\n                unchecked {\n                    j++;\n                }\n            }\n\n            pendingScoreUpdates--;\n            isScoreUpdated[nextScoreUpdateRoundId][user] = true;\n\n            unchecked {\n                i++;\n            }\n\n            emit UserScoreUpdated(user);\n        }\n    }\n\n    /**\n     * @notice Update value of alpha\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\n     */\n    function updateAlpha(uint128 _alphaNumerator, uint128 _alphaDenominator) external {\n        _checkAccessAllowed(\"updateAlpha(uint128,uint128)\");\n        _checkAlphaArguments(_alphaNumerator, _alphaDenominator);\n\n        emit AlphaUpdated(alphaNumerator, alphaDenominator, _alphaNumerator, _alphaDenominator);\n\n        alphaNumerator = _alphaNumerator;\n        alphaDenominator = _alphaDenominator;\n\n        for (uint256 i = 0; i < allMarkets.length; ) {\n            accrueInterest(allMarkets[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        _startScoreUpdateRound();\n    }\n\n    /**\n     * @notice Update multipliers for a market\n     * @param market address of the market vToken\n     * @param supplyMultiplier new supply multiplier for the market, scaled by 1e18\n     * @param borrowMultiplier new borrow multiplier for the market, scaled by 1e18\n     */\n    function updateMultipliers(address market, uint256 supplyMultiplier, uint256 borrowMultiplier) external {\n        _checkAccessAllowed(\"updateMultipliers(address,uint256,uint256)\");\n        if (!markets[market].exists) revert MarketNotSupported();\n\n        accrueInterest(market);\n\n        emit MultiplierUpdated(\n            market,\n            markets[market].supplyMultiplier,\n            markets[market].borrowMultiplier,\n            supplyMultiplier,\n            borrowMultiplier\n        );\n        markets[market].supplyMultiplier = supplyMultiplier;\n        markets[market].borrowMultiplier = borrowMultiplier;\n\n        _startScoreUpdateRound();\n    }\n\n    /**\n     * @notice Add a market to prime program\n     * @param vToken address of the market vToken\n     * @param supplyMultiplier the multiplier for supply cap. It should be converted to 1e18\n     * @param borrowMultiplier the multiplier for borrow cap. It should be converted to 1e18\n     */\n    function addMarket(address vToken, uint256 supplyMultiplier, uint256 borrowMultiplier) external {\n        _checkAccessAllowed(\"addMarket(address,uint256,uint256)\");\n        if (markets[vToken].exists) revert MarketAlreadyExists();\n\n        bool isMarketExist = InterfaceComptroller(comptroller).markets(vToken);\n        if (!isMarketExist) revert InvalidVToken();\n\n        markets[vToken].rewardIndex = 0;\n        markets[vToken].supplyMultiplier = supplyMultiplier;\n        markets[vToken].borrowMultiplier = borrowMultiplier;\n        markets[vToken].sumOfMembersScore = 0;\n        markets[vToken].exists = true;\n\n        vTokenForAsset[_getUnderlying(vToken)] = vToken;\n\n        allMarkets.push(vToken);\n        _startScoreUpdateRound();\n\n        _ensureMaxLoops(allMarkets.length);\n\n        emit MarketAdded(vToken, supplyMultiplier, borrowMultiplier);\n    }\n\n    /**\n     * @notice Set limits for total tokens that can be minted\n     * @param _irrevocableLimit total number of irrevocable tokens that can be minted\n     * @param _revocableLimit total number of revocable tokens that can be minted\n     */\n    function setLimit(uint256 _irrevocableLimit, uint256 _revocableLimit) external {\n        _checkAccessAllowed(\"setLimit(uint256,uint256)\");\n        if (_irrevocableLimit < totalIrrevocable || _revocableLimit < totalRevocable) revert InvalidLimit();\n\n        emit MintLimitsUpdated(irrevocableLimit, revocableLimit, _irrevocableLimit, _revocableLimit);\n\n        revocableLimit = _revocableLimit;\n        irrevocableLimit = _irrevocableLimit;\n    }\n\n    /**\n     * @notice Directly issue prime tokens to users\n     * @param isIrrevocable are the tokens being issued\n     * @param users list of address to issue tokens to\n     */\n    function issue(bool isIrrevocable, address[] calldata users) external {\n        _checkAccessAllowed(\"issue(bool,address[])\");\n\n        if (isIrrevocable) {\n            for (uint256 i = 0; i < users.length; ) {\n                Token storage userToken = tokens[users[i]];\n                if (userToken.exists && !userToken.isIrrevocable) {\n                    _upgrade(users[i]);\n                } else {\n                    _mint(true, users[i]);\n                    _initializeMarkets(users[i]);\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < users.length; ) {\n                _mint(false, users[i]);\n                _initializeMarkets(users[i]);\n                delete stakedAt[users[i]];\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Executed by XVSVault whenever user's XVSVault balance changes\n     * @param user the account address whose balance was updated\n     */\n    function xvsUpdated(address user) external {\n        uint256 totalStaked = _xvsBalanceOfUser(user);\n        bool isAccountEligible = isEligible(totalStaked);\n\n        if (tokens[user].exists && !isAccountEligible) {\n            if (tokens[user].isIrrevocable) {\n                _accrueInterestAndUpdateScore(user);\n            } else {\n                _burn(user);\n            }\n        } else if (!isAccountEligible && !tokens[user].exists && stakedAt[user] > 0) {\n            stakedAt[user] = 0;\n        } else if (stakedAt[user] == 0 && isAccountEligible && !tokens[user].exists) {\n            stakedAt[user] = block.timestamp;\n        } else if (tokens[user].exists && isAccountEligible) {\n            _accrueInterestAndUpdateScore(user);\n        }\n    }\n\n    /**\n     * @notice accrues interes and updates score for an user for a specific market\n     * @param user the account address for which to accrue interest and update score\n     * @param market the market for which to accrue interest and update score\n     */\n    function accrueInterestAndUpdateScore(address user, address market) external {\n        _executeBoost(user, market);\n        _updateScore(user, market);\n    }\n\n    /**\n     * @notice For claiming prime token when staking period is completed\n     */\n    function claim() external {\n        if (stakedAt[msg.sender] == 0) revert IneligibleToClaim();\n        if (block.timestamp - stakedAt[msg.sender] < STAKING_PERIOD) revert WaitMoreTime();\n\n        stakedAt[msg.sender] = 0;\n\n        _mint(false, msg.sender);\n        _initializeMarkets(msg.sender);\n    }\n\n    /**\n     * @notice For burning any prime token\n     * @param user the account address for which the prime token will be burned\n     */\n    function burn(address user) external {\n        _checkAccessAllowed(\"burn(address)\");\n        _burn(user);\n    }\n\n    /**\n     * @notice To pause or unpause claiming of interest\n     */\n    function togglePause() external {\n        _checkAccessAllowed(\"togglePause()\");\n        if (paused()) {\n            _unpause();\n        } else {\n            _pause();\n        }\n    }\n\n    /**\n     * @notice For user to claim boosted yield\n     * @param vToken the market for which claim the accrued interest\n     * @return amount the amount of tokens transferred to the user\n     */\n    function claimInterest(address vToken) external whenNotPaused returns (uint256) {\n        return _claimInterest(vToken, msg.sender);\n    }\n\n    /**\n     * @notice For user to claim boosted yield\n     * @param vToken the market for which claim the accrued interest\n     * @param user the user for which claim the accrued interest\n     * @return amount the amount of tokens transferred to the user\n     */\n    function claimInterest(address vToken, address user) external whenNotPaused returns (uint256) {\n        return _claimInterest(vToken, user);\n    }\n\n    /**\n     * @notice Callback by ProtocolShareReserve to update assets state when funds are released to this contract\n     * @param _comptroller The address of the Comptroller whose income is distributed\n     * @param asset The address of the asset whose income is distributed\n     */\n    function updateAssetsState(address _comptroller, address asset) external {\n        if (msg.sender != protocolShareReserve) revert InvalidCaller();\n        if (comptroller != _comptroller) revert InvalidComptroller();\n\n        address vToken = vTokenForAsset[asset];\n        if (vToken == address(0)) revert MarketNotSupported();\n\n        IVToken market = IVToken(vToken);\n        unreleasedPSRIncome[_getUnderlying(address(market))] = 0;\n\n        emit UpdatedAssetsState(comptroller, asset);\n    }\n\n    /**\n     * @notice Retrieves an array of all available markets\n     * @return an array of addresses representing all available markets\n     */\n    function getAllMarkets() external view returns (address[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice fetch the numbers of seconds remaining for staking period to complete\n     * @param user the account address for which we are checking the remaining time\n     * @return timeRemaining the number of seconds the user needs to wait to claim prime token\n     */\n    function claimTimeRemaining(address user) external view returns (uint256) {\n        if (stakedAt[user] == 0) return STAKING_PERIOD;\n\n        uint256 totalTimeStaked = block.timestamp - stakedAt[user];\n        if (totalTimeStaked < STAKING_PERIOD) {\n            return STAKING_PERIOD - totalTimeStaked;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns supply and borrow APR for user for a given market\n     * @param market the market for which to fetch the APR\n     * @param user the account for which to get the APR\n     * @return supplyAPR supply APR of the user in BPS\n     * @return borrowAPR borrow APR of the user in BPS\n     */\n    function calculateAPR(address market, address user) external view returns (uint256 supplyAPR, uint256 borrowAPR) {\n        IVToken vToken = IVToken(market);\n        uint256 borrow = vToken.borrowBalanceStored(user);\n        uint256 exchangeRate = vToken.exchangeRateStored();\n        uint256 balanceOfAccount = vToken.balanceOf(user);\n        uint256 supply = (exchangeRate * balanceOfAccount) / EXP_SCALE;\n\n        uint256 userScore = interests[market][user].score;\n        uint256 totalScore = markets[market].sumOfMembersScore;\n\n        uint256 xvsBalanceForScore = _xvsBalanceForScore(_xvsBalanceOfUser(user));\n        (, uint256 cappedSupply, uint256 cappedBorrow) = _capitalForScore(\n            xvsBalanceForScore,\n            borrow,\n            supply,\n            address(vToken)\n        );\n\n        return _calculateUserAPR(market, supply, borrow, cappedSupply, cappedBorrow, userScore, totalScore);\n    }\n\n    /**\n     * @notice Returns supply and borrow APR for estimated supply, borrow and XVS staked\n     * @param market the market for which to fetch the APR\n     * @param user the account for which to get the APR\n     * @param borrow hypothetical borrow amount\n     * @param supply hypothetical supply amount\n     * @param xvsStaked hypothetical staked XVS amount\n     * @return supplyAPR supply APR of the user in BPS\n     * @return borrowAPR borrow APR of the user in BPS\n     */\n    function estimateAPR(\n        address market,\n        address user,\n        uint256 borrow,\n        uint256 supply,\n        uint256 xvsStaked\n    ) external view returns (uint256 supplyAPR, uint256 borrowAPR) {\n        uint256 totalScore = markets[market].sumOfMembersScore - interests[market][user].score;\n\n        uint256 xvsBalanceForScore = _xvsBalanceForScore(xvsStaked);\n        (uint256 capital, uint256 cappedSupply, uint256 cappedBorrow) = _capitalForScore(\n            xvsBalanceForScore,\n            borrow,\n            supply,\n            market\n        );\n        uint256 userScore = Scores.calculateScore(xvsBalanceForScore, capital, alphaNumerator, alphaDenominator);\n\n        totalScore = totalScore + userScore;\n\n        return _calculateUserAPR(market, supply, borrow, cappedSupply, cappedBorrow, userScore, totalScore);\n    }\n\n    /**\n     * @notice Distributes income from market since last distribution\n     * @param vToken the market for which to distribute the income\n     */\n    function accrueInterest(address vToken) public {\n        if (!markets[vToken].exists) revert MarketNotSupported();\n\n        address underlying = _getUnderlying(vToken);\n\n        IPrimeLiquidityProvider _primeLiquidityProvider = IPrimeLiquidityProvider(primeLiquidityProvider);\n\n        uint256 totalIncomeUnreleased = IProtocolShareReserve(protocolShareReserve).getUnreleasedFunds(\n            comptroller,\n            IProtocolShareReserve.Schema.SPREAD_PRIME_CORE,\n            address(this),\n            underlying\n        );\n\n        uint256 distributionIncome = totalIncomeUnreleased - unreleasedPSRIncome[underlying];\n\n        _primeLiquidityProvider.accrueTokens(underlying);\n        uint256 totalAccruedInPLP = _primeLiquidityProvider.tokenAmountAccrued(underlying);\n        uint256 unreleasedPLPAccruedInterest = totalAccruedInPLP - unreleasedPLPIncome[underlying];\n\n        distributionIncome += unreleasedPLPAccruedInterest;\n\n        if (distributionIncome == 0) {\n            return;\n        }\n\n        unreleasedPSRIncome[underlying] = totalIncomeUnreleased;\n        unreleasedPLPIncome[underlying] = totalAccruedInPLP;\n\n        uint256 delta;\n        if (markets[vToken].sumOfMembersScore > 0) {\n            delta = ((distributionIncome * EXP_SCALE) / markets[vToken].sumOfMembersScore);\n        }\n\n        markets[vToken].rewardIndex = markets[vToken].rewardIndex + delta;\n    }\n\n    /**\n     * @notice Returns boosted interest accrued for a user\n     * @param vToken the market for which to fetch the accrued interest\n     * @param user the account for which to get the accrued interest\n     * @return interestAccrued the number of underlying tokens accrued by the user since the last accrual\n     */\n    function getInterestAccrued(address vToken, address user) public returns (uint256) {\n        accrueInterest(vToken);\n\n        return _interestAccrued(vToken, user);\n    }\n\n    /**\n     * @notice accrues interes and updates score of all markets for an user\n     * @param user the account address for which to accrue interest and update score\n     */\n    function _accrueInterestAndUpdateScore(address user) internal {\n        address[] storage _allMarkets = allMarkets;\n        for (uint256 i = 0; i < _allMarkets.length; ) {\n            _executeBoost(user, _allMarkets[i]);\n            _updateScore(user, _allMarkets[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @notice Initializes all the markets for the user when a prime token is minted\n     * @param account the account address for which markets needs to be initialized\n     */\n    function _initializeMarkets(address account) internal {\n        address[] storage _allMarkets = allMarkets;\n        for (uint256 i = 0; i < _allMarkets.length; ) {\n            address market = _allMarkets[i];\n            accrueInterest(market);\n\n            interests[market][account].rewardIndex = markets[market].rewardIndex;\n\n            uint256 score = _calculateScore(market, account);\n            interests[market][account].score = score;\n            markets[market].sumOfMembersScore = markets[market].sumOfMembersScore + score;\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @notice calculate the current score of user\n     * @param market the market for which to calculate the score\n     * @param user the account for which to calculate the score\n     * @return score the score of the user\n     */\n    function _calculateScore(address market, address user) internal returns (uint256) {\n        uint256 xvsBalanceForScore = _xvsBalanceForScore(_xvsBalanceOfUser(user));\n\n        IVToken vToken = IVToken(market);\n        uint256 borrow = vToken.borrowBalanceStored(user);\n        uint256 exchangeRate = vToken.exchangeRateStored();\n        uint256 balanceOfAccount = vToken.balanceOf(user);\n        uint256 supply = (exchangeRate * balanceOfAccount) / EXP_SCALE;\n\n        address xvsToken = IXVSVault(xvsVault).xvsAddress();\n        oracle.updateAssetPrice(xvsToken);\n        oracle.updatePrice(market);\n\n        (uint256 capital, , ) = _capitalForScore(xvsBalanceForScore, borrow, supply, market);\n        capital = capital * (10 ** (18 - vToken.decimals()));\n\n        return Scores.calculateScore(xvsBalanceForScore, capital, alphaNumerator, alphaDenominator);\n    }\n\n    /**\n     * @notice To transfer the accrued interest to user\n     * @param vToken the market for which to claim\n     * @param user the account for which to get the accrued interest\n     * @return amount the amount of tokens transferred to the user\n     */\n    function _claimInterest(address vToken, address user) internal returns (uint256) {\n        uint256 amount = getInterestAccrued(vToken, user);\n        amount += interests[vToken][user].accrued;\n\n        interests[vToken][user].rewardIndex = markets[vToken].rewardIndex;\n        interests[vToken][user].accrued = 0;\n\n        address underlying = _getUnderlying(vToken);\n        IERC20Upgradeable asset = IERC20Upgradeable(underlying);\n\n        if (amount > asset.balanceOf(address(this))) {\n            address[] memory assets = new address[](1);\n            assets[0] = address(asset);\n            IProtocolShareReserve(protocolShareReserve).releaseFunds(comptroller, assets);\n            if (amount > asset.balanceOf(address(this))) {\n                IPrimeLiquidityProvider(primeLiquidityProvider).releaseFunds(address(asset));\n                unreleasedPLPIncome[underlying] = 0;\n            }\n        }\n\n        asset.safeTransfer(user, amount);\n\n        emit InterestClaimed(user, vToken, amount);\n\n        return amount;\n    }\n\n    /**\n     * @notice Used to mint a new prime token\n     * @param isIrrevocable is the tokens being issued is irrevocable\n     * @param user token owner\n     */\n    function _mint(bool isIrrevocable, address user) internal {\n        if (tokens[user].exists) revert IneligibleToClaim();\n\n        tokens[user].exists = true;\n        tokens[user].isIrrevocable = isIrrevocable;\n\n        if (isIrrevocable) {\n            totalIrrevocable++;\n        } else {\n            totalRevocable++;\n        }\n\n        if (totalIrrevocable > irrevocableLimit || totalRevocable > revocableLimit) revert InvalidLimit();\n\n        emit Mint(user, isIrrevocable);\n    }\n\n    /**\n     * @notice Used to burn a new prime token\n     * @param user owner whose prime token to burn\n     */\n    function _burn(address user) internal {\n        if (!tokens[user].exists) revert UserHasNoPrimeToken();\n\n        address[] storage _allMarkets = allMarkets;\n\n        for (uint256 i = 0; i < _allMarkets.length; ) {\n            _executeBoost(user, _allMarkets[i]);\n\n            markets[_allMarkets[i]].sumOfMembersScore =\n                markets[_allMarkets[i]].sumOfMembersScore -\n                interests[_allMarkets[i]][user].score;\n            interests[_allMarkets[i]][user].score = 0;\n            interests[_allMarkets[i]][user].rewardIndex = 0;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        if (tokens[user].isIrrevocable) {\n            totalIrrevocable--;\n        } else {\n            totalRevocable--;\n        }\n\n        tokens[user].exists = false;\n        tokens[user].isIrrevocable = false;\n\n        _updateRoundAfterTokenBurned(user);\n\n        emit Burn(user);\n    }\n\n    /**\n     * @notice Used to upgrade an token\n     * @param user owner whose prime token to upgrade\n     */\n    function _upgrade(address user) internal {\n        Token storage userToken = tokens[user];\n\n        userToken.isIrrevocable = true;\n        totalIrrevocable++;\n        totalRevocable--;\n\n        if (totalIrrevocable > irrevocableLimit) revert InvalidLimit();\n\n        emit TokenUpgraded(user);\n    }\n\n    /**\n     * @notice Accrue rewards for the user. Must be called by Comptroller before changing account's borrow or supply balance.\n     * @param user account for which we need to accrue rewards\n     * @param vToken the market for which we need to accrue rewards\n     */\n    function _executeBoost(address user, address vToken) internal {\n        if (!markets[vToken].exists || !tokens[user].exists) {\n            return;\n        }\n\n        accrueInterest(vToken);\n        interests[vToken][user].accrued += _interestAccrued(vToken, user);\n        interests[vToken][user].rewardIndex = markets[vToken].rewardIndex;\n    }\n\n    /**\n     * @notice Update total score of user and market. Must be called after changing account's borrow or supply balance.\n     * @param user account for which we need to update score\n     * @param market the market for which we need to score\n     */\n    function _updateScore(address user, address market) internal {\n        if (!markets[market].exists || !tokens[user].exists) {\n            return;\n        }\n\n        uint256 score = _calculateScore(market, user);\n        markets[market].sumOfMembersScore = markets[market].sumOfMembersScore - interests[market][user].score + score;\n        interests[market][user].score = score;\n    }\n\n    /**\n     * @notice Verify new alpha arguments\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\n     */\n    function _checkAlphaArguments(uint128 _alphaNumerator, uint128 _alphaDenominator) internal {\n        if (_alphaDenominator == 0 || _alphaNumerator > _alphaDenominator) {\n            revert InvalidAlphaArguments();\n        }\n    }\n\n    /**\n     * @notice starts round to update scores of a particular or all markets\n     */\n    function _startScoreUpdateRound() internal {\n        nextScoreUpdateRoundId++;\n        totalScoreUpdatesRequired = totalIrrevocable + totalRevocable;\n        pendingScoreUpdates = totalScoreUpdatesRequired;\n    }\n\n    /**\n     * @notice update the required score updates when token is burned before round is completed\n     */\n    function _updateRoundAfterTokenBurned(address user) internal {\n        if (totalScoreUpdatesRequired > 0) totalScoreUpdatesRequired--;\n\n        if (pendingScoreUpdates > 0 && !isScoreUpdated[nextScoreUpdateRoundId][user]) {\n            pendingScoreUpdates--;\n        }\n    }\n\n    /**\n     * @notice fetch the current XVS balance of user in the XVSVault\n     * @param user the account address\n     * @return xvsBalance the XVS balance of user\n     */\n    function _xvsBalanceOfUser(address user) internal view returns (uint256) {\n        (uint256 xvs, , uint256 pendingWithdrawals) = IXVSVault(xvsVault).getUserInfo(\n            xvsVaultRewardToken,\n            xvsVaultPoolId,\n            user\n        );\n        return (xvs - pendingWithdrawals);\n    }\n\n    /**\n     * @notice calculate the current XVS balance that will be used in calculation of score\n     * @param xvs the actual XVS balance of user\n     * @return xvsBalanceForScore the XVS balance to use in score\n     */\n    function _xvsBalanceForScore(uint256 xvs) internal view returns (uint256) {\n        if (xvs > MAXIMUM_XVS_CAP) {\n            return MAXIMUM_XVS_CAP;\n        } else {\n            return xvs;\n        }\n    }\n\n    /**\n     * @notice calculate the capital for calculation of score\n     * @param xvs the actual XVS balance of user\n     * @param borrow the borrow balance of user\n     * @param supply the supply balance of user\n     * @param market the market vToken address\n     * @return capital the capital to use in calculation of score\n     * @return cappedSupply the capped supply of user\n     * @return cappedBorrow the capped borrow of use"
    }
  ]
}