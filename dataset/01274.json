{
  "Title": "Farming can be deactivated by accident",
  "Content": "##### Description\nThe current check for farming deactivation can be triggered by accident if `tick` hasn't changed during the swap and `zeroToOne` is false https://github.com/cryptoalgebra/Algebra/blob/6f57b3e218630106a4d41aedefd38f9e83b41e2b/src/farming/contracts/farmings/EternalVirtualPool.sol#L131-L134. This action will disconnect farming from the pool and will affect incentive distribution for users.\n\n##### Recommendation\nWe recommend using this check https://github.com/cryptoalgebra/Algebra/blob/6f57b3e218630106a4d41aedefd38f9e83b41e2b/src/farming/contracts/farmings/EternalVirtualPool.sol#L137-L141 before setting the `deactive` state to the virtual pool.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/farming/contracts/farmings/EternalVirtualPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\npragma abicoder v1;\n\nimport '@cryptoalgebra/core/contracts/libraries/FullMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\nimport '@cryptoalgebra/core/contracts/libraries/TickMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/LiquidityMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/TickManagement.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPool.sol';\n\nimport '../base/VirtualTickStructure.sol';\n\n/// @title Algebra eternal virtual pool\n/// @notice used to track active liquidity in farming and distribute rewards\ncontract EternalVirtualPool is VirtualTickStructure {\n  using TickManagement for mapping(int24 => TickManagement.Tick);\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  uint128 public override currentLiquidity;\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  int24 public override globalTick;\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  uint32 public override prevTimestamp;\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  bool public override deactivated;\n\n  address public immutable farmingAddress;\n  address public immutable plugin;\n\n  uint128 internal rewardRate0;\n  uint128 internal rewardRate1;\n\n  uint128 internal rewardReserve0;\n  uint128 internal rewardReserve1;\n\n  uint256 internal totalRewardGrowth0 = 1;\n  uint256 internal totalRewardGrowth1 = 1;\n\n  modifier onlyFromFarming() {\n    _checkIsFromFarming();\n    _;\n  }\n\n  constructor(address _farmingAddress, address _plugin) {\n    farmingAddress = _farmingAddress;\n    plugin = _plugin;\n\n    prevTimestamp = uint32(block.timestamp);\n    globalPrevInitializedTick = TickMath.MIN_TICK;\n    globalNextInitializedTick = TickMath.MAX_TICK;\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function rewardReserves() external view override returns (uint128 reserve0, uint128 reserve1) {\n    return (rewardReserve0, rewardReserve1);\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function rewardRates() external view override returns (uint128 rate0, uint128 rate1) {\n    return (rewardRate0, rewardRate1);\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function totalRewardGrowth() external view override returns (uint256 rewardGrowth0, uint256 rewardGrowth1) {\n    return (totalRewardGrowth0, totalRewardGrowth1);\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function getInnerRewardsGrowth(\n    int24 bottomTick,\n    int24 topTick\n  ) external view override returns (uint256 rewardGrowthInside0, uint256 rewardGrowthInside1) {\n    unchecked {\n      // check if ticks are initialized\n      if (ticks[bottomTick].prevTick == ticks[bottomTick].nextTick || ticks[topTick].prevTick == ticks[topTick].nextTick)\n        revert IAlgebraPoolErrors.tickIsNotInitialized();\n\n      uint32 timeDelta = uint32(block.timestamp) - prevTimestamp;\n      int24 _globalTick = globalTick;\n\n      (uint256 _totalRewardGrowth0, uint256 _totalRewardGrowth1) = (totalRewardGrowth0, totalRewardGrowth1);\n\n      if (timeDelta > 0) {\n        // update rewards\n        uint128 _currentLiquidity = currentLiquidity;\n        if (_currentLiquidity > 0) {\n          (uint256 reward0, uint256 reward1) = (rewardRate0 * timeDelta, rewardRate1 * timeDelta);\n          (uint256 _rewardReserve0, uint256 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n\n          if (reward0 > _rewardReserve0) reward0 = _rewardReserve0;\n          if (reward1 > _rewardReserve1) reward1 = _rewardReserve1;\n\n          if (reward0 > 0) _totalRewardGrowth0 += FullMath.mulDiv(reward0, Constants.Q128, _currentLiquidity);\n          if (reward1 > 0) _totalRewardGrowth1 += FullMath.mulDiv(reward1, Constants.Q128, _currentLiquidity);\n        }\n      }\n\n      return ticks.getInnerFeeGrowth(bottomTick, topTick, _globalTick, _totalRewardGrowth0, _totalRewardGrowth1);\n    }\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function deactivate() external override onlyFromFarming {\n    deactivated = true;\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function addRewards(uint128 token0Amount, uint128 token1Amount) external override onlyFromFarming {\n    _applyRewardsDelta(true, token0Amount, token1Amount);\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function decreaseRewards(uint128 token0Amount, uint128 token1Amount) external override onlyFromFarming {\n    _applyRewardsDelta(false, token0Amount, token1Amount);\n  }\n\n  /// @inheritdoc IAlgebraVirtualPool\n  function crossTo(int24 targetTick, bool zeroToOne) external override returns (bool) {\n    if (msg.sender != plugin) revert onlyPlugin();\n\n    uint128 _currentLiquidity = currentLiquidity;\n    int24 _globalTick = globalTick;\n    uint32 _prevTimestamp = prevTimestamp;\n    bool _deactivated = deactivated;\n\n    int24 previousTick = globalPrevInitializedTick;\n    int24 nextTick = globalNextInitializedTick;\n\n    if (_deactivated) return false;\n    else if (targetTick > _globalTick == zeroToOne) {\n      deactivated = true; // deactivate if invalid input params (possibly desynchronization)\n      return false;\n    }\n\n    // early return if without any crosses\n    if (zeroToOne) {\n      if (targetTick >= previousTick) return true;\n    } else {\n      if (targetTick < nextTick) return true;\n    }\n\n    _distributeRewards(_prevTimestamp, _currentLiquidity);\n\n    (uint256 rewardGrowth0, uint256 rewardGrowth1) = (totalRewardGrowth0, totalRewardGrowth1);\n    // The set of active ticks in the virtual pool must be a subset of the active ticks in the real pool\n    // so this loop will cross no more ticks than the real pool\n    if (zeroToOne) {\n      while (_globalTick != TickMath.MIN_TICK) {\n        if (targetTick >= previousTick) break;\n        unchecked {\n          int128 liquidityDelta;\n          _globalTick = previousTick - 1; // safe since tick index range is narrower than the data type\n          (liquidityDelta, previousTick, nextTick) = ticks.cross(previousTick, rewardGrowth0, rewardGrowth1);\n          _currentLiquidity = LiquidityMath.addDelta(_currentLiquidity, -liquidityDelta);\n        }\n      }\n    } else {\n      while (_globalTick != TickMath.MAX_TICK - 1) {\n        if (targetTick < nextTick) break;\n        int128 liquidityDelta;\n        _globalTick = nextTick;\n        (liquidityDelta, previousTick, nextTick) = ticks.cross(nextTick, rewardGrowth0, rewardGrowth1);\n        _currentLiquidity = LiquidityMath.addDelta(_currentLiquidity, liquidityDelta);\n      }\n    }\n\n    currentLiquidity = _currentLiquidity;\n    globalTick = targetTick;\n\n    globalPrevInitializedTick = previousTick;\n    globalNextInitializedTick = nextTick;\n    return true;\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function distributeRewards() external override onlyFromFarming {\n    _distributeRewards();\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function applyLiquidityDeltaToPosition(\n    int24 bottomTick,\n    int24 topTick,\n    int128 liquidityDelta,\n    int24 currentTick\n  ) external override onlyFromFarming {\n    uint128 _currentLiquidity = currentLiquidity;\n    uint32 _prevTimestamp = prevTimestamp;\n    bool _deactivated = deactivated;\n    {\n      int24 _lastKnownTick = globalTick;\n      int24 _nextActiveTick = globalNextInitializedTick;\n      int24 _prevActiveTick = globalPrevInitializedTick;\n\n      if (\n        (currentTick < _nextActiveTick != _lastKnownTick < _nextActiveTick) || (currentTick >= _prevActiveTick != _lastKnownTick >= _prevActiveTick)\n      ) {\n        _deactivated = true;\n        deactivated = true;\n      }\n    }\n\n    if (!_deactivated) {\n      globalTick = currentTick;\n    }\n\n    if (uint32(block.timestamp) > _prevTimestamp) {\n      _distributeRewards(_prevTimestamp, _currentLiquidity);\n    }\n\n    if (liquidityDelta != 0) {\n      // if we need to update the ticks, do it\n\n      bool flippedBottom = _updateTick(bottomTick, currentTick, liquidityDelta, false);\n      bool flippedTop = _updateTick(topTick, currentTick, liquidityDelta, true);\n\n      if (currentTick >= bottomTick && currentTick < topTick) {\n        currentLiquidity = LiquidityMath.addDelta(_currentLiquidity, liquidityDelta);\n      }\n\n      if (flippedBottom || flippedTop) {\n        _addOrRemoveTicks(bottomTick, topTick, flippedBottom, flippedTop, currentTick, liquidityDelta < 0);\n      }\n    }\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function setRates(uint128 rate0, uint128 rate1) external override onlyFromFarming {\n    _distributeRewards();\n    (rewardRate0, rewardRate1) = (rate0, rate1);\n  }\n\n  function _checkIsFromFarming() internal view {\n    if (msg.sender != farmingAddress) revert onlyFarming();\n  }\n\n  function _applyRewardsDelta(bool add, uint128 token0Delta, uint128 token1Delta) private {\n    _distributeRewards();\n    if (token0Delta | token1Delta != 0) {\n      (uint128 _rewardReserve0, uint128 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n      if (add) {\n        _rewardReserve0 = _rewardReserve0 + token0Delta;\n        _rewardReserve1 = _rewardReserve1 + token1Delta;\n      } else {\n        _rewardReserve0 = _rewardReserve0 - token0Delta;\n        _rewardReserve1 = _rewardReserve1 - token1Delta;\n      }\n      (rewardReserve0, rewardReserve1) = (_rewardReserve0, _rewardReserve1);\n    }\n  }\n\n  function _distributeRewards() internal {\n    _distributeRewards(prevTimestamp, currentLiquidity);\n  }\n\n  function _distributeRewards(uint32 _prevTimestamp, uint256 _currentLiquidity) internal {\n    // currentLiquidity is uint128\n    unchecked {\n      uint256 timeDelta = uint32(block.timestamp) - _prevTimestamp; // safe until timedelta > 136 years\n      if (timeDelta == 0) return; // only once per block\n\n      if (_currentLiquidity > 0) {\n        (uint256 reward0, uint256 reward1) = (rewardRate0 * timeDelta, rewardRate1 * timeDelta);\n        (uint128 _rewardReserve0, uint128 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n\n        if (reward0 > _rewardReserve0) reward0 = _rewardReserve0;\n        if (reward1 > _rewardReserve1) reward1 = _rewardReserve1;\n\n        if (reward0 | reward1 != 0) {\n          _rewardReserve0 = uint128(_rewardReserve0 - reward0);\n          _rewardReserve1 = uint128(_rewardReserve1 - reward1);\n\n          if (reward0 > 0) totalRewardGrowth0 += FullMath.mulDiv(reward0, Constants.Q128, _currentLiquidity);\n          if (reward1 > 0) totalRewardGrowth1 += FullMath.mulDiv(reward1, Constants.Q128, _currentLiquidity);\n\n          (rewardReserve0, rewardReserve1) = (_rewardReserve0, _rewardReserve1);\n        }\n      }\n    }\n\n    prevTimestamp = uint32(block.timestamp);\n    return;\n  }\n\n  function _updateTick(int24 tick, int24 currentTick, int128 liquidityDelta, bool isTopTick) internal returns (bool updated) {\n    return ticks.update(tick, currentTick, liquidityDelta, totalRewardGrowth0, totalRewardGrowth1, isTopTick);\n  }\n}"
    },
    {
      "filename": "src/farming/contracts/farmings/EternalVirtualPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\npragma abicoder v1;\n\nimport '@cryptoalgebra/core/contracts/libraries/FullMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\nimport '@cryptoalgebra/core/contracts/libraries/TickMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/LiquidityMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/TickManagement.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPool.sol';\n\nimport '../base/VirtualTickStructure.sol';\n\n/// @title Algebra eternal virtual pool\n/// @notice used to track active liquidity in farming and distribute rewards\ncontract EternalVirtualPool is VirtualTickStructure {\n  using TickManagement for mapping(int24 => TickManagement.Tick);\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  uint128 public override currentLiquidity;\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  int24 public override globalTick;\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  uint32 public override prevTimestamp;\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  bool public override deactivated;\n\n  address public immutable farmingAddress;\n  address public immutable plugin;\n\n  uint128 internal rewardRate0;\n  uint128 internal rewardRate1;\n\n  uint128 internal rewardReserve0;\n  uint128 internal rewardReserve1;\n\n  uint256 internal totalRewardGrowth0 = 1;\n  uint256 internal totalRewardGrowth1 = 1;\n\n  modifier onlyFromFarming() {\n    _checkIsFromFarming();\n    _;\n  }\n\n  constructor(address _farmingAddress, address _plugin) {\n    farmingAddress = _farmingAddress;\n    plugin = _plugin;\n\n    prevTimestamp = uint32(block.timestamp);\n    globalPrevInitializedTick = TickMath.MIN_TICK;\n    globalNextInitializedTick = TickMath.MAX_TICK;\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function rewardReserves() external view override returns (uint128 reserve0, uint128 reserve1) {\n    return (rewardReserve0, rewardReserve1);\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function rewardRates() external view override returns (uint128 rate0, uint128 rate1) {\n    return (rewardRate0, rewardRate1);\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function totalRewardGrowth() external view override returns (uint256 rewardGrowth0, uint256 rewardGrowth1) {\n    return (totalRewardGrowth0, totalRewardGrowth1);\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function getInnerRewardsGrowth(\n    int24 bottomTick,\n    int24 topTick\n  ) external view override returns (uint256 rewardGrowthInside0, uint256 rewardGrowthInside1) {\n    unchecked {\n      // check if ticks are initialized\n      if (ticks[bottomTick].prevTick == ticks[bottomTick].nextTick || ticks[topTick].prevTick == ticks[topTick].nextTick)\n        revert IAlgebraPoolErrors.tickIsNotInitialized();\n\n      uint32 timeDelta = uint32(block.timestamp) - prevTimestamp;\n      int24 _globalTick = globalTick;\n\n      (uint256 _totalRewardGrowth0, uint256 _totalRewardGrowth1) = (totalRewardGrowth0, totalRewardGrowth1);\n\n      if (timeDelta > 0) {\n        // update rewards\n        uint128 _currentLiquidity = currentLiquidity;\n        if (_currentLiquidity > 0) {\n          (uint256 reward0, uint256 reward1) = (rewardRate0 * timeDelta, rewardRate1 * timeDelta);\n          (uint256 _rewardReserve0, uint256 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n\n          if (reward0 > _rewardReserve0) reward0 = _rewardReserve0;\n          if (reward1 > _rewardReserve1) reward1 = _rewardReserve1;\n\n          if (reward0 > 0) _totalRewardGrowth0 += FullMath.mulDiv(reward0, Constants.Q128, _currentLiquidity);\n          if (reward1 > 0) _totalRewardGrowth1 += FullMath.mulDiv(reward1, Constants.Q128, _currentLiquidity);\n        }\n      }\n\n      return ticks.getInnerFeeGrowth(bottomTick, topTick, _globalTick, _totalRewardGrowth0, _totalRewardGrowth1);\n    }\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function deactivate() external override onlyFromFarming {\n    deactivated = true;\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function addRewards(uint128 token0Amount, uint128 token1Amount) external override onlyFromFarming {\n    _applyRewardsDelta(true, token0Amount, token1Amount);\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function decreaseRewards(uint128 token0Amount, uint128 token1Amount) external override onlyFromFarming {\n    _applyRewardsDelta(false, token0Amount, token1Amount);\n  }\n\n  /// @inheritdoc IAlgebraVirtualPool\n  function crossTo(int24 targetTick, bool zeroToOne) external override returns (bool) {\n    if (msg.sender != plugin) revert onlyPlugin();\n\n    uint128 _currentLiquidity = currentLiquidity;\n    int24 _globalTick = globalTick;\n    uint32 _prevTimestamp = prevTimestamp;\n    bool _deactivated = deactivated;\n\n    int24 previousTick = globalPrevInitializedTick;\n    int24 nextTick = globalNextInitializedTick;\n\n    if (_deactivated) return false;\n    else if (targetTick > _globalTick == zeroToOne) {\n      deactivated = true; // deactivate if invalid input params (possibly desynchronization)\n      return false;\n    }\n\n    // early return if without any crosses\n    if (zeroToOne) {\n      if (targetTick >= previousTick) return true;\n    } else {\n      if (targetTick < nextTick) return true;\n    }\n\n    _distributeRewards(_prevTimestamp, _currentLiquidity);\n\n    (uint256 rewardGrowth0, uint256 rewardGrowth1) = (totalRewardGrowth0, totalRewardGrowth1);\n    // The set of active ticks in the virtual pool must be a subset of the active ticks in the real pool\n    // so this loop will cross no more ticks than the real pool\n    if (zeroToOne) {\n      while (_globalTick != TickMath.MIN_TICK) {\n        if (targetTick >= previousTick) break;\n        unchecked {\n          int128 liquidityDelta;\n          _globalTick = previousTick - 1; // safe since tick index range is narrower than the data type\n          (liquidityDelta, previousTick, nextTick) = ticks.cross(previousTick, rewardGrowth0, rewardGrowth1);\n          _currentLiquidity = LiquidityMath.addDelta(_currentLiquidity, -liquidityDelta);\n        }\n      }\n    } else {\n      while (_globalTick != TickMath.MAX_TICK - 1) {\n        if (targetTick < nextTick) break;\n        int128 liquidityDelta;\n        _globalTick = nextTick;\n        (liquidityDelta, previousTick, nextTick) = ticks.cross(nextTick, rewardGrowth0, rewardGrowth1);\n        _currentLiquidity = LiquidityMath.addDelta(_currentLiquidity, liquidityDelta);\n      }\n    }\n\n    currentLiquidity = _currentLiquidity;\n    globalTick = targetTick;\n\n    globalPrevInitializedTick = previousTick;\n    globalNextInitializedTick = nextTick;\n    return true;\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function distributeRewards() external override onlyFromFarming {\n    _distributeRewards();\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function applyLiquidityDeltaToPosition(\n    int24 bottomTick,\n    int24 topTick,\n    int128 liquidityDelta,\n    int24 currentTick\n  ) external override onlyFromFarming {\n    uint128 _currentLiquidity = currentLiquidity;\n    uint32 _prevTimestamp = prevTimestamp;\n    bool _deactivated = deactivated;\n    {\n      int24 _lastKnownTick = globalTick;\n      int24 _nextActiveTick = globalNextInitializedTick;\n      int24 _prevActiveTick = globalPrevInitializedTick;\n\n      if (\n        (currentTick < _nextActiveTick != _lastKnownTick < _nextActiveTick) || (currentTick >= _prevActiveTick != _lastKnownTick >= _prevActiveTick)\n      ) {\n        _deactivated = true;\n        deactivated = true;\n      }\n    }\n\n    if (!_deactivated) {\n      globalTick = currentTick;\n    }\n\n    if (uint32(block.timestamp) > _prevTimestamp) {\n      _distributeRewards(_prevTimestamp, _currentLiquidity);\n    }\n\n    if (liquidityDelta != 0) {\n      // if we need to update the ticks, do it\n\n      bool flippedBottom = _updateTick(bottomTick, currentTick, liquidityDelta, false);\n      bool flippedTop = _updateTick(topTick, currentTick, liquidityDelta, true);\n\n      if (currentTick >= bottomTick && currentTick < topTick) {\n        currentLiquidity = LiquidityMath.addDelta(_currentLiquidity, liquidityDelta);\n      }\n\n      if (flippedBottom || flippedTop) {\n        _addOrRemoveTicks(bottomTick, topTick, flippedBottom, flippedTop, currentTick, liquidityDelta < 0);\n      }\n    }\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function setRates(uint128 rate0, uint128 rate1) external override onlyFromFarming {\n    _distributeRewards();\n    (rewardRate0, rewardRate1) = (rate0, rate1);\n  }\n\n  function _checkIsFromFarming() internal view {\n    if (msg.sender != farmingAddress) revert onlyFarming();\n  }\n\n  function _applyRewardsDelta(bool add, uint128 token0Delta, uint128 token1Delta) private {\n    _distributeRewards();\n    if (token0Delta | token1Delta != 0) {\n      (uint128 _rewardReserve0, uint128 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n      if (add) {\n        _rewardReserve0 = _rewardReserve0 + token0Delta;\n        _rewardReserve1 = _rewardReserve1 + token1Delta;\n      } else {\n        _rewardReserve0 = _rewardReserve0 - token0Delta;\n        _rewardReserve1 = _rewardReserve1 - token1Delta;\n      }\n      (rewardReserve0, rewardReserve1) = (_rewardReserve0, _rewardReserve1);\n    }\n  }\n\n  function _distributeRewards() internal {\n    _distributeRewards(prevTimestamp, currentLiquidity);\n  }\n\n  function _distributeRewards(uint32 _prevTimestamp, uint256 _currentLiquidity) internal {\n    // currentLiquidity is uint128\n    unchecked {\n      uint256 timeDelta = uint32(block.timestamp) - _prevTimestamp; // safe until timedelta > 136 years\n      if (timeDelta == 0) return; // only once per block\n\n      if (_currentLiquidity > 0) {\n        (uint256 reward0, uint256 reward1) = (rewardRate0 * timeDelta, rewardRate1 * timeDelta);\n        (uint128 _rewardReserve0, uint128 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n\n        if (reward0 > _rewardReserve0) reward0 = _rewardReserve0;\n        if (reward1 > _rewardReserve1) reward1 = _rewardReserve1;\n\n        if (reward0 | reward1 != 0) {\n          _rewardReserve0 = uint128(_rewardReserve0 - reward0);\n          _rewardReserve1 = uint128(_rewardReserve1 - reward1);\n\n          if (reward0 > 0) totalRewardGrowth0 += FullMath.mulDiv(reward0, Constants.Q128, _currentLiquidity);\n          if (reward1 > 0) totalRewardGrowth1 += FullMath.mulDiv(reward1, Constants.Q128, _currentLiquidity);\n\n          (rewardReserve0, rewardReserve1) = (_rewardReserve0, _rewardReserve1);\n        }\n      }\n    }\n\n    prevTimestamp = uint32(block.timestamp);\n    return;\n  }\n\n  function _updateTick(int24 tick, int24 currentTick, int128 liquidityDelta, bool isTopTick) internal returns (bool updated) {\n    return ticks.update(tick, currentTick, liquidityDelta, totalRewardGrowth0, totalRewardGrowth1, isTopTick);\n  }\n}"
    }
  ]
}