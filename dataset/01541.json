{
  "Title": "M-7: Malicious users can exploit the auction and make profit when the SetToken is not locked.",
  "Content": "# Issue M-7: Malicious users can exploit the auction and make profit when the SetToken is not locked. \n\nSource: https://github.com/sherlock-audit/2023-06-Index-judging/issues/57 \n\n## Found by \nast3ros\n## Summary\n\nThe SetToken can be minted and redeemed by anyone when it is not locked during rebalancing. This can allow malicious users to front-run and back-run the bidders and manipulate the auction outcome.\n\n## Vulnerability Detail\n\nWhen rebalancing, the token manager can configure if the SetToken is locked or not. If the SetToken is not locked, anyone can mint and redeem the SetToken using BasicIssuanceModule. The token manager can also configure the pricing mechanism via the priceAdapter. There are some mechanisms:\n- ConstantPriceAdapter: the price is fixed - similar to place limit orders.\n- BoundedStepWise adapters: like Dutch Auction which the price can increase/decrease over time.\n\nLet's see an example: \n\nThe current price of WETH is 1940 USDC.\nTotal supply of the SetToken is 10.\n\nA Set Token with component WETH and current unit(1 WETH) wants to achieve target unit (0.5 WETH - 975 USDC).\n- Current unit: 1 WETH => Current notional: 10 WETH\n- Target unint: 0.5 WETH - 975 USDC => Target notional: (5 WETH - 9750 USDC)\n\nTo achieve this, it needs to sell WETH to buy USDC. The manager starts rebalancing using linear price curve: start at $2000, lower to minimum $1900, take steps of $0.1 every minute. It also chooses USDC as the quote token.\n\nAssuming when the price of WETH reaches 1950 USDC, a bidder bids for all of the available WETH for the rebalance process, which is 0.5 WETH per Set Token or 5 WETH in total for 9750 USDC (5*1950). The expected result should be that the SetToken will meet the target and the rebalancing process will finish. The end position will be:\n\n- Expected position: 0.5 WETH - 975 USDC => Expected notional (5 WETH - 9750 USDC)\n\nHowever, the module is deployed on mainnet and polygon, a malicious user can front-run the bidder and mint the SetToken to make profit and disrupt the auction. The malicious user mints 10 SetToken using 10 WETH. It increases the total supply of the SetToken to 20.\n\n- After the malicious user front-run the bidder: \n    - Current unit: 1 WETH => Current notional: 20 WETH.\n    - Target unit: 0.5 WETH - 975 USDC => Target notional: (10 WETH - 19500 USDC)\n- After bidder bids 5 WETH for 9750 USDC:\n    - Current: 0.75 WETH - 487.5 USDC => Current notional: (15 WETH - 9750 USDC)\n\nAfter that, the malicious user can back-run the bidding transaction and redeem his 10 SetToken for 7.5 ETH and 4875 USDC. Malicious user balance:\n\n- Before: 10 WETH = 19400 USDC\n- After: 7.5 WETH + 4875 USDC = 7.5 * 1940 + 4875 = 19425 USDC.\n\nThe malicious user can make a profit of 25 USDC and disrupt the auction because the auction cannot finish as it should be.\n\nHe cannot make a profit directly by bidding because the bidder may need to be whitelisted by the manager.\n\nIn conclusion, if the price of auction is above the market price and a bid is placed, a malicious user can front-run and back-run the bidder and make a profit and disrupt the auction in the unlocked rebalancing process.\n\n## Impact\n\nThe malicious user can make a profit and prevent the auction from meeting the target and finishing.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L254-L257\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe SetToken should be always locked when rebalancing.\n\n\n\n\n## Discussion\n\n**thangtranth**\n\nEscalate\n\nThis is not the duplication of #21 since it does not require ERC777. Please help to review.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is not the duplication of #21 since it does not require ERC777. Please help to review.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**pblivin0x**\n\n`In conclusion, if the price of auction is above the market price and a bid is placed, a malicious user can front-run and back-run the bidder and make a profit and disrupt the auction in the unlocked rebalancing process.`\n\nIf the bidder is bidding on an auction that is above market price, then yes, there is profit to be made in the system. That is by design. \n\nAn example of this would be a bidder desperate to exit a position, and willing to incur slippage to exit, just so happens that the exit is market making the SetToken auction. \n\nInvalid issue, note that we've added logic to settle remaining units as part of remediation for #41 \n\n**hrishibhat**\n\n@thangtranth \n\n**pblivin0x**\n\nFor the security purposes of this audit, it can be considered that the price set by the trusted SetToken manager is valid, and any NAV decay of the SetToken needs to be measured against these prices. \n\nBy allowing bid's, mints, and redeems there is no clear way to decay NAV as defined by the auction prices.\n\nAny arbitrage open between the auction prices and market prices is to be handled by the SetToken manager. \n\n**thangtranth**\n\nHi @pblivin0x,\n\n> If the bidder is bidding on an auction that is above market price, then yes, there is profit to be made in the system. That is by design.\n\nIn this issue, it shows that the profit goes to the malicious user who is not the current SetToken holder. He only buys SetToken when there is a profit bidding auction and sells immediately after that by back running. \n\nHe can make **risk free money** and can **prevent** the auction from getting the target. In the example above, if the bidder bids 9750 USDC, the auction should be completed, however it is not because profit is extracted by malicious user.  Actually a MEV can increase the buying and selling amount and extract most of the profit from the bidding.\n\nBecause the protocol is deployed in mainnet and polygon then it is very common to happen. Therefore it should be addressed.\n\n> An example of this would be a bidder desperate to exit a position, and willing to incur slippage to exit, just so happens that the exit is market making the SetToken auction.\n\nThere is nothing wrong with the bidder here. He gets his expected bidding price for the assets.\n\n\n\n\n\n\n**pblivin0x**\n\n> Hi @pblivin0x,\n> \n> > If the bidder is bidding on an auction that is above market price, then yes, there is profit to be made in the system. That is by design.\n> \n> In this issue, it shows that the profit goes to the malicious user who is not the current SetToken holder. He only buys SetToken when there is a profit bidding auction and sells immediately after that by back running.\n> \n> He can make **risk free money** and can **prevent** the auction from getting the target. In the example above, if the bidder bids 9750 USDC, the auction should be completed, however it is not because profit is extracted by malicious user. Actually a MEV can increase the buying and selling amount and extract most of the profit from the bidding.\n> \n> Because the protocol is deployed in mainnet and polygon then it is very common to happen. Therefore it should be addressed.\n> \n> > An example of this would be a bidder desperate to exit a position, and willing to incur slippage to exit, just so happens that the exit is market making the SetToken auction.\n> \n> There is nothing wrong with the bidder here. He gets his expected bidding price for the assets.\n\nMy current understanding is this, I would love to get more opinions.\n\n---\n\n**If**: \n+ A `bid()` is placed on a `component` sell auction\n+ The auction price is greater than the price perceived by some external actor\n\n**Then**: \n+ The external actor can sandwich attack the `bid()` by issuing a size much greater than `totalSupply`, allowing the `bid()` to go through, and redeeming the same size. The full perceived value difference can be extracted.\n+ The SetToken manager and holders do not have sufficient protections that a `bid()` will push the `positionUnit` closer to the `targetUnit` by an amount proportional to `componentAmount` and `totalSupply` before the bid. \n\n**Fix**: \n+ Apply a supply cap on `SetToken.totalSupply` when the manager calls `startRebalance()`. This will facilitate honest issuance and redemption while preventing the size needed for effective sandwich attacks. \n\n---\n\nIf there is no supply cap on an unlocked auction, then anytime a malicious actor sees a `bid()` at a price sufficiently higher than their perceived price, then the malicious actor `can make risk free money and can prevent the auction from getting the target.` - @thangtranth \n\n**FlattestWhite**\n\n```\nAfter that, the malicious user can back-run the bidding transaction and redeem his 10 SetToken for 7.5 ETH and 4875 USDC. Malicious user balance:\n\nBefore: 10 WETH = 19400 USDC\nAfter: 7.5 WETH + 4875 USDC = 7.5 * 1940 + 4875 = 19425 USDC.\n```\nWhy is Before 10 WETH = 19400 USDC? Isn't it 10 WETH = 19500 USDC\nAfter: 7.5 WETH + 4875 USDC = 7.5 * 1950 + 4875 = 19500 USDC\n\n**pblivin0x**\n\nWould a mint/redeem fee prevent the sandwich attack? @thangtranth \n\n**thangtranth**\n\n> Would a mint/redeem fee prevent the sandwich attack? @thangtranth\n\nI think it makes the attack more expensive. Then the attacker needs to consider the amount of fees that he has to pay for mint + redeem and the profit gained (the gap between bid price and current price). If we config the fees large enough then it may. However honest users will have to pay the fee as well.\n\n**thangtranth**\n\n> ```\n> After that, the malicious user can back-run the bidding transaction and redeem his 10 SetToken for 7.5 ETH and 4875 USDC. Malicious user balance:\n> \n> Before: 10 WETH = 19400 USDC\n> After: 7.5 WETH + 4875 USDC = 7.5 * 1940 + 4875 = 19425 USDC.\n> ```\n> \n> Why is Before 10 WETH = 19400 USDC? Isn't it 10 WETH = 19500 USDC After: 7.5 WETH + 4875 USDC = 7.5 * 1950 + 4875 = 19500 USDC\n\nPlease refer to the scenario: The current price of WETH is 1940 USDC.\nThe 1950 is the price of the bid from bidder.\n\n\n**0xauditsea**\n\nI don't think this is valid, when those kind of MEV is allowed, auction managers will allow tokens not being locked, but otherwise `_shouldLockSetToken` will be set to true.\n\n**thangtranth**\n\n> I don't think this is valid, when those kind of MEV is allowed, auction managers will allow tokens not being locked, but otherwise `_shouldLockSetToken` will be set to true.\n\nHi, it is already confirmed with the protocol team that this is not the intended behaviour when MEV is allowed when unlocked.\nFrom the protocol team:\n> it is concerning...it is ideal for SetToken's to actually not be locked during rebalancing bc we want users to always have access to their underlying\n\n**bizzyvinci**\n\nThe issue with this issue is that it assumes a logical bidder would trade at a loss against SetToken.\n\n\nI'll start with some axioms which I believe are True\n\n* market is DEX. market price is DEX price.\n* No logical bidder would trade at a loss. Because bidders would want to trade at a DEX instantly for profit.\n* price is how much quoteAsset you need to purchase 1 component (which is base asset).\n* Minting and burning does not manipulate unit.\n* Notional values are what's minted, burned and traded, which is equal to `unit * tokenAmount` (tokenAmount could be totalSupply).\n\n\nIf the axioms listed above are True. Then the following should be True\n* SetToken would sell component at a price lower than market/DEX. So that bidder would buy it and sell on DEX for an instant profit.\n* SetToken would buy component at a price higher than market/DEX. So that bidder would buy it cheaper on DEX and sell it for SetToken for an instant profit.\n* SetToken is trading at a discount loss compared to market.\n\nP.S: Another reason I believe SetToken is comfortable at trading at discount loss is because Auction could be used against DEX slippage or as an order book that would be executed at a future time when price reaches the limit set by manager.\n\n\nAnd\n* If totalSupply increases when SetToken is selling component, It would be provided with more component notional to sell at a loss. Because It needs more component notional to buy quoteAsset at a loss.\n* If totalSupply increases when SetToken is buying component, It would be provided with more quote notional to sell at a loss. Because It needs more quote notional to buy component at a loss.\n* The loss is distributed to all holders of SetToken\n\nP.S: quote asset must be a component for second point to be True. And I believe that's done because the contract [checks that bidded component is not quoteAsset](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L750) to avoid attacks when quoteAsset is part of SetToken components. And most importantly, it updates both quoteAsset and bidded component position [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L997-L1008).\n\nTherefore:\n* Higher notional means SetToken is provided with more tokens to trade at a loss to market/DEX.\n* Anyone sandwiching this trade by minting and burning SetToken is partaking in the loss.\n\n\nUsing numbers would be more complicated cause there are several parameters. And the proof provided by the issue is flawed because SetToken is selling component at a price higher than market/DEX. This means that bidder is taking a loss and SetToken is taking a profit. That's the source of the $25. Proof:\n* Price of 1900-2000 means USDC is quote asset while WETH is component (base asset)\n* SetToken is selling WETH for USDC\n* A bidder decides to buy it 1950 which is higher than 1940 of market price\n* The bidder bought 5 WETH, so the bidder loses $50 while the SetToken gains $50\n* Since the sandwicher owns 50% of supply, they get 50% of $50 which is $25\n\nIf the bidder is logical he would wait till price is below market price so that he'll make a profit on the trade. Therefore sandwicher would take part in the loss.\n\n\n**sinarette**\n\n> Should not be able to decay the SetToken Net-Asset-Value according to this price. with any combination of actions (bids, mints, or redeems)\n\nAccording to the contest readme it requires damage calculated according to the bid price.\nHere the stated attack scenario is just buying ETH at 1940 USDC and selling at 1950 USDC; we don't tell this kind of profitable trading stategy an 'attack'. In fact, in ETH units it's not a profit; the attacker who had 19400/1940 = 10 ETH now has 19425/1950 = 9.96 ETH.\n\n**pblivin0x**\n\nAgree with @bizzyvinci here that bidder's in the system are expected to be rationale profit seeking actors - ` If the bidder is logical he would wait till price is below market price so that he'll make a profit on the trade. Therefore sandwicher would take part in the loss.`\n\n**thangtranth**\n\nYes, I also agree with @bizzyvinci . A very good point about rationale bidder ðŸ‘\n\n**pblivin0x**\n\nThank you for all the input here @thangtranth @bizzyvinci @0xauditsea @sinarette @Oot2k \n\nAfter much consideration I'm of the following opinion\n+ When a `bid()` is placed on a component sell auction that is above market price, a malicious actor can sandwich attack the `bid()`, and prevent the `bid()` from contributing meaningfully towards the auction getting closer to target. \n+ Bidderâ€™s are expected to be rationale profit-seeking actors, so the situation where a `bid()` is placed above market price is not expected to happen often.\n+ To prevent such a sandwich attack, a reasonable supply cap can be placed on the SetToken, such that normal user issuance and redemption is possible, but large sandwich attack issuance is not possible. \n\nIndex is prepared to take the following remediations\n+ Add a warning about sandwich attacks on unlocked rebalances to the `AuctionRebalanceModuleV1` natspec\n+ In production, utilize a supply cap on the SetToken during unlocked rebalances (e.g., 2x supply at the start of rebalance)\n\nI believe this is a Medium severity issue because\n+ While the sandwich attack requires that the bidder is acting \"irrationally\" and is not expected to happen often, part of the dutch auction mechanism is that the auctioneer benefits from poorly priced bids. This sandwich attack could take all the benefits from the auctioneer, by preventing the auction from getting any closer to target. \n+ This is exactly the edge case I wanted examined during the audit, with the addition of broader market dynamics - `Should not be able to decay the SetToken Net-Asset-Value according to this price. with any combination of actions (bids, mints, or redeems)` https://github.com/sherlock-audit/2023-06-Index#q-are-there-any-additional-protocol-roles-if-yes-please-explain-in-detail\n+ Index is taking meaningful remediations from this issue\n\n\n**Oot2k**\n\nAgree with escalation and agree that this is valid.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a medium issue based on above comments \nhttps://github.com/sherlock-audit/2023-06-Index-judging/issues/57#issuecomment-1666224199\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [thangtranth](https://github.com/sherlock-audit/2023-06-Index-judging/issues/57/#issuecomment-1658144838): accepted\n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe changes are to add warnings to use a supply cap in order to avoid large front running issuance and redemption\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L48-L51\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L239\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/91",
  "Code": [
    {
      "filename": "index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol",
      "content": "/*\n    Copyright 2023 Index Coop\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.6.10;\npragma experimental \"ABIEncoderV2\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/math/Math.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport { AddressArrayUtils } from \"../../../lib/AddressArrayUtils.sol\";\nimport { IAuctionPriceAdapterV1 } from \"../../../interfaces/IAuctionPriceAdapterV1.sol\";\nimport { IController } from \"../../../interfaces/IController.sol\";\nimport { Invoke } from \"../../lib/Invoke.sol\";\nimport { ISetToken } from \"../../../interfaces/ISetToken.sol\";\nimport { ModuleBase } from \"../../lib/ModuleBase.sol\";\nimport { Position } from \"../../lib/Position.sol\";\nimport { PreciseUnitMath } from \"../../../lib/PreciseUnitMath.sol\";\n\n/**\n * @title AuctionRebalanceModuleV1\n * @author Index Coop\n * @notice Facilitates rebalances for index sets via single-asset auctions. Managers initiate\n * rebalances specifying target allocations in precise units (scaled by 10^18), quote asset\n * (e.g., WETH, USDC), auction parameters per component, and rebalance duration through\n * startRebalance(). Bidders can participate via bid() for individual components. Excess\n * quote asset can be managed by proportionally increasing the targets using raiseAssetTargets().\n *\n * @dev Compatible with StreamingFeeModule and BasicIssuanceModule. Review compatibility if used\n * with additional modules.\n */\ncontract AuctionRebalanceModuleV1 is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n\n    /* ============ Structs ============ */\n\n    struct AuctionExecutionParams {\n        uint256 targetUnit;                      // Target quantity of the component in Set, in precise units (10 ** 18).\n        string priceAdapterName;                 // Identifier for the price adapter to be used.\n        bytes priceAdapterConfigData;            // Encoded data for configuring the chosen price adapter.\n    }\n\n    struct BidPermissionInfo {\n        bool isAnyoneAllowedToBid;               // Flag indicating if bids are open to anyone (true) or restricted (false).\n        address[] biddersHistory;                // List of addresses that have been permissioned to bid.\n        mapping(address => bool) bidAllowList;   // Mapping of addresses to a boolean indicating if they are allowed to bid.\n    }\n\n    struct RebalanceInfo {\n        IERC20 quoteAsset;                       // Reference to the ERC20 token used to quote auctions.\n        uint256 rebalanceStartTime;              // Unix timestamp marking the start of the rebalance.\n        uint256 rebalanceDuration;               // Duration of the rebalance in seconds.\n        uint256 positionMultiplier;              // Position multiplier when target units were calculated.\n        uint256 raiseTargetPercentage;           // Optional percentage to increase all target units if allowed, in precise units.\n        address[] rebalanceComponents;           // List of component tokens involved in the rebalance.\n    }\n\n    struct BidInfo {\n        ISetToken setToken;                      // Instance of the SetToken contract that is being rebalanced.\n        IERC20 sendToken;                        // The ERC20 token being sent in this bid.\n        IERC20 receiveToken;                     // The ERC20 token being received in this bid.\n        IAuctionPriceAdapterV1 priceAdapter;     // Instance of the price adapter contract used for this bid.\n        bytes priceAdapterConfigData;            // Data for configuring the price adapter.\n        bool isSellAuction;                      // Indicates if this is a sell auction (true) or a buy auction (false).\n        uint256 auctionQuantity;                 // The quantity of the component being auctioned.\n        uint256 componentPrice;                  // The price of the component as quoted by the price adapter.\n        uint256 quantitySentBySet;               // Quantity of tokens sent by SetToken in this bid.\n        uint256 quantityReceivedBySet;           // Quantity of tokens received by SetToken in this bid.\n        uint256 preBidTokenSentBalance;          // Balance of tokens being sent by SetToken before the bid.\n        uint256 preBidTokenReceivedBalance;      // Balance of tokens being received by SetToken before the bid.\n        uint256 setTotalSupply;                  // Total supply of the SetToken at the time of the bid.\n    }\n\n    /* ============ Events ============ */\n\n    /**\n     * @dev Emitted when the target percentage increase is modified via setRaiseTargetPercentage()\n     * @param setToken                   Reference to the SetToken undergoing rebalancing\n     * @param newRaiseTargetPercentage   Updated percentage for potential target unit increases, in precise units (10 ** 18)\n     */\n    event RaiseTargetPercentageUpdated(\n        ISetToken indexed setToken, \n        uint256 newRaiseTargetPercentage\n    );\n\n    /**\n     * @dev Emitted upon calling raiseAssetTargets()\n     * @param setToken                Reference to the SetToken undergoing rebalancing\n     * @param newPositionMultiplier   Updated position multiplier for the SetToken rebalance\n     */\n    event AssetTargetsRaised(\n        ISetToken indexed setToken, \n        uint256 newPositionMultiplier\n    );\n\n    /**\n     * @dev Emitted upon toggling the bid permission setting via setAnyoneBid()\n     * @param setToken               Reference to the SetToken undergoing rebalancing\n     * @param isAnyoneAllowedToBid   Flag indicating if bids are open to all (true) or restricted (false)\n     */\n    event AnyoneBidUpdated(\n        ISetToken indexed setToken, \n        bool isAnyoneAllowedToBid\n    );\n\n    /**\n     * @dev Emitted when the bidding status of an address is changed via setBidderStatus()\n     * @param setToken          Reference to the SetToken undergoing rebalancing\n     * @param bidder            Address whose bidding permission status is toggled\n     * @param isBidderAllowed   Flag indicating if the address is allowed (true) or not allowed (false) to bid\n     */\n    event BidderStatusUpdated(\n        ISetToken indexed setToken, \n        address indexed bidder, \n        bool isBidderAllowed\n    );\n\n    /**\n     * @dev Emitted when a rebalance is initiated using the startRebalance() function.\n     * @param setToken                    Instance of the SetToken contract that is undergoing rebalancing.\n     * @param quoteAsset                  The ERC20 token that is used as a quote currency for the auctions.\n     * @param isSetTokenLocked            Indicates if the rebalance process locks the SetToken (true) or not (false).\n     * @param rebalanceDuration           Duration of the rebalance process in seconds.\n     * @param initialPositionMultiplier   Position multiplier when target units were calculated.\n     * @param componentsInvolved          Array of addresses of the component tokens involved in the rebalance.\n     * @param auctionParameters           Array of AuctionExecutionParams structs, containing auction parameters for each component token.\n     */\n    event RebalanceStarted(\n        ISetToken indexed setToken,\n        IERC20 indexed quoteAsset,\n        bool isSetTokenLocked,\n        uint256 rebalanceDuration,\n        uint256 initialPositionMultiplier,\n        address[] componentsInvolved,\n        AuctionExecutionParams[] auctionParameters\n    );\n\n    /**\n     * @dev Emitted upon execution of a bid via the bid() function.\n     * @param setToken                   Instance of the SetToken contract that is being rebalanced.\n     * @param sendToken                  The ERC20 token that is being sent by the bidder.\n     * @param receiveToken               The ERC20 token that is being received by the bidder.\n     * @param bidder                     The address of the bidder.\n     * @param priceAdapter               Instance of the price adapter contract used for this bid.\n     * @param isSellAuction              Indicates if this is a sell auction (true) or a buy auction (false).\n     * @param price                      The price of the component in precise units (10 ** 18).\n     * @param netQuantitySentBySet       The net amount of tokens sent by the SetToken in the bid.\n     * @param netQuantityReceivedBySet   The net amount of tokens received by the SetToken in the bid.\n     * @param protocolFee                The amount of the received token allocated as a protocol fee.\n     * @param setTotalSupply             The total supply of the SetToken at the time of the bid.\n     */\n    event BidExecuted(\n        ISetToken indexed setToken,\n        address indexed sendToken,\n        address indexed receiveToken,\n        address bidder,\n        IAuctionPriceAdapterV1 priceAdapter,\n        bool isSellAuction,\n        uint256 price,\n        uint256 netQuantitySentBySet,\n        uint256 netQuantityReceivedBySet,\n        uint256 protocolFee,\n        uint256 setTotalSupply\n    );\n\n    /**\n     * @dev Emitted when a locked rebalance is concluded early via the unlock() function.\n     * @param setToken            Instance of the SetToken contract that is being rebalanced.\n     */\n    event LockedRebalanceEndedEarly(\n        ISetToken indexed setToken\n    );\n\n\n    /* ============ Constants ============ */\n\n    uint256 private constant AUCTION_MODULE_V1_PROTOCOL_FEE_INDEX = 0;   // Index of the protocol fee percentage assigned to this module in the Controller.\n\n    /* ============ State Variables ============ */\n\n    mapping(ISetToken => mapping(IERC20 => AuctionExecutionParams)) public executionInfo;   // Maps SetToken to component tokens and their respective auction execution parameters.\n    mapping(ISetToken => BidPermissionInfo) public permissionInfo;                          // Maps SetToken to information regarding bid permissions during a rebalance.\n    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Maps SetToken to data relevant to the most recent rebalance.\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyAllowedBidder(ISetToken _setToken) {\n        _validateOnlyAllowedBidder(_setToken);\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    constructor(IController _controller) public ModuleBase(_controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @dev MANAGER ONLY: Initiates the rebalance process by setting target allocations for the SetToken. Opens auctions\n     * for filling by the Set's designated bidders. The function takes in new components to be added with their target units\n     * and existing components with updated target units (set to 0 if removing). A positionMultiplier is supplied to adjust\n     * target units, e.g., in cases where fee accrual affects the positionMultiplier of the SetToken, ensuring proportional\n     * allocation among components. If target allocations are not met within the specified duration, the rebalance concludes\n     * with the allocations achieved.\n     *\n     * @param _setToken                     The SetToken to be rebalanced.\n     * @param _quoteAsset                   ERC20 token used as the quote asset in auctions.\n     * @param _newComponents                Addresses of new components to be added.\n     * @param _newComponentsAuctionParams   AuctionExecutionParams for new components, indexed corresponding to _newComponents.\n     * @param _oldComponentsAuctionParams   AuctionExecutionParams for existing components, indexed corresponding to\n     *                                      the current component positions. Set to 0 for components being removed.\n     * @param _shouldLockSetToken           Indicates if the rebalance should lock the SetToken.\n     * @param _rebalanceDuration            Duration of the rebalance in seconds.\n     * @param _initialPositionMultiplier    Position multiplier at the start of the rebalance.\n     */\n    function startRebalance(\n        ISetToken _setToken,\n        IERC20 _quoteAsset,\n        address[] calldata _newComponents,\n        AuctionExecutionParams[] memory _newComponentsAuctionParams,\n        AuctionExecutionParams[] memory _oldComponentsAuctionParams,\n        bool _shouldLockSetToken,\n        uint256 _rebalanceDuration,\n        uint256 _initialPositionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Lock the SetToken if the _shouldLockSetToken flag is true and the SetToken is not already locked by this module\n        if (_shouldLockSetToken && _setToken.locker() != address(this)) {\n            _setToken.lock();\n        }\n\n        // Aggregate components and auction parameters\n        (address[] memory allComponents, AuctionExecutionParams[] memory allAuctionParams) = _aggregateComponentsAndAuctionParams(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsAuctionParams,\n            _oldComponentsAuctionParams\n        );\n\n        // Set the execution information\n        for (uint256 i = 0; i < allComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(allComponents[i]), \"External positions not allowed\");\n            executionInfo[_setToken][IERC20(allComponents[i])] = allAuctionParams[i];\n        }\n\n        // Set the rebalance information\n        rebalanceInfo[_setToken].quoteAsset = _quoteAsset;\n        rebalanceInfo[_setToken].rebalanceStartTime = block.timestamp;\n        rebalanceInfo[_setToken].rebalanceDuration = _rebalanceDuration;\n        rebalanceInfo[_setToken].positionMultiplier = _initialPositionMultiplier;\n        rebalanceInfo[_setToken].rebalanceComponents = allComponents;\n\n        // Emit the RebalanceStarted event\n        emit RebalanceStarted(_setToken, _quoteAsset, _shouldLockSetToken, _rebalanceDuration, _initialPositionMultiplier, allComponents, allAuctionParams);\n    }\n\n   /**\n     * @dev ACCESS LIMITED: Only approved addresses can call this function unless isAnyoneAllowedToBid is enabled. This function\n     * is used to push the current component units closer to the target units defined in startRebalance().\n     *\n     * Bidders specify the amount of the component they intend to buy or sell, and also specify the maximum/minimum amount \n     * of the quote asset they are willing to spend/receive.\n     *\n     * The auction parameters, which are set by the manager, are used to determine the price of the component. Any bids that \n     * either don't move the component units towards the target, or overshoot the target, will be reverted.\n     *\n     * If protocol fees are enabled, they are collected in the token received in a bid.\n     * \n     * SELL AUCTIONS:\n     * At the start of the rebalance, sell auctions are available to be filled in their full size.\n     * \n     * BUY AUCTIONS:\n     * Buy auctions can be filled up to the amount of quote asset available in the SetToken. This means that if the SetToken \n     * does not contain the quote asset as a component, buy auctions cannot be bid on until sell auctions have been executed \n     * and there is quote asset available in the SetToken.\n     *\n     * @param _setToken          The SetToken to be rebalanced.\n     * @param _component         The component for which the auction is to be bid on.\n     * @param _componentAmount   The amount of component in the bid.\n     * @param _quoteAssetLimit   The maximum or minimum amount of quote asset that can be spent or received during the bid.\n     */\n    function bid(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _componentAmount,\n        uint256 _quoteAssetLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedBidder(_setToken)\n    {\n        // Validate whether the bid targets are legitimate\n        _validateBidTargets(_setToken, _component);\n\n        // Create the bid information structure\n        BidInfo memory bidInfo = _createBidInfo(_setToken, _component, _componentAmount, _quoteAssetLimit);\n\n        // Execute the token transfer specified in the bid information\n        _executeBid(bidInfo);\n\n        // Accrue protocol fee and store the amount\n        uint256 protocolFeeAmount = _accrueProtocolFee(bidInfo);\n\n        // Update the position state and store the net amounts\n        (uint256 netAmountSent, uint256 netAmountReceived) = _updatePositionState(bidInfo);\n\n        // Emit the BidExecuted event\n        emit BidExecuted(\n            bidInfo.setToken,\n            address(bidInfo.sendToken),\n            address(bidInfo.receiveToken),\n            msg.sender,\n            bidInfo.priceAdapter,\n            bidInfo.isSellAuction,\n            bidInfo.componentPrice,\n            netAmountSent,\n            netAmountReceived,\n            protocolFeeAmount,\n            bidInfo.setTotalSupply\n        );\n    }\n\n    /**\n     * @dev ACCESS LIMITED: Increases asset targets uniformly when all target units have been met but there is remaining quote asset.\n     * Can be called multiple times if necessary. Targets are increased by the percentage specified by raiseAssetTargetsPercentage set by the manager.\n     * This helps in reducing tracking error and providing greater granularity in reaching an equilibrium between the excess quote asset\n     * and the components to be purchased. However, excessively raising targets may result in under-allocating to the quote asset as more of\n     * it is spent buying components to meet the new targets.\n     *\n     * @param _setToken   The SetToken to be rebalanced.\n     */\n    function raiseAssetTargets(ISetToken _setToken)\n        external\n        onlyAllowedBidder(_setToken)\n        virtual\n    {\n        // Ensure the rebalance is in progress\n        require(!_isRebalanceDurationElapsed(_setToken), \"Rebalance must be in progress\");\n\n        // Ensure that all targets are met and there is excess quote asset\n        require(_canRaiseAssetTargets(_setToken), \"Targets not met or quote asset =~ 0\");\n\n        // Calculate the new positionMultiplier\n        uint256 newPositionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n\n        // Update the positionMultiplier in the RebalanceInfo struct\n        rebalanceInfo[_setToken].positionMultiplier = newPositionMultiplier;\n\n        // Emit the AssetTargetsRaised event\n        emit AssetTargetsRaised(_setToken, newPositionMultiplier);\n    }\n\n    /**\n     * @dev Unlocks the SetToken after rebalancing. Can be called once the rebalance duration has elapsed.\n     * Can only be called before the rebalance duration has elapsed if all targets are met, there is excess\n     * or at-target quote asset, and raiseTargetPercentage is zero.\n     *\n     * @param _setToken The SetToken to be unlocked.\n     */\n    function unlock(ISetToken _setToken) external {\n        bool isRebalanceDurationElapsed = _isRebalanceDurationElapsed(_setToken);\n        bool canUnlockEarly = _canUnlockEarly(_setToken);\n\n        // Ensure that either the rebalance duration has elapsed or the conditions for early unlock are met\n        require(isRebalanceDurationElapsed || canUnlockEarly, \"Cannot unlock early unless all targets are met and raiseTargetPercentage is zero\");\n\n        // If unlocking early, update the state\n        if (canUnlockEarly) {\n            delete rebalanceInfo[_setToken].rebalanceDuration;\n            emit LockedRebalanceEndedEarly(_setToken);\n        }\n\n        // Unlock the SetToken\n        _setToken.unlock();\n    }\n\n    /**\n     * @dev MANAGER ONLY: Sets the percentage by which the target units for all components can be increased.\n     * Can be called at any time by the manager.\n     *\n     * @param _setToken               The SetToken to be rebalanced.\n     * @param _raiseTargetPercentage  The percentage (in precise units) by which the target units can be increased.\n     */\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Ensure the raise target percentage is greater than 0\n        require(_raiseTargetPercentage > 0, \"Target percentage must be greater than 0\");\n\n        // Update the raise target percentage in the RebalanceInfo struct\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n\n        // Emit an event to log the updated raise target percentage\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n\n    /**\n     * @dev MANAGER ONLY: Toggles the permission status of specified addresses to call the `bid()` function.\n     * The manager can call this function at any time.\n     *\n     * @param _setToken  The SetToken being rebalanced.\n     * @param _bidders   An array of addresses whose bidding permission status is to be toggled.\n     * @param _statuses  An array of booleans indicating the new bidding permission status for each corresponding address in `_bidders`.\n     */\n    function setBidderStatus(\n        ISetToken _setToken,\n        address[] memory _bidders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Validate that the input arrays have the same length\n        _bidders.validatePairsWithArray(_statuses);\n\n        // Iterate through the input arrays and update the permission status for each bidder\n        for (uint256 i = 0; i < _bidders.length; i++) {\n            _updateBiddersHistory(_setToken, _bidders[i], _statuses[i]);\n            permissionInfo[_setToken].bidAllowList[_bidders[i]] = _statuses[i];\n\n            // Emit an event to log the updated permission status\n            emit BidderStatusUpdated(_setToken, _bidders[i], _statuses[i]);\n        }\n    }\n\n    /**\n     * @dev MANAGER ONLY: Toggles whether or not anyone is allowed to call the `bid()` function.\n     * If set to true, it bypasses the bidAllowList, allowing any address to call the `bid()` function.\n     * The manager can call this function at any time.\n     *\n     * @param _setToken  The SetToken instance.\n     * @param _status    A boolean indicating if anyone can bid.\n     */\n    function setAnyoneBid(\n        ISetToken _setToken,\n        bool _status\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Update the anyoneBid status in the PermissionInfo struct\n        permissionInfo[_setToken].isAnyoneAllowedToBid = _status;\n\n        // Emit an event to log the updated anyoneBid status\n        emit AnyoneBidUpdated(_setToken, _status);\n    }\n\n\n    /**\n     * @dev MANAGER ONLY: Initializes the module for a SetToken, enabling access to AuctionModuleV1 for rebalances.\n     * Retrieves the current units for each asset in the Set and sets the targetUnit to match the current unit, effectively\n     * preventing any bidding until `startRebalance()` is explicitly called. The position multiplier is also logged to ensure that\n     * any changes to the position multiplier do not unintentionally open the Set for rebalancing.\n     *\n     * @param _setToken   Address of the Set Token\n     */\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n\n        for (uint256 i = 0; i < positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, \"External positions not allowed\");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n        }\n\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n\n\n    /**\n     * @dev Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the `rebalanceInfo` and `permissionsInfo` of the calling SetToken.\n     * IMPORTANT: The auction execution settings of the SetToken, including auction parameters,\n     * are NOT DELETED. Restoring a previously removed module requires careful initialization of\n     * the execution settings.\n     */\n    function removeModule() external override {\n        BidPermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n\n        for (uint256 i = 0; i < tokenPermissionInfo.biddersHistory.length; i++) {\n            tokenPermissionInfo.bidAllowList[tokenPermissionInfo.biddersHistory[i]] = false;\n        }\n\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n\n\n    /* ============ External View Functions ============ */\n\n    /**\n     * @dev Checks externally if the rebalance duration has elapsed for the given SetToken.\n     *\n     * @param _setToken The SetToken whose rebalance duration is being checked.\n     * @return bool True if the rebalance duration has elapsed; false otherwise.\n     */\n    function isRebalanceDurationElapsed(ISetToken _setToken) external view returns (bool) {\n        return _isRebalanceDurationElapsed(_setToken);\n    }\n\n    /**\n     * @dev Retrieves the array of components that are involved in the rebalancing of the given SetToken.\n     *\n     * @param _setToken    Instance of the SetToken.\n     *\n     * @return address[]   Array of component addresses involved in the rebalance.\n     */\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n\n    /**\n     * @dev Calculates the quantity of a component involved in the rebalancing of the given SetToken,\n     * and determines if the component is being bought or sold.\n     *\n     * @param _setToken    Instance of the SetToken being rebalanced.\n     * @param _component   Instance of the IERC20 component to bid on.\n     *\n     * @return isSellAuction       Indicates if this is a sell auction (true) or a buy auction (false).\n     * @return componentQuantity   Quantity of the component involved in the bid.\n     */\n    function getAuctionSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool isSellAuction, uint256 componentQuantity)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            \"Component not part of rebalance\"\n        );\n        \n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateAuctionSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n    /**\n     * @dev Retrieves the balance of the quote asset for a given SetToken.\n     *\n     * @param _setToken The SetToken whose quote asset balance is being retrieved.\n     * @return uint256 The balance of the quote asset.\n     */\n    function getQuoteAssetBalance(ISetToken _setToken) external view returns (uint256) {\n        RebalanceInfo storage rebalance = rebalanceInfo[_setToken];\n        return IERC20(rebalance.quoteAsset).balanceOf(address(_setToken));\n    }\n\n    /**\n     * @dev Generates a preview of the bid for a given component in the rebalancing of the SetToken.\n     * It calculates the quantity of the component that will be exchanged and the direction of exchange.\n     *\n     * @param _setToken             Instance of the SetToken being rebalanced.\n     * @param _component            Instance of the component auction to bid on.\n     * @param _componentQuantity    Quantity of the component involved in the bid.\n     * @param _quoteQuantityLimit   Maximum or minimum amount of quote asset spent or received during the bid.\n     *\n     * @return BidInfo              Struct containing data for the bid.\n     */\n    function getBidPreview(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _componentQuantity,\n        uint256 _quoteQuantityLimit\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (BidInfo memory)\n    {\n        _validateBidTargets(_setToken, _component);\n        BidInfo memory bidInfo = _createBidInfo(_setToken, _component, _componentQuantity, _quoteQuantityLimit);\n        \n        return bidInfo;\n    }\n\n    /**\n     * @dev Checks externally if the conditions for early unlock are met.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if early unlock conditions are met; false otherwise.\n     */\n    function canUnlockEarly(ISetToken _setToken) external view returns (bool) {\n        return _canUnlockEarly(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if the conditions to raise asset targets are met.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if conditions to raise asset targets are met; false otherwise.\n     */\n    function canRaiseAssetTargets(ISetToken _setToken) external view returns (bool) {\n        return _canRaiseAssetTargets(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if all target units for components have been met.\n     *\n     * @param _setToken Instance of the SetToken to be rebalanced.\n     * @return bool True if all component's target units have been met; false otherwise.\n     */\n    function allTargetsMet(ISetToken _setToken) external view returns (bool) {\n        return _allTargetsMet(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if the quote asset is in excess or at target.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if the quote asset is in excess or at target; false otherwise.\n     */\n    function isQuoteAssetExcessOrAtTarget(ISetToken _setToken) external view returns (bool) {\n        return _isQuoteAssetExcessOrAtTarget(_setToken);\n    }\n\n    /**\n     * @dev Determines whether the given bidder address is allowed to participate in the auction.\n     *\n     * @param _setToken   Instance of the SetToken for which the bid is being placed.\n     * @param _bidder     Address of the bidder.\n     *\n     * @return bool       True if the given `_bidder` is permitted to bid, false otherwise.\n     */\n    function isAllowedBidder(ISetToken _setToken, address _bidder)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedBidder(_setToken, _bidder);\n    }\n\n    /**\n     * @dev Retrieves the list of addresses that are permitted to participate in the auction by calling `bid()`.\n     *\n     * @param _setToken           Instance of the SetToken for which to retrieve the list of allowed bidders.\n     *\n     * @return address[]          Array of addresses representing the allowed bidders.\n     */\n    function getAllowedBidders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].biddersHistory;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev Aggregates the current SetToken components with the new components and validates their auction parameters.\n     * Ensures that the sizes of the new components and new auction parameters arrays are the same, and that the number of current component auction parameters\n     * matches the number of current components. Additionally, it validates that the price adapter exists, the price adapter configuration data is valid for the adapter,\n     * and the target unit is greater than zero for new components. T"
    }
  ]
}