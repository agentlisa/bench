{
  "Title": "[H-01] Array Length of `tickTracking_ ` can be purposely increased to Brick Minting and Burning of most users' liquidity positions",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L24-L35><br>\n<https://github.com/code-423n4/2023-10-canto/blob/40edbe0c9558b478c84336aaad9b9626e5d99f34/canto_ambient/contracts/mixins/LiquidityMining.sol#L122>\n\n### Impact\n\nA malicious user can brick minting, burning and harvesting of liquidity for almost all liquidity providers.\n\n*Important NOTE*: This is a different vector from another gas issue, which is iterating over too many ticks in `(int24 i = lowerTick + 10; i <= upperTick - 10; ++i)`. That issue affects wide liquidity positions, while this attack vector affects even liquidity positions with a relatively small number of ticks.\n\n### Proof of Concept\n\nWhen `accrueConcentratedPositionTimeWeightedLiquidity` is called, under most conditions for every potentially eligible tick, it will iterate over every `tickTrackingData` in `tickTracking`:\n\n```solidity\nwhile (time < block.timestamp && tickTrackingIndex < numTickTracking)\n```\n\n`tickTracking` is iterated by `tickTrackingIndex++;`\n\nThe array mapped by `tickTracking_` is increased by 1 for a tick every time a trade through the liquidity pool changes the price from a different tick to this tick. This is implemented in the `crossTicks` function:\n\n```solidity\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n```\n\nA user could purposely increase the length of the `tickTracking_` array and cause the gas limit to be reached whenever the array is looped over.\n\nThe price impact required to cross a tick is from 0 to 1 bps, with 1 bps as the tick width. This is already extremely small, but the attacker could have the swap amount be a very small fraction of a bps if they first swap to make the price end very close to a tick boundary, then execute multiple extremely small swaps which bounce the price back and forth over the tick boundary.\n\nNote that the CANTO liquidity rewards are targeted to stable pools. An attacker can be quite confident, for example, that a USDC/USDT pool will trade at around `$`1, and the ticks closest to `$`1 will always be eligible for rewards and therefore be looped over by all rewardable positions when `accrueConcentratedPositionTimeWeightedLiquidity` is called. Therefore, the attack can be targeted to just one or two ticks to affect almost every user.\n\n`accrueConcentratedPositionTimeWeightedLiquidity` is called during minting, burning and harvesting liquidity positions. Therefore, this gas griefing attack will make all these functions revert for almost every user. This would basically break the functionality of concentrated liquidity pools on Ambient.\n\nContrast the effect to the cost to the attacker: using the aforementioned attack vector the main cost to the attacker will be the gas costs of performing the swaps. This is far lower than the damage that is done to the protocol/users.\n\nOne additional factor which makes this attack easy to execute, is that crossing ticks, even if the entry and exit is within the same `block.timestamp`, adds to the array length. Tracking this is unnecessary, because the tick was active for 0 blocks, and therefore, the time delta and allocated rewards is zero.\n\n### Recommended Mitigation Steps\n\nOne immediate step would to `pop()` `tickTrackingData` as soon as the `exitTimestamp == entryTimestamp`. This happens to the last element of the array when `crossTicks` is called. Tracking this is unnecessary, because the tick was active for 0 blocks, and therefore, the time delta and allocated rewards is zero.\n\nThe documentation stated that CANTO rewards are meant to be distributed for stable pools for this codebase. The term \"stable\" could have different interpretations, but this recommendation assumes that this refers to stablecoin-like or pegged asset pairs such as stETH/WETH, USDT/USDC etc.\n\nInstead of iterating through every tick, one could assume a range where the stable assets could lie and then reward all positions that lie within the specified range; in this case, +/- 10 ticks of the price tick.\n\nThis makes an assumption that these \"stable assets\" will actually stay pegged to each other. However, the current accounting architecture has multiple problems:\n\n- Given the high number of loops required by the current accounting mechanism, there are multiple reasons that gas could run out. This includes iterating through too many ticks or having too many tick entries/exits.\n\n- The current mechanism increases the gas costs of all minting, burning and harvesting.\n\n- DOS attacks like the one described in this issue are possible.\n\nAssuming a stable price has the downside of misallocating rewards if the stable assets depeg from each other. However, this may be a reasonable tradeoff to prevent this DOS attack.\n\n### Assessed type\n\nDoS\n\n**[OpenCoreCH (Canto) confirmed](https://github.com/code-423n4/2023-10-canto-findings/issues/114#issuecomment-1757196983)**\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-10-canto-findings/issues/114)*.\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-canto",
  "Code": [
    {
      "filename": "canto_ambient/contracts/mixins/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"./PositionRegistrar.sol\";\nimport \"./StorageLayout.sol\";\nimport \"./PoolRegistry.sol\";\n\n/* @title Liquidity mining mixin\n * @notice Contains the functions related to liquidity mining claiming. */\ncontract LiquidityMining is PositionRegistrar {\n    uint256 constant WEEK = 604800; // Week in seconds 604800\n\n    /// @notice Initialize the tick tracking for the first tick of a pool\n    function initTickTracking(bytes32 poolIdx, int24 tick) internal {\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][tick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the tick crossings\n    /// @dev Needs to be called whenever a tick is crossed\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the global in-range time-weighted concentrated liquidity per week\n    /// @dev Needs to be called whenever the concentrated liquidity is modified (tick crossed, positions changed)\n    function accrueConcentratedGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalConcLiquidityLastSet_[\n            poolIdx\n        ];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.concLiq_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalConcLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n    /// @dev Needs to be called whenever a position is modified\n    function accrueConcentratedPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal {\n        RangePosition72 storage pos = lookupPosition(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = pos.liquidity_;\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                uint32 origIndex = tickTrackingIndex;\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                uint32 time = lastAccrued;\n                // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                    TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                    uint32 currWeek = uint32((time / WEEK) * WEEK);\n                    uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                    uint32 dt = uint32(\n                        nextWeek < block.timestamp\n                            ? nextWeek - time\n                            : block.timestamp - time\n                    );\n                    uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                    uint32 tickActiveEnd;\n                    if (tickTracking.enterTimestamp < nextWeek) {\n                        // Tick was active before next week, need to add the liquidity\n                        if (tickTracking.enterTimestamp < time) {\n                            // Tick was already active when last claim happened, only accrue from last claim timestamp\n                            tickActiveStart = time;\n                        } else {\n                            // Tick has become active this week\n                            tickActiveStart = tickTracking.enterTimestamp;\n                        }\n                        if (tickTracking.exitTimestamp == 0) {\n                            // Tick still active, do not increase index because we need to continue from here\n                            tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                        } else {\n                            // Tick is no longer active\n                            if (tickTracking.exitTimestamp < nextWeek) {\n                                // Exit was in this week, continue with next tick\n                                tickActiveEnd = tickTracking.exitTimestamp;\n                                tickTrackingIndex++;\n                                dt = tickActiveEnd - tickActiveStart;\n                            } else {\n                                // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                tickActiveEnd = nextWeek;\n                            }\n                        }\n                        timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n                            (tickActiveEnd - tickActiveStart) * liquidity;\n                    }\n                    time += dt;\n                }\n                if (tickTrackingIndex != origIndex) {\n                    tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n                }\n            }\n        } else {\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                if (numTickTracking > 0) {\n                    if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n                        // Tick currently active\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n                    } else {\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n                    }\n                }\n            }\n        }\n        timeWeightedWeeklyPositionConcLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimConcentratedRewards(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick,\n        uint32[] memory weeksToClaim\n    ) internal {\n        accrueConcentratedPositionTimeWeightedLiquidity(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        // Need to do a global accrual in case the current tick was already in range for a long time without any modifications that triggered an accrual\n        accrueConcentratedGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !concLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallInRangeLiquidity = timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][week];\n            if (overallInRangeLiquidity > 0) {\n                uint256 inRangeLiquidityOfPosition;\n                for (int24 j = lowerTick + 10; j <= upperTick - 10; ++j) {\n                    inRangeLiquidityOfPosition += timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][week][j];\n                }\n                // Percentage of this weeks overall in range liquidity that was provided by the user times the overall weekly rewards\n                rewardsToSend += inRangeLiquidityOfPosition * concRewardPerWeek_[poolIdx][week] / overallInRangeLiquidity;\n            }\n            concLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n\n    function accrueAmbientGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.ambientSeeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalAmbLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    function accrueAmbientPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx\n    ) internal {\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint32 lastAccrued = timeWeightedWeeklyPositionAmbLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only init time on first call\n        if (lastAccrued != 0) {\n            AmbientPosition storage pos = lookupPosition(owner, poolIdx);\n            uint256 liquidity = pos.seeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyPositionAmbLiquidity_[poolIdx][posKey][\n                    currWeek\n                ] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyPositionAmbLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimAmbientRewards(\n        address owner,\n        bytes32 poolIdx,\n        uint32[] memory weeksToClaim\n    ) internal {\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        accrueAmbientPositionTimeWeightedLiquidity(payable(owner), poolIdx);\n        accrueAmbientGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !ambLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallTimeWeightedLiquidity = timeWeightedWeeklyGlobalAmbLiquidity_[\n                    poolIdx\n                ][week];\n            if (overallTimeWeightedLiquidity > 0) {\n                uint256 rewardsForWeek = (timeWeightedWeeklyPositionAmbLiquidity_[\n                    poolIdx\n                ][posKey][week] * ambRewardPerWeek_[poolIdx][week]) /\n                    overallTimeWeightedLiquidity;\n                rewardsToSend += rewardsForWeek;\n            }\n            ambLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/mixins/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"./PositionRegistrar.sol\";\nimport \"./StorageLayout.sol\";\nimport \"./PoolRegistry.sol\";\n\n/* @title Liquidity mining mixin\n * @notice Contains the functions related to liquidity mining claiming. */\ncontract LiquidityMining is PositionRegistrar {\n    uint256 constant WEEK = 604800; // Week in seconds 604800\n\n    /// @notice Initialize the tick tracking for the first tick of a pool\n    function initTickTracking(bytes32 poolIdx, int24 tick) internal {\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][tick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the tick crossings\n    /// @dev Needs to be called whenever a tick is crossed\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the global in-range time-weighted concentrated liquidity per week\n    /// @dev Needs to be called whenever the concentrated liquidity is modified (tick crossed, positions changed)\n    function accrueConcentratedGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalConcLiquidityLastSet_[\n            poolIdx\n        ];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.concLiq_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalConcLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n    /// @dev Needs to be called whenever a position is modified\n    function accrueConcentratedPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal {\n        RangePosition72 storage pos = lookupPosition(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = pos.liquidity_;\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                uint32 origIndex = tickTrackingIndex;\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                uint32 time = lastAccrued;\n                // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                    TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                    uint32 currWeek = uint32((time / WEEK) * WEEK);\n                    uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                    uint32 dt = uint32(\n                        nextWeek < block.timestamp\n                            ? nextWeek - time\n                            : block.timestamp - time\n                    );\n                    uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                    uint32 tickActiveEnd;\n                    if (tickTracking.enterTimestamp < nextWeek) {\n                        // Tick was active before next week, need to add the liquidity\n                        if (tickTracking.enterTimestamp < time) {\n                            // Tick was already active when last claim happened, only accrue from last claim timestamp\n                            tickActiveStart = time;\n                        } else {\n                            // Tick has become active this week\n                            tickActiveStart = tickTracking.enterTimestamp;\n                        }\n                        if (tickTracking.exitTimestamp == 0) {\n                            // Tick still active, do not increase index because we need to continue from here\n                            tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                        } else {\n                            // Tick is no longer active\n                            if (tickTracking.exitTimestamp < nextWeek) {\n                                // Exit was in this week, continue with next tick\n                                tickActiveEnd = tickTracking.exitTimestamp;\n                                tickTrackingIndex++;\n                                dt = tickActiveEnd - tickActiveStart;\n                            } else {\n                                // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                tickActiveEnd = nextWeek;\n                            }\n                        }\n                        timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n                            (tickActiveEnd - tickActiveStart) * liquidity;\n                    }\n                    time += dt;\n                }\n                if (tickTrackingIndex != origIndex) {\n                    tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n                }\n            }\n        } else {\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                if (numTickTracking > 0) {\n                    if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n                        // Tick currently active\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n                    } else {\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n                    }\n                }\n            }\n        }\n        timeWeightedWeeklyPositionConcLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimConcentratedRewards(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick,\n        uint32[] memory weeksToClaim\n    ) internal {\n        accrueConcentratedPositionTimeWeightedLiquidity(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        // Need to do a global accrual in case the current tick was already in range for a long time without any modifications that triggered an accrual\n        accrueConcentratedGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !concLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallInRangeLiquidity = timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][week];\n            if (overallInRangeLiquidity > 0) {\n                uint256 inRangeLiquidityOfPosition;\n                for (int24 j = lowerTick + 10; j <= upperTick - 10; ++j) {\n                    inRangeLiquidityOfPosition += timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][week][j];\n                }\n                // Percentage of this weeks overall in range liquidity that was provided by the user times the overall weekly rewards\n                rewardsToSend += inRangeLiquidityOfPosition * concRewardPerWeek_[poolIdx][week] / overallInRangeLiquidity;\n            }\n            concLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n\n    function accrueAmbientGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.ambientSeeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalAmbLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    function accrueAmbientPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx\n    ) internal {\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint32 lastAccrued = timeWeightedWeeklyPositionAmbLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only init time on first call\n        if (lastAccrued != 0) {\n            AmbientPosition storage pos = lookupPosition(owner, poolIdx);\n            uint256 liquidity = pos.seeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyPositionAmbLiquidity_[poolIdx][posKey][\n                    currWeek\n                ] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyPositionAmbLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimAmbientRewards(\n        address owner,\n        bytes32 poolIdx,\n        uint32[] memory weeksToClaim\n    ) internal {\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        accrueAmbientPositionTimeWeightedLiquidity(payable(owner), poolIdx);\n        accrueAmbientGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !ambLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallTimeWeightedLiquidity = timeWeightedWeeklyGlobalAmbLiquidity_[\n                    poolIdx\n                ][week];\n            if (overallTimeWeightedLiquidity > 0) {\n                uint256 rewardsForWeek = (timeWeightedWeeklyPositionAmbLiquidity_[\n                    poolIdx\n                ][posKey][week] * ambRewardPerWeek_[poolIdx][week]) /\n                    overallTimeWeightedLiquidity;\n                rewardsToSend += rewardsForWeek;\n            }\n            ambLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n}"
    }
  ]
}