{
  "Title": "M-1: ERC5095 has not approved MarketPlace to spend tokens in ERC5095",
  "Content": "# Issue M-1: ERC5095 has not approved MarketPlace to spend tokens in ERC5095 \n\nSource: https://github.com/sherlock-audit/2023-01-illuminate-judging/issues/23 \n\n## Found by \ncccz\n\n## Summary\nERC5095 requires approving MarketPlace to spend the tokens in ERC5095 before calling MarketPlace.sellUnderlying/sellPrincipalToken\n## Vulnerability Detail\nMarketPlace.sellUnderlying/sellPrincipalToken will call transferFrom to send tokens from msg.sender to pool, which requires msg.sender to approve MarketPlace.\nHowever, before calling MarketPlace.sellUnderlying/sellPrincipalToken in ERC5095, there is no approval for MarketPlace to spend the tokens in ERC5095, which causes functions such as ERC5095.deposit/mint/withdraw/redeem functions fail, i.e. users cannot sell tokens through ERC5095.\n```solidity\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the number of PTs received for selling `a` underlying tokens\n        uint128 expected = pool.sellBasePreview(a);\n\n        // Verify slippage does not exceed the one set by the user\n        if (expected < s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\n...\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Preview amount of underlying received by selling `a` PTs\n        uint256 expected = pool.sellFYTokenPreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected < s) {\n            revert Exception(16, expected, s, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            a\n        );\n```\nIn the test file, `vm.startPrank(address(token))` is used and approves the MarketPlace, which cannot be done in the mainnet\n```solidity\n        vm.startPrank(address(token));\n        IERC20(Contracts.USDC).approve(address(marketplace), type(uint256).max);\n        IERC20(Contracts.YIELD_TOKEN).approve(\n            address(marketplace),\n            type(uint256).max\n        );\n```\n## Impact\nIt makes functions such as ERC5095.deposit/mint/withdraw/redeem functions fail, i.e. users cannot sell tokens through ERC5095.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/MarketPlace.sol#L396-L414\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/MarketPlace.sol#L319-L342\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/tokens/ERC5095.sol#L188-L197\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/tokens/ERC5095.sol#L230-L244\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/tokens/ERC5095.sol#L267-L276\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/tokens/ERC5095.sol#L372-L385\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/tokens/ERC5095.sol#L267-L307\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/tokens/ERC5095.sol#L372-L409\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/test/fork/ERC5095.t.sol#L72-L77\n## Tool used\n\nManual Review\n\n## Recommendation\nApprove MarketPlace to spend tokens in ERC5095 in ERC5095.setPool.\n```diff\n    function setPool(address p)\n        external\n        authorized(marketplace)\n        returns (bool)\n    {\n        pool = p.fyToken();\n+      Safe.approve(IERC20(underlying), marketplace, type(uint256).max);\n+      Safe.approve(IERC20(p.), marketplace, type(uint256).max);\n\n        return true;\n    }\n\n        pool = address(0);\n    }\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/35",
  "Code": [
    {
      "filename": "src/MarketPlace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC5095.sol';\nimport 'src/lib/Safe.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/ILender.sol';\nimport 'src/interfaces/ICreator.sol';\nimport 'src/interfaces/IPool.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the available principals for each loan market.\n/// @notice In addition, this contract routes swap orders between Illuminate PTs and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate, // 0\n        Swivel, // 1\n        Yield, // 2\n        Element, // 3\n        Pendle, // 4\n        Tempus, // 5\n        Sense, // 6\n        Apwine, // 7\n        Notional // 8\n    }\n\n    /// @notice markets are defined by a tuple that points to a fixed length array of principal token addresses.\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set pools, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n    /// @notice address of the deployed creator contract\n    address public immutable creator;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address[9] tokens,\n        address element,\n        address apwine\n    );\n    /// @notice emitted upon setting a principal token\n    event SetPrincipal(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed principal,\n        uint8 protocol\n    );\n    /// @notice emitted upon swapping with the pool\n    event Swap(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address sold,\n        address bought,\n        uint256 received,\n        uint256 spent,\n        address spender\n    );\n    /// @notice emitted upon minting tokens with the pool\n    event Mint(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 underlyingIn,\n        uint256 principalTokensIn,\n        uint256 minted,\n        address minter\n    );\n    /// @notice emitted upon burning tokens with the pool\n    event Burn(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 tokensBurned,\n        uint256 underlyingReceived,\n        uint256 principalTokensReceived,\n        address burner\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting a pool\n    event SetPool(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed pool\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice initializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    /// @param c address of the deployed creator contract\n    constructor(\n        address r,\n        address l,\n        address c\n    ) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n        creator = c;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market\n    /// @param n name for the Illuminate token\n    /// @param s symbol for the Illuminate token\n    /// @param a address of the APWine router that corresponds to this market\n    /// @param e address of the Element vault that corresponds to this market\n    /// @param h address of a helper contract, used for Sense approvals if active in the market\n    /// @param sensePeriphery address of the Sense periphery contract that must be approved by the lender\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] calldata t,\n        string calldata n,\n        string calldata s,\n        address a,\n        address e,\n        address h,\n        address sensePeriphery\n    ) external authorized(admin) returns (bool) {\n        {\n            // Get the Illuminate principal token for this market (if one exists)\n            address illuminate = markets[u][m][0];\n\n            // If illuminate PT already exists, a new market cannot be created\n            if (illuminate != address(0)) {\n                revert Exception(9, 0, 0, illuminate, address(0));\n            }\n        }\n\n        // Create an Illuminate principal token for the new market\n        address illuminateToken = ICreator(creator).create(\n            u,\n            m,\n            redeemer,\n            lender,\n            address(this),\n            n,\n            s\n        );\n\n        {\n            // create the principal tokens array\n            address[9] memory market = [\n                illuminateToken, // Illuminate\n                t[0], // Swivel\n                t[1], // Yield\n                t[2], // Element\n                t[3], // Pendle\n                t[4], // Tempus\n                t[5], // Sense\n                t[6], // APWine\n                t[7] // Notional\n            ];\n\n            // Set the market\n            markets[u][m] = market;\n\n            // Have the lender contract approve the several contracts\n            ILender(lender).approve(u, a, e, t[7], sensePeriphery);\n\n            // Have the redeemer contract approve the Pendle principal token\n            if (t[3] != address(0)) {\n                address underlyingYieldToken = IPendleToken(t[3])\n                    .underlyingYieldToken();\n                IRedeemer(redeemer).approve(underlyingYieldToken);\n            }\n\n            // Allow converter to spend interest bearing asset\n            if (t[5] != address(0)) {\n                IRedeemer(redeemer).approve(h);\n            }\n\n            // Approve interest bearing token conversion to underlying for APWine\n            if (t[6] != address(0)) {\n                address futureVault = IAPWineToken(t[6]).futureVault();\n                address interestBearingToken = IAPWineFutureVault(futureVault)\n                    .getIBTAddress();\n                IRedeemer(redeemer).approve(interestBearingToken);\n            }\n\n            emit CreateMarket(u, m, market, e, a);\n        }\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the new principal token\n    /// @param h a supplementary address (apwine needs a router, element needs a vault, sense needs interest bearing asset)\n    /// @param sensePeriphery address of the Sense periphery contract that must be approved by the lender\n    /// @return bool true if the principal set, false otherwise\n    function setPrincipal(\n        uint8 p,\n        address u,\n        uint256 m,\n        address a,\n        address h,\n        address sensePeriphery\n    ) external authorized(admin) returns (bool) {\n        // Set the principal token in the markets mapping\n        markets[u][m][p] = a;\n\n        if (p == uint8(Principals.Element)) {\n            // Approve Element vault if setting Element's principal token\n            ILender(lender).approve(u, address(0), h, address(0), address(0));\n        } else if (p == uint8(Principals.Pendle)) {\n            // Principal token must be approved for Pendle's redeem\n            address underlyingYieldToken = IPendleToken(a)\n                .underlyingYieldToken();\n            IRedeemer(redeemer).approve(underlyingYieldToken);\n        } else if (p == uint8(Principals.Sense)) {\n            // Approve converter to transfer yield token for Sense's redeem\n            IRedeemer(redeemer).approve(h);\n\n            // Approve Periphery to be used from Lender\n            ILender(lender).approve(\n                u,\n                address(0),\n                address(0),\n                address(0),\n                sensePeriphery\n            );\n        } else if (p == uint8(Principals.Apwine)) {\n            // Approve converter to transfer yield token for APWine's redeem\n            address futureVault = IAPWineToken(a).futureVault();\n            address interestBearingToken = IAPWineFutureVault(futureVault)\n                .getIBTAddress();\n            IRedeemer(redeemer).approve(interestBearingToken);\n\n            // Approve APWine's router if setting APWine's principal token\n            ILender(lender).approve(u, h, address(0), address(0), address(0));\n        } else if (p == uint8(Principals.Notional)) {\n            // Principal token must be approved for Notional's lend\n            ILender(lender).approve(u, address(0), address(0), a, address(0));\n        }\n\n        emit SetPrincipal(u, m, a, p);\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if the admin set, false otherwise\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address for a pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the pool\n    /// @return bool true if the pool set, false otherwise\n    function setPool(\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        // Verify that the pool has not already been set\n        address pool = pools[u][m];\n\n        // Revert if the pool already exists\n        if (pool != address(0)) {\n            revert Exception(10, 0, 0, pool, address(0));\n        }\n\n        // Set the pool\n        pools[u][m] = a;\n\n        // Get the principal token\n        ERC5095 pt = ERC5095(markets[u][m][uint8(Principals.Illuminate)]);\n\n        // Set the pool for the principal token\n        pt.setPool(a);\n\n        emit SetPool(u, m, a);\n        return true;\n    }\n\n    /// @notice sells the PT for the underlying via the pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PTs to sell\n    /// @param s slippage cap, minimum amount of underlying that must be received\n    /// @return uint128 amount of underlying bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Preview amount of underlying received by selling `a` PTs\n        uint256 expected = pool.sellFYTokenPreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected < s) {\n            revert Exception(16, expected, s, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            a\n        );\n\n        // Execute the swap\n        uint128 received = pool.sellFYToken(msg.sender, Cast.u128(expected));\n        emit Swap(u, m, address(pool.fyToken()), u, received, a, msg.sender);\n\n        return received;\n    }\n\n    /// @notice buys the PT for the underlying via the pool\n    /// @notice determines how many underlying to sell by using the preview\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PTs to be purchased\n    /// @param s slippage cap, maximum number of underlying that can be sold\n    /// @return uint128 amount of underlying sold\n    function buyPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the amount of base hypothetically required to purchase `a` PTs\n        uint128 expected = pool.buyFYTokenPreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected > s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(\n            IERC20(pool.base()),\n            msg.sender,\n            address(pool),\n            expected\n        );\n\n        // Execute the swap to purchase `a` base tokens\n        uint128 spent = pool.buyFYToken(msg.sender, a, expected);\n\n        emit Swap(u, m, u, address(pool.fyToken()), a, spent, msg.sender);\n        return spent;\n    }\n\n    /// @notice sells the underlying for the PT via the pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to sell\n    /// @param s slippage cap, minimum number of PTs that must be received\n    /// @return uint128 amount of PT purchased\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the number of PTs received for selling `a` underlying tokens\n        uint128 expected = pool.sellBasePreview(a);\n\n        // Verify slippage does not exceed the one set by the user\n        if (expected < s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\n\n        // Execute the swap\n        uint128 received = pool.sellBase(msg.sender, expected);\n\n        emit Swap(u, m, u, address(pool.fyToken()), received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @notice determines how many PTs to sell by using the preview\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to be purchased\n    /// @param s slippage cap, maximum number of PTs that can be sold\n    /// @return uint128 amount of PTs sold\n    function buyUnderlying(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the amount of PTs hypothetically required to purchase `a` underlying\n        uint256 expected = pool.buyBasePreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected > s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            expected\n        );\n\n        // Execute the swap to purchase `a` underlying tokens\n        uint128 spent = pool.buyBase(msg.sender, a, Cast.u128(expected));\n\n        emit Swap(u, m, address(pool.fyToken()), u, a, spent, msg.sender);\n        return spent;\n    }\n\n    /// @notice mint liquidity tokens in exchange for adding underlying and PT\n    /// @dev amount of liquidity tokens to mint is calculated from the amount of unaccounted for PT in this contract.\n    /// @dev A proportional amount of underlying tokens need to be present in this contract, also unaccounted for.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param b number of base tokens\n    /// @param p the principal token amount being sent\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool.\n    /// @param maxRatio maximum ratio of LP tokens to PT in the pool.\n    /// @return uint256 number of base tokens passed to the method\n    /// @return uint256 number of yield tokens passed to the method\n    /// @return uint256 the amount of tokens minted.\n    function mint(\n        address u,\n        uint256 m,\n        uint256 b,\n        uint256 p,\n        uint256 minRatio,\n        uint256 maxRatio\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), b);\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            p\n        );\n\n        // Mint the tokens and return the leftover assets to the caller\n        (uint256 underlyingIn, uint256 principalTokensIn, uint256 minted) = pool\n            .mint(msg.sender, msg.sender, minRatio, maxRatio);\n\n        emit Mint(u, m, underlyingIn, principalTokensIn, minted, msg.sender);\n        return (underlyingIn, principalTokensIn, minted);\n    }\n\n    /// @notice Mint liquidity tokens in exchange for adding only underlying\n    /// @dev amount of liquidity tokens is calculated from the amount of PT to buy from the pool,\n    /// plus the amount of unaccounted for PT in this contract.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the underlying amount being sent\n    /// @param p amount of `PT` being bought in the Pool, from this we calculate how much underlying it will be taken in.\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool.\n    /// @param maxRatio maximum ratio of LP tokens to PT in the pool.\n    /// @return uint256 number of base tokens passed to the method\n    /// @return uint256 number of yield tokens passed to the method\n    /// @return uint256 the amount of tokens minted.\n    function mintWithUnderlying(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 p,\n        uint256 minRatio,\n        uint256 maxRatio\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\n\n        // Mint the tokens to the user\n        (uint256 underlyingIn, , uint256 minted) = pool.mintWithBase(\n            msg.sender,\n            msg.sender,\n            p,\n            minRatio,\n            maxRatio\n        );\n\n        emit Mint(u, m, underlyingIn, 0, minted, msg.sender);\n        return (underlyingIn, 0, minted);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying and PT.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the amount of liquidity tokens to burn\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool\n    /// @param maxRatio maximum ratio of LP tokens to PT in the pool\n    /// @return uint256 amount of LP tokens burned\n    /// @return uint256 amount of base tokens received\n    /// @return uint256 amount of fyTokens received\n    function burn(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 minRatio,\n        uint256 maxRatio\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(address(pool)), msg.sender, address(pool), a);\n\n        // Burn the tokens\n        (\n            uint256 tokensBurned,\n            uint256 underlyingReceived,\n            uint256 principalTokensReceived\n        ) = pool.burn(msg.sender, msg.sender, minRatio, maxRatio);\n\n        emit Burn(\n            u,\n            m,\n            tokensBurned,\n            underlyingReceived,\n            principalTokensReceived,\n            msg.sender\n        );\n        return (tokensBurned, underlyingReceived, principalTokensReceived);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the amount of liquidity tokens to burn\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool.\n    /// @param maxRatio minimum ratio of LP tokens to PT in the pool.\n    /// @return uint256 amount of PT tokens sent to the pool\n    /// @return uint256 amount of underlying tokens returned\n    function burnForUnderlying(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(address(pool)), msg.sender, address(pool), a);\n\n        // Burn the tokens in exchange for underlying tokens\n        (uint256 tokensBurned, uint256 underlyingReceived) = pool.burnForBase(\n            msg.sender,\n            minRatio,\n            maxRatio\n        );\n\n        emit Burn(u, m, tokensBurned, underlyingReceived, 0, msg.sender);\n        return (tokensBurned, underlyingReceived);\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param c An array of inputs for each call.\n    function batch(bytes[] calldata c)\n        external\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](c.length);\n        for (uint256 i; i < c.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                c[i]\n            );\n            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n            results[i] = result;\n        }\n    }\n}"
    },
    {
      "filename": "src/MarketPlace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC5095.sol';\nimport 'src/lib/Safe.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/ILender.sol';\nimport 'src/interfaces/ICreator.sol';\nimport 'src/interfaces/IPool.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the available principals for each loan market.\n/// @notice In addition, this contract routes swap orders between Illuminate PTs and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate, // 0\n        Swivel, // 1\n        Yield, // 2\n        Element, // 3\n        Pendle, // 4\n        Tempus, // 5\n        Sense, // 6\n        Apwine, // 7\n        Notional // 8\n    }\n\n    /// @notice markets are defined by a tuple that points to a fixed length array of principal token addresses.\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set pools, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n    /// @notice address of the deployed creator contract\n    address public immutable creator;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address[9] tokens,\n        address element,\n        address apwine\n    );\n    /// @notice emitted upon setting a principal token\n    event SetPrincipal(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed principal,\n        uint8 protocol\n    );\n    /// @notice emitted upon swapping with the pool\n    event Swap(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address sold,\n        address bought,\n        uint256 received,\n        uint256 spent,\n        address spender\n    );\n    /// @notice emitted upon minting tokens with the pool\n    event Mint(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 underlyingIn,\n        uint256 principalTokensIn,\n        uint256 minted,\n        address minter\n    );\n    /// @notice emitted upon burning tokens with the pool\n    event Burn(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 tokensBurned,\n        uint256 underlyingReceived,\n        uint256 principalTokensReceived,\n        address burner\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting a pool\n    event SetPool(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed pool\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice initializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    /// @param c address of the deployed creator contract\n    constructor(\n        address r,\n        address l,\n        address c\n    ) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n        creator = c;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market\n    /// @param n name for the Illuminate token\n    /// @param s symbol for the Illuminate token\n    /// @param a address of the APWine router that corresponds to this market\n    /// @param e address of the Element vault that corresponds to this market\n    /// @param h address of a helper contract, used for Sense approvals if active in the market\n    /// @param sensePeriphery address of the Sense periphery contract that must be approved by the lender\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] calldata t,\n        string calldata n,\n        string calldata s,\n        address a,\n        address e,\n        address h,\n        address sensePeriphery\n    ) external authorized(admin) returns (bool) {\n        {\n            // Get the Illuminate principal token for this market (if one exists)\n            address illuminate = markets[u][m][0];\n\n            // If illuminate PT already exists, a new market cannot be created\n            if (illuminate != address(0)) {\n                revert Exception(9, 0, 0, illuminate, address(0));\n            }\n        }\n\n        // Create an Illuminate principal token for the new market\n        address illuminateToken = ICreator(creator).create(\n            u,\n            m,\n            redeemer,\n            lender,\n            address(this),\n            n,\n            s\n        );\n\n        {\n            // create the principal tokens array\n            address[9] memory market = [\n                illuminateToken, // Illuminate\n                t[0], // Swivel\n                t[1], // Yield\n                t[2], // Element\n                t[3], // Pendle\n                t[4], // Tempus\n                t[5], // Sense\n                t[6], // APWine\n                t[7] // Notional\n            ];\n\n            // Set the market\n            markets[u][m] = market;\n\n            // Have the lender contract approve the several contracts\n            ILender(lender).approve(u, a, e, t[7], sensePeriphery);\n\n            // Have the redeemer contract approve the Pendle principal token\n            if (t[3] != address(0)) {\n                address underlyingYieldToken = IPendleToken(t[3])\n                    .underlyingYieldToken();\n                IRedeemer(redeemer).approve(underlyingYieldToken);\n            }\n\n            // Allow converter to spend interest bearing asset\n            if (t[5] != address(0)) {\n                IRedeemer(redeemer).approve(h);\n            }\n\n            // Approve interest bearing token conversion to underlying for APWine\n            if (t[6] != address(0)) {\n                address futureVault = IAPWineToken(t[6]).futureVault();\n                address interestBearingToken = IAPWineFutureVault(futureVault)\n                    .getIBTAddress();\n                IRedeemer(redeemer).approve(interestBearingToken);\n            }\n\n            emit CreateMarket(u, m, market, e, a);\n        }\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the new principal token\n    /// @param h a supplementary address (apwine needs a router, element needs a vault, sense needs interest bearing asset)\n    /// @param sensePeriphery address of the Sense periphery contract that must be approved by the lender\n    /// @return bool true if the principal set, false otherwise\n    function setPrincipal(\n        uint8 p,\n        address u,\n        uint256 m,\n        address a,\n        address h,\n        address sensePeriphery\n    ) external authorized(admin) returns (bool) {\n        // Set the principal token in the markets mapping\n        markets[u][m][p] = a;\n\n        if (p == uint8(Principals.Element)) {\n            // Approve Element vault if setting Element's principal token\n            ILender(lender).approve(u, address(0), h, address(0), address(0));\n        } else if (p == uint8(Principals.Pendle)) {\n            // Principal token must be approved for Pendle's redeem\n            address underlyingYieldToken = IPendleToken(a)\n                .underlyingYieldToken();\n            IRedeemer(redeemer).approve(underlyingYieldToken);\n        } else if (p == uint8(Principals.Sense)) {\n            // Approve converter to transfer yield token for Sense's redeem\n            IRedeemer(redeemer).approve(h);\n\n            // Approve Periphery to be used from Lender\n            ILender(lender).approve(\n                u,\n                address(0),\n                address(0),\n                address(0),\n                sensePeriphery\n            );\n        } else if (p == uint8(Principals.Apwine)) {\n            // Approve converter to transfer yield token for APWine's redeem\n            address futureVault = IAPWineToken(a).futureVault();\n            address interestBearingToken = IAPWineFutureVault(future"
    }
  ]
}