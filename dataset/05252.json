{
  "Title": "[M-21] When forming POL the DAO will end up stucked with DAI and USDS tokens that cannot handle",
  "Content": "\nThe DAO contract cannot handle any token beside SALT tokens. So, if tokens like USDS or DAI were in its balance, they will be lost forever.\n\nThis can happen during the `upkeep` calls. Basically, during upkeep the contract takes some percentage from the arbitrage profits and use them to form POL for the DAO (usds/dai and salt/usds). The DAO swaps the ETH for both of the needed tokens and then adds the liquidity using the zapping flag to true.\n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/DAO.sol#L316-L324>\n\nZapping will compute the amount of either tokenA or tokenB to swap in order to add liquidity at the final ratio of reserves after the swap. But, it is important to note that the zap computations do no take into account that the same pool may get arbitraged atomically, changing the ratio of reserves a little.\n\nAs a consequence, some of the USDS and DAI tokens will be send back to the DAO contract:\n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/Liquidity.sol#L110C3-L115C1>\n\n### Proof of Concept\n\nThe following coded PoC should be pasted into `root_tests/Upkeep.t.sol`, actually its the same test that can be found at the end of the file with some added lines to showcase the issue. Specifically, it shows how the USDS and DAI balance of the DAO are zero before upkeep and how both are greater than zero after upkeep.\n\n<details>\n\n```solidity\nfunction testDoublePerformUpkeep() public {\n\n        _setupLiquidity();\n        _generateArbitrageProfits(false);\n\n    \t// Dummy WBTC and WETH to send to Liquidizer\n    \tvm.prank(DEPLOYER);\n    \tweth.transfer( address(liquidizer), 50 ether );\n\n    \t// Indicate that some USDS should be burned\n    \tvm.prank( address(collateralAndLiquidity));\n    \tliquidizer.incrementBurnableUSDS( 40 ether);\n\n    \t// Mimic arbitrage profits deposited as WETH for the DAO\n    \tvm.prank(DEPLOYER);\n    \tweth.transfer(address(dao), 100 ether);\n\n    \tvm.startPrank(address(dao));\n    \tweth.approve(address(pools), 100 ether);\n    \tpools.deposit(weth, 100 ether);\n    \tvm.stopPrank();\n\n        // === Perform upkeep ===\n        address upkeepCaller = address(0x9999);\n\n        uint256 daiDaoBalanceBefore = dai.balanceOf(address(dao));\n        uint256 usdsDaoBalanceBefore = usds.balanceOf(address(dao));\n\n        assertEq(daiDaoBalanceBefore, 0);\n        assertEq(usdsDaoBalanceBefore, 0);\n\n        vm.prank(upkeepCaller);\n        upkeep.performUpkeep();\n        // ==================\n\n        _secondPerformUpkeep();\n\n        uint256 daiDaoBalanceAfter = dai.balanceOf(address(dao));\n        uint256 usdsDaoBalanceAfter = usds.balanceOf(address(dao));\n\n        assertTrue(daiDaoBalanceAfter > 0);\n        assertTrue(usdsDaoBalanceAfter > 0);\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nThe leftovers of USDS or DAI should be send to liquidizer so they can be handled.\n\n**[othernet-global (Salty.IO) commented](https://github.com/code-423n4/2024-01-salty-findings/issues/324#issuecomment-1950531010):**\n > The DAO contract uses the available token balances to form POL, ensuring no extra tokens left in the contract.\n> \n> https://github.com/othernet-global/salty-io/commit/5364426aaf97e646fa3990f148e364167adcd0a5\n\n > POL has been removed from the protocol:\n> \n> [eaf40ef0fa27314c6e674db6830990df68e5d70e](https://github.com/othernet-global/salty-io/commit/eaf40ef0fa27314c6e674db6830990df68e5d70e)\n> https://github.com/othernet-global/salty-io/commit/8e3231d3f444e9851881d642d6dd03021fade5ed\n> \n\n**Status:** Mitigation confirmed. Full details in reports from [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/84), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/104), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/20).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/dao/DAO.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"../rewards/interfaces/IRewardsEmitter.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../stable/interfaces/IStableConfig.sol\";\nimport \"../stable/interfaces/ILiquidizer.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../interfaces/IAccessManager.sol\";\nimport \"./interfaces/ICalledContract.sol\";\nimport \"./interfaces/IProposals.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"../pools/PoolUtils.sol\";\nimport \"./Parameters.sol\";\nimport \"../Upkeep.sol\";\n\n\n// Allows users to propose and vote on various governance actions such as changing parameters, whitelisting/unwhitelisting tokens, sending tokens, calling other contracts, and updating the website.\n// It handles proposing ballots, tracking votes, enforcing voting requirements, and executing approved proposals.\ncontract DAO is IDAO, Parameters, ReentrancyGuard\n    {\n\tevent BallotFinalized(uint256 indexed ballotID, Vote winningVote);\n    event SetContract(string indexed ballotName, address indexed contractAddress);\n    event SetWebsiteURL(string newURL);\n    event WhitelistToken(IERC20 indexed token);\n    event UnwhitelistToken(IERC20 indexed token);\n    event GeoExclusionUpdated(string country, bool excluded, uint256 geoVersion);\n    event ArbitrageProfitsWithdrawn(address indexed upkeepContract, IERC20 indexed weth, uint256 withdrawnAmount);\n    event SaltSent(address indexed to, uint256 amount);\n    event ContractCalled(address indexed contractAddress, uint256 indexed intArg);\n    event TeamRewardsTransferred(uint256 teamAmount);\n\n    event POLFormed(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 amountA, uint256 amountB);\n    event POLProcessed(uint256 claimedSALT);\n    event POLWithdrawn(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 withdrawnA, uint256 withdrawnB);\n\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n\n\tIPools immutable public pools;\n\tIProposals immutable public proposals;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIStakingConfig immutable public stakingConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tIStableConfig immutable public stableConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tIRewardsEmitter immutable public liquidityRewardsEmitter;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tILiquidizer immutable public liquidizer;\n\n\tISalt immutable public salt;\n    IUSDS immutable public usds;\n\tIERC20 immutable public dai;\n\n\n\t// The default IPFS URL for the website content (can be changed with a setWebsiteURL proposal)\n\tstring public websiteURL;\n\n\t// Countries that have been excluded from access to the DEX (used by AccessManager.sol)\n\t// Keys as ISO 3166 Alpha-2 Codes\n\tmapping(string=>bool) public excludedCountries;\n\n\n    constructor( IPools _pools, IProposals _proposals, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IRewardsConfig _rewardsConfig, IStableConfig _stableConfig, IDAOConfig _daoConfig, IPriceAggregator _priceAggregator, IRewardsEmitter _liquidityRewardsEmitter, ICollateralAndLiquidity _collateralAndLiquidity )\n\t\t{\n\t\tpools = _pools;\n\t\tproposals = _proposals;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\t\trewardsConfig = _rewardsConfig;\n\t\tstableConfig = _stableConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tpriceAggregator = _priceAggregator;\n        liquidityRewardsEmitter = _liquidityRewardsEmitter;\n        collateralAndLiquidity = _collateralAndLiquidity;\n \t\tliquidizer = collateralAndLiquidity.liquidizer();\n\n        usds = exchangeConfig.usds();\n        salt = exchangeConfig.salt();\n        dai = exchangeConfig.dai();\n\n\t\t// Gas saving approves for eventually forming Protocol Owned Liquidity\n\t\tsalt.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tusds.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tdai.approve(address(collateralAndLiquidity), type(uint256).max);\n\n\t\t// Excluded by default: United States, Canada, United Kingdom, China, India, Pakistan, Russia, Afghanistan, Cuba, Iran, North Korea, Syria, Venezuela\n\t\t// Note that the DAO can remove any of these exclusions - or open up access completely to the exchange as it sees fit.\n\t\texcludedCountries[\"US\"] = true;\n\t\texcludedCountries[\"CA\"] = true;\n\t\texcludedCountries[\"GB\"] = true;\n\t\texcludedCountries[\"CN\"] = true;\n\t\texcludedCountries[\"IN\"] = true;\n\t\texcludedCountries[\"PK\"] = true;\n\t\texcludedCountries[\"RU\"] = true;\n\t\texcludedCountries[\"AF\"] = true;\n\t\texcludedCountries[\"CU\"] = true;\n\t\texcludedCountries[\"IR\"] = true;\n\t\texcludedCountries[\"KP\"] = true;\n\t\texcludedCountries[\"SY\"] = true;\n\t\texcludedCountries[\"VE\"] = true;\n        }\n\n\n\t// Finalize the vote for a parameter ballot (increase, decrease or no_change) for a given parameter\n\tfunction _finalizeParameterBallot( uint256 ballotID ) internal\n\t\t{\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tVote winningVote = proposals.winningParameterVote(ballotID);\n\n\t\tif ( winningVote == Vote.INCREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), true, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\t\telse if ( winningVote == Vote.DECREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), false, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\n\t\t// Finalize the ballot even if NO_CHANGE won\n\t\tproposals.markBallotAsFinalized(ballotID);\n\n\t\temit BallotFinalized(ballotID, winningVote);\n\t\t}\n\n\n\tfunction _executeSetContract( Ballot memory ballot ) internal\n\t\t{\n\t\tbytes32 nameHash = keccak256(bytes( ballot.ballotName ) );\n\n\t\tif ( nameHash == keccak256(bytes( \"setContract:priceFeed1_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 1, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed2_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 2, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed3_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 3, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:accessManager_confirm\" )) )\n\t\t\texchangeConfig.setAccessManager( IAccessManager(ballot.address1) );\n\n\t\temit SetContract(ballot.ballotName, ballot.address1);\n\t\t}\n\n\n\tfunction _executeSetWebsiteURL( Ballot memory ballot ) internal\n\t\t{\n\t\twebsiteURL = ballot.string1;\n\t\temit SetWebsiteURL(ballot.string1);\n\t\t}\n\n\n\tfunction _executeApproval( Ballot memory ballot ) internal\n\t\t{\n\t\tif ( ballot.ballotType == BallotType.UNWHITELIST_TOKEN )\n\t\t\t{\n\t\t\t// All tokens are paired with both WBTC and WETH so unwhitelist those pools\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\temit UnwhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.SEND_SALT )\n\t\t\t{\n\t\t\t// Make sure the contract has the SALT balance before trying to send it.\n\t\t\t// This should not happen but is here just in case - to prevent approved proposals from reverting on finalization.\n\t\t\tif ( exchangeConfig.salt().balanceOf(address(this)) >= ballot.number1 )\n\t\t\t\t{\n\t\t\t\tIERC20(exchangeConfig.salt()).safeTransfer( ballot.address1, ballot.number1 );\n\n\t\t\t\temit SaltSent(ballot.address1, ballot.number1);\n\t\t\t\t}\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.CALL_CONTRACT )\n\t\t\t{\n\t\t\tICalledContract(ballot.address1).callFromDAO( ballot.number1 );\n\n\t\t\temit ContractCalled(ballot.address1, ballot.number1);\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.INCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = false;\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, false, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.EXCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = true;\n\n\t\t\t// If the AccessManager doesn't implement excludedCountriesUpdated, this will revert and countries will not be able to be excluded until the AccessManager is working properly.\n\t\t\texchangeConfig.accessManager().excludedCountriesUpdated();\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, true, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\t// Once an initial setContract proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_CONTRACT )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_CONTRACT, ballot.address1, \"\", ballot.description );\n\n\t\t// Once an initial setWebsiteURL proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_WEBSITE_URL )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_WEBSITE_URL, address(0), ballot.string1, ballot.description );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_CONTRACT )\n\t\t\t_executeSetContract( ballot );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_WEBSITE_URL )\n\t\t\t_executeSetWebsiteURL( ballot );\n\t\t}\n\n\n\t// Finalize the vote for an approval ballot (yes or no) for a given proposal\n\tfunction _finalizeApprovalBallot( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\t\t\t_executeApproval( ballot );\n\t\t\t}\n\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize and execute a token whitelisting ballot.\n\t// If the proposal is currently the whitelisting proposal with the most yes votes then the token can be whitelisted.\n\t// Only the top voted whitelisting proposal can be finalized - as whitelisting requires bootstrapping rewards to be sent from the DAO.\n\t// If NO > YES than the proposal is removed immediately (quorum would already have been determined - in canFinalizeBallot as called from finalizeBallot).\n\tfunction _finalizeTokenWhitelisting( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\t// The ballot is approved. Any reversions below will allow the ballot to be attemped to be finalized later - as the ballot won't be finalized on reversion.\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\t\tuint256 bootstrappingRewards = daoConfig.bootstrappingRewards();\n\n\t\t\t// Make sure that the DAO contract holds the required amount of SALT for bootstrappingRewards.\n\t\t\t// Twice the bootstrapping rewards are needed (for both the token/WBTC and token/WETH pools)\n\t\t\tuint256 saltBalance = exchangeConfig.salt().balanceOf( address(this) );\n\t\t\trequire( saltBalance >= bootstrappingRewards * 2, \"Whitelisting is not currently possible due to insufficient bootstrapping rewards\" );\n\n\t\t\t// Fail to whitelist for now if this isn't the whitelisting proposal with the most votes - can try again later.\n\t\t\tuint256 bestWhitelistingBallotID = proposals.tokenWhitelistingBallotWithTheMostVotes();\n\t\t\trequire( bestWhitelistingBallotID == ballotID, \"Only the token whitelisting ballot with the most votes can be finalized\" );\n\n\t\t\t// All tokens are paired with both WBTC and WETH, so whitelist both pairings\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\tbytes32 pool1 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tbytes32 pool2 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\t// Send the initial bootstrappingRewards to promote initial liquidity on these two newly whitelisted pools\n\t\t\tAddedReward[] memory addedRewards = new AddedReward[](2);\n\t\t\taddedRewards[0] = AddedReward( pool1, bootstrappingRewards );\n\t\t\taddedRewards[1] = AddedReward( pool2, bootstrappingRewards );\n\n\t\t\texchangeConfig.salt().approve( address(liquidityRewardsEmitter), bootstrappingRewards * 2 );\n\t\t\tliquidityRewardsEmitter.addSALTRewards( addedRewards );\n\n\t\t\temit WhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\t// Mark the ballot as finalized (which will also remove it from the list of open token whitelisting proposals)\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize the vote on a specific ballot.\n\t// Can be called by anyone, but only actually finalizes the ballot if it can be finalized.\n\tfunction finalizeBallot( uint256 ballotID ) external nonReentrant\n\t\t{\n\t\t// Checks that ballot is live, and minimumEndTime and quorum have both been reached\n\t\trequire( proposals.canFinalizeBallot(ballotID), \"The ballot is not yet able to be finalized\" );\n\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\t_finalizeParameterBallot(ballotID);\n\t\telse if ( ballot.ballotType == BallotType.WHITELIST_TOKEN )\n\t\t\t_finalizeTokenWhitelisting(ballotID);\n\t\telse\n\t\t\t_finalizeApprovalBallot(ballotID);\n\t\t}\n\n\n\t// Withdraw the WETH arbitrage profits deposited in the Pools contract and send them to the caller (the Upkeep contract).\n\tfunction withdrawArbitrageProfits( IERC20 weth ) external returns (uint256 withdrawnAmount)\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.withdrawArbitrageProfits is only callable from the Upkeep contract\" );\n\n\t\t// The arbitrage profits are deposited in the Pools contract as WETH and owned by the DAO.\n\t\tuint256 depositedWETH = pools.depositedUserBalance(address(this), weth );\n\t\tif ( depositedWETH == 0 )\n\t\t\treturn 0;\n\n\t\tpools.withdraw( weth, depositedWETH );\n\n\t\t// Check the WETH balance - in case any WETH was accidentally sent here previously\n\t\twithdrawnAmount = weth.balanceOf( address(this) );\n\t\tweth.safeTransfer( msg.sender, withdrawnAmount );\n\n\t\temit ArbitrageProfitsWithdrawn(msg.sender, weth, withdrawnAmount);\n\t\t}\n\n\n\t// Form SALT/USDS or USDS/DAI Protocol Owned Liquidity using the given amount of specified tokens.\n\t// Assumes that the tokens have already been transferred to this contract.\n\tfunction formPOL( IERC20 tokenA, IERC20 tokenB, uint256 amountA, uint256 amountB ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.formPOL is only callable from the Upkeep contract\" );\n\n\t\t// Use zapping to form the liquidity so that all the specified tokens are used\n\t\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare( tokenA, tokenB, amountA, amountB, 0, block.timestamp, true );\n\n\t\temit POLFormed(tokenA, tokenB, amountA, amountB);\n\t\t}\n\n\n\tfunction processRewardsFromPOL() external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.processRewardsFromPOL is only callable from the Upkeep contract\" );\n\n\t\t// The DAO owns SALT/USDS and USDS/DAI liquidity.\n\t\tbytes32[] memory poolIDs = new bytes32[](2);\n\t\tpoolIDs[0] = PoolUtils._poolID(salt, usds);\n\t\tpoolIDs[1] = PoolUtils._poolID(usds, dai);\n\n\t\tuint256 claimedSALT = collateralAndLiquidity.claimAllRewards(poolIDs);\n\t\tif ( claimedSALT == 0 )\n\t\t\treturn;\n\n\t\t// Send 10% of the rewards to the initial team\n\t\tuint256 amountToSendToTeam = claimedSALT / 10;\n\t\tsalt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), amountToSendToTeam );\n\t\temit TeamRewardsTransferred(amountToSendToTeam);\n\n\t\tuint256 remainingSALT = claimedSALT - amountToSendToTeam;\n\n\t\t// Burn a default 50% of the remaining SALT that was just claimed - the rest of the SALT stays in the DAO contract.\n\t\tuint256 saltToBurn = ( remainingSALT * daoConfig.percentPolRewardsBurned() ) / 100;\n\n\t\tsalt.safeTransfer( address(salt), saltToBurn );\n\t\tsalt.burnTokensInContract();\n\n\t\temit POLProcessed(claimedSALT);\n\t\t}\n\n\n\t// Withdraws the specified amount of the Protocol Owned Liquidity from the DAO and sends the underlying tokens to the Liquidizer to be burned as USDS as needed.\n\t// Called when the amount of recovered USDS from liquidating a user's WBTC/WETH collateral is insufficient to cover burning the USDS that they had borrowed.\n\t// Only callable from the Liquidizer contract.\n\tfunction withdrawPOL( IERC20 tokenA, IERC20 tokenB, uint256 percentToLiquidate ) external\n\t\t{\n\t\trequire(msg.sender == address(liquidizer), \"DAO.withdrawProtocolOwnedLiquidity is only callable from the Liquidizer contract\" );\n\n\t\tbytes32 poolID = PoolUtils._poolID(tokenA, tokenB);\n\t\tuint256 liquidityHeld = collateralAndLiquidity.userShareForPool( address(this), poolID );\n\t\tif ( liquidityHeld == 0 )\n\t\t\treturn;\n\n\t\tuint256 liquidityToWithdraw = (liquidityHeld * percentToLiquidate) / 100;\n\n\t\t// Withdraw the specified Protocol Owned Liquidity\n\t\t(uint256 reclaimedA, uint256 reclaimedB) = collateralAndLiquidity.withdrawLiquidityAndClaim(tokenA, tokenB, liquidityToWithdraw, 0, 0, block.timestamp );\n\n\t\t// Send the withdrawn tokens to the Liquidizer so that the tokens can be swapped to USDS and burned as needed.\n\t\ttokenA.safeTransfer( address(liquidizer), reclaimedA );\n\t\ttokenB.safeTransfer( address(liquidizer), reclaimedB );\n\n\t\temit POLWithdrawn(tokenA, tokenB, reclaimedA, reclaimedB);\n\t\t}\n\n\n\t// === VIEWS ===\n\n\tfunction countryIsExcluded( string calldata country ) external view returns (bool)\n\t\t{\n\t\treturn excludedCountries[country];\n\t\t}\n\t}"
    },
    {
      "filename": "src/staking/Liquidity.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../pools/interfaces/IPools.sol\";\nimport \"./interfaces/ILiquidity.sol\";\nimport \"./StakingRewards.sol\";\nimport \"../pools/PoolMath.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Allows users to add liquidity and increase their liquidity share in the StakingRewards pool so that they can receive proportional future rewards.\n// Keeps track of the liquidity held by each user via StakingRewards.userShare.\n\nabstract contract Liquidity is ILiquidity, StakingRewards\n    {\n    event LiquidityDeposited(address indexed user, address indexed tokenA, address indexed tokenB, uint256 amountA, uint256 amountB, uint256 addedLiquidity);\n    event LiquidityWithdrawn(address indexed user, address indexed tokenA, address indexed tokenB, uint256 amountA, uint256 amountB, uint256 withdrawnLiquidity);\n\n\tusing SafeERC20 for IERC20;\n\n\tIPools immutable public pools;\n\n\t// The poolID of WBTC/WETH collateral - which should not be withdrawable from this contract directly.\n    bytes32 immutable public collateralPoolID;\n\n\n\tconstructor( IPools _pools, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\tStakingRewards( _exchangeConfig, _poolsConfig, _stakingConfig )\n\t\t{\n\t\tpools = _pools;\n\n\t\tcollateralPoolID = PoolUtils._poolID( exchangeConfig.wbtc(), exchangeConfig.weth() );\n\t\t}\n\n\n\tmodifier ensureNotExpired(uint deadline)\n\t\t{\n\t\trequire(block.timestamp <= deadline, \"TX EXPIRED\");\n\t\t_;\n\t\t}\n\n\n\t// Deposit an arbitrary amount of one or both tokens into the pool and receive liquidity corresponding the the value of both of them.\n\t// As the ratio of tokens added to the pool has to be the same as the existing ratio of reserves, some of the excess token will be swapped to the other.\n\t// Due to precision reduction during zapping calculation, the minimum possible reserves and quantity possible to zap is .000101,\n\tfunction _dualZapInLiquidity(IERC20 tokenA, IERC20 tokenB, uint256 zapAmountA, uint256 zapAmountB ) internal returns (uint256 amountForLiquidityA, uint256 amountForLiquidityB  )\n\t\t{\n\t\t(uint256 reserveA, uint256 reserveB) = pools.getPoolReserves(tokenA, tokenB);\n\t\t(uint256 swapAmountA, uint256 swapAmountB ) = PoolMath._determineZapSwapAmount( reserveA, reserveB, zapAmountA, zapAmountB );\n\n\t\t// tokenA is in excess so swap some of it to tokenB?\n\t\tif ( swapAmountA > 0)\n\t\t\t{\n\t\t\ttokenA.approve( address(pools), swapAmountA );\n\n\t\t\t// Swap from tokenA to tokenB and adjust the zapAmounts\n\t\t\tzapAmountA -= swapAmountA;\n\t\t\tzapAmountB += pools.depositSwapWithdraw( tokenA, tokenB, swapAmountA, 0, block.timestamp );\n\t\t\t}\n\n\t\t// tokenB is in excess so swap some of it to tokenA?\n\t\telse if ( swapAmountB > 0)\n\t\t\t{\n\t\t\ttokenB.approve( address(pools), swapAmountB );\n\n\t\t\t// Swap from tokenB to tokenA and adjust the zapAmounts\n\t\t\tzapAmountB -= swapAmountB;\n\t\t\tzapAmountA += pools.depositSwapWithdraw( tokenB, tokenA, swapAmountB, 0, block.timestamp );\n\t\t\t}\n\n\t\treturn (zapAmountA, zapAmountB);\n\t\t}\n\n\n\t// Add a certain amount of liquidity to the specified pool and increase the user's liquidity share for that pool so that they can receive future rewards.\n\t// With zapping, all the tokens specified by the user are added to the liquidity pool regardless of their ratio.\n\t// If one of the tokens has excess in regards to the reserves token ratio, then some of it is first swapped for the other before the liquidity is added. (See PoolMath.sol for details)\n\t// Requires exchange access for the user.\n\tfunction _depositLiquidityAndIncreaseShare( IERC20 tokenA, IERC20 tokenB, uint256 maxAmountA, uint256 maxAmountB, uint256 minLiquidityReceived, bool useZapping ) internal returns (uint256 addedAmountA, uint256 addedAmountB, uint256 addedLiquidity)\n\t\t{\n\t\trequire( exchangeConfig.walletHasAccess(msg.sender), \"Sender does not have exchange access\" );\n\n\t\t// Transfer the specified maximum amount of tokens from the user\n\t\ttokenA.safeTransferFrom(msg.sender, address(this), maxAmountA );\n\t\ttokenB.safeTransferFrom(msg.sender, address(this), maxAmountB );\n\n\t\t// Balance the token amounts by swapping one to the other before adding the liquidity?\n\t\tif ( useZapping )\n\t\t\t(maxAmountA, maxAmountB) = _dualZapInLiquidity(tokenA, tokenB, maxAmountA, maxAmountB );\n\n\t\t// Approve the liquidity to add\n\t\ttokenA.approve( address(pools), maxAmountA );\n\t\ttokenB.approve( address(pools), maxAmountB );\n\n\t\t// Deposit the specified liquidity into the Pools contract\n\t\t// The added liquidity will be owned by this contract. (external call to Pools contract)\n\t\tbytes32 poolID = PoolUtils._poolID( tokenA, tokenB );\n\t\t(addedAmountA, addedAmountB, addedLiquidity) = pools.addLiquidity( tokenA, tokenB, maxAmountA, maxAmountB, minLiquidityReceived, totalShares[poolID]);\n\n\t\t// Increase the user's liquidity share by the amount of addedLiquidity.\n\t\t// Cooldown is specified to prevent reward hunting (ie - quickly depositing and withdrawing large amounts of liquidity to snipe rewards as they arrive)\n\t\t// _increaseUserShare confirms the pool as whitelisted as well.\n\t\t_increaseUserShare( msg.sender, poolID, addedLiquidity, true );\n\n\t\t// If any of the user's tokens were not used, then send them back\n\t\tif ( addedAmountA < maxAmountA )\n\t\t\ttokenA.safeTransfer( msg.sender, maxAmountA - addedAmountA );\n\n\t\tif ( addedAmountB < maxAmountB )\n\t\t\ttokenB.safeTransfer( msg.sender, maxAmountB - addedAmountB );\n\n\t\temit LiquidityDeposited(msg.sender, address(tokenA), address(tokenB), addedAmountA, addedAmountB, addedLiquidity);\n\t\t}\n\n\n\t// Withdraw specified liquidity, decrease the user's liquidity share and claim any pending rewards.\n    function _withdrawLiquidityAndClaim( IERC20 tokenA, IERC20 tokenB, uint256 liquidityToWithdraw, uint256 minReclaimedA, uint256 minReclaimedB ) internal returns (uint256 reclaimedA, uint256 reclaimedB)\n\t\t{\n\t\tbytes32 poolID = PoolUtils._poolID( tokenA, tokenB );\n\t\trequire( userShareForPool(msg.sender, poolID) >= liquidityToWithdraw, \"Cannot withdraw more than existing user share\" );\n\n\t\t// Remove the amount of liquidity specified by the user.\n\t\t// The liquidity in the pool is currently owned by this contract. (external call)\n\t\t(reclaimedA, reclaimedB) = pools.removeLiquidity( tokenA, tokenB, liquidityToWithdraw, minReclaimedA, minReclaimedB, totalShares[poolID] );\n\n\t\t// Transfer the reclaimed tokens to the user\n\t\ttokenA.safeTransfer( msg.sender, reclaimedA );\n\t\ttokenB.safeTransfer( msg.sender, reclaimedB );\n\n\t\t// Reduce the user's liquidity share for the specified pool so that they receive less rewards.\n\t\t// Cooldown is specified to prevent reward hunting (ie - quickly depositing and withdrawing large amounts of liquidity to snipe rewards)\n\t\t// This call will send any pending SALT rewards to msg.sender as well.\n\t\t_decreaseUserShare( msg.sender, poolID, liquidityToWithdraw, true );\n\n\t\temit LiquidityWithdrawn(msg.sender, address(tokenA), address(tokenB), reclaimedA, reclaimedB, liquidityToWithdraw);\n\t\t}\n\n\n\t// Public wrapper for adding liquidity which prevents direct deposits to the collateral pool.\n\t// CollateralAndLiquidity::depositCollateralAndIncreaseShare bypasses this and calls _depositLiquidityAndIncreaseShare directly.\n\t// Requires exchange access for the sending wallet.\n\tfunction depositLiquidityAndIncreaseShare( IERC20 tokenA, IERC20 tokenB, uint256 maxAmountA, uint256 maxAmountB, uint256 minLiquidityReceived, uint256 deadline, bool useZapping ) external nonReentrant ensureNotExpired(deadline) returns (uint256 addedAmountA, uint256 addedAmountB, uint256 addedLiquidity)\n\t\t{\n\t\trequire( PoolUtils._poolID( tokenA, tokenB ) != collateralPoolID, \"Stablecoin collateral cannot be deposited via Liquidity.depositLiquidityAndIncreaseShare\" );\n\n    \treturn _depositLiquidityAndIncreaseShare(tokenA, tokenB, maxAmountA, maxAmountB, minLiquidityReceived, useZapping);\n\t\t}\n\n\n\t// Public wrapper for withdrawing liquidity which prevents the direct withdrawal from the collateral pool.\n\t// CollateralAndLiquidity.withdrawCollateralAndClaim bypasses this and calls _withdrawLiquidityAndClaim directly.\n\t// No exchange access required for withdrawals.\n    function withdrawLiquidityAndClaim( IERC20 tokenA, IERC20 tokenB, uint256 liquidityToWithdraw, uint256 minReclaimedA, uint256 minReclaimedB, uint256 deadline ) external nonReentrant ensureNotExpired(deadline) returns (uint256 reclaimedA, uint256 reclaimedB)\n    \t{\n\t\trequire( PoolUtils._poolID( tokenA, tokenB ) != collateralPoolID, \"Stablecoin collateral cannot be withdrawn via Liquidity.withdrawLiquidityAndClaim\" );\n\n    \treturn _withdrawLiquidityAndClaim(tokenA, tokenB, liquidityToWithdraw, minReclaimedA, minReclaimedB);\n    \t}\n\t}"
    }
  ]
}