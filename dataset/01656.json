{
  "Title": "H-1: Pool deviation check in SimpleManager on rebalance can be bypassed",
  "Content": "# Issue H-1: Pool deviation check in SimpleManager on rebalance can be bypassed \n\nSource: https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/26 \n\n## Found by \ncergyk, n33k\n## Summary\nIn `SimpleManager` a price deviation check is enforced to prevent an operator to add liquidity to a UniV3 pool at a really unfavorable price during rebalance and backrun to extract vault funds. We will show here that this check can be entirely bypassed by a malicious operator.\n\n## Vulnerability Detail\n\n### Rebalance context\nDuring a call to `SimpleManger.rebalance`, the following operations are run:\n- 1/ Enforce price deviation not too large for mint pools:\nhttps://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-manager-templates/contracts/SimpleManager.sol#L366-L385\n\nand correct slippage parameter for swap:\nhttps://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-manager-templates/contracts/SimpleManager.sol#L318-L354\n\n- 2/ Remove liquidity on specified UniV3 ranges (we are not going to use it here)\n\n- 3/ Use a low level call to a whitelisted Router to execute a swap\nhttps://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-core/contracts/ArrakisV2.sol#L334-L336\n\n- 4/ Enforce received amounts from the swap \n\n- 5/ Provide liquidity on specified UniV3 ranges\n- 6/ Enforce provided amounts during addLiquidity (these parameters are provided by operator and unbounded, so they can be (0, 0), and check is a noop). \n\n### Exploit description\nWe are going to use the swap step (3/) to imbalance the pools after the check of price deviation (1/) is passed, so the liquidity provided in 5/ is done at a really unfavorable price, and can be backrun by the operator to extract funds from the vault.\n\nTo not trigger the slippage protection after the swap, we are going to use the router to swap on a totally unrelated pool of tokens controlled by the malicious operator: `PSN/PSN2` (PSN stands for Poison).\n\n`PSN` token has a callback in the `_transfer` function to make a large swap on UNIv3 pool where the operator is going to provide liquidity in 5/, to deviate it a lot.\n\nafter the call to the router is done, no changes to the balances of the vault have been made, the slippage checks out.\n\nLiquidity provided at 5/ is done at a terrible price for some of the ranges, and the operator backruns for a nice profit. \n\nNB: All these steps can be run inside a flashloan callback, to not use attacker own funds\n\n## Impact\nAn arbitrary amount can be drained from the vault by an operator\n\n## Code Snippet\n\n## Tool used\nManual Review\n\n## Recommendation\nIdeally the check on price deviation should be enforced right before the liquidity providing. \n\n\n\n## Discussion\n\n**syjcnss**\n\nEscalate\n\nThis one should be a valid high and my #187 should be the only duplicate of this.\n\nThis one and #187 both showed that the `swap.router.call` calls into a malicious ERC20 contract that manipulates liquidity pool prices to bypass slippage checks and sandwich attack liquidity adding. I've added additional proof in [the comment](https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/187#issuecomment-1636038030).\n\n#43, #135, #213 are clearly unrelated and should be reevaluated.\n\n#213 should be a dup of #181. They are all about missing checks on burn pools.\n\n**sherlock-admin**\n\n > Escalate\n> \n> This one should be a valid high and my #187 should be the only duplicate of this.\n> \n> This one and #187 both showed that the `swap.router.call` calls into a malicious ERC20 contract that manipulates liquidity pool prices to bypass slippage checks and sandwich attack liquidity adding. I've added additional proof in [the comment](https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/187#issuecomment-1636038030).\n> \n> #43, #135, #213 are clearly unrelated and should be reevaluated.\n> \n> #213 should be a dup of #181. They are all about missing checks on burn pools.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**SergeKireev**\n\nAgree with @syjcnss\n\n**P12473**\n\n> PSN token has a callback in the _transfer function to make a large swap on UNIv3 pool where the operator is going to provide liquidity in 5/, to deviate it a lot.\n\nThe core of this exploit requires a PSN/PSN2 pool where the PSN tokens have a malicious _transfer function but according to the README `These should be assumed to use SimpleManager.sol and Chainlink oracle feed(s) and thus only support \"Major\" tokens with suitable chainlink oracle support.`.\n\nhow easy is it For one to create a malicious token and to provide a feed for it on chainlink?\n\n**syjcnss**\n\n@P12473 \nThe section `1. on the swap slippage check` in [my comment](https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/187#issuecomment-1636038030) in #187 should be able to anwser your question. \n\n**SergeKireev**\n\n> > PSN token has a callback in the _transfer function to make a large swap on UNIv3 pool where the operator is going to provide liquidity in 5/, to deviate it a lot.\n> \n> The core of this exploit requires a PSN/PSN2 pool where the PSN tokens have a malicious _transfer function but according to the README `These should be assumed to use SimpleManager.sol and Chainlink oracle feed(s) and thus only support \"Major\" tokens with suitable chainlink oracle support.`. \n> \n> How easy is it for one to create a malicious token and to provide a feed for it on chainlink?\n\n@syjcnss explained it very well in his linked comment.\n\nI would like to add there is no need for chainlink feeds on poison tokens, since they would only be passed inside the payload used for the router call, and Arrakis never decodes this payload\n\n**P12473**\n\n> > > PSN token has a callback in the _transfer function to make a large swap on UNIv3 pool where the operator is going to provide liquidity in 5/, to deviate it a lot.\n> > \n> > \n> > The core of this exploit requires a PSN/PSN2 pool where the PSN tokens have a malicious _transfer function but according to the README `These should be assumed to use SimpleManager.sol and Chainlink oracle feed(s) and thus only support \"Major\" tokens with suitable chainlink oracle support.`.\n> > How easy is it for one to create a malicious token and to provide a feed for it on chainlink?\n> \n> @syjcnss explained it very well in his linked comment.\n> \n> I would like to add there is no need for chainlink feeds on poison tokens, since they would only be passed inside the payload used for the router call, and Arrakis never decodes this payload\n\nAh yes, apologies for that. Great explanation shared by @syjcnss ðŸ’¯\n\n**SergeKireev**\n\nAlso obviously agree with @syjcnss that this should be of `high` severity since impact is unbounded theft of funds by an operator  \n\n**Gevarist**\n\noperators are semi trusted, we should consider this issue as medium.\n\n**hrishibhat**\n\n@Gevarist \nReadme says:\n>  However the rebalances that are executed MUST NOT be exploitable by frontrun or sandwich.\nI think this should be a high based on another duplicate and POC here:\nhttps://github.com/sherlock-audit/2023-06-arrakis-judging/issues/187#issuecomment-1636038030\n\n**kassandraoftroy**\n\n(EDITED after some thought and discussion) ... Hmm I'm still not convinced this is a high. For me a high is when an arbitrary address can extract value, not a semi-trusted party.\n\nHere: `However the rebalances that are executed MUST NOT be exploitable by frontrun or sandwich.` we refer to a THIRD PARTY being able to frontrun or sandwich the rebalance. If ONLY whitelisted manager operator themself can frontrun/sandwich/extract it's still a medium to me, to be fair to \"Real\" high's that allow an arbitrary address to exploit the contract.\n\n**syjcnss**\n\nThe readme also says about the operator self sandwich,\n\n> HOWEVER in this \"Public Vault\" setting the \"Manager\" role is taken by the SimpleManager.sol smart contract which should add additional checks that make it impossible for SimpleManager.operators to frontrun/sandwich their own rebalance transactions and extract value beyond the accepted slippage tolerance defined in the SimpleManager smart contract for any Arrakis V2 vault managed by SimpleManager.\n\nHaving this, `However the rebalances that are executed MUST NOT be exploitable by frontrun or sandwich.` doesn't look like only referring to THIRD PARTY sandwich to me.\n\nThe attack breaks the above trust assumption in readme and will result in a material loss of funds.\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nBased on the context of the readme, the assumption set is that there is a clear possibility of having a malicious operator. \nGiven that there is a clear loss of funds as show in this issue and #187 \nConsidering this a valid high based on the above comments \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [syjcnss](https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/26/#issuecomment-1636690026): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/86",
  "Code": [
    {
      "filename": "v2-manager-templates/contracts/SimpleManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {\n    IERC20,\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    EnumerableSet\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {\n    IUniswapV3Factory\n} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {\n    IUniswapV3Pool\n} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {\n    IArrakisV2,\n    Rebalance\n} from \"@arrakisfi/v2-core/contracts/interfaces/IArrakisV2.sol\";\nimport {FullMath} from \"@arrakisfi/v3-lib-0.8/contracts/FullMath.sol\";\nimport {IOwnable} from \"./interfaces/IOwnable.sol\";\nimport {IOracleWrapper} from \"./interfaces/IOracleWrapper.sol\";\nimport {IDecimals} from \"./interfaces/IDecimals.sol\";\n\nimport {hundred_percent, ten_percent} from \"./constants/CSimpleManager.sol\";\n\n/// @title SimpleManager\n/// @dev Most simple manager to manage public vault on Arrakis V2.\ncontract SimpleManager is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct VaultInfo {\n        IOracleWrapper oracle;\n        uint24 maxDeviation;\n        uint24 maxSlippage;\n        uint16 managerFeeBPS;\n    }\n\n    struct SetupParams {\n        address vault;\n        IOracleWrapper oracle;\n        uint24 maxDeviation;\n        uint24 maxSlippage;\n        uint16 managerFeeBPS;\n    }\n\n    IUniswapV3Factory public immutable uniFactory;\n\n    mapping(address => VaultInfo) public vaults;\n\n    EnumerableSet.AddressSet internal _operators;\n\n    event InitManagement(\n        address vault,\n        address oracle,\n        uint24 maxDeviation,\n        uint24 maxSlippage,\n        uint16 managerFeeBPS\n    );\n    event RebalanceVault(address vault, address caller);\n    event AddOperators(address[] operators);\n    event RemoveOperators(address[] operators);\n    event SetManagerFeeBPS(address[] vaults, uint16 managerFeeBPS);\n    event SetManagerFeeBPS(address vault, uint16 managerFeeBPS);\n\n    modifier requireAddressNotZero(address addr) {\n        require(addr != address(0), \"ZA\");\n        _;\n    }\n\n    constructor(\n        IUniswapV3Factory uniFactory_\n    ) requireAddressNotZero(address(uniFactory_)) {\n        uniFactory = uniFactory_;\n    }\n\n    function initialize(\n        address owner_\n    ) external initializer requireAddressNotZero(owner_) {\n        _transferOwnership(owner_);\n    }\n\n    /// @notice Initialize management\n    /// @dev onced initialize Arrakis will start to manage the initialize vault\n    /// @param params SetupParams struct containing data for manager vault\n    function initManagement(\n        SetupParams calldata params\n    ) external onlyOwner requireAddressNotZero(address(params.oracle)) {\n        require(params.maxDeviation > 0, \"DN\");\n        require(address(this) == IArrakisV2(params.vault).manager(), \"NM\");\n        require(address(vaults[params.vault].oracle) == address(0), \"AV\");\n        require(params.managerFeeBPS > 0, \"MFB\");\n        /// @dev 10% max slippage allowed by the manager.\n        require(params.maxSlippage <= ten_percent, \"MS\");\n\n        if (params.managerFeeBPS != IArrakisV2(params.vault).managerFeeBPS()) {\n            IArrakisV2(params.vault).setManagerFeeBPS(params.managerFeeBPS);\n\n            emit SetManagerFeeBPS(params.vault, params.managerFeeBPS);\n        }\n\n        vaults[params.vault] = VaultInfo({\n            oracle: params.oracle,\n            maxDeviation: params.maxDeviation,\n            maxSlippage: params.maxSlippage,\n            managerFeeBPS: params.managerFeeBPS\n        });\n\n        emit InitManagement(\n            params.vault,\n            address(params.oracle),\n            params.maxDeviation,\n            params.maxSlippage,\n            params.managerFeeBPS\n        );\n    }\n\n    /// @notice Rebalance vault\n    /// @dev only an operator of the contract Arrakis Finance can call the contract\n    /// @param vault_ address of the Arrakis V2 vault to rebalance\n    /// @param rebalanceParams_ rebalance parameters.\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function rebalance(\n        address vault_,\n        Rebalance calldata rebalanceParams_\n    ) external {\n        require(_operators.contains(msg.sender), \"NO\");\n        require(\n            IArrakisV2(vault_).manager() == address(this) &&\n                address(vaults[vault_].oracle) != address(0),\n            \"NM\"\n        );\n        VaultInfo memory vaultInfo = vaults[vault_];\n\n        address token0;\n        address token1;\n        uint8 token0Decimals;\n        uint8 token1Decimals;\n        uint24[] memory checked;\n        uint256 oraclePrice;\n        uint256 increment;\n\n        uint256 mintsLength = rebalanceParams_.mints.length;\n\n        if (mintsLength > 0 || rebalanceParams_.swap.amountIn > 0) {\n            token0 = address(IArrakisV2(vault_).token0());\n            token1 = address(IArrakisV2(vault_).token1());\n            token0Decimals = IDecimals(token0).decimals();\n            token1Decimals = IDecimals(token1).decimals();\n        }\n\n        if (mintsLength > 0) {\n            checked = new uint24[](mintsLength);\n            oraclePrice = vaultInfo.oracle.getPrice0();\n        }\n\n        for (uint256 i; i < mintsLength; ++i) {\n            if (\n                _includes(\n                    rebalanceParams_.mints[i].range.feeTier,\n                    checked,\n                    increment\n                )\n            ) continue;\n\n            IUniswapV3Pool pool = IUniswapV3Pool(\n                _getPool(\n                    token0,\n                    token1,\n                    rebalanceParams_.mints[i].range.feeTier\n                )\n            );\n\n            uint256 sqrtPriceX96;\n\n            (sqrtPriceX96, , , , , , ) = pool.slot0();\n\n            uint256 poolPrice = FullMath.mulDiv(\n                sqrtPriceX96 * sqrtPriceX96,\n                10 ** token0Decimals,\n                2 ** 192\n            );\n\n            _checkDeviation(\n                poolPrice,\n                oraclePrice,\n                vaultInfo.maxDeviation,\n                token1Decimals\n            );\n\n            checked[increment] = rebalanceParams_.mints[i].range.feeTier;\n            increment++;\n        }\n\n        // check expectedMinReturn on rebalance swap against oracle\n        if (rebalanceParams_.swap.amountIn > 0) {\n            _checkMinReturn(\n                rebalanceParams_,\n                vaultInfo.oracle,\n                vaultInfo.maxSlippage,\n                token0Decimals,\n                token1Decimals\n            );\n        }\n\n        IArrakisV2(vault_).rebalance(rebalanceParams_);\n\n        emit RebalanceVault(vault_, msg.sender);\n    }\n\n    /// @notice Withdraw and Collect Fees generated by vaults on Uni v3\n    /// @dev only the owner of the contract Arrakis Finance can call the contract\n    /// @param vaults_ array of vaults where to collect fees\n    /// @param tokens_ array of tokens where to withdraw fees\n    /// @param target receiver of fees collection\n    // solhint-disable-next-line code-complexity\n    function withdrawAndCollectFees(\n        IArrakisV2[] calldata vaults_,\n        IERC20[] calldata tokens_,\n        address target\n    ) external onlyOwner requireAddressNotZero(target) {\n        uint256 vaultsLength = vaults_.length;\n\n        // #region withdraw from vaults.\n\n        for (uint256 i; i < vaultsLength; ++i) {\n            require(\n                vaults_[i].manager() == address(this) &&\n                    address(vaults[address(vaults_[i])].oracle) != address(0),\n                \"NM\"\n            );\n\n            vaults_[i].withdrawManagerBalance();\n        }\n\n        // #endregion withdraw from vaults.\n\n        // #region transfer token to target.\n\n        uint256 tokensLength = tokens_.length;\n        for (uint256 i; i < tokensLength; ++i) {\n            uint256 balance = IERC20(tokens_[i]).balanceOf(address(this));\n            if (balance > 0) IERC20(tokens_[i]).safeTransfer(target, balance);\n        }\n\n        // #endregion transfer token to target.\n    }\n\n    /// @notice Set manager fee bps as manager\n    /// @dev only the owner of simple manager call this function\n    /// @param vaults_ array of vaults where to update manager fee bps\n    /// @param managerFeeBPS_ new value of manager fee bps\n    // solhint-disable-next-line code-complexity\n    function setManagerFee(\n        address[] calldata vaults_,\n        uint16 managerFeeBPS_\n    ) external onlyOwner {\n        uint256 vaultsLength = vaults_.length;\n        for (uint256 i; i < vaultsLength; ++i) {\n            require(address(vaults[vaults_[i]].oracle) != address(0), \"NM\");\n            require(vaults[vaults_[i]].managerFeeBPS != managerFeeBPS_, \"NU\");\n            vaults[vaults_[i]].managerFeeBPS = managerFeeBPS_;\n\n            IArrakisV2(vaults_[i]).setManagerFeeBPS(managerFeeBPS_);\n        }\n\n        emit SetManagerFeeBPS(vaults_, managerFeeBPS_);\n    }\n\n    /// @notice for adding operators\n    /// @param operators_ list of operators to add\n    /// @dev only callable by owner\n    function addOperators(address[] calldata operators_) external onlyOwner {\n        uint256 operatorsLength = operators_.length;\n        require(operatorsLength > 0, \"ZO\");\n        for (uint256 i; i < operatorsLength; ++i) {\n            require(\n                operators_[i] != address(0) && _operators.add(operators_[i]),\n                \"O\"\n            );\n        }\n\n        emit AddOperators(operators_);\n    }\n\n    /// @notice for removing operators\n    /// @param operators_ list of operators to remove\n    /// @dev only callable by owner\n    function removeOperators(address[] memory operators_) external onlyOwner {\n        uint256 operatorsLength = operators_.length;\n        require(operatorsLength > 0, \"ZO\");\n        for (uint256 i; i < operatorsLength; ++i) {\n            require(_operators.remove(operators_[i]), \"NO\");\n        }\n\n        emit RemoveOperators(operators_);\n    }\n\n    /// @notice get list of operators\n    /// @return operators array of address representing operators\n    function getOperators() external view returns (address[] memory) {\n        return _operators.values();\n    }\n\n    /// @notice check if it's operators\n    /// @param operator_ address to check if it's an operator\n    /// @return return true if inputed address is an operator\n    /// otherwise return false\n    function isOperator(address operator_) external view returns (bool) {\n        return _operators.contains(operator_);\n    }\n\n    function _checkMinReturn(\n        Rebalance memory rebalanceParams_,\n        IOracleWrapper oracle_,\n        uint24 maxSlippage,\n        uint8 decimals0,\n        uint8 decimals1\n    ) internal view {\n        if (rebalanceParams_.swap.zeroForOne) {\n            require(\n                FullMath.mulDiv(\n                    rebalanceParams_.swap.expectedMinReturn,\n                    10 ** decimals0,\n                    rebalanceParams_.swap.amountIn\n                ) >\n                    FullMath.mulDiv(\n                        oracle_.getPrice0(),\n                        hundred_percent - maxSlippage,\n                        hundred_percent\n                    ),\n                \"S0\"\n            );\n        } else {\n            require(\n                FullMath.mulDiv(\n                    rebalanceParams_.swap.expectedMinReturn,\n                    10 ** decimals1,\n                    rebalanceParams_.swap.amountIn\n                ) >\n                    FullMath.mulDiv(\n                        oracle_.getPrice1(),\n                        hundred_percent - maxSlippage,\n                        hundred_percent\n                    ),\n                \"S1\"\n            );\n        }\n    }\n\n    function _getPool(\n        address token0,\n        address token1,\n        uint24 feeTier\n    ) internal view returns (address pool) {\n        pool = uniFactory.getPool(token0, token1, feeTier);\n\n        require(pool != address(0), \"NP\");\n    }\n\n    function _checkDeviation(\n        uint256 currentPrice_,\n        uint256 oraclePrice_,\n        uint24 maxDeviation_,\n        uint8 priceDecimals_\n    ) internal pure {\n        uint256 deviation = FullMath.mulDiv(\n            FullMath.mulDiv(\n                currentPrice_ > oraclePrice_\n                    ? currentPrice_ - oraclePrice_\n                    : oraclePrice_ - currentPrice_,\n                10 ** priceDecimals_,\n                oraclePrice_\n            ),\n            hundred_percent,\n            10 ** priceDecimals_\n        );\n\n        require(deviation <= maxDeviation_, \"maxDeviation\");\n    }\n\n    function _includes(\n        uint24 target,\n        uint24[] memory set,\n        uint256 upperIndex\n    ) internal pure returns (bool) {\n        for (uint256 j; j < upperIndex; j++) {\n            if (set[j] == target) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}"
    },
    {
      "filename": "v2-manager-templates/contracts/SimpleManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {\n    IERC20,\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    EnumerableSet\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {\n    IUniswapV3Factory\n} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {\n    IUniswapV3Pool\n} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {\n    IArrakisV2,\n    Rebalance\n} from \"@arrakisfi/v2-core/contracts/interfaces/IArrakisV2.sol\";\nimport {FullMath} from \"@arrakisfi/v3-lib-0.8/contracts/FullMath.sol\";\nimport {IOwnable} from \"./interfaces/IOwnable.sol\";\nimport {IOracleWrapper} from \"./interfaces/IOracleWrapper.sol\";\nimport {IDecimals} from \"./interfaces/IDecimals.sol\";\n\nimport {hundred_percent, ten_percent} from \"./constants/CSimpleManager.sol\";\n\n/// @title SimpleManager\n/// @dev Most simple manager to manage public vault on Arrakis V2.\ncontract SimpleManager is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct VaultInfo {\n        IOracleWrapper oracle;\n        uint24 maxDeviation;\n        uint24 maxSlippage;\n        uint16 managerFeeBPS;\n    }\n\n    struct SetupParams {\n        address vault;\n        IOracleWrapper oracle;\n        uint24 maxDeviation;\n        uint24 maxSlippage;\n        uint16 managerFeeBPS;\n    }\n\n    IUniswapV3Factory public immutable uniFactory;\n\n    mapping(address => VaultInfo) public vaults;\n\n    EnumerableSet.AddressSet internal _operators;\n\n    event InitManagement(\n        address vault,\n        address oracle,\n        uint24 maxDeviation,\n        uint24 maxSlippage,\n        uint16 managerFeeBPS\n    );\n    event RebalanceVault(address vault, address caller);\n    event AddOperators(address[] operators);\n    event RemoveOperators(address[] operators);\n    event SetManagerFeeBPS(address[] vaults, uint16 managerFeeBPS);\n    event SetManagerFeeBPS(address vault, uint16 managerFeeBPS);\n\n    modifier requireAddressNotZero(address addr) {\n        require(addr != address(0), \"ZA\");\n        _;\n    }\n\n    constructor(\n        IUniswapV3Factory uniFactory_\n    ) requireAddressNotZero(address(uniFactory_)) {\n        uniFactory = uniFactory_;\n    }\n\n    function initialize(\n        address owner_\n    ) external initializer requireAddressNotZero(owner_) {\n        _transferOwnership(owner_);\n    }\n\n    /// @notice Initialize management\n    /// @dev onced initialize Arrakis will start to manage the initialize vault\n    /// @param params SetupParams struct containing data for manager vault\n    function initManagement(\n        SetupParams calldata params\n    ) external onlyOwner requireAddressNotZero(address(params.oracle)) {\n        require(params.maxDeviation > 0, \"DN\");\n        require(address(this) == IArrakisV2(params.vault).manager(), \"NM\");\n        require(address(vaults[params.vault].oracle) == address(0), \"AV\");\n        require(params.managerFeeBPS > 0, \"MFB\");\n        /// @dev 10% max slippage allowed by the manager.\n        require(params.maxSlippage <= ten_percent, \"MS\");\n\n        if (params.managerFeeBPS != IArrakisV2(params.vault).managerFeeBPS()) {\n            IArrakisV2(params.vault).setManagerFeeBPS(params.managerFeeBPS);\n\n            emit SetManagerFeeBPS(params.vault, params.managerFeeBPS);\n        }\n\n        vaults[params.vault] = VaultInfo({\n            oracle: params.oracle,\n            maxDeviation: params.maxDeviation,\n            maxSlippage: params.maxSlippage,\n            managerFeeBPS: params.managerFeeBPS\n        });\n\n        emit InitManagement(\n            params.vault,\n            address(params.oracle),\n            params.maxDeviation,\n            params.maxSlippage,\n            params.managerFeeBPS\n        );\n    }\n\n    /// @notice Rebalance vault\n    /// @dev only an operator of the contract Arrakis Finance can call the contract\n    /// @param vault_ address of the Arrakis V2 vault to rebalance\n    /// @param rebalanceParams_ rebalance parameters.\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function rebalance(\n        address vault_,\n        Rebalance calldata rebalanceParams_\n    ) external {\n        require(_operators.contains(msg.sender), \"NO\");\n        require(\n            IArrakisV2(vault_).manager() == address(this) &&\n                address(vaults[vault_].oracle) != address(0),\n            \"NM\"\n        );\n        VaultInfo memory vaultInfo = vaults[vault_];\n\n        address token0;\n        address token1;\n        uint8 token0Decimals;\n        uint8 token1Decimals;\n        uint24[] memory checked;\n        uint256 oraclePrice;\n        uint256 increment;\n\n        uint256 mintsLength = rebalanceParams_.mints.length;\n\n        if (mintsLength > 0 || rebalanceParams_.swap.amountIn > 0) {\n            token0 = address(IArrakisV2(vault_).token0());\n            token1 = address(IArrakisV2(vault_).token1());\n            token0Decimals = IDecimals(token0).decimals();\n            token1Decimals = IDecimals(token1).decimals();\n        }\n\n        if (mintsLength > 0) {\n            checked = new uint24[](mintsLength);\n            oraclePrice = vaultInfo.oracle.getPrice0();\n        }\n\n        for (uint256 i; i < mintsLength; ++i) {\n            if (\n                _includes(\n                    rebalanceParams_.mints[i].range.feeTier,\n                    checked,\n                    increment\n                )\n            ) continue;\n\n            IUniswapV3Pool pool = IUniswapV3Pool(\n                _getPool(\n                    token0,\n                    token1,\n                    rebalanceParams_.mints[i].range.feeTier\n                )\n            );\n\n            uint256 sqrtPriceX96;\n\n            (sqrtPriceX96, , , , , , ) = pool.slot0();\n\n            uint256 poolPrice = FullMath.mulDiv(\n                sqrtPriceX96 * sqrtPriceX96,\n                10 ** token0Decimals,\n                2 ** 192\n            );\n\n            _checkDeviation(\n                poolPrice,\n                oraclePrice,\n                vaultInfo.maxDeviation,\n                token1Decimals\n            );\n\n            checked[increment] = rebalanceParams_.mints[i].range.feeTier;\n            increment++;\n        }\n\n        // check expectedMinReturn on rebalance swap against oracle\n        if (rebalanceParams_.swap.amountIn > 0) {\n            _checkMinReturn(\n                rebalanceParams_,\n                vaultInfo.oracle,\n                vaultInfo.maxSlippage,\n                token0Decimals,\n                token1Decimals\n            );\n        }\n\n        IArrakisV2(vault_).rebalance(rebalanceParams_);\n\n        emit RebalanceVault(vault_, msg.sender);\n    }\n\n    /// @notice Withdraw and Collect Fees generated by vaults on Uni v3\n    /// @dev only the owner of the contract Arrakis Finance can call the contract\n    /// @param vaults_ array of vaults where to collect fees\n    /// @param tokens_ array of tokens where to withdraw fees\n    /// @param target receiver of fees collection\n    // solhint-disable-next-line code-complexity\n    function withdrawAndCollectFees(\n        IArrakisV2[] calldata vaults_,\n        IERC20[] calldata tokens_,\n        address target\n    ) external onlyOwner requireAddressNotZero(target) {\n        uint256 vaultsLength = vaults_.length;\n\n        // #region withdraw from vaults.\n\n        for (uint256 i; i < vaultsLength; ++i) {\n            require(\n                vaults_[i].manager() == address(this) &&\n                    address(vaults[address(vaults_[i])].oracle) != address(0),\n                \"NM\"\n            );\n\n            vaults_[i].withdrawManagerBalance();\n        }\n\n        // #endregion withdraw from vaults.\n\n        // #region transfer token to target.\n\n        uint256 tokensLength = tokens_.length;\n        for (uint256 i; i < tokensLength; ++i) {\n            uint256 balance = IERC20(tokens_[i]).balanceOf(address(this));\n            if (balance > 0) IERC20(tokens_[i]).safeTransfer(target, balance);\n        }\n\n        // #endregion transfer token to target.\n    }\n\n    /// @notice Set manager fee bps as manager\n    /// @dev only the owner of simple manager call this function\n    /// @param vaults_ array of vaults where to update manager fee bps\n    /// @param managerFeeBPS_ new value of manager fee bps\n    // solhint-disable-next-line code-complexity\n    function setManagerFee(\n        address[] calldata vaults_,\n        uint16 managerFeeBPS_\n    ) external onlyOwner {\n        uint256 vaultsLength = vaults_.length;\n        for (uint256 i; i < vaultsLength; ++i) {\n            require(address(vaults[vaults_[i]].oracle) != address(0), \"NM\");\n            require(vaults[vaults_[i]].managerFeeBPS != managerFeeBPS_, \"NU\");\n            vaults[vaults_[i]].managerFeeBPS = managerFeeBPS_;\n\n            IArrakisV2(vaults_[i]).setManagerFeeBPS(managerFeeBPS_);\n        }\n\n        emit SetManagerFeeBPS(vaults_, managerFeeBPS_);\n    }\n\n    /// @notice for adding operators\n    /// @param operators_ list of operators to add\n    /// @dev only callable by owner\n    function addOperators(address[] calldata operators_) external onlyOwner {\n        uint256 operatorsLength = operators_.length;\n        require(operatorsLength > 0, \"ZO\");\n        for (uint256 i; i < operatorsLength; ++i) {\n            require(\n                operators_[i] != address(0) && _operators.add(operators_[i]),\n                \"O\"\n            );\n        }\n\n        emit AddOperators(operators_);\n    }\n\n    /// @notice for removing operators\n    /// @param operators_ list of operators to remove\n    /// @dev only callable by owner\n    function removeOperators(address[] memory operators_) external onlyOwner {\n        uint256 operatorsLength = operators_.length;\n        require(operatorsLength > 0, \"ZO\");\n        for (uint256 i; i < operatorsLength; ++i) {\n            require(_operators.remove(operators_[i]), \"NO\");\n        }\n\n        emit RemoveOperators(operators_);\n    }\n\n    /// @notice get list of operators\n    /// @return operators array of address representing operators\n    function getOperators() external view returns (address[] memory) {\n        return _operators.values();\n    }\n\n    /// @notice check if it's operators\n    /// @param operator_ address to check if it's an operator\n    /// @return return true if inputed address is an operator\n    /// otherwise return false\n    function isOperator(address operator_) external view returns (bool) {\n        return _operators.contains(operator_);\n    }\n\n    function _checkMinReturn(\n        Rebalance memory rebalanceParams_,\n        IOracleWrapper oracle_,\n        uint24 maxSlippage,\n        uint8 decimals0,\n        uint8 decimals1\n    ) internal view {\n        if (rebalanceParams_.swap.zeroForOne) {\n            require(\n                FullMath.mulDiv(\n                    rebalanceParams_.swap.expectedMinReturn,\n                    10 ** decimals0,\n                    rebalanceParams_.swap.amountIn\n                ) >\n                    FullMath.mulDiv(\n                        oracle_.getPrice0(),\n                        hundred_percent - maxSlippage,\n                        hundred_percent\n                    ),\n                \"S0\"\n            );\n        } else {\n            require(\n                FullMath.mulDiv(\n                    rebalanceParams_.swap.expectedMinReturn,\n                    10 ** decimals1,\n                    rebalanceParams_.swap.amountIn\n                ) >\n                    FullMath.mulDiv(\n                        oracle_.getPrice1(),\n                        hundred_percent - maxSlippage,\n                        hundred_percent\n                    ),\n                \"S1\"\n            );\n        }\n    }\n\n    function _getPool(\n        address token0,\n        address token1,\n        uint24 feeTier\n    ) internal view returns (address pool) {\n        pool = uniFactory.getPool(token0, token1, feeTier);\n\n        require(pool != address(0), \"NP\");\n    }\n\n    function _checkDeviation(\n        uint256 currentPrice_,\n        uint256 oraclePrice_,\n        uint24 maxDeviation_,\n        uint8 priceDecimals_\n    ) internal pure {\n        uint256 deviation = FullMath.mulDiv(\n            FullMath.mulDiv(\n                currentPrice_ > oraclePrice_\n                    ? currentPrice_ - oraclePrice_\n                    : oraclePrice_ - currentPrice_,\n                10 ** priceDecimals_,\n                oraclePrice_\n            ),\n            hundred_percent,\n            10 ** priceDecimals_\n        );\n\n        require(deviation <= maxDeviation_, \"maxDeviation\");\n    }\n\n    function _includes(\n        uint24 target,\n        uint24[] memory set,\n        uint256 upperIndex\n    ) internal pure returns (bool) {\n        for (uint256 j; j < upperIndex; j++) {\n            if (set[j] == target) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}"
    },
    {
      "filename": "v2-core/contracts/ArrakisV2.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport {\n    IUniswapV3MintCallback\n} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {\n    IUniswapV3Pool\n} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {\n    IUniswapV3Factory,\n    ArrakisV2Storage,\n    IERC20,\n    SafeERC20,\n    EnumerableSet,\n    Range,\n    Rebalance\n} from \"./abstract/ArrakisV2Storage.sol\";\nimport {FullMath} from \"@arrakisfi/v3-lib-0.8/contracts/LiquidityAmounts.sol\";\nimport {Withdraw, UnderlyingPayload} from \"./structs/SArrakisV2.sol\";\nimport {Position} from \"./libraries/Position.sol\";\nimport {Pool} from \"./libraries/Pool.sol\";\nimport {Underlying as UnderlyingHelper} from \"./libraries/Underlying.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {hundredPercent} from \"./constants/CArrakisV2.sol\";\n\n/// @title ArrakisV2 LP vault version 2\n/// @notice Smart contract managing liquidity providing strategy for a given token pair\n/// using multiple Uniswap V3 LP positions on multiple fee tiers.\n/// @author Arrakis Finance\n/// @dev DO NOT ADD STATE VARIABLES - APPEND THEM TO ArrakisV2Storage\ncontract ArrakisV2 is IUniswapV3MintCallback, ArrakisV2Storage {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(IUniswapV3Factory factory_) ArrakisV2Storage(factory_) {}\n\n    /// @notice Uniswap V3 callback fn, called back on pool.mint\n    function uniswapV3MintCallback(\n        uint256 amount0Owed_,\n        uint256 amount1Owed_,\n        bytes calldata /*_data*/\n    ) external override {\n        _uniswapV3CallBack(amount0Owed_, amount1Owed_);\n    }\n\n    /// @notice mint Arrakis V2 shares by depositing underlying\n    /// @param mintAmount_ represent the amount of Arrakis V2 shares to mint.\n    /// @param receiver_ address that will receive Arrakis V2 shares.\n    /// @return amount0 amount of token0 needed to mint mintAmount_ of shares.\n    /// @return amount1 amount of token1 needed to mint mintAmount_ of shares.\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function mint(uint256 mintAmount_, address receiver_)\n        external\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(mintAmount_ > 0, \"MA\");\n        require(\n            restrictedMint == address(0) || msg.sender == restrictedMint,\n            \"R\"\n        );\n        address me = address(this);\n        uint256 ts = totalSupply();\n        bool isTotalSupplyGtZero = ts > 0;\n        if (isTotalSupplyGtZero) {\n            (amount0, amount1) = UnderlyingHelper.totalUnderlyingForMint(\n                UnderlyingPayload({\n                    ranges: _ranges,\n                    factory: factory,\n                    token0: address(token0),\n                    token1: address(token1),\n                    self: me\n                }),\n                mintAmount_,\n                ts\n            );\n        } else {\n            uint256 denominator = 1 ether;\n            uint256 init0M = init0;\n            uint256 init1M = init1;\n\n            amount0 = FullMath.mulDivRoundingUp(\n                mintAmount_,\n                init0M,\n                denominator\n            );\n            amount1 = FullMath.mulDivRoundingUp(\n                mintAmount_,\n                init1M,\n                denominator\n            );\n\n            /// @dev check ratio against small values that skew init ratio\n            if (FullMath.mulDiv(mintAmount_, init0M, denominator) == 0) {\n                amount0 = 0;\n            }\n            if (FullMath.mulDiv(mintAmount_, init1M, denominator) == 0) {\n                amount1 = 0;\n            }\n\n            uint256 amount0Mint = init0M != 0\n                ? FullMath.mulDiv(amount0, denominator, init0M)\n                : type(uint256).max;\n            uint256 amount1Mint = init1M != 0\n                ? FullMath.mulDiv(amount1, denominator, init1M)\n                : type(uint256).max;\n\n            require(\n                (amount0Mint < amount1Mint ? amount0Mint : amount1Mint) ==\n                    mintAmount_,\n                \"A0&A1\"\n            );\n        }\n\n        _mint(receiver_, mintAmount_);\n\n        // transfer amounts owed to contract\n        if (amount0 > 0) {\n            token0.safeTransferFrom(msg.sender, me, amount0);\n        }\n        if (amount1 > 0) {\n            token1.safeTransferFrom(msg.sender, me, amount1);\n        }\n\n        if (isTotalSupplyGtZero) {\n            for (uint256 i; i < _ranges.length; i++) {\n                Range memory range = _ranges[i];\n                IUniswapV3Pool pool = IUniswapV3Pool(\n                    factory.getPool(\n                        address(token0),\n                        address(token1),\n                        range.feeTier\n                    )\n                );\n                uint128 liquidity = Position.getLiquidityByRange(\n                    pool,\n                    me,\n                    range.lowerTick,\n                    range.upperTick\n                );\n                if (liquidity == 0) continue;\n\n                liquidity = SafeCast.toUint128(\n                    FullMath.mulDiv(liquidity, mintAmount_, ts)\n                );\n\n                pool.mint(me, range.lowerTick, range.upperTick, liquidity, \"\");\n            }\n        }\n\n        emit LogMint(receiver_, mintAmount_, amount0, amount1);\n    }\n\n    /// @notice burn Arrakis V2 shares and withdraw underlying.\n    /// @param burnAmount_ amount of vault shares to burn.\n    /// @param receiver_ address to receive underlying tokens withdrawn.\n    /// @return amount0 amount of token0 sent to receiver\n    /// @return amount1 amount of token1 sent to receiver\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function burn(uint256 burnAmount_, address receiver_)\n        external\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(burnAmount_ > 0, \"BA\");\n\n        uint256 ts = totalSupply();\n        require(ts > 0, \"TS\");\n\n        _burn(msg.sender, burnAmount_);\n\n        Withdraw memory total;\n        for (uint256 i; i < _ranges.length; i++) {\n            Range memory range = _ranges[i];\n            IUniswapV3Pool pool = IUniswapV3Pool(\n                factory.getPool(address(token0), address(token1), range.feeTier)\n            );\n            uint128 liquidity = Position.getLiquidityByRange(\n                pool,\n                address(this),\n                range.lowerTick,\n                range.upperTick"
    }
  ]
}