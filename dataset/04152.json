{
  "Title": "[L09] Lack of input sanitization",
  "Content": "Throughout the codebase, many contracts have an instance of the function `modifyParameters()`, which allows authorized accounts to change parameters of the protocol. For example, such functions exist [in the `CoinSavingsAccount`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CoinSavingsAccount.sol#L153) contract and [in the `GlobalSettlement`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L235) contract, among many others.\n\n\nHowever, there are no safety checks for many of these parameters when they are being changed. For example, in the [`GlobalSettlement`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L237-L242) contract, no changes to `address` parameters check that the `address` given is not `address(0)`, or that there is a contract at that address. In the [`AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L172-L173) contract, some “delay” parameters are not bounded, allowing them to be set to excessively high values. And in the [`CollateralAuctionHouse`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L162-L163) contract, some parameters are immediately cast to `uint48`, allowing undetected overflows if the value is higher than `2**48-1`.\n\n\nFurthermore, values passed into `constructor`s for various contracts do not contain input checks. For example, the [`constructor` for the `BasicCollateralJoin` contract](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/BasicTokenAdapters.sol#L97-L105) contains no checks that the two `address` parameters are not `address(0)`, and neither does the [`constructor` of the `CollateralAuctionHouse`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L130-L136) contract.\n\n\nNote that while these are examples, this is not an exhaustive list of all places needing input sanitization. To help follow the “fail early and loudly principle”, ensure that for all instances of `modifyParameters` and for all `constructor`s, there are checks on the values being set. In general, consider checking that `address` parameters are not `address(0)`, that `address`es which correspond to contracts have `extcodesize != 0`, that `uint` variables which are then downcast have not overflowed, and that numeric parameters are bounded to reasonable values given their application.\n\n\n***Update:** Aknowledged, not fixed. Reflexer Labs’ statement for this issue:*\n\n\n\n> \n>  We understand the concern although we’d like to stick to what we inherited from MCD.\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/CoinSavingsAccount.sol",
      "content": "/// CoinSavingsAccount.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\n/*\n   \"Savings Coin\" is obtained when the core coin created by the protocol\n   is deposited into this contract. Each \"Savings Coin\" accrues interest\n   at the \"Savings Rate\". This contract does not implement a user tradeable token\n   and is intended to be used with adapters.\n         --- `save` your `coin` in the `savings account` ---\n   - `savingsRate`: the Savings Rate\n   - `savings`: user balance of Savings Coins\n   - `deposit`: start saving some coins\n   - `withdraw`: withdraw coins from the savings account\n   - `updateAccumulatedRate`: perform rate collection\n*/\n\nabstract contract SAFEEngineLike {\n    function transferInternalCoins(address,address,uint256) virtual external;\n    function createUnbackedDebt(address,address,uint256) virtual external;\n}\n\ncontract CoinSavingsAccount {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CoinSavingsAccount/account-not-authorized\");\n        _;\n    }\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint256 data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event DisableContract();\n    event Deposit(address usr, uint256 balance, uint256 totalSavings);\n    event Withdraw(address usr, uint256 balance, uint256 totalSavings);\n    event UpdateAccumulatedRate(uint256 newAccumulatedRate, uint256 coinAmount);\n\n    // --- Data ---\n    // Amount of coins each user has deposited\n    mapping (address => uint256) public savings;\n\n    // Total amount of coins deposited\n    uint256 public totalSavings;\n    // Per second savings rate\n    uint256 public savingsRate;\n    // An index representing total accumulated rates\n    uint256 public accumulatedRate;\n\n    // SAFE database\n    SAFEEngineLike public safeEngine;\n    // Accounting engine\n    address public accountingEngine;\n    // When accumulated rates were last updated\n    uint256 public latestUpdateTime;\n    // Whether this contract is enabled or not\n    uint256 public contractEnabled;\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SAFEEngineLike(safeEngine_);\n        savingsRate = RAY;\n        accumulatedRate = RAY;\n        latestUpdateTime = now;\n        contractEnabled = 1;\n    }\n\n    // --- Math ---\n    uint256 constant RAY = 10 ** 27;\n    function rpower(uint x, uint n, uint base) internal pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    x := div(xxRound, base)\n                    if mod(n,2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Administration ---\n    /**\n     * @notice Modify savings rate\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        require(contractEnabled == 1, \"CoinSavingsAccount/contract-not-enabled\");\n        require(now == latestUpdateTime, \"CoinSavingsAccount/accumulation-time-not-updated\");\n        if (parameter == \"savingsRate\") savingsRate = data;\n        else revert(\"CoinSavingsAccount/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify address of the accounting engine\n     * @param parameter The name of the parameter modified\n     * @param addr New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\n        if (parameter == \"accountingEngine\") accountingEngine = addr;\n        else revert(\"CoinSavingsAccount/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, addr);\n    }\n    /**\n     * @notice Disable this contract (usually called by Global Settlement)\n     */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        savingsRate = RAY;\n        emit DisableContract();\n    }\n\n    // --- Savings Rate Accumulation ---\n    /**\n     * @notice Update the accumulated rates index\n     * @dev We return early if 'latestUpdateTime' is smaller or equal to block.timestamp. When the savings\n            rate is positive, we create unbacked debt for the accounting engine and issue new coins for\n            this contract\n     */\n    function updateAccumulatedRate() external returns (uint newAccumulatedRate) {\n        if (now <= latestUpdateTime) return accumulatedRate;\n        newAccumulatedRate = rmultiply(rpower(savingsRate, subtract(now, latestUpdateTime), RAY), accumulatedRate);\n        uint accumulatedRate_ = subtract(newAccumulatedRate, accumulatedRate);\n        accumulatedRate = newAccumulatedRate;\n        latestUpdateTime = now;\n        safeEngine.createUnbackedDebt(address(accountingEngine), address(this), multiply(totalSavings, accumulatedRate_));\n        emit UpdateAccumulatedRate(newAccumulatedRate, multiply(totalSavings, accumulatedRate_));\n    }\n    /**\n     * @notice Get the next value of 'accumulatedRate' without actually updating the variable\n     */\n    function nextAccumulatedRate() external view returns (uint) {\n        if (now <= latestUpdateTime) return accumulatedRate;\n        return rmultiply(rpower(savingsRate, subtract(now, latestUpdateTime), RAY), accumulatedRate);\n    }\n\n    // --- Savings Management ---\n    /**\n     * @notice Deposit coins in the savings account\n     * @param wad Amount of coins to deposit (expressed as an 18 decimal number). 'wad' will be multiplied by\n              'accumulatedRate' (27 decimals) to result in a correct amount of internal coins transferred\n     */\n    function deposit(uint wad) external {\n        require(now == latestUpdateTime, \"CoinSavingsAccount/accumulation-time-not-updated\");\n        savings[msg.sender] = addition(savings[msg.sender], wad);\n        totalSavings        = addition(totalSavings, wad);\n        safeEngine.transferInternalCoins(msg.sender, address(this), multiply(accumulatedRate, wad));\n        emit Deposit(msg.sender, savings[msg.sender], totalSavings);\n    }\n    /**\n     * @notice Withdraw coins (alongside any interest accrued) from the savings account\n     * @param wad Amount of coins to withdraw (expressed as an 18 decimal number). 'wad' will be multiplied by\n              'accumulatedRate' (27 decimals) to result in a correct amount of internal coins transferred\n     */\n    function withdraw(uint wad) external {\n        savings[msg.sender] = subtract(savings[msg.sender], wad);\n        totalSavings        = subtract(totalSavings, wad);\n        safeEngine.transferInternalCoins(address(this), msg.sender, multiply(accumulatedRate, wad));\n        emit Withdraw(msg.sender, savings[msg.sender], totalSavings);\n    }\n}"
    },
    {
      "filename": "src/GlobalSettlement.sol",
      "content": "/// GlobalSettlement.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n// Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function coinBalance(address) virtual public view returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        uint256 debtAmount,        // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,       // [ray]\n        uint256 debtCeiling,       // [rad]\n        uint256 debtFloor,         // [rad]\n        uint256 liquidationPrice   // [ray]\n    );\n    function safes(bytes32,address) virtual public view returns (\n        uint256 lockedCollateral, // [wad]\n        uint256 generatedDebt     // [wad]\n    );\n    function globalDebt() virtual public returns (uint256);\n    function transferInternalCoins(address src, address dst, uint256 rad) virtual external;\n    function approveSAFEModification(address) virtual external;\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) virtual external;\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address safe, address collateralSource, address debtDestination, int256 deltaCollateral, int256 deltaDebt) virtual external;\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint256 rad) virtual external;\n    function disableContract() virtual external;\n}\nabstract contract LiquidationEngineLike {\n    function collateralTypes(bytes32) virtual public view returns (\n        address collateralAuctionHouse,\n        uint256 liquidationPenalty,     // [wad]\n        uint256 liquidationQuantity     // [rad]\n    );\n    function disableContract() virtual external;\n}\nabstract contract StabilityFeeTreasuryLike {\n    function disableContract() virtual external;\n}\nabstract contract AccountingEngineLike {\n    function disableContract() virtual external;\n}\nabstract contract CoinSavingsAccountLike {\n    function disableContract() virtual external;\n}\nabstract contract CollateralAuctionHouseLike {\n    function bidAmount(uint id) virtual public view returns (uint256);\n    function remainingAmountToSell(uint id) virtual public view returns (uint256);\n    function forgoneCollateralReceiver(uint id) virtual public view returns (address);\n    function amountToRaise(uint id) virtual public view returns (uint256);\n    function terminateAuctionPrematurely(uint auctionId) virtual external;\n}\nabstract contract OracleLike {\n    function read() virtual public view returns (uint256);\n}\nabstract contract OracleRelayerLike {\n    function redemptionPrice() virtual public returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        OracleLike orcl,\n        uint256 safetyCRatio,\n        uint256 liquidationCRatio\n    );\n    function disableContract() virtual external;\n}\n\n/*\n    This is the Global Settlement module. It is an\n    involved, stateful process that takes place over nine steps.\n    First we freeze the system and lock the prices for each collateral type.\n    1. `shutdownSystem()`:\n        - freezes user entrypoints\n        - cancels collateral/surplus auctions\n        - starts cooldown period\n    2. `freezeCollateralType(collateralType)`:\n       - set the final price for each collateralType, reading off the price feed\n    We must process some system state before it is possible to calculate\n    the final coin / collateral price. In particular, we need to determine:\n      a. `collateralShortfall` (considers under-collateralised SAFEs)\n      b. `outstandingCoinSupply` (after including system surplus / deficit)\n    We determine (a) by processing all under-collateralised SAFEs with\n    `processSAFE`\n    3. `processSAFE(collateralType, safe)`:\n       - cancels SAFE debt\n       - any excess collateral remains\n       - backing collateral taken\n    We determine (b) by processing ongoing coin generating processes,\n    i.e. auctions. We need to ensure that auctions will not generate any\n    further coin income. In the two-way auction model this occurs when\n    all auctions are in the reverse (`decreaseSoldAmount`) phase. There are two ways\n    of ensuring this:\n    4.  i) `shutdownCooldown`: set the cooldown period to be at least as long as the\n           longest auction duration, which needs to be determined by the\n           shutdown administrator.\n           This takes a fairly predictable time to occur but with altered\n           auction dynamics due to the now varying price of the system coin.\n       ii) `fastTrackAuction`: cancel all ongoing auctions and seize the collateral.\n           This allows for faster processing at the expense of more\n           processing calls. This option allows coin holders to retrieve\n           their collateral faster.\n           `fastTrackAuction(collateralType, auctionId)`:\n            - cancel individual collateral auctions in the `increaseBidSize` (forward) phase\n            - retrieves collateral and returns coins to bidder\n            - `decreaseSoldAmount` (reverse) phase auctions can continue normally\n    Option (i), `shutdownCooldown`, is sufficient for processing the system\n    settlement but option (ii), `fastTrackAuction`, will speed it up. Both options\n    are available in this implementation, with `fastTrackAuction` being enabled on a\n    per-auction basis.\n    When a SAFE has been processed and has no debt remaining, the\n    remaining collateral can be removed.\n    5. `freeCollateral(collateralType)`:\n        - remove collateral from the caller's SAFE\n        - owner can call as needed\n    After the processing period has elapsed, we enable calculation of\n    the final price for each collateral type.\n    6. `setOutstandingCoinSupply()`:\n       - only callable after processing time period elapsed\n       - assumption that all under-collateralised SAFEs are processed\n       - fixes the total outstanding supply of coin\n       - may also require extra SAFE processing to cover system surplus\n    7. `calculateCashPrice(collateralType)`:\n        - calculate `collateralCashPrice`\n        - adjusts `collateralCashPrice` in the case of deficit / surplus\n    At this point we have computed the final price for each collateral\n    type and coin holders can now turn their coin into collateral. Each\n    unit coin can claim a fixed basket of collateral.\n    Coin holders must first `prepareCoinsForRedeeming` into a `coinBag`. Once prepared,\n    coins cannot be transferred out of the bag. More coin can be added to a bag later.\n    8. `prepareCoinsForRedeeming(coinAmount)`:\n        - put some coins into a bag in order to 'redeemCollateral'. The bigger the bag, the more collateral the user can claim.\n    9. `redeemCollateral(collateralType, collateralAmount)`:\n        - exchange some coin from your bag for tokens from a specific collateral type\n        - the amount of collateral available to redeem is limited by how big your bag is\n*/\n\ncontract GlobalSettlement {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"GlobalSettlement/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    SAFEEngineLike            public safeEngine;\n    LiquidationEngineLike    public liquidationEngine;\n    AccountingEngineLike     public accountingEngine;\n    OracleRelayerLike        public oracleRelayer;\n    CoinSavingsAccountLike   public coinSavingsAccount;\n    StabilityFeeTreasuryLike public stabilityFeeTreasury;\n\n    uint256  public contractEnabled;\n    uint256  public shutdownTime;\n    uint256  public shutdownCooldown;\n    uint256  public outstandingCoinSupply;                                      // [rad]\n\n    mapping (bytes32 => uint256) public finalCoinPerCollateralPrice;            // [ray]\n    mapping (bytes32 => uint256) public collateralShortfall;                    // [wad]\n    mapping (bytes32 => uint256) public collateralTotalDebt;                    // [wad]\n    mapping (bytes32 => uint256) public collateralCashPrice;                    // [ray]\n\n    mapping (address => uint256)                      public coinBag;           // [wad]\n    mapping (bytes32 => mapping (address => uint256)) public coinsUsedToRedeem; // [wad]\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event ShutdownSystem();\n    event FreezeCollateralType(bytes32 collateralType, uint finalCoinPerCollateralPrice);\n    event FastTrackAuction(bytes32 collateralType, uint256 auctionId, uint256 collateralTotalDebt);\n    event ProcessSAFE(bytes32 collateralType, address safe, uint256 collateralShortfall);\n    event FreeCollateral(bytes32 collateralType, address sender, int collateralAmount);\n    event SetOutstandingCoinSupply(uint256 outstandingCoinSupply);\n    event CalculateCashPrice(bytes32 collateralType, uint collateralCashPrice);\n    event PrepareCoinsForRedeeming(address sender, uint coinBag);\n    event RedeemCollateral(bytes32 collateralType, address sender, uint coinsAmount, uint collateralAmount);\n\n    // --- Init ---\n    constructor() public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function minimum(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        if (parameter == \"safeEngine\") safeEngine = SAFEEngineLike(data);\n        else if (parameter == \"liquidationEngine\") liquidationEngine = LiquidationEngineLike(data);\n        else if (parameter == \"accountingEngine\") accountingEngine = AccountingEngineLike(data);\n        else if (parameter == \"oracleRelayer\") oracleRelayer = OracleRelayerLike(data);\n        else if (parameter == \"coinSavingsAccount\") coinSavingsAccount = CoinSavingsAccountLike(data);\n        else if (parameter == \"stabilityFeeTreasury\") stabilityFeeTreasury = StabilityFeeTreasuryLike(data);\n        else revert(\"GlobalSettlement/modify-unrecognized-parameter\");\n        emit ModifyParameters(parameter, data);\n    }\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        if (parameter == \"shutdownCooldown\") shutdownCooldown = data;\n        else revert(\"GlobalSettlement/modify-unrecognized-parameter\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Settlement ---\n    function shutdownSystem() external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        contractEnabled = 0;\n        shutdownTime = now;\n        safeEngine.disableContract();\n        liquidationEngine.disableContract();\n        // treasury must be disabled before AccountingEngine so that all surplus is gathered in one place\n        if (address(stabilityFeeTreasury) != address(0)) {\n          stabilityFeeTreasury.disableContract();\n        }\n        accountingEngine.disableContract();\n        oracleRelayer.disableContract();\n        if (address(coinSavingsAccount) != address(0)) {\n          coinSavingsAccount.disableContract();\n        }\n        emit ShutdownSystem();\n    }\n\n    function freezeCollateralType(bytes32 collateralType) external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        require(finalCoinPerCollateralPrice[collateralType] == 0, \"GlobalSettlement/final-collateral-price-already-defined\");\n        (collateralTotalDebt[collateralType],,,,,) = safeEngine.collateralTypes(collateralType);\n        (OracleLike orcl,,) = oracleRelayer.collateralTypes(collateralType);\n        // redemptionPrice is a ray, orcl returns a wad\n        finalCoinPerCollateralPrice[collateralType] = wdivide(oracleRelayer.redemptionPrice(), uint(orcl.read()));\n        emit FreezeCollateralType(collateralType, finalCoinPerCollateralPrice[collateralType]);\n    }\n    function fastTrackAuction(bytes32 collateralType, uint256 auctionId) external {\n        require(finalCoinPerCollateralPrice[collateralType] != 0, \"GlobalSettlement/final-collateral-price-not-defined\");\n\n        (address auctionHouse_,,)    = liquidationEngine.collateralTypes(collateralType);\n        CollateralAuctionHouseLike collateralAuctionHouse = CollateralAuctionHouseLike(auctionHouse_);\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n\n        uint bidAmount                    = collateralAuctionHouse.bidAmount(auctionId);\n        uint collateralToSell             = collateralAuctionHouse.remainingAmountToSell(auctionId);\n        address forgoneCollateralReceiver = collateralAuctionHouse.forgoneCollateralReceiver(auctionId);\n        uint amountToRaise                = collateralAuctionHouse.amountToRaise(auctionId);\n\n        safeEngine.createUnbackedDebt(address(accountingEngine), address(accountingEngine), amountToRaise);\n        safeEngine.createUnbackedDebt(address(accountingEngine), address(this), bidAmount);\n        safeEngine.approveSAFEModification(address(collateralAuctionHouse));\n        collateralAuctionHouse.terminateAuctionPrematurely(auctionId);\n\n        uint debt_ = amountToRaise / accumulatedRate;\n        collateralTotalDebt[collateralType] = addition(collateralTotalDebt[collateralType], debt_);\n        require(int(collateralToSell) >= 0 && int(debt_) >= 0, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(collateralType, forgoneCollateralReceiver, address(this), address(accountingEngine), int(collateralToSell), int(debt_));\n        emit FastTrackAuction(collateralType, auctionId, collateralTotalDebt[collateralType]);\n    }\n    function processSAFE(bytes32 collateralType, address safe) external {\n        require(finalCoinPerCollateralPrice[collateralType] != 0, \"GlobalSettlement/final-collateral-price-not-defined\");\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n        (uint safeCollateral, uint safeDebt) = safeEngine.safes(collateralType, safe);\n\n        uint amountOwed = rmultiply(rmultiply(safeDebt, accumulatedRate), finalCoinPerCollateralPrice[collateralType]);\n        uint minCollateral = minimum(safeCollateral, amountOwed);\n        collateralShortfall[collateralType] = addition(\n            collateralShortfall[collateralType],\n            subtract(amountOwed, minCollateral)\n        );\n\n        require(minCollateral <= 2**255 && safeDebt <= 2**255, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(\n            collateralType,\n            safe,\n            address(this),\n            address(accountingEngine),\n            -int(minCollateral),\n            -int(safeDebt)\n        );\n\n        emit ProcessSAFE(collateralType, safe, collateralShortfall[collateralType]);\n    }\n    function freeCollateral(bytes32 collateralType) external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        (uint safeCollateral, uint safeDebt) = safeEngine.safes(collateralType, msg.sender);\n        require(safeDebt == 0, \"GlobalSettlement/art-not-zero\");\n        require(safeCollateral <= 2**255, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(\n          collateralType,\n          msg.sender,\n          msg.sender,\n          address(accountingEngine),\n          -int(safeCollateral),\n          0\n        );\n        emit FreeCollateral(collateralType, msg.sender, -int(safeCollateral));\n    }\n    function setOutstandingCoinSupply() external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        require(outstandingCoinSupply == 0, \"GlobalSettlement/outstanding-coin-supply-not-zero\");\n        require(safeEngine.coinBalance(address(accountingEngine)) == 0, \"GlobalSettlement/surplus-not-zero\");\n        require(now >= addition(shutdownTime, shutdownCooldown), \"GlobalSettlement/shutdown-cooldown-not-finished\");\n        outstandingCoinSupply = safeEngine.globalDebt();\n        emit SetOutstandingCoinSupply(outstandingCoinSupply);\n    }\n    function calculateCashPrice(bytes32 collateralType) external {\n        require(outstandingCoinSupply != 0, \"GlobalSettlement/outstanding-coin-supply-zero\");\n        require(collateralCashPrice[collateralType] == 0, \"GlobalSettlement/collateral-cash-price-already-defined\");\n\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n        uint256 redemptionAdjustedDebt = rmultiply(\n          rmultiply(collateralTotalDebt[collateralType], accumulatedRate), finalCoinPerCollateralPrice[collateralType]\n        );\n        collateralCashPrice[collateralType] = rdivide(\n          multiply(subtract(redemptionAdjustedDebt, collateralShortfall[collateralType]), RAY), outstandingCoinSupply\n        );\n        emit CalculateCashPrice(collateralType, collateralCashPrice[collateralType]);\n    }\n    function prepareCoinsForRedeeming(uint256 coinAmount) external {\n        require(outstandingCoinSupply != 0, \"GlobalSettlement/outstanding-coin-supply-zero\");\n        safeEngine.transferInternalCoins(msg.sender, address(accountingEngine), multiply(coinAmount, RAY));\n        coinBag[msg.sender] = addition(coinBag[msg.sender], coinAmount);\n        emit PrepareCoinsForRedeeming(msg.sender, coinBag[msg.sender]);\n    }\n    function redeemCollateral(bytes32 collateralType, uint coinsAmount) external {\n        require(collateralCashPrice[collateralType] != 0, \"GlobalSettlement/collateral-cash-price-not-defined\");\n        uint collateralAmount = rmultiply(coinsAmount, collateralCashPrice[collateralType]);\n        safeEngine.transferCollateral(\n          collateralType,\n          address(this),\n          msg.sender,\n          collateralAmount\n        );\n        coinsUsedToRedeem[collateralType][msg.sender] = addition(coinsUsedToRedeem[collateralType][msg.sender], coinsAmount);\n        require(coinsUsedToRedeem[collateralType][msg.sender] <= coinBag[msg.sender], \"GlobalSettlement/insufficient-bag-balance\");\n        emit RedeemCollateral(collateralType, msg.sender, coinsAmount, collateralAmount);\n    }\n}"
    },
    {
      "filename": "src/BasicTokenAdapters.sol",
      "content": "/// BasicTokenAdapters.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract CollateralLike {\n    function decimals() virtual public view returns (uint);\n    function transfer(address,uint) virtual public returns (bool);\n    function transferFrom(address,address,uint) virtual public returns (bool);\n}\n\nabstract contract DSTokenLike {\n    function mint(address,uint) virtual external;\n    function burn(address,uint) virtual external;\n}\n\nabstract contract SAFEEngineLike {\n    function modifyCollateralBalance(bytes32,address,int) virtual external;\n    function transferInternalCoins(address,address,uint) virtual external;\n}\n\n/*\n    Here we provide *adapters* to connect the SAFEEngine to arbitrary external\n    token implementations, creating a bounded context for the SAFEEngine. The\n    adapters here are provided as working examples:\n      - `BasicCollateralJoin`: For well behaved ERC20 tokens, with simple transfer semantics.\n      - `ETHJoin`: For native Ether.\n      - `CoinJoin`: For connecting internal coin balances to an external\n                   `Coin` implementation.\n    In practice, adapter implementations will be varied and specific to\n    individual collateral types, accounting for different transfer\n    semantics and token standards.\n    Adapters need to implement two basic methods:\n      - `join`: enter collateral into the system\n      - `exit`: remove collateral from the system\n*/\n\ncontract BasicCollateralJoin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"BasicCollateralJoin/account-not-authorized\");\n        _"
    }
  ]
}