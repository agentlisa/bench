{
  "Title": "[M-06] Multiplier is incorrectly calculated in `Controller`",
  "Content": "\nIn `Controller` smart contract, due to mistake in multiplication of `i_gain`, it's miscalculated and the error occurs. This can lead to a multiplier reflecting an incorrect value and therefore affect yin borrowing rate.\n\n### Proof of Concept\n\nAccording to the multiplier formula, first we calculate `p_term`. The formula for `p_term` is following:\n\n`p_term = p_gain * error`\n\nAnd that's done right using the `get_p_term_internal()` function:\n\n<https://github.com/code-423n4/2024-01-opus/blob/main/src/core/controller.cairo#L243-245>\n\n\n    fn get_p_term_internal(self: @ContractState) -> SignedRay {\n                self.p_gain.read() * nonlinear_transform(self.get_current_error(), self.alpha_p.read(), self.beta_p.read())\n            }\n\nThen we add right and go to integral term calculation. It's almost the same as `p_term`, only the time scale factor is added:\n\n<https://github.com/code-423n4/2024-01-opus/blob/main/src/core/controller.cairo#L256-258>\n\n```\n  old_i_term\n                + nonlinear_transform(self.get_prev_error(), self.alpha_i.read(), self.beta_i.read())\n                    * time_since_last_update_scaled\n```\n\nThe problem is that when we add this formula to the multiplier, we multiply it additionally by `i_gain`:\n\n<https://github.com/code-423n4/2024-01-opus/blob/main/src/core/controller.cairo#L166-167>\n\n\n     let new_i_term: SignedRay = self.get_i_term_internal();\n                    multiplier += i_gain * new_i_term;\n\nAnd, according to the formula, only this part should be multiplied by `i_gain`:\n\n    nonlinear_transform(self.get_prev_error(), self.alpha_i.read(), self.beta_i.read())\n                        * time_since_last_update_scaled\n\nBut `old_term` also ends up multiplied.\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2024-01-opus/blob/main/src/core/controller.cairo#L256-258>\n\n```diff\n-               old_i_term + nonlinear_transform(self.get_prev_error(), \n-               self.alpha_i.read(), self.beta_i.read()) * \n-               time_since_last_update_scaled\n\n+               old_i_term + i_gain * nonlinear_transform(self.get_prev_error(), \n+               self.alpha_i.read(), self.beta_i.read()) * \n+               time_since_last_update_scaled\n```\n\n<https://github.com/code-423n4/2024-01-opus/blob/main/src/core/controller.cairo#L167>\n\n```diff\n-               multiplier += i_gain * new_i_term;\n+               multiplier += new_i_term;\n```\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-01-opus-findings/issues/75#issuecomment-1964274383):**\n > The warden has demonstrated how the formula that is in use by the Controller contradicts the documentation of the project, and namely the [specification](https://demo-35.gitbook.io/untitled/smart-contracts/controller-module#specification) of the aforementioned formula.\n> \n> In detail, the specification states:\n> \n> *Note: Please see provided formula in the judge's [original comment](https://github.com/code-423n4/2024-01-opus-findings/issues/75#issuecomment-1964274383).*\n> \n> We are interested in the latter part of the formula, specifically:\n> \n>*Note: Please see provided formula in the judge's [original comment](https://github.com/code-423n4/2024-01-opus-findings/issues/75#issuecomment-1964274383).*\n> \n> The documentation states that `k_i` stands for the:\n> \n> > gain that is applied to the integral term\n> \n> The problem highlighted by the warden is that the implementation will calculate the following:\n> \n> *Note: Please see provided formula in the judge's [original comment](https://github.com/code-423n4/2024-01-opus-findings/issues/75#issuecomment-1964274383).*\n> \n> The above corresponds to:\n> \n> ```cairo\n> let new_i_term: SignedRay = self.get_i_term_internal();\n> multiplier += i_gain * new_i_term;\n> ```\n> \n> Whereby the `get_i_term_internal` function will ultimately yield:\n> \n> ```cairo\n> old_i_term\n>     + nonlinear_transform(self.get_prev_error(), self.alpha_i.read(), self.beta_i.read())\n>     * time_since_last_update_scaled\n> ```\n> \n> In the above:\n> \n> *Note: please review provided terms in the judge's [original comment](https://github.com/code-423n4/2024-01-opus-findings/issues/75#issuecomment-1964274383).*\n> \n> Based on the above analysis, the documentation indeed contradicts what the code calculates. The Opus team is invited to evaluate this exhibit; however, regardless of the correct behaviour of the system, this submission will be accepted as valid due to the documentation being the \"source of truth\" during the audit's duration.\n\n**[milancermak (Opus) confirmed](https://github.com/code-423n4/2024-01-opus-findings/issues/75#issuecomment-1966748974)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/controller.cairo",
      "content": "#[starknet::contract]\nmod controller {\n    use access_control::access_control_component;\n    use opus::core::roles::controller_roles;\n    use opus::interfaces::IController::IController;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::utils::math;\n    use starknet::{ContractAddress, contract_address, get_block_timestamp};\n    use wadray::{Ray, RAY_ONE, SignedRay, SignedRayZeroable, Wad};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Time intervals between updates are scaled down by this factor\n    // to prevent the integral term from getting too large\n    const TIME_SCALE: u128 = consteval_int!(60 * 60); // 60 mins * 60 seconds = 1 hour\n\n    // multiplier bounds (ray)\n    const MIN_MULTIPLIER: u128 = 200000000000000000000000000; // 0.2\n    const MAX_MULTIPLIER: u128 = 2000000000000000000000000000; // 2\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // Shrine associated with this Controller\n        shrine: IShrineDispatcher,\n        // parameters\n        yin_previous_price: Wad,\n        yin_price_last_updated: u64,\n        i_term_last_updated: u64,\n        i_term: SignedRay,\n        p_gain: SignedRay,\n        i_gain: SignedRay,\n        alpha_p: u8,\n        beta_p: u8,\n        alpha_i: u8,\n        beta_i: u8,\n    }\n\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        ParameterUpdated: ParameterUpdated,\n        GainUpdated: GainUpdated,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct ParameterUpdated {\n        #[key]\n        name: felt252,\n        value: u8\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct GainUpdated {\n        #[key]\n        name: felt252,\n        value: Ray\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState,\n        admin: ContractAddress,\n        shrine: ContractAddress,\n        p_gain: Ray,\n        i_gain: Ray,\n        alpha_p: u8,\n        beta_p: u8,\n        alpha_i: u8,\n        beta_i: u8,\n    ) {\n        self.access_control.initializer(admin, Option::Some(controller_roles::default_admin_role()));\n\n        // Setting `i_term_last_updated` to the current timestamp to\n        // ensure that the integral term is correctly updated\n        self.i_term_last_updated.write(get_block_timestamp());\n\n        // Initializing the previous price to the current price\n        // This ensures the integral term is correctly calculated\n        let shrine = IShrineDispatcher { contract_address: shrine };\n        self.yin_previous_price.write(shrine.get_yin_spot_price());\n        self.shrine.write(shrine);\n\n        self.p_gain.write(p_gain.into());\n        self.i_gain.write(i_gain.into());\n        self.alpha_p.write(alpha_p);\n        self.beta_p.write(beta_p);\n        self.alpha_i.write(alpha_i);\n        self.beta_i.write(beta_i);\n\n        self.emit(GainUpdated { name: 'p_gain', value: p_gain });\n        self.emit(GainUpdated { name: 'i_gain', value: i_gain });\n        self.emit(ParameterUpdated { name: 'alpha_p', value: alpha_p });\n        self.emit(ParameterUpdated { name: 'beta_p', value: beta_p });\n        self.emit(ParameterUpdated { name: 'alpha_i', value: alpha_i });\n        self.emit(ParameterUpdated { name: 'beta_i', value: beta_i });\n    }\n\n    #[abi(embed_v0)]\n    impl IControllerImpl of IController<ContractState> {\n        fn get_current_multiplier(self: @ContractState) -> Ray {\n            let i_gain = self.i_gain.read();\n\n            let mut multiplier: SignedRay = RAY_ONE.into() + self.get_p_term_internal();\n\n            if i_gain.is_non_zero() {\n                let new_i_term: SignedRay = self.get_i_term_internal();\n                multiplier += i_gain * new_i_term;\n            }\n\n            bound_multiplier(multiplier).try_into().unwrap()\n        }\n\n\n        fn get_p_term(self: @ContractState) -> SignedRay {\n            self.get_p_term_internal()\n        }\n\n\n        fn get_i_term(self: @ContractState) -> SignedRay {\n            let i_gain = self.i_gain.read();\n            if i_gain.is_zero() {\n                SignedRayZeroable::zero()\n            } else {\n                i_gain * self.get_i_term_internal()\n            }\n        }\n\n\n        fn get_parameters(self: @ContractState) -> ((SignedRay, SignedRay), (u8, u8, u8, u8)) {\n            (\n                (self.p_gain.read(), self.i_gain.read()),\n                (self.alpha_p.read(), self.beta_p.read(), self.alpha_i.read(), self.beta_i.read())\n            )\n        }\n\n\n        fn update_multiplier(ref self: ContractState) {\n            let shrine: IShrineDispatcher = self.shrine.read();\n\n            let i_gain = self.i_gain.read();\n            let mut multiplier: SignedRay = RAY_ONE.into() + self.get_p_term_internal();\n\n            // Only updating the integral term and adding it to the multiplier if the integral gain is non-zero\n            if i_gain.is_non_zero() {\n                let new_i_term: SignedRay = self.get_i_term_internal();\n                multiplier += i_gain * new_i_term;\n                self.i_term.write(new_i_term);\n                self.i_term_last_updated.write(get_block_timestamp());\n            }\n\n            // Updating the previous yin price for the next integral term update\n            self.yin_previous_price.write(shrine.get_yin_spot_price().into());\n\n            let multiplier_ray: Ray = bound_multiplier(multiplier).try_into().unwrap();\n            shrine.set_multiplier(multiplier_ray);\n        }\n\n\n        fn set_p_gain(ref self: ContractState, p_gain: Ray) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            self.p_gain.write(p_gain.into());\n            self.emit(GainUpdated { name: 'p_gain', value: p_gain });\n        }\n\n\n        fn set_i_gain(ref self: ContractState, i_gain: Ray) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n\n            // Since `i_term_last_updated` isn't updated in `update_multiplier`\n            // while `i_gain` is zero, we must update it here whenever the\n            // `i_gain` is set from zero to a non-zero value in order to ensure\n            // that the accumulation of the integral term starts at zero.\n            if self.i_gain.read().is_zero() {\n                self.i_term_last_updated.write(get_block_timestamp());\n            }\n\n            // Reset the integral term if the i_gain is set to zero\n            if i_gain.is_zero() {\n                self.i_term.write(SignedRayZeroable::zero());\n            }\n\n            self.i_gain.write(i_gain.into());\n            self.emit(GainUpdated { name: 'i_gain', value: i_gain });\n        }\n\n\n        fn set_alpha_p(ref self: ContractState, alpha_p: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(alpha_p % 2 == 1, 'CTR: alpha_p must be odd');\n            self.alpha_p.write(alpha_p);\n            self.emit(ParameterUpdated { name: 'alpha_p', value: alpha_p });\n        }\n\n\n        fn set_beta_p(ref self: ContractState, beta_p: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(beta_p % 2 == 0, 'CTR: beta_p must be even');\n            self.beta_p.write(beta_p);\n            self.emit(ParameterUpdated { name: 'beta_p', value: beta_p });\n        }\n\n\n        fn set_alpha_i(ref self: ContractState, alpha_i: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(alpha_i % 2 == 1, 'CTR: alpha_i must be odd');\n            self.alpha_i.write(alpha_i);\n            self.emit(ParameterUpdated { name: 'alpha_i', value: alpha_i });\n        }\n\n\n        fn set_beta_i(ref self: ContractState, beta_i: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(beta_i % 2 == 0, 'CTR: beta_i must be even');\n            self.beta_i.write(beta_i);\n            self.emit(ParameterUpdated { name: 'beta_i', value: beta_i });\n        }\n    }\n\n    #[generate_trait]\n    impl ControllerInternalFunctions of ControllerInternalFunctionsTrait {\n        #[inline(always)]\n        fn get_p_term_internal(self: @ContractState) -> SignedRay {\n            self.p_gain.read() * nonlinear_transform(self.get_current_error(), self.alpha_p.read(), self.beta_p.read())\n        }\n\n        #[inline(always)]\n        fn get_i_term_internal(self: @ContractState) -> SignedRay {\n            let current_timestamp: u64 = get_block_timestamp();\n            let old_i_term = self.i_term.read();\n\n            let time_since_last_update: u128 = (current_timestamp - self.i_term_last_updated.read()).into();\n            let time_since_last_update_scaled: SignedRay = (time_since_last_update * RAY_ONE).into()\n                / (TIME_SCALE * RAY_ONE).into();\n\n            old_i_term\n                + nonlinear_transform(self.get_prev_error(), self.alpha_i.read(), self.beta_i.read())\n                    * time_since_last_update_scaled\n        }\n\n        #[inline(always)]\n        fn get_current_error(self: @ContractState) -> SignedRay {\n            RAY_ONE.into() - self.shrine.read().get_yin_spot_price().into()\n        }\n\n        // Returns the error at the time of the last update to the multiplier\n        #[inline(always)]\n        fn get_prev_error(self: @ContractState) -> SignedRay {\n            RAY_ONE.into() - self.yin_previous_price.read().into()\n        }\n    }\n\n    // Pure functions\n\n    #[inline(always)]\n    fn nonlinear_transform(error: SignedRay, alpha: u8, beta: u8) -> SignedRay {\n        let error_ray: Ray = Ray { val: error.val };\n        let denominator: SignedRay = math::sqrt(RAY_ONE.into() + math::pow(error_ray, beta)).into();\n        math::pow(error, alpha) / denominator\n    }\n\n    #[inline(always)]\n    fn bound_multiplier(multiplier: SignedRay) -> SignedRay {\n        if multiplier > MAX_MULTIPLIER.into() {\n            MAX_MULTIPLIER.into()\n        } else if multiplier < MIN_MULTIPLIER.into() {\n            MIN_MULTIPLIER.into()\n        } else {\n            multiplier\n        }\n    }\n}"
    },
    {
      "filename": "src/core/controller.cairo",
      "content": "#[starknet::contract]\nmod controller {\n    use access_control::access_control_component;\n    use opus::core::roles::controller_roles;\n    use opus::interfaces::IController::IController;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::utils::math;\n    use starknet::{ContractAddress, contract_address, get_block_timestamp};\n    use wadray::{Ray, RAY_ONE, SignedRay, SignedRayZeroable, Wad};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Time intervals between updates are scaled down by this factor\n    // to prevent the integral term from getting too large\n    const TIME_SCALE: u128 = consteval_int!(60 * 60); // 60 mins * 60 seconds = 1 hour\n\n    // multiplier bounds (ray)\n    const MIN_MULTIPLIER: u128 = 200000000000000000000000000; // 0.2\n    const MAX_MULTIPLIER: u128 = 2000000000000000000000000000; // 2\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // Shrine associated with this Controller\n        shrine: IShrineDispatcher,\n        // parameters\n        yin_previous_price: Wad,\n        yin_price_last_updated: u64,\n        i_term_last_updated: u64,\n        i_term: SignedRay,\n        p_gain: SignedRay,\n        i_gain: SignedRay,\n        alpha_p: u8,\n        beta_p: u8,\n        alpha_i: u8,\n        beta_i: u8,\n    }\n\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        ParameterUpdated: ParameterUpdated,\n        GainUpdated: GainUpdated,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct ParameterUpdated {\n        #[key]\n        name: felt252,\n        value: u8\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct GainUpdated {\n        #[key]\n        name: felt252,\n        value: Ray\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState,\n        admin: ContractAddress,\n        shrine: ContractAddress,\n        p_gain: Ray,\n        i_gain: Ray,\n        alpha_p: u8,\n        beta_p: u8,\n        alpha_i: u8,\n        beta_i: u8,\n    ) {\n        self.access_control.initializer(admin, Option::Some(controller_roles::default_admin_role()));\n\n        // Setting `i_term_last_updated` to the current timestamp to\n        // ensure that the integral term is correctly updated\n        self.i_term_last_updated.write(get_block_timestamp());\n\n        // Initializing the previous price to the current price\n        // This ensures the integral term is correctly calculated\n        let shrine = IShrineDispatcher { contract_address: shrine };\n        self.yin_previous_price.write(shrine.get_yin_spot_price());\n        self.shrine.write(shrine);\n\n        self.p_gain.write(p_gain.into());\n        self.i_gain.write(i_gain.into());\n        self.alpha_p.write(alpha_p);\n        self.beta_p.write(beta_p);\n        self.alpha_i.write(alpha_i);\n        self.beta_i.write(beta_i);\n\n        self.emit(GainUpdated { name: 'p_gain', value: p_gain });\n        self.emit(GainUpdated { name: 'i_gain', value: i_gain });\n        self.emit(ParameterUpdated { name: 'alpha_p', value: alpha_p });\n        self.emit(ParameterUpdated { name: 'beta_p', value: beta_p });\n        self.emit(ParameterUpdated { name: 'alpha_i', value: alpha_i });\n        self.emit(ParameterUpdated { name: 'beta_i', value: beta_i });\n    }\n\n    #[abi(embed_v0)]\n    impl IControllerImpl of IController<ContractState> {\n        fn get_current_multiplier(self: @ContractState) -> Ray {\n            let i_gain = self.i_gain.read();\n\n            let mut multiplier: SignedRay = RAY_ONE.into() + self.get_p_term_internal();\n\n            if i_gain.is_non_zero() {\n                let new_i_term: SignedRay = self.get_i_term_internal();\n                multiplier += i_gain * new_i_term;\n            }\n\n            bound_multiplier(multiplier).try_into().unwrap()\n        }\n\n\n        fn get_p_term(self: @ContractState) -> SignedRay {\n            self.get_p_term_internal()\n        }\n\n\n        fn get_i_term(self: @ContractState) -> SignedRay {\n            let i_gain = self.i_gain.read();\n            if i_gain.is_zero() {\n                SignedRayZeroable::zero()\n            } else {\n                i_gain * self.get_i_term_internal()\n            }\n        }\n\n\n        fn get_parameters(self: @ContractState) -> ((SignedRay, SignedRay), (u8, u8, u8, u8)) {\n            (\n                (self.p_gain.read(), self.i_gain.read()),\n                (self.alpha_p.read(), self.beta_p.read(), self.alpha_i.read(), self.beta_i.read())\n            )\n        }\n\n\n        fn update_multiplier(ref self: ContractState) {\n            let shrine: IShrineDispatcher = self.shrine.read();\n\n            let i_gain = self.i_gain.read();\n            let mut multiplier: SignedRay = RAY_ONE.into() + self.get_p_term_internal();\n\n            // Only updating the integral term and adding it to the multiplier if the integral gain is non-zero\n            if i_gain.is_non_zero() {\n                let new_i_term: SignedRay = self.get_i_term_internal();\n                multiplier += i_gain * new_i_term;\n                self.i_term.write(new_i_term);\n                self.i_term_last_updated.write(get_block_timestamp());\n            }\n\n            // Updating the previous yin price for the next integral term update\n            self.yin_previous_price.write(shrine.get_yin_spot_price().into());\n\n            let multiplier_ray: Ray = bound_multiplier(multiplier).try_into().unwrap();\n            shrine.set_multiplier(multiplier_ray);\n        }\n\n\n        fn set_p_gain(ref self: ContractState, p_gain: Ray) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            self.p_gain.write(p_gain.into());\n            self.emit(GainUpdated { name: 'p_gain', value: p_gain });\n        }\n\n\n        fn set_i_gain(ref self: ContractState, i_gain: Ray) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n\n            // Since `i_term_last_updated` isn't updated in `update_multiplier`\n            // while `i_gain` is zero, we must update it here whenever the\n            // `i_gain` is set from zero to a non-zero value in order to ensure\n            // that the accumulation of the integral term starts at zero.\n            if self.i_gain.read().is_zero() {\n                self.i_term_last_updated.write(get_block_timestamp());\n            }\n\n            // Reset the integral term if the i_gain is set to zero\n            if i_gain.is_zero() {\n                self.i_term.write(SignedRayZeroable::zero());\n            }\n\n            self.i_gain.write(i_gain.into());\n            self.emit(GainUpdated { name: 'i_gain', value: i_gain });\n        }\n\n\n        fn set_alpha_p(ref self: ContractState, alpha_p: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(alpha_p % 2 == 1, 'CTR: alpha_p must be odd');\n            self.alpha_p.write(alpha_p);\n            self.emit(ParameterUpdated { name: 'alpha_p', value: alpha_p });\n        }\n\n\n        fn set_beta_p(ref self: ContractState, beta_p: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(beta_p % 2 == 0, 'CTR: beta_p must be even');\n            self.beta_p.write(beta_p);\n            self.emit(ParameterUpdated { name: 'beta_p', value: beta_p });\n        }\n\n\n        fn set_alpha_i(ref self: ContractState, alpha_i: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(alpha_i % 2 == 1, 'CTR: alpha_i must be odd');\n            self.alpha_i.write(alpha_i);\n            self.emit(ParameterUpdated { name: 'alpha_i', value: alpha_i });\n        }\n\n\n        fn set_beta_i(ref self: ContractState, beta_i: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(beta_i % 2 == 0, 'CTR: beta_i must be even');\n            self.beta_i.write(beta_i);\n            self.emit(ParameterUpdated { name: 'beta_i', value: beta_i });\n        }\n    }\n\n    #[generate_trait]\n    impl ControllerInternalFunctions of ControllerInternalFunctionsTrait {\n        #[inline(always)]\n        fn get_p_term_internal(self: @ContractState) -> SignedRay {\n            self.p_gain.read() * nonlinear_transform(self.get_current_error(), self.alpha_p.read(), self.beta_p.read())\n        }\n\n        #[inline(always)]\n        fn get_i_term_internal(self: @ContractState) -> SignedRay {\n            let current_timestamp: u64 = get_block_timestamp();\n            let old_i_term = self.i_term.read();\n\n            let time_since_last_update: u128 = (current_timestamp - self.i_term_last_updated.read()).into();\n            let time_since_last_update_scaled: SignedRay = (time_since_last_update * RAY_ONE).into()\n                / (TIME_SCALE * RAY_ONE).into();\n\n            old_i_term\n                + nonlinear_transform(self.get_prev_error(), self.alpha_i.read(), self.beta_i.read())\n                    * time_since_last_update_scaled\n        }\n\n        #[inline(always)]\n        fn get_current_error(self: @ContractState) -> SignedRay {\n            RAY_ONE.into() - self.shrine.read().get_yin_spot_price().into()\n        }\n\n        // Returns the error at the time of the last update to the multiplier\n        #[inline(always)]\n        fn get_prev_error(self: @ContractState) -> SignedRay {\n            RAY_ONE.into() - self.yin_previous_price.read().into()\n        }\n    }\n\n    // Pure functions\n\n    #[inline(always)]\n    fn nonlinear_transform(error: SignedRay, alpha: u8, beta: u8) -> SignedRay {\n        let error_ray: Ray = Ray { val: error.val };\n        let denominator: SignedRay = math::sqrt(RAY_ONE.into() + math::pow(error_ray, beta)).into();\n        math::pow(error, alpha) / denominator\n    }\n\n    #[inline(always)]\n    fn bound_multiplier(multiplier: SignedRay) -> SignedRay {\n        if multiplier > MAX_MULTIPLIER.into() {\n            MAX_MULTIPLIER.into()\n        } else if multiplier < MIN_MULTIPLIER.into() {\n            MIN_MULTIPLIER.into()\n        } else {\n            multiplier\n        }\n    }\n}"
    },
    {
      "filename": "src/core/controller.cairo",
      "content": "#[starknet::contract]\nmod controller {\n    use access_control::access_control_component;\n    use opus::core::roles::controller_roles;\n    use opus::interfaces::IController::IController;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::utils::math;\n    use starknet::{ContractAddress, contract_address, get_block_timestamp};\n    use wadray::{Ray, RAY_ONE, SignedRay, SignedRayZeroable, Wad};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Time intervals between updates are scaled down by this factor\n    // to prevent the integral term from getting too large\n    const TIME_SCALE: u128 = consteval_int!(60 * 60); // 60 mins * 60 seconds = 1 hour\n\n    // multiplier bounds (ray)\n    const MIN_MULTIPLIER: u128 = 200000000000000000000000000; // 0.2\n    const MAX_MULTIPLIER: u128 = 2000000000000000000000000000; // 2\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // Shrine associated with this Controller\n        shrine: IShrineDispatcher,\n        // parameters\n        yin_previous_price: Wad,\n        yin_price_last_updated: u64,\n        i_term_last_updated: u64,\n        i_term: SignedRay,\n        p_gain: SignedRay,\n        i_gain: SignedRay,\n        alpha_p: u8,\n        beta_p: u8,\n        alpha_i: u8,\n        beta_i: u8,\n    }\n\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        ParameterUpdated: ParameterUpdated,\n        GainUpdated: GainUpdated,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct ParameterUpdated {\n        #[key]\n        name: felt252,\n        value: u8\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct GainUpdated {\n        #[key]\n        name: felt252,\n        value: Ray\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState,\n        admin: ContractAddress,\n        shrine: ContractAddress,\n        p_gain: Ray,\n        i_gain: Ray,\n        alpha_p: u8,\n        beta_p: u8,\n        alpha_i: u8,\n        beta_i: u8,\n    ) {\n        self.access_control.initializer(admin, Option::Some(controller_roles::default_admin_role()));\n\n        // Setting `i_term_last_updated` to the current timestamp to\n        // ensure that the integral term is correctly updated\n        self.i_term_last_updated.write(get_block_timestamp());\n\n        // Initializing the previous price to the current price\n        // This ensures the integral term is correctly calculated\n        let shrine = IShrineDispatcher { contract_address: shrine };\n        self.yin_previous_price.write(shrine.get_yin_spot_price());\n        self.shrine.write(shrine);\n\n        self.p_gain.write(p_gain.into());\n        self.i_gain.write(i_gain.into());\n        self.alpha_p.write(alpha_p);\n        self.beta_p.write(beta_p);\n        self.alpha_i.write(alpha_i);\n        self.beta_i.write(beta_i);\n\n        self.emit(GainUpdated { name: 'p_gain', value: p_gain });\n        self.emit(GainUpdated { name: 'i_gain', value: i_gain });\n        self.emit(ParameterUpdated { name: 'alpha_p', value: alpha_p });\n        self.emit(ParameterUpdated { name: 'beta_p', value: beta_p });\n        self.emit(ParameterUpdated { name: 'alpha_i', value: alpha_i });\n        self.emit(ParameterUpdated { name: 'beta_i', value: beta_i });\n    }\n\n    #[abi(embed_v0)]\n    impl IControllerImpl of IController<ContractState> {\n        fn get_current_multiplier(self: @ContractState) -> Ray {\n            let i_gain = self.i_gain.read();\n\n            let mut multiplier: SignedRay = RAY_ONE.into() + self.get_p_term_internal();\n\n            if i_gain.is_non_zero() {\n                let new_i_term: SignedRay = self.get_i_term_internal();\n                multiplier += i_gain * new_i_term;\n            }\n\n            bound_multiplier(multiplier).try_into().unwrap()\n        }\n\n\n        fn get_p_term(self: @ContractState) -> SignedRay {\n            self.get_p_term_internal()\n        }\n\n\n        fn get_i_term(self: @ContractState) -> SignedRay {\n            let i_gain = self.i_gain.read();\n            if i_gain.is_zero() {\n                SignedRayZeroable::zero()\n            } else {\n                i_gain * self.get_i_term_internal()\n            }\n        }\n\n\n        fn get_parameters(self: @ContractState) -> ((SignedRay, SignedRay), (u8, u8, u8, u8)) {\n            (\n                (self.p_gain.read(), self.i_gain.read()),\n                (self.alpha_p.read(), self.beta_p.read(), self.alpha_i.read(), self.beta_i.read())\n            )\n        }\n\n\n        fn update_multiplier(ref self: ContractState) {\n            let shrine: IShrineDispatcher = self.shrine.read();\n\n            let i_gain = self.i_gain.read();\n            let mut multiplier: SignedRay = RAY_ONE.into() + self.get_p_term_internal();\n\n            // Only updating the integral term and adding it to the multiplier if the integral gain is non-zero\n            if i_gain.is_non_zero() {\n                let new_i_term: SignedRay = self.get_i_term_internal();\n                multiplier += i_gain * new_i_term;\n                self.i_term.write(new_i_term);\n                self.i_term_last_updated.write(get_block_timestamp());\n            }\n\n            // Updating the previous yin price for the next integral term update\n            self.yin_previous_price.write(shrine.get_yin_spot_price().into());\n\n            let multiplier_ray: Ray = bound_multiplier(multiplier).try_into().unwrap();\n            shrine.set_multiplier(multiplier_ray);\n        }\n\n\n        fn set_p_gain(ref self: ContractState, p_gain: Ray) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            self.p_gain.write(p_gain.into());\n            self.emit(GainUpdated { name: 'p_gain', value: p_gain });\n        }\n\n\n        fn set_i_gain(ref self: ContractState, i_gain: Ray) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n\n            // Since `i_term_last_updated` isn't updated in `update_multiplier`\n            // while `i_gain` is zero, we must update it here whenever the\n            // `i_gain` is set from zero to a non-zero value in order to ensure\n            // that the accumulation of the integral term starts at zero.\n            if self.i_gain.read().is_zero() {\n                self.i_term_last_updated.write(get_block_timestamp());\n            }\n\n            // Reset the integral term if the i_gain is set to zero\n            if i_gain.is_zero() {\n                self.i_term.write(SignedRayZeroable::zero());\n            }\n\n            self.i_gain.write(i_gain.into());\n            self.emit(GainUpdated { name: 'i_gain', value: i_gain });\n        }\n\n\n        fn set_alpha_p(ref self: ContractState, alpha_p: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(alpha_p % 2 == 1, 'CTR: alpha_p must be odd');\n            self.alpha_p.write(alpha_p);\n            self.emit(ParameterUpdated { name: 'alpha_p', value: alpha_p });\n        }\n\n\n        fn set_beta_p(ref self: ContractState, beta_p: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(beta_p % 2 == 0, 'CTR: beta_p must be even');\n            self.beta_p.write(beta_p);\n            self.emit(ParameterUpdated { name: 'beta_p', value: beta_p });\n        }\n\n\n        fn set_alpha_i(ref self: ContractState, alpha_i: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(alpha_i % 2 == 1, 'CTR: alpha_i must be odd');\n            self.alpha_i.write(alpha_i);\n            self.emit(ParameterUpdated { name: 'alpha_i', value: alpha_i });\n        }\n\n\n        fn set_beta_i(ref self: ContractState, beta_i: u8) {\n            self.access_control.assert_has_role(controller_roles::TUNE_CONTROLLER);\n            assert(beta_i % 2 == 0, 'CTR: beta_i must be even');\n            self.beta_i.write(beta_i);\n            self.emit(ParameterUpdated { name: 'beta_i', value: beta_i });\n        }\n    }\n\n    #[generate_trait]\n    impl ControllerInternalFunctions of ControllerInternalFunctionsTrait {\n        #[inline(always)]\n        fn get_p_term_internal(self: @ContractState) -> SignedRay {\n            self.p_gain.read() * nonlinear_transform(self.get_current_error(), self.alpha_p.read(), self.beta_p.read())\n        }\n\n        #[inline(always)]\n        fn get_i_term_internal(self: @ContractState) -> SignedRay {\n            let current_timestamp: u64 = get_block_timestamp();\n            let old_i_term = self.i_term.read();\n\n            let time_since_last_update: u128 = (current_timestamp - self.i_term_last_updated.read()).into();\n            let time_since_last_update_scaled: SignedRay = (time_since_last_update * RAY_ONE).into()\n                / (TIME_SCALE * RAY_ONE).into();\n\n            old_i_term\n                + nonlinear_transform(self.get_prev_error(), self.alpha_i.read(), self.beta_i.read())\n                    * time_since_last_update_scaled\n        }\n\n        #[inline(always)]\n        fn get_current_error(self: @ContractState) -> SignedRay {\n            RAY_ONE.into() - self.shrine.read().get_yin_spot_price().into()\n        }\n\n        // Returns the error at the time of the last update to the multiplier\n        #[inline(always)]\n        fn get_prev_error(self: @ContractState) -> SignedRay {\n            RAY_ONE.into() - self.yin_previous_price.read().into()\n        }\n    }\n\n    // Pure functions\n\n    #[inline(always)]\n    fn nonlinear_transform(error: SignedRay, alpha: u8, beta: u8) -> SignedRay {\n        let error_ray: Ray = Ray { val: error.val };\n        let denominator: SignedRay = math::sqrt(RAY_ONE.into() + math::pow(error_ray, beta)).into();\n        math::pow(error, alpha) / denominator\n    }\n\n    #[inline(always)]\n    fn bound_multiplier(multiplier: SignedRay) -> SignedRay {\n        if multiplier > MAX_MULTIPLIER.into() {\n            MAX_MULTIPLIER.into()\n        } else if multiplier < MIN_MULTIPLIER.into() {\n            MIN_MULTIPLIER.into()\n        } else {\n            multiplier\n        }\n    }\n}"
    },
    {
      "filename": "src/core/controller.cairo",
      "content": "#[starknet::contract]\nmod controller {\n    use access_control::access_control_component;\n    use opus::core::roles::controller_roles;\n    use opus::interfaces::IController::IController;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::utils::math;\n    use starknet::{ContractAddress, contract_address, get_block_timestamp};\n    use wadray::{Ray, RAY_ONE, SignedRay, SignedRayZeroable, Wad};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Time intervals between updates are scaled down by this factor\n    // to prevent the integral term from getting too large\n    c"
    }
  ]
}