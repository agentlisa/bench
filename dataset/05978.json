{
  "Title": "[M-07] Liquidators can be tricked to operate with `LiquidationPairs` that were deployed using the `LiquidationPairFactory` but they configured the `LiquidationSource` as a fake malicious contract",
  "Content": "\nUsers and Bots can be tricked into operating with LiquidationPairs that were deployed using the LiquidationPairFactory but they configured the LiquidationSource as a fake malicious contract that will allow the Liquidator's creator to steal all the POOL tokens that were meant to be used to liquidate the Vault's Yield.\n\n### Proof of Concept\n\n*   The current implementation of the [`LiquidationPairFactory::createPair()`](https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/LiquidationPairFactory.sol#L65-L108) allows the callers to set the LiquidationSource as any arbitrary address with no restrictions.\n*   The problem is that the address of the `_source` parameter may not necessarily be a real vault contract, and even though the `_source` address is set as a fake malicious contract, the LiquidationPair will be created and added to the `deployedPairs` mapping, and [as stated in the protocol's documentation, **any LiquidationPair created by the factory determines if a pair is legitimate or not**](https://dev.pooltogether.com/protocol/next/guides/liquidating-yield#find-the-liquidation-pair)\n\n![Liquidation Pair Protocol's Documentation](https://res.cloudinary.com/djt3zbrr3/image/upload/v1691397160/PoolTogether/LiquidationPairFactory_Documentation.png)\n\n*   So, if a LiquidationPair is created by the LiquidationPairFactory may allow malicious users to trick users who want to liquidate the Vault's Yield to operate with a LiquidationPair who'll end up stealing their POOL tokens (tokenIn) when swapping tokens.\n\n*   Practical Example of how the LiquidationPair would steal the user's assets, (Keep in mind that `source` is not the address of a Vault, but an arbitrary contract)\n    *   The fake `source` contract would look like this:\n\n```solidity\ncontract FakeSource {\n\n  function targetOf(address _token) external view returns (address) {\n    return <ContractCreatorAddress>;\n  }\n\n  function liquidate(\n    address _account,\n    address _tokenIn,\n    uint256 _amountIn,\n    address _tokenOut,\n    uint256 _amountOut\n  ) public virtual override returns (bool) {\n    return true;\n  }\n\n}\n\n```\n\n1.  Calling [`LiquidationPair.target()`](https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/LiquidationRouter.sol#L71) will return `source.targetOf(tokenIn)`, and the `source` contract can return any address when the `targetOf()` is called, so, let's say that will return the address of its creator.\n\n * So, `LiquidationPair.target()` will return the address of its creator, instead of returning the expected address of the `PrizePool` contract\n\n2.  Calling [`LiquidationPair::swapExactAmount()`](https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/LiquidationRouter.sol#L75) will do some computations prior to call `source.liquidate()`, and the `source.liquidate()` can just return true not to cause the tx to be reverted.\n\n * So, `LiquidationPair::swapExactAmount()` will basically do nothing.\n\n * With the above points in mind, let's see what would be the result of swapping using the LiquidationRouter contract\n\n```solidity\nfunction swapExactAmountOut(\n  LiquidationPair _liquidationPair,\n  address _receiver,\n  uint256 _amountOut,\n  uint256 _amountInMax\n) external onlyTrustedLiquidationPair(_liquidationPair) returns (uint256) {\n\n  //@audit-issue => The `tokenIn` will be transferred to the address of the LiquidationPair's creator instead of the PrizePool contract (Point 1) <====== Point 1 ======>\n  IERC20(_liquidationPair.tokenIn()).safeTransferFrom(\n    msg.sender,\n    _liquidationPair.target(),\n    _liquidationPair.computeExactAmountIn(_amountOut)\n  );\n\n  //@audit-issue => This call will basically do nothing, just return a true not to cause the tx to be reverted (Point 2)  <====== Point 2 ======>\n  uint256 amountIn = _liquidationPair.swapExactAmountOut(_receiver, _amountOut, _amountInMax);\n\n  emit SwappedExactAmountOut(_liquidationPair, _receiver, _amountOut, _amountInMax, amountIn);\n\n  return amountIn;\n}\n```\n\n### Recommended Mitigation Steps\n\n*   Use the `deployedVaults` mapping of the `VaultFactory` contract to validate if the inputted address of the `_source` parameter is a valid vault supported by the Protocol.\n    *   Additionally, it could be a good idea to set the `_tokenIn` and `_tokenOut` by pulling the values that are already set up in the vault.\n\n```solidity\nfunction createPair(\n  ILiquidationSource _source,\n- address _tokenIn,\n- address _tokenOut,\n  uint32 _periodLength,\n  uint32 _periodOffset,\n  uint32 _targetFirstSaleTime,\n  SD59x18 _decayConstant,\n  uint112 _initialAmountIn,\n  uint112 _initialAmountOut,\n  uint256 _minimumAuctionAmount\n) external returns (LiquidationPair) {\n\n+ require(VaultFactory.deployedVaults(address(_source)) == true, \"_source address is not a supported Vault\");\n+ address _prizePool = _source.prizePool();\n+ address _tokenIn = _prizePool.prizeToken();\n+ address _tokenOut = address(_source);\n  \n  LiquidationPair _liquidationPair = new LiquidationPair(\n    _source,\n    _tokenIn,\n    _tokenOut,\n    _periodLength,\n    _periodOffset,\n    _targetFirstSaleTime,\n    _decayConstant,\n    _initialAmountIn,\n    _initialAmountOut,\n    _minimumAuctionAmount\n  );\n\n  allPairs.push(_liquidationPair);\n  deployedPairs[_liquidationPair] = true;\n\n  emit PairCreated(\n    _liquidationPair,\n    _source,\n    _tokenIn,\n    _tokenOut,\n    _periodLength,\n    _periodOffset,\n    _targetFirstSaleTime,\n    _decayConstant,\n    _initialAmountIn,\n    _initialAmountOut,\n    _minimumAuctionAmount\n  );\n\n  return _liquidationPair;\n}\n\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[asselstine (PoolTogether) confirmed and commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/68#issuecomment-1673555674):**\n > This is an interesting report.\n> \n> There are two ways we expect liquidations to occur:\n> \n> - EOAs that interact with the LiquidationRouter. (users, off-chain bots, etc)\n> - Smart Contracts that interact with the LiquidationPair directly\n> \n> Smart contracts that interact with the Pair can easily assert that they received the expected tokens; so a malicious LiquidationSource would not be a problem.\n> \n> However, EOAs that interact with a Pair via the LiquidationRouter would be vulnerable to this kind of attack.\n> \n> This makes me think that the fix is actually to alter the LiquidationRouter so that:\n> \n> 1. In `swapExactAmountOut` the router makes itself the recipient of the tokens.\n> 2. The router asserts that it has received the expected amount of tokens\n> 3. The router transfers to the tokens to the caller.\n> \n> It costs more gas, but this change ensures that anyone who calls the router would receive the expected tokens.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/LiquidationPairFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.19;\n\nimport \"./LiquidationPair.sol\";\n\n/// @title LiquidationPairFactory\n/// @author G9 Software Inc.\n/// @notice Factory contract for deploying LiquidationPair contracts.\ncontract LiquidationPairFactory {\n\n  /* ============ Events ============ */\n\n  /// @notice Emitted when a new LiquidationPair is created\n  /// @param pair The address of the new pair\n  /// @param source The liquidation source that the pair is using\n  /// @param tokenIn The input token for the pair\n  /// @param tokenOut The output token for the pair\n  /// @param periodLength The duration of auctions\n  /// @param periodOffset The start time offset of auctions\n  /// @param targetFirstSaleTime The target time for the first auction\n  /// @param decayConstant The decay constant that the pair is using\n  /// @param initialAmountIn The initial amount of input tokens (used to compute initial exchange rate)\n  /// @param initialAmountOut The initial amount of output tokens (used to compute initial exchange rate)\n  /// @param minimumAuctionAmount The minimum auction size in output tokens\n  event PairCreated(\n    LiquidationPair indexed pair,\n    ILiquidationSource source,\n    address tokenIn,\n    address tokenOut,\n    uint32 periodLength,\n    uint32 periodOffset,\n    uint32 targetFirstSaleTime,\n    SD59x18 decayConstant,\n    uint112 initialAmountIn,\n    uint112 initialAmountOut,\n    uint256 minimumAuctionAmount\n  );\n\n  /* ============ Variables ============ */\n\n  /// @notice Tracks an array of all pairs created by this factory\n  LiquidationPair[] public allPairs;\n\n  /* ============ Mappings ============ */\n\n  /**\n   * @notice Mapping to verify if a LiquidationPair has been deployed via this factory.\n   * @dev LiquidationPair address => boolean\n   */\n  mapping(LiquidationPair => bool) public deployedPairs;\n\n  /// @notice Creates a new LiquidationPair and registers it within the factory\n  /// @param _source The liquidation source that the pair will use\n  /// @param _tokenIn The input token for the pair\n  /// @param _tokenOut The output token for the pair\n  /// @param _periodLength The duration of auctions\n  /// @param _periodOffset The start time offset of auctions\n  /// @param _targetFirstSaleTime The target time for the first auction\n  /// @param _decayConstant The decay constant that the pair will use. This determines how rapidly the price changes.\n  /// @param _initialAmountIn The initial amount of input tokens (used to compute initial exchange rate)\n  /// @param _initialAmountOut The initial amount of output tokens (used to compute initial exchange rate)\n  /// @param _minimumAuctionAmount The minimum auction size in output tokens\n  /// @return The address of the new pair\n  function createPair(\n    ILiquidationSource _source,\n    address _tokenIn,\n    address _tokenOut,\n    uint32 _periodLength,\n    uint32 _periodOffset,\n    uint32 _targetFirstSaleTime,\n    SD59x18 _decayConstant,\n    uint112 _initialAmountIn,\n    uint112 _initialAmountOut,\n    uint256 _minimumAuctionAmount\n  ) external returns (LiquidationPair) {\n    LiquidationPair _liquidationPair = new LiquidationPair(\n      _source,\n      _tokenIn,\n      _tokenOut,\n      _periodLength,\n      _periodOffset,\n      _targetFirstSaleTime,\n      _decayConstant,\n      _initialAmountIn,\n      _initialAmountOut,\n      _minimumAuctionAmount\n    );\n\n    allPairs.push(_liquidationPair);\n    deployedPairs[_liquidationPair] = true;\n\n    emit PairCreated(\n      _liquidationPair,\n      _source,\n      _tokenIn,\n      _tokenOut,\n      _periodLength,\n      _periodOffset,\n      _targetFirstSaleTime,\n      _decayConstant,\n      _initialAmountIn,\n      _initialAmountOut,\n      _minimumAuctionAmount\n    );\n\n    return _liquidationPair;\n  }\n\n  /**\n   * @notice Total number of LiquidationPair deployed by this factory.\n   * @return Number of LiquidationPair deployed by this factory.\n   */\n  function totalPairs() external view returns (uint256) {\n    return allPairs.length;\n  }\n}"
    },
    {
      "filename": "src/LiquidationRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport \"openzeppelin/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport { LiquidationPair } from \"./LiquidationPair.sol\";\nimport { LiquidationPairFactory } from \"./LiquidationPairFactory.sol\";\n\nerror UndefinedLiquidationPairFactory();\nerror UnknownLiquidationPair(LiquidationPair liquidationPair);\n\n/// @title LiquidationRouter\n/// @author G9 Software Inc.\n/// @notice Serves as the user-facing swapping interface for Liquidation Pairs.\ncontract LiquidationRouter {\n  using SafeERC20 for IERC20;\n\n  /* ============ Events ============ */\n\n  /// @notice Emitted when the router is created\n  event LiquidationRouterCreated(LiquidationPairFactory indexed liquidationPairFactory);\n\n  /// @notice Emitted after a swap occurs\n  /// @param liquidationPair The pair that was swapped against\n  /// @param receiver The address that received the output tokens\n  /// @param amountOut The amount of output tokens received\n  /// @param amountInMax The maximum amount of input tokens that could have been used\n  /// @param amountIn The amount of input tokens that were actually used\n  event SwappedExactAmountOut(\n    LiquidationPair indexed liquidationPair,\n    address indexed receiver,\n    uint256 amountOut,\n    uint256 amountInMax,\n    uint256 amountIn\n  );\n\n  /* ============ Variables ============ */\n\n  /// @notice The LiquidationPairFactory that this router uses.\n  /// @dev LiquidationPairs will be checked to ensure they were created by the factory\n  LiquidationPairFactory internal immutable _liquidationPairFactory;\n\n  /// @notice Constructs a new LiquidationRouter\n  /// @param liquidationPairFactory_ The factory that pairs will be verified to have been created by\n  constructor(LiquidationPairFactory liquidationPairFactory_) {\n    if(address(liquidationPairFactory_) == address(0)) {\n      revert UndefinedLiquidationPairFactory();\n    }\n    _liquidationPairFactory = liquidationPairFactory_;\n\n    emit LiquidationRouterCreated(liquidationPairFactory_);\n  }\n\n  /* ============ External Methods ============ */\n\n  /// @notice Swaps the given amount of output tokens for at most input tokens\n  /// @param _liquidationPair The pair to swap against\n  /// @param _receiver The account to receive the output tokens\n  /// @param _amountOut The exactly amount of output tokens expected\n  /// @param _amountInMax The maximum of input tokens to spend\n  /// @return The actual number of input tokens used\n  function swapExactAmountOut(\n    LiquidationPair _liquidationPair,\n    address _receiver,\n    uint256 _amountOut,\n    uint256 _amountInMax\n  ) external onlyTrustedLiquidationPair(_liquidationPair) returns (uint256) {\n    IERC20(_liquidationPair.tokenIn()).safeTransferFrom(\n      msg.sender,\n      _liquidationPair.target(),\n      _liquidationPair.computeExactAmountIn(_amountOut)\n    );\n\n    uint256 amountIn = _liquidationPair.swapExactAmountOut(_receiver, _amountOut, _amountInMax);\n\n    emit SwappedExactAmountOut(_liquidationPair, _receiver, _amountOut, _amountInMax, amountIn);\n\n    return amountIn;\n  }\n\n  /// @notice Checks that the given pair was created by the factory\n  /// @param _liquidationPair The pair to check\n  modifier onlyTrustedLiquidationPair(LiquidationPair _liquidationPair) {\n    if (!_liquidationPairFactory.deployedPairs(_liquidationPair)) {\n      revert UnknownLiquidationPair(_liquidationPair);\n    }\n    _;\n  }\n}"
    },
    {
      "filename": "src/LiquidationRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport \"openzeppelin/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport { LiquidationPair } from \"./LiquidationPair.sol\";\nimport { LiquidationPairFactory } from \"./LiquidationPairFactory.sol\";\n\nerror UndefinedLiquidationPairFactory();\nerror UnknownLiquidationPair(LiquidationPair liquidationPair);\n\n/// @title LiquidationRouter\n/// @author G9 Software Inc.\n/// @notice Serves as the user-facing swapping interface for Liquidation Pairs.\ncontract LiquidationRouter {\n  using SafeERC20 for IERC20;\n\n  /* ============ Events ============ */\n\n  /// @notice Emitted when the router is created\n  event LiquidationRouterCreated(LiquidationPairFactory indexed liquidationPairFactory);\n\n  /// @notice Emitted after a swap occurs\n  /// @param liquidationPair The pair that was swapped against\n  /// @param receiver The address that received the output tokens\n  /// @param amountOut The amount of output tokens received\n  /// @param amountInMax The maximum amount of input tokens that could have been used\n  /// @param amountIn The amount of input tokens that were actually used\n  event SwappedExactAmountOut(\n    LiquidationPair indexed liquidationPair,\n    address indexed receiver,\n    uint256 amountOut,\n    uint256 amountInMax,\n    uint256 amountIn\n  );\n\n  /* ============ Variables ============ */\n\n  /// @notice The LiquidationPairFactory that this router uses.\n  /// @dev LiquidationPairs will be checked to ensure they were created by the factory\n  LiquidationPairFactory internal immutable _liquidationPairFactory;\n\n  /// @notice Constructs a new LiquidationRouter\n  /// @param liquidationPairFactory_ The factory that pairs will be verified to have been created by\n  constructor(LiquidationPairFactory liquidationPairFactory_) {\n    if(address(liquidationPairFactory_) == address(0)) {\n      revert UndefinedLiquidationPairFactory();\n    }\n    _liquidationPairFactory = liquidationPairFactory_;\n\n    emit LiquidationRouterCreated(liquidationPairFactory_);\n  }\n\n  /* ============ External Methods ============ */\n\n  /// @notice Swaps the given amount of output tokens for at most input tokens\n  /// @param _liquidationPair The pair to swap against\n  /// @param _receiver The account to receive the output tokens\n  /// @param _amountOut The exactly amount of output tokens expected\n  /// @param _amountInMax The maximum of input tokens to spend\n  /// @return The actual number of input tokens used\n  function swapExactAmountOut(\n    LiquidationPair _liquidationPair,\n    address _receiver,\n    uint256 _amountOut,\n    uint256 _amountInMax\n  ) external onlyTrustedLiquidationPair(_liquidationPair) returns (uint256) {\n    IERC20(_liquidationPair.tokenIn()).safeTransferFrom(\n      msg.sender,\n      _liquidationPair.target(),\n      _liquidationPair.computeExactAmountIn(_amountOut)\n    );\n\n    uint256 amountIn = _liquidationPair.swapExactAmountOut(_receiver, _amountOut, _amountInMax);\n\n    emit SwappedExactAmountOut(_liquidationPair, _receiver, _amountOut, _amountInMax, amountIn);\n\n    return amountIn;\n  }\n\n  /// @notice Checks that the given pair was created by the factory\n  /// @param _liquidationPair The pair to check\n  modifier onlyTrustedLiquidationPair(LiquidationPair _liquidationPair) {\n    if (!_liquidationPairFactory.deployedPairs(_liquidationPair)) {\n      revert UnknownLiquidationPair(_liquidationPair);\n    }\n    _;\n  }\n}"
    }
  ]
}