{
  "Title": "[M01] Capturing the award balance may fail",
  "Content": "The [`captureAwardBalance` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L461) of the `PrizePool` contract relies on the [underlying asset balance](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L463) to calculate any available interest as award balance. Given that the way of calculating this balance may differ on each yield source, there is a possiblity that the [calculated `totalInterest`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L464) may be greater than the `_currentAwardBalance` accumulated. For instance, the [`balanceOfUnderlying`](https://github.com/compound-finance/compound-protocol/blob/23eac9425accafb82551777c93896ee7678a85a3/contracts/CToken.sol#L190) function in the Compound’s `CToken` contract [truncates the returned result](https://github.com/compound-finance/compound-protocol/blob/23eac9425accafb82551777c93896ee7678a85a3/contracts/CToken.sol#L192), which could lead into [an underflow when calculating the unnacounted prize balance](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L465) in extreme cases, and therefore stall the function for future calls.\n\n\nEven though this might not occur in the system as it is, this may change in future versions of the protocol when introducing new yield sources.\n\n\nConsider checking that the [`totalInterest`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L464) value calculated using the underlying asset’s balance is greater than the accumulated `_currentAwardBalance`.\n\n\n***Update:** Fixed in [pull request #205](https://github.com/pooltogether/pooltogether-pool-contracts/pull/205). The `captureAwardBalance` function now checks that the `totalInterest` value is greater than the `_currentAwardBalance` value to avoid the subtraction underflow.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/prize-pool/PrizePool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../external/pooltogether/FixedPoint.sol\";\nimport \"../comptroller/ComptrollerInterface.sol\";\nimport \"./YieldSource.sol\";\nimport \"../token/ControlledToken.sol\";\nimport \"../token/TokenControllerInterface.sol\";\nimport \"../utils/MappedSinglyLinkedList.sol\";\nimport \"../utils/RelayRecipient.sol\";\n\n/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.\n/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.\n/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens\nabstract contract PrizePool is YieldSource, OwnableUpgradeSafe, RelayRecipient, ReentrancyGuardUpgradeSafe, TokenControllerInterface {\n  using SafeMath for uint256;\n  using SafeCast for uint256;\n  using SafeERC20 for IERC20;\n  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;\n\n  /// @dev Emitted when an instance is initialized\n  event Initialized(\n    address trustedForwarder,\n    address comptroller,\n    uint256 maxExitFeeMantissa,\n    uint256 maxTimelockDuration\n  );\n\n  /// @dev Event emitted when controlled token is added\n  event ControlledTokenAdded(\n    address indexed token\n  );\n\n  /// @dev Set when the comptroller changes the type of reserve token\n  event ReserveFeeControlledTokenSet(\n    address indexed token\n  );\n\n  /// @dev Emitted when reserve is captured.\n  event ReserveFeeCaptured(\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when assets are deposited\n  event Deposited(\n    address indexed operator,\n    address indexed to,\n    address indexed token,\n    uint256 amount,\n    address referrer\n  );\n\n  /// @dev Event emitted when timelocked funds are re-deposited\n  event TimelockDeposited(\n    address indexed operator,\n    address indexed to,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when interest is awarded to a winner\n  event Awarded(\n    address indexed winner,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when external ERC20s are awarded to a winner\n  event AwardedExternalERC20(\n    address indexed winner,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when external ERC721s are awarded to a winner\n  event AwardedExternalERC721(\n    address indexed winner,\n    address indexed token,\n    uint256[] tokenIds\n  );\n\n  /// @dev Event emitted when assets are withdrawn instantly\n  event InstantWithdrawal(\n    address indexed operator,\n    address indexed from,\n    address indexed token,\n    uint256 amount,\n    uint256 redeemed,\n    uint256 exitFee\n  );\n\n  /// @dev Event emitted upon a withdrawal with timelock\n  event TimelockedWithdrawal(\n    address indexed operator,\n    address indexed from,\n    address indexed token,\n    uint256 amount,\n    uint256 unlockTimestamp\n  );\n\n  /// @dev Event emitted when timelocked funds are swept back to a user\n  event TimelockedWithdrawalSwept(\n    address indexed operator,\n    address indexed from,\n    uint256 amount,\n    uint256 redeemed\n  );\n\n  /// @dev Event emitted when the Liquidity Cap is set\n  event LiquidityCapSet(\n    uint256 liquidityCap\n  );\n\n  /// @dev Event emitted when the Credit plan is set\n  event CreditPlanSet(\n    address token,\n    uint128 creditLimitMantissa,\n    uint128 creditRateMantissa\n  );\n\n  /// @dev Event emitted when the Prize Strategy is set\n  event PrizeStrategySet(\n    address indexed prizeStrategy\n  );\n\n  /// @dev Emitted when credit is minted\n  event CreditMinted(\n    address indexed user,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Emitted when credit is burned\n  event CreditBurned(\n    address indexed user,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when the prize pool enters emergency shutdown mode\n  event EmergencyShutdown();\n\n  struct CreditPlan {\n    uint128 creditLimitMantissa;\n    uint128 creditRateMantissa;\n  }\n\n  struct CreditBalance {\n    uint192 balance;\n    uint32 timestamp;\n    bool initialized;\n  }\n\n  /// @dev Comptroller to which reserve fees are sent\n  ComptrollerInterface public comptroller;\n\n  /// @dev Controlled token to serve as the reserve fee\n  address public reserveFeeControlledToken;\n\n  /// @dev A linked list of all the controlled tokens\n  MappedSinglyLinkedList.Mapping internal _tokens;\n\n  /// @dev The Prize Strategy that this Prize Pool is bound to.\n  PrizePoolTokenListenerInterface public prizeStrategy;\n\n  /// @dev The maximum possible exit fee fraction as a fixed point 18 number.\n  /// For example, if the maxExitFeeMantissa is \"0.1 ether\", then the maximum exit fee for a withdrawal of 100 Dai will be 10 Dai\n  uint256 public maxExitFeeMantissa;\n\n  /// @dev The maximum possible timelock duration for a timelocked withdrawal (in seconds).\n  uint256 public maxTimelockDuration;\n\n  /// @dev The total funds that are timelocked.\n  uint256 public timelockTotalSupply;\n\n  /// @dev The total amount of funds that the prize pool can hold.\n  uint256 public liquidityCap;\n\n  /// @dev the The awardable balance\n  uint256 internal _currentAwardBalance;\n\n  /// @dev The timelocked balances for each user\n  mapping(address => uint256) internal _timelockBalances;\n\n  /// @dev The unlock timestamps for each user\n  mapping(address => uint256) internal _unlockTimestamps;\n\n  /// @dev Stores the credit plan for each token.\n  mapping(address => CreditPlan) internal tokenCreditPlans;\n\n  /// @dev Stores each users balance of credit per token.\n  mapping(address => mapping(address => CreditBalance)) internal tokenCreditBalances;\n\n  /// @notice Initializes the Prize Pool\n  /// @param _trustedForwarder Address of the Forwarding Contract for GSN Meta-Txs\n  /// @param _prizeStrategy Address of the prize strategy\n  /// @param _controlledTokens Array of ControlledTokens that are controlled by this Prize Pool.\n  /// @param _maxExitFeeMantissa The maximum exit fee size\n  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock\n  function initialize (\n    address _trustedForwarder,\n    PrizePoolTokenListenerInterface _prizeStrategy,\n    ComptrollerInterface _comptroller,\n    address[] memory _controlledTokens,\n    uint256 _maxExitFeeMantissa,\n    uint256 _maxTimelockDuration\n  )\n    public\n    initializer\n  {\n    require(address(_comptroller) != address(0), \"PrizePool/comptroller-not-zero\");\n    require(_trustedForwarder != address(0), \"PrizePool/forwarder-not-zero\");\n    _setPrizeStrategy(address(_prizeStrategy));\n    _tokens.initialize();\n    for (uint256 i = 0; i < _controlledTokens.length; i++) {\n      _addControlledToken(_controlledTokens[i]);\n    }\n    __Ownable_init();\n    __ReentrancyGuard_init();\n    _setLiquidityCap(uint256(-1));\n\n    trustedForwarder = _trustedForwarder;\n    comptroller = _comptroller;\n    maxExitFeeMantissa = _maxExitFeeMantissa;\n    maxTimelockDuration = _maxTimelockDuration;\n\n    emit Initialized(\n      _trustedForwarder,\n      address(_comptroller),\n      maxExitFeeMantissa,\n      maxTimelockDuration\n    );\n  }\n\n  /// @dev Returns the address of the underlying ERC20 asset\n  /// @return The address of the asset\n  function token() external view returns (IERC20) {\n    return _token();\n  }\n\n  /// @dev Returns the total underlying balance of all assets. This includes both principal and interest.\n  /// @return The underlying balance of assets\n  function balance() external returns (uint256) {\n    return _balance();\n  }\n\n  /// @dev Checks with the Prize Pool if a specific token type may be awarded as an external prize\n  /// @param _externalToken The address of the token to check\n  /// @return True if the token may be awarded, false otherwise\n  function canAwardExternal(address _externalToken) external view returns (bool) {\n    return _canAwardExternal(_externalToken);\n  }\n\n  /// @dev Sets which controlled token will be minted as the reserve fee.  Only callable by the owner.\n  /// @param controlledToken The controlled token to mint.  This must be controlled by the PrizePool.\n  function setReserveFeeControlledToken(address controlledToken) external onlyControlledToken(controlledToken) onlyOwner {\n    reserveFeeControlledToken = controlledToken;\n\n    emit ReserveFeeControlledTokenSet(controlledToken);\n  }\n\n  /// @notice Deposits timelocked tokens for a user back into the Prize Pool as another asset.\n  /// @param to The address receiving the tokens\n  /// @param amount The amount of timelocked assets to re-deposit\n  /// @param controlledToken The type of token to be minted in exchange (i.e. tickets or sponsorship)\n  function timelockDepositTo(\n    address to,\n    uint256 amount,\n    address controlledToken\n  )\n    external\n    onlyControlledToken(controlledToken)\n    canAddLiquidity(amount)\n    notShutdown\n    nonReentrant\n  {\n    address operator = _msgSender();\n    _mint(to, amount, controlledToken, address(0));\n    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);\n    timelockTotalSupply = timelockTotalSupply.sub(amount);\n\n    emit TimelockDeposited(operator, to, controlledToken, amount);\n  }\n\n  /// @notice Deposit assets into the Prize Pool in exchange for tokens\n  /// @param to The address receiving the newly minted tokens\n  /// @param amount The amount of assets to deposit\n  /// @param controlledToken The address of the type of token the user is minting\n  /// @param referrer The referrer of the deposit\n  function depositTo(\n    address to,\n    uint256 amount,\n    address controlledToken,\n    address referrer\n  )\n    external\n    onlyControlledToken(controlledToken)\n    canAddLiquidity(amount)\n    notShutdown\n    nonReentrant\n  {\n    address operator = _msgSender();\n\n    _mint(to, amount, controlledToken, referrer);\n\n    _token().safeTransferFrom(operator, address(this), amount);\n    _supply(amount);\n\n    emit Deposited(operator, to, controlledToken, amount, referrer);\n  }\n\n  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.\n  /// @param from The address to redeem tokens from.\n  /// @param amount The amount of tokens to redeem for assets.\n  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)\n  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.\n  /// @return The actual exit fee paid\n  function withdrawInstantlyFrom(\n    address from,\n    uint256 amount,\n    address controlledToken,\n    uint256 maximumExitFee\n  )\n    external\n    nonReentrant\n    onlyControlledToken(controlledToken)\n    returns (uint256)\n  {\n    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);\n    require(exitFee <= maximumExitFee, \"PrizePool/exit-fee-exceeds-user-maximum\");\n\n    // burn the credit\n    _burnCredit(from, controlledToken, burnedCredit);\n\n    // burn the tickets\n    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);\n\n    // redeem the tickets less the fee\n    uint256 amountLessFee = amount.sub(exitFee);\n    uint256 redeemed = _redeem(amountLessFee);\n\n    _token().safeTransfer(from, redeemed);\n\n    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);\n\n    return exitFee;\n  }\n\n  /// @notice Limits the exit fee to the maximum as hard-coded into the contract\n  /// @param withdrawalAmount The amount that is attempting to be withdrawn\n  /// @param exitFee The exit fee to check against the limit\n  /// @return The passed exit fee if it is less than the maximum, otherwise the maximum fee is returned.\n  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {\n    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);\n    if (exitFee > maxFee) {\n      exitFee = maxFee;\n    }\n    return exitFee;\n  }\n\n  /// @notice Withdraw assets from the Prize Pool by placing them into the timelock.\n  /// The timelock is used to ensure that the tickets have contributed their fair share of the prize.\n  /// @dev Note that if the user has previously timelocked funds then this contract will try to sweep them.\n  /// If the existing timelocked funds are still locked, then the incoming\n  /// balance is added to their existing balance and the new timelock unlock timestamp will overwrite the old one.\n  /// @param from The address to withdraw from\n  /// @param amount The amount to withdraw\n  /// @param controlledToken The type of token being withdrawn\n  /// @return The timestamp from which the funds can be swept\n  function withdrawWithTimelockFrom(\n    address from,\n    uint256 amount,\n    address controlledToken\n  )\n    external\n    nonReentrant\n    onlyControlledToken(controlledToken)\n    returns (uint256)\n  {\n    uint256 blockTime = _currentTime();\n    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);\n    uint256 unlockTimestamp = blockTime.add(lockDuration);\n    _burnCredit(from, controlledToken, burnedCredit);\n    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);\n    _mintTimelock(from, amount, unlockTimestamp);\n    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);\n\n    // return the block at which the funds will be available\n    return unlockTimestamp;\n  }\n\n  /// @notice Adds to a user's timelock balance.  It will attempt to sweep before updating the balance.\n  /// Note that this will overwrite the previous unlock timestamp.\n  /// @param user The user whose timelock balance should increase\n  /// @param amount The amount to increase by\n  /// @param timestamp The new unlock timestamp\n  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {\n    // Sweep the old balance, if any\n    address[] memory users = new address[](1);\n    users[0] = user;\n    _sweepTimelockBalances(users);\n\n    timelockTotalSupply = timelockTotalSupply.add(amount);\n    _timelockBalances[user] = _timelockBalances[user].add(amount);\n    _unlockTimestamps[user] = timestamp;\n\n    // if the funds should already be unlocked\n    if (timestamp <= _currentTime()) {\n      _sweepTimelockBalances(users);\n    }\n  }\n\n  /// @notice Updates the Prize Strategy when tokens are transferred between holders.\n  /// @param from The address the tokens are being transferred from (0 if minting)\n  /// @param to The address the tokens are being transferred to (0 if burning)\n  /// @param amount The amount of tokens being trasferred\n  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {\n    if (from != address(0)) {\n      uint256 fromBeforeBalance = IERC20(msg.sender).balanceOf(from);\n      // first accrue credit for their old balance\n      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);\n      // now limit their credit based on the new balance\n      newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);\n      _updateCreditBalance(from, msg.sender, newCreditBalance);\n    }\n    if (to != address(0)) {\n      _accrueCredit(to, msg.sender, IERC20(msg.sender).balanceOf(to), 0);\n    }\n    // if we aren't minting\n    if (from != address(0)) {\n      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);\n      if (address(comptroller) != address(0)) {\n        comptroller.beforeTokenTransfer(\n          from,\n          to,\n          amount,\n          msg.sender\n        );\n      }\n    }\n  }\n\n  /// @notice Returns the balance that is available to award.\n  /// @dev captureAwardBalance() should be called first\n  /// @return The total amount of assets to be awarded for the current prize\n  function awardBalance() external view returns (uint256) {\n    return _currentAwardBalance;\n  }\n\n  /// @notice Captures any available interest as award balance.\n  /// @dev This function also captures the reserve fees.\n  /// @return The total amount of assets to be awarded for the current prize\n  function captureAwardBalance() external nonReentrant returns (uint256) {\n    uint256 tokenTotalSupply = _tokenTotalSupply();\n    uint256 currentBalance = _balance();\n    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;\n    uint256 unaccountedPrizeBalance = totalInterest.sub(_currentAwardBalance);\n\n    if (unaccountedPrizeBalance > 0) {\n      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);\n      if (reserveFee > 0) {\n        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);\n        _mint(address(comptroller), reserveFee, reserveFeeControlledToken, address(0));\n        emit ReserveFeeCaptured(reserveFeeControlledToken, reserveFee);\n      }\n    }\n\n    _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);\n\n    return _currentAwardBalance;\n  }\n\n  /// @notice Called by the prize strategy to award prizes.\n  /// @dev The amount awarded must be less than the awardBalance()\n  /// @param to The address of the winner that receives the award\n  /// @param amount The amount of assets to be awarded\n  /// @param controlledToken The address of the asset token being awarded\n  function award(\n    address to,\n    uint256 amount,\n    address controlledToken\n  )\n    external\n    onlyPrizeStrategy\n    onlyControlledToken(controlledToken)\n  {\n    if (amount == 0) {\n      return;\n    }\n\n    require(amount <= _currentAwardBalance, \"PrizePool/award-exceeds-avail\");\n    _currentAwardBalance = _currentAwardBalance.sub(amount);\n\n    _mint(to, amount, controlledToken, address(0));\n\n    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);\n    _accrueCredit(to, controlledToken, IERC20(controlledToken).balanceOf(to), extraCredit);\n\n    emit Awarded(to, controlledToken, amount);\n  }\n\n  /// @notice Called by the Prize-Strategy to award external ERC20 prizes\n  /// @dev Used to award any arbitrary tokens held by the Prize Pool\n  /// @param to The address of the winner that receives the award\n  /// @param amount The amount of external assets to be awarded\n  /// @param externalToken The address of the external asset token being awarded\n  function awardExternalERC20(\n    address to,\n    address externalToken,\n    uint256 amount\n  )\n    external\n    onlyPrizeStrategy\n  {\n    require(_canAwardExternal(externalToken), \"PrizePool/invalid-external-token\");\n\n    if (amount == 0) {\n      return;\n    }\n\n    IERC20(externalToken).safeTransfer(to, amount);\n\n    emit AwardedExternalERC20(to, externalToken, amount);\n  }\n\n  /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.\n  /// @param to The user who is receiving the tokens\n  /// @param amount The amount of tokens they are receiving\n  /// @param controlledToken The token that is going to be minted\n  /// @param referrer The user who referred the minting\n  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {\n    prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);\n    if (address(comptroller) != address(0)) {\n      comptroller.beforeTokenMint(\n        to,\n        amount,\n        controlledToken,\n        referrer\n      );\n    }\n    ControlledToken(controlledToken).controllerMint(to, amount);\n  }\n\n  /// @notice Called by the prize strategy to award external ERC721 prizes\n  /// @dev Used to award any arbitrary NFTs held by the Prize Pool\n  /// @param to The address of the winner that receives the award\n  /// @param externalToken The address of the external NFT token being awarded\n  /// @param tokenIds An array of NFT Token IDs to be transferred\n  function awardExternalERC721(\n    address to,\n    address externalToken,\n    uint256[] calldata tokenIds\n  )\n    external\n    onlyPrizeStrategy\n  {\n    require(_canAwardExternal(externalToken), \"PrizePool/invalid-external-token\");\n\n    if (tokenIds.length == 0) {\n      return;\n    }\n\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      IERC721(externalToken).transferFrom(address(this), to, tokenIds[i]);\n    }\n\n    emit AwardedExternalERC721(to, externalToken, tokenIds);\n  }\n\n  /// @notice Calculates the reserve portion of the given amount of funds.  If there is no reserve address, the portion will be zero.\n  /// @param amount The prize amount\n  /// @return The size of the reserve portion of the prize\n  function calculateReserveFee(uint256 amount) public view returns (uint256) {\n    if (address(comptroller) == address(0)) {\n      return 0;\n    }\n    uint256 reserveRateMantissa = comptroller.reserveRateMantissa();\n    if (reserveRateMantissa == 0 || reserveFeeControlledToken == address(0)) {\n      return 0;\n    }\n    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);\n  }\n\n  /// @notice Sweep all timelocked balances and transfer unlocked assets to owner accounts\n  /// @param users An array of account addresses to sweep balances for\n  /// @return The total amount of assets swept from the Prize Pool\n  function sweepTimelockBalances(\n    address[] calldata users\n  )\n    external\n    nonReentrant\n    returns (uint256)\n  {\n    return _sweepTimelockBalances(users);\n  }\n\n  /// @notice Sweep available timelocked balances to their owners.  The full balances will be swept to the owners.\n  /// @param users An array of owner addresses\n  /// @return The total amount of assets swept from the Prize Pool\n  function _sweepTimelockBalances(\n    address[] memory users\n  )\n    internal\n    returns (uint256)\n  {\n    address operator = _msgSender();\n\n    uint256[] memory balances = new uint256[](users.length);\n\n    uint256 totalWithdrawal;\n\n    uint256 i;\n    for (i = 0; i < users.length; i++) {\n      address user = users[i];\n      if (_unlockTimestamps[user] <= _currentTime()) {\n        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);\n        balances[i] = _timelockBalances[user];\n        delete _timelockBalances[user];\n      }\n    }\n\n    // if there is nothing to do, just quit\n    if (totalWithdrawal == 0) {\n      return 0;\n    }\n\n    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);\n\n    uint256 redeemed = _redeem(totalWithdrawal);\n\n    IERC20 underlyingToken = IERC20(_token());\n\n    for (i = 0; i < users.length; i++) {\n      if (balances[i] > 0) {\n        delete _unlockTimestamps[users[i]];\n        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);\n        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);\n        underlyingToken.safeTransfer(users[i], transferAmount);\n        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);\n      }\n    }\n\n    return totalWithdrawal;\n  }\n\n  /// @notice Calculates a timelocked withdrawal duration and credit consumption.\n  /// @param from The user who is withdrawing\n  /// @param amount The amount the user is withdrawing\n  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)\n  /// @return durationSeconds The duration of the timelock in seconds\n  function calculateTimelockDuration(\n    address from,\n    address controlledToken,\n    uint256 amount\n  )\n    external\n    returns (\n      uint256 durationSeconds,\n      uint256 burnedCredit\n    )\n  {\n    return _calculateTimelockDuration(from, controlledToken, amount);\n  }\n\n  /// @dev Calculates a timelocked withdrawal duration and credit consumption.\n  /// @param from The user who is withdrawing\n  /// @param amount The amount the user is withdrawing\n  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)\n  /// @return durationSeconds The duration of the timelock in seconds\n  /// @return burnedCredit The credit that was burned\n  function _calculateTimelockDuration(\n    address from,\n    address controlledToken,\n    uint256 amount\n  )\n    internal\n    returns (\n      uint256 durationSeconds,\n      uint256 burnedCredit\n    )\n  {\n    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);\n    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);\n    if (duration > maxTimelockDuration) {\n      duration = maxTimelockDuration;\n    }\n    return (duration, _burnedCredit);\n  }\n\n  /// @notice Calculates the early exit fee for the given amount\n  /// @param from The user who is withdrawing\n  /// @param controlledToken The type of collateral being withdrawn\n  /// @param amount The amount of collateral to be withdrawn\n  /// @return exitFee The exit fee\n  /// @return burnedCredit The user's credit that was burned\n  function calculateEarlyExitFee(\n    address from,\n    address controlledToken,\n    uint256 amount\n  )\n    external\n    returns (\n      uint256 exitFee,\n      uint256 burnedCredit\n    )\n  {\n    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);\n  }\n\n  /// @dev Calculates the early exit fee for the given amount\n  /// @param amount The amount of collateral to be withdrawn\n  /// @return Exit fee\n  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {\n    return _limitExitFee(\n      amount,\n      FixedPoint.multiplyUintByMantissa(amount, tokenCreditPlans[controlledToken].creditLimitMantissa)\n    );\n  }\n\n  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit.\n  /// @param _principal The principal amount on which interest is accruing\n  /// @param _interest The amount of interest that must accrue\n  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.\n  function estimateCreditAccrualTime(\n    address _controlledToken,\n    uint256 _principal,\n    uint256 _interest\n  )\n    external\n    view\n    returns (uint256 durationSeconds)\n  {\n    return _estimateCreditAccrualTime(\n      _controlledToken,\n      _principal,\n      _interest\n    );\n  }\n\n  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit\n  /// @param _principal The principal amount on which interest is accruing\n  /// @param _interest The amount of interest that must accrue\n  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.\n  function _estimateCreditAccrualTime(\n    address _controlledToken,\n    uint256 _principal,\n    uint256 _interest\n  )\n    internal\n    view\n    returns (uint256 durationSeconds)\n  {\n    // interest = credit rate * principal * time\n    // => time = interest / (credit rate * principal)\n    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, tokenCreditPlans[_controlledToken].creditRateMantissa);\n    if (accruedPerSecond == 0) {\n      return 0;\n    }\n    return _interest.div(accruedPerSecond);\n  }\n\n  /// @notice Burns a users credit.\n  /// @param user The user whose credit should be burned\n  /// @param credit The amount of credit to burn\n  function _burnCredit(address user, address controlledToken, uint256 credit) internal {\n    tokenCreditBalances[controlledToken][user].balance = uint256(tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();\n\n    emit CreditBurned(user, controlledToken, credit);\n  }\n\n  /// @notice Accrues ticket credit for a user assuming their current balance is the passed balance.  May burn credit if they exceed their limit.\n  /// @param user The user for whom to accrue credit\n  /// @param controlledToken The controlled token whose balance we are checking\n  /// @param controlledTokenBalance The balance to use for the user\n  /// @param extra Additional credit to be added\n  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {\n    _updateCreditBalance(\n      user,\n      controlledToken,\n      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)\n    );\n  }\n\n  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {\n    uint256 newBalance;\n    CreditBalance storage creditBalance = tokenCreditBalances[controlledToken][user];\n    if (!creditBalance.initialized) {\n      newBalance = 0;\n    } else {\n      uint256 credit = calculateAccruedCredit(user, controlledToken, controlledTokenBalance);\n      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));\n    }\n    return newBalance;\n  }\n\n  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {\n    uint256 oldBalance = tokenCreditBalances[controlledToken][user].balance;\n\n    tokenCreditBalances[controlledToken][user] = CreditBalance({\n      balance: newBalance.toUint128(),\n      timestamp: _currentTime().toUint32(),\n      initialized: true\n    });\n\n    if (oldBalance < newBalance) {\n      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));\n    } else {\n      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));\n    }\n  }\n\n  /// @notice Applies the credit limit to a credit balance.  The balance cannot exceed the credit limit.\n  /// @param controlledToken The controlled token that the user holds\n  /// @param controlledTokenBalance The users ticket balance (used to calculate credit limit)\n  /// @param creditBalance The new credit balance to be checked\n  /// @return The users new credit balance.  Will not exceed the credit limit.\n  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {\n    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(\n      controlledTokenBalance,\n      tokenCreditPlans[controlledToken].creditLimitMantissa\n    );\n    if (creditBalance > creditLimit) {\n      creditBalance = creditLimit;\n    }\n\n    return creditBalance;\n  }\n\n  /// @notice Calculates the accrued interest for a user\n  /// @param user The user whose credit should be calculated.\n  /// @param controlledToken The controlled token that the user holds\n  /// @param controlledTokenBalance The user's current balance of the controlled tokens.\n  /// @return The credit that has accrued since the last credit update.\n  function calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {\n    uint256 userTimestamp = tokenCreditBalances[controlledToken][user].timestamp;\n\n    if (!tokenCreditBalances[controlledToken][user].initialized) {\n      return 0;\n    }\n\n    uint256 deltaTime = _currentTime().sub(userTimestamp);\n    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, tokenCreditPlans[controlledToken].creditRateMantissa);\n    return deltaTime.mul(creditPerSecond);\n  }\n\n  /// @notice Returns the credit balance for a given user.  Not that this includes both minted credit and pending credit.\n  /// @param user The user whose credit balance should be returned\n  /// @return The balance of the users credit\n  function balanceOfCredit(address user, address controlledToken) external onlyControlledToken(controlledToken) returns (uint256) {\n    _accrueCredit(user, controlledToken, IERC20(controlledToken).balanceOf(user), 0);\n    return tokenCreditBalances[controlledToken][user].balance;\n  }\n\n  /// @notice Sets the rate at which credit accrues per second.  The credit rate is a fixed point 18 number (like Ether).\n  /// @param _controlledToken The controlled token for whom to set the credit plan\n  /// @param _creditRateMantissa The credit rate to set.  Is a fixed point 18 decimal (like Ether).\n  /// @param _creditLimitMantissa The credit limit to set.  Is a fixed point 18 decimal (like Ether).\n  function setCreditPlanOf(\n    address _controlledToken,\n    uint128 _creditRateMantissa,\n    uint128 _creditLimitMantissa\n  )\n    external\n    onlyControlledToken(_controlledToken)\n    onlyOwner\n  {\n    tokenCreditPlans[_controlledToke"
    }
  ]
}