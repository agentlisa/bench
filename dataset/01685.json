{
  "Title": "Code Simplifications",
  "Content": "A number of opportunities for simplification of code were observed. Consider applying the following code simplifications:\n\n\n* Contracts [`GaugeV2`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeV2.sol) and [`GaugeV2_CL`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeV2_CL.sol) can be refactored so that a base contract contains the shared logic.\n* [Line 123](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L123) of the `GaugeExtraRewarder` contract can be simplified as the first condition is already covered by the second.\n* The functions [`balanceOfAt`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L98), [`balanceOf`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L105), [`balanceOfOwner`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L112), and [`balanceOfOwnerAt`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L118) can be refactored to consolidate shared logic.\n* The functions [`getReward`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeV2.sol#L284) and [`getReward`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeV2.sol#L298) in the `GaugeV2` contract can be refactored to consolidate shared logic.\n* The functions [`earned`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L124), [`earned`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L153), and [`earnedWithTimestamp`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L181) in the `Bribes` contract can be refactored to consolidate shared logic.\n* The functions [`getReward`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#LL269C14-L269C23), [`getReward`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L287), [`getRewardForOwner`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L304), and [`getRewardForAddress`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L322) in the `Bribes` contract can be refactored to consolidate shared logic.\n* In the [`_vote`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L418-L457) function of the `VoterV3` contract, the [`_usedWeight`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L424) variable contains the same value as [`_totalWeight`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L423) is therefore redundant.\n* The conditions on [lines 820-822](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L820-L822) of the `_updateFor` function in the `VoterV3` contract can be consolidated into a single `if` statement.\n* The functions [`_updateFor`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L810) and [`_updateForAfterDistribution`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L833) of the `VoterV3` contract can be refactored to consolidate shared logic.\n* The function `claimBribes` on [line 467](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L467) and `claimFees` on [line 475](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L475) of the `VoterV3` contract are identical.\n* The function `claimBribes` on [line 483](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L483) and `claimFees` on [line 490](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L490) of the `VoterV3` contract are identical.\n* Ιn [line 366](https://github.com/ThenafiBNB/THENA-Contracts/blob/e5458ee4ea811788576585af7a56c02986d16122/contracts/VoterV3.sol#L366) and [line 382](https://github.com/ThenafiBNB/THENA-Contracts/blob/e5458ee4ea811788576585af7a56c02986d16122/contracts/VoterV3.sol#L382) of the `_reset` function of the `VoterV3` contract, there is a call to `_epochTimestamp()` but the value of `_epochTimestamp()` has already been stored in the [`_time`](https://github.com/ThenafiBNB/THENA-Contracts/blob/e5458ee4ea811788576585af7a56c02986d16122/contracts/VoterV3.sol#L356) variable.\n* The [`_reset`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L352) function in the `VoterV3` contract can be refactored as follows:\n\n\n\t+ The `if` statement on [line 370](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L370) is redundant as `_votes` is unsigned and resides inside the check on [line 362](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L362)\n\t+ The calls to `_withdraw` on [lines 371-372](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L371-L373) are only meaningful when the token was last voted in the current active period. If these operations are performed only when this condition is met, the `if` statement on [line 382](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L382) can be removed.\n* In the `GaugeV2` contract, the variables [`fees0`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeV2.sol#L50) and [`fees1`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeV2.sol#L51) are only ever assigned to zero and are therefore redundant.\n* In the `Bribes` contract, the `if` statement on [lines 131-133](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L131-L133) is redundant, as this case is covered on [lines 141-143](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L141-L143).\n* In the `Bribes` contract, the [`IERC20Ext`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Bribes.sol#L15) interface declaration is unused and can be removed.\n* In the `PermissionsRegistry` contract, the functions [`__helper_stringToBytes`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/PermissionsRegistry.sol#L183) and [`__helper_bytesToString`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/PermissionsRegistry.sol#L188) are unused and can be removed.\n* Ιn lines [821](https://github.com/ThenafiBNB/THENA-Contracts/blob/e5458ee4ea811788576585af7a56c02986d16122/contracts/VoterV3.sol#L821) and [844](https://github.com/ThenafiBNB/THENA-Contracts/blob/e5458ee4ea811788576585af7a56c02986d16122/contracts/VoterV3.sol#L844) of the `VoterV3` contract, the variable `_supplied` is cast to `uint` but is already declared as `uint256`.\n* The [`increaseGaugeApprovals`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L211-L215) function of the `VoterV3` contract sets the allowance of `_gauge` by `VoterV3` to `type(uint256).max`. However, the allowance is already set to `type(uint256).max` during [the gauge creation](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L554-L617) and the approval [will never decrease](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/Thena.sol#L71). Therefore, the `increaseGaugeApprovals` function is redundant.\n\n\n***Update:** Partially resolved in [pull request #5](https://github.com/ThenafiBNB/THENA-Contracts/pull/5) at commit [541bd36](https://github.com/ThenafiBNB/THENA-Contracts/pull/5/commits/541bd366d0f2cf05dedda9e21d78ef872ba29cb8). Most of the suggestions were not adopted.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/GaugeExtraRewarder.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./libraries/SignedSafeMath.sol\";\n\n\ninterface IRewarder {\n    function onReward(uint256 pid, address user, address recipient, uint256 lqdrAmount, uint256 newLpAmount) external;\n    function pendingTokens(uint256 pid, address user, uint256 lqdrAmount) external view returns (IERC20[] memory, uint256[] memory);\n}\n\ninterface IGauge {\n    function TOKEN() external view returns(address);\n}\n\n\ncontract GaugeExtraRewarder is Ownable {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    bool public stop = false;\n\n    IERC20 public immutable rewardToken;\n\n    /// @notice Info of each user.\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Struct of pool info\n   \n    struct PoolInfo {\n        uint256 accRewardPerShare;\n        uint256 lastRewardTime;\n    }\n\n    /// @notice pool info\n    PoolInfo public poolInfo;\n\n    /// @notice Info of each user that stakes tokens.\n    mapping(address => UserInfo) public userInfo;\n\n    uint public lastDistributedTime;\n    uint public rewardPerSecond;\n    uint public distributePeriod = 86400 * 7;\n    uint public ACC_TOKEN_PRECISION = 1e12;\n\n\n    address private immutable GAUGE;\n\n    event LogOnReward(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n\n    constructor (IERC20 _rewardToken, address gauge) {\n        rewardToken = _rewardToken;\n        poolInfo = PoolInfo({\n            lastRewardTime: block.timestamp,\n            accRewardPerShare: 0\n        });\n        GAUGE = gauge;\n    }\n\n\n    function onReward(uint256 /*pid*/, address _user, address to, uint256 /*extraData*/, uint256 lpToken) onlyGauge external {\n        if(stop) return;\n        PoolInfo memory pool = updatePool();\n        UserInfo storage user = userInfo[_user];\n        uint256 pending;\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        if (user.amount > 0) {\n            pending = int256( user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION ).sub(user.rewardDebt).toUInt256();\n            rewardToken.safeTransfer(to, pending);\n        }\n        user.amount = lpToken;\n        user.rewardDebt = int256(lpToken.mul(pool.accRewardPerShare) / ACC_TOKEN_PRECISION);\n    }\n\n\n    /// @notice View function to see pending WBNB on frontend.\n    /// @param _user Address of user.\n    /// @return pending rewardToken reward for a given user.\n    function pendingReward(address _user) external view returns (uint256 pending){\n        PoolInfo memory pool = poolInfo;\n        UserInfo storage user = userInfo[_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 lpSupply = IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE);\n\n        if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n            uint256 time = block.timestamp.sub(pool.lastRewardTime);\n            uint256 reward = time.mul(rewardPerSecond);\n            accRewardPerShare = accRewardPerShare.add( reward.mul(ACC_TOKEN_PRECISION) / lpSupply );\n        }\n        pending = int256( user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION ).sub(user.rewardDebt).toUInt256();\n    }\n\n\n    modifier onlyGauge {\n        require(msg.sender == GAUGE,\"!GAUGE\");\n        _;\n    }\n\n\n\n    /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Reward to be distributed per second.\n    function setRewardPerSecond(uint256 _rewardPerSecond) public onlyOwner {\n        updatePool();\n        rewardPerSecond = _rewardPerSecond;\n    }\n\n\n    function setDistributionRate(uint256 amount) public onlyOwner {\n        updatePool();\n        require(IERC20(rewardToken).balanceOf(address(this)) >= amount);\n        uint256 notDistributed;\n        if (lastDistributedTime > 0 && block.timestamp < lastDistributedTime) {\n            uint256 timeLeft = lastDistributedTime.sub(block.timestamp);\n            notDistributed = rewardPerSecond.mul(timeLeft);\n        }\n\n        amount = amount.add(notDistributed);\n        uint256 _rewardPerSecond = amount.div(distributePeriod);\n        rewardPerSecond = _rewardPerSecond;\n        lastDistributedTime = block.timestamp.add(distributePeriod);\n    }\n\n\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool() public returns (PoolInfo memory pool) {\n        pool = poolInfo;\n\n        if (block.timestamp > pool.lastRewardTime) {\n            uint256 lpSupply = IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE);\n            if (lpSupply > 0) {\n                uint256 time = block.timestamp.sub(pool.lastRewardTime);\n                uint256 reward = time.mul(rewardPerSecond);\n                pool.accRewardPerShare = pool.accRewardPerShare.add( reward.mul(ACC_TOKEN_PRECISION).div(lpSupply) );\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo = pool;\n        }\n    }\n\n\n    function recoverERC20(uint amount, address token) external onlyOwner {\n        require(amount > 0);\n        require(token != address(0));\n        require(IERC20(token).balanceOf(address(this)) >= amount);\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function stopRewarder() external onlyOwner {\n        stop = true;\n    }\n\n    function startRewarder() external onlyOwner {\n        stop = false;\n    }\n\n\n}"
    },
    {
      "filename": "contracts/Bribes.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"./interfaces/IMinter.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport './libraries/Math.sol';\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\n\ninterface IERC20Ext {\n    function name() external returns(string memory);\n    function symbol() external returns(string memory);\n}\n\ncontract Bribe is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant WEEK = 7 days; // rewards are released over 7 days\n    uint256 public firstBribeTimestamp;\n\n    /* ========== STATE VARIABLES ========== */\n\n    struct Reward {\n        uint256 periodFinish;\n        uint256 rewardsPerEpoch;\n        uint256 lastUpdateTime; \n    }\n\n    mapping(address => mapping(uint => Reward)) public rewardData;  // token -> startTimestamp -> Reward\n    mapping(address => bool) public isRewardToken;\n    address[] public rewardTokens;\n    address public voter;\n    address public bribeFactory;\n    address public minter;\n    address public ve;\n    address public owner;\n\n    string public TYPE;\n\n    // owner -> reward token -> lastTime\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n    mapping(address => mapping(address => uint256)) public userTimestamp;\n\n    //uint256 private _totalSupply;\n    mapping(uint256 => uint256) public _totalSupply;\n    mapping(address => mapping(uint256 => uint256)) private _balances; //owner -> timestamp -> amount\n\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _owner,address _voter,address _bribeFactory, string memory _type)  {\n        require(_bribeFactory != address(0) && _voter != address(0) && _owner != address(0));\n        voter = _voter;\n        bribeFactory = _bribeFactory;\n        firstBribeTimestamp = 0;\n        ve = IVoter(_voter)._ve();\n        minter = IVoter(_voter).minter();\n        require(minter != address(0));\n        owner = _owner;\n        TYPE = _type;\n    }\n\n    /// @notice get the current epoch \n    function getEpochStart() public view returns(uint){\n        return IMinter(minter).active_period();\n    }\n\n    /// @notice get next epoch (where bribes are saved)\n    function getNextEpochStart() public view returns(uint){\n        return getEpochStart() + WEEK;\n    }\n\n\n    /* ========== VIEWS ========== */\n\n    /// @notice get the length of the reward tokens\n    function rewardsListLength() external view returns(uint256) {\n        return rewardTokens.length;\n    }\n\n    /// @notice get the last totalSupply (total votes for a pool)\n    function totalSupply() external view returns (uint256) {\n        uint256 _currentEpochStart = IMinter(minter).active_period(); // claim until current epoch\n        return _totalSupply[_currentEpochStart];\n    }\n\n    /// @notice get a totalSupply given a timestamp\n    function totalSupplyAt(uint256 _timestamp) external view returns (uint256) {\n        return _totalSupply[_timestamp];\n    }\n\n    /// @notice read the balanceOf the tokenId at a given timestamp\n    function balanceOfAt(uint256 tokenId, uint256 _timestamp) public view returns (uint256) {\n        address _owner = IVotingEscrow(ve).ownerOf(tokenId);\n        return _balances[_owner][_timestamp];\n    }\n\n\n    /// @notice get last deposit available given a tokenID\n    function balanceOf(uint256 tokenId) public view returns (uint256) {\n        uint256 _timestamp = getNextEpochStart();\n        address _owner = IVotingEscrow(ve).ownerOf(tokenId);\n        return _balances[_owner][_timestamp];\n    }\n\n    /// @notice get the balance of a owner in the current epoch\n    function balanceOfOwner(address _owner) public view returns (uint256) {\n        uint256 _timestamp = getNextEpochStart();\n        return _balances[_owner][_timestamp];\n    }\n\n    /// @notice get the balance of a owner given a timestamp\n    function balanceOfOwnerAt(address _owner, uint256 _timestamp) public view returns (uint256) {\n        return _balances[_owner][_timestamp];\n    }\n\n\n    /// @notice Read earned amount given a tokenID and _rewardToken\n    function earned(uint256 tokenId, address _rewardToken) public view returns(uint256){\n        uint k = 0;\n        uint reward = 0;\n        uint256 _endTimestamp = IMinter(minter).active_period(); // claim until current epoch\n        address _owner = IVotingEscrow(ve).ownerOf(tokenId);\n        uint256 _userLastTime = userTimestamp[_owner][_rewardToken];\n        \n        if(_endTimestamp == _userLastTime){\n            return 0;\n        }\n\n        // if user first time then set it to first bribe - week to avoid any timestamp problem\n        if(_userLastTime < firstBribeTimestamp){\n            _userLastTime = firstBribeTimestamp - WEEK;\n        }\n\n        for(k; k < 50; k++){\n            if(_userLastTime == _endTimestamp){\n                // if we reach the current epoch, exit\n                break;\n            }\n            reward += _earned(_owner, _rewardToken, _userLastTime);\n            _userLastTime += WEEK;   \n                     \n        }  \n        return reward;  \n    }\n\n    /// @notice read earned amounts given an address and the reward token\n    function earned(address _owner, address _rewardToken) public view returns(uint256){\n        uint k = 0;\n        uint reward = 0;\n        uint256 _endTimestamp = IMinter(minter).active_period(); // claim until current epoch\n        uint256 _userLastTime = userTimestamp[_owner][_rewardToken];\n        \n        if(_endTimestamp == _userLastTime){\n            return 0;\n        }\n\n        // if user first time then set it to first bribe - week to avoid any timestamp problem\n        if(_userLastTime < firstBribeTimestamp){\n            _userLastTime = firstBribeTimestamp - WEEK;\n        }\n\n        for(k; k < 50; k++){\n            if(_userLastTime == _endTimestamp){\n                // if we reach the current epoch, exit\n                break;\n            }\n            reward += _earned(_owner, _rewardToken, _userLastTime);\n            _userLastTime += WEEK;   \n                     \n        }  \n        return reward;  \n    }\n\n    /// @notice Read earned amount given address and reward token, returns the rewards and the last user timestamp (used in case user do not claim since 50+epochs)\n    function earnedWithTimestamp(address _owner, address _rewardToken) private view returns(uint256,uint256){\n        uint k = 0;\n        uint reward = 0;\n        uint256 _endTimestamp = IMinter(minter).active_period(); // claim until current epoch\n        uint256 _userLastTime = userTimestamp[_owner][_rewardToken];\n        \n        if(_endTimestamp == _userLastTime){\n            return (0, _userLastTime);\n        }\n\n        // if user first time then set it to first bribe - week to avoid any timestamp problem\n        if(_userLastTime < firstBribeTimestamp){\n            _userLastTime = firstBribeTimestamp - WEEK;\n        }\n\n        for(k; k < 50; k++){\n            if(_userLastTime == _endTimestamp){\n                // if we reach the current epoch, exit\n                break;\n            }\n            reward += _earned(_owner, _rewardToken, _userLastTime);\n            _userLastTime += WEEK;   \n                     \n        }  \n        return (reward, _userLastTime);  \n    }\n\n    /// @notice get the earned rewards\n    function _earned(address _owner, address _rewardToken, uint256 _timestamp) internal view returns (uint256) {\n        uint256 _balance = balanceOfOwnerAt(_owner, _timestamp);\n        if(_balance == 0){\n            return 0;\n        } else {\n            uint256 _rewardPerToken = rewardPerToken(_rewardToken, _timestamp);\n            uint256 _rewards = _rewardPerToken * _balance / 1e18;\n            return _rewards;\n        }\n    }\n\n    /// @notice get the rewards for token\n    function rewardPerToken(address _rewardsToken, uint256 _timestmap) public view returns (uint256) {\n        if (_totalSupply[_timestmap] == 0) {\n            return rewardData[_rewardsToken][_timestmap].rewardsPerEpoch;\n        }\n        return rewardData[_rewardsToken][_timestmap].rewardsPerEpoch * 1e18 / _totalSupply[_timestmap];\n    }\n\n \n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /// @notice User votes deposit\n    /// @dev    called on voter.vote() or voter.poke()\n    ///         we save into owner \"address\" and not \"tokenID\". \n    ///         Owner must reset before transferring token\n    function _deposit(uint256 amount, uint256 tokenId) external nonReentrant {\n        require(amount > 0, \"Cannot stake 0\");\n        require(msg.sender == voter);\n        uint256 _startTimestamp = IMinter(minter).active_period() + WEEK;\n        uint256 _oldSupply = _totalSupply[_startTimestamp]; \n        address _owner = IVotingEscrow(ve).ownerOf(tokenId);\n        uint256 _lastBalance = _balances[_owner][_startTimestamp]; \n\n        _totalSupply[_startTimestamp] =  _oldSupply + amount;\n        _balances[_owner][_startTimestamp] = _lastBalance + amount;\n\n        emit Staked(tokenId, amount);\n    }\n\n    /// @notice User votes withdrawal \n    /// @dev    called on voter.reset()\n    function _withdraw(uint256 amount, uint256 tokenId) public nonReentrant {\n        require(amount > 0, \"Cannot withdraw 0\");\n        require(msg.sender == voter);\n        uint256 _startTimestamp = IMinter(minter).active_period() + WEEK; \n        address _owner = IVotingEscrow(ve).ownerOf(tokenId);\n\n        // incase of bribe contract reset in gauge proxy\n        if (amount <= _balances[_owner][_startTimestamp]) {\n            uint256 _oldSupply = _totalSupply[_startTimestamp]; \n            uint256 _oldBalance = _balances[_owner][_startTimestamp];\n            _totalSupply[_startTimestamp] =  _oldSupply - amount;\n            _balances[_owner][_startTimestamp] =  _oldBalance - amount;\n            emit Withdrawn(tokenId, amount);\n        }\n\n    }\n\n    /// @notice Claim the TOKENID rewards\n    function getReward(uint tokenId, address[] memory tokens) external nonReentrant  {\n        require(IVotingEscrow(ve).isApprovedOrOwner(msg.sender, tokenId));\n        uint256 _userLastTime;\n        uint256 reward = 0;\n        address _owner = IVotingEscrow(ve).ownerOf(tokenId);\n        \n        for (uint256 i = 0; i < tokens.length; i++) {\n            address _rewardToken = tokens[i];\n            (reward, _userLastTime) = earnedWithTimestamp(_owner, _rewardToken);          \n            if (reward > 0) {\n                IERC20(_rewardToken).safeTransfer(_owner, reward);\n                emit RewardPaid(_owner, _rewardToken, reward);\n            }\n            userTimestamp[_owner][_rewardToken] = _userLastTime;\n        }\n    }\n\n    /// @notice Claim the rewards given msg.sender\n    function getReward(address[] memory tokens) external nonReentrant  {\n        uint256 _userLastTime;\n        uint256 reward = 0;\n        address _owner = msg.sender;\n        \n        for (uint256 i = 0; i < tokens.length; i++) {\n            address _rewardToken = tokens[i];\n            (reward, _userLastTime) = earnedWithTimestamp(_owner, _rewardToken);          \n            if (reward > 0) {\n                IERC20(_rewardToken).safeTransfer(_owner, reward);\n                emit RewardPaid(_owner, _rewardToken, reward);\n            }\n            userTimestamp[_owner][_rewardToken] = _userLastTime;\n        }\n    }\n\n    /// @notice Claim rewards from voter\n    function getRewardForOwner(uint tokenId, address[] memory tokens) public nonReentrant  {\n        require(msg.sender == voter);\n        uint256 _userLastTime;\n        uint256 reward = 0;\n        address _owner = IVotingEscrow(ve).ownerOf(tokenId);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address _rewardToken = tokens[i];\n            (reward, _userLastTime) = earnedWithTimestamp(_owner, _rewardToken);    \n            if (reward > 0) {\n                IERC20(_rewardToken).safeTransfer(_owner, reward);\n                emit RewardPaid(_owner, _rewardToken, reward);\n            }\n            userTimestamp[_owner][_rewardToken] = _userLastTime;\n        }\n    }\n\n    /// @notice Claim rewards from voter\n    function getRewardForAddress(address _owner, address[] memory tokens) public nonReentrant  {\n        require(msg.sender == voter);\n        uint256 _userLastTime;\n        uint256 reward = 0;\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address _rewardToken = tokens[i];\n            (reward, _userLastTime) = earnedWithTimestamp(_owner, _rewardToken);    \n            if (reward > 0) {\n                IERC20(_rewardToken).safeTransfer(_owner, reward);\n                emit RewardPaid(_owner, _rewardToken, reward);\n            }\n            userTimestamp[_owner][_rewardToken] = _userLastTime;\n        }\n    }\n\n    /// @notice Notify a bribe amount\n    /// @dev    Rewards are saved into NEXT EPOCH mapping. \n    function notifyRewardAmount(address _rewardsToken, uint256 reward) external nonReentrant {\n        require(isRewardToken[_rewardsToken], \"reward token not verified\");\n        IERC20(_rewardsToken).safeTransferFrom(msg.sender,address(this),reward);\n\n        uint256 _startTimestamp = IMinter(minter).active_period() + WEEK; //period points to the current thursday. Bribes are distributed from next epoch (thursday)\n        if(firstBribeTimestamp == 0){\n            firstBribeTimestamp = _startTimestamp;\n        }\n\n        uint256 _lastReward = rewardData[_rewardsToken][_startTimestamp].rewardsPerEpoch;\n        \n        rewardData[_rewardsToken][_startTimestamp].rewardsPerEpoch = _lastReward + reward;\n        rewardData[_rewardsToken][_startTimestamp].lastUpdateTime = block.timestamp;\n        rewardData[_rewardsToken][_startTimestamp].periodFinish = _startTimestamp + WEEK;\n\n        emit RewardAdded(_rewardsToken, reward, _startTimestamp);\n    }\n\n\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /// @notice add rewards tokens\n    function addRewards(address[] memory _rewardsToken) public onlyAllowed {\n        uint i = 0;\n        for(i; i < _rewardsToken.length; i++){\n           _addReward(_rewardsToken[i]);\n        }\n    }\n\n    /// @notice add a single reward token\n    function addReward(address _rewardsToken) public onlyAllowed {\n        _addReward(_rewardsToken);\n    }\n    function _addReward(address _rewardsToken) internal {\n        if(!isRewardToken[_rewardsToken]){\n            isRewardToken[_rewardsToken] = true;\n            rewardTokens.push(_rewardsToken);\n        }\n    }\n\n    /// @notice Recover some ERC20 from the contract and updated given bribe\n    function recoverERC20AndUpdateData(address tokenAddress, uint256 tokenAmount) external onlyAllowed {\n        require(tokenAmount <= IERC20(tokenAddress).balanceOf(address(this)));\n        \n        uint256 _startTimestamp = IMinter(minter).active_period() + WEEK;\n        uint256 _lastReward = rewardData[tokenAddress][_startTimestamp].rewardsPerEpoch;\n        rewardData[tokenAddress][_startTimestamp].rewardsPerEpoch = _lastReward - tokenAmount;\n        rewardData[tokenAddress][_startTimestamp].lastUpdateTime = block.timestamp;\n\n\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    /// @notice Recover some ERC20 from the contract.\n    /// @dev    Be careful --> if called then getReward() at last epoch will fail because some reward are missing! \n    ///         Think about calling recoverERC20AndUpdateData()\n    function emergencyRecoverERC20(address tokenAddress, uint256 tokenAmount) external onlyAllowed {\n        require(tokenAmount <= IERC20(tokenAddress).balanceOf(address(this)));\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    /// @notice Set a new voter\n    function setVoter(address _Voter) external onlyAllowed {\n        require(_Voter != address(0));\n        voter = _Voter;\n    }\n\n    /// @notice Set a new minter\n    function setMinter(address _minter) external onlyAllowed {\n        require(_minter != address(0));\n        minter = _minter;\n    }\n\n    /// @notice Set a new Owner\n    function setOwner(address _owner) external onlyAllowed {\n        require(_owner != address(0));\n        owner = _owner;\n    }\n\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    modifier onlyAllowed() {\n        require( (msg.sender == owner || msg.sender == bribeFactory), \"permission is denied!\" );\n        _;\n    }\n\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address rewardToken, uint256 reward, uint256 startTimestamp);\n    event Staked(uint256 indexed tokenId, uint256 amount);\n    event Withdrawn(uint256 indexed tokenId, uint256 amount);\n    event RewardPaid(address indexed user,address indexed rewardsToken,uint256 reward);\n    event Recovered(address token, uint256 amount);\n}"
    },
    {
      "filename": "contracts/GaugeV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport './interfaces/IPair.sol';\nimport './interfaces/IBribe.sol';\nimport \"./libraries/Math.sol\";\n\ninterface IRewarder {\n    function onReward(\n        uint256 pid,\n        address user,\n        address recipient,\n        uint256 amount,\n        uint256 newLpAmount\n    ) external;\n}\n\n\ncontract GaugeV2 is ReentrancyGuard, Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    bool public isForPair;\n    bool public emergency;\n\n\n    IERC20 public rewardToken;\n    IERC20 public _VE;\n    IERC20 public TOKEN;\n\n    address public DISTRIBUTION;\n    address public gaugeRewarder;\n    address public internal_bribe;\n    address public external_bribe;\n\n    uint256 public rewarderPid;\n    uint256 public DURATION;\n    uint256 public periodFinish;\n    uint256 public rewardRate;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    uint public fees0;\n    uint public fees1;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 public _totalSupply;\n    mapping(address => uint256) public _balances;\n\n    event RewardAdded(uint256 reward);\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Harvest(address indexed user, uint256 reward);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    modifier onlyDistribution() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier isNotEmergency() {\n        require(emergency == false);\n        _;\n    }\n\n    constructor(address _rewardToken,address _ve,address _token,address _distribution, address _internal_bribe, address _external_bribe, bool _isForPair) {\n        rewardToken = IERC20(_rewardToken);     // main reward\n        _VE = IERC20(_ve);                      // vested\n        TOKEN = IERC20(_token);                 // underlying (LP)\n        DISTRIBUTION = _distribution;           // distro address (voter)\n        DURATION = 7 * 86400;                    // distro time\n\n        internal_bribe = _internal_bribe;       // lp fees goes here\n        external_bribe = _external_bribe;       // bribe fees goes here\n\n        isForPair = _isForPair;                 // pair boolean, if false no claim_fees\n\n        emergency = false;                      // emergency flag\n\n    }\n\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    ONLY OWNER\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    ///@notice set distribution address (should be GaugeProxyL2)\n    function setDistribution(address _distribution) external onlyOwner {\n        require(_distribution != address(0), \"zero addr\");\n        require(_distribution != DISTRIBUTION, \"same addr\");\n        DISTRIBUTION = _distribution;\n    }\n\n    ///@notice set gauge rewarder address\n    function setGaugeRewarder(address _gaugeRewarder) external onlyOwner {\n        require(_gaugeRewarder != address(0), \"zero addr\");\n        require(_gaugeRewarder != gaugeRewarder, \"same addr\");\n        gaugeRewarder = _gaugeRewarder;\n    }\n\n    ///@notice set extra rewarder pid\n    function setRewarderPid(uint256 _pid) external onlyOwner {\n        require(_pid >= 0, \"zero\");\n        require(_pid != rewarderPid, \"same pid\");\n        rewarderPid = _pid;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function setInternalBribe(address _int) external onlyOwner {\n        require(_int >= address(0), \"zero\");\n        internal_bribe = _int;\n    }\n\n    function activateEmergencyMode() external onlyOwner {\n        require(emergency == false);\n        emergency = true;\n    }\n\n    function stopEmergencyMode() external onlyOwner {\n        require(emergency == false);\n        emergency = false;\n    }\n\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VIEW FUNCTIONS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    ///@notice total supply held\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    ///@notice balance of a user\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    ///@notice last time reward\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    ///@notice  reward for a sinle token\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        } else {\n            return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply));\n        }\n    }\n\n    ///@notice see earned rewards for user\n    function earned(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }\n\n    ///@notice get total reward for the duration\n    function rewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(DURATION);\n    }\n\n    function _periodFinish() external view returns (uint256) {\n        return periodFinish;\n    }\n\n\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n\n    ///@notice deposit all TOKEN of msg.sender\n    function depositAll() external {\n        _deposit(TOKEN.balanceOf(msg.sender), msg.sender);\n    }\n\n    ///@notice deposit amount TOKEN\n    function deposit(uint256 amount) external {\n        _deposit(amount, msg.sender);\n    }\n\n    ///@notice deposit internal\n    function _deposit(uint256 amount, address account) internal nonReentrant isNotEmergency updateReward(account) {\n        require(amount > 0, \"deposit(Gauge): cannot stake 0\");\n\n        _balances[account] = _balances[account].add(amount);\n        _totalSupply = _totalSupply.add(amount);\n\n        TOKEN.safeTransferFrom(account, address(this), amount);\n\n        if (address(gaugeRewarder) != address(0)) {\n            IRewarder(gaugeRewarder).onReward(rewarderPid, account, account, 0, _balances[account]);\n        }\n\n        emit Deposit(account, amount);\n    }\n\n    ///@notice withdraw all token\n    function withdrawAll() external {\n        _withdraw(_balances[msg.sender]);\n    }\n\n    ///@notice withdraw a certain amount of TOKEN\n    function withdraw(uint256 amount) external {\n        _withdraw(amount);\n    }\n\n    ///@notice withdraw internal\n    function _withdraw(uint256 amount) internal nonReentrant isNotEmergency updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        require(_totalSupply.sub(amount) >= 0, \"supply < 0\");\n        require(_balances[msg.sender] > 0, \"no balances\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        if (address(gaugeRewarder) != address(0)) {\n            IRewarder(gaugeRewarder).onReward(rewarderPid, msg.sender, msg.sender, 0, _balances[msg.sender]);\n        }\n\n        TOKEN.safeTransfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function emergencyWithdraw() external nonReentrant {\n        require(emergency);\n        require(_balances[msg.sender] > 0, \"no balances\");\n        uint256 _amount = _balances[msg.sender];\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = 0;\n        TOKEN.safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n    function emergencyWithdrawAmount(uint256 _amount) external nonReentrant {\n        require(emergency);\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender] - _amount;\n        TOKEN.safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    ///@notice withdraw all TOKEN and harvest rewardToken\n    function withdrawAllAndHarvest() external {"
    }
  ]
}