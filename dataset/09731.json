{
  "Title": "[M-03] Usage of deprecated Chainlink functions",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84\n\n\n# Vulnerability details\n\n## Impact\nThe Chainlink functions `latestAnswer()` and `getAnswer()` are deprecated. Instead, use the [`latestRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata) and [`getRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#getrounddata) functions.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84\n\nGo to https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code and search for `latestAnswer()` or `getAnswer()`. You'll find the deprecation notice.\n\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nSwitch to `latestRoundData()` as described [here](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"../../interfaces/external/chainlink/IEACAggregatorProxy.sol\";\nimport \"../PriceRegistry.sol\";\nimport \"./ProviderOracleManager.sol\";\nimport \"../../libraries/ProtocolValue.sol\";\nimport \"../../libraries/QuantMath.sol\";\nimport \"../../interfaces/IChainlinkOracleManager.sol\";\n\n/// @title For managing chainlink oracles for assets and submitting chainlink prices to the registry\n/// @author Rolla\n/// @notice Once an oracle is added for an asset it can't be changed!\ncontract ChainlinkOracleManager is\n    ProviderOracleManager,\n    IChainlinkOracleManager\n{\n    using QuantMath for uint256;\n    using QuantMath for QuantMath.FixedPointInt;\n\n    struct BinarySearchResult {\n        uint80 firstRound;\n        uint80 lastRound;\n        uint80 firstRoundProxy;\n        uint80 lastRoundProxy;\n    }\n\n    uint256 public immutable override fallbackPeriodSeconds;\n    uint8 public immutable override strikeAssetDecimals;\n    uint8 public constant CHAINLINK_ORACLE_DECIMALS = 8;\n\n    /// @param _config address of quant central configuration\n    /// @param _fallbackPeriodSeconds amount of seconds before fallback price submitter can submit\n    constructor(\n        address _config,\n        uint8 _strikeAssetDecimals,\n        uint256 _fallbackPeriodSeconds\n    ) ProviderOracleManager(_config) {\n        fallbackPeriodSeconds = _fallbackPeriodSeconds;\n        strikeAssetDecimals = _strikeAssetDecimals;\n    }\n\n    /// @inheritdoc IChainlinkOracleManager\n    function setExpiryPriceInRegistryByRound(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _roundIdAfterExpiry\n    ) external override {\n        _setExpiryPriceInRegistryByRound(\n            _asset,\n            _expiryTimestamp,\n            _roundIdAfterExpiry\n        );\n    }\n\n    /// @inheritdoc IProviderOracleManager\n    function setExpiryPriceInRegistry(\n        address _asset,\n        uint256 _expiryTimestamp,\n        bytes memory\n    ) external override(ProviderOracleManager, IProviderOracleManager) {\n        //search and get round\n        uint80 roundAfterExpiry = searchRoundToSubmit(_asset, _expiryTimestamp);\n\n        //submit price to registry\n        _setExpiryPriceInRegistryByRound(\n            _asset,\n            _expiryTimestamp,\n            roundAfterExpiry\n        );\n    }\n\n    /// @inheritdoc IOracleFallbackMechanism\n    function setExpiryPriceInRegistryFallback(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external override {\n        require(\n            config.hasRole(\n                config.quantRoles(\"FALLBACK_PRICE_ROLE\"),\n                msg.sender\n            ),\n            \"ChainlinkOracleManager: Only the fallback price submitter can submit a fallback price\"\n        );\n\n        require(\n            block.timestamp >= _expiryTimestamp + fallbackPeriodSeconds,\n            \"ChainlinkOracleManager: The fallback price period has not passed since the timestamp\"\n        );\n\n        emit PriceRegistrySubmission(\n            _asset,\n            _expiryTimestamp,\n            _price,\n            0,\n            msg.sender,\n            true\n        );\n\n        PriceRegistry(\n            config.protocolAddresses(ProtocolValue.encode(\"priceRegistry\"))\n        ).setSettlementPrice(\n                _asset,\n                _expiryTimestamp,\n                _price,\n                CHAINLINK_ORACLE_DECIMALS\n            );\n    }\n\n    /// @inheritdoc IProviderOracleManager\n    function getCurrentPrice(address _asset)\n        external\n        view\n        override(ProviderOracleManager, IProviderOracleManager)\n        returns (uint256)\n    {\n        address assetOracle = getAssetOracle(_asset);\n        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);\n        int256 answer = aggregator.latestAnswer();\n        require(\n            answer > 0,\n            \"ChainlinkOracleManager: No pricing data available\"\n        );\n\n        return\n            uint256(answer)\n                .fromScaledUint(CHAINLINK_ORACLE_DECIMALS)\n                .toScaledUint(strikeAssetDecimals, true);\n    }\n\n    /// @inheritdoc IProviderOracleManager\n    function isValidOption(\n        address,\n        uint256,\n        uint256\n    )\n        public\n        view\n        virtual\n        override(ProviderOracleManager, IProviderOracleManager)\n        returns (bool)\n    {\n        return true;\n    }\n\n    /// @inheritdoc IChainlinkOracleManager\n    function searchRoundToSubmit(address _asset, uint256 _expiryTimestamp)\n        public\n        view\n        override\n        returns (uint80)\n    {\n        address assetOracle = getAssetOracle(_asset);\n\n        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);\n\n        require(\n            aggregator.latestTimestamp() > _expiryTimestamp,\n            \"ChainlinkOracleManager: The latest round timestamp is not after the expiry timestamp\"\n        );\n\n        uint80 latestRound = uint80(aggregator.latestRound());\n\n        uint16 phaseOffset = 64;\n        uint16 phaseId = uint16(latestRound >> phaseOffset);\n\n        uint80 lowestPossibleRound = uint80((phaseId << phaseOffset) | 1);\n        uint80 highestPossibleRound = latestRound;\n        uint80 firstId = lowestPossibleRound;\n        uint80 lastId = highestPossibleRound;\n\n        require(\n            lastId > firstId,\n            \"ChainlinkOracleManager: Not enough rounds to find round after\"\n        );\n\n        //binary search until we find two values our desired timestamp lies between\n        while (lastId - firstId != 1) {\n            BinarySearchResult memory result = _binarySearchStep(\n                aggregator,\n                _expiryTimestamp,\n                lowestPossibleRound,\n                highestPossibleRound\n            );\n\n            lowestPossibleRound = result.firstRound;\n            highestPossibleRound = result.lastRound;\n            firstId = result.firstRoundProxy;\n            lastId = result.lastRoundProxy;\n        }\n\n        return highestPossibleRound; //return round above\n    }\n\n    /// @notice Get the expiry price from chainlink asset oracle and store it in the price registry\n    /// @param _asset asset to set price of\n    /// @param _expiryTimestamp timestamp of price\n    /// @param _roundIdAfterExpiry the chainlink round id immediately after the option expired\n    function _setExpiryPriceInRegistryByRound(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _roundIdAfterExpiry\n    ) internal {\n        address assetOracle = getAssetOracle(_asset);\n\n        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);\n\n        require(\n            aggregator.getTimestamp(uint256(_roundIdAfterExpiry)) >\n                _expiryTimestamp,\n            \"ChainlinkOracleManager: The round posted is not after the expiry timestamp\"\n        );\n\n        uint16 phaseOffset = 64;\n        uint16 phaseId = uint16(_roundIdAfterExpiry >> phaseOffset);\n\n        uint64 expiryRound = uint64(_roundIdAfterExpiry) - 1;\n        uint80 expiryRoundId = uint80(\n            (uint256(phaseId) << phaseOffset) | expiryRound\n        );\n\n        require(\n            aggregator.getTimestamp(uint256(expiryRoundId)) <= _expiryTimestamp,\n            \"ChainlinkOracleManager: Expiry round prior to the one posted is after the expiry timestamp\"\n        );\n\n        (uint256 price, uint256 roundId) = _getExpiryPrice(\n            aggregator,\n            _expiryTimestamp,\n            _roundIdAfterExpiry,\n            expiryRoundId\n        );\n\n        emit PriceRegistrySubmission(\n            _asset,\n            _expiryTimestamp,\n            price,\n            roundId,\n            msg.sender,\n            false\n        );\n\n        PriceRegistry(\n            config.protocolAddresses(ProtocolValue.encode(\"priceRegistry\"))\n        ).setSettlementPrice(\n                _asset,\n                _expiryTimestamp,\n                price,\n                CHAINLINK_ORACLE_DECIMALS\n            );\n    }\n\n    function _getExpiryPrice(\n        IEACAggregatorProxy aggregator,\n        uint256,\n        uint256,\n        uint256 _expiryRoundId\n    ) internal view virtual returns (uint256, uint256) {\n        return (uint256(aggregator.getAnswer(_expiryRoundId)), _expiryRoundId);\n    }\n\n    /// @notice Performs a binary search step between the first and last round in the aggregator proxy\n    /// @param _expiryTimestamp expiry timestamp to find the price at\n    /// @param _firstRoundProxy the lowest possible round for the timestamp\n    /// @param _lastRoundProxy the highest possible round for the timestamp\n    /// @return a binary search result object representing lowest and highest possible rounds of the timestamp\n    function _binarySearchStep(\n        IEACAggregatorProxy aggregator,\n        uint256 _expiryTimestamp,\n        uint80 _firstRoundProxy,\n        uint80 _lastRoundProxy\n    ) internal view returns (BinarySearchResult memory) {\n        uint16 phaseOffset = 64;\n        uint16 phaseId = uint16(_lastRoundProxy >> phaseOffset);\n\n        uint64 lastRoundId = uint64(_lastRoundProxy);\n        uint64 firstRoundId = uint64(_firstRoundProxy);\n\n        uint80 roundToCheck = uint80(\n            (uint256(firstRoundId) + uint256(lastRoundId)) / 2\n        );\n        uint80 roundToCheckProxy = uint80(\n            (uint256(phaseId) << phaseOffset) | roundToCheck\n        );\n\n        uint256 roundToCheckTimestamp = aggregator.getTimestamp(\n            uint256(roundToCheckProxy)\n        );\n\n        if (roundToCheckTimestamp <= _expiryTimestamp) {\n            return\n                BinarySearchResult(\n                    roundToCheckProxy,\n                    _lastRoundProxy,\n                    roundToCheck,\n                    lastRoundId\n                );\n        }\n\n        return\n            BinarySearchResult(\n                _firstRoundProxy,\n                roundToCheckProxy,\n                firstRoundId,\n                roundToCheck\n            );\n    }\n}"
    },
    {
      "filename": "quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./ChainlinkOracleManager.sol\";\nimport \"../../interfaces/external/chainlink/IEACAggregatorProxy.sol\";\nimport \"../../interfaces/IChainlinkFixedTimeOracleManager.sol\";\n\n/// @title For managing Chainlink oracles with updates at fixed times.\n/// @author Rolla\n/// @notice Update times are counted as seconds since the start of the day.\ncontract ChainlinkFixedTimeOracleManager is\n    ChainlinkOracleManager,\n    IChainlinkFixedTimeOracleManager\n{\n    mapping(uint256 => bool) public override chainlinkFixedTimeUpdates;\n\n    /// @param _config address of quant central configuration\n    /// @param _fallbackPeriodSeconds amount of seconds before fallback price submitter can submit\n    constructor(\n        address _config,\n        uint8 _strikeAssetDecimals,\n        uint256 _fallbackPeriodSeconds\n    )\n        ChainlinkOracleManager(\n            _config,\n            _strikeAssetDecimals,\n            _fallbackPeriodSeconds\n        )\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    /// @inheritdoc IChainlinkFixedTimeOracleManager\n    function setFixedTimeUpdate(uint256 fixedTime, bool isValidTime)\n        external\n        override\n    {\n        require(\n            config.hasRole(\n                config.quantRoles(\"ORACLE_MANAGER_ROLE\"),\n                msg.sender\n            ),\n            \"ChainlinkFixedTimeOracleManager: Only an oracle admin can add a fixed time for updates\"\n        );\n\n        chainlinkFixedTimeUpdates[fixedTime] = isValidTime;\n\n        emit FixedTimeUpdate(fixedTime, isValidTime);\n    }\n\n    /// @inheritdoc IProviderOracleManager\n    function isValidOption(\n        address,\n        uint256 _expiryTime,\n        uint256\n    )\n        public\n        view\n        override(ChainlinkOracleManager, IProviderOracleManager)\n        returns (bool)\n    {\n        uint256 timeInSeconds = _expiryTime % 86400;\n        return chainlinkFixedTimeUpdates[timeInSeconds];\n    }\n\n    /// @notice Gets the price and roundId for a given expiry time.\n    /// @param aggregator address of the Chainlink aggregator proxy contract\n    /// @param _expiryTimestamp option expiration timestamp in seconds since the Unix epoch\n    /// @param _roundIdAfterExpiry id of the round right after the expiry\n    /// @param _expiryRoundId id of the round right before or at the expiry\n    function _getExpiryPrice(\n        IEACAggregatorProxy aggregator,\n        uint256 _expiryTimestamp,\n        uint256 _roundIdAfterExpiry,\n        uint256 _expiryRoundId\n    ) internal view override returns (uint256 price, uint256 roundId) {\n        if (\n            aggregator.getTimestamp(uint256(_expiryRoundId)) == _expiryTimestamp\n        ) {\n            price = uint256(aggregator.getAnswer(_expiryRoundId));\n            roundId = _expiryRoundId;\n        } else {\n            price = uint256(aggregator.getAnswer(_roundIdAfterExpiry));\n            roundId = _roundIdAfterExpiry;\n        }\n    }\n}"
    },
    {
      "filename": "quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./ChainlinkOracleManager.sol\";\nimport \"../../interfaces/external/chainlink/IEACAggregatorProxy.sol\";\nimport \"../../interfaces/IChainlinkFixedTimeOracleManager.sol\";\n\n/// @title For managing Chainlink oracles with updates at fixed times.\n/// @author Rolla\n/// @notice Update times are counted as seconds since the start of the day.\ncontract ChainlinkFixedTimeOracleManager is\n    ChainlinkOracleManager,\n    IChainlinkFixedTimeOracleManager\n{\n    mapping(uint256 => bool) public override chainlinkFixedTimeUpdates;\n\n    /// @param _config address of quant central configuration\n    /// @param _fallbackPeriodSeconds amount of seconds before fallback price submitter can submit\n    constructor(\n        address _config,\n        uint8 _strikeAssetDecimals,\n        uint256 _fallbackPeriodSeconds\n    )\n        ChainlinkOracleManager(\n            _config,\n            _strikeAssetDecimals,\n            _fallbackPeriodSeconds\n        )\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    /// @inheritdoc IChainlinkFixedTimeOracleManager\n    function setFixedTimeUpdate(uint256 fixedTime, bool isValidTime)\n        external\n        override\n    {\n        require(\n            config.hasRole(\n                config.quantRoles(\"ORACLE_MANAGER_ROLE\"),\n                msg.sender\n            ),\n            \"ChainlinkFixedTimeOracleManager: Only an oracle admin can add a fixed time for updates\"\n        );\n\n        chainlinkFixedTimeUpdates[fixedTime] = isValidTime;\n\n        emit FixedTimeUpdate(fixedTime, isValidTime);\n    }\n\n    /// @inheritdoc IProviderOracleManager\n    function isValidOption(\n        address,\n        uint256 _expiryTime,\n        uint256\n    )\n        public\n        view\n        override(ChainlinkOracleManager, IProviderOracleManager)\n        returns (bool)\n    {\n        uint256 timeInSeconds = _expiryTime % 86400;\n        return chainlinkFixedTimeUpdates[timeInSeconds];\n    }\n\n    /// @notice Gets the price and roundId for a given expiry time.\n    /// @param aggregator address of the Chainlink aggregator proxy contract\n    /// @param _expiryTimestamp option expiration timestamp in seconds since the Unix epoch\n    /// @param _roundIdAfterExpiry id of the round right after the expiry\n    /// @param _expiryRoundId id of the round right before or at the expiry\n    function _getExpiryPrice(\n        IEACAggregatorProxy aggregator,\n        uint256 _expiryTimestamp,\n        uint256 _roundIdAfterExpiry,\n        uint256 _expiryRoundId\n    ) internal view override returns (uint256 price, uint256 roundId) {\n        if (\n            aggregator.getTimestamp(uint256(_expiryRoundId)) == _expiryTimestamp\n        ) {\n            price = uint256(aggregator.getAnswer(_expiryRoundId));\n            roundId = _expiryRoundId;\n        } else {\n            price = uint256(aggregator.getAnswer(_roundIdAfterExpiry));\n            roundId = _roundIdAfterExpiry;\n        }\n    }\n}"
    }
  ]
}