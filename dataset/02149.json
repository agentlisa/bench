{
  "Title": "M-6: FeeBuyback.submit() method may fail if all allowance is not used by referral contract",
  "Content": "# Issue M-6: FeeBuyback.submit() method may fail if all allowance is not used by referral contract \n\nSource: https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/22 \n\n## Found by \njonatascm, jasonxiale, ddimitrov22, 0xGoodess, spyrosonic10\n\n## Summary\nInside `submit()` method of `FeeBuyback.sol`, if token is `_telcoin` then it safeApprove to `_referral` contract.   If `_referral` contract do not use all allowance then `submit()` method will fail in next call. \n\n## Vulnerability Detail\n`SafeApprove()` method of library `SafeERC20Upgradeable` revert in following scenario. \n```solidity\nrequire((value == 0) || (token.allowance(address(this), spender) == 0), \n\"SafeERC20: approve from non-zero to non-zero allowance\");\n```\nSubmit method is doing `safeApproval` of Telcoin to referral contract.  If referral contract do not use full allowance then subsequent call to submit() method will fails because of `SafeERC20: approve from non-zero to non-zero allowance`.  `FeeBuyback` contract should not trust or assume that referral contract will use all allowance.  If it does not use all allowance in `increaseClaimableBy()` method then submit() method will revert in next call. This vulnerability exists at two places in `submit()` method.  Link given in code snippet section.\n\n## Impact\nSubmit() call will fail until referral contract do not use all allowance.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/FeeBuyback.sol#L63-L64\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/FeeBuyback.sol#L63-L64\n\n## Tool used\n\nManual Review\n\n## Recommendation\nReset allowance to 0 before non-zero approval.\n\n```solidity\n_telcoin.safeApprove(address(_referral), 0);\n_telcoin.safeApprove(address(_referral), _telcoin.balanceOf(address(this)));\n```\n\n## Discussion\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/3\n\n**dmitriia**\n\nLooks ok\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/49",
  "Code": [
    {
      "filename": "telcoin-audit/contracts/staking/FeeBuyback.sol",
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\n//imports\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../util/TieredOwnership.sol\";\nimport \"../interfaces/IFeeBuyback.sol\";\nimport \"../interfaces/ISimplePlugin.sol\";\n\n/**\n * @title FeeBuyback\n * @author Amir Shirif, Telcoin, LLC.\n * @notice Helps facilitate a secondary swap, if required, to allow the referrer of a user to receive a fraction of the generated transaction fee, based on the stake of the referrer.\n */\ncontract FeeBuyback is IFeeBuyback, TieredOwnership {\n  using SafeERC20 for IERC20;\n  //MATIC address\n  address constant public MATIC = 0x0000000000000000000000000000000000001010;\n  //1 inch aggregator address\n  address immutable public _aggregator;\n  //reward token\n  IERC20 immutable public _telcoin;\n  //destination of rewards\n  ISimplePlugin immutable public _referral;\n\n  //constructor\n  constructor(address aggregator_, IERC20 telcoin_, ISimplePlugin referral_) TieredOwnership() {\n    require(aggregator_ != address(0), \"FeeBuyback: zero aggregator\");\n    _aggregator = aggregator_;\n    _telcoin = telcoin_;\n    _referral = referral_;\n  }\n\n  /**\n   * @notice submits wallet transactions\n   * @dev a secondary swap may occur\n   * @dev staking contract updates may be made\n   * @param wallet address of the primary transaction\n   * @param walletData bytes wallet data for primary transaction\n   * @param token address the token that is being swapped from in a secondary transaction\n   * @param amount uint256 the quantity of the token being swapped\n   * @param swapData bytes swap data from primary transaction\n   * @return boolean representing if a referral transaction was made\n   */\n  function submit(address wallet, bytes memory walletData, address safe, address token, address recipient, uint256 amount, bytes memory swapData) external override payable onlyOwner() returns (bool) {\n    //wallet validity check\n    require(wallet != address(0), \"FeeBuyback: zero wallet\");\n    //Perform user swap first\n    //Verify success\n    (bool walletResult,) = wallet.call{value: 0}(walletData);\n    require(walletResult, \"FeeBuyback: wallet transaction failed\");\n\n    //check if this is a referral transaction\n    //if not exit execution\n    if (token == address(0) || recipient == address(0) || amount == 0 ) {\n      return false;\n    }\n\n    //if swapped token is in TEL, no swap is necessary\n    //do simple transfer from and submit\n    if (token == address(_telcoin)) {\n      _telcoin.safeTransferFrom(safe, address(this), amount);\n      _telcoin.safeApprove(address(_referral), _telcoin.balanceOf(address(this)));\n      require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n      return true;\n    }\n\n    //MATIC does not allow for approvals\n    //ERC20s only\n    if (token != MATIC) {\n      IERC20(token).safeTransferFrom(safe, address(this), amount);\n      IERC20(token).safeApprove(_aggregator, 0);\n      IERC20(token).safeApprove(_aggregator, amount);\n    }\n\n    //Perform secondary swap from fee token to TEL\n    //do simple transfer from and submit\n    (bool swapResult,) = _aggregator.call{value: msg.value}(swapData);\n    require(swapResult, \"FeeBuyback: swap transaction failed\");\n    _telcoin.safeApprove(address(_referral), _telcoin.balanceOf(address(this)));\n    require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n    return true;\n  }\n\n  /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Only an owner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n  * Emits a {Transfer} event.\n  */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyExecutor() returns (bool) {\n    if (externalToken != MATIC) {\n      IERC20(externalToken).safeTransfer(account, amount);\n    } else {\n      (bool sent,) = executor().call{value: amount}(\"\");\n      require(sent, \"FeeBuyback: MATIC send failed\");\n    }\n    return true;\n  }\n}"
    },
    {
      "filename": "telcoin-audit/contracts/staking/FeeBuyback.sol",
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\n//imports\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../util/TieredOwnership.sol\";\nimport \"../interfaces/IFeeBuyback.sol\";\nimport \"../interfaces/ISimplePlugin.sol\";\n\n/**\n * @title FeeBuyback\n * @author Amir Shirif, Telcoin, LLC.\n * @notice Helps facilitate a secondary swap, if required, to allow the referrer of a user to receive a fraction of the generated transaction fee, based on the stake of the referrer.\n */\ncontract FeeBuyback is IFeeBuyback, TieredOwnership {\n  using SafeERC20 for IERC20;\n  //MATIC address\n  address constant public MATIC = 0x0000000000000000000000000000000000001010;\n  //1 inch aggregator address\n  address immutable public _aggregator;\n  //reward token\n  IERC20 immutable public _telcoin;\n  //destination of rewards\n  ISimplePlugin immutable public _referral;\n\n  //constructor\n  constructor(address aggregator_, IERC20 telcoin_, ISimplePlugin referral_) TieredOwnership() {\n    require(aggregator_ != address(0), \"FeeBuyback: zero aggregator\");\n    _aggregator = aggregator_;\n    _telcoin = telcoin_;\n    _referral = referral_;\n  }\n\n  /**\n   * @notice submits wallet transactions\n   * @dev a secondary swap may occur\n   * @dev staking contract updates may be made\n   * @param wallet address of the primary transaction\n   * @param walletData bytes wallet data for primary transaction\n   * @param token address the token that is being swapped from in a secondary transaction\n   * @param amount uint256 the quantity of the token being swapped\n   * @param swapData bytes swap data from primary transaction\n   * @return boolean representing if a referral transaction was made\n   */\n  function submit(address wallet, bytes memory walletData, address safe, address token, address recipient, uint256 amount, bytes memory swapData) external override payable onlyOwner() returns (bool) {\n    //wallet validity check\n    require(wallet != address(0), \"FeeBuyback: zero wallet\");\n    //Perform user swap first\n    //Verify success\n    (bool walletResult,) = wallet.call{value: 0}(walletData);\n    require(walletResult, \"FeeBuyback: wallet transaction failed\");\n\n    //check if this is a referral transaction\n    //if not exit execution\n    if (token == address(0) || recipient == address(0) || amount == 0 ) {\n      return false;\n    }\n\n    //if swapped token is in TEL, no swap is necessary\n    //do simple transfer from and submit\n    if (token == address(_telcoin)) {\n      _telcoin.safeTransferFrom(safe, address(this), amount);\n      _telcoin.safeApprove(address(_referral), _telcoin.balanceOf(address(this)));\n      require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n      return true;\n    }\n\n    //MATIC does not allow for approvals\n    //ERC20s only\n    if (token != MATIC) {\n      IERC20(token).safeTransferFrom(safe, address(this), amount);\n      IERC20(token).safeApprove(_aggregator, 0);\n      IERC20(token).safeApprove(_aggregator, amount);\n    }\n\n    //Perform secondary swap from fee token to TEL\n    //do simple transfer from and submit\n    (bool swapResult,) = _aggregator.call{value: msg.value}(swapData);\n    require(swapResult, \"FeeBuyback: swap transaction failed\");\n    _telcoin.safeApprove(address(_referral), _telcoin.balanceOf(address(this)));\n    require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n    return true;\n  }\n\n  /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Only an owner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n  * Emits a {Transfer} event.\n  */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyExecutor() returns (bool) {\n    if (externalToken != MATIC) {\n      IERC20(externalToken).safeTransfer(account, amount);\n    } else {\n      (bool sent,) = executor().call{value: amount}(\"\");\n      require(sent, \"FeeBuyback: MATIC send failed\");\n    }\n    return true;\n  }\n}"
    }
  ]
}