{
  "Title": "[L-08] ERC-777 tokens can lead to re-entrancy vulnerabilities",
  "Content": "\nERC-777 behave like ERC-20 tokens, but they make a callback when tokens are transfered.\n\n### Impact\n\nPositions containing ERC-777 tokens as collateral may be victim of re-entrancy attacks.\n\nThe possible impacts are unrestricted minting of ZCHF tokens via `end`, and stealing ZCHF tokens from the `MintingHub`, both critical.\n\nOn top of that, some inconsistency on the positions' storage can be result of these unexpected behavior.\n\nThe actual impact relies on the `minters` of the protocol allowing the possibility of using ERC-777 tokens as collateral or denying them.\n\n### Proof of Concept\n\nThese functions in the `MintingHub` are suceptible to re-entrancy attacks. An attacker can perform them by first launching a challenge, and then calling the respected functions. As the bidder and challenger will be the same, the collateral will be transfered between attacker accounts.\n\n`end()` calls `returnCollateral` early on the function, before the `challenge` is deleted. So, it can be re-entered to mint extra tokens via `zchf.notifyLoss`:\n\n```solidity\n    // returnCollateral()\n    challenge.position.collateral().transfer(msg.sender, challenge.size);\n```\n\n[Link to code](https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/MintingHub.sol#L211)\n\n`bid()` can be re-entered when the bid is high enough to avert the challenge.\n\nFirst, the attacker needs to have a previous bid, or the attacker can create one.\n\nThe attacker would then be able to steal the initial bid multiple times via the `zchf.transfer(challenge.bidder, challenge.bid);`. Assets will be taken from the `MintingHub` contract.\n\nThe re-entrancy can be executed by calling the function with a value big enough to avert the challenge:\n\n```solidity\n    // bid()\n    challenge.position.collateral().transfer(challenge.challenger, challenge.size); // return the challenger's collateral\n```\n\n[Link to code](https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/MintingHub.sol#L294)\n\n### Recommended Mitigation Steps\n\nAdd re-entrancy guards to functions that transfer collateral, and implement the Checks-Effects-Interaction pattern. Or disallow the use of ERC-777 tokens as collateral.\n\n[Link to code](https://github.com/Frankencoin-ZCHF/FrankenCoin/blob/main/contracts/MintingHub.sol#L88-L113)\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-frankencoin",
  "Code": [
    {
      "filename": "contracts/MintingHub.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./IPosition.sol\";\n\n/**\n * The central hub for creating, cloning and challenging collateralized Frankencoin positions.\n * Only one instance of this contract is required, whereas every new position comes with a new position\n * contract. Pending challenges are stored as structs in an array.\n */\ncontract MintingHub {\n\n    /**\n     * Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\n     */\n    uint256 public constant OPENING_FEE = 1000 * 10**18;\n\n    /**\n     * The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\n     */\n    uint32 public constant CHALLENGER_REWARD = 20000; // 2%\n\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n    IFrankencoin public immutable zchf; // currency\n    Challenge[] public challenges; // list of open challenges\n\n    /**\n     * Map to remember pending postponed collateral returns.\n     * It maps collateral => beneficiary => amount.\n     */\n    mapping (address /** col */ => mapping (address => uint256)) public pendingReturns;\n\n    struct Challenge {\n        address challenger; // the address from which the challenge was initiated\n        IPosition position; // the position that was challenged\n        uint256 size;       // how much collateral the challenger provided\n        uint256 end;        // the deadline of the challenge (block.timestamp)\n        address bidder;     // the address from which the highest bid was made, if any\n        uint256 bid;        // the highest bid in ZCHF (total amount, not price per unit)\n    }\n\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\n    event ChallengeAverted(address indexed position, uint256 number);\n    event ChallengeSucceeded(address indexed position, uint256 bid, uint256 number);\n    event NewBid(uint256 challengedId, uint256 bidAmount, address bidder);\n    event PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\n\n    constructor(address _zchf, address factory) {\n        zchf = IFrankencoin(_zchf);\n        POSITION_FACTORY = IPositionFactory(factory);\n    }\n\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n            return openPosition(_collateralAddress, _minCollateral, _initialCollateral, _mintingMaximum,\n            7 days, _expirationSeconds, _challengeSeconds, _mintingFeePPM, _liqPrice, _reservePPM);\n    }\n\n    /**\n     * Open a collateralized loan position. See also https://docs.frankencoin.com/positions/open .\n     * For a successful call, you must set allowances for both ZCHF and the collateral token, allowing\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\n     * withdraw the fees.\n     *\n     * Together, the expiration and the minting fee imply an interest rate.\n     * TODO: in future versions, it might be better to fix the interest and not the fee\n     *\n     * @param _collateralAddress        address of collateral token\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\n     * @param _initialCollateral amount of initial collateral to be deposited\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\n     * @param _mintingFeePPM     ppm of minted amount that is paid as fee to the equity contract\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\n     *                           e.g. 18 decimals for an 18 decimal collateral, 36 decimals for a 0 decimal collateral.\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\n     * @return address           address of created position\n     */\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _initPeriodSeconds, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n        IPosition pos = IPosition(\n            POSITION_FACTORY.createNewPosition(\n                msg.sender,\n                address(zchf),\n                _collateralAddress,\n                _minCollateral,\n                _mintingMaximum,\n                _initPeriodSeconds,\n                _expirationSeconds,\n                _challengeSeconds,\n                _mintingFeePPM,\n                _liqPrice,\n                _reservePPM\n            )\n        );\n        zchf.registerPosition(address(pos));\n        zchf.transferFrom(msg.sender, address(zchf.reserve()), OPENING_FEE);\n        require(_initialCollateral >= _minCollateral, \"must start with min col\");\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n        return address(pos);\n    }\n\n    modifier validPos(address position) {\n        require(zchf.isPosition(position) == address(this), \"not our pos\");\n        _;\n    }\n\n    /**\n     * Clones an existing position and immediately tries to mint the specified amount using the given amount of collateral.\n     * This requires an allowance to be set on the collateral contract such that the minting hub can withdraw the collateral.\n     */\n    function clonePosition(address position, uint256 _initialCollateral, uint256 _initialMint) public validPos(position) returns (address) {\n        IPosition existing = IPosition(position);\n        uint256 limit = existing.reduceLimitForClone(_initialMint);\n        address pos = POSITION_FACTORY.clonePosition(position);\n        zchf.registerPosition(pos);\n        existing.collateral().transferFrom(msg.sender, address(pos), _initialCollateral);\n        IPosition(pos).initializeClone(msg.sender, existing.price(), limit, _initialCollateral, _initialMint);\n        return address(pos);\n    }\n\n    /**\n     * Launch a challenge on a position\n     * @param _positionAddr      address of the position we want to challenge\n     * @param _collateralAmount  size of the collateral we want to challenge (dec 18)\n     * @return index of the challenge in challenge-array\n     */\n    function launchChallenge(address _positionAddr, uint256 _collateralAmount) external validPos(_positionAddr) returns (uint256) {\n        IPosition position = IPosition(_positionAddr);\n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\n        uint256 pos = challenges.length;\n        challenges.push(Challenge(msg.sender, position, _collateralAmount, block.timestamp + position.challengePeriod(), address(0x0), 0));\n        position.notifyChallengeStarted(_collateralAmount);\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\n        return pos;\n    }\n\n    /**\n     * Splits a challenge into two smaller challenges.\n     * This can be useful to guard an attack, where a challenger launches a challenge so big that most bidders do not\n     * have the liquidity available to bid a sufficient amount. With this function, the can split of smaller slices of\n     * the challenge and avert it piece by piece.\n     */\n    function splitChallenge(uint256 _challengeNumber, uint256 splitOffAmount) external returns (uint256) {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        Challenge memory copy = Challenge(\n            challenge.challenger,\n            challenge.position,\n            splitOffAmount,\n            challenge.end,\n            challenge.bidder,\n            (challenge.bid * splitOffAmount) / challenge.size\n        );\n        challenge.bid -= copy.bid;\n        challenge.size -= copy.size;\n\n        uint256 min = IPosition(challenge.position).minimumCollateral();\n        require(challenge.size >= min);\n        require(copy.size >= min);\n\n        uint256 pos = challenges.length;\n        challenges.push(copy);\n        emit ChallengeStarted(challenge.challenger, address(challenge.position), challenge.size, _challengeNumber);\n        emit ChallengeStarted(copy.challenger, address(copy.position), copy.size, pos);\n        return pos;\n    }\n\n    function minBid(uint256 challenge) public view returns (uint256) {\n        return minBid(challenges[challenge]);\n    }\n\n    /**\n     * The minimum bid size for the next bid. It must be 0.5% higher than the previous bid.\n     */\n    function minBid(Challenge storage challenge) internal view returns (uint256) {\n        return (challenge.bid * 1005) / 1000;\n    }\n\n    /**\n     * Post a bid in ZCHF given an open challenge. Requires a ZCHF allowance from the caller to the minting hub.\n     *\n     * @param _challengeNumber   index of the challenge as broadcast in the event\n     * @param _bidAmountZCHF     how much to bid for the collateral of this challenge (dec 18)\n     * @param expectedSize       size verification to guard against frontrunners doing a split-challenge-attack\n     */\n    function bid(uint256 _challengeNumber, uint256 _bidAmountZCHF, uint256 expectedSize) external {\n        Challenge storage challenge = challenges[_challengeNumber];\n        if (block.timestamp >= challenge.end) revert TooLate();\n        if (expectedSize != challenge.size) revert UnexpectedSize();\n        if (challenge.bid > 0) {\n            zchf.transfer(challenge.bidder, challenge.bid); // return old bid\n        }\n        emit NewBid(_challengeNumber, _bidAmountZCHF, msg.sender);\n        // ask position if the bid was high enough to avert the challenge\n        if (challenge.position.tryAvertChallenge(challenge.size, _bidAmountZCHF)) {\n            // bid was high enough, let bidder buy collateral from challenger\n            zchf.transferFrom(msg.sender, challenge.challenger, _bidAmountZCHF);\n            challenge.position.collateral().transfer(msg.sender, challenge.size);\n            emit ChallengeAverted(address(challenge.position), _challengeNumber);\n            delete challenges[_challengeNumber];\n        } else {\n            // challenge is not averted, update bid\n            if (_bidAmountZCHF < minBid(challenge)) revert BidTooLow(_bidAmountZCHF, minBid(challenge));\n            uint256 earliestEnd = block.timestamp + 30 minutes;\n            if (earliestEnd >= challenge.end) {\n                // bump remaining time like ebay does when last minute bids come in\n                // An attacker trying to postpone the challenge forever must increase the bid by 0.5%\n                // every 30 minutes, or double it every three days, making the attack hard to sustain\n                // for a prolonged period of time.\n                challenge.end = earliestEnd;\n            }\n            zchf.transferFrom(msg.sender, address(this), _bidAmountZCHF);\n            challenge.bid = _bidAmountZCHF;\n            challenge.bidder = msg.sender;\n        }\n    }\n\n    error TooLate();\n    error UnexpectedSize();\n    error BidTooLow(uint256 bid, uint256 min);\n\n    function end(uint256 _challengeNumber) external {\n        end(_challengeNumber, false);\n    }\n\n    function isChallengeOpen(uint256 _challengeNumber) external view returns (bool) {\n        return challenges[_challengeNumber].end > block.timestamp;\n    }\n\n    /**\n     * Ends a challenge successfully after the auction period ended, whereas successfully means that the challenger\n     * could show that the price of the collateral is too low to make the position well-collateralized.\n     *\n     * In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token has a blacklist and the\n     * challenger is on it), it is possible to postpone the return of the collateral.\n     *\n     * @param postponeCollateralReturn Can be used to postpone the return of the collateral to the challenger. Usually false. \n     */\n    function end(uint256 _challengeNumber, bool postponeCollateralReturn) public {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        require(block.timestamp >= challenge.end, \"period has not ended\");\n        // challenge must have been successful, because otherwise it would have immediately ended on placing the winning bid\n        returnCollateral(challenge, postponeCollateralReturn);\n        // notify the position that will send the collateral to the bidder. If there is no bid, send the collateral to msg.sender\n        address recipient = challenge.bidder == address(0x0) ? msg.sender : challenge.bidder;\n        (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size);\n        if (effectiveBid < challenge.bid) {\n            // overbid, return excess amount\n            IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid);\n        }\n        uint256 reward = (volume * CHALLENGER_REWARD) / 1000_000;\n        uint256 fundsNeeded = reward + repayment;\n        if (effectiveBid > fundsNeeded){\n            zchf.transfer(owner, effectiveBid - fundsNeeded);\n        } else if (effectiveBid < fundsNeeded){\n            zchf.notifyLoss(fundsNeeded - effectiveBid); // ensure we have enough to pay everything\n        }\n        zchf.transfer(challenge.challenger, reward); // pay out the challenger reward\n        zchf.burn(repayment, reservePPM); // Repay the challenged part\n        emit ChallengeSucceeded(address(challenge.position), challenge.bid, _challengeNumber);\n        delete challenges[_challengeNumber];\n    }\n\n    /**\n     * Challengers can call this method to withdraw collateral whose return was postponed.\n     */\n    function returnPostponedCollateral(address collateral, address target) external {\n        uint256 amount = pendingReturns[collateral][msg.sender];\n        delete pendingReturns[collateral][msg.sender];\n        IERC20(collateral).transfer(target, amount);\n    }\n\n    function returnCollateral(Challenge storage challenge, bool postpone) internal {\n        if (postpone){\n            // Postponing helps in case the challenger was blacklisted on the collateral token or otherwise cannot receive it at the moment.\n            address collateral = address(challenge.position.collateral());\n            pendingReturns[collateral][challenge.challenger] += challenge.size;\n            emit PostPonedReturn(collateral, challenge.challenger, challenge.size);\n        } else {\n            challenge.position.collateral().transfer(challenge.challenger, challenge.size); // return the challenger's collateral\n        }\n    }\n}\n\ninterface IPositionFactory {\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint256 _initPeriodSeconds,\n        uint256 _duration,\n        uint256 _challengePeriod,\n        uint32 _mintingFeePPM,\n        uint256 _liqPrice,\n        uint32 _reserve\n    ) external returns (address);\n\n    function clonePosition(address _existing) external returns (address);\n}"
    },
    {
      "filename": "contracts/MintingHub.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./IPosition.sol\";\n\n/**\n * The central hub for creating, cloning and challenging collateralized Frankencoin positions.\n * Only one instance of this contract is required, whereas every new position comes with a new position\n * contract. Pending challenges are stored as structs in an array.\n */\ncontract MintingHub {\n\n    /**\n     * Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\n     */\n    uint256 public constant OPENING_FEE = 1000 * 10**18;\n\n    /**\n     * The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\n     */\n    uint32 public constant CHALLENGER_REWARD = 20000; // 2%\n\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n    IFrankencoin public immutable zchf; // currency\n    Challenge[] public challenges; // list of open challenges\n\n    /**\n     * Map to remember pending postponed collateral returns.\n     * It maps collateral => beneficiary => amount.\n     */\n    mapping (address /** col */ => mapping (address => uint256)) public pendingReturns;\n\n    struct Challenge {\n        address challenger; // the address from which the challenge was initiated\n        IPosition position; // the position that was challenged\n        uint256 size;       // how much collateral the challenger provided\n        uint256 end;        // the deadline of the challenge (block.timestamp)\n        address bidder;     // the address from which the highest bid was made, if any\n        uint256 bid;        // the highest bid in ZCHF (total amount, not price per unit)\n    }\n\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\n    event ChallengeAverted(address indexed position, uint256 number);\n    event ChallengeSucceeded(address indexed position, uint256 bid, uint256 number);\n    event NewBid(uint256 challengedId, uint256 bidAmount, address bidder);\n    event PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\n\n    constructor(address _zchf, address factory) {\n        zchf = IFrankencoin(_zchf);\n        POSITION_FACTORY = IPositionFactory(factory);\n    }\n\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n            return openPosition(_collateralAddress, _minCollateral, _initialCollateral, _mintingMaximum,\n            7 days, _expirationSeconds, _challengeSeconds, _mintingFeePPM, _liqPrice, _reservePPM);\n    }\n\n    /**\n     * Open a collateralized loan position. See also https://docs.frankencoin.com/positions/open .\n     * For a successful call, you must set allowances for both ZCHF and the collateral token, allowing\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\n     * withdraw the fees.\n     *\n     * Together, the expiration and the minting fee imply an interest rate.\n     * TODO: in future versions, it might be better to fix the interest and not the fee\n     *\n     * @param _collateralAddress        address of collateral token\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\n     * @param _initialCollateral amount of initial collateral to be deposited\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\n     * @param _mintingFeePPM     ppm of minted amount that is paid as fee to the equity contract\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\n     *                           e.g. 18 decimals for an 18 decimal collateral, 36 decimals for a 0 decimal collateral.\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\n     * @return address           address of created position\n     */\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _initPeriodSeconds, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n        IPosition pos = IPosition(\n            POSITION_FACTORY.createNewPosition(\n                msg.sender,\n                address(zchf),\n                _collateralAddress,\n                _minCollateral,\n                _mintingMaximum,\n                _initPeriodSeconds,\n                _expirationSeconds,\n                _challengeSeconds,\n                _mintingFeePPM,\n                _liqPrice,\n                _reservePPM\n            )\n        );\n        zchf.registerPosition(address(pos));\n        zchf.transferFrom(msg.sender, address(zchf.reserve()), OPENING_FEE);\n        require(_initialCollateral >= _minCollateral, \"must start with min col\");\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n        return address(pos);\n    }\n\n    modifier validPos(address position) {\n        require(zchf.isPosition(position) == address(this), \"not our pos\");\n        _;\n    }\n\n    /**\n     * Clones an existing position and immediately tries to mint the specified amount using the given amount of collateral.\n     * This requires an allowance to be set on the collateral contract such that the minting hub can withdraw the collateral.\n     */\n    function clonePosition(address position, uint256 _initialCollateral, uint256 _initialMint) public validPos(position) returns (address) {\n        IPosition existing = IPosition(position);\n        uint256 limit = existing.reduceLimitForClone(_initialMint);\n        address pos = POSITION_FACTORY.clonePosition(position);\n        zchf.registerPosition(pos);\n        existing.collateral().transferFrom(msg.sender, address(pos), _initialCollateral);\n        IPosition(pos).initializeClone(msg.sender, existing.price(), limit, _initialCollateral, _initialMint);\n        return address(pos);\n    }\n\n    /**\n     * Launch a challenge on a position\n     * @param _positionAddr      address of the position we want to challenge\n     * @param _collateralAmount  size of the collateral we want to challenge (dec 18)\n     * @return index of the challenge in challenge-array\n     */\n    function launchChallenge(address _positionAddr, uint256 _collateralAmount) external validPos(_positionAddr) returns (uint256) {\n        IPosition position = IPosition(_positionAddr);\n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\n        uint256 pos = challenges.length;\n        challenges.push(Challenge(msg.sender, position, _collateralAmount, block.timestamp + position.challengePeriod(), address(0x0), 0));\n        position.notifyChallengeStarted(_collateralAmount);\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\n        return pos;\n    }\n\n    /**\n     * Splits a challenge into two smaller challenges.\n     * This can be useful to guard an attack, where a challenger launches a challenge so big that most bidders do not\n     * have the liquidity available to bid a sufficient amount. With this function, the can split of smaller slices of\n     * the challenge and avert it piece by piece.\n     */\n    function splitChallenge(uint256 _challengeNumber, uint256 splitOffAmount) external returns (uint256) {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        Challenge memory copy = Challenge(\n            challenge.challenger,\n            challenge.position,\n            splitOffAmount,\n            challenge.end,\n            challenge.bidder,\n            (challenge.bid * splitOffAmount) / challenge.size\n        );\n        challenge.bid -= copy.bid;\n        challenge.size -= copy.size;\n\n        uint256 min = IPosition(challenge.position).minimumCollateral();\n        require(challenge.size >= min);\n        require(copy.size >= min);\n\n        uint256 pos = challenges.length;\n        challenges.push(copy);\n        emit ChallengeStarted(challenge.challenger, address(challenge.position), challenge.size, _challengeNumber);\n        emit ChallengeStarted(copy.challenger, address(copy.position), copy.size, pos);\n        return pos;\n    }\n\n    function minBid(uint256 challenge) public view returns (uint256) {\n        return minBid(challenges[challenge]);\n    }\n\n    /**\n     * The minimum bid size for the next bid. It must be 0.5% higher than the previous bid.\n     */\n    function minBid(Challenge storage challenge) internal view returns (uint256) {\n        return (challenge.bid * 1005) / 1000;\n    }\n\n    /**\n     * Post a bid in ZCHF given an open challenge. Requires a ZCHF allowance from the caller to the minting hub.\n     *\n     * @param _challengeNumber   index of the challenge as broadcast in the event\n     * @param _bidAmountZCHF     how much to bid for the collateral of this challenge (dec 18)\n     * @param expectedSize       size verification to guard against frontrunners doing a split-challenge-attack\n     */\n    function bid(uint256 _challengeNumber, uint256 _bidAmountZCHF, uint256 expectedSize) external {\n        Challenge storage challenge = challenges[_challengeNumber];\n        if (block.timestamp >= challenge.end) revert TooLate();\n        if (expectedSize != challenge.size) revert UnexpectedSize();\n        if (challenge.bid > 0) {\n            zchf.transfer(challenge.bidder, challenge.bid); // return old bid\n        }\n        emit NewBid(_challengeNumber, _bidAmountZCHF, msg.sender);\n        // ask position if the bid was high enough to avert the challenge\n        if (challenge.position.tryAvertChallenge(challenge.size, _bidAmountZCHF)) {\n            // bid was high enough, let bidder buy collateral from challenger\n            zchf.transferFrom(msg.sender, challenge.challenger, _bidAmountZCHF);\n            challenge.position.collateral().transfer(msg.sender, challenge.size);\n            emit ChallengeAverted(address(challenge.position), _challengeNumber);\n            delete challenges[_challengeNumber];\n        } else {\n            // challenge is not averted, update bid\n            if (_bidAmountZCHF < minBid(challenge)) revert BidTooLow(_bidAmountZCHF, minBid(challenge));\n            uint256 earliestEnd = block.timestamp + 30 minutes;\n            if (earliestEnd >= challenge.end) {\n                // bump remaining time like ebay does when last minute bids come in\n                // An attacker trying to postpone the challenge forever must increase the bid by 0.5%\n                // every 30 minutes, or double it every three days, making the attack hard to sustain\n                // for a prolonged period of time.\n                challenge.end = earliestEnd;\n            }\n            zchf.transferFrom(msg.sender, address(this), _bidAmountZCHF);\n            challenge.bid = _bidAmountZCHF;\n            challenge.bidder = msg.sender;\n        }\n    }\n\n    error TooLate();\n    error UnexpectedSize();\n    error BidTooLow(uint256 bid, uint256 min);\n\n    function end(uint256 _challengeNumber) external {\n        end(_challengeNumber, false);\n    }\n\n    function isChallengeOpen(uint256 _challengeNumber) external view returns (bool) {\n        return challenges[_challengeNumber].end > block.timestamp;\n    }\n\n    /**\n     * Ends a challenge successfully after the auction period ended, whereas successfully means that the challenger\n     * could show that the price of the collateral is too low to make the position well-collateralized.\n     *\n     * In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token has a blacklist and the\n     * challenger is on it), it is possible to postpone the return of the collateral.\n     *\n     * @param postponeCollateralReturn Can be used to postpone the return of the collateral to the challenger. Usually false. \n     */\n    function end(uint256 _challengeNumber, bool postponeCollateralReturn) public {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        require(block.timestamp >= challenge.end, \"period has not ended\");\n        // challenge must have been successful, because otherwise it would have immediately ended on placing the winning bid\n        returnCollateral(challenge, postponeCollateralReturn);\n        // notify the position that will send the collateral to the bidder. If there is no bid, send the collateral to msg.sender\n        address recipient = challenge.bidder == address(0x0) ? msg.sender : challenge.bidder;\n        (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size);\n        if (effectiveBid < challenge.bid) {\n            // overbid, return excess amount\n            IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid);\n        }\n        uint256 reward = (volume * CHALLENGER_REWARD) / 1000_000;\n        uint256 fundsNeeded = reward + repayment;\n        if (effectiveBid > fundsNeeded){\n            zchf.transfer(owner, effectiveBid - fundsNeeded);\n        } else if (effectiveBid < fundsNeeded){\n            zchf.notifyLoss(fundsNeeded - effectiveBid); // ensure we have enough to pay everything\n        }\n        zchf.transfer(challenge.challenger, reward); // pay out the challenger reward\n        zchf.burn(repayment, reservePPM); // Repay the challenged part\n        emit ChallengeSucceeded(address(challenge.position), challenge.bid, _challengeNumber);\n        delete challenges[_challengeNumber];\n    }\n\n    /**\n     * Challengers can call this method to withdraw collateral whose return was postponed.\n     */\n    function returnPostponedCollateral(address collateral, address target) external {\n        uint256 amount = pendingReturns[collateral][msg.sender];\n        delete pendingReturns[collateral][msg.sender];\n        IERC20(collateral).transfer(target, amount);\n    }\n\n    function returnCollateral(Challenge storage challenge, bool postpone) internal {\n        if (postpone){\n            // Postponing helps in case the challenger was blacklisted on the collateral token or otherwise cannot receive it at the moment.\n            address collateral = address(challenge.position.collateral());\n            pendingReturns[collateral][challenge.challenger] += challenge.size;\n            emit PostPonedReturn(collateral, challenge.challenger, challenge.size);\n        } else {\n            challenge.position.collateral().transfer(challenge.challenger, challenge.size); // return the challenger's collateral\n        }\n    }\n}\n\ninterface IPositionFactory {\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint256 _initPeriodSeconds,\n        uint256 _duration,\n        uint256 _challengePeriod,\n        uint32 _mintingFeePPM,\n        uint256 _liqPrice,\n        uint32 _reserve\n    ) external returns (address);\n\n    function clonePosition(address _existing) external returns (address);\n}"
    },
    {
      "filename": "contracts/MintingHub.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interface/IERC20.sol\";\nimport \"./interface/IReserve.sol\";\nimport \"./interface/IFrankencoin.sol\";\nimport \"./interface/IPosition.sol\";\nimport \"./interface/IPositionFactory.sol\";\n\n/**\n * @title Minting Hub\n * @notice The central hub for creating, cloning and challenging collateralized Frankencoin positions.\n * @dev Only one instance of this contract is required, whereas every new position comes with a new position\n * contract. Pending challenges are stored as structs in an array.\n */\ncontract MintingHub {\n    /**\n     * @notice Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\n     */\n    uint256 public constant OPENING_FEE = 1000 * 10 ** 18;\n\n    /**\n     * @notice The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\n     */\n    uint32 public constant CHALLENGER_REWARD = 20000; // 2%\n\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n    IF"
    }
  ]
}