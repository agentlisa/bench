{
  "Title": "[H-52] Attacker can prevent rewards from being issued to gauges for a given epoch in TapiocaOptionBroker",
  "Content": "\n<https://github.com/Tapioca-DAO/tap-token-audit/blob/59749be5bc2286f0bdbf59d7ddc258ddafd49a9f/contracts/options/TapiocaOptionBroker.sol#L426> \n\n<https://github.com/Tapioca-DAO/tap-token-audit/blob/59749be5bc2286f0bdbf59d7ddc258ddafd49a9f/contracts/tokens/TapOFT.sol#L201>\n\nAn attacker can prevent rewards from being issued to gauges for a given epoch\n\n### Proof of Concept\n\n`TapOFT.emitForWeek()` is callable by anyone. The function will only return a value > 0 the first time it's called in any given week:\n\n```sol\n    ///-- Write methods --\n    /// @notice Emit the TAP for the current week\n    /// @return the emitted amount\n    function emitForWeek() external notPaused returns (uint256) {\n        require(_getChainId() == governanceChainIdentifier, \"chain not valid\");\n\n        uint256 week = _timestampToWeek(block.timestamp);\n        if (emissionForWeek[week] > 0) return 0;\n\n        // Update DSO supply from last minted emissions\n        dso_supply -= mintedInWeek[week - 1];\n\n        // Compute unclaimed emission from last week and add it to the current week emission\n        uint256 unclaimed = emissionForWeek[week - 1] - mintedInWeek[week - 1];\n        uint256 emission = uint256(_computeEmission());\n        emission += unclaimed;\n        emissionForWeek[week] = emission;\n\n        emit Emitted(week, emission);\n\n        return emission;\n    }\n```\n\nIn `TapiocaOptionBroker.newEpoch()` the return value of `emitForWeek()` is used to determine the amount of tokens to distribute to the gauges. If the return value is 0, it will assign 0 reward tokens to each gauge:\n\n```sol\n    /// @notice Start a new epoch, extract TAP from the TapOFT contract,\n    ///         emit it to the active singularities and get the price of TAP for the epoch.\n    function newEpoch() external {\n        require(\n            block.timestamp >= lastEpochUpdate + EPOCH_DURATION,\n            \"tOB: too soon\"\n        );\n        uint256[] memory singularities = tOLP.getSingularities();\n        require(singularities.length > 0, \"tOB: No active singularities\");\n\n        // Update epoch info\n        lastEpochUpdate = block.timestamp;\n        epoch++;\n\n        // Extract TAP\n\n        // @audit `emitForWeek` can be called by anyone. If it's called for a given\n        // week, subsequent calls will return `0`. \n        // \n        // Attacker calls `emitForWeek` before it's executed through `newEpoch()`.\n        // The call to `newEpoch()` will cause `emitForWeek` to return `0`.\n        // That will prevent it from emitting any of the TAP to the gauges.\n        // For that epoch, no rewards will be distributed to users.\n        uint256 epochTAP = tapOFT.emitForWeek();\n        _emitToGauges(epochTAP);\n\n        // Get epoch TAP valuation\n        (, epochTAPValuation) = tapOracle.get(tapOracleData);\n        emit NewEpoch(epoch, epochTAP, epochTAPValuation);\n    }\n```\n\nAn attacker who frontruns the call to `newEpoch()` with a call to `emitForWeek()` will prevent any rewards from being distributed for a given epoch.\n\nThe reward tokens aren't lost. TapOFT will roll the missed epoch's rewards into the next one. Meaning, the gauge rewards will be delayed. The length depends on the number of times the attacker is able to frontrun the call to `newEpoch()`.\n\nBut, it will cause the distribution to be screwed. If Alice is eligible for gauge rewards until epoch x + 1 (her lock runs out), and the attacker manages to keep the attack running until x + 2, she won't be able to claim her reward tokens. They will be distributed in epoch x + 3 to all the users who have an active lock at that time.\n\nHere's a PoC:\n\n```typescript\n// tOB.test.ts\n    it.only(\"should fail to emit rewards to gauges if attacker frontruns\", async () => {\n        const {\n            tOB,\n            tapOFT,\n            tOLP,\n            sglTokenMock,\n            sglTokenMockAsset,\n            tapOracleMock,\n            sglTokenMock2,\n            sglTokenMock2Asset,\n        } = await loadFixture(setupFixture);\n\n        // Setup tOB\n        await tOB.oTAPBrokerClaim();\n        await tapOFT.setMinter(tOB.address);\n\n        // No singularities\n        await expect(tOB.newEpoch()).to.be.revertedWith(\n            'tOB: No active singularities',\n        );\n\n        // Register sgl\n        const tapPrice = BN(1e18).mul(2);\n        await tapOracleMock.set(tapPrice);\n        await tOLP.registerSingularity(\n            sglTokenMock.address,\n            sglTokenMockAsset,\n            0,\n        );\n\n        await tapOFT.emitForWeek();\n\n        await tOB.newEpoch();\n\n        const emittedTAP = await tapOFT.getCurrentWeekEmission();\n\n        expect(await tOB.singularityGauges(1, sglTokenMockAsset)).to.be.equal(\n            emittedTAP,\n        );\n    })\n```\n\nTest output:\n\n```sh\n  TapiocaOptionBroker\n    1) should fail to emit rewards to gauges if attacker frontruns\n\n\n  0 passing (1s)\n  1 failing\n\n  1) TapiocaOptionBroker\n       should fail to emit rewards to gauges if attacker frontruns:\n\n      AssertionError: expected 0 to equal 469157964000000000000000. The numerical values of the given \"ethers.BigNumber\" and \"ethers.BigNumber\" inputs were compared, and they differed.\n      + expected - actual\n\n      -0\n      +469157964000000000000000\n\n      at Context.<anonymous> (test/oTAP/tOB.test.ts:606:73)\n      at processTicksAndRejections (node:internal/process/task_queues:96:5)\n      at runNextTicks (node:internal/process/task_queues:65:3)\n      at listOnTimeout (node:internal/timers:528:9)\n      at processTimers (node:internal/timers:502:7)\n\n```\n\n### Recommended Mitigation Steps\n\n`emitForWeek()` should return the current week's emitted amount if it was already called:\n\n```sol\n    function emitForWeek() external notPaused returns (uint256) {\n        require(_getChainId() == governanceChainIdentifier, \"chain not valid\");\n\n        uint256 week = _timestampToWeek(block.timestamp);\n        if (emissionForWeek[week] > 0) return emissionForWeek[week];\n        // ...\n```\n\n**[0xRektora (Tapioca) confirmed via duplicate issue 192](https://github.com/code-423n4/2023-07-tapioca-findings/issues/192)**\n\n**[LSDan (Judge) increase severity to High](https://github.com/code-423n4/2023-07-tapioca-findings/issues/541#issuecomment-1723509071)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/options/TapiocaOptionBroker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"tapioca-periph/contracts/interfaces/IOracle.sol\";\nimport \"./TapiocaOptionLiquidityProvision.sol\";\nimport \"../tokens/TapOFT.sol\";\nimport \"../twAML.sol\";\nimport \"./oTAP.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\nstruct Participation {\n    bool hasVotingPower;\n    bool divergenceForce; // 0 negative, 1 positive\n    uint256 averageMagnitude;\n}\n\nstruct TWAMLPool {\n    uint256 totalParticipants;\n    uint256 averageMagnitude;\n    uint256 totalDeposited;\n    uint256 cumulative;\n}\n\nstruct PaymentTokenOracle {\n    IOracle oracle;\n    bytes oracleData;\n}\n\n/// @title TapiocaOptionBroker\n/// @notice This contract handles the creation of oTAP, the oTAP options creates an expiry dates to exercise the option, and an eligible amount of TAP that can be exercised.\n///         The amount of TAP that can be exercised is calculated by the TWAML algorithm, which takes into account the size of the participant as well his lock time.\n///         More info about twAML can be found here https://docs.tapioca.xyz/tapioca/core-technologies/twaml\n///         More info about the mechanic of how to receive oTAP can be found here https://docs.tapioca.xyz/tapioca/token-economy/dso-dao-share-options\n/// @dev   Actions:\n///        - Participate with tOLP lock tokens to receive oTAP\n///        - ExerciseOption: Exercise the option to buy TAP at the given discount\n///        - Exit: Withdraw tOLP lock tokens\ncontract TapiocaOptionBroker is Pausable, BoringOwnable, TWAML {\n    TapiocaOptionLiquidityProvision public immutable tOLP;\n    bytes public tapOracleData;\n    TapOFT public immutable tapOFT;\n    OTAP public immutable oTAP;\n    IOracle public tapOracle;\n\n    uint256 public lastEpochUpdate; // timestamp of the last epoch update\n    uint256 public epochTAPValuation; // TAP price for the current epoch\n    uint256 public epoch; // Represents the number of weeks since the start of the contract\n\n    mapping(uint256 => Participation) public participants; // tOLPTokenID => Participation\n    mapping(uint256 => mapping(uint256 => uint256)) public oTAPCalls; // oTAPTokenID => epoch => amountExercised\n\n    mapping(uint256 => mapping(uint256 => uint256)) public singularityGauges; // epoch => sglAssetId => availableTAP\n\n    mapping(ERC20 => PaymentTokenOracle) public paymentTokens; // Token address => PaymentTokenOracle\n    address public paymentTokenBeneficiary; // Where to collect the payment tokens\n\n    /// ===== TWAML ======\n    mapping(uint256 => TWAMLPool) public twAML; // sglAssetId => twAMLPool\n\n    uint256 constant MIN_WEIGHT_FACTOR = 10; // In BPS, 0.1%\n    uint256 constant dMAX = 50 * 1e4; // 5% - 50% discount\n    uint256 constant dMIN = 5 * 1e4;\n    uint256 public immutable EPOCH_DURATION; // 7 days = 604800\n\n    /// =====-------======\n    constructor(\n        address _tOLP,\n        address _oTAP,\n        address payable _tapOFT,\n        address _paymentTokenBeneficiary,\n        uint256 _epochDuration,\n        address _owner\n    ) {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n        tOLP = TapiocaOptionLiquidityProvision(_tOLP);\n        tapOFT = TapOFT(_tapOFT);\n        oTAP = OTAP(_oTAP);\n        EPOCH_DURATION = _epochDuration;\n        owner = _owner;\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(\n        uint256 indexed epoch,\n        uint256 indexed sglAssetID,\n        uint256 totalDeposited,\n        LockPosition lock,\n        uint256 discount\n    );\n    event AMLDivergence(\n        uint256 indexed epoch,\n        uint256 cumulative,\n        uint256 averageMagnitude,\n        uint256 totalParticipants\n    );\n    event ExerciseOption(\n        uint256 indexed epoch,\n        address indexed to,\n        ERC20 indexed paymentToken,\n        uint256 oTapTokenID,\n        uint256 amount\n    );\n    event NewEpoch(\n        uint256 indexed epoch,\n        uint256 extractedTAP,\n        uint256 epochTAPValuation\n    );\n    event ExitPosition(\n        uint256 indexed epoch,\n        uint256 indexed tokenId,\n        uint256 amount\n    );\n    event SetPaymentToken(ERC20 paymentToken, IOracle oracle, bytes oracleData);\n    event SetTapOracle(IOracle oracle, bytes oracleData);\n\n    // ==========\n    //    READ\n    // ==========\n\n    /// @notice Returns the details of an OTC deal for a given oTAP token ID and a payment token.\n    ///         The oracle uses the last peeked value, and not the latest one, so the payment amount may be different.\n    /// @param _oTAPTokenID The oTAP token ID\n    /// @param _paymentToken The payment token\n    /// @param _tapAmount The amount of TAP to be exchanged. If 0 it will use the full amount of TAP eligible for the deal\n    /// @return eligibleTapAmount The amount of TAP eligible for the deal\n    /// @return paymentTokenAmount The amount of payment tokens required for the deal\n    /// @return tapAmount The amount of TAP to be exchanged\n    function getOTCDealDetails(\n        uint256 _oTAPTokenID,\n        ERC20 _paymentToken,\n        uint256 _tapAmount\n    )\n        external\n        view\n        returns (\n            uint256 eligibleTapAmount,\n            uint256 paymentTokenAmount,\n            uint256 tapAmount\n        )\n    {\n        // Load data\n        (, TapOption memory oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        (bool isPositionActive, LockPosition memory tOLPLockPosition) = tOLP\n            .getLock(oTAPPosition.tOLP);\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[\n            _paymentToken\n        ];\n\n        // Check requirements\n        require(\n            paymentTokenOracle.oracle != IOracle(address(0)),\n            \"tOB: Payment token not supported\"\n        );\n\n        require(isPositionActive, \"tOB: Option expired\");\n\n        // Get eligible OTC amount\n        uint256 gaugeTotalForEpoch = singularityGauges[cachedEpoch][\n            tOLPLockPosition.sglAssetID\n        ];\n        eligibleTapAmount = muldiv(\n            tOLPLockPosition.amount,\n            gaugeTotalForEpoch,\n            tOLP.getTotalPoolDeposited(tOLPLockPosition.sglAssetID)\n        );\n        eligibleTapAmount -= oTAPCalls[_oTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        require(eligibleTapAmount >= _tapAmount, \"tOB: Too high\");\n\n        tapAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        require(tapAmount >= 1e18, \"tOB: Too low\");\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation; // Divided by TAP decimals\n        // Get payment token valuation\n        (, uint256 paymentTokenValuation) = paymentTokenOracle.oracle.peek(\n            paymentTokenOracle.oracleData\n        );\n        // Get payment token amount\n        paymentTokenAmount = _getDiscountedPaymentAmount(\n            otcAmountInUSD,\n            paymentTokenValuation,\n            oTAPPosition.discount,\n            _paymentToken.decimals()\n        );\n    }\n\n    // ===========\n    //    WRITE\n    // ===========\n\n    /// @notice Participate in twAMl voting and mint an oTAP position\n    /// @param _tOLPTokenID The tokenId of the tOLP position\n    function participate(\n        uint256 _tOLPTokenID\n    ) external returns (uint256 oTAPTokenID) {\n        // Compute option parameters\n        (bool isPositionActive, LockPosition memory lock) = tOLP.getLock(\n            _tOLPTokenID\n        );\n        require(isPositionActive, \"tOB: Position is not active\");\n        require(lock.lockDuration >= EPOCH_DURATION, \"tOB: Duration too short\");\n\n        TWAMLPool memory pool = twAML[lock.sglAssetID];\n\n        require(\n            tOLP.isApprovedOrOwner(msg.sender, _tOLPTokenID),\n            \"tOB: Not approved or owner\"\n        );\n\n        // Transfer tOLP position to this contract\n        tOLP.transferFrom(msg.sender, address(this), _tOLPTokenID);\n\n        uint256 magnitude = computeMagnitude(\n            uint256(lock.lockDuration),\n            pool.cumulative\n        );\n        bool divergenceForce;\n        uint256 target = computeTarget(dMIN, dMAX, magnitude, pool.cumulative);\n\n        // Participate in twAMl voting\n        bool hasVotingPower = lock.amount >=\n            computeMinWeight(pool.totalDeposited, MIN_WEIGHT_FACTOR);\n        if (hasVotingPower) {\n            pool.totalParticipants++; // Save participation\n            pool.averageMagnitude =\n                (pool.averageMagnitude + magnitude) /\n                pool.totalParticipants; // compute new average magnitude\n\n            // Compute and save new cumulative\n            divergenceForce = lock.lockDuration > pool.cumulative;\n            if (divergenceForce) {\n                pool.cumulative += pool.averageMagnitude;\n            } else {\n                if (pool.cumulative > pool.averageMagnitude) {\n                    pool.cumulative -= pool.averageMagnitude;\n                } else {\n                    pool.cumulative = 0;\n                }\n            }\n\n            // Save new weight\n            pool.totalDeposited += lock.amount;\n\n            twAML[lock.sglAssetID] = pool; // Save twAML participation\n            emit AMLDivergence(\n                epoch,\n                pool.cumulative,\n                pool.averageMagnitude,\n                pool.totalParticipants\n            ); // Register new voting power event\n        }\n        // Save twAML participation\n        participants[_tOLPTokenID] = Participation(\n            hasVotingPower,\n            divergenceForce,\n            pool.averageMagnitude\n        );\n\n        // Mint oTAP position\n        oTAPTokenID = oTAP.mint(\n            msg.sender,\n            lock.lockTime + lock.lockDuration,\n            uint128(target),\n            _tOLPTokenID\n        );\n        emit Participate(\n            epoch,\n            lock.sglAssetID,\n            pool.totalDeposited,\n            lock,\n            target\n        );\n    }\n\n    /// @notice Exit a twAML participation and delete the voting power if existing\n    /// @param _oTAPTokenID The tokenId of the oTAP position\n    function exitPosition(uint256 _oTAPTokenID) external {\n        require(oTAP.exists(_oTAPTokenID), \"tOB: oTAP position does not exist\");\n\n        // Load data\n        (, TapOption memory oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        (, LockPosition memory lock) = tOLP.getLock(oTAPPosition.tOLP);\n\n        require(\n            block.timestamp >= lock.lockTime + lock.lockDuration,\n            \"tOB: Lock not expired\"\n        );\n\n        Participation memory participation = participants[oTAPPosition.tOLP];\n\n        // Remove participation\n        if (participation.hasVotingPower) {\n            TWAMLPool memory pool = twAML[lock.sglAssetID];\n\n            if (participation.divergenceForce) {\n                if (pool.cumulative > pool.averageMagnitude) {\n                    pool.cumulative -= pool.averageMagnitude;\n                } else {\n                    pool.cumulative = 0;\n                }\n            } else {\n                pool.cumulative += pool.averageMagnitude;\n            }\n\n            pool.totalDeposited -= lock.amount;\n            pool.totalParticipants--;\n\n            twAML[lock.sglAssetID] = pool; // Save twAML exit\n            emit AMLDivergence(\n                epoch,\n                pool.cumulative,\n                pool.averageMagnitude,\n                pool.totalParticipants\n            ); // Register new voting power event\n        }\n\n        // Delete participation and burn oTAP position\n        address otapOwner = oTAP.ownerOf(_oTAPTokenID);\n        delete participants[oTAPPosition.tOLP];\n        oTAP.burn(_oTAPTokenID);\n\n        // Transfer position back to oTAP owner\n        tOLP.transferFrom(address(this), otapOwner, oTAPPosition.tOLP);\n\n        emit ExitPosition(epoch, oTAPPosition.tOLP, lock.amount);\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param _oTAPTokenID tokenId of the oTAP position, position must be active\n    /// @param _paymentToken Address of the payment token to use, must be whitelisted\n    /// @param _tapAmount Amount of TAP to exercise. If 0, the full amount is exercised\n    function exerciseOption(\n        uint256 _oTAPTokenID,\n        ERC20 _paymentToken,\n        uint256 _tapAmount\n    ) external {\n        // Load data\n        (, TapOption memory oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        (bool isPositionActive, LockPosition memory tOLPLockPosition) = tOLP\n            .getLock(oTAPPosition.tOLP);\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[\n            _paymentToken\n        ];\n\n        // Check requirements\n        require(\n            paymentTokenOracle.oracle != IOracle(address(0)),\n            \"tOB: Payment token not supported\"\n        );\n        require(\n            oTAP.isApprovedOrOwner(msg.sender, _oTAPTokenID),\n            \"tOB: Not approved or owner\"\n        );\n        require(isPositionActive, \"tOB: Option expired\");\n\n        // Get eligible OTC amount\n        uint256 gaugeTotalForEpoch = singularityGauges[cachedEpoch][\n            tOLPLockPosition.sglAssetID\n        ];\n        uint256 eligibleTapAmount = muldiv(\n            tOLPLockPosition.amount,\n            gaugeTotalForEpoch,\n            tOLP.getTotalPoolDeposited(tOLPLockPosition.sglAssetID)\n        );\n        eligibleTapAmount -= oTAPCalls[_oTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        require(eligibleTapAmount >= _tapAmount, \"tOB: Too high\");\n\n        uint256 chosenAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        require(chosenAmount >= 1e18, \"tOB: Too low\");\n        oTAPCalls[_oTAPTokenID][cachedEpoch] += chosenAmount; // Adds up exercised amount to current epoch\n\n        // Finalize the deal\n        _processOTCDeal(\n            _paymentToken,\n            paymentTokenOracle,\n            chosenAmount,\n            oTAPPosition.discount\n        );\n\n        emit ExerciseOption(\n            cachedEpoch,\n            msg.sender,\n            _paymentToken,\n            _oTAPTokenID,\n            chosenAmount\n        );\n    }\n\n    /// @notice Start a new epoch, extract TAP from the TapOFT contract,\n    ///         emit it to the active singularities and get the price of TAP for the epoch.\n    function newEpoch() external {\n        require(\n            block.timestamp >= lastEpochUpdate + EPOCH_DURATION,\n            \"tOB: too soon\"\n        );\n        uint256[] memory singularities = tOLP.getSingularities();\n        require(singularities.length > 0, \"tOB: No active singularities\");\n\n        // Update epoch info\n        lastEpochUpdate = block.timestamp;\n        epoch++;\n\n        // Extract TAP\n        uint256 epochTAP = tapOFT.emitForWeek();\n        _emitToGauges(epochTAP);\n\n        // Get epoch TAP valuation\n        (, epochTAPValuation) = tapOracle.get(tapOracleData);\n        emit NewEpoch(epoch, epochTAP, epochTAPValuation);\n    }\n\n    /// @notice Claim the Broker role of the oTAP contract\n    function oTAPBrokerClaim() external {\n        oTAP.brokerClaim();\n    }\n\n    // =========\n    //   OWNER\n    // =========\n\n    /// @notice Set the TapOFT Oracle address and data\n    /// @param _tapOracle The new TapOFT Oracle address\n    /// @param _tapOracleData The new TapOFT Oracle data\n    function setTapOracle(\n        IOracle _tapOracle,\n        bytes calldata _tapOracleData\n    ) external onlyOwner {\n        tapOracle = _tapOracle;\n        tapOracleData = _tapOracleData;\n\n        emit SetTapOracle(_tapOracle, _tapOracleData);\n    }\n\n    /// @notice Activate or deactivate a payment token\n    /// @dev set the oracle to address(0) to deactivate, expect the same decimal precision as TAP oracle\n    function setPaymentToken(\n        ERC20 _paymentToken,\n        IOracle _oracle,\n        bytes calldata _oracleData\n    ) external onlyOwner {\n        paymentTokens[_paymentToken].oracle = _oracle;\n        paymentTokens[_paymentToken].oracleData = _oracleData;\n\n        emit SetPaymentToken(_paymentToken, _oracle, _oracleData);\n    }\n\n    /// @notice Set the payment token beneficiary\n    /// @param _paymentTokenBeneficiary The new payment token beneficiary\n    function setPaymentTokenBeneficiary(\n        address _paymentTokenBeneficiary\n    ) external onlyOwner {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n    }\n\n    /// @notice Collect the payment tokens from the OTC deals\n    /// @param _paymentTokens The payment tokens to collect\n    function collectPaymentTokens(\n        address[] calldata _paymentTokens\n    ) external onlyOwner {\n        require(\n            paymentTokenBeneficiary != address(0),\n            \"tOB: Payment token beneficiary not set\"\n        );\n        uint256 len = _paymentTokens.length;\n\n        unchecked {\n            for (uint256 i = 0; i < len; ++i) {\n                ERC20 paymentToken = ERC20(_paymentTokens[i]);\n                paymentToken.transfer(\n                    paymentTokenBeneficiary,\n                    paymentToken.balanceOf(address(this))\n                );\n            }\n        }\n    }\n\n    // ============\n    //   INTERNAL\n    // ============\n\n    /// @notice Process the OTC deal, transfer the payment token to the broker and the TAP amount to the user\n    /// @param _paymentToken The payment token\n    /// @param _paymentTokenOracle The oracle of the payment token\n    /// @param tapAmount The amount of TAP that the user has to receive\n    /// @param discount The discount that the user has to apply to the OTC deal\n    function _processOTCDeal(\n        ERC20 _paymentToken,\n        PaymentTokenOracle memory _paymentTokenOracle,\n        uint256 tapAmount,\n        uint256 discount\n    ) internal {\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation;\n\n        // Get payment token valuation\n        (, uint256 paymentTokenValuation) = _paymentTokenOracle.oracle.get(\n            _paymentTokenOracle.oracleData\n        );\n\n        // Calculate payment amount and initiate the transfers\n        uint256 discountedPaymentAmount = _getDiscountedPaymentAmount(\n            otcAmountInUSD,\n            paymentTokenValuation,\n            discount,\n            _paymentToken.decimals()\n        );\n\n        _paymentToken.transferFrom(\n            msg.sender,\n            address(this),\n            discountedPaymentAmount\n        );\n        tapOFT.extractTAP(msg.sender, tapAmount);\n    }\n\n    /// @notice Computes the discounted payment amount for a given OTC amount in USD\n    /// @param _otcAmountInUSD The OTC amount in USD, 18 decimals\n    /// @param _paymentTokenValuation The payment token valuation in USD, 18 decimals\n    /// @param _discount The discount in BPS\n    /// @param _paymentTokenDecimals The payment token decimals\n    /// @return paymentAmount The discounted payment amount\n    function _getDiscountedPaymentAmount(\n        uint256 _otcAmountInUSD,\n        uint256 _paymentTokenValuation,\n        uint256 _discount,\n        uint256 _paymentTokenDecimals\n    ) internal pure returns (uint256 paymentAmount) {\n        // Calculate payment amount\n        uint256 rawPaymentAmount = _otcAmountInUSD / _paymentTokenValuation;\n        paymentAmount =\n            rawPaymentAmount -\n            muldiv(rawPaymentAmount, _discount, 100e4); // 1e4 is discount decimals, 100 is discount percentage\n        paymentAmount = paymentAmount / (10 ** (18 - _paymentTokenDecimals));\n    }\n\n    /// @notice Emit TAP to the gauges equitably\n    function _emitToGauges(uint256 _epochTAP) internal {\n        SingularityPool[] memory sglPools = tOLP.getSingularityPools();\n        uint256 totalWeights = tOLP.totalSingularityPoolWeights();\n\n        uint256 len = sglPools.length;\n        unchecked {\n            for (uint256 i = 0; i < len; ++i) {\n                uint256 currentPoolWeight = sglPools[i].poolWeight;\n                uint256 quotaPerSingularity = muldiv(\n                    currentPoolWeight,\n                    _epochTAP,\n                    totalWeights\n                );\n                singularityGauges[epoch][\n                    sglPools[i].sglAssetID\n                ] = quotaPerSingularity;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tokens/TapOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"./BaseTapOFT.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title Tapioca OFT token\n/// @notice OFT compatible TAP token\n/// @dev Latest size: 17.663  KiB\n/// @dev Emissions E(x)= E(x-1) - E(x-1) * D with E being total supply a x week, and D the initial decay rate.\n///      More info can be found here https://docs.tapioca.xyz/tapioca/token-economy/tap-distribution-and-issuance\ncontract TapOFT is BaseTapOFT, ERC20Permit {\n    // ==========\n    // *DATA*\n    // ==========\n\n    //  Allocation:\n    // =========\n    // * DSO: 53,313,405\n    // * DAO: 8m\n    // * Contributors: 15m\n    // * Early supporters: 3,686,595\n    // * Supporters: 12.5m\n    // * LBP: 5m\n    // * Airdrop: 2.5m\n    // == 100M ==\n    uint256 public constant INITIAL_SUPPLY = 46_686_595 * 1e18; // Everything minus DSO\n    uint256 public dso_supply = 53_313_405 * 1e18;\n\n    /// @notice the a parameter used in the emission function;\n    uint256 constant decay_rate = 8800000000000000; // 0.88%\n    uint256 constant DECAY_RATE_DECIMAL = 1e18;\n\n    /// @notice seconds in a week\n    uint256 public constant WEEK = 604800;\n\n    /// @notice starts time for emissions\n    /// @dev initialized in the constructor with block.timestamp\n    uint256 public immutable emissionsStartTime;\n\n    /// @notice returns the amount of emitted TAP for a specific week\n    /// @dev week is computed using (timestamp - emissionStartTime) / WEEK\n    mapping(uint256 => uint256) public emissionForWeek;\n\n    /// @notice returns the amount minted for a specific week\n    /// @dev week is computed using (timestamp - emissionStartTime) / WEEK\n    mapping(uint256 => uint256) public mintedInWeek;\n\n    /// @notice returns the minter address\n    address public minter;\n\n    /// @notice LayerZero governance chain identifier\n    uint256 public governanceChainIdentifier;\n\n    /// @notice returns the pause state of the contract\n    bool public paused;\n\n    // ==========\n    // *EVENTS*\n    // ==========\n    /// @notice event emitted when a new minter is set\n    event MinterUpdated(address indexed _old, address indexed _new);\n    /// @notice event emitted when a new emission is called\n    event Emitted(uint256 week, uint256 amount);\n    /// @notice event emitted when new TAP is minted\n    event Minted(address indexed _by, address indexed _to, uint256 _amount);\n    /// @notice event emitted when new TAP is burned\n    event Burned(address indexed _from, uint256 _amount);\n    /// @notice event emitted when the governance chain identifier is updated\n    event GovernanceChainIdentifierUpdated(uint256 _old, uint256 _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(bool oldState, bool newState);\n\n    modifier notPaused() {\n        require(!paused, \"TAP: paused\");\n        _;\n    }\n\n    // ==========\n    // * METHODS *\n    // ==========\n    /// @notice Creates a new TAP OFT type token\n    /// @dev The initial supply of 100M is not minted here as we have the wrap method\n    /// @param _lzEndpoint the layer zero address endpoint deployed on the current chain\n    /// @param _contributors address of the  contributors. 15m\n    /// @param _earlySupporters address of early supporters. 3,686,595\n    /// @param _supporters address of supporters. 12.5m\n    /// @param _lbp address of the LBP. 5m\n    /// @param _dao address of the DAO. 8m\n    /// @param _airdrop address of the airdrop contract. 2.5m\n    /// @param _governanceChainId LayerZero governance chain identifier\n    /// @param _conservator address of the conservator/owner\n    constructor(\n        address _lzEndpoint,\n        address _contributors,\n        address _earlySupporters,\n        address _supporters,\n        address _lbp,\n        address _dao,\n        address _airdrop,\n        uint256 _governanceChainId,\n        address _conservator\n    ) BaseTapOFT(\"TapOFT\", \"TAP\", 8, _lzEndpoint) ERC20Permit(\"TapOFT\") {\n        require(_lzEndpoint != address(0), \"LZ endpoint not valid\");\n        governanceChainIdentifier = _governanceChainId;\n        if (_getChainId() == governanceChainIdentifier) {\n            _mint(_contributors, 1e18 * 15_000_000);\n            _mint(_earlySupporters, 1e18 * 3_686_595);\n            _mint(_supporters, 1e18 * 12_500_000);\n            _mint(_lbp, 1e18 * 5_000_000);\n            _mint(_dao, 1e18 * 8_000_000);\n            _mint(_airdrop, 1e18 * 2_500_000);\n            require(\n                totalSupply() == INITIAL_SUPPLY,\n                \"initial supply not valid\"\n            );\n        }\n        emissionsStartTime = block.timestamp;\n\n        transferOwnership(_conservator);\n    }\n\n    ///-- Owner methods --\n    /// @notice sets the governance chain identifier\n    /// @param _identifier LayerZero chain identifier\n    function setGovernanceChainIdentifier(\n        uint256 _identifier\n    ) external onlyOwner {\n        emit GovernanceChainIdentifierUpdated(\n            governanceChainIdentifier,\n            _identifier\n        );\n        governanceChainIdentifier = _identifier;\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @param val the new value\n    function updatePause(bool val) external onlyOwner {\n        require(val != paused, \"TAP: same state\");\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    /// @notice sets a new minter address\n    /// @param _minter the new address\n    function setMinter(address _minter) external onlyOwner {\n        require(_minter != address(0), \"address not valid\");\n        emit MinterUpdated(minter, _minter);\n        minter = _minter;\n    }\n\n    //-- View methods --\n    /// @notice returns token's decimals\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    /// @notice Returns the current week given a timestamp\n    function timestampToWeek(\n        uint256 timestamp\n    ) external view returns (uint256) {\n        if (timestamp == 0) {\n            timestamp = block.timestamp;\n        }\n        if (timestamp < emissionsStartTime) return 0;\n\n        return _timestampToWeek(timestamp);\n    }\n\n    /// @notice Returns the current week\n    function getCurrentWeek() external view returns (uint256) {\n        return _timestampToWeek(block.timestamp);\n    }\n\n    /// @notice Returns the current week emission\n    function getCurrentWeekEmission() external view returns (uint256) {\n        return emissionForWeek[_timestampToWeek(block.timestamp)];\n    }\n\n    ///-- Write methods --\n    /// @notice Emit the TAP for the current week\n    /// @return the emitted amount\n    function emitForWeek() external notPaused returns (uint256) {\n        require(_getChainId() == governanceChainIdentifier, \"chain not valid\");\n\n        uint256 week = _timestampToWeek(block.timestamp);\n        if (emissionForWeek[week] > 0) return 0;\n\n        // Update DSO supply from last minted emissions\n        dso_supply -= mintedInWeek[week - 1];\n\n        // Compute unclaimed emission from last week and add it to the current week emission\n        uint256 unclaimed = emissionForWeek[week - 1] - mintedInWeek[week - 1];\n        uint256 emission = uint256(_computeEmission());\n        emission += unclaimed;\n        emissionForWeek[week] = emission;\n\n        emit Emitted(week, emission);\n\n        return emission;\n    }\n\n    /// @notice extracts from the minted TAP\n    /// @param _to Address to send the minted TAP to\n    /// @param _amount TAP amount\n    function extractTAP(address _to, uint256 _amount) external notPaused {\n        require(msg.sender == minter, \"unauthorized\");\n        require(_amount > 0, \"amount not valid\");\n\n        uint256 week = _timestampToWeek(block.timestamp);\n        require(emissionForWeek[week] >= _amount, \"exceeds allowable amount\");\n        _mint(_to, _amount);\n        mintedInWeek[week] += _amount;\n        emit Minted(msg.sender, _to, _amount);\n    }\n\n    /// @notice burns TAP\n    /// @param _amount TAP amount\n    function removeTAP(uint256 _amount) external notPaused {\n        _burn(msg.sender, _amount);\n        emit Burned(msg.sender, _amount);\n    }\n\n    ///-- Internal methods --\n    function _timestampToWeek(\n        uint256 timestamp\n    ) internal view returns (uint256) {\n        return ((timestamp - emissionsStartTime) / WEEK) + 1; // Starts at week 1\n    }\n\n    ///-- Private methods --\n    /// @notice Return the current chain ID.\n    /// @dev Useful for testing.\n    function _getChainId() private view returns (uint256) {\n        return block.chainid;\n    }\n\n    /// @notice returns the available emissions for a given supply\n    function _computeEmission() internal view returns (uint256 result) {\n        result = (dso_supply * decay_rate) / DECAY_RATE_DECIMAL;\n    }\n}"
    }
  ]
}