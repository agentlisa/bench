{
  "Title": "M-3: _validateAndGetPrice() doesn't check If Arbitrum sequencer is down in Chainlink feeds",
  "Content": "# Issue M-3: _validateAndGetPrice() doesn't check If Arbitrum sequencer is down in Chainlink feeds \n\nSource: https://github.com/sherlock-audit/2023-02-bond-judging/issues/1 \n\n## Found by \nAvci\n\n## Summary\nWhen utilizing Chainlink in L2 chains like Arbitrum, it's important to ensure that the prices provided are not falsely perceived as fresh, even when the sequencer is down. This vulnerability could potentially be exploited by malicious actors to gain an unfair advantage.\n\n## Vulnerability Detail\nThere is no check: \n```soldity\nsolidity function _validateAndGetPrice(AggregatorV2V3Interface feed_, uint48 updateThreshold_)\n        internal\n        view\n        returns (uint256)\n    {\n        // Get latest round data from feed\n        (uint80 roundId, int256 priceInt, , uint256 updatedAt, uint80 answeredInRound) = feed_\n            .latestRoundData();\n        // @audit check if Arbitrum L2 sequencer is down in Chainlink feeds: medium\n        // Validate chainlink price feed data\n        // 1. Answer should be greater than zero\n        // 2. Updated at timestamp should be within the update threshold\n        // 3. Answered in round ID should be the same as the round ID\n        if (\n            priceInt <= 0 ||\n            updatedAt < block.timestamp - uint256(updateThreshold_) ||\n            answeredInRound != roundId\n        ) revert BondOracle_BadFeed(address(feed_));\n        return uint256(priceInt);\n    }\n```\n## Impact\ncould potentially be exploited by malicious actors to gain an unfair advantage.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-bond-0xdanial/blob/0d6f979c9f361bc1101f429b3bb09264577b9a71/bonds/src/BondChainlinkOracle.sol#L129\n## Tool used\n\nManual Review\n\n## Recommendation\ncode example of Chainlink:\nhttps://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code \n\n\n## Discussion\n\n**Oighty**\n\nAgree this should be fixed for using the Chainlink Oracle Contract on L2s. I think the best way to handle is to have a mainnet version of the contract (as is) and L2 version of the contract which implements the sequencer feed check.\n\n**UsmannK**\n\nEscalate for 10 USDC.\n\nWatson states that the arbitrum sequencer may temporarily go down and cause stale prices to be read from the oracle. This is incorrect; the arbitrum sequencer going down cannot result in stale prices to be accepted. \n\nStale prices will have an old `updatedAt` timestamp and be rejected by the following code:\nhttps://github.com/sherlock-audit/2023-02-bond/blob/8a326a4b39fdaf9eaf5911cfd3e9676a83c24a58/bonds/src/BondChainlinkOracle.sol#L141-L146\n\n```solidity\n        // Validate chainlink price feed data\n        // 1. Answer should be greater than zero\n        // 2. Updated at timestamp should be within the update threshold\n        // 3. Answered in round ID should be the same as the round ID\n        if (\n            priceInt <= 0 ||\n            updatedAt < block.timestamp - uint256(updateThreshold_) ||\n            answeredInRound != roundId\n        ) revert BondOracle_BadFeed(address(feed_));\n```\n\nThe watson's link (https://docs.chain.link/data-feeds/l2-sequencer-feeds#arbitrum) is actually a metadata feed about historical uptime/downtime data that is not related to the supposed issue.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> Watson states that the arbitrum sequencer may temporarily go down and cause stale prices to be read from the oracle. This is incorrect; the arbitrum sequencer going down cannot result in stale prices to be accepted. \n> \n> Stale prices will have an old `updatedAt` timestamp and be rejected by the following code:\n> https://github.com/sherlock-audit/2023-02-bond/blob/8a326a4b39fdaf9eaf5911cfd3e9676a83c24a58/bonds/src/BondChainlinkOracle.sol#L141-L146\n> \n> ```solidity\n>         // Validate chainlink price feed data\n>         // 1. Answer should be greater than zero\n>         // 2. Updated at timestamp should be within the update threshold\n>         // 3. Answered in round ID should be the same as the round ID\n>         if (\n>             priceInt <= 0 ||\n>             updatedAt < block.timestamp - uint256(updateThreshold_) ||\n>             answeredInRound != roundId\n>         ) revert BondOracle_BadFeed(address(feed_));\n> ```\n> \n> The watson's link (https://docs.chain.link/data-feeds/l2-sequencer-feeds#arbitrum) is actually a metadata feed about historical uptime/downtime data that is not related to the supposed issue.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Oighty**\n\nIssue fixed here: https://github.com/Bond-Protocol/bonds/pull/53\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/pull/53\n\n**hrishibhat**\n\nEscalation rejected\n\nUpdating the escalation resolution.  \nConsidering this issue as a valid medium, additional sponsor comments:\n> If it updates again within the update threshold. The feeds typically can update several times within a threshold period if the price is moving a lot\nwhen the sequencer is down, the new price won't be reported to the chain. the feed on the L2 will return the value it had when it went down\n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Updating the escalation resolution.  \n> Considering this issue as a valid medium, additional sponsor comments:\n> > If it updates again within the update threshold. The feeds typically can update several times within a threshold period if the price is moving a lot\n> when the sequencer is down, the new price won't be reported to the chain. the feed on the L2 will return the value it had when it went down\n> \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/53",
  "Code": [
    {
      "filename": "bonds/src/BondChainlinkOracle.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {AggregatorV2V3Interface} from \"src/interfaces/AggregatorV2V3Interface.sol\";\nimport \"src/bases/BondBaseOracle.sol\";\nimport {FullMath} from \"src/lib/FullMath.sol\";\n\n/// @title Bond Chainlink Oracle\n/// @notice Bond Chainlink Oracle Sample Contract\ncontract BondChainlinkOracle is BondBaseOracle {\n    using FullMath for uint256;\n\n    /* ========== ERRORS ========== */\n    error BondOracle_BadFeed(address feed_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @dev Parameters to configure price feeds for a pair of tokens. There are 4 cases:\n    /// 1. Single feed -> Use when there is a price feed for the exact asset pair in quote\n    ///     tokens per payout token (e.g. OHM/ETH which provides the number of ETH (qt) per OHM (pt))\n    ///\n    ///     Params: numeratorFeed, numeratorUpdateThreshold, 0, 0, decimals, false\n    ///\n    /// 2. Single feed inverse -> Use when there is a price for the opposite of your asset\n    ///     pair in quote tokens per payout token (e.g. OHM/ETH which provides the number\n    ///     of ETH per OHM, but you need the number of OHM (qt) per ETH (pt)).\n    ///\n    ///     Params: numeratorFeed, numeratorUpdateThreshold, 0, 0, decimals, true\n    ///\n    /// 3. Double feed mul -> Use when two price feeds are required to get the price of the\n    ///      desired asset pair in quote tokens per payout token. For example, if you need the\n    ///      price of OHM/USD, but there is only a price feed for OHM/ETH and ETH/USD, then\n    ///      multiplying the two feeds will give you the price of OHM/USD.\n    ///\n    ///     Params: numeratorFeed, numeratorUpdateThreshold, denominatorFeed, denominatorUpdateThreshold, decimals, false\n    ///\n    /// 4. Double feed div -> Use when two price feeds are required to get the price of the\n    ///      desired asset pair in quote tokens per payout token. For example, if you need the\n    ///      price of OHM/DAI, but there is only a price feed for OHM/ETH and DAI/ETH, then\n    ///      dividing the two feeds will give you the price of OHM/DAI.\n    ///\n    ///     Params: numeratorFeed, numeratorUpdateThreshold, denominatorFeed, denominatorUpdateThreshold, decimals, true\n    ///\n    struct PriceFeedParams {\n        AggregatorV2V3Interface numeratorFeed; // address of the numerator (or first) price feed\n        uint48 numeratorUpdateThreshold; // update threshold for the numerator price feed, will revert if data is older than block.timestamp - this\n        AggregatorV2V3Interface denominatorFeed; // address of the denominator (or second) price feed. if zero address, then only use numerator feed\n        uint48 denominatorUpdateThreshold; // update threshold for the denominator price feed, will revert if data is older than block.timestamp - this\n        uint8 decimals; // number of decimals that the price should be scaled to\n        bool div; // if true, then the numerator feed is divided by the denominator feed, otherwise multiplied. if only one feed is used, then div = false is standard and div = true is the inverse.\n    }\n\n    mapping(ERC20 => mapping(ERC20 => PriceFeedParams)) public priceFeedParams;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address aggregator_, address[] memory auctioneers_)\n        BondBaseOracle(aggregator_, auctioneers_)\n    {}\n\n    /* ========== PRICE ========== */\n\n    function _currentPrice(ERC20 quoteToken_, ERC20 payoutToken_)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        PriceFeedParams memory params = priceFeedParams[quoteToken_][payoutToken_];\n\n        // Get price from feed\n        if (address(params.denominatorFeed) == address(0)) {\n            return _getOneFeedPrice(params);\n        } else {\n            return _getTwoFeedPrice(params);\n        }\n    }\n\n    function _getOneFeedPrice(PriceFeedParams memory params_) internal view returns (uint256) {\n        // Get price from feed\n        uint256 price = _validateAndGetPrice(\n            params_.numeratorFeed,\n            params_.numeratorUpdateThreshold\n        );\n\n        // Scale price and return\n        return\n            params_.div\n                ? (10**params_.decimals).mulDiv(10**(params_.numeratorFeed.decimals()), price)\n                : price.mulDiv(10**params_.decimals, 10**(params_.numeratorFeed.decimals()));\n    }\n\n    function _getTwoFeedPrice(PriceFeedParams memory params_) internal view returns (uint256) {\n        // Get decimal value scale factor\n        uint8 exponent;\n        uint8 denomDecimals = params_.denominatorFeed.decimals();\n        uint8 numDecimals = params_.numeratorFeed.decimals();\n        if (params_.div) {\n            if (params_.decimals + denomDecimals < numDecimals) revert BondOracle_InvalidParams();\n            exponent =\n                params_.decimals +\n                params_.denominatorFeed.decimals() -\n                params_.numeratorFeed.decimals();\n        } else {\n            if (numDecimals + denomDecimals < params_.decimals) revert BondOracle_InvalidParams();\n            exponent =\n                params_.denominatorFeed.decimals() +\n                params_.numeratorFeed.decimals() -\n                params_.decimals;\n        }\n\n        // Get prices from feeds\n        uint256 numeratorPrice = _validateAndGetPrice(\n            params_.numeratorFeed,\n            params_.numeratorUpdateThreshold\n        );\n        uint256 denominatorPrice = _validateAndGetPrice(\n            params_.denominatorFeed,\n            params_.denominatorUpdateThreshold\n        );\n\n        // Calculate and scale price\n        return\n            params_.div\n                ? numeratorPrice.mulDiv(10**exponent, denominatorPrice)\n                : numeratorPrice.mulDiv(denominatorPrice, 10**exponent);\n    }\n\n    function _validateAndGetPrice(AggregatorV2V3Interface feed_, uint48 updateThreshold_)\n        internal\n        view\n        returns (uint256)\n    {\n        // Get latest round data from feed\n        (uint80 roundId, int256 priceInt, , uint256 updatedAt, uint80 answeredInRound) = feed_\n            .latestRoundData();\n\n        // Validate chainlink price feed data\n        // 1. Answer should be greater than zero\n        // 2. Updated at timestamp should be within the update threshold\n        // 3. Answered in round ID should be the same as the round ID\n        if (\n            priceInt <= 0 ||\n            updatedAt < block.timestamp - uint256(updateThreshold_) ||\n            answeredInRound != roundId\n        ) revert BondOracle_BadFeed(address(feed_));\n        return uint256(priceInt);\n    }\n\n    /* ========== DECIMALS ========== */\n\n    function _decimals(ERC20 quoteToken_, ERC20 payoutToken_)\n        internal\n        view\n        override\n        returns (uint8)\n    {\n        return priceFeedParams[quoteToken_][payoutToken_].decimals;\n    }\n\n    /* ========== ADMIN ========== */\n\n    function _setPair(\n        ERC20 quoteToken_,\n        ERC20 payoutToken_,\n        bool supported_,\n        bytes memory oracleData_\n    ) internal override {\n        if (supported_) {\n            // Decode oracle data into PriceFeedParams struct\n            PriceFeedParams memory params = abi.decode(oracleData_, (PriceFeedParams));\n\n            // Feed decimals\n            uint8 numerDecimals = params.numeratorFeed.decimals();\n            uint8 denomDecimals = address(params.denominatorFeed) != address(0)\n                ? params.denominatorFeed.decimals()\n                : 0;\n\n            // Validate params\n            if (\n                address(params.numeratorFeed) == address(0) ||\n                params.numeratorUpdateThreshold < uint48(1 hours) ||\n                params.numeratorUpdateThreshold > uint48(7 days) ||\n                params.decimals < 6 ||\n                params.decimals > 18 ||\n                numerDecimals < 6 ||\n                numerDecimals > 18 ||\n                (address(params.denominatorFeed) == address(0) &&\n                    !params.div &&\n                    params.decimals < numerDecimals) ||\n                (address(params.denominatorFeed) != address(0) &&\n                    (params.denominatorUpdateThreshold < uint48(1 hours) ||\n                        params.denominatorUpdateThreshold > uint48(7 days) ||\n                        denomDecimals < 6 ||\n                        denomDecimals > 18 ||\n                        (params.div && params.decimals + denomDecimals < numerDecimals) ||\n                        (!params.div && numerDecimals + denomDecimals < params.decimals)))\n            ) revert BondOracle_InvalidParams();\n\n            // Store params for token pair\n            priceFeedParams[quoteToken_][payoutToken_] = params;\n        } else {\n            // Delete params for token pair\n            delete priceFeedParams[quoteToken_][payoutToken_];\n        }\n    }\n}"
    },
    {
      "filename": "bonds/src/BondChainlinkOracle.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {AggregatorV2V3Interface} from \"src/interfaces/AggregatorV2V3Interface.sol\";\nimport \"src/bases/BondBaseOracle.sol\";\nimport {FullMath} from \"src/lib/FullMath.sol\";\n\n/// @title Bond Chainlink Oracle\n/// @notice Bond Chainlink Oracle Sample Contract\ncontract BondChainlinkOracle is BondBaseOracle {\n    using FullMath for uint256;\n\n    /* ========== ERRORS ========== */\n    error BondOracle_BadFeed(address feed_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @dev Parameters to configure price feeds for a pair of tokens. There are 4 cases:\n    /// 1. Single feed -> Use when there is a price feed for the exact asset pair in quote\n    ///     tokens per payout token (e.g. OHM/ETH which provides the number of ETH (qt) per OHM (pt))\n    ///\n    ///     Params: numeratorFeed, numeratorUpdateThreshold, 0, 0, decimals, false\n    ///\n    /// 2. Single feed inverse -> Use when there is a price for the opposite of your asset\n    ///     pair in quote tokens per payout token (e.g. OHM/ETH which provides the number\n    ///     of ETH per OHM, but you need the number of OHM (qt) per ETH (pt)).\n    ///\n    ///     Params: numeratorFeed, numeratorUpdateThreshold, 0, 0, decimals, true\n    ///\n    /// 3. Double feed mul -> Use when two price feeds are required to get the price of the\n    ///      desired asset pair in quote tokens per payout token. For example, if you need the\n    ///      price of OHM/USD, but there is only a price feed for OHM/ETH and ETH/USD, then\n    ///      multiplying the two feeds will give you the price of OHM/USD.\n    ///\n    ///     Params: numeratorFeed, numeratorUpdateThreshold, denominatorFeed, denominatorUpdateThreshold, decimals, false\n    ///\n    /// 4. Double feed div -> Use when two price feeds are required to get the price of the\n    ///      desired asset pair in quote tokens per payout token. For example, if you need the\n    ///      price of OHM/DAI, but there is only a price feed for OHM/ETH and DAI/ETH, then\n    ///      dividing the two feeds will give you the price of OHM/DAI.\n    ///\n    ///     Params: numeratorFeed, numeratorUpdateThreshold, denominatorFeed, denominatorUpdateThreshold, decimals, true\n    ///\n    struct PriceFeedParams {\n        AggregatorV2V3Interface numeratorFeed; // address of the numerator (or first) price feed\n        uint48 numeratorUpdateThreshold; // update threshold for the numerator price feed, will revert if data is older than block.timestamp - this\n        AggregatorV2V3Interface denominatorFeed; // address of the denominator (or second) price feed. if zero address, then only use numerator feed\n        uint48 denominatorUpdateThreshold; // update threshold for the denominator price feed, will revert if data is older than block.timestamp - this\n        uint8 decimals; // number of decimals that the price should be scaled to\n        bool div; // if true, then the numerator feed is divided by the denominator feed, otherwise multiplied. if only one feed is used, then div = false is standard and div = true is the inverse.\n    }\n\n    mapping(ERC20 => mapping(ERC20 => PriceFeedParams)) public priceFeedParams;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address aggregator_, address[] memory auctioneers_)\n        BondBaseOracle(aggregator_, auctioneers_)\n    {}\n\n    /* ========== PRICE ========== */\n\n    function _currentPrice(ERC20 quoteToken_, ERC20 payoutToken_)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        PriceFeedParams memory params = priceFeedParams[quoteToken_][payoutToken_];\n\n        // Get price from feed\n        if (address(params.denominatorFeed) == address(0)) {\n            return _getOneFeedPrice(params);\n        } else {\n            return _getTwoFeedPrice(params);\n        }\n    }\n\n    function _getOneFeedPrice(PriceFeedParams memory params_) internal view returns (uint256) {\n        // Get price from feed\n        uint256 price = _validateAndGetPrice(\n            params_.numeratorFeed,\n            params_.numeratorUpdateThreshold\n        );\n\n        // Scale price and return\n        return\n            params_.div\n                ? (10**params_.decimals).mulDiv(10**(params_.numeratorFeed.decimals()), price)\n                : price.mulDiv(10**params_.decimals, 10**(params_.numeratorFeed.decimals()));\n    }\n\n    function _getTwoFeedPrice(PriceFeedParams memory params_) internal view returns (uint256) {\n        // Get decimal value scale factor\n        uint8 exponent;\n        uint8 denomDecimals = params_.denominatorFeed.decimals();\n        uint8 numDecimals = params_.numeratorFeed.decimals();\n        if (params_.div) {\n            if (params_.decimals + denomDecimals < numDecimals) revert BondOracle_InvalidParams();\n            exponent =\n                params_.decimals +\n                params_.denominatorFeed.decimals() -\n                params_.numeratorFeed.decimals();\n        } else {\n            if (numDecimals + denomDecimals < params_.decimals) revert BondOracle_InvalidParams();\n            exponent =\n                params_.denominatorFeed.decimals() +\n                params_.numeratorFeed.decimals() -\n                params_.decimals;\n        }\n\n        // Get prices from feeds\n        uint256 numeratorPrice = _validateAndGetPrice(\n            params_.numeratorFeed,\n            params_.numeratorUpdateThreshold\n        );\n        uint256 denominatorPrice = _validateAndGetPrice(\n            params_.denominatorFeed,\n            params_.denominatorUpdateThreshold\n        );\n\n        // Calculate and scale price\n        return\n            params_.div\n                ? numeratorPrice.mulDiv(10**exponent, denominatorPrice)\n                : numeratorPrice.mulDiv(denominatorPrice, 10**exponent);\n    }\n\n    function _validateAndGetPrice(AggregatorV2V3Interface feed_, uint48 updateThreshold_)\n        internal\n        view\n        returns (uint256)\n    {\n        // Get latest round data from feed\n        (uint80 roundId, int256 priceInt, , uint256 updatedAt, uint80 answeredInRound) = feed_\n            .latestRoundData();\n\n        // Validate chainlink price feed data\n        // 1. Answer should be greater than zero\n        // 2. Updated at timestamp should be within the update threshold\n        // 3. Answered in round ID should be the same as the round ID\n        if (\n            priceInt <= 0 ||\n            updatedAt < block.timestamp - uint256(updateThreshold_) ||\n            answeredInRound != roundId\n        ) revert BondOracle_BadFeed(address(feed_));\n        return uint256(priceInt);\n    }\n\n    /* ========== DECIMALS ========== */\n\n    function _decimals(ERC20 quoteToken_, ERC20 payoutToken_)\n        internal\n        view\n        override\n        returns (uint8)\n    {\n        return priceFeedParams[quoteToken_][payoutToken_].decimals;\n    }\n\n    /* ========== ADMIN ========== */\n\n    function _setPair(\n        ERC20 quoteToken_,\n        ERC20 payoutToken_,\n        bool supported_,\n        bytes memory oracleData_\n    ) internal override {\n        if (supported_) {\n            // Decode oracle data into PriceFeedParams struct\n            PriceFeedParams memory params = abi.decode(oracleData_, (PriceFeedParams));\n\n            // Feed decimals\n            uint8 numerDecimals = params.numeratorFeed.decimals();\n            uint8 denomDecimals = address(params.denominatorFeed) != address(0)\n                ? params.denominatorFeed.decimals()\n                : 0;\n\n            // Validate params\n            if (\n                address(params.numeratorFeed) == address(0) ||\n                params.numeratorUpdateThreshold < uint48(1 hours) ||\n                params.numeratorUpdateThreshold > uint48(7 days) ||\n                params.decimals < 6 ||\n                params.decimals > 18 ||\n                numerDecimals < 6 ||\n                numerDecimals > 18 ||\n                (address(params.denominatorFeed) == address(0) &&\n                    !params.div &&\n                    params.decimals < numerDecimals) ||\n                (address(params.denominatorFeed) != address(0) &&\n                    (params.denominatorUpdateThreshold < uint48(1 hours) ||\n                        params.denominatorUpdateThreshold > uint48(7 days) ||\n                        denomDecimals < 6 ||\n                        denomDecimals > 18 ||\n                        (params.div && params.decimals + denomDecimals < numerDecimals) ||\n                        (!params.div && numerDecimals + denomDecimals < params.decimals)))\n            ) revert BondOracle_InvalidParams();\n\n            // Store params for token pair\n            priceFeedParams[quoteToken_][payoutToken_] = params;\n        } else {\n            // Delete params for token pair\n            delete priceFeedParams[quoteToken_][payoutToken_];\n        }\n    }\n}"
    }
  ]
}