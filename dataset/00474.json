{
  "Title": "M-1: Depositing to EigenLayer can revert due to round downs in converting shares<->assets",
  "Content": "# Issue M-1: Depositing to EigenLayer can revert due to round downs in converting shares<->assets \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/9 \n\n## Found by \n0xkaden, Bauer, Drynooo, KupiaSec, Tricko, hash, kennedy1030, klaus, lemonmon, mstpr-brainbot, shaka\n## Summary\nWhen the underlying tokens deposited from depositPool to EigenLayer strategy, there are bunch of converting operations done which rounds down the solution at some point and the require check reverts hence, the depositing might not be possible due to this small round down issue. \n## Vulnerability Detail\nBest to go for this is an example, so let's do it.\n\nAssume the deposit pool has 111 * 1e18 stETH waiting for rebalance to be deposited to EigenLayer and there is only 1 operator with 1 strategy allowed which is the EigenLayers stETH strategy. \nAlso, assume the EigenLayer has 3333 * 1e18 stETH in total and 3232  * 1e18 shares in supply. Also, note that the EigenLayer uses virtual shares offset which is 1e3.\n\nNow, let's say there is no withdrawal queue to ease the complexity of the issue and rebalance is called and the balance in the deposit pool will be forwarded to EigenLayer strategy as follows:\n```solidity\nfunction rebalance(address asset) external checkRebalanceDelayMet(asset) {\n        .\n        .\n        // Deposit remaining assets into EigenLayer.\n        (uint256 sharesReceived, bool isDepositCapped) = depositPool().depositBalanceIntoEigenLayer(asset);\n        .\n    }\n```\n\nThen, the `depositBalanceIntoEigenLayer` will trigger the `OperatorOperations.depositTokenToOperators` function as follows:\n```solidity \nfunction depositBalanceIntoEigenLayer(address asset) external onlyCoordinator returns (uint256, bool) {\n        uint256 amountToDeposit = asset.getSelfBalance();\n        if (amountToDeposit == 0) return (0, false);\n        .\n        .\n        address strategy = assetRegistry().getAssetStrategy(asset);\n        uint256 sharesToAllocate = assetRegistry().convertToSharesFromAsset(asset, amountToDeposit);\n        // @review library called\n        -> return (OperatorOperations.depositTokenToOperators(operatorRegistry(), asset, strategy, sharesToAllocate), isDepositCapped);\n    }\n```\nAs we can see in the above snippet, the underlying tokens to be deposited which is 111 * 1e18 stETH in our example will be converted to EigenLayer strategy shares via `assetRegistry().convertToSharesFromAsset`\n\nNow, how does EigenLayer calculates how much shares to be minted given an underlying token deposit is as follows:\n```solidity\nfunction underlyingToSharesView(uint256 amountUnderlying) public view virtual returns (uint256) {\n        // account for virtual shares and balance\n        uint256 virtualTotalShares = totalShares + SHARES_OFFSET;\n        uint256 virtualTokenBalance = _tokenBalance() + BALANCE_OFFSET;\n        // calculate ratio based on virtual shares and balance, being careful to multiply before dividing\n        return (amountUnderlying * virtualTotalShares) / virtualTokenBalance;\n    }\n```\n\nNow, let's plugin our numbers in the example to calculate how much shares would be minted according to EigenLayer:\n`virtualTotalShares` = 3232 * 1e18 + 1e3\n`virtualTokenBalance` = 3333 * 1e18 + 1e3\n`amountUnderlying` = 111 * 1e18\n\n**and when we do the math we will calculate the shares to be minted as:\n107636363636363636364**\n\nThen, the library function will be executed as follows:\n```solidity\nfunction depositTokenToOperators(\n        IRioLRTOperatorRegistry operatorRegistry,\n        address token,\n        address strategy,\n        uint256 sharesToAllocate // @review 107636363636363636364 as we calculated above!\n    ) internal returns (uint256 sharesReceived) {\n        (uint256 sharesAllocated, IRioLRTOperatorRegistry.OperatorStrategyAllocation[] memory  allocations) = operatorRegistry.allocateStrategyShares(\n            strategy, sharesToAllocate\n        );\n\n        for (uint256 i = 0; i < allocations.length; ++i) {\n            IRioLRTOperatorRegistry.OperatorStrategyAllocation memory allocation = allocations[i];\n\n            IERC20(token).safeTransfer(allocation.delegator, allocation.tokens);\n            sharesReceived += IRioLRTOperatorDelegator(allocation.delegator).stakeERC20(strategy, token, allocation.tokens);\n        }\n        if (sharesReceived != sharesAllocated) revert INCORRECT_NUMBER_OF_SHARES_RECEIVED();\n    }\n```\n\nThe very first line of the above snippet executes the `operatorRegistry.allocateStrategyShares`, let's examine that:\n```solidity\n function allocateStrategyShares(address strategy, uint256 sharesToAllocate) external onlyDepositPool returns (uint256 sharesAllocated, OperatorStrategyAllocation[] memory allocations) {\n        .\n        uint256 remainingShares = sharesToAllocate;\n        allocations = new OperatorStrategyAllocation[](s.activeOperatorCount);\n        while (remainingShares > 0) {\n            .\n            .\n            uint256 newShareAllocation = FixedPointMathLib.min(operatorShares.cap - operatorShares.allocation, remainingShares);\n            uint256 newTokenAllocation = IStrategy(strategy).sharesToUnderlyingView(newShareAllocation);\n            allocations[allocationIndex] = OperatorStrategyAllocation(\n                operator.delegator,\n                newShareAllocation,\n                newTokenAllocation\n            );\n            remainingShares -= newShareAllocation;\n            .\n            .\n        }\n        sharesAllocated = sharesToAllocate - remainingShares;\n        .\n        .\n    }\n```\n\nSo, let's value the above snippet aswell considering the cap is not reached. As we can see the how much underlying token needed is again calculated by querying the EigenLayer strategy `sharesToUnderlyingView`, so let's first calculate that:\n```solidity\nfunction sharesToUnderlyingView(uint256 amountShares) public view virtual override returns (uint256) {\n        // account for virtual shares and balance\n        uint256 virtualTotalShares = totalShares + SHARES_OFFSET;\n        uint256 virtualTokenBalance = _tokenBalance() + BALANCE_OFFSET;\n        // calculate ratio based on virtual shares and balance, being careful to multiply before dividing\n        return (virtualTokenBalance * amountShares) / virtualTotalShares;\n    }\n```\nLet's put the values to above snippet:\n`virtualTotalShares` = 3232 * 1e18 + 1e3\n`virtualTokenBalance` = 3333 * 1e18 + 1e3\n`amountShares` = 107636363636363636364\n**hence, the return value is 110999999999999999999(as you noticed it is not 111 * 1e18 as we expect!)**\n\n`sharesToAllocate` =  remainingShares  = newShareAllocation  = 107636363636363636364\n`newTokenAllocation` = 110999999999999999999\n`sharesAllocated` = 107636363636363636364\n\nNow, let's go back to `depositTokenToOperators` function and move with the execution flow:\n\nas we can see the underlying tokens we calculated (110999999999999999999) is deposited to EigenLayer for shares here and then compared in the last line in the if check as follows:\n```solidity\nfor (uint256 i = 0; i < allocations.length; ++i) {\n            IRioLRTOperatorRegistry.OperatorStrategyAllocation memory allocation = allocations[i];\n\n            IERC20(token).safeTransfer(allocation.delegator, allocation.tokens);\n            sharesReceived += IRioLRTOperatorDelegator(allocation.delegator).stakeERC20(strategy, token, allocation.tokens);\n        }\n        if (sharesReceived != sharesAllocated) revert INCORRECT_NUMBER_OF_SHARES_RECEIVED();\n```\n\n`stakeERC20` will stake 110999999999999999999 tokens and in exchange **will receive 107636363636363636363** shares. Then the `sharesReceived` will be compared with the **initial share amount calculation which is 107636363636363636364**\n\n**hence, the last if check will revert because\n107636363636363636363 != 107636363636363636364**\n\n**Coded PoC:**\n```solidity\nfunction test_RioRoundingDownPrecision() external pure returns (uint, uint) {\n        uint underlyingTokens = 111 * 1e18;\n        uint totalUnderlyingTokensInEigenLayer = 3333 * 1e18;\n        uint totalSharesInEigenLayer = 3232 * 1e18;\n        uint SHARE_AND_BALANCE_OFFSET = 1e3;\n\n        uint virtualTotalShares =  totalSharesInEigenLayer + SHARE_AND_BALANCE_OFFSET;\n        uint virtualTokenBalance = totalUnderlyingTokensInEigenLayer + SHARE_AND_BALANCE_OFFSET;\n\n        uint underlyingTokensToEigenLayerShares = (underlyingTokens * virtualTotalShares) / virtualTokenBalance;\n        uint eigenSharesToUnderlying = (virtualTokenBalance * underlyingTokensToEigenLayerShares) / virtualTotalShares;\n\n        // we expect eigenSharesToUnderlying == underlyingTokens, which is not\n        require(eigenSharesToUnderlying != underlyingTokens);\n\n        return (underlyingTokensToEigenLayerShares, eigenSharesToUnderlying);\n    }\n```\n## Impact\nThe issue described above can happen frequently as long as the perfect division is not happening when converting shares/assets. In order to solve the issue the amounts and shares has to be perfectly divisible such that the rounding down is not an issue. This can be fixed by owner to airdrop some assets such that this is possible. However, considering how frequent and easy the above scenario can happen and owner needs to do some math to fix the issue, I'll label this as high.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-rio-vesting-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTDepositPool.sol#L47-L67\n\nhttps://github.com/sherlock-audit/2024-02-rio-vesting-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTAssetRegistry.sol#L215-L221\n\nhttps://github.com/Layr-Labs/eigenlayer-contracts/blob/5c192e1a780c22e027f6861f958db90fb9ae263c/src/contracts/strategies/StrategyBase.sol#L211-L243\n\nhttps://github.com/sherlock-audit/2024-02-rio-vesting-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorOperations.sol#L51-L68\n\nhttps://github.com/sherlock-audit/2024-02-rio-vesting-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorRegistry.sol#L342-L392\n\nhttps://github.com/sherlock-audit/2024-02-rio-vesting-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L174-L179\n## Tool used\n\nManual Review\n\n## Recommendation\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/rio-org/rio-sherlock-audit/pull/11.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IDelegationManager} from 'contracts/interfaces/eigenlayer/IDelegationManager.sol';\nimport {IRioLRTDepositPool} from 'contracts/interfaces/IRioLRTDepositPool.sol';\nimport {OperatorOperations} from 'contracts/utils/OperatorOperations.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {\n    BEACON_CHAIN_STRATEGY,\n    ETH_DEPOSIT_SOFT_CAP,\n    ETH_DEPOSIT_BUFFER_LIMIT,\n    ETH_ADDRESS\n} from 'contracts/utils/Constants.sol';\n\ncontract RioLRTDepositPool is IRioLRTDepositPool, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using FixedPointMathLib for uint256;\n    using Asset for *;\n    using Array for *;\n\n    /// @notice The primary delegation contract for EigenLayer.\n    IDelegationManager public immutable delegationManager;\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    /// @param delegationManager_ The primary delegation contract for EigenLayer.\n    constructor(address issuer_, address delegationManager_) RioLRTCore(issuer_) {\n        delegationManager = IDelegationManager(delegationManager_);\n    }\n\n    /// @notice Initializes the deposit pool contract.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Deposits the entire deposit pool balance of the specified `asset` into EigenLayer, unless capped.\n    /// @param asset The address of the asset to be deposited.\n    function depositBalanceIntoEigenLayer(address asset) external onlyCoordinator returns (uint256, bool) {\n        uint256 amountToDeposit = asset.getSelfBalance();\n        if (amountToDeposit == 0) return (0, false);\n\n        bool isDepositCapped;\n        if (asset == ETH_ADDRESS) {\n            // Due to the high cost associated with ETH deposits, we cap the deposit at or near the defined soft cap to avoid\n            // hitting the block gas limit.\n            if (amountToDeposit > ETH_DEPOSIT_SOFT_CAP) {\n                // Only cap the deposit if the excess is beyond the allowed buffer limit.\n                if (amountToDeposit - ETH_DEPOSIT_SOFT_CAP > ETH_DEPOSIT_BUFFER_LIMIT) {\n                    (amountToDeposit, isDepositCapped) = (ETH_DEPOSIT_SOFT_CAP, true);\n                }\n            }\n            return (OperatorOperations.depositETHToOperators(operatorRegistry(), amountToDeposit), isDepositCapped);\n        }\n\n        address strategy = assetRegistry().getAssetStrategy(asset);\n        uint256 sharesToAllocate = assetRegistry().convertToSharesFromAsset(asset, amountToDeposit);\n        return (OperatorOperations.depositTokenToOperators(operatorRegistry(), asset, strategy, sharesToAllocate), isDepositCapped);\n    }\n\n    /// @notice Transfers the maximum possible amount of assets based on the available\n    /// pool balance and requested shares.\n    /// @param asset The address of the asset to be transferred.\n    /// @param sharesRequested The number of shares to convert into assets for transfer.\n    /// @param recipient The address of the recipient of the transferred assets.\n    /// @dev This function handles asset transfer by converting the share value to assets and\n    /// ensures that either the requested amount or the maximum possible amount is transferred.\n    function transferMaxAssetsForShares(address asset, uint256 sharesRequested, address recipient)\n        external\n        onlyCoordinator\n        returns (uint256, uint256)\n    {\n        uint256 poolBalance = asset.getSelfBalance();\n        uint256 poolBalanceShareValue = assetRegistry().convertToSharesFromAsset(asset, poolBalance);\n\n        // Return early if the deposit pool has no balance or value for the given asset.\n        if (poolBalance == 0 || poolBalanceShareValue == 0) {\n            return (0, 0);\n        }\n\n        // If the deposit pool balance can cover the requested shares, transfer the equivalent assets.\n        if (poolBalanceShareValue >= sharesRequested) {\n            address strategy = assetRegistry().getAssetStrategy(asset);\n            uint256 assetsSent = assetRegistry().convertFromSharesToAsset(strategy, sharesRequested);\n            asset.transferTo(recipient, assetsSent);\n\n            return (assetsSent, sharesRequested);\n        }\n\n        // Transfer the maximum possible assets from the deposit pool if it\n        // cannot cover the requested shares. If withdrawing ETH, we reduce the\n        // precision of the shares owed to the nearest Gwei, which is the smallest\n        // unit of account supported by EigenLayer.\n        if (asset == ETH_ADDRESS) {\n            poolBalance = poolBalance.reducePrecisionToGwei();\n            poolBalanceShareValue = poolBalanceShareValue.reducePrecisionToGwei();\n        }\n        asset.transferTo(recipient, poolBalance);\n\n        return (poolBalance, poolBalanceShareValue);\n    }\n\n    /// @notice Completes a withdrawal from EigenLayer for the specified asset and operator.\n    /// Withdrawals directly to the deposit pool can occur for two reasons:\n    /// 1. The operator has exited the strategy and the assets have been returned to the deposit pool.\n    /// 2. Excess full withdrawal ETH has been scraped from the EigenPod.\n    /// @param asset The address of the asset to be withdrawn.\n    /// @param operatorId The ID of the operator from which the asset is being withdrawn.\n    /// @param queuedWithdrawal The withdrawal to be completed.\n    /// @param middlewareTimesIndex The index of the middleware times to use for the withdrawal.\n    function completeOperatorWithdrawalForAsset(\n        address asset,\n        uint8 operatorId,\n        IDelegationManager.Withdrawal calldata queuedWithdrawal,\n        uint256 middlewareTimesIndex\n    ) external {\n        // Only allow one strategy exit at a time.\n        if (queuedWithdrawal.strategies.length != 1) revert INVALID_WITHDRAWAL_STRATEGY_LENGTH();\n\n        // Verify that the withdrawal originated from an operator delegator within the system.\n        IRioLRTOperatorDelegator operatorDelegator_ = operatorDelegator(operatorRegistry(), operatorId);\n        if (queuedWithdrawal.staker != address(operatorDelegator_)) {\n            revert INVALID_WITHDRAWAL_ORIGIN();\n        }\n\n        // If ETH, decrease the amount of ETH queued for withdrawal. Otherwise, decrease the\n        // amount of shares held for the asset.\n        address strategy = queuedWithdrawal.strategies[0];\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            operatorDelegator_.decreaseETHQueuedForOperatorExitOrScrape(queuedWithdrawal.shares[0]);\n        } else {\n            assetRegistry().decreaseSharesHeldForAsset(asset, queuedWithdrawal.shares[0]);\n        }\n\n        // Complete the withdrawal. This function verifies that the passed `asset` is correct.\n        delegationManager.completeQueuedWithdrawal(queuedWithdrawal, asset.toArray(), middlewareTimesIndex, true);\n\n        emit OperatorAssetWithdrawalCompleted(operatorId, asset, keccak256(abi.encode(queuedWithdrawal)));\n    }\n\n    /// @dev Receives ETH for deposit into EigenLayer.\n    receive() external payable {}\n\n    /// @dev Allows the owner to upgrade the deposit pool implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTAssetRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IPriceFeed} from 'contracts/interfaces/oracle/IPriceFeed.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {BEACON_CHAIN_STRATEGY, ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {IStrategy} from 'contracts/interfaces/eigenlayer/IStrategy.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\n\ncontract RioLRTAssetRegistry is IRioLRTAssetRegistry, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    /// @notice The number of decimals that all asset price feeds must use.\n    uint8 public priceFeedDecimals;\n\n    /// @notice The price scale used for all assets (max of 18 decimals).\n    uint64 public priceScale;\n\n    /// @notice All supported assets.\n    address[] public supportedAssets;\n\n    /// @notice Information about a supported asset.\n    mapping(address asset => AssetInfo) public assetInfo;\n\n    /// @notice The amount of ETH held in unverified validators.\n    uint256 public ethBalanceInUnverifiedValidators;\n\n    /// @notice Require that the caller is the withdrawal queue or deposit pool.\n    modifier onlyWithdrawalQueueOrDepositPool() {\n        if (msg.sender != address(withdrawalQueue()) && msg.sender != address(depositPool())) {\n            revert ONLY_WITHDRAWAL_QUEUE_OR_DEPOSIT_POOL();\n        }\n        _;\n    }\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    constructor(address issuer_) RioLRTCore(issuer_) {}\n\n    /// @notice Initializes the asset registry contract.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    /// @param priceFeedDecimals_ The number of decimals that all price feeds must use.\n    /// @param initialAssets The initial supported asset configurations.\n    function initialize(\n        address initialOwner,\n        address token_,\n        uint8 priceFeedDecimals_,\n        AssetConfig[] calldata initialAssets\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n\n        // Non-ETH pairs must use 8 decimals, while ETH pairs must use 18.\n        if (priceFeedDecimals_ != 8 && priceFeedDecimals_ != 18) revert INVALID_PRICE_FEED_DECIMALS();\n\n        priceFeedDecimals = priceFeedDecimals_;\n        priceScale = uint64(10) ** priceFeedDecimals_;\n\n        // Add the initial assets, if any.\n        for (uint256 i = 0; i < initialAssets.length; ++i) {\n            _addAsset(initialAssets[i]);\n        }\n    }\n\n    /// @notice Returns the total value of all underlying assets in the unit of account.\n    function getTVL() public view returns (uint256 value) {\n        address[] memory assets = getSupportedAssets();\n        for (uint256 i = 0; i < assets.length; ++i) {\n            value += getTVLForAsset(assets[i]);\n        }\n    }\n\n    /// @notice Returns the total value of the underlying asset in the unit of account.\n    /// @param asset The address of the asset.\n    function getTVLForAsset(address asset) public view returns (uint256) {\n        uint256 balance = getTotalBalanceForAsset(asset);\n        if (asset == ETH_ADDRESS) {\n            return balance;\n        }\n        return convertToUnitOfAccountFromAsset(asset, balance);\n    }\n\n    /// @notice Returns the total balance of the asset, including the deposit pool and EigenLayer.\n    /// @param asset The address of the asset.\n    function getTotalBalanceForAsset(address asset) public view returns (uint256) {\n        if (!isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n\n        address depositPool_ = address(depositPool());\n        if (asset == ETH_ADDRESS) {\n            return depositPool_.balance + getETHBalanceInEigenLayer();\n        }\n\n        uint256 sharesHeld = getAssetSharesHeld(asset);\n        uint256 tokensInRio = IERC20(asset).balanceOf(depositPool_);\n        uint256 tokensInEigenLayer = convertFromSharesToAsset(getAssetStrategy(asset), sharesHeld);\n\n        return tokensInRio + tokensInEigenLayer;\n    }\n\n    /// @notice Returns the ETH balance held in EigenLayer. This includes the ETH held in\n    /// unverified validators, EigenPod shares, and ETH that's queued for withdrawal.\n    function getETHBalanceInEigenLayer() public view returns (uint256 balance) {\n        balance = ethBalanceInUnverifiedValidators;\n\n        IRioLRTOperatorRegistry operatorRegistry_ = operatorRegistry();\n        uint8 endAtID = operatorRegistry_.operatorCount() + 1; // Operator IDs start at 1.\n        for (uint8 id = 1; id < endAtID; ++id) {\n            balance += operatorDelegator(operatorRegistry_, id).getETHUnderManagement();\n        }\n    }\n\n    /// @notice Checks if a given asset is supported.\n    /// @param asset The address of the asset to check.\n    function isSupportedAsset(address asset) public view returns (bool) {\n        return assetInfo[asset].strategy != address(0);\n    }\n\n    /// @notice Returns information about an asset.\n    /// @param asset The address of the asset.\n    function getAssetInfoByAddress(address asset) public view returns (AssetInfo memory) {\n        return assetInfo[asset];\n    }\n\n    /// @notice Returns the asset's EigenLayer strategy.\n    /// @param asset The address of the asset.\n    function getAssetStrategy(address asset) public view returns (address) {\n        return assetInfo[asset].strategy;\n    }\n\n    /// @notice Returns the amount of EigenLayer shares held for an asset.\n    /// @param asset The address of the asset.\n    function getAssetSharesHeld(address asset) public view returns (uint256) {\n        return assetInfo[asset].shares;\n    }\n\n    /// @notice Returns the asset's current price feed.\n    /// @param asset The address of the asset.\n    function getAssetPriceFeed(address asset) external view returns (address) {\n        return assetInfo[asset].priceFeed;\n    }\n\n    /// @notice Returns the asset's current deposit cap.\n    /// @param asset The address of the asset.\n    function getAssetDepositCap(address asset) external view returns (uint256) {\n        return assetInfo[asset].depositCap;\n    }\n\n    /// @notice Returns the asset's decimal precision.\n    /// @param asset The address of the asset.\n    function getAssetDecimals(address asset) external view returns (uint256) {\n        return assetInfo[asset].decimals;\n    }\n\n    /// @notice Returns the asset's current price.\n    /// @param asset The address of the asset.\n    function getAssetPrice(address asset) public view returns (uint256) {\n        return getPrice(assetInfo[asset].priceFeed);\n    }\n\n    /// @notice Returns an array of all supported assets.\n    function getSupportedAssets() public view returns (address[] memory assets) {\n        uint256 assetCount = supportedAssets.length;\n        assets = new address[](assetCount);\n\n        for (uint256 i = 0; i < assetCount; ++i) {\n            assets[i] = supportedAssets[i];\n        }\n    }\n\n    /// @notice Returns the EigenLayer strategies for all supported assets.\n    function getAssetStrategies() external view returns (address[] memory strategies) {\n        uint256 assetCount = supportedAssets.length;\n        strategies = new address[](assetCount);\n\n        for (uint256 i = 0; i < assetCount; ++i) {\n            strategies[i] = getAssetStrategy(supportedAssets[i]);\n        }\n    }\n\n    /// @notice Converts an asset amount to its equivalent value in the unit of account. The unit of\n    /// account is the price feed's quote asset.\n    /// @param asset The address of the asset to convert.\n    /// @param amount The amount of the asset to convert.\n    function convertToUnitOfAccountFromAsset(address asset, uint256 amount) public view returns (uint256) {\n        if (asset == ETH_ADDRESS) {\n            return amount;\n        }\n        address priceFeed = assetInfo[asset].priceFeed;\n        uint256 price = getPrice(priceFeed);\n\n        return _normalizeDecimals(price * amount / priceScale, assetInfo[asset].decimals, priceFeedDecimals);\n    }\n\n    /// @notice Converts the unit of account value to its equivalent in the asset. The unit of\n    /// account is the price feed's quote asset.\n    /// @param asset The address of the asset to convert to.\n    /// @param value The asset's value in the unit of account.\n    function convertFromUnitOfAccountToAsset(address asset, uint256 value) public view returns (uint256) {\n        if (asset == ETH_ADDRESS) {\n            return value;\n        }\n        address priceFeed = assetInfo[asset].priceFeed;\n        uint256 price = getPrice(priceFeed);\n\n        return _normalizeDecimals(value * priceScale / price, priceFeedDecimals, assetInfo[asset].decimals);\n    }\n\n    /// @notice Converts an amount of an asset to the equivalent amount of EigenLayer shares.\n    /// @param asset The address of the asset to convert.\n    /// @param amount The amount of the asset to convert.\n    function convertToSharesFromAsset(address asset, uint256 amount) public view returns (uint256 shares) {\n        address strategy = assetInfo[asset].strategy;\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            return amount;\n        }\n        shares = IStrategy(strategy).underlyingToSharesView(amount);\n    }\n\n    /// @notice Converts an amount of EigenLayer shares to the equivalent amount of an asset.\n    /// @param strategy The EigenLayer strategy.\n    /// @param shares The amount of EigenLayer shares.\n    function convertFromSharesToAsset(address strategy, uint256 shares) public view returns (uint256 amount) {\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            return shares;\n        }\n        amount = IStrategy(strategy).sharesToUnderlyingView(shares);\n    }\n\n    /// @dev Get the current price from the provided price feed.\n    /// @param priceFeed The price feed contract address.\n    function getPrice(address priceFeed) public view returns (uint256) {\n        if (priceFeed == address(0)) {\n            revert INVALID_PRICE_FEED();\n        }\n        return IPriceFeed(priceFeed).getPrice();\n    }\n\n    /// @notice Adds a new underlying asset to the liquid restaking token.\n    /// @param config The asset's configuration.\n    function addAsset(AssetConfig calldata config) external onlyOwner {\n        _addAsset(config);\n    }\n\n    /// @notice Removes an underlying asset from the liquid restaking token.\n    /// @param asset The address of the asset to remove.\n    function removeAsset(address asset) external onlyOwner {\n        if (!isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n        if (getTVLForAsset(asset) > 0) revert ASSET_HAS_BALANCE();\n\n        uint256 assetCount = supportedAssets.length;\n        uint256 assetIndex = _findAssetIndex(asset);\n\n        supportedAssets[assetIndex] = supportedAssets[assetCount - 1];\n        supportedAssets.pop();\n\n        delete assetInfo[asset];\n\n        emit AssetRemoved(asset);\n    }\n\n    /// @dev Sets the asset's deposit cap.\n    /// @param newDepositCap The new rebalance delay.\n    function setAssetDepositCap(address asset, uint96 newDepositCap) external onlyOwner {\n        if (!isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n\n        assetInfo[asset].depositCap = newDepositCap;\n\n        emit AssetDepositCapSet(asset, newDepositCap);\n    }\n\n    /// @dev Sets the asset's price feed.\n    /// @param newPriceFeed The new price feed.\n    function setAssetPriceFeed(address asset, address newPriceFeed) external onlyOwner {\n        if (!isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n        if (newPriceFeed == address(0)) revert INVALID_PRICE_FEED();\n\n        assetInfo[asset].priceFeed = newPriceFeed;\n\n        emit AssetPriceFeedSet(asset, newPriceFeed);\n    }\n\n    /// @notice Increases the number of EigenLayer shares held for an asset.\n    /// @param asset The address of the asset.\n    /// @param amount The amount of EigenLayer shares to increase.\n    function increaseSharesHeldForAsset(address asset, uint256 amount) external onlyCoordinator {\n        if (!isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n\n        assetInfo[asset].shares += amount;\n        emit AssetSharesIncreased(asset, amount);\n    }\n\n    /// @notice Decreases the number of EigenLayer shares held for an asset.\n    /// @param asset The address of the asset.\n    /// @param amount The amount of EigenLayer shares to decrease.\n    function decreaseSharesHeldForAsset(address asset, uint256 amount) external onlyWithdrawalQueueOrDepositPool {\n        if (!isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n\n        assetInfo[asset].shares -= amount;\n        emit AssetSharesDecreased(asset, amount);\n    }\n\n    /// @notice Increases the unverified validator ETH balance.\n    /// @param amount The amount of ETH to increase.\n    function increaseUnverifiedValidatorETHBalance(uint256 amount) external onlyCoordinator {\n        if (!isSupportedAsset(ETH_ADDRESS)) revert ASSET_NOT_SUPPORTED(ETH_ADDRESS);\n\n        ethBalanceInUnverifiedValidators += amount;\n        emit UnverifiedValidatorETHBalanceIncreased(amount);\n    }\n\n    /// @notice Decreases the unverified validator ETH balance.\n    /// @param amount The amount of ETH to decrease.\n    function decreaseUnverifiedValidatorETHBalance(uint256 amount) external onlyOperatorRegistry {\n        if (!isSupportedAsset(ETH_ADDRESS)) revert ASSET_NOT_SUPPORTED(ETH_ADDRESS);\n\n        ethBalanceInUnverifiedValidators -= amount;\n        emit UnverifiedValidatorETHBalanceDecreased(amount);\n    }\n\n    /// @dev Adds a new underlying asset to the liquid restaking token.\n    /// @param config The asset's configuration.\n    function _addAsset(AssetConfig calldata config) internal {\n        if (isSupportedAsset(config.asset)) revert ASSET_ALREADY_SUPPORTED(config.asset);\n        if (config.asset == address(0)) revert INVALID_ASSET_ADDRESS();\n\n        uint8 decimals = config.asset == ETH_ADDRESS ? 18 : IERC20Metadata(config.asset).decimals();\n        if (config.asset == ETH_ADDRESS) {\n            if (config.priceFeed != address(0)) revert INVALID_PRICE_FEED();\n            if (config.strategy != BEACON_CHAIN_STRATEGY) revert INVALID_STRATEGY();\n        } else {\n            if (decimals > 18) revert INVALID_ASSET_DECIMALS();\n            if (config.priceFeed == address(0)) revert INVALID_PRICE_FEED();\n            if (IPriceFeed(config.priceFeed).decimals() != priceFeedDecimals) revert INVALID_PRICE_FEED_DECIMALS();\n            if (IStrategy(config.strategy).underlyingToken() != config.asset) revert INVALID_STRATEGY();\n        }\n        supportedAssets.push(config.asset);\n\n        AssetInfo storage info = assetInfo[config.asset];\n        info.decimals = decimals;\n        info.depositCap = config.depositCap;\n        info.priceFeed = config.priceFeed;\n        info.strategy = config.strategy;\n\n        emit AssetAdded(config);\n    }\n\n    /// @dev Returns the index of the asset in the supported assets array.\n    /// @param asset The address of the asset.\n    function _findAssetIndex(address asset) internal view returns (uint256) {\n        uint256 assetCount = supportedAssets.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            if (supportedAssets[i] == asset) {\n                return i;\n            }\n        }\n        revert ASSET_NOT_SUPPORTED(asset);\n    }\n\n    /// @notice Normalizes an amount from one decimal precision to another.\n    /// @param amount The amount to normalize.\n    /// @param fromDecimals The amount's current decimal precision.\n    /// @param toDecimals The amount's target decimal precision.\n    function _normalizeDecimals(uint256 amount, uint8 fromDecimals, uint8 toDecimals) internal pure returns (uint256) {\n        // No adjustment needed if decimals are the same.\n        if (fromDecimals == toDecimals) {\n            return amount;\n        }\n        // Scale down to match the target decimal precision.\n        if (fromDecimals > toDecimals) {\n            return amount / 10 ** (fromDecimals - toDecimals);\n        }\n        // Scale up to match the target decimal precision.\n        return amount * 10 ** (toDecimals - fromDecimals);\n    }\n\n    /// @dev Allows the owner to upgrade the asset registry implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    },
    {
      "filename": "src/contracts/strategies/StrategyBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"../interfaces/IStrategyManager.sol\";\nimport \"../permissions/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @title Base implementation of `IStrategy` interface, designed to be inherited from by more complex strategies.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Simple, basic, \"do-nothing\" Strategy that holds a single underlying token and returns it on withdrawals.\n * Implements minimal versions of the IStrategy functions, this contract is designed to be inherited by\n * more complex strategies, which can then override its functions as necessary.\n * @dev Note that some functions have their mutability restricted; developers inheriting from this contract cannot broaden\n * the mutability without modifying this contract itself.\n * @dev This contract is expressly *not* intended for use with 'fee-on-transfer'-type tokens.\n * Setting the `underlyingToken` to be a fee-on-transfer token may result in improper accounting.\n * @notice This contract functions similarly to an ERC4626 vault, only without issuing a token.\n * To mitigate against the common \"inflation attack\" vector, we have chosen to use the 'virtual shares' mitigation route,\n * similar to [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol).\n * We acknowledge that this mitigation has the known downside of the virtual shares causing some losses to users, which are pronounced\n * particularly in the case of the share exchange rate changing signficantly, either positively or negatively.\n * For a fairly thorough discussion of this issue and our chosen mitigation strategy, we recommend reading through\n * [this thread](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706) on the OpenZeppelin repo.\n * We specifically use a share offset of `SHARES_OFFSET` and a balance offset of `BALANCE_OFFSET`.\n */\ncontract StrategyBase is Initializable, Pausable, IStrategy {\n    using SafeERC20 for IERC20;\n\n    uint8 internal constant PAUSED_DEPOSITS = 0;\n    uint8 internal constant PAUSED_WITHDRAWALS = 1;\n\n    /**\n     * @notice virtual shares used as part of the mitigation of the common 'share inflation' attack vector.\n     * Constant value chosen to reasonably reduce attempted share inflation by the first depositor, while still\n     * incurring reasonably small losses to depositors\n     */\n    uint256 internal constant SHARES_OFFSET = 1e3;\n    /**\n     * @notice virtual balance used as part of the mitigation of the common 'share inflation' attack vector\n     * Constant value chosen to reasonably reduce attempted share inflation by the first depositor, while still\n     * incurring reasonably small losses to depositors\n     */\n    uint256 internal constant BALANCE_OFFSET = 1e3;\n\n    /// @notice EigenLayer's StrategyManager contract\n    IStrategyManager public immutable strategyManager;\n\n    /// @notice The underlying token for shares in this Strategy\n    IERC20 public underlyingToken;\n\n    /// @notice The total number of extant shares in this Strategy\n    uint256 public totalShares;\n\n    /// @notice Simply checks that the `msg.sender` is the `strategyManager`, which is an address stored immutably at construction.\n    modifier onlyStrategyManager() {\n        require(msg.sender == address(strategyManager), \"StrategyBase.onlyStrategyManager\");\n        _;\n    }\n\n    /// @notice Since this contract is designed to be initializable, the constructor simply sets `strategyManager`, the only immutable variable.\n    constructor(IStrategyManager _strategyManager) {\n        strategyManager = _strategyManager;\n        _disableInitializers();\n    }\n\n    function initialize(IERC20 _underlyingToken, IPauserRegistry _pauserRegistry) public virtual initializer {\n        _initializeStrategyBase(_underlyingToken, _pauserRegistry);\n    }\n\n    /// @notice Sets the `underlyingToken` and `pauserRegistry` for the strategy.\n    function _initializeStrategyBase(\n        IERC20 _underlyingToken,\n        IPauserRegistry _pauserRegistry\n    ) internal onlyInitializing {\n        underlyingToken = _underlyingToken;\n        _initializePauser(_pauserRegistry, UNPAUSE_ALL);\n    }\n\n    /**\n     * @notice Used to deposit tokens into this Strategy\n     * @param token is the ERC20 token being deposited\n     * @param amount is the amount of token being deposited\n     * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\n     * `depositIntoStrategy` function, and individual share balances are recorded in the strategyManager as well.\n     * @dev Note that the assumption is made that `amount` of `token` has already been transferred directly to this contract\n     * (as performed in the StrategyManager's deposit functions). In particular, setting the `underlyingToken` of this contract\n     * to be a fee-on-transfer token will break the assumption that the amount this contract *received* of the token is equal to\n     * the amount that was input when the transfer was performed (i.e. the amount transferred 'out' of the depositor's balance).\n     * @dev Note that any validation of `token` is done inside `_beforeDeposit`. This can be overridden if needed.\n     * @return newShares is the number of new shares issued at the current exchange ratio.\n     */\n    function deposit(\n        IERC20 token,\n        uint256 amount\n    ) external virtual override onlyWhenNotPaused(PAUSED_DEPOSITS) onlyStrategyManager returns (uint256 newShares) {\n        // call hook to allow for any pre-deposit logic\n        _beforeDeposit(token, amount);\n\n        // copy `totalShares` value to memory, prior to any change\n        uint256 priorTotalShares = totalShares;\n\n        /**\n         * @notice calculation of newShares *mirrors* `underlyingToShares(amount)`, but is different since the balance of `underlyingToken`\n         * has already been increased due to the `strategyManager` transferring tokens to this strategy prior to calling this function\n         */\n        // account for virtual shares and balance\n        uint256 virtualShareAmount = priorTotalShares + SHARES_OFFSET;\n        uint256 virtualTokenBalance = _tokenBalance() + BALANCE_OFFSET;\n        // calculate the prior virtual balance to account for the tokens that were already transferred to this contract\n        uint256 virtualPriorTokenBalance = virtualTokenBalance - amount;\n        newShares = (amount * virtualShareAmount) / virtualPriorTokenBalance;\n\n        // extra check for correctness / against edge case where share rate can be massively inflated as a 'griefing' sort of attack\n        require(newShares != 0, \"StrategyBase.deposit: newShares cannot be zero\");\n\n        // update total share amount to account for deposit\n        totalShares = (priorTotalShares + newShares);\n        return newShares;\n    }\n\n    /**\n     * @notice Used to withdraw tokens from this Strategy, to the `recipient`'s address\n     * @param recipient is the address to receive the withdrawn funds\n     * @param token is the ERC20 token being transferred out\n     * @param amountShares is the amount of shares being withdrawn\n     * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\n     * other functions, and individual share balances are recorded in the strategyManager as well.\n     * @dev Note that any validation of `token` is done inside `_beforeWithdrawa"
    }
  ]
}