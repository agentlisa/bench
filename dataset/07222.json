{
  "Title": "[M-06] Too few rewards paid over periods in Furnace and StRSR",
  "Content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L77-L79><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L509-L512><br>\n<https://github.com/reserve-protocol/protocol/blob/946d9b101dd77275c6cbfe0bfe9457927bd221a9/contracts/p1/StRSR.sol#L490-L493>\n\nFor two instances in the codebase ([`Furnace`](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L77-L79) and [`StRSR`](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L509-L512)), the composed rewards calculation seems to be wrong.\n\nHow the rewards are working in these two snippets is that we are first measuring how much `period` or `rewardPeriod` occured since the last payout and calculating in only **one** step the rewards that should be distributed over these periods. In other words, it is composing the ratio over periods.\n\n### Proof of Concept\n\nTaken from the [comments](https://github.com/reserve-protocol/protocol/blob/946d9b101dd77275c6cbfe0bfe9457927bd221a9/contracts/p1/StRSR.sol#L490-L493), we can write the formula of the next rewards payout as:\n\n    with n = (i+1) > 0, n is the number of periods\n    rewards{0} = rsrRewards()\n    payout{i+1} = rewards{i} * payoutRatio\n    rewards{i+1} = rewards{i} - payout{i+1}\n    rewards{i+1} = rewards{i} * (1 - payoutRatio)\n\nGeneralization:\n$$u\\_{i+1} = u\\_{i} * (1 - r)$$\n\nIt's a geometric mean whose growth rate is `(1 - r)`.\n\nCalculation of the sum:\n\n![](https://user-images.githubusercontent.com/51274081/213756676-cbbcf22b-3237-433d-a6e3-9577b6d75474.png)\n\nYou can play with the graph [here](https://www.desmos.com/calculator/1fnpsnf8nt).\n\nFor a practical example, let's say that our `rsrRewardsAtLastPayout` is 5, with a `rewardRatio` of 0.9.\n\nIf we had to calculate our compounded rewards, from the formula given by the comments above, we could calculate manually for the first elements. Let's take the sum for n = 3:\n\n$$S = u\\_{2} + u\\_{1} + u\\_{0}$$\n$$u\\_{2} = u\\_{1} * (1-0.9)$$\n$$u\\_{1} = u\\_{0} * (1-0.9)$$\n$$u\\_{0} = rsrRewardsAtLastPayout$$\n\nSo,\n\n$$S = u\\_{0} * (1-0.9) * (1-0.9) + u\\_{0} * (1-0.9) + u\\_{0}$$\n\nFor the values given above, that's\n\n$$S = 5 * 0.1Â² + 5 * 0.1 + 5$$\n$$S = 5.55$$\n\nIf we do the same calculation with the sum formula\n\n![](https://user-images.githubusercontent.com/51274081/213756989-03bb092b-a0a3-447a-a0e8-83035559be7b.png)\n$$S' = 4.995$$\n\n### Recommended Mitigation Steps\n\nRather than dividing by 1 (1e18 from the Fixed library), divide it by the `ratio`.\n\n```solidity\n// Furnace.sol\n// Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.\nuint192 payoutRatio = FIX_ONE.minus(FIX_ONE.minus(ratio).powu(numPeriods));\n\nuint256 amount = payoutRatio * lastPayoutBal / ratio;\n```\n\n```solidity\n// StRSR.sol\nuint192 payoutRatio = FIX_ONE - FixLib.powu(FIX_ONE - rewardRatio, numPeriods);\n\n// payout: {qRSR} = D18{1} * {qRSR} / r\nuint256 payout = (payoutRatio * rsrRewardsAtLastPayout) / rewardRatio;\n```\n\n**[tbrent (Reserve) disputed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/377#issuecomment-1405453764):**\n > I think there is a mistake in the math here, possibly arising from the fact that `rsrRewards()` doesn't correspond to how much rewards _has_ been handed out, but how much is _available_ to be handed out. \n> \n> I don't understand why the warden is computing the sum of `u_i`. If `u_0` is the value of `rsrRewards()` at time 0, and `u_1` is the value of `rsrRewards()` at time 1, why is the sum of `u_i` for all i interesting? This is double-counting balances, since only some of `u_i` is handed out each time. \n> \n> As the number of payouts approach infinity, the total amount handed out approaches `u_0`. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/377#issuecomment-1410642492):**\n > Would be good to get the warden to comment here during QA - will see if we can have that occur to clear up the difference in understanding.\n\n***Please note: the following comment and re-assessment took place after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.***\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/377#issuecomment-1428771851):**\n > I want to apologize that I missed the fact that no response was given during QA and currently believe this issue to be invalid.  \n\n**[Franfran (warden) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/377#issuecomment-1429273607):**\n > Hey friends, sorry for not hopping into the discussion earlier!<br>\n> My reasoning was that if the staker's rewards doesn't compound over time, then there is no reason for them to stay in the pool and not harvest the rewards, which is a costly process if they would have to harvest each cycle.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/p1/Furnace.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"../libraries/Fixed.sol\";\nimport \"../interfaces/IFurnace.sol\";\nimport \"./mixins/Component.sol\";\n\n/**\n * @title FurnaceP1\n * @notice A helper to melt RTokens slowly and permisionlessly.\n */\ncontract FurnaceP1 is ComponentP1, IFurnace {\n    using FixLib for uint192;\n\n    uint192 public constant MAX_RATIO = FIX_ONE; // {1} 100%\n    uint48 public constant MAX_PERIOD = 31536000; // {s} 1 year\n\n    uint192 public ratio; // {1} What fraction of balance to melt each period\n    uint48 public period; // {seconds} How often to melt\n    uint256 public lastPayoutBal; // {qRTok} The balance of RToken at the last payout\n    uint48 public lastPayout; // {seconds} The last time we did a payout\n\n    IRToken private rToken;\n\n    // ==== Invariants ====\n    // ratio <= MAX_RATIO = 1e18\n    // 0 < period <= MAX_PERIOD\n    // lastPayout was the timestamp of the end of the last period we paid out\n    //   (or, if no periods have been paid out, the timestamp init() was called)\n    // lastPayoutBal was rtoken.balanceOf(this) after the last period we paid out\n    //   (or, if no periods have been paid out, that balance when init() was called)\n\n    function init(\n        IMain main_,\n        uint48 period_,\n        uint192 ratio_\n    ) external initializer {\n        __Component_init(main_);\n        rToken = main_.rToken();\n        setPeriod(period_);\n        setRatio(ratio_);\n        lastPayout = uint48(block.timestamp);\n        lastPayoutBal = rToken.balanceOf(address(this));\n    }\n\n    // [furnace-payout-formula]:\n    //   The process we're modelling is:\n    //     N = number of whole periods since lastPayout\n    //     bal_0 = rToken.balanceOf(this)\n    //     payout_{i+1} = bal_i * ratio\n    //     bal_{i+1} = bal_i - payout_{i+1}\n    //     payoutAmount = sum{payout_i for i in [1...N]}\n    //   thus:\n    //     bal_N = bal_0 - payout\n    //     bal_{i+1} = bal_i - bal_i * ratio = bal_i * (1-ratio)\n    //     bal_N = bal_0 * (1-ratio)**N\n    //   and so:\n    //     payoutAmount = bal_N - bal_0 = bal_0 * (1 - (1-ratio)**N)\n\n    /// Performs any melting that has vested since last call.\n    /// @custom:refresher\n    // let numPeriods = number of whole periods that have passed since `lastPayout`\n    //     payoutAmount = RToken.balanceOf(this) * (1 - (1-ratio)**N) from [furnace-payout-formula]\n    // effects:\n    //   lastPayout' = lastPayout + numPeriods * period (end of last pay period)\n    //   lastPayoutBal' = rToken.balanceOf'(this) (balance now == at end of pay leriod)\n    // actions:\n    //   rToken.melt(payoutAmount), paying payoutAmount to RToken holders\n\n    function melt() external notPausedOrFrozen {\n        if (uint48(block.timestamp) < uint64(lastPayout) + period) return;\n\n        // # of whole periods that have passed since lastPayout\n        uint48 numPeriods = uint48((block.timestamp) - lastPayout) / period;\n\n        // Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.\n        uint192 payoutRatio = FIX_ONE.minus(FIX_ONE.minus(ratio).powu(numPeriods));\n\n        uint256 amount = payoutRatio.mulu_toUint(lastPayoutBal);\n\n        lastPayout += numPeriods * period;\n        lastPayoutBal = rToken.balanceOf(address(this)) - amount;\n        if (amount > 0) rToken.melt(amount);\n    }\n\n    /// Period setting\n    /// @custom:governance\n    function setPeriod(uint48 period_) public governance {\n        require(period_ > 0 && period_ <= MAX_PERIOD, \"invalid period\");\n        emit PeriodSet(period, period_);\n        period = period_;\n    }\n\n    /// Ratio setting\n    /// @custom:governance\n    function setRatio(uint192 ratio_) public governance {\n        require(ratio_ <= MAX_RATIO, \"invalid ratio\");\n        // The ratio can safely be set to 0\n        emit RatioSet(ratio, ratio_);\n        ratio = ratio_;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}"
    },
    {
      "filename": "contracts/p1/StRSR.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IStRSR.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"../libraries/Permit.sol\";\nimport \"./mixins/Component.sol\";\n\n/*\n * @title StRSRP1\n * @notice StRSR is an ERC20 token contract that allows people to stake their RSR as\n *   over-collateralization behind an RToken. As compensation stakers receive a share of revenues\n *   in the form of RSR. Balances are generally non-rebasing. As rewards are paid out StRSR becomes\n *   redeemable for increasing quantities of RSR.\n *\n * The one time that StRSR will rebase is if the entirety of over-collateralization RSR is seized.\n *   If this happens, users balances are zereod out and StRSR is re-issued at a 1:1 exchange rate\n *   with RSR.\n *\n * There's an important asymmetry in StRSR: when RSR is added it must be split only\n *   across non-withdrawing stakes, while when RSR is seized it is seized uniformly from both\n *   stakes that are in the process of being withdrawn and those that are not.\n */\n// solhint-disable max-states-count\nabstract contract StRSRP1 is Initializable, ComponentP1, IStRSR, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint48 public constant MAX_UNSTAKING_DELAY = 31536000; // {s} 1 year\n    uint48 public constant MAX_REWARD_PERIOD = 31536000; // {s} 1 year\n    uint192 public constant MAX_REWARD_RATIO = FIX_ONE; // {1} 100%\n\n    // === ERC20 ===\n    string public name; // mutable\n    string public symbol; // mutable\n    // solhint-disable const-name-snakecase\n    uint8 public constant decimals = 18;\n\n    // Component addresses, immutable after init()\n    IAssetRegistry private assetRegistry;\n    IBackingManager private backingManager;\n    IBasketHandler private basketHandler;\n    IERC20 private rsr;\n\n    /// === Financial State: Stakes (balances) ===\n    // Era. If stake balances are wiped out due to RSR seizure, increment the era to zero balances.\n    // Only ever directly written by beginEra()\n    uint256 internal era;\n\n    // Typically: \"balances\". These are the tokenized staking positions!\n    // era => ({account} => {qStRSR})\n    mapping(uint256 => mapping(address => uint256)) private stakes; // Stakes per account {qStRSR}\n    uint256 internal totalStakes; // Total of all stakes {qStRSR}\n    uint256 internal stakeRSR; // Amount of RSR backing all stakes {qRSR}\n    uint192 public stakeRate; // The exchange rate between stakes and RSR. D18{qStRSR/qRSR}\n\n    uint192 private constant MAX_STAKE_RATE = 1e9 * FIX_ONE; // 1e9 D18{qStRSR/qRSR}\n\n    // era => (owner => (spender => {qStRSR}))\n    mapping(uint256 => mapping(address => mapping(address => uint256))) private _allowances;\n\n    // === Financial State: Drafts ===\n    // Era. If drafts get wiped out due to RSR seizure, increment the era to zero draft values.\n    // Only ever directly written by beginDraftEra()\n    uint256 internal draftEra;\n    // Drafts: share of the withdrawing tokens. Not transferrable and not revenue-earning.\n    struct CumulativeDraft {\n        // Avoid re-using uint192 in order to avoid confusion with our type system; 176 is enough\n        uint176 drafts; // Total amount of drafts that will become available // {qDraft}\n        uint64 availableAt; // When the last of the drafts will become available\n    }\n    // draftEra => ({account} => {drafts})\n    mapping(uint256 => mapping(address => CumulativeDraft[])) public draftQueues; // {drafts}\n    mapping(uint256 => mapping(address => uint256)) public firstRemainingDraft; // draft index\n    uint256 internal totalDrafts; // Total of all drafts {qDrafts}\n    uint256 internal draftRSR; // Amount of RSR backing all drafts {qRSR}\n    uint192 public draftRate; // The exchange rate between drafts and RSR. D18{qDrafts/qRSR}\n\n    uint192 private constant MAX_DRAFT_RATE = 1e9 * FIX_ONE; // 1e9 D18{qDrafts/qRSR}\n\n    // ==== Analysis Definitions for Financial State ====\n    // Let `bal` be the map stakes[era]; so, bal[acct] == balanceOf(acct)\n\n    // Entirely different concepts for the Drafts:\n    // `draft[acct]` is a \"draft record\". If, say, r = draft[acct], then:\n    //   Let `r.queue` be the map draftQueues[era][acct]\n    //   Let `r.left` be the value firstRemainingDraft[era][acct] // ( minus 1? )\n    //   Let `r.right` be the value draftsQueues[era][acct].length\n    //   We further define r.queue[-1].drafts to be 0.\n    //\n    // So, for any keyval pair (acct, r) in draft:\n    // r.left <= r.right\n    // for all i and j with r.left <= i < j < r.right:\n    //   r.queue[i].drafts < r.queue[j].drafts, and\n    //   r.queue[i].availableAt <= r.queue[j].availableAt\n    //\n    // Define draftSum, the total amount of drafts eventually due to the account holder of record r:\n    // Let draftSum(r:draftRecord) =\n    //   r.queue[r.right-1].drafts - r.queue[r.left-1].drafts\n\n    // ==== Invariants ====\n    // [total-stakes]: totalStakes == sum(bal[acct] for acct in bal)\n    // [max-stake-rate]: 0 < stakeRate <= MAX_STAKE_RATE\n    // [stake-rate]: if totalStakes == 0, then stakeRSR == 0 and stakeRate == FIX_ONE\n    //               else, stakeRSR * stakeRate >= totalStakes * 1e18\n    //               (ie, stakeRSR covers totalStakes at stakeRate)\n    //\n    // [total-drafts]: totalDrafts == sum(draftSum(draft[acct]) for acct in draft)\n    // [max-draft-rate]: 0 < draftRate <= MAX_DRAFT_RATE\n    // [draft-rate]: if totalDrafts == 0, then draftRSR == 0 and draftRate == FIX_ONE\n    //               else, draftRSR * draftRate >= totalDrafts * 1e18\n    //               (ie, draftRSR covers totalDrafts at draftRate)\n    //\n    // === ERC20Permit ===\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    // ==== Gov Params ====\n    // Promise: Each gov param is set _only_ by the appropriate \"set\" function.\n    // Invariant: rewardPeriod * 2 <= unstakingDelay\n    uint48 public unstakingDelay; // {s} The minimum length of time spent in the draft queue\n    uint48 public rewardPeriod; // {s} The number of seconds between revenue payout events\n    uint192 public rewardRatio; // {1} The fraction of the revenue balance to handout per period\n\n    // === Rewards Cache ===\n    // Promise: The two *payout* vars are modified only by init() and _payoutRewards()\n    //   init() pretends that the \"first\" payout happens at initialization time\n    //   _payoutRewards() updates them as described.\n    // When init() or _payoutRewards() was last called:\n    //     payoutLastPaid was the timestamp when the last paid-up block ended\n    //     rsrRewardsAtLastPayout was the value of rsrRewards() at that time\n\n    // {seconds} The last time when rewards were paid out\n    uint48 public payoutLastPaid;\n\n    // {qRSR} How much reward RSR was held the last time rewards were paid out\n    uint256 internal rsrRewardsAtLastPayout;\n\n    // ======================\n\n    // init() can only be called once (initializer)\n    // ==== Financial State:\n    // effects:\n    //   draft' = {}, bal' = {}, all totals zero, all rates FIX_ONE.\n    //   payoutLastPaid' = now\n    //   rsrRewardsAtLastPayout' = current RSR balance ( == rsrRewards() given the above )\n    function init(\n        IMain main_,\n        string calldata name_,\n        string calldata symbol_,\n        uint48 unstakingDelay_,\n        uint48 rewardPeriod_,\n        uint192 rewardRatio_\n    ) external initializer {\n        require(bytes(name_).length > 0, \"name empty\");\n        require(bytes(symbol_).length > 0, \"symbol empty\");\n        __Component_init(main_);\n        __EIP712_init(name_, \"1\");\n        name = name_;\n        symbol = symbol_;\n\n        assetRegistry = main_.assetRegistry();\n        backingManager = main_.backingManager();\n        basketHandler = main_.basketHandler();\n        rsr = IERC20(address(main_.rsr()));\n\n        payoutLastPaid = uint48(block.timestamp);\n        rsrRewardsAtLastPayout = main_.rsr().balanceOf(address(this));\n        setUnstakingDelay(unstakingDelay_);\n        setRewardPeriod(rewardPeriod_);\n        setRewardRatio(rewardRatio_);\n\n        beginEra();\n        beginDraftEra();\n    }\n\n    /// Assign reward payouts to the staker pool\n    /// @custom:refresher\n    function payoutRewards() external notPausedOrFrozen {\n        _payoutRewards();\n    }\n\n    /// Stakes an RSR `amount` on the corresponding RToken to earn yield and over-collateralize\n    /// the system\n    /// @param rsrAmount {qRSR}\n    /// @dev Staking continues while paused/frozen, without reward handouts\n    /// @custom:interaction CEI\n    // checks:\n    //   0 < rsrAmount\n    //\n    // effects:\n    //   stakeRSR' = stakeRSR + rsrAmount\n    //   totalStakes' = stakeRSR' * stakeRate / 1e18   (as required by invariant)\n    //   bal'[caller] = bal[caller] + (totalStakes' - totalStakes)\n    //   stakeRate' = stakeRate     (this could go without saying, but it's important!)\n    //\n    // actions:\n    //   rsr.transferFrom(account, this, rsrAmount)\n    function stake(uint256 rsrAmount) external {\n        require(rsrAmount > 0, \"Cannot stake zero\");\n\n        if (!main.pausedOrFrozen()) _payoutRewards();\n\n        // Compute stake amount\n        // This is not an overflow risk according to our expected ranges:\n        //   rsrAmount <= 1e29, totalStaked <= 1e38, 1e29 * 1e38 < 2^256.\n        // stakeAmount: how many stRSR the user shall receive.\n        // pick stakeAmount as big as we can such that (newTotalStakes <= newStakeRSR * stakeRate)\n        uint256 newStakeRSR = stakeRSR + rsrAmount;\n        // newTotalStakes: {qStRSR} = D18{qStRSR/qRSR} * {qRSR} / D18\n        uint256 newTotalStakes = (stakeRate * newStakeRSR) / FIX_ONE;\n        uint256 stakeAmount = newTotalStakes - totalStakes;\n\n        // Update staked\n        address account = _msgSender();\n        stakeRSR += rsrAmount;\n        _mint(account, stakeAmount);\n\n        // Transfer RSR from account to this contract\n        emit Staked(era, account, rsrAmount, stakeAmount);\n\n        // == Interactions ==\n        IERC20Upgradeable(address(rsr)).safeTransferFrom(account, address(this), rsrAmount);\n    }\n\n    /// Begins a delayed unstaking for `amount` StRSR\n    /// @param stakeAmount {qStRSR}\n    // checks:\n    //   not paused or frozen\n    //   0 < stakeAmount <= bal[caller]\n    //\n    // effects:\n    //   totalStakes' = totalStakes - stakeAmount\n    //   bal'[caller] = bal[caller] - stakeAmount\n    //   stakeRSR' = ceil(totalStakes' * 1e18 / stakeRate)\n    //   stakeRate' = stakeRate (no change)\n    //\n    //   draftRSR' + stakeRSR' = draftRSR + stakeRSR\n    //   draftRate' = draftRate (no change)\n    //   totalDrafts' = floor(draftRSR' + draftRate' / 1e18)\n    //\n    //   A draft for (totalDrafts' - totalDrafts) drafts\n    //   is freshly appended to the caller's draft record.\n    function unstake(uint256 stakeAmount) external notPausedOrFrozen {\n        address account = _msgSender();\n        require(stakeAmount > 0, \"Cannot withdraw zero\");\n        require(stakes[era][account] >= stakeAmount, \"Not enough balance\");\n\n        _payoutRewards();\n\n        // ==== Compute changes to stakes and RSR accounting\n        // rsrAmount: how many RSR to move from the stake pool to the draft pool\n        // pick rsrAmount as big as we can such that (newTotalStakes <= newStakeRSR * stakeRate)\n        _burn(account, stakeAmount);\n\n        // newStakeRSR: {qRSR} = D18 * {qStRSR} / D18{qStRSR/qRSR}\n        uint256 newStakeRSR = (FIX_ONE_256 * totalStakes + (stakeRate - 1)) / stakeRate;\n        uint256 rsrAmount = stakeRSR - newStakeRSR;\n        stakeRSR = newStakeRSR;\n\n        // Create draft\n        (uint256 index, uint64 availableAt) = pushDraft(account, rsrAmount);\n        emit UnstakingStarted(index, era, account, rsrAmount, stakeAmount, availableAt);\n    }\n\n    /// Complete an account's unstaking; callable by anyone\n    /// @custom:interaction RCEI\n    // Let:\n    //   r = draft[account]\n    //   draftAmount = r.queue[endId - 1].drafts - r.queue[r.left-1].drafts\n    //\n    // checks:\n    //   RToken is fully collateralized and the basket is sound.\n    //   The system is not paused or frozen.\n    //   endId <= r.right\n    //   r.queue[endId - 1].availableAt <= now\n    //\n    // effects:\n    //   r'.left = max(endId, r.left)\n    //   draftSum'(account) = draftSum(account) + draftAmount)\n    //   r'.right = r.right\n    //   totalDrafts' = totalDrafts - draftAmount\n    //   draftRSR' = ceil(totalDrafts' * 1e18 / draftRate)\n    //\n    // actions:\n    //   rsr.transfer(account, rsrOut)\n    function withdraw(address account, uint256 endId) external notPausedOrFrozen {\n        // == Refresh ==\n        assetRegistry.refresh();\n\n        // == Checks + Effects ==\n        require(basketHandler.fullyCollateralized(), \"RToken uncollateralized\");\n        require(basketHandler.status() == CollateralStatus.SOUND, \"basket defaulted\");\n\n        uint256 firstId = firstRemainingDraft[draftEra][account];\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n        if (endId == 0 || firstId >= endId) return;\n\n        require(endId <= queue.length, \"index out-of-bounds\");\n        require(queue[endId - 1].availableAt <= block.timestamp, \"withdrawal unavailable\");\n\n        uint192 oldDrafts = firstId > 0 ? queue[firstId - 1].drafts : 0;\n        uint192 draftAmount = queue[endId - 1].drafts - oldDrafts;\n\n        // advance queue past withdrawal\n        firstRemainingDraft[draftEra][account] = endId;\n\n        // ==== Compute RSR amount\n        uint256 newTotalDrafts = totalDrafts - draftAmount;\n        // newDraftRSR: {qRSR} = {qDrafts} * D18 / D18{qDrafts/qRSR}\n        uint256 newDraftRSR = (newTotalDrafts * FIX_ONE_256 + (draftRate - 1)) / draftRate;\n        uint256 rsrAmount = draftRSR - newDraftRSR;\n\n        if (rsrAmount == 0) return;\n\n        // ==== Transfer RSR from the draft pool\n        totalDrafts = newTotalDrafts;\n        draftRSR = newDraftRSR;\n\n        emit UnstakingCompleted(firstId, endId, draftEra, account, rsrAmount);\n\n        // == Interaction ==\n        IERC20Upgradeable(address(rsr)).safeTransfer(account, rsrAmount);\n    }\n\n    /// @param rsrAmount {qRSR}\n    /// Must seize at least `rsrAmount`, or revert\n    /// @custom:protected\n    // let:\n    //   keepRatio = 1 - (rsrAmount / rsr.balanceOf(this))\n    //\n    // checks:\n    //   0 < rsrAmount <= rsr.balanceOf(this)\n    //   not paused or frozen\n    //   caller is backingManager\n    //\n    // effects, in two phases. Phase 1: (from x to x')\n    //   stakeRSR' = floor(stakeRSR * keepRatio)\n    //   totalStakes' = totalStakes\n    //   stakeRate' = ceil(totalStakes' * 1e18 / stakeRSR')\n    //\n    //   draftRSR' = floor(draftRSR * keepRatio)\n    //   totalDrafts' = totalDrafts\n    //   draftRate' = ceil(totalDrafts' * 1e18 / draftRSR')\n    //\n    //   let fromRewards = floor(rsrRewards() * (1 - keepRatio))\n    //\n    // effects phase 2: (from x' to x'')\n    //   draftRSR'' = (draftRSR' <= MAX_DRAFT_RATE) ? draftRSR' : 0\n    //   if draftRSR'' = 0, then totalDrafts'' = 0 and draftRate'' = FIX_ONE\n    //   stakeRSR'' = (stakeRSR' <= MAX_STAKE_RATE) ? stakeRSR' : 0\n    //   if stakeRSR'' = 0, then totalStakes'' = 0 and stakeRate'' = FIX_ONE\n    //\n    // actions:\n    //   as (this), rsr.transfer(backingManager, seized)\n    //   where seized = draftRSR - draftRSR'' + stakeRSR - stakeRSR'' + fromRewards\n    //\n    // other properties:\n    //   seized >= rsrAmount, which should be a logical consequence of the above effects\n\n    function seizeRSR(uint256 rsrAmount) external notPausedOrFrozen {\n        require(_msgSender() == address(backingManager), \"not backing manager\");\n        require(rsrAmount > 0, \"Amount cannot be zero\");\n        uint192 initRate = exchangeRate();\n\n        uint256 rsrBalance = rsr.balanceOf(address(this));\n        require(rsrAmount <= rsrBalance, \"Cannot seize more RSR than we hold\");\n\n        uint256 seizedRSR;\n        uint256 rewards = rsrRewards();\n\n        // Remove RSR from stakeRSR\n        uint256 stakeRSRToTake = (stakeRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n        stakeRSR -= stakeRSRToTake;\n        seizedRSR = stakeRSRToTake;\n\n        // update stakeRate, possibly beginning a new stake era\n        if (stakeRSR > 0) {\n            // Downcast is safe: totalStakes is 1e38 at most so expression maximum value is 1e56\n            stakeRate = uint192((FIX_ONE_256 * totalStakes + (stakeRSR - 1)) / stakeRSR);\n        }\n        if (stakeRSR == 0 || stakeRate > MAX_STAKE_RATE) {\n            seizedRSR += stakeRSR;\n            beginEra();\n        }\n\n        // Remove RSR from draftRSR\n        uint256 draftRSRToTake = (draftRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n        draftRSR -= draftRSRToTake;\n        seizedRSR += draftRSRToTake;\n\n        // update draftRate, possibly beginning a new draft era\n        if (draftRSR > 0) {\n            // Downcast is safe: totalDrafts is 1e38 at most so expression maximum value is 1e56\n            draftRate = uint192((FIX_ONE_256 * totalDrafts + (draftRSR - 1)) / draftRSR);\n        }\n\n        if (draftRSR == 0 || draftRate > MAX_DRAFT_RATE) {\n            seizedRSR += draftRSR;\n            beginDraftEra();\n        }\n\n        // Remove RSR from yet-unpaid rewards (implicitly)\n        seizedRSR += (rewards * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n\n        // Transfer RSR to caller\n        emit ExchangeRateSet(initRate, exchangeRate());\n        IERC20Upgradeable(address(rsr)).safeTransfer(_msgSender(), seizedRSR);\n    }\n\n    /// @return D18{qRSR/qStRSR} The exchange rate between RSR and StRSR\n    function exchangeRate() public view returns (uint192) {\n        // D18{qRSR/qStRSR} = D18 * D18 / D18{qStRSR/qRSR}\n        return (FIX_SCALE_SQ + (stakeRate / 2)) / stakeRate; // ROUND method\n    }\n\n    /// Return the maximum value of endId such that withdraw(endId) can immediately work\n    // let r = draft[account]\n    // returns:\n    //   if r.left == r.right: r.right (i.e, withdraw 0 drafts)\n    //   else: the least id such that r.left <= id <= r.right and r.queue[id].availableAt > now\n    function endIdForWithdraw(address account) external view returns (uint256) {\n        uint256 time = block.timestamp;\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n\n        // Bounds our search for the current cumulative draft\n        (uint256 left, uint256 right) = (firstRemainingDraft[draftEra][account], queue.length);\n\n        // If there are no drafts to be found, return 0 drafts\n        if (left >= right) return right;\n        if (queue[left].availableAt > time) return left;\n\n        // Otherwise, there *are* drafts with left <= index < right and availableAt <= time.\n        // Binary search:\n        uint256 test;\n        while (left < right - 1) {\n            // Loop invariants, because without great care a binary search is usually wrong:\n            // - queue[left].availableAt <= time\n            // - either right == queue.length or queue[right].availableAt > time\n            test = (left + right) / 2; // left < test < right because left < right - 1\n            if (queue[test].availableAt <= time) left = test;\n            else right = test;\n        }\n        return right;\n    }\n\n    /// Used by FacadeP1\n    /// @return The length of the draft queue for an account in an era\n    function draftQueueLen(uint256 era_, address account) external view returns (uint256) {\n        return draftQueues[era_][account].length;\n    }\n\n    // ==== Internal Functions ====\n\n    /// Assign reward payouts to the staker pool\n    /// @dev do this by effecting stakeRSR and payoutLastPaid as appropriate, given the current\n    /// value of rsrRewards()\n    /// @dev perhaps astonishingly, this _isn't_ a refresher\n\n    // let\n    //   N = numPeriods; the number of whole rewardPeriods since the last payout\n    //   payout = rsrRewards() * (1 - (1 - rewardRatio)^N)  (see [strsr-payout-formula])\n    //\n    // effects:\n    //   stakeRSR' = stakeRSR + payout\n    //   rsrRewards'() = rsrRewards() - payout   (implicit in the code, but true)\n    //   stakeRate' = ceil(totalStakes' * 1e18 / stakeRSR')  (because [stake-rate])\n    //     unless totalStakes == 0 or stakeRSR == 0, in which case stakeRate' = FIX_ONE\n    //   totalStakes' = totalStakes\n    //\n    // [strsr-payout-formula]:\n    //   The process we're modelling is:\n    //     N = number of whole rewardPeriods since last _payoutRewards() call\n    //     rewards_0 = rsrRewards()\n    //     payout_{i+1} = rewards_i * payoutRatio\n    //     rewards_{i+1} = rewards_i - payout_{i+1}\n    //     payout = sum{payout_i for i in [1...N]}\n    //   thus:\n    //     rewards_N = rewards_0 - payout\n    //     rewards_{i+1} = rewards_i - rewards_i * payoutRatio = rewards_i * (1-payoutRatio)\n    //     rewards_N = rewards_0 * (1-payoutRatio) ^ N\n    //     payout = rewards_N - rewards_0 = rewards_0 * (1 - (1-payoutRatio)^N)\n    function _payoutRewards() internal {\n        if (block.timestamp < payoutLastPaid + rewardPeriod) return;\n        uint48 numPeriods = (uint48(block.timestamp) - payoutLastPaid) / rewardPeriod;\n\n        uint192 initRate = exchangeRate();\n        uint256 payout;\n\n        // Do an actual payout if and only if stakers exist!\n        if (totalStakes > 0) {\n            // Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.\n            // Apply payout to RSR backing\n            // payoutRatio: D18 = FIX_ONE: D18 - FixLib.powu(): D18\n            // Both uses of uint192(-) are fine, as it's equivalent to FixLib.sub().\n            uint192 payoutRatio = FIX_ONE - FixLib.powu(FIX_ONE - rewardRatio, numPeriods);\n\n            // payout: {qRSR} = D18{1} * {qRSR} / D18\n            payout = (payoutRatio * rsrRewardsAtLastPayout) / FIX_ONE;\n            stakeRSR += payout;\n        }\n\n        payoutLastPaid += numPeriods * rewardPeriod;\n        rsrRewardsAtLastPayout = rsrRewards();\n\n        // stakeRate else case: D18{qStRSR/qRSR} = {qStRSR} * D18 / {qRSR}\n        // downcast is safe: it's at most 1e38 * 1e18 = 1e56\n        // untestable:\n        //      the second half of the OR comparison is untestable because of the invariant:\n        //      if totalStakes == 0, then stakeRSR == 0\n        stakeRate = (stakeRSR == 0 || totalStakes == 0)\n            ? FIX_ONE\n            : uint192((totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR);\n\n        emit RewardsPaid(payout);\n        emit ExchangeRateSet(initRate, exchangeRate());\n    }\n\n    /// @param rsrAmount {qRSR}\n    /// @return index The index of the draft\n    /// @return availableAt {s} The timestamp the cumulative draft vests\n    // effects:\n    //   draftRSR' = draftRSR + rsrAmount\n    //   draftRate' = draftRate    (ie, unchanged)\n    //   totalDrafts' = floor(draftRSR' * draftRate' / 1e18)\n    //   r'.left = r.left\n    //   r'.right = r.right + 1\n    //   r'.queue is r.queue with a new entry appeneded for (totalDrafts' - totalDraft) drafts\n    //   where r = draft[account] and r' = draft'[account]\n    function pushDraft(address account, uint256 rsrAmount)\n        internal\n        returns (uint256 index, uint64 availableAt)\n    {\n        // draftAmount: how many drafts to create and assign to the user\n        // pick draftAmount as big as we can such that (newTotalDrafts <= newDraftRSR * draftRate)\n        draftRSR += rsrAmount;\n        // newTotalDrafts: {qDrafts} = D18{qDrafts/qRSR} * {qRSR} / D18\n        uint256 newTotalDrafts = (draftRate * draftRSR) / FIX_ONE;\n        uint256 draftAmount = newTotalDrafts - totalDrafts;\n        totalDrafts = newTotalDrafts;\n\n        // Push drafts into account's draft queue\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n        index = queue.length;\n\n        uint192 oldDrafts = index > 0 ? queue[index - 1].drafts : 0;\n        uint64 lastAvailableAt = index > 0 ? queue[index - 1].availableAt : 0;\n        availableAt = uint64(block.timestamp) + unstakingDelay;\n        if (lastAvailableAt > availableAt) {\n            availableAt = lastAvailableAt;\n        }\n\n        queue.push(CumulativeDraft(uint176(oldDrafts + draftAmount), availableAt));\n    }\n\n    /// Zero all stakes and withdrawals\n    /// Overriden in StRSRVotes to handle rebases\n    // effects:\n    //   stakeRSR' = totalStakes' = 0\n    //   stakeRate' = FIX_ONE\n    function beginEra() internal virtual {\n        stakeRSR = 0;\n        totalStakes = 0;\n        stakeRate = FIX_ONE;\n        era++;\n\n        emit AllBalancesReset(era);\n    }\n\n    // effects:\n    //  draftRSR' = totalDrafts' = 0\n    //  draftRate' = FIX_ONE\n    function beginDraftEra() internal virtual {\n        draftRSR = 0;\n        totalDrafts = 0;\n        draftRate = FIX_ONE;\n        draftEra++;\n\n        emit AllUnstakingReset(draftEra);\n    }\n\n    /// @return {qRSR} The balance of RSR that this contract owns dedicated to future RSR rewards.\n    function rsrRewards() internal view returns (uint256) {\n        return rsr.balanceOf(address(this)) - stakeRSR - draftRSR;\n    }\n\n    // ==== ERC20 ====\n    // This section extracted from ERC20; adjusted to work with stakes/eras\n    // name(), symbol(), and decimals() are all auto-generated\n\n    function totalSupply() public view returns (uint256) {\n        return totalStakes;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return stakes[era][account];\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[era][owner][spender];\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        _spendAllowance(from, _msgSender(), amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[era][owner][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[era][owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    // checks: from != 0, to != 0,\n    // effects: bal[from] -= amount; bal[to] += amount;\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        mapping(address => uint256) storage eraStakes = stakes[era];\n        uint256 fromBalance = eraStakes[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            eraStakes[from] = fromBalance - amount;\n        }\n        eraStakes[to] += amount;\n\n        emit Transfer(from, to"
    }
  ]
}