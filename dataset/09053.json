{
  "Title": "[06] `ConduitTransfer` identifier field can be dirty and unused",
  "Content": "\nThere are two external entry points `execute(ConduitBatch1155Transfer[] calldata batchTransfers)` and `executeWithBatch1155(ConduitTransfer[] calldata standardTransfers, ConduitBatch1155Transfer[] calldata batchTransfers)` which trigger the internal [`_transfer(...)`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/conduit/Conduit.sol#L174) function. It works off this data structure:\n```solidity\nstruct ConduitTransfer {\n    ConduitItemType itemType;\n    address token;\n    address from;\n    address to;\n    uint256 identifier;\n    uint256 amount;\n}\n```\n\nThe `_transfer` function only supports the ERC-20/ERC-721/ERC-1155 item types, where it ensures that `amount == 1` for ERC-721, but allows `identifier` to be anything for ERC-20 transfers.\n\nIt could be:\n1) used to create multiple transactions which have identical outcomes (since the field is ignored)\n2) misused to masquerade an ERC-20 transfer to look more similar to an ERC-721 transfer.\n\nThis problem is similar to the `SpentItem/ReceivedItem fields can be dirty and unused` issue and can be triggered through that transaction, but since the `Conduit` is a general purpose feature and could be used and triggered by other contracts too.\n\nWe believe that can have severe risks in the future. But it is hard to argue about the severity of this currently due to lack of clarity on what kinds of applications would be built on top of conduits.\n\n### Proof of Concept\n**Context:** [Conduit.sol#L174](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/conduit/Conduit.sol#L174), [Conduit.sol#L52](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/conduit/Conduit.sol#L52), [Conduit.sol#L117](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/conduit/Conduit.sol#L117)\n\n### Recommended Mitigation Steps\n\nInsert check that `item.identifier == 0` for `ConduitItemType.ERC20`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/conduit/Conduit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\n\nimport { ConduitItemType } from \"./lib/ConduitEnums.sol\";\n\nimport { TokenTransferrer } from \"../lib/TokenTransferrer.sol\";\n\n// prettier-ignore\nimport {\n    ConduitTransfer,\n    ConduitBatch1155Transfer\n} from \"./lib/ConduitStructs.sol\";\n\n/**\n * @title Conduit\n * @author 0age\n * @notice This contract serves as an originator for \"proxied\" transfers. Each\n *         conduit is deployed and controlled by a \"conduit controller\" that can\n *         add and remove \"channels\" or contracts that can instruct the conduit\n *         to transfer approved ERC20/721/1155 tokens. *IMPORTANT NOTE: each\n *         conduit has an owner that can arbitrarily add or remove channels, and\n *         a malicious or negligent owner can add a channel that allows for any\n *         approved ERC20/721/1155 tokens to be taken immediately — be extremely\n *         cautious with what conduits you give token approvals to!*\n */\ncontract Conduit is ConduitInterface, TokenTransferrer {\n    // Set deployer as an immutable controller that can update channel statuses.\n    address private immutable _controller;\n\n    // Track the status of each channel.\n    mapping(address => bool) private _channels;\n\n    /**\n     * @notice In the constructor, set the deployer as the controller.\n     */\n    constructor() {\n        // Set the deployer as the controller.\n        _controller = msg.sender;\n    }\n\n    /**\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\n     *         with an open channel can call this function.\n     *\n     * @param transfers The ERC20/721/1155 transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function execute(ConduitTransfer[] calldata transfers)\n        external\n        override\n        returns (bytes4 magicValue)\n    {\n        // Ensure that the caller has an open channel.\n        if (!_channels[msg.sender]) {\n            revert ChannelClosed();\n        }\n\n        // Retrieve the total number of transfers and place on the stack.\n        uint256 totalStandardTransfers = transfers.length;\n\n        // Iterate over each transfer.\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\n            // Retrieve the transfer in question.\n            ConduitTransfer calldata standardTransfer = transfers[i];\n\n            // Perform the transfer.\n            _transfer(standardTransfer);\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.execute.selector;\n    }\n\n    /**\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\n     *         open channel can call this function.\n     *\n     * @param batchTransfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeBatch1155(\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) external override returns (bytes4 magicValue) {\n        // Ensure that the caller has an open channel.\n        if (!_channels[msg.sender]) {\n            revert ChannelClosed();\n        }\n\n        // Perform 1155 batch transfers.\n        _performERC1155BatchTransfers(batchTransfers);\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.executeBatch1155.selector;\n    }\n\n    /**\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\n     *         a caller with an open channel can call this function.\n     *\n     * @param standardTransfers The ERC20/721/1155 transfers to perform.\n     * @param batchTransfers    The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeWithBatch1155(\n        ConduitTransfer[] calldata standardTransfers,\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) external override returns (bytes4 magicValue) {\n        // Ensure that the caller has an open channel.\n        if (!_channels[msg.sender]) {\n            revert ChannelClosed();\n        }\n\n        // Retrieve the total number of transfers and place on the stack.\n        uint256 totalStandardTransfers = standardTransfers.length;\n\n        // Iterate over each standard transfer.\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\n            // Retrieve the transfer in question.\n            ConduitTransfer calldata standardTransfer = standardTransfers[i];\n\n            // Perform the transfer.\n            _transfer(standardTransfer);\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Perform 1155 batch transfers.\n        _performERC1155BatchTransfers(batchTransfers);\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.executeWithBatch1155.selector;\n    }\n\n    /**\n     * @notice Open or close a given channel. Only callable by the controller.\n     *\n     * @param channel The channel to open or close.\n     * @param isOpen  The status of the channel (either open or closed).\n     */\n    function updateChannel(address channel, bool isOpen) external override {\n        // Ensure that the caller is the controller of this contract.\n        if (msg.sender != _controller) {\n            revert InvalidController();\n        }\n\n        // Update the status of the channel.\n        _channels[channel] = isOpen;\n\n        // Emit a corresponding event.\n        emit ChannelUpdated(channel, isOpen);\n    }\n\n    /**\n     * @dev Internal function to transfer a given ERC20/721/1155 item.\n     *\n     * @param item The ERC20/721/1155 item to transfer.\n     */\n    function _transfer(ConduitTransfer calldata item) internal {\n        // If the item type indicates Ether or a native token...\n        if (item.itemType == ConduitItemType.ERC20) {\n            // Transfer ERC20 token.\n            _performERC20Transfer(item.token, item.from, item.to, item.amount);\n        } else if (item.itemType == ConduitItemType.ERC721) {\n            // Ensure that exactly one 721 item is being transferred.\n            if (item.amount != 1) {\n                revert InvalidERC721TransferAmount();\n            }\n\n            // Transfer ERC721 token.\n            _performERC721Transfer(\n                item.token,\n                item.from,\n                item.to,\n                item.identifier\n            );\n        } else if (item.itemType == ConduitItemType.ERC1155) {\n            // Transfer ERC1155 token.\n            _performERC1155Transfer(\n                item.token,\n                item.from,\n                item.to,\n                item.identifier,\n                item.amount\n            );\n        } else {\n            // Throw with an error.\n            revert InvalidItemType();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/conduit/Conduit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\n\nimport { ConduitItemType } from \"./lib/ConduitEnums.sol\";\n\nimport { TokenTransferrer } from \"../lib/TokenTransferrer.sol\";\n\n// prettier-ignore\nimport {\n    ConduitTransfer,\n    ConduitBatch1155Transfer\n} from \"./lib/ConduitStructs.sol\";\n\n/**\n * @title Conduit\n * @author 0age\n * @notice This contract serves as an originator for \"proxied\" transfers. Each\n *         conduit is deployed and controlled by a \"conduit controller\" that can\n *         add and remove \"channels\" or contracts that can instruct the conduit\n *         to transfer approved ERC20/721/1155 tokens. *IMPORTANT NOTE: each\n *         conduit has an owner that can arbitrarily add or remove channels, and\n *         a malicious or negligent owner can add a channel that allows for any\n *         approved ERC20/721/1155 tokens to be taken immediately — be extremely\n *         cautious with what conduits you give token approvals to!*\n */\ncontract Conduit is ConduitInterface, TokenTransferrer {\n    // Set deployer as an immutable controller that can update channel statuses.\n    address private immutable _controller;\n\n    // Track the status of each channel.\n    mapping(address => bool) private _channels;\n\n    /**\n     * @notice In the constructor, set the deployer as the controller.\n     */\n    constructor() {\n        // Set the deployer as the controller.\n        _controller = msg.sender;\n    }\n\n    /**\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\n     *         with an open channel can call this function.\n     *\n     * @param transfers The ERC20/721/1155 transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function execute(ConduitTransfer[] calldata transfers)\n        external\n        override\n        returns (bytes4 magicValue)\n    {\n        // Ensure that the caller has an open channel.\n        if (!_channels[msg.sender]) {\n            revert ChannelClosed();\n        }\n\n        // Retrieve the total number of transfers and place on the stack.\n        uint256 totalStandardTransfers = transfers.length;\n\n        // Iterate over each transfer.\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\n            // Retrieve the transfer in question.\n            ConduitTransfer calldata standardTransfer = transfers[i];\n\n            // Perform the transfer.\n            _transfer(standardTransfer);\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.execute.selector;\n    }\n\n    /**\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\n     *         open channel can call this function.\n     *\n     * @param batchTransfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeBatch1155(\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) external override returns (bytes4 magicValue) {\n        // Ensure that the caller has an open channel.\n        if (!_channels[msg.sender]) {\n            revert ChannelClosed();\n        }\n\n        // Perform 1155 batch transfers.\n        _performERC1155BatchTransfers(batchTransfers);\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.executeBatch1155.selector;\n    }\n\n    /**\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\n     *         a caller with an open channel can call this function.\n     *\n     * @param standardTransfers The ERC20/721/1155 transfers to perform.\n     * @param batchTransfers    The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeWithBatch1155(\n        ConduitTransfer[] calldata standardTransfers,\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) external override returns (bytes4 magicValue) {\n        // Ensure that the caller has an open channel.\n        if (!_channels[msg.sender]) {\n            revert ChannelClosed();\n        }\n\n        // Retrieve the total number of transfers and place on the stack.\n        uint256 totalStandardTransfers = standardTransfers.length;\n\n        // Iterate over each standard transfer.\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\n            // Retrieve the transfer in question.\n            ConduitTransfer calldata standardTransfer = standardTransfers[i];\n\n            // Perform the transfer.\n            _transfer(standardTransfer);\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Perform 1155 batch transfers.\n        _performERC1155BatchTransfers(batchTransfers);\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.executeWithBatch1155.selector;\n    }\n\n    /**\n     * @notice Open or close a given channel. Only callable by the controller.\n     *\n     * @param channel The channel to open or close.\n     * @param isOpen  The status of the channel (either open or closed).\n     */\n    function updateChannel(address channel, bool isOpen) external override {\n        // Ensure that the caller is the controller of this contract.\n        if (msg.sender != _controller) {\n            revert InvalidController();\n        }\n\n        // Update the status of the channel.\n        _channels[channel] = isOpen;\n\n        // Emit a corresponding event.\n        emit ChannelUpdated(channel, isOpen);\n    }\n\n    /**\n     * @dev Internal function to transfer a given ERC20/721/1155 item.\n     *\n     * @param item The ERC20/721/1155 item to transfer.\n     */\n    function _transfer(ConduitTransfer calldata item) internal {\n        // If the item type indicates Ether or a native token...\n        if (item.itemType == ConduitItemType.ERC20) {\n            // Transfer ERC20 token.\n            _performERC20Transfer(item.token, item.from, item.to, item.amount);\n        } else if (item.itemType == ConduitItemType.ERC721) {\n            // Ensure that exactly one 721 item is being transferred.\n            if (item.amount != 1) {\n                revert InvalidERC721TransferAmount();\n            }\n\n            // Transfer ERC721 token.\n            _performERC721Transfer(\n                item.token,\n                item.from,\n                item.to,\n                item.identifier\n            );\n        } else if (item.itemType == ConduitItemType.ERC1155) {\n            // Transfer ERC1155 token.\n            _performERC1155Transfer(\n                item.token,\n                item.from,\n                item.to,\n                item.identifier,\n                item.amount\n            );\n        } else {\n            // Throw with an error.\n            revert InvalidItemType();\n        }\n    }\n}"
    }
  ]
}