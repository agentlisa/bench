{
  "Title": "H-9: IdleProvider's balanceUnderlying and calcShares outputs are misscaled by up to 10^12",
  "Content": "# Issue H-9: IdleProvider's balanceUnderlying and calcShares outputs are misscaled by up to 10^12 \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/225 \n\n## Found by \nhyh\n\n## Summary\n\nbalanceUnderlying() returns values scaled with Idle LP token decimals instead of the underlying decimals.\n\ncalcShares() returns values scaled with underlying decimals instead of the LP token decimals.\n\n## Vulnerability Detail\n\nCore reason is exchangeRate() output is similarly and incorrectly processed in both functions. This results in wrong decimals of the both return values.\n\nIdle LP tokens have 18 decimals, while underlying token decimals can differ: for example, while Idle USDC tokens have 18 decimals, USDC have 6.\n\n## Impact\n\nAmount of the underlying held by Idle pool and amount of shares needed for a withdrawal can be misstated by magnitudes wheneven underlying token decimals aren't 18, which can lead to protocol-wide losses.\n\nSpecifically for USDC and USDT cases balanceUnderlying() is overstated by `10^12`, while calcShares() is understated by `10^12`.\n\n## Code Snippet\n\nbalanceUnderlying() cancels out exchangeRate() decimals with dividing by `10^(Underlying Token Decimals)`, which results in Idle LP token decimals:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/IdleProvider.sol#L79-L92\n\n```solidity\n  /// @notice Get balance from address in underlying token\n  /// @dev balance = poolvalue * shares / totalsupply\n  /// @param _address Address to request balance from, most likely an Vault\n  /// @param _iToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _iToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _iToken);\n    uint256 price = exchangeRate(_iToken);\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\n    return (balanceShares * price) / 10 ** decimals;\n  }\n```\n\nAs balance() returns Idle token balance and have Idle LP token decimals of 18:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/IdleProvider.sol#L109-L111\n\n```solidity\n  function balance(address _address, address _iToken) public view override returns (uint256) {\n    return IIdle(_iToken).balanceOf(_address);\n  }\n```\n\nWhile exchangeRate() is scaled with underlying token decimals:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/IdleProvider.sol#L113-L118\n\n```solidity\n  /// @notice Exchange rate of underyling protocol token\n  /// @param _iToken Address of protocol LP Token eg yUSDC\n  /// @return price of LP token\n  function exchangeRate(address _iToken) public view override returns (uint256) {\n    return IIdle(_iToken).tokenPrice();\n  }\n```\n\nhttps://github.com/Idle-Labs/idle-contracts/blob/develop/contracts/IdleTokenV3_1.sol#L240-L245\n\n```solidity\n  /**\n   * IdleToken price calculation, in underlying\n   *\n   * @return : price in underlying token\n   */\n  function tokenPrice() external view returns (uint256) {}\n```\n\nIdle LP token decimals are fixed, while underlying token decimals vary.\n\nFor example, while USDC underlying have 6 decimals, it's 18 decimals for Idle USDC:\n\nhttps://etherscan.io/token/0x5274891bec421b39d23760c04a6755ecb444797c\n\nhttps://etherscan.io/token/0xcddb1bceb7a1979c6caa0229820707429dd3ec6c\n\nbalanceUnderlying() is used in Vault rebalancing:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L178-L192\n\n```solidity\n  function rebalanceCheckProtocols(\n    uint256 _newTotalUnderlying\n  ) internal returns (uint256[] memory) {\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      storePriceAndRewards(_newTotalUnderlying, i);\n\n      if (isBlacklisted) continue;\n      setAllocation(i);\n\n      int256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\n      uint256 currentBalance = balanceUnderlying(i);\n```\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L111-L118\n\n```solidity\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n```\n\nSimilarly in calcShares() the `shares` scale is corrected wrongly, resulting with it having underlying decimals instead of LP token decimals (`exchangeRate(_cToken)` has `decimals` scale cancelled by `10 ** decimals`, `_amount` is in underlying):\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/IdleProvider.sol#L94-L103\n\n```solidity\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev shares = totalsupply * balance / poolvalue\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _iToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _iToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\n    uint256 shares = (_amount * (10 ** decimals)) / exchangeRate(_iToken);\n    return shares;\n  }\n```\n\ncalcShares() is used in rebalancing as well:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L307-L315\n\n```solidity\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    if (_amount <= 0) return;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    _amount = (_amount * protocol.uScale) / uScale;\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIdle exchange rate is specifically scaled so that `LPToken_balance * price` has `18 + Underlying Token Decimals`, so it's enough to use `1e18`:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/IdleProvider.sol#L79-L92\n\n```diff\n  /// @notice Get balance from address in underlying token\n  /// @dev balance = poolvalue * shares / totalsupply\n  /// @param _address Address to request balance from, most likely an Vault\n  /// @param _iToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _iToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _iToken);\n    uint256 price = exchangeRate(_iToken);\n-   uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\n-   return (balanceShares * price) / 10 ** decimals;\n+   return (balanceShares * price) / 1e18;\n  }\n```\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/IdleProvider.sol#L94-L103\n\n```diff\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev shares = totalsupply * balance / poolvalue\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _iToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _iToken) external view override returns (uint256) {\n-   uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\n-   uint256 shares = (_amount * (10 ** decimals)) / exchangeRate(_iToken);\n-   return shares;\n+   return (_amount * 1e18) / exchangeRate(_iToken);\n  }\n```\n\n\n\n\n## Discussion\n\n**dmitriia**\n\nEscalate for 10 USDC\n202 and this aren't duplicates.\n\n202 deals with CompoundProvider's treatment of cToken exchange rate in balanceUnderlying() and calcShares().\n\nThis issue is about IdleProvider's balanceUnderlying() and calcShares(). The fact that resulting recommendations look similar is a mere coincidence as Idle and Compound have different mechanics (i.e. both were misunderstood, but separately and in a different way).\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> 202 and this aren't duplicates.\n> \n> 202 deals with CompoundProvider's treatment of cToken exchange rate in balanceUnderlying() and calcShares().\n> \n> This issue is about IdleProvider's balanceUnderlying() and calcShares(). The fact that resulting recommendations look similar is a mere coincidence as Idle and Compound have different mechanics (i.e. both were misunderstood, but separately and in a different way).\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue separate from #202, although the functions and the mitigation is similar, the underlying calculations are different and need to be addressed separately. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue separate from #202, although the functions and the mitigation is similar, the underlying calculations are different and need to be addressed separately. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Providers/IdleProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IIdle.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract IdleProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Idle\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Idle, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _iToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_iToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 tTokenBefore = IIdle(_iToken).balanceOf(address(this));\r\n    // expensive mint\r\n    IIdle(_iToken).mintIdleToken(_amount, true, address(0));\r\n    uint256 tTokenAfter = IIdle(_iToken).balanceOf(address(this));\r\n\r\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\r\n    IIdle(_iToken).transfer(msg.sender, tTokensReceived);\r\n\r\n    return tTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Idle\r\n  /// @dev Pulls tTokens from Vault, redeem them from Idle, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _iToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      IIdle(_iToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    IIdle(_iToken).redeemIdleToken(_amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _iToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _iToken);\r\n    uint256 price = exchangeRate(_iToken);\r\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\r\n    return (balanceShares * price) / 10 ** decimals;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _iToken) external view override returns (uint256) {\r\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\r\n    uint256 shares = (_amount * (10 ** decimals)) / exchangeRate(_iToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _iToken) public view override returns (uint256) {\r\n    return IIdle(_iToken).balanceOf(_address);\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @param _iToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _iToken) public view override returns (uint256) {\r\n    return IIdle(_iToken).tokenPrice();\r\n  }\r\n\r\n  function claim(address _iToken, address _claimer) external override returns (bool) {}\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/IdleProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IIdle.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract IdleProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Idle\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Idle, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _iToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_iToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 tTokenBefore = IIdle(_iToken).balanceOf(address(this));\r\n    // expensive mint\r\n    IIdle(_iToken).mintIdleToken(_amount, true, address(0));\r\n    uint256 tTokenAfter = IIdle(_iToken).balanceOf(address(this));\r\n\r\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\r\n    IIdle(_iToken).transfer(msg.sender, tTokensReceived);\r\n\r\n    return tTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Idle\r\n  /// @dev Pulls tTokens from Vault, redeem them from Idle, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _iToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      IIdle(_iToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    IIdle(_iToken).redeemIdleToken(_amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _iToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _iToken);\r\n    uint256 price = exchangeRate(_iToken);\r\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\r\n    return (balanceShares * price) / 10 ** decimals;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _iToken) external view override returns (uint256) {\r\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\r\n    uint256 shares = (_amount * (10 ** decimals)) / exchangeRate(_iToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _iToken) public view override returns (uint256) {\r\n    return IIdle(_iToken).balanceOf(_address);\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @param _iToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _iToken) public view override returns (uint256) {\r\n    return IIdle(_iToken).tokenPrice();\r\n  }\r\n\r\n  function claim(address _iToken, address _claimer) external override returns (bool) {}\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/IdleProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IIdle.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract IdleProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Idle\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Idle, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _iToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_iToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 tTokenBefore = IIdle(_iToken).balanceOf(address(this));\r\n    // expensive mint\r\n    IIdle(_iToken).mintIdleToken(_amount, true, address(0));\r\n    uint256 tTokenAfter = IIdle(_iToken).balanceOf(address(this));\r\n\r\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\r\n    IIdle(_iToken).transfer(msg.sender, tTokensReceived);\r\n\r\n    return tTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Idle\r\n  /// @dev Pulls tTokens from Vault, redeem them from Idle, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _iToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      IIdle(_iToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    IIdle(_iToken).redeemIdleToken(_amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _iToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _iToken);\r\n    uint256 price = exchangeRate(_iToken);\r\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\r\n    return (balanceShares * price) / 10 ** decimals;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _iToken) external view override returns (uint256) {\r\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\r\n    uint256 shares = (_amount * (10 ** decimals)) / exchangeRate(_iToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _iToken) public view override returns (uint256) {\r\n    return IIdle(_iToken).balanceOf(_address);\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @param _iToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _iToken) public view override returns (uint256) {\r\n    return IIdle(_iToken).tokenPrice();\r\n  }\r\n\r\n  function claim(address _iToken, address _claimer) external override returns (bool) {}\r\n}"
    },
    {
      "filename": "contracts/IdleTokenV3_1.sol",
      "content": "/**\n * @title: Idle Token Bootstrap contract\n * @summary: Used to deploy a new instance of an idleToken. The contract will then\n * be upgraded to IdleTokenGovernance\n * @author: Idle Labs Inc., idle.finance\n */\npragma solidity 0.5.16;\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\";\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/lifecycle/Pausable.sol\";\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./interfaces/iERC20Fulcrum.sol\";\nimport \"./interfaces/ILendingProtocol.sol\";\nimport \"./interfaces/IGovToken.sol\";\nimport \"./interfaces/IIdleTokenV3_1.sol\";\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\n\nimport \"./interfaces/Comptroller.sol\";\nimport \"./interfaces/CERC20.sol\";\nimport \"./interfaces/IdleController.sol\";\nimport \"./interfaces/PriceOracle.sol\";\nimport \"./interfaces/IUniswapV2Router02.sol\";\nimport \"./interfaces/IIdleTokenHelper.sol\";\n\nimport \"./GST2ConsumerV2.sol\";\n\ncontract IdleTokenV3_1 is Initializable, ERC20, ERC20Detailed, ReentrancyGuard, Ownable, Pausable, IIdleTokenV3_1, GST2ConsumerV2 {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  uint256 private constant ONE_18 = 10**18;\n  // State variables\n  // eg. DAI address\n  address public token;\n  // eg. iDAI address\n  address private iToken;\n  // eg. cDAI address\n  address private cToken;\n  // Idle rebalancer current implementation address\n  address public rebalancer;\n  // Address collecting underlying fees\n  address public feeAddress;\n  // Last iToken price, used to pause contract in case of a black swan event\n  uint256 public lastITokenPrice;\n  // eg. 18 for DAI\n  uint256 private tokenDecimals;\n  // Max unlent assets percentage for gas friendly swaps\n  uint256 public maxUnlentPerc; // 100000 == 100% -> 1000 == 1%\n  // Current fee on interest gained\n  uint256 public fee;\n  // eg. [cTokenAddress, iTokenAddress, ...]\n  address[] public allAvailableTokens;\n  // eg. [COMPAddress, CRVAddress, ...]\n  address[] public govTokens;\n  // last fully applied allocations (ie when all liquidity has been correctly placed)\n  // eg. [5000, 0, 5000, 0] for 50% in compound, 0% fulcrum, 50% aave, 0 dydx. same order of allAvailableTokens\n  uint256[] public lastAllocations;\n  // Map that saves avg idleToken price paid for each user, used to calculate earnings\n  mapping(address => uint256) public userAvgPrices;\n  // eg. cTokenAddress => IdleCompoundAddress\n  mapping(address => address) public protocolWrappers;\n  // array with last balance recorded for each gov tokens\n  mapping (address => uint256) public govTokensLastBalances;\n  // govToken -> user_address -> user_index eg. usersGovTokensIndexes[govTokens[0]][msg.sender] = 1111123;\n  mapping (address => mapping (address => uint256)) public usersGovTokensIndexes;\n  // global indices for each gov tokens used as a reference to calculate a fair share for each user\n  mapping (address => uint256) public govTokensIndexes;\n  // Map that saves amount with no fee for each user\n  mapping(address => uint256) private userNoFeeQty;\n  // variable used for avoid the call of mint and redeem in the same tx\n  bytes32 private _minterBlock;\n\n  // Events\n  event Rebalance(address _rebalancer, uint256 _amount);\n  event Referral(uint256 _amount, address _ref);\n\n  // ########## IdleToken V4_1 updates\n  // Idle governance token\n  address public constant IDLE = address(0x875773784Af8135eA0ef43b5a374AaD105c5D39e);\n  // Compound governance token\n  address public constant COMP = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n  uint256 private constant FULL_ALLOC = 100000;\n\n  // Idle distribution controller\n  address public constant idleController = address(0x275DA8e61ea8E02d51EDd8d0DC5c0E62b4CDB0BE);\n  // oracle used for calculating the avgAPR with gov tokens\n  address public oracle;\n  // eg cDAI -> COMP\n  mapping(address => address) private protocolTokenToGov;\n  // Whether openRebalance is enabled or not\n  bool public isRiskAdjusted;\n  // last allocations submitted by rebalancer\n  uint256[] private lastRebalancerAllocations;\n\n  // ########## IdleToken V5 updates\n  // Fee for flash loan\n  uint256 public flashLoanFee;\n  // IdleToken helper address\n  address public tokenHelper;\n\n  /**\n  * @dev Emitted on flashLoan()\n  * @param target The address of the flash loan receiver contract\n  * @param initiator The address initiating the flash loan\n  * @param amount The amount flash borrowed\n  * @param premium The fee flash borrowed\n  **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    uint256 amount,\n    uint256 premium\n  );\n\n  // Addresses for stkAAVE distribution from Aave\n  address public constant stkAAVE = address(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\n  address private aToken;\n\n  // ####################################################\n  // ################# INIT METHODS #####################\n  // ####################################################\n\n  /**\n   * It allows owner to manually initialize new contract implementation which supports IDLE distribution\n   *\n   * @param _newGovTokens : array of gov token addresses\n   * @param _protocolTokens : array of protocol tokens supported\n   * @param _wrappers : array of wrappers for protocol tokens\n   * @param _lastRebalancerAllocations : array of allocations\n   * @param _isRiskAdjusted : flag whether is risk adjusted or not\n   */\n  function manualInitialize(\n    address[] calldata _newGovTokens,\n    address[] calldata _protocolTokens,\n    address[] calldata _wrappers,\n    uint256[] calldata _lastRebalancerAllocations,\n    bool _isRiskAdjusted,\n    address _cToken,\n    address _aToken\n  ) external onlyOwner {\n    cToken = _cToken;\n    aToken = _aToken;\n    isRiskAdjusted = _isRiskAdjusted;\n    // set all available tokens and set the protocolWrappers mapping in the for loop\n    allAvailableTokens = _protocolTokens;\n    // same as setGovTokens, copied to avoid make the method public and save on bytecode size\n    govTokens = _newGovTokens;\n    // set protocol token to gov token mapping\n    for (uint256 i = 0; i < _protocolTokens.length; i++) {\n      protocolWrappers[_protocolTokens[i]] = _wrappers[i];\n      if (i < _newGovTokens.length) {\n        if (_newGovTokens[i] == IDLE) { continue; }\n        protocolTokenToGov[_protocolTokens[i]] = _newGovTokens[i];\n      }\n    }\n\n    lastRebalancerAllocations = _lastRebalancerAllocations;\n    lastAllocations = _lastRebalancerAllocations;\n    // Idle multisig\n    addPauser(address(0xaDa343Cb6820F4f5001749892f6CAA9920129F2A));\n    // Remove pause ability from msg.sender\n    renouncePauser();\n  }\n\n  function _init(\n    string calldata _name, // eg. IdleDAI\n    string calldata _symbol, // eg. IDLEDAI\n    address _token\n  ) external initializer {\n    // copied from old initialize() method removed at commit 04e29bd6f9282ef5677edc16570918da1a72dd3a\n    // Initialize inherited contracts\n    ERC20Detailed.initialize(_name, _symbol, 18);\n    Ownable.initialize(msg.sender);\n    Pausable.initialize(msg.sender);\n    ReentrancyGuard.initialize();\n    // Initialize storage variables\n    maxUnlentPerc = 1000;\n    flashLoanFee = 80;\n    token = _token;\n    tokenDecimals = ERC20Detailed(_token).decimals();\n    // end of old initialize method\n    oracle = address(0xB5A8f07dD4c3D315869405d702ee8F6EA695E8C5);\n    feeAddress = address(0xBecC659Bfc6EDcA552fa1A67451cC6b38a0108E4);\n    rebalancer = address(0xB3C8e5534F0063545CBbb7Ce86854Bf42dB8872B);\n    tokenHelper = address(0x5B7400cC634a49650Cb3212D882512424fED00ed);\n    fee = 10000;\n    iToken = address(0);\n  }\n\n  // ####################################################\n  // ############### END INIT METHODS ###################\n  // ####################################################\n\n  // Contract interfact for IIdleTokenV3_1\n  // view\n  /**\n   * Get latest allocations submitted by rebalancer\n   *\n   * @return : array of allocations ordered as allAvailableTokens\n   */\n  function getAllocations() external view returns (uint256[] memory) {\n    return lastRebalancerAllocations;\n  }\n\n  /**\n  * Get currently used gov tokens\n  *\n  * @return : array of govTokens supported\n  */\n  function getGovTokens() external view returns (address[] memory) {\n    return govTokens;\n  }\n\n  /**\n  * Get currently used protocol tokens (cDAI, aDAI, ...)\n  *\n  * @return : array of protocol tokens supported\n  */\n  function getAllAvailableTokens() external view returns (address[] memory) {\n    return allAvailableTokens;\n  }\n\n  /**\n  * Get gov token associated to a protocol token eg protocolTokenToGov[cDAI] = COMP\n  *\n  * @return : address of the gov token\n  */\n  function getProtocolTokenToGov(address _protocolToken) external view returns (address) {\n    return protocolTokenToGov[_protocolToken];\n  }\n\n  /**\n   * IdleToken price calculation, in underlying\n   *\n   * @return : price in underlying token\n   */\n  function tokenPrice() external view returns (uint256) {}\n\n  /**\n   * Get APR of every ILendingProtocol\n   *\n   * @return addresses: array of token addresses\n   * @return aprs: array of aprs (ordered in respect to the `addresses` array)\n   */\n  function getAPRs() external view returns (address[] memory, uint256[] memory) {}\n\n  /**\n   * Get current avg APR of this IdleToken\n   *\n   * @return avgApr: current weighted avg apr\n   */\n  function getAvgAPR() public view returns (uint256) {}\n\n  /**\n   * Get how many gov tokens a user is entitled to (this may not include eventual undistributed tokens)\n   *\n   * @param _usr : user address\n   * @return : array of amounts for each gov token\n   */\n  function getGovTokensAmounts(address _usr) external view returns (uint256[] memory _amounts) {}\n\n  // external\n  /**\n   * Used to mint IdleTokens, given an underlying amount (eg. DAI).\n   * This method triggers a rebalance of the pools if _skipRebalance is set to false\n   * NOTE: User should 'approve' _amount of tokens before calling mintIdleToken\n   * NOTE 2: this method can be paused\n   * This method use GasTokens of this contract (if present) to get a gas discount\n   *\n   * @param _amount : amount of underlying token to be lended\n   * @param _referral : referral address\n   * @return mintedTokens : amount of IdleTokens minted\n   */\n  function mintIdleToken(uint256 _amount, bool _skipRebalance, address _referral)\n    external returns (uint256 mintedTokens) {}\n\n\n  /**\n   * Here we calc the pool share one can withdraw given the amount of IdleToken they want to burn\n   *\n   * @param _amount : amount of IdleTokens to be burned\n   * @return redeemedTokens : amount of underlying tokens redeemed\n   */\n  function redeemIdleToken(uint256 _amount) external returns (uint256 redeemedTokens) {}\n\n  /**\n   * Here we calc the pool share one can withdraw given the amount of IdleToken they want to burn\n   * and send interest-bearing tokens (eg. cDAI/iDAI) directly to the user.\n   * Underlying (eg. DAI) is not redeemed here.\n   *\n   * @param _amount : amount of IdleTokens to be burned\n   */\n  function redeemInterestBearingTokens(uint256 _amount) external {}\n\n  /**\n   * Dynamic allocate all the pool across different lending protocols if needed,\n   * rebalance without params\n   *\n   * NOTE: this method can be paused\n   *\n   * @return : whether has rebalanced or not\n   */\n  function rebalance() external returns (bool) {}\n\n  /**\n   * Allow any users to set new allocations as long as the new allocation\n   * gives a better avg APR than before\n   * Allocations should be in the format [100000, 0, 0, 0, ...] where length is the same\n   * as lastAllocations variable and the sum of all value should be == 100000\n   *\n   * This method is not callble if this instance of IdleToken is a risk adjusted instance\n   * NOTE: this method can be paused\n   *\n   * @param _newAllocations : array with new allocations in percentage\n   * @return hasRebalanced : whether has rebalanced or not\n   * @return avgApr : the new avg apr after rebalance\n   */\n  function openRebalance(uint256[] calldata _newAllocations)\n    external whenNotPaused\n    returns (bool hasRebalanced, uint256 avgApr) {}\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IProvider.sol\";\n\nimport \"./VaultToken.sol\";\nimport \"./libraries/Swap.sol\";\n\ncontract Vault is ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // state 0 Rebalance done and ready for xController to rebalance again\n  // state 1 Allocation amount received and ready to send funds over to xController\n  // state 2 Allocation amount 0 received => will receive funds from xController\n  // state 3 Allocation amount sent or received and ready to rebalance the vault itself\n  enum State {\n    Idle,\n    PushedUnderlying,\n    SendingFundsXChain,\n    WaitingForFunds,\n    RebalanceVault,\n    SendRewardsPerToken\n  }\n\n  IERC20 internal vaultCurrency;\n  IController internal controller;\n  State public state;\n\n  bool public deltaAllocationsReceived;\n\n  address private dao;\n  address private guardian;\n  address public vaultCurrencyAddr;\n  address public xController;\n\n  uint256 public vaultNumber;\n  uint256 public liquidityPerc;\n  uint256 public performanceFee;\n  uint256 public rebalancingPeriod;\n  uint256 public uScale;\n  uint256 public minimumPull;\n  int256 public marginScale;\n\n  // UNIX timestamp\n  uint256 public rebalanceInterval;\n  uint256 public lastTimeStamp;\n\n  // total underlying of all protocols in vault, excluding vault balance\n  uint256 public savedTotalUnderlying;\n\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\n  uint256 internal reservedFunds;\n\n  // total number of allocated Derby tokens currently\n  int256 public totalAllocatedTokens;\n  // delta of the total number of Derby tokens allocated on next rebalancing\n  int256 private deltaAllocatedTokens;\n\n  string internal stateError = \"Wrong state\";\n\n  // (protocolNumber => currentAllocation): current allocations over the protocols\n  mapping(uint256 => int256) internal currentAllocations;\n\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\n  mapping(uint256 => int256) internal deltaAllocations;\n\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken;\n\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\n  mapping(uint256 => uint256) public lastPrices;\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Vault: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  constructor(\n    uint256 _vaultNumber,\n    address _dao,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  ) {\n    controller = IController(_controller);\n    vaultCurrency = IERC20(_vaultCurrency);\n\n    vaultNumber = _vaultNumber;\n    dao = _dao;\n    uScale = _uScale;\n    lastTimeStamp = block.timestamp;\n    minimumPull = 1_000_000;\n  }\n\n  /// @notice Withdraw from protocols on shortage in Vault\n  /// @dev Keeps on withdrawing until the Vault balance > _value\n  /// @param _value The total value of vaultCurrency an user is trying to withdraw.\n  /// @param _value The (value - current underlying value of this vault) is withdrawn from the underlying protocols.\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\n      savedTotalUnderlying -= amountToWithdraw;\n\n      if (amountToWithdraw < minimumPull) break;\n      withdrawFromProtocol(i, amountToWithdraw);\n\n      if (_value <= vaultCurrency.balanceOf(address(this))) break;\n    }\n  }\n\n  /// @notice Step 7 trigger, end; Vaults rebalance\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\n  /// @dev if amountToDeposit < 0 => withdraw\n  /// @dev Execute all withdrawals before deposits\n  function rebalance() external nonReentrant {\n    require(state == State.RebalanceVault, stateError);\n    require(deltaAllocationsReceived, \"!Delta allocations\");\n\n    rebalancingPeriod++;\n\n    claimTokens();\n    settleDeltaAllocation();\n\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(underlyingIncBalance);\n\n    executeDeposits(protocolToDeposit);\n    setTotalUnderlying();\n\n    if (reservedFunds > vaultCurrency.balanceOf(address(this))) pullFunds(reservedFunds);\n\n    state = State.SendRewardsPerToken;\n    deltaAllocationsReceived = false;\n  }\n\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\n  /// @return underlying totalUnderlying"
    }
  ]
}