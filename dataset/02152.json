{
  "Title": "H-1: Protocol assumes 18 decimals collateral",
  "Content": "# Issue H-1: Protocol assumes 18 decimals collateral \n\nSource: https://github.com/sherlock-audit/2023-03-taurus-judging/issues/35 \n\n## Found by \nimare, GimelSec, jonatascm, cducrest-brainbot, 0x52, bytes032, Bauer, Bahurum, duc, yixxas, mstpr-brainbot, RaymondFam, roguereddwarf, peanuts, ck\n\n## Summary\n\nMultiple calculation are done with the amount of collateral token that assume the collateral token has 18 decimals. Currently the only handled collateral (staked GLP) uses 18 decimals. However, if other tokens are added in the future, the protocol may be broken.\n\n## Vulnerability Detail\n\nTauMath.sol calculates the collateral ratio (coll * price / debt) as such:\n\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Libs/TauMath.sol#L18\n\nIt accounts for the price decimals, and the debt decimals (TAU is 18 decimals) by multiplying by Constants.precision (`1e18`) and dividing by `10**priceDecimals`. The result is a number with decimal precision corresponding to the decimals of `_coll`.\n\nThis `collRatio` is later used and compared to values such as `MIN_COL_RATIO`, `MAX_LIQ_COLL_RATIO`, `LIQUIDATION_SURCHARGE`, or `MAX_LIQ_DISCOUNT` which are all expressed in `1e18`.\n\nSecondly, in `TauDripFeed` the extra reward is calculated as:\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/TauDripFeed.sol#L91\n\nThis once again assumes 18 decimals for the collateral. This error is cancelled out when the vault calculates the user reward with:\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/BaseVault.sol#L90\n\nHowever, if the number of decimals for the collateral is higher than 18 decimals, the rounding of `_extraRewardPerCollateral` may bring the rewards for users to 0.\n\nFor example: `_tokensToDisburse = 100 e18`, `_currentCollateral = 1_000_000 e33`, then `_extraRewardPerCollateral = 0` and no reward will be distributed.\n\n## Impact\n\nCollateral ratio cannot be properly computed (or used) if the collateral token does not use 18 decimals. If it uses more decimals, users will appear way more collateralised than they are. If it uses less decimals, users will appear way less collateralised. The result is that users will be able to withdraw way more TAU than normally able or they will be in a liquidatable position before they should.\n\nIt may be impossible to distribute rewards if collateral token uses more than 18 decimals.\n\n## Code Snippet\n\nConstants.precision is `1e18`:\n\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Libs/Constants.sol#L24\n\nMIN_COL_RATIO is expressed in 1e18:\n\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/BaseVault.sol#L57\n\nTauDripFeed uses `1e18` once again in calculation with collateral amount:\n\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/TauDripFeed.sol#L91\n\nThe calculation for maxRepay is also impacted:\n\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/BaseVault.sol#L251-L253\n\nThe calculation for expected liquidation collateral is also impacted:\n\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/BaseVault.sol#L367\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAccount for the collateral decimals in the calculation instead of using `Constants.PRECISION`.\n\n## Discussion\n\n**IAm0x52**\n\nEscalate for 10 USDC\n\nThis should be medium rather than high, since affected tokens would simply be incompatible because MIN_COL_RATIO is expressed to 18 dp.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This should be medium rather than high, since affected tokens would simply be incompatible because MIN_COL_RATIO is expressed to 18 dp.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**iHarishKumar**\n\nhttps://github.com/protokol/taurus-contracts/pull/124\n\n**spyrosonic10**\n\nEscalate for 10 USDC\n\nFrom the constest scope\n`ERC20: any non-rebasing. In particular, fee + staked GLP will be the first collateral token (managed through GMX's ERC20-compliant wrapper) and Arbitrum Weth will be the main yield token.`\n\nPresent state of contract is designed and to use with 18 decimal gmx token.  Future release should be out of scope so it is invalid issue. In order to launch other vault types protocol will be the first to know about decimal things. Given the current state of protocol and codebase this issue doesn't pose any risk to user funds. Not qualified for high.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> From the constest scope\n> `ERC20: any non-rebasing. In particular, fee + staked GLP will be the first collateral token (managed through GMX's ERC20-compliant wrapper) and Arbitrum Weth will be the main yield token.`\n> \n> Present state of contract is designed and to use with 18 decimal gmx token.  Future release should be out of scope so it is invalid issue. In order to launch other vault types protocol will be the first to know about decimal things. Given the current state of protocol and codebase this issue doesn't pose any risk to user funds. Not qualified for high.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nGiven that the assumption for 18 decimals impacts calculations across the codebase and also affects the borrow calculations, considering this issue a valid high. \n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Given that the assumption for 18 decimals impacts calculations across the codebase and also affects the borrow calculations, considering this issue a valid high. \n> \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/45",
  "Code": [
    {
      "filename": "taurus-contracts/contracts/Libs/TauMath.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { Constants } from \"./Constants.sol\";\n\nlibrary TauMath {\n    /**\n     * @dev function to calculate the collateral ratio of an account.\n     */\n    function _computeCR(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _price,\n        uint8 priceDecimals\n    ) internal pure returns (uint256) {\n        if (_debt > 0) {\n            uint256 newCollRatio = (_coll * _price * Constants.PRECISION) / (_debt * 10 ** priceDecimals);\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the account has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return type(uint256).max;\n        }\n    }\n}"
    },
    {
      "filename": "taurus-contracts/contracts/Vault/TauDripFeed.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ControllableUpgradeable } from \"../Controller/ControllableUpgradeable.sol\";\nimport { ERC20Burnable } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Constants } from \"../Libs/Constants.sol\";\n\n// @dev contains logic for accepting TAU yield and distributing it to users over time to protect against sandwich attacks.\nabstract contract TauDripFeed is PausableUpgradeable, ControllableUpgradeable {\n    // @dev total amount of tau tokens that have ever been rewarded to the contract, divided by the total collateral present at the time of each deposit.\n    // This number can only increase.\n    uint256 public cumulativeTauRewardPerCollateral;\n\n    /// @dev Tau tokens yet to be doled out to the vault. Tokens yet to be doled out are not counted towards cumulativeTauRewardPerCollateral.\n    uint256 public tauWithheld;\n\n    /// @dev timestamp at which tokens were most recently disbursed. Updated only when tauWithheld > 0. Used in conjunction with DRIP_DURATION to\n    /// calculate next token disbursal amount.\n    uint256 public tokensLastDisbursedTimestamp;\n\n    /// @dev duration of the drip feed. Deposited TAU is steadily distributed to the contract over this amount of time.\n    uint256 public constant DRIP_DURATION = 1 days;\n\n    /// @dev address of TAU\n    address public tau;\n\n    /// @dev address of token used as collateral by this vault.\n    address public collateralToken;\n\n    function __TauDripFeed_init(address _tau, address _collateralToken) internal initializer {\n        __Pausable_init();\n        tau = _tau;\n        collateralToken = _collateralToken;\n    }\n\n    function pause() external onlyMultisig {\n        _pause();\n    }\n\n    function unpause() external onlyMultisig {\n        _unpause();\n    }\n\n    /**\n     * @dev function to deposit TAU into the contract while averting sandwich attacks.\n     * @param amount is the amount of TAU to be burned and used to cancel out debt.\n     * note the main source of TAU is the SwapHandler. This function is just a safeguard in case some other source of TAU arises.\n     */\n    function distributeTauRewards(uint256 amount) external whenNotPaused {\n        // Burn depositor's Tau\n        ERC20Burnable(tau).burnFrom(msg.sender, amount);\n\n        // Disburse available tau\n        _disburseTau();\n\n        // Set new tau aside to protect against sandwich attacks\n        _withholdTau(amount);\n    }\n\n    function disburseTau() external whenNotPaused {\n        _disburseTau();\n    }\n\n    /**\n     * @dev disburse TAU to the contract by updating cumulativeTauRewardPerCollateral.\n     * Note that since rewards are distributed based on timeElapsed / DRIP_DURATION, this function will technically only distribute 100% of rewards if it is not called\n        until the DRIP_DURATION has elapsed. This isn't too much of an issue--at worst, about 2/3 of the rewards will be distributed per DRIP_DURATION, the rest carrying over\n        to the next DRIP_DURATION.\n     * Note that if collateral == 0, tokens will not be disbursed. This prevents undefined behavior when rewards are deposited before collateral is.\n     */\n    function _disburseTau() internal {\n        if (tauWithheld > 0) {\n            uint256 _currentCollateral = IERC20(collateralToken).balanceOf(address(this));\n\n            if (_currentCollateral > 0) {\n                // Get tokens to disburse since last disbursal\n                uint256 _timeElapsed = block.timestamp - tokensLastDisbursedTimestamp;\n\n                uint256 _tokensToDisburse;\n                if (_timeElapsed >= DRIP_DURATION) {\n                    _tokensToDisburse = tauWithheld;\n                    tauWithheld = 0;\n                } else {\n                    _tokensToDisburse = (_timeElapsed * tauWithheld) / DRIP_DURATION;\n                    tauWithheld -= _tokensToDisburse;\n                }\n\n                // Divide by current collateral to get the additional tokensPerCollateral which we'll be adding to the cumulative sum\n                uint256 _extraRewardPerCollateral = (_tokensToDisburse * Constants.PRECISION) / _currentCollateral;\n\n                cumulativeTauRewardPerCollateral += _extraRewardPerCollateral;\n\n                tokensLastDisbursedTimestamp = block.timestamp;\n            }\n        }\n    }\n\n    /**\n     * @dev internal function to deposit TAU into the contract while averting sandwich attacks.\n     * This is primarily meant to be called by the SwapHandler, which is the smart contract's source of TAU.\n     * It is also called by the BaseVault when an account earns TAU rewards in excess of their debt.\n     * Note that this function should generally only be called after disburseTau has been called.\n     */\n    function _withholdTau(uint256 amount) internal {\n        // Update block.timestamp in case it hasn't been updated yet this transaction.\n        tokensLastDisbursedTimestamp = block.timestamp;\n        tauWithheld += amount;\n    }\n\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "taurus-contracts/contracts/Vault/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Contracts\nimport { Controllable } from \"../Controller/Controllable.sol\";\nimport { Controller } from \"../Controller/Controller.sol\";\nimport { PriceOracleManager } from \"../Oracle/PriceOracleManager.sol\";\nimport { TauDripFeed } from \"./TauDripFeed.sol\";\nimport { SwapHandler } from \"./SwapHandler.sol\";\nimport { TAU } from \"../TAU.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\n// Libraries\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Constants } from \"../Libs/Constants.sol\";\nimport { TauMath } from \"../Libs/TauMath.sol\";\n\n// Note that this contract is not compatible with ERC777 tokens due to potential reentrancy concerns.\nabstract contract BaseVault is SwapHandler, UUPSUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// Define the errors\n    error insufficientCollateral();\n    error userNotFound();\n    error wrongLiquidationAmount();\n    error incorrectDebtRepayAmount();\n    error insufficientCollateralLiquidated(uint256 debtRepaid, uint256 collateralReceived);\n    error cannotLiquidateHealthyAccount();\n\n    // Events\n    event Repay(address indexed _repayer, uint256 _amountTau);\n    event Borrow(address indexed _borrower, uint256 _amountTau);\n    event Deposit(address indexed _depositer, uint256 _amountAsset);\n    event Withdraw(address indexed _withdrawer, uint256 _amountAsset);\n    event AccountLiquidated(address _liquidator, address _account, uint256 _amount, uint256 _liqFees);\n    event TauEarned(address indexed _account, uint256 _amount); // Emitted when a user's debt is cancelled\n\n    struct UserDetails {\n        uint256 collateral; // Collateral amount deposited by user\n        uint256 debt; // Debt amount borrowed by user\n        uint256 lastUpdatedRewardPerCollateral; // Last updated reward per collateral for the user\n        uint256 startTimestamp; // Time when the first deposit was made by the user\n    }\n\n    /// @dev mapping of user and UserDetails\n    mapping(address => UserDetails) public userDetails;\n\n    /// @dev keep track of user addresses to index the userDetails for liquidation\n    address[] public userAddresses;\n\n    // Liquidation constants\n\n    // Minimum collateral ratio\n    uint256 public constant MIN_COL_RATIO = 1.2e18; // 120 %\n\n    // Maximum collateral ratio an account can have after being liquidated (limits liquidation size to only what is necessary)\n    uint256 public constant MAX_LIQ_COLL_RATIO = 1.3e18; // 130 %\n\n    uint256 public constant MAX_LIQ_DISCOUNT = 0.2e18; // 20 %\n\n    // 2% of the liquidated amount is sent to the FeeSplitter to fund protocol stability\n    // and disincentivize self-liquidation\n    uint256 public constant LIQUIDATION_SURCHARGE = 0.02e18;\n\n    function __BaseVault_init(address _controller, address _tau, address _collateralToken) internal initializer {\n        __Controllable_init(_controller);\n        __TauDripFeed_init(_tau, _collateralToken);\n    }\n\n    /**\n     * @dev modifier to update user's reward per collateral and pay off some of their debt. This is\n        executed before any function that modifies a user's collateral or debt.\n     * note if there is surplus TAU after the debt is paid off, it is added back to the drip feed.\n     */\n    modifier updateReward(address _account) {\n        // Disburse available yield from the drip feed\n        _disburseTau();\n\n        // If user has collateral, pay down their debt and recycle surplus rewards back into the tauDripFeed.\n        uint256 _userCollateral = userDetails[_account].collateral;\n        if (_userCollateral > 0) {\n            // Get diff between global rewardPerCollateral and user lastUpdatedRewardPerCollateral\n            uint256 _rewardDiff = cumulativeTauRewardPerCollateral -\n                userDetails[_account].lastUpdatedRewardPerCollateral;\n\n            // Calculate user's TAU earned since the last update, use it to pay off debt\n            uint256 _tauEarned = (_rewardDiff * _userCollateral) / Constants.PRECISION;\n\n            if (_tauEarned > 0) {\n                uint256 _userDebt = userDetails[_account].debt;\n                if (_tauEarned > _userDebt) {\n                    // If user has earned more than enough TAU to pay off their debt, pay off debt and add surplus to drip feed\n                    userDetails[_account].debt = 0;\n\n                    _withholdTau(_tauEarned - _userDebt);\n                    _tauEarned = _userDebt;\n                } else {\n                    // Pay off as much debt as possible\n                    userDetails[_account].debt = _userDebt - _tauEarned;\n                }\n\n                emit TauEarned(_account, _tauEarned);\n            }\n        } else {\n            // If this is a new user, add them to the userAddresses array to keep track of them.\n            if (userDetails[_account].startTimestamp == 0) {\n                userAddresses.push(_account);\n                userDetails[_account].startTimestamp = block.timestamp;\n            }\n        }\n\n        // Update user lastUpdatedRewardPerCollateral\n        userDetails[_account].lastUpdatedRewardPerCollateral = cumulativeTauRewardPerCollateral;\n        _;\n    }\n\n    //------------------------------------------------------------View functions------------------------------------------------------------\n\n    /// @dev In this function, we assume that TAU is worth $1 exactly. This allows users to arbitrage the difference, if any.\n    function getAccountHealth(address _account) public view returns (bool) {\n        uint256 ratio = _getCollRatio(_account);\n\n        return (ratio > MIN_COL_RATIO);\n    }\n\n    /**\n     * @dev calculate the max amount of debt that can be liquidated from an account\n     * @param _account is the address of the account to be liquidated\n     * @return maxRepay is the maximum amount of debt that can be liquidated from the account\n     */\n    function getMaxLiquidation(address _account) external view returns (uint256 maxRepay) {\n        (uint256 price, uint8 decimals) = _getCollPrice();\n        UserDetails memory accDetails = userDetails[_account];\n        uint256 _collRatio = TauMath._computeCR(accDetails.collateral, accDetails.debt, price, decimals);\n\n        // This call will revert if the account is healthy\n        uint256 totalLiquidationDiscount = _calcLiquidationDiscount(_collRatio);\n\n        maxRepay = _getMaxLiquidation(\n            accDetails.collateral,\n            accDetails.debt,\n            price,\n            decimals,\n            totalLiquidationDiscount\n        );\n        return maxRepay;\n    }\n\n    /// @dev Get the number of users\n    function getUsersCount() public view returns (uint256) {\n        return userAddresses.length;\n    }\n\n    /** @dev Get the user details in the range given start and end index.\n     * note the start and end index are inclusive\n     */\n    function getUsersDetailsInRange(uint256 _start, uint256 _end) public view returns (UserDetails[] memory users) {\n        if (_end > getUsersCount() || _start > _end) revert indexOutOfBound();\n\n        users = new UserDetails[](_end - _start + 1);\n\n        for (uint i = _start; i < _end; ++i) {\n            users[i - _start] = userDetails[userAddresses[i]];\n        }\n    }\n\n    /** @dev Get the user addresses in the range given start and end index\n     * note the start and end index are inclusive\n     */\n    function getUsers(uint256 _start, uint256 _end) public view returns (address[] memory users) {\n        if (_end > getUsersCount() || _start > _end) revert indexOutOfBound();\n\n        users = new address[](_end - _start + 1);\n\n        for (uint256 i = _start; i < _end; ++i) {\n            users[i - _start] = userAddresses[i];\n        }\n    }\n\n    function _checkAccountHealth(address _account) internal view {\n        if (!getAccountHealth(_account)) {\n            revert insufficientCollateral();\n        }\n    }\n\n    /// @dev In this function, we calculate the collateral ratio\n    function _getCollRatio(address _account) internal view returns (uint256 ratio) {\n        // Fetch the price from oracle manager\n        (uint256 price, uint8 decimals) = _getCollPrice();\n\n        // Check that user's collateral ratio is above minimum healthy ratio\n        ratio = TauMath._computeCR(userDetails[_account].collateral, userDetails[_account].debt, price, decimals);\n    }\n\n    function _getCollPrice() internal view virtual returns (uint256 price, uint8 decimals) {\n        bool success;\n\n        // Fetch the price from oracle manager\n        (price, decimals, success) = PriceOracleManager(\n            Controller(controller).addressMapper(Constants.PRICE_ORACLE_MANAGER)\n        ).getExternalPrice(collateralToken, abi.encodePacked(false));\n        if (!success) {\n            revert oracleCorrupt();\n        }\n    }\n\n    //------------------------------------------------------------User functions------------------------------------------------------------\n\n    function modifyPosition(\n        uint256 _collateralDelta,\n        uint256 _debtDelta,\n        bool _increaseCollateral,\n        bool _increaseDebt\n    ) external whenNotPaused updateReward(msg.sender) {\n        _modifyPosition(msg.sender, _collateralDelta, _debtDelta, _increaseCollateral, _increaseDebt);\n    }\n\n    /**\n     * @dev Function allowing a user to automatically close their position.\n     * Note that this function is available even when the contract is paused.\n     * Note that since this function does not call updateReward, it should only be used when the contract is paused.\n     *\n     */\n    function emergencyClosePosition() external {\n        _modifyPosition(msg.sender, userDetails[msg.sender].collateral, userDetails[msg.sender].debt, false, false);\n    }\n\n    /**\n     * @dev Find the max amount of debt that can be liquidated from an account.\n     * @param _collateral is the amount of collateral the user has.\n     * @param _debt is the amount of debt the user has.\n     * @param _price is $ / collateral\n     * @param _decimals is the number of decimals in price\n     * @param _liquidationDiscount is the liquidation discount in percentage, e.g. 120% * PRECISION\n     * @return maxRepay is the max amount of debt which can be repaid as part of the liquidation process, 0 if the user's account is healthy.\n     */\n    function _getMaxLiquidation(\n        uint256 _collateral,\n        uint256 _debt,\n        uint256 _price,\n        uint8 _decimals,\n        uint256 _liquidationDiscount\n    ) internal pure returns (uint256 maxRepay) {\n        // Formula to find the liquidation amount is as follows\n        // [(collateral * price) - (liqDiscount * liqAmount)] / (debt - liqAmount) = max liq ratio\n        // Therefore\n        // liqAmount = [(max liq ratio * debt) - (collateral * price)] / (max liq ratio - liqDiscount)\n        maxRepay =\n            ((MAX_LIQ_COLL_RATIO * _debt) - ((_collateral * _price * Constants.PRECISION) / (10 ** _decimals))) /\n            (MAX_LIQ_COLL_RATIO - _liquidationDiscount);\n\n        // Liquidators cannot repay more than the account's debt\n        if (maxRepay > _debt) {\n            maxRepay = _debt;\n        }\n\n        return maxRepay;\n    }\n\n    //------------------------------------------------------------BaseVault internal functions------------------------------------------------------------\n\n    /**\n     * @dev function to modify user collateral and debt in any way. If debt is increased or collateral reduced, the account must be healthy at the end of the tx.\n     * note that generally this function is called after updateReward, meaning that user details are up to date.\n     * @param _account is the account to be modified\n     * @param _collateralDelta is the absolute value of the change in collateral.\n     *  note that withdrawals cannot attempt to withdraw more than the user collateral balance, or the transaction will revert.\n     * @param _debtDelta is the absolute value of the change in debt\n     *  note that repayments can attempt to repay more than their debt balance. Only their debt balance will be pulled, and used to cancel out their debt.\n     * @param _increaseCollateral is true if collateral is being deposited, false if collateralDelta is 0 or collateral is being withdrawn\n     * @param _increaseDebt is true if debt is being borrowed, false if debtDelta is 0 or debt is being repaid\n     */\n    function _modifyPosition(\n        address _account,\n        uint256 _collateralDelta,\n        uint256 _debtDelta,\n        bool _increaseCollateral,\n        bool _increaseDebt\n    ) internal virtual {\n        bool mustCheckHealth; // False until an action is taken which can reduce account health\n\n        // Handle debt first, since TAU has no reentrancy concerns.\n        if (_debtDelta != 0) {\n            if (_increaseDebt) {\n                // Borrow TAU from the vault\n                userDetails[_account].debt += _debtDelta;\n                mustCheckHealth = true;\n                TAU(tau).mint(_account, _debtDelta);\n\n                emit Borrow(_account, _debtDelta);\n            } else {\n                // Repay TAU debt\n                uint256 currentDebt = userDetails[_account].debt;\n                if (_debtDelta > currentDebt) _debtDelta = currentDebt;\n                userDetails[_account].debt = currentDebt - _debtDelta;\n                // Burn Tau used to repay debt\n                TAU(tau).burnFrom(_account, _debtDelta);\n\n                emit Repay(_account, _debtDelta);\n            }\n        }\n\n        if (_collateralDelta != 0) {\n            if (_increaseCollateral) {\n                // Deposit collateral\n                userDetails[_account].collateral += _collateralDelta;\n                IERC20(collateralToken).safeTransferFrom(msg.sender, address(this), _collateralDelta);\n\n                emit Deposit(_account, _collateralDelta);\n            } else {\n                // Withdraw collateral\n                uint256 currentCollateral = userDetails[_account].collateral;\n                if (_collateralDelta > currentCollateral) revert insufficientCollateral();\n                userDetails[_account].collateral = currentCollateral - _collateralDelta;\n                mustCheckHealth = true;\n                IERC20(collateralToken).safeTransfer(msg.sender, _collateralDelta);\n\n                emit Withdraw(_account, _collateralDelta);\n            }\n        }\n\n        if (mustCheckHealth) {\n            _checkAccountHealth(_account);\n        }\n    }\n\n    //------------------------------------------------------------Liquidator/governance functions------------------------------------------------------------\n\n    /**\n     * @param _account is the account to be liquidated. It must be unhealthy.\n     * @param _debtAmount is the amount of debt to be repaid. It must be greater than 0. If the entire account is liquidateable, an arbitrarily\n     high debt amount will signal that the entire account should be liquidated. Otherwise, _debtAmount must be less than or equal to the max\n     debt which can be liquidated from the acount.\n     * @param _minExchangeRate represents the minimum number of collateral tokens which the liquidator is willing to receive in exchange for \n      1 debt token. A value of PRECISION will mean that the liquidation will revert unless the liquidator receives at least 1 collateral per\n      debt token repaid. A value of 0 means that slippage is not checked, and the liquidator will accept whatever the exchange rate happens to be.\n     * @return true if the liquidation was successful\n     */\n    function liquidate(\n        address _account,\n        uint256 _debtAmount,\n        uint256 _minExchangeRate\n    ) external onlyLiquidator whenNotPaused updateReward(_account) returns (bool) {\n        if (_debtAmount == 0) revert wrongLiquidationAmount();\n\n        UserDetails memory accDetails = userDetails[_account];\n\n        // Since Taurus accounts' debt continuously decreases, liquidators may pass in an arbitrarily large number in order to\n        // request to liquidate the entire account.\n        if (_debtAmount > accDetails.debt) {\n            _debtAmount = accDetails.debt;\n        }\n\n        // Get total fee charged to the user for this liquidation. Collateral equal to (liquidated taurus debt value * feeMultiplier) will be deducted from the user's account.\n        // This call reverts if the account is healthy or if the liquidation amount is too large.\n        (uint256 collateralToLiquidate, uint256 liquidationSurcharge) = _calcLiquidation(\n            accDetails.collateral,\n            accDetails.debt,\n            _debtAmount\n        );\n\n        // Check that collateral received is sufficient for liquidator\n        uint256 collateralToLiquidator = collateralToLiquidate - liquidationSurcharge;\n        if (collateralToLiquidator < (_debtAmount * _minExchangeRate) / Constants.PRECISION) {\n            revert insufficientCollateralLiquidated(_debtAmount, collateralToLiquidator);\n        }\n\n        // Update user info\n        userDetails[_account].collateral = accDetails.collateral - collateralToLiquidate;\n        userDetails[_account].debt = accDetails.debt - _debtAmount;\n\n        // Burn liquidator's Tau\n        TAU(tau).burnFrom(msg.sender, _debtAmount);\n\n        // Transfer part of _debtAmount to liquidator and Taurus as fees for liquidation\n        IERC20(collateralToken).safeTransfer(msg.sender, collateralToLiquidator);\n        IERC20(collateralToken).safeTransfer(\n            Controller(controller).addressMapper(Constants.FEE_SPLITTER),\n            liquidationSurcharge\n        );\n\n        emit AccountLiquidated(msg.sender, _account, collateralToLiquidate, liquidationSurcharge);\n\n        return true;\n    }\n\n    /**\n     * @dev calculate relevant liquidation parameters. If 100 TAU are liquidated, and the discount is 105%, then 100 * 1.05 = 105 TAU worth of collateral\n     * will be liquidated.\n     * @return collateralToLiquidate is the amount of the user's collateral which will be liquidated\n     * @return liquidationSurcharge is the amount of collateral which will be sent to the Taurus treasury as a liquidation fee\n     */\n    function _calcLiquidation(\n        uint256 _accountCollateral,\n        uint256 _accountDebt,\n        uint256 _debtToLiquidate\n    ) internal view returns (uint256 collateralToLiquidate, uint256 liquidationSurcharge) {\n        (uint256 price, uint8 decimals) = _getCollPrice();\n        uint256 _collRatio = TauMath._computeCR(_accountCollateral, _accountDebt, price, decimals);\n\n        uint256 totalLiquidationDiscount = _calcLiquidationDiscount(_collRatio);\n\n        uint256 collateralToLiquidateWithoutDiscount = (_debtToLiquidate * (10 ** decimals)) / price;\n        collateralToLiquidate = (collateralToLiquidateWithoutDiscount * totalLiquidationDiscount) / Constants.PRECISION;\n        if (collateralToLiquidate > _accountCollateral) {\n            collateralToLiquidate = _accountCollateral;\n        }\n\n        // Revert if requested liquidation amount is greater than allowed\n        if (\n            _debtToLiquidate >\n            _getMaxLiquidation(_accountCollateral, _accountDebt, price, decimals, totalLiquidationDiscount)\n        ) revert wrongLiquidationAmount();\n\n        return (\n            collateralToLiquidate,\n            (collateralToLiquidateWithoutDiscount * LIQUIDATION_SURCHARGE) / Constants.PRECISION\n        );\n    }\n\n    /**\n     * @dev calculate the current liquidation discount for a given account\n     * @return liquidationDiscount -- the discount applied to the price of the user's collateral. If 100 TAU of debt are liquidated, 100 * liquidationDiscount / PRECISION collateral \n     will be liquidated.\n     * note that the calculated discount includes the liquidation surcharge, so not all of the discounted funds will be sent to the liquidator.\n     * note that the discount cannot exceed MAX_LIQ_DISCOUNT.\n     * The liquidation discount may be any value in the range of (PRECISION, MAX_LIQ_DISCOUNT]. \n     */\n    function _calcLiquidationDiscount(uint256 _accountHealth) internal pure returns (uint256 liquidationDiscount) {\n        if (_accountHealth >= MIN_COL_RATIO) {\n            revert cannotLiquidateHealthyAccount();\n        }\n\n        // The liquidator's discount on user funds is based on how far underwater the position is, to simulate a dutch auction.\n        // The discount is capped at MAX_LIQ_DISCOUNT.\n        uint256 diff = (MIN_COL_RATIO + LIQUIDATION_SURCHARGE) - _accountHealth;\n        if (diff > MAX_LIQ_DISCOUNT) {\n            diff = MAX_LIQ_DISCOUNT;\n        }\n\n        liquidationDiscount = Constants.PRECISION + diff;\n    }\n\n    /**\n     * @dev Updates a user's rewards. Callable by anyone, but really only useful for keepers\n     *  to update inactive accounts (thus redistributing their excess rewards to the vault).\n     * @param _account is the account whose rewards will be updated\n     */\n    function updateRewards(address _account) external whenNotPaused updateReward(_account) {}\n\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyGovernor {}\n\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "taurus-contracts/contracts/Libs/Constants.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n// Basic contract to hold some constants used throughout the Taurus system\nlibrary Constants {\n    // Roles\n    // Role for keepers, trusted accounts which manage system operations.\n    bytes32 internal constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    // Role for the team multisig, which adds/removes keepers and may perform other administrative functions in the future.\n    bytes32 internal constant MULTISIG_ROLE = keccak256(\"MULTISIG_ROLE\");\n\n    // Governance has DEFAULT_ADMIN_ROLE i.e. bytes32(0). This puts it in charge of the multisig as well. It's exposed here for convenience.\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = bytes32(0);\n\n    // SwapAdapter names\n    bytes32 internal constant UNISWAP_SWAP_ADAPTER = keccak256(\"UNISWAP_SWAP_ADAPTER\");\n    bytes32 internal constant CURVE_SWAP_ADAPTER = keccak256(\"CURVE_SWAP_ADAPTER\");\n\n    // Role for accounts that can liquidate the underwater accounts in the system\n    bytes32 internal constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n    uint256 internal constant PRECISION = 1e18;\n\n    // Fees\n\n    uint256 internal constant MAX_FEE_PERC = 4e17; // Max protocol fees are 40%\n    uint256 internal constant PERCENT_PRECISION = 1e18; // i.e. 1% will be represented as 1e16.\n\n    // Fee names\n    // Fraction of yield from GLP vault which will be sent to the feeSplitter, i.e. the protocol. Precision is PERCENT_PRECISION.\n    bytes32 internal constant GLP_VAULT_PROTOCOL_FEE = keccak256(\"GLP_VAULT_PROTOCOL_FEE\");\n\n    bytes32 internal constant LIQUIDATOR_FEE = keccak256(\"LIQUIDATOR_FEE\");\n\n    bytes32 internal constant TAURUS_LIQUIDATION_FEE = keccak256(\"TAURUS_LIQUIDATION_FEE\");\n\n    bytes32 internal constant PRICE_ORACLE_MANAGER = keccak256(\"PRICE_ORACLE_MANAGER\");\n\n    bytes32 internal constant FEE_SPLITTER = keccak256(\"FEE_SPLITTER\");\n}"
    },
    {
      "filename": "taurus-contracts/contracts/Vault/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Contracts\nimport { Controllable } from \"../Controller/Controllable.sol\";\nimport { Controller } from \"../Controller/Controller.sol\";\nimport { PriceOracleManager } from \"../Oracle/PriceOracleManager.sol\";\nimport { TauDripFeed } from \"./TauDripFeed.sol\";\nimport { SwapHandler } from \"./SwapHandler.sol\";\nimport { TAU } from \"../TAU.sol\";\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\n// Libraries\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Constants } from \"../Libs/Constants.sol\";\nimport { TauMath } from \"../Libs/TauMath.sol\";\n\n// Note that this contract is not compatible with ERC777 tokens due to potential reentrancy concerns.\nabstract contract BaseVault is SwapHandler, UUPSUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// Define the errors\n    error insufficientCollateral();\n    error userNotFound();\n    error wrongLiquidationAmount();\n    error incorrectDebtRepayAmount();\n    error insufficientCollateralLiquidated(uint256 debtRepaid, uint256 collateralReceived);\n    error cannotLiquidateHealthyAccount();\n\n    // Events\n    event Repay(address indexed _repayer, uint256 _amountTau);\n    event Borrow(address indexed _borrower, uint256 _amountTau);\n    event Deposit(address indexed _depositer, uint256 _amountAsset);\n    event Withdraw(address indexed _withdrawer, uint256 _amountAsset);\n    event AccountLiquidated(address _liquidator, address _account, uint256 _amount, uint256 _liqFees);\n    event TauEarned(address indexed _account, uint256 _amount); // Emitted when a user's debt is cancelled\n\n    struct UserDetails {\n        uint256 collateral; // Collateral amount deposited by user\n        uint256 debt; // Debt amount borrowed by user\n        uint256 lastUpdatedRewardPerCollateral; // Last updated reward per collateral for the user\n        uint256 startTimestamp; // Time when the first deposit was made by the user\n    }\n\n    /// @dev mapping of user and UserDetails\n    mapping(address => UserDetails) public userDetails;\n\n    /// @dev keep track of user addresses to index the userDetails for liquidation\n    address[] public userAddresses;\n\n    // Liquidation constants\n\n    // Minimum collateral ratio\n    uint256 public constant MIN_COL_RATIO = 1.2e18; // 120 %\n\n    // Maximum collateral ratio an account can have after being liquidated (limits liquidation size to only what is necessary)\n    uint256 public constant MAX_LIQ_COLL_RATIO = 1.3e18; // 130 %\n\n    uint256 public constant MAX_LIQ_DISCOUNT = 0.2e18; // 20 %\n\n    // 2% of the liquidated amount is sent to the FeeSplitter to fund protocol stability\n    // and disincentivize self-liquidation\n    uint256 public constant LIQUIDATION_SURCHARGE = 0.02e18;\n\n    function __BaseVault_init(address _controller, address _tau, address _collateralToken) internal initializer {\n        __Controllable_init(_controller);\n        __TauDripFeed_init(_tau, _collateralToken);\n    }\n\n    /**\n     * @dev modifier to update user's reward per collateral and pay off some of their debt. This is\n        executed before any function that modifies a user's collater"
    }
  ]
}