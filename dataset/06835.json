{
  "Title": "[H-05] Reth `poolPrice` calculation may overflow",
  "Content": "\nThe Reth derivative contract implements the `poolPrice` function to get the spot price of the derivative asset using a Uniswap V3 pool. The function queries the pool to fetch the `sqrtPriceX96` and does the following calculation:\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L228-L242>\n\n```solidity\nfunction poolPrice() private view returns (uint256) {\n    address rocketTokenRETHAddress = RocketStorageInterface(\n        ROCKET_STORAGE_ADDRESS\n    ).getAddress(\n            keccak256(\n                abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n            )\n        );\n    IUniswapV3Factory factory = IUniswapV3Factory(UNI_V3_FACTORY);\n    IUniswapV3Pool pool = IUniswapV3Pool(\n        factory.getPool(rocketTokenRETHAddress, W_ETH_ADDRESS, 500)\n    );\n    (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n    return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);\n}\n```\n\nThe main issue here is that the multiplications in the expression `sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)` may eventually overflow. This case is taken into consideration by the implementation of the [OracleLibrary.getQuoteAtTick](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/OracleLibrary#getquoteattick) function which is part of the Uniswap V3 periphery set of contracts.\n\n<https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L49-L69>\n\n```solidity\n49:     function getQuoteAtTick(\n50:         int24 tick,\n51:         uint128 baseAmount,\n52:         address baseToken,\n53:         address quoteToken\n54:     ) internal pure returns (uint256 quoteAmount) {\n55:         uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n56: \n57:         // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n58:         if (sqrtRatioX96 <= type(uint128).max) {\n59:             uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n60:             quoteAmount = baseToken < quoteToken\n61:                 ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n62:                 : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n63:         } else {\n64:             uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n65:             quoteAmount = baseToken < quoteToken\n66:                 ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n67:                 : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n68:         }\n69:     }\n```\n\nNote that this implementation guards against different numerical issues. In particular, the if in line 58 checks for a potential overflow of `sqrtRatioX96` and switches the implementation to avoid the issue.\n\n### Recommendation\n\nThe `poolPrice` function can delegate the calculation directly to the [OracleLibrary.getQuoteAtTick](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/OracleLibrary#getquoteattick) function of the `v3-periphery` package:\n\n```solidity\nfunction poolPrice() private view returns (uint256) {\n    address rocketTokenRETHAddress = RocketStorageInterface(\n        ROCKET_STORAGE_ADDRESS\n    ).getAddress(\n            keccak256(\n                abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n            )\n        );\n    IUniswapV3Factory factory = IUniswapV3Factory(UNI_V3_FACTORY);\n    IUniswapV3Pool pool = IUniswapV3Pool(\n        factory.getPool(rocketTokenRETHAddress, W_ETH_ADDRESS, 500)\n    );\n    (, int24 tick, , , , , ) = pool.slot0();\n    return OracleLibrary.getQuoteAtTick(tick, 1e18, rocketTokenRETHAddress, W_ETH_ADDRESS);\n}\n```\n\n**[toshiSat (Asymmetry) disputed via duplicate issue `#693`](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/693#issuecomment-1500457920)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Using Chainlink to get price instead of poolPrice.<br>\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/33), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/28), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/6).\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-03-asymmetry",
  "Code": [
    {
      "filename": "contracts/SafEth/derivatives/Reth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IDerivative.sol\";\nimport \"../../interfaces/frax/IsFrxEth.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/rocketpool/RocketStorageInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketTokenRETHInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDepositPoolInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../interfaces/uniswap/ISwapRouter.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Factory.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Pool.sol\";\n\n/// @title Derivative contract for rETH\n/// @author Asymmetry Finance\ncontract Reth is IDerivative, Initializable, OwnableUpgradeable {\n    address public constant ROCKET_STORAGE_ADDRESS =\n        0x1d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46;\n    address public constant W_ETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant UNISWAP_ROUTER =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address public constant UNI_V3_FACTORY =\n        0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    uint256 public maxSlippage;\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - owner of the contract which handles stake/unstake\n    */\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n        maxSlippage = (1 * 10 ** 16); // 1%\n    }\n\n    /**\n        @notice - Return derivative name\n    */\n    function name() public pure returns (string memory) {\n        return \"RocketPool\";\n    }\n\n    /**\n        @notice - Owner only function to set max slippage for derivative\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(uint256 _slippage) external onlyOwner {\n        maxSlippage = _slippage;\n    }\n\n    /**\n        @notice - Get rETH address\n        @dev - per RocketPool Docs query addresses each time it is used\n     */\n    function rethAddress() private view returns (address) {\n        return\n            RocketStorageInterface(ROCKET_STORAGE_ADDRESS).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n    }\n\n    /**\n        @notice - Swap tokens through Uniswap\n        @param _tokenIn - token to swap from\n        @param _tokenOut - token to swap to\n        @param _poolFee - pool fee for particular swap\n        @param _amountIn - amount of token to swap from\n        @param _minOut - minimum amount of token to receive (slippage)\n     */\n    function swapExactInputSingleHop(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _poolFee,\n        uint256 _amountIn,\n        uint256 _minOut\n    ) private returns (uint256 amountOut) {\n        IERC20(_tokenIn).approve(UNISWAP_ROUTER, _amountIn);\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n            .ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _poolFee,\n                recipient: address(this),\n                amountIn: _amountIn,\n                amountOutMinimum: _minOut,\n                sqrtPriceLimitX96: 0\n            });\n        amountOut = ISwapRouter(UNISWAP_ROUTER).exactInputSingle(params);\n    }\n\n    /**\n        @notice - Convert derivative into ETH\n     */\n    function withdraw(uint256 amount) external onlyOwner {\n        RocketTokenRETHInterface(rethAddress()).burn(amount);\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n        @notice - Check whether or not rETH deposit pool has room users amount\n        @param _amount - amount that will be deposited\n     */\n    function poolCanDeposit(uint256 _amount) private view returns (bool) {\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        address rocketProtocolSettingsAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\n                        \"contract.address\",\n                        \"rocketDAOProtocolSettingsDeposit\"\n                    )\n                )\n            );\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(\n                rocketProtocolSettingsAddress\n            );\n\n        return\n            rocketDepositPool.getBalance() + _amount <=\n            rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&\n            _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n    }\n\n    /**\n        @notice - Deposit into derivative\n        @dev - will either get rETH on exchange or deposit into contract depending on availability\n     */\n    function deposit() external payable onlyOwner returns (uint256) {\n        // Per RocketPool Docs query addresses each time it is used\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        if (!poolCanDeposit(msg.value)) {\n            uint rethPerEth = (10 ** 36) / poolPrice();\n\n            uint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n                ((10 ** 18 - maxSlippage))) / 10 ** 18);\n\n            IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n            uint256 amountSwapped = swapExactInputSingleHop(\n                W_ETH_ADDRESS,\n                rethAddress(),\n                500,\n                msg.value,\n                minOut\n            );\n\n            return amountSwapped;\n        } else {\n            address rocketTokenRETHAddress = RocketStorageInterface(\n                ROCKET_STORAGE_ADDRESS\n            ).getAddress(\n                    keccak256(\n                        abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                    )\n                );\n            RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(\n                rocketTokenRETHAddress\n            );\n            uint256 rethBalance1 = rocketTokenRETH.balanceOf(address(this));\n            rocketDepositPool.deposit{value: msg.value}();\n            uint256 rethBalance2 = rocketTokenRETH.balanceOf(address(this));\n            require(rethBalance2 > rethBalance1, \"No rETH was minted\");\n            uint256 rethMinted = rethBalance2 - rethBalance1;\n            return (rethMinted);\n        }\n    }\n\n    /**\n        @notice - Get price of derivative in terms of ETH\n        @dev - we need to pass amount so that it gets price from the same source that it buys or mints the rEth\n        @param _amount - amount to check for ETH price\n     */\n    function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        if (poolCanDeposit(_amount))\n            return\n                RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n        else return (poolPrice() * 10 ** 18) / (10 ** 18);\n    }\n\n    /**\n        @notice - Total derivative balance\n     */\n    function balance() public view returns (uint256) {\n        return IERC20(rethAddress()).balanceOf(address(this));\n    }\n\n    /**\n        @notice - Price of derivative in liquidity pool\n     */\n    function poolPrice() private view returns (uint256) {\n        address rocketTokenRETHAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n        IUniswapV3Factory factory = IUniswapV3Factory(UNI_V3_FACTORY);\n        IUniswapV3Pool pool = IUniswapV3Pool(\n            factory.getPool(rocketTokenRETHAddress, W_ETH_ADDRESS, 500)\n        );\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/libraries/OracleLibrary.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n        internal\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) =\n            IUniswapV3Pool(pool).observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta =\n            secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % secondsAgo != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) =\n            IUniswapV3Pool(pool).observations((observationIndex + 1) % observationCardinality);\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        secondsAgo = uint32(block.timestamp) - observationTimestamp;\n    }\n\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\n    /// @param pool Address of Uniswap V3 pool\n    /// @return The tick that the pool was in at the start of the current block\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n        // 2 observations are needed to reliably calculate the block starting tick\n        require(observationCardinality > 1, 'NEO');\n\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\n        // We don't need to check if this observation is initialized - it is guaranteed to be.\n        (uint32 observationTimestamp, int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128, ) =\n            IUniswapV3Pool(pool).observations(observationIndex);\n        if (observationTimestamp != uint32(block.timestamp)) {\n            return (tick, IUniswapV3Pool(pool).liquidity());\n        }\n\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n        (\n            uint32 prevObservationTimestamp,\n            int56 prevTickCumulative,\n            uint160 prevSecondsPerLiquidityCumulativeX128,\n            bool prevInitialized\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\n\n        require(prevInitialized, 'ONI');\n\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\n        tick = int24((tickCumulative - prevTickCumulative) / delta);\n        uint128 liquidity =\n            uint128(\n                (uint192(delta) * type(uint160).max) /\n                    (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n            );\n        return (tick, liquidity);\n    }\n\n    /// @notice Information for calculating a weighted arithmetic mean tick\n    struct WeightedTickData {\n        int24 tick;\n        uint128 weight;\n    }\n\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n    /// @param weightedTickData An array of ticks and weights\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\n        internal\n        pure\n        returns (int24 weightedArithmeticMeanTick)\n    {\n        // Accumulates the sum of products between each tick and its weight\n        int256 numerator;\n\n        // Accumulates the sum of the weights\n        uint256 denominator;\n\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n        for (uint256 i; i < weightedTickData.length; i++) {\n            numerator += weightedTickData[i].tick * int256(weightedTickData[i].weight);\n            denominator += weightedTickData[i].weight;\n        }\n\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n    }\n\n    /// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n    /// @dev Useful for calculating relative prices along routes.\n    /// @dev There must be one tick for each pairwise set of tokens.\n    /// @param tokens The token contract addresses\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\n        internal\n        pure\n        returns (int256 syntheticTick)\n    {\n        require(tokens.length - 1 == ticks.length, 'DL');\n        for (uint256 i = 1; i <= ticks.length; i++) {\n            // check the tokens for address sort order, then accumulate the\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n            tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n        }\n    }\n}"
    }
  ]
}