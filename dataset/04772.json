{
  "Title": "[L-03] The `rounding direction` should be set to `round up` in the `_adjustAddLiquidity` function in the `router` contract",
  "Content": "\nIn the `_adjustAddLiquidity` function, all calculations are `rounded down`.\nhttps://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/periphery/Router.sol#L521-L538\n```\nfunction _adjustAddLiquidity(\n    address lp,\n    uint256 baseInAmount,\n    uint256 quoteInAmount\n) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {\n        if (IERC20(lp).totalSupply() == 0) {\n            uint256 i = IMagicLP(lp)._I_();\n            uint256 shares = quoteInAmount < DecimalMath.mulFloor(baseInAmount, i) ? DecimalMath.divFloor(quoteInAmount, i) : baseInAmount;\n            baseAdjustedInAmount = shares;\n@here:            quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n        } else {\n            if (quoteReserve > 0 && baseReserve > 0) {\n                uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\n                uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\n                if (baseIncreaseRatio <= quoteIncreaseRatio) {\n                    baseAdjustedInAmount = baseInAmount;\n@here:                    quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);\n                } else {\n                    quoteAdjustedInAmount = quoteInAmount;\n@here:                    baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);\n                }\n            }\n        }\n}\n```\nThese adjusted values are exactly what are deposited into the `pool`. \nGenerally, in most `protocols`, the deposited token amounts should be `rounded up` in favor of the `protocol` rather than the `users` and such kind of issues have been treated as `medium`.\nIn short, the `shares` calculation should be `rounded down`, while the token amounts calculation should be `rounded up`.\n\nAlso in the `previewCreatePool` function.\nhttps://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/periphery/Router.sol#L103\n```\nfunction previewCreatePool() external pure returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n    quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n}\n```\nAnd in the `previewAddLiquidity` function.\nhttps://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/periphery/Router.sol#L140\n```\nfunction previewAddLiquidity() external view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n    if (totalSupply == 0) {\n        quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n    }\n}\n```\nShould use `mulCeil` instead of `mulFloor`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/mimswap/periphery/Router.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {IERC20} from \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {IWETH} from \"interfaces/IWETH.sol\";\nimport {IMagicLP} from \"/mimswap/interfaces/IMagicLP.sol\";\nimport {IFactory} from \"/mimswap/interfaces/IFactory.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\n\ncontract Router {\n    using SafeTransferLib for address;\n    using SafeTransferLib for address payable;\n\n    error ErrNotETHLP();\n    error ErrExpired();\n    error ErrZeroAddress();\n    error ErrPathTooLong();\n    error ErrEmptyPath();\n    error ErrBadPath();\n    error ErrTooHighSlippage(uint256 amountOut);\n    error ErrInvalidBaseToken();\n    error ErrInvalidQuoteToken();\n    error ErrInTokenNotETH();\n    error ErrOutTokenNotETH();\n    error ErrInvalidQuoteTarget();\n    error ErrZeroDecimals();\n    error ErrDecimalsDifferenceTooLarge();\n\n    uint256 public constant MAX_BASE_QUOTE_DECIMALS_DIFFERENCE = 12;\n\n    IWETH public immutable weth;\n    IFactory public immutable factory;\n\n    receive() external payable {}\n\n    constructor(IWETH weth_, IFactory factory_) {\n        if (address(weth_) == address(0) || address(factory_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        weth = weth_;\n        factory = factory_;\n    }\n\n    modifier ensureDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) {\n            revert ErrExpired();\n        }\n        _;\n    }\n\n    function createPool(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        address to,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) external returns (address clone, uint256 shares) {\n        _validateDecimals(IERC20Metadata(baseToken).decimals(), IERC20Metadata(quoteToken).decimals());\n\n        clone = IFactory(factory).create(baseToken, quoteToken, lpFeeRate, i, k);\n\n        baseToken.safeTransferFrom(msg.sender, clone, baseInAmount);\n        quoteToken.safeTransferFrom(msg.sender, clone, quoteInAmount);\n        (shares, , ) = IMagicLP(clone).buyShares(to);\n    }\n\n    function createPoolETH(\n        address token,\n        bool useTokenAsQuote,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        address to,\n        uint256 tokenInAmount\n    ) external payable returns (address clone, uint256 shares) {\n        if (useTokenAsQuote) {\n            _validateDecimals(18, IERC20Metadata(token).decimals());\n        } else {\n            _validateDecimals(IERC20Metadata(token).decimals(), 18);\n        }\n\n        clone = IFactory(factory).create(useTokenAsQuote ? address(weth) : token, useTokenAsQuote ? token : address(weth), lpFeeRate, i, k);\n\n        weth.deposit{value: msg.value}();\n        token.safeTransferFrom(msg.sender, clone, tokenInAmount);\n        address(weth).safeTransferFrom(address(this), clone, msg.value);\n        (shares, , ) = IMagicLP(clone).buyShares(to);\n    }\n\n    function previewCreatePool(\n        uint256 i,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) external pure returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        shares = quoteInAmount < DecimalMath.mulFloor(baseInAmount, i) ? DecimalMath.divFloor(quoteInAmount, i) : baseInAmount;\n        baseAdjustedInAmount = shares;\n        quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n\n        if (shares <= 2001) {\n            return (0, 0, 0);\n        }\n\n        shares -= 1001;\n    }\n\n    function previewAddLiquidity(\n        address lp,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) external view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        (uint256 baseReserve, uint256 quoteReserve) = IMagicLP(lp).getReserves();\n\n        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp)) + baseInAmount;\n        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp)) + quoteInAmount;\n\n        baseInAmount = baseBalance - baseReserve;\n        quoteInAmount = quoteBalance - quoteReserve;\n\n        if (baseInAmount == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 totalSupply = IERC20(lp).totalSupply();\n\n        if (totalSupply == 0) {\n            if (quoteBalance == 0) {\n                return (0, 0, 0);\n            }\n\n            uint256 i = IMagicLP(lp)._I_();\n\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, i) ? DecimalMath.divFloor(quoteBalance, i) : baseBalance;\n            baseAdjustedInAmount = shares;\n            quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n\n            if (shares <= 2001) {\n                return (0, 0, 0);\n            }\n\n            shares -= 1001;\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\n            if (baseInputRatio <= quoteInputRatio) {\n                baseAdjustedInAmount = baseInAmount;\n                quoteAdjustedInAmount = DecimalMath.mulCeil(quoteReserve, baseInputRatio);\n                shares = DecimalMath.mulFloor(totalSupply, baseInputRatio);\n            } else {\n                quoteAdjustedInAmount = quoteInAmount;\n                baseAdjustedInAmount = DecimalMath.mulCeil(baseReserve, quoteInputRatio);\n                shares = DecimalMath.mulFloor(totalSupply, quoteInputRatio);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address lp,\n        address to,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, baseInAmount, quoteInAmount);\n\n        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, baseAdjustedInAmount);\n        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, quoteAdjustedInAmount);\n\n        shares = _addLiquidity(lp, to, minimumShares);\n    }\n\n    function addLiquidityUnsafe(\n        address lp,\n        address to,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 shares) {\n        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, baseInAmount);\n        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, quoteInAmount);\n\n        return _addLiquidity(lp, to, minimumShares);\n    }\n\n    function addLiquidityETH(\n        address lp,\n        address to,\n        address payable refundTo,\n        uint256 tokenInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        uint256 wethAdjustedAmount;\n        uint256 tokenAdjustedAmount;\n        address token = IMagicLP(lp)._BASE_TOKEN_();\n        if (token == address(weth)) {\n            token = IMagicLP(lp)._QUOTE_TOKEN_();\n            (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, msg.value, tokenInAmount);\n            wethAdjustedAmount = baseAdjustedInAmount;\n            tokenAdjustedAmount = quoteAdjustedInAmount;\n        } else if (IMagicLP(lp)._QUOTE_TOKEN_() == address(weth)) {\n            (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, tokenInAmount, msg.value);\n            wethAdjustedAmount = quoteAdjustedInAmount;\n            tokenAdjustedAmount = baseAdjustedInAmount;\n        } else {\n            revert ErrNotETHLP();\n        }\n\n        weth.deposit{value: wethAdjustedAmount}();\n        address(weth).safeTransfer(lp, wethAdjustedAmount);\n\n        // Refund unused ETH\n        if (msg.value > wethAdjustedAmount) {\n            refundTo.safeTransferETH(msg.value - wethAdjustedAmount);\n        }\n\n        token.safeTransferFrom(msg.sender, lp, tokenAdjustedAmount);\n\n        shares = _addLiquidity(lp, to, minimumShares);\n    }\n\n    function addLiquidityETHUnsafe(\n        address lp,\n        address to,\n        uint256 tokenInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 shares) {\n        address token = IMagicLP(lp)._BASE_TOKEN_();\n        if (token == address(weth)) {\n            token = IMagicLP(lp)._QUOTE_TOKEN_();\n        } else if (IMagicLP(lp)._QUOTE_TOKEN_() != address(weth)) {\n            revert ErrNotETHLP();\n        }\n\n        weth.deposit{value: msg.value}();\n        address(weth).safeTransfer(lp, msg.value);\n\n        token.safeTransferFrom(msg.sender, lp, tokenInAmount);\n\n        return _addLiquidity(lp, to, minimumShares);\n    }\n\n    function previewRemoveLiquidity(address lp, uint256 sharesIn) external view returns (uint256 baseAmountOut, uint256 quoteAmountOut) {\n        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp));\n        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp));\n\n        uint256 totalShares = IERC20(lp).totalSupply();\n\n        baseAmountOut = (baseBalance * sharesIn) / totalShares;\n        quoteAmountOut = (quoteBalance * sharesIn) / totalShares;\n    }\n\n    function removeLiquidity(\n        address lp,\n        address to,\n        uint256 sharesIn,\n        uint256 minimumBaseAmount,\n        uint256 minimumQuoteAmount,\n        uint256 deadline\n    ) external returns (uint256 baseAmountOut, uint256 quoteAmountOut) {\n        lp.safeTransferFrom(msg.sender, address(this), sharesIn);\n\n        return IMagicLP(lp).sellShares(sharesIn, to, minimumBaseAmount, minimumQuoteAmount, \"\", deadline);\n    }\n\n    function removeLiquidityETH(\n        address lp,\n        address to,\n        uint256 sharesIn,\n        uint256 minimumETHAmount,\n        uint256 minimumTokenAmount,\n        uint256 deadline\n    ) external returns (uint256 ethAmountOut, uint256 tokenAmountOut) {\n        lp.safeTransferFrom(msg.sender, address(this), sharesIn);\n\n        address token = IMagicLP(lp)._BASE_TOKEN_();\n        if (token == address(weth)) {\n            token = IMagicLP(lp)._QUOTE_TOKEN_();\n            (ethAmountOut, tokenAmountOut) = IMagicLP(lp).sellShares(\n                sharesIn,\n                address(this),\n                minimumETHAmount,\n                minimumTokenAmount,\n                \"\",\n                deadline\n            );\n        } else if (IMagicLP(lp)._QUOTE_TOKEN_() == address(weth)) {\n            (tokenAmountOut, ethAmountOut) = IMagicLP(lp).sellShares(\n                sharesIn,\n                address(this),\n                minimumTokenAmount,\n                minimumETHAmount,\n                \"\",\n                deadline\n            );\n        } else {\n            revert ErrNotETHLP();\n        }\n\n        weth.withdraw(ethAmountOut);\n        to.safeTransferETH(ethAmountOut);\n\n        token.safeTransfer(to, tokenAmountOut);\n    }\n\n    function swapTokensForTokens(\n        address to,\n        uint256 amountIn,\n        address[] calldata path,\n        uint256 directions,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        _validatePath(path);\n\n        address firstLp = path[0];\n\n        // Transfer to the first LP\n        if (directions & 1 == 0) {\n            IMagicLP(firstLp)._BASE_TOKEN_().safeTransferFrom(msg.sender, address(firstLp), amountIn);\n        } else {\n            IMagicLP(firstLp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, address(firstLp), amountIn);\n        }\n\n        return _swap(to, path, directions, minimumOut);\n    }\n\n    function swapETHForTokens(\n        address to,\n        address[] calldata path,\n        uint256 directions,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 amountOut) {\n        _validatePath(path);\n\n        address firstLp = path[0];\n        address inToken;\n\n        if (directions & 1 == 0) {\n            inToken = IMagicLP(firstLp)._BASE_TOKEN_();\n        } else {\n            inToken = IMagicLP(firstLp)._QUOTE_TOKEN_();\n        }\n\n        // Transfer to the first LP\n        if (inToken != address(weth)) {\n            revert ErrInTokenNotETH();\n        }\n\n        weth.deposit{value: msg.value}();\n        inToken.safeTransfer(address(firstLp), msg.value);\n\n        return _swap(to, path, directions, minimumOut);\n    }\n\n    function swapTokensForETH(\n        address to,\n        uint256 amountIn,\n        address[] calldata path,\n        uint256 directions,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        _validatePath(path);\n\n        uint256 lastLpIndex = path.length - 1;\n        address lastLp = path[lastLpIndex];\n        address outToken;\n\n        if ((directions >> lastLpIndex) & 1 == 0) {\n            outToken = IMagicLP(lastLp)._QUOTE_TOKEN_();\n        } else {\n            outToken = IMagicLP(lastLp)._BASE_TOKEN_();\n        }\n\n        if (outToken != address(weth)) {\n            revert ErrOutTokenNotETH();\n        }\n\n        address firstLp = path[0];\n\n        // Transfer to the first LP\n        if (directions & 1 == 0) {\n            IMagicLP(firstLp)._BASE_TOKEN_().safeTransferFrom(msg.sender, firstLp, amountIn);\n        } else {\n            IMagicLP(firstLp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, firstLp, amountIn);\n        }\n\n        amountOut = _swap(address(this), path, directions, minimumOut);\n        weth.withdraw(amountOut);\n\n        to.safeTransferETH(amountOut);\n    }\n\n    function sellBaseTokensForTokens(\n        address lp,\n        address to,\n        uint256 amountIn,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);\n        return _sellBase(lp, to, minimumOut);\n    }\n\n    function sellBaseETHForTokens(\n        address lp,\n        address to,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 amountOut) {\n        address baseToken = IMagicLP(lp)._BASE_TOKEN_();\n\n        if (baseToken != address(weth)) {\n            revert ErrInvalidBaseToken();\n        }\n\n        weth.deposit{value: msg.value}();\n        baseToken.safeTransfer(lp, msg.value);\n        return _sellBase(lp, to, minimumOut);\n    }\n\n    function sellBaseTokensForETH(\n        address lp,\n        address to,\n        uint256 amountIn,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        if (IMagicLP(lp)._QUOTE_TOKEN_() != address(weth)) {\n            revert ErrInvalidQuoteToken();\n        }\n\n        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);\n        amountOut = _sellBase(lp, address(this), minimumOut);\n        weth.withdraw(amountOut);\n        to.safeTransferETH(amountOut);\n    }\n\n    function sellQuoteTokensForTokens(\n        address lp,\n        address to,\n        uint256 amountIn,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);\n\n        return _sellQuote(lp, to, minimumOut);\n    }\n\n    function sellQuoteETHForTokens(\n        address lp,\n        address to,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 amountOut) {\n        address quoteToken = IMagicLP(lp)._QUOTE_TOKEN_();\n\n        if (quoteToken != address(weth)) {\n            revert ErrInvalidQuoteToken();\n        }\n\n        weth.deposit{value: msg.value}();\n        quoteToken.safeTransfer(lp, msg.value);\n        return _sellQuote(lp, to, minimumOut);\n    }\n\n    function sellQuoteTokensForETH(\n        address lp,\n        address to,\n        uint256 amountIn,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        if (IMagicLP(lp)._BASE_TOKEN_() != address(weth)) {\n            revert ErrInvalidBaseToken();\n        }\n\n        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);\n        amountOut = _sellQuote(lp, address(this), minimumOut);\n        weth.withdraw(amountOut);\n        to.safeTransferETH(amountOut);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _addLiquidity(address lp, address to, uint256 minimumShares) internal returns (uint256 shares) {\n        (shares, , ) = IMagicLP(lp).buyShares(to);\n\n        if (shares < minimumShares) {\n            revert ErrTooHighSlippage(shares);\n        }\n    }\n\n    /// Adapted from: https://github.com/DODOEX/contractV2/blob/main/contracts/SmartRoute/proxies/DODODspProxy.sol\n    /// Copyright 2020 DODO ZOO. Licensed under Apache-2.0.\n    function _adjustAddLiquidity(\n        address lp,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {\n        (uint256 baseReserve, uint256 quoteReserve) = IMagicLP(lp).getReserves();\n        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp)) + baseInAmount;\n        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp)) + quoteInAmount;\n\n        baseInAmount = baseBalance - baseReserve;\n        quoteInAmount = quoteBalance - quoteReserve;\n\n        if (IERC20(lp).totalSupply() == 0) {\n            uint256 i = IMagicLP(lp)._I_();\n            uint256 shares = quoteInAmount < DecimalMath.mulFloor(baseInAmount, i) ? DecimalMath.divFloor(quoteInAmount, i) : baseInAmount;\n            baseAdjustedInAmount = shares;\n            quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n        } else {\n            if (quoteReserve > 0 && baseReserve > 0) {\n                uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\n                uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\n                if (baseIncreaseRatio <= quoteIncreaseRatio) {\n                    baseAdjustedInAmount = baseInAmount;\n                    quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);\n                } else {\n                    quoteAdjustedInAmount = quoteInAmount;\n                    baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);\n                }\n            }\n        }\n    }\n\n    function _swap(address to, address[] calldata path, uint256 directions, uint256 minimumOut) internal returns (uint256 amountOut) {\n        uint256 iterations = path.length - 1; // Subtract by one as last swap is done separately\n\n        for (uint256 i = 0; i < iterations; ) {\n            if (directions & 1 == 0) {\n                // Sell base\n                IMagicLP(path[i]).sellBase(address(path[i + 1]));\n            } else {\n                // Sell quote\n                IMagicLP(path[i]).sellQuote(address(path[i + 1]));\n            }\n\n            directions >>= 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if ((directions & 1 == 0)) {\n            amountOut = IMagicLP(path[iterations]).sellBase(to);\n        } else {\n            amountOut = IMagicLP(path[iterations]).sellQuote(to);\n        }\n\n        if (amountOut < minimumOut) {\n            revert ErrTooHighSlippage(amountOut);\n        }\n    }\n\n    function _sellBase(address lp, address to, uint256 minimumOut) internal returns (uint256 amountOut) {\n        amountOut = IMagicLP(lp).sellBase(to);\n        if (amountOut < minimumOut) {\n            revert ErrTooHighSlippage(amountOut);\n        }\n    }\n\n    function _sellQuote(address lp, address to, uint256 minimumOut) internal returns (uint256 amountOut) {\n        amountOut = IMagicLP(lp).sellQuote(to);\n\n        if (amountOut < minimumOut) {\n            revert ErrTooHighSlippage(amountOut);\n        }\n    }\n\n    function _validatePath(address[] calldata path) internal pure {\n        uint256 pathLength = path.length;\n\n        // Max 256 because of bits in directions\n        if (pathLength > 256) {\n            revert ErrPathTooLong();\n        }\n        if (pathLength <= 0) {\n            revert ErrEmptyPath();\n        }\n    }\n\n    function _validateDecimals(uint8 baseDecimals, uint8 quoteDecimals) internal pure {\n        if (baseDecimals == 0 || quoteDecimals == 0) {\n            revert ErrZeroDecimals();\n        }\n        if (quoteDecimals - baseDecimals > MAX_BASE_QUOTE_DECIMALS_DIFFERENCE) {\n            revert ErrDecimalsDifferenceTooLarge();\n        }\n    }\n}"
    },
    {
      "filename": "src/mimswap/periphery/Router.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {IERC20} from \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {IWETH} from \"interfaces/IWETH.sol\";\nimport {IMagicLP} from \"/mimswap/interfaces/IMagicLP.sol\";\nimport {IFactory} from \"/mimswap/interfaces/IFactory.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\n\ncontract Router {\n    using SafeTransferLib for address;\n    using SafeTransferLib for address payable;\n\n    error ErrNotETHLP();\n    error ErrExpired();\n    error ErrZeroAddress();\n    error ErrPathTooLong();\n    error ErrEmptyPath();\n    error ErrBadPath();\n    error ErrTooHighSlippage(uint256 amountOut);\n    error ErrInvalidBaseToken();\n    error ErrInvalidQuoteToken();\n    error ErrInTokenNotETH();\n    error ErrOutTokenNotETH();\n    error ErrInvalidQuoteTarget();\n    error ErrZeroDecimals();\n    error ErrDecimalsDifferenceTooLarge();\n\n    uint256 public constant MAX_BASE_QUOTE_DECIMALS_DIFFERENCE = 12;\n\n    IWETH public immutable weth;\n    IFactory public immutable factory;\n\n    receive() external payable {}\n\n    constructor(IWETH weth_, IFactory factory_) {\n        if (address(weth_) == address(0) || address(factory_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        weth = weth_;\n        factory = factory_;\n    }\n\n    modifier ensureDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) {\n            revert ErrExpired();\n        }\n        _;\n    }\n\n    function createPool(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        address to,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) external returns (address clone, uint256 shares) {\n        _validateDecimals(IERC20Metadata(baseToken).decimals(), IERC20Metadata(quoteToken).decimals());\n\n        clone = IFactory(factory).create(baseToken, quoteToken, lpFeeRate, i, k);\n\n        baseToken.safeTransferFrom(msg.sender, clone, baseInAmount);\n        quoteToken.safeTransferFrom(msg.sender, clone, quoteInAmount);\n        (shares, , ) = IMagicLP(clone).buyShares(to);\n    }\n\n    function createPoolETH(\n        address token,\n        bool useTokenAsQuote,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        address to,\n        uint256 tokenInAmount\n    ) external payable returns (address clone, uint256 shares) {\n        if (useTokenAsQuote) {\n            _validateDecimals(18, IERC20Metadata(token).decimals());\n        } else {\n            _validateDecimals(IERC20Metadata(token).decimals(), 18);\n        }\n\n        clone = IFactory(factory).create(useTokenAsQuote ? address(weth) : token, useTokenAsQuote ? token : address(weth), lpFeeRate, i, k);\n\n        weth.deposit{value: msg.value}();\n        token.safeTransferFrom(msg.sender, clone, tokenInAmount);\n        address(weth).safeTransferFrom(address(this), clone, msg.value);\n        (shares, , ) = IMagicLP(clone).buyShares(to);\n    }\n\n    function previewCreatePool(\n        uint256 i,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) external pure returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        shares = quoteInAmount < DecimalMath.mulFloor(baseInAmount, i) ? DecimalMath.divFloor(quoteInAmount, i) : baseInAmount;\n        baseAdjustedInAmount = shares;\n        quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n\n        if (shares <= 2001) {\n            return (0, 0, 0);\n        }\n\n        shares -= 1001;\n    }\n\n    function previewAddLiquidity(\n        address lp,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) external view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        (uint256 baseReserve, uint256 quoteReserve) = IMagicLP(lp).getReserves();\n\n        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp)) + baseInAmount;\n        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp)) + quoteInAmount;\n\n        baseInAmount = baseBalance - baseReserve;\n        quoteInAmount = quoteBalance - quoteReserve;\n\n        if (baseInAmount == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 totalSupply = IERC20(lp).totalSupply();\n\n        if (totalSupply == 0) {\n            if (quoteBalance == 0) {\n                return (0, 0, 0);\n            }\n\n            uint256 i = IMagicLP(lp)._I_();\n\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, i) ? DecimalMath.divFloor(quoteBalance, i) : baseBalance;\n            baseAdjustedInAmount = shares;\n            quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n\n            if (shares <= 2001) {\n                return (0, 0, 0);\n            }\n\n            shares -= 1001;\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\n            if (baseInputRatio <= quoteInputRatio) {\n                baseAdjustedInAmount = baseInAmount;\n                quoteAdjustedInAmount = DecimalMath.mulCeil(quoteReserve, baseInputRatio);\n                shares = DecimalMath.mulFloor(totalSupply, baseInputRatio);\n            } else {\n                quoteAdjustedInAmount = quoteInAmount;\n                baseAdjustedInAmount = DecimalMath.mulCeil(baseReserve, quoteInputRatio);\n                shares = DecimalMath.mulFloor(totalSupply, quoteInputRatio);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address lp,\n        address to,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, baseInAmount, quoteInAmount);\n\n        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, baseAdjustedInAmount);\n        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, quoteAdjustedInAmount);\n\n        shares = _addLiquidity(lp, to, minimumShares);\n    }\n\n    function addLiquidityUnsafe(\n        address lp,\n        address to,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 shares) {\n        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, baseInAmount);\n        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, quoteInAmount);\n\n        return _addLiquidity(lp, to, minimumShares);\n    }\n\n    function addLiquidityETH(\n        address lp,\n        address to,\n        address payable refundTo,\n        uint256 tokenInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        uint256 wethAdjustedAmount;\n        uint256 tokenAdjustedAmount;\n        address token = IMagicLP(lp)._BASE_TOKEN_();\n        if (token == address(weth)) {\n            token = IMagicLP(lp)._QUOTE_TOKEN_();\n            (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, msg.value, tokenInAmount);\n            wethAdjustedAmount = baseAdjustedInAmount;\n            tokenAdjustedAmount = quoteAdjustedInAmount;\n        } else if (IMagicLP(lp)._QUOTE_TOKEN_() == address(weth)) {\n            (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, tokenInAmount, msg.value);\n            wethAdjustedAmount = quoteAdjustedInAmount;\n            tokenAdjustedAmount = baseAdjustedInAmount;\n        } else {\n            revert ErrNotETHLP();\n        }\n\n        weth.deposit{value: wethAdjustedAmount}();\n        address(weth).safeTransfer(lp, wethAdjustedAmount);\n\n        // Refund unused ETH\n        if (msg.value > wethAdjustedAmount) {\n            refundTo.safeTransferETH(msg.value - wethAdjustedAmount);\n        }\n\n        token.safeTransferFrom(msg.sender, lp, tokenAdjustedAmount);\n\n        shares = _addLiquidity(lp, to, minimumShares);\n    }\n\n    function addLiquidityETHUnsafe(\n        address lp,\n        address to,\n        uint256 tokenInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 shares) {\n        address token = IMagicLP(lp)._BASE_TOKEN_();\n        if (token == address(weth)) {\n            token = IMagicLP(lp)._QUOTE_TOKEN_();\n        } else if (IMagicLP(lp)._QUOTE_TOKEN_() != address(weth)) {\n            revert ErrNotETHLP();\n        }\n\n        weth.deposit{value: msg.value}();\n        address(weth).safeTransfer(lp, msg.value);\n\n        token.safeTransferFrom(msg.sender, lp, tokenInAmount);\n\n        return _addLiquidity(lp, to, minimumShares);\n    }\n\n    function previewRemoveLiquidity(address lp, uint256 sharesIn) external view returns (uint256 baseAmountOut, uint256 quoteAmountOut) {\n        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp));\n        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp));\n\n        uint256 totalShares = IERC20(lp).totalSupply();\n\n        baseAmountOut = (baseBalance * sharesIn) / totalShares;\n        quoteAmountOut = (quoteBalance * sharesIn) / totalShares;\n    }\n\n    function removeLiquidity(\n        address lp,\n        address to,\n        uint256 sharesIn,\n        uint256 minimumBaseAmount,\n        uint256 minimumQuoteAmount,\n        uint256 deadline\n    ) external returns (uint256 baseAmountOut, uint256 quoteAmountOut) {\n        lp.safeTransferFrom(msg.sender, address(this), sharesIn);\n\n        return IMagicLP(lp).sellShares(sharesIn, to, minimumBaseAmount, minimumQuoteAmount, \"\", deadline);\n    }\n\n    function removeLiquidityETH(\n        address lp,\n        address to,\n        uint256 sharesIn,\n        uint256 minimumETHAmount,\n        uint256 minimumTokenAmount,\n        uint256 deadline\n    ) external returns (uint256 ethAmountOut, uint256 tokenAmountOut) {\n        lp.safeTransferFrom(msg.sender, address(this), sharesIn);\n\n        address token = IMagicLP(lp)._BASE_TOKEN_();\n        if (token == address(weth)) {\n            token = IMagicLP(lp)._QUOTE_TOKEN_();\n            (ethAmountOut, tokenAmountOut) = IMagicLP(lp).sellShares(\n                sharesIn,\n                address(this),\n                minimumETHAmount,\n                minimumTokenAmount,\n                \"\",\n                deadline\n            );\n        } else if (IMagicLP(lp)._QUOTE_TOKEN_() == address(weth)) {\n            (tokenAmountOut, ethAmountOut) = IMagicLP(lp).sellShares(\n                sharesIn,\n                address(this),\n                minimumTokenAmount,\n                minimumETHAmount,\n                \"\",\n                deadline\n            );\n        } else {\n            revert ErrNotETHLP();\n        }\n\n        weth.withdraw(ethAmountOut);\n        to.safeTransferETH(ethAmountOut);\n\n        token.safeTransfer(to, tokenAmountOut);\n    }\n\n    function swapTokensForTokens(\n        address to,\n        uint256 amountIn,\n        address[] calldata path,\n        uint256 dire"
    }
  ]
}