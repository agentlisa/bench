{
  "Title": "[G-05] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
  "Content": "\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. Each iteration of this for-loop costs at least 60 gas (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Structs have the same overhead as an array of length one\n\n*There are 6 instances of this issue:*\n\n```solidity\nFile: contracts/Interfaces.sol\n\n17:       function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n\n79:           JoinPoolRequest memory request\n\n83:           SingleSwap memory singleSwap,\n\n84:           FundManagement memory funds,\n\n93:           ExitPoolRequest memory request\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/Interfaces.sol#L17>\n\n```solidity\nFile: convex-platform/contracts/contracts/PoolManagerSecondaryProxy.sol\n\n68:       function setUsedAddress(address[] memory usedList) external onlyOwner{\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/PoolManagerSecondaryProxy.sol#L68>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/Interfaces.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\npragma abicoder v2;\n\ninterface IPriceOracle {\n    struct OracleAverageQuery {\n        Variable variable;\n        uint256 secs;\n        uint256 ago;\n    }\n    enum Variable {\n        PAIR_PRICE,\n        BPT_PRICE,\n        INVARIANT\n    }\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n}\n\ninterface IVault {\n    enum PoolSpecialization {\n        GENERAL,\n        MINIMAL_SWAP_INFO,\n        TWO_TOKEN\n    }\n    enum JoinKind {\n        INIT,\n        EXACT_TOKENS_IN_FOR_BPT_OUT,\n        TOKEN_IN_FOR_EXACT_BPT_OUT,\n        ALL_TOKENS_IN_FOR_EXACT_BPT_OUT\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external returns (uint256 amountCalculated);\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n    enum ExitKind {\n        EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n        EXACT_BPT_IN_FOR_TOKENS_OUT,\n        BPT_IN_FOR_EXACT_TOKENS_OUT,\n        MANAGEMENT_FEE_TOKENS_OUT // for ManagedPool\n    }\n}\n\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}\n\ninterface IAuraLocker {\n    function lock(address _account, uint256 _amount) external;\n\n    function checkpointEpoch() external;\n\n    function epochCount() external view returns (uint256);\n\n    function balanceAtEpochOf(uint256 _epoch, address _user) external view returns (uint256 amount);\n\n    function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply);\n\n    function queueNewRewards(uint256 _rewards) external;\n\n    function notifyRewardAmount(address _rewardsToken, uint256 reward) external;\n\n    function getReward(address _account, bool _stake) external;\n\n    function getReward(address _account) external;\n}\n\ninterface IExtraRewardsDistributor {\n    function addReward(address _token, uint256 _amount) external;\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/PoolManagerSecondaryProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/IGaugeController.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\n\n/**\n * @title   PoolManagerSecondaryProxy\n * @author  ConvexFinance\n * @notice  Basically a PoolManager that has a better shutdown and calls addPool on PoolManagerProxy. \n *          Immutable pool manager proxy to enforce that when a  pool is shutdown, the proper number\n *          of lp tokens are returned to the booster contract for withdrawal.\n */\ncontract PoolManagerSecondaryProxy{\n    using SafeMath for uint256;\n\n    address public immutable gaugeController;\n    address public immutable pools;\n    address public immutable booster;\n    address public owner;\n    address public operator;\n    bool public isShutdown;\n\n    mapping(address => bool) public usedMap;\n\n    /**\n     * @param _gaugeController Curve Gauge controller (0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB)\n     * @param _pools PoolManagerProxy (0x5F47010F230cE1568BeA53a06eBAF528D05c5c1B)\n     * @param _booster Booster\n     * @param _owner Executoor\n     */\n    constructor(\n        address _gaugeController,\n        address _pools,\n        address _booster,\n        address _owner\n    ) public {\n        gaugeController = _gaugeController;\n        pools = _pools;\n        booster = _booster;\n        owner = _owner; \n        operator = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"!owner\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operator == msg.sender, \"!op\");\n        _;\n    }\n\n    //set owner - only OWNER\n    function setOwner(address _owner) external onlyOwner{\n        owner = _owner;\n    }\n\n    //set operator - only OWNER\n    function setOperator(address _operator) external onlyOwner{\n        operator = _operator;\n    }\n\n    //manual set an address to used state\n    function setUsedAddress(address[] memory usedList) external onlyOwner{\n        for(uint i=0; i < usedList.length; i++){\n            usedMap[usedList[i]] = true;\n        }\n    }\n\n    //shutdown pool management and disallow new pools. change is immutable\n    function shutdownSystem() external onlyOwner{\n        isShutdown = true;\n    }\n\n    /**\n     * @notice  Shutdown a pool - only OPERATOR\n     * @dev     Shutdowns a pool and ensures all the LP tokens are properly\n     *          withdrawn to the Booster contract \n     */\n    function shutdownPool(uint256 _pid) external onlyOperator returns(bool){\n        //get pool info\n        (address lptoken, address depositToken,,,,bool isshutdown) = IPools(booster).poolInfo(_pid);\n        require(!isshutdown, \"already shutdown\");\n\n        //shutdown pool and get before and after amounts\n        uint256 beforeBalance = IERC20(lptoken).balanceOf(booster);\n        IPools(pools).shutdownPool(_pid);\n        uint256 afterBalance = IERC20(lptoken).balanceOf(booster);\n\n        //check that proper amount of tokens were withdrawn(will also fail if already shutdown)\n        require( afterBalance.sub(beforeBalance) >= IERC20(depositToken).totalSupply(), \"supply mismatch\");\n\n        return true;\n    }\n\n    //add a new pool if it has weight on the gauge controller - only OPERATOR\n    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external onlyOperator returns(bool){\n        //check that the pool as weight\n        uint256 weight = IGaugeController(gaugeController).get_gauge_weight(_gauge);\n        require(weight > 0, \"must have weight\");\n\n        return _addPool(_lptoken, _gauge, _stashVersion);\n    }\n\n    //force add a new pool, but only for addresses that have never been used before - only OPERATOR\n    function forceAddPool(address _lptoken, address _gauge, uint256 _stashVersion) external onlyOperator returns(bool){\n        require(!usedMap[_lptoken] && !usedMap[_gauge], \"cant force used pool\");\n\n        return _addPool(_lptoken, _gauge, _stashVersion);\n    }\n\n    //internal add pool and updated used list\n    function _addPool(address _lptoken, address _gauge, uint256 _stashVersion) internal returns(bool){\n        require(!isShutdown, \"shutdown\");\n\n        usedMap[_lptoken] = true;\n        usedMap[_gauge] = true;\n\n        return IPools(pools).addPool(_lptoken,_gauge,_stashVersion);\n    }\n}"
    }
  ]
}