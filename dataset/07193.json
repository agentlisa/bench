{
  "Title": "[N-07] Typos in comments",
  "Content": "\nThe default order numerator + denominator values are _always_ 1 and 1, so this `e.g.` in [`ConsiderationDecoder.sol`](https://github.com/horsefacts/seaport/blob/5de7302bc773d9821ba4759e47fc981680911ea0/contracts/lib/ConsiderationDecoder.sol#L351-L353) should be an `i.e.`:\n\n```solidity\n        // Write default Order numerator and denominator values (e.g. 1/1).\n        mPtr.offset(AdvancedOrder_numerator_offset).write(1);\n        mPtr.offset(AdvancedOrder_denominator_offset).write(1);\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-opensea",
  "Code": [
    {
      "filename": "contracts/lib/ConsiderationDecoder.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {\n    BasicOrderParameters,\n    Order,\n    CriteriaResolver,\n    AdvancedOrder,\n    FulfillmentComponent,\n    Execution,\n    Fulfillment,\n    OrderComponents,\n    OrderParameters,\n    SpentItem,\n    OfferItem,\n    ConsiderationItem,\n    ReceivedItem\n} from \"./ConsiderationStructs.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\nimport \"../helpers/PointerLibraries.sol\";\n\ncontract ConsiderationDecoder {\n    /**\n     * @dev Takes a bytes array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the bytes array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the bytes array in\n     *                    memory which contains the length of the array.\n     */\n    function _decodeBytes(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Derive the size of the bytes array, rounding up to nearest word\n            // and adding a word for the length field.\n            // Note: masking `calldataload(cdPtrLength)` is redundant here.\n            let size := add(\n                and(\n                    add(calldataload(cdPtrLength), AlmostOneWord),\n                    OnlyFullWordMask\n                ),\n                OneWord\n            )\n\n            // Copy bytes from calldata into memory based on pointers and size.\n            calldatacopy(mPtrLength, cdPtrLength, size)\n            // Store the masked value in memory.\n            // Note: the value of `size` is at least 32.\n            // So the previous line will at least write to `[mPtrLength, mPtrLength + 32)`.\n            mstore(\n                mPtrLength,\n                and(calldataload(cdPtrLength), OffsetOrLengthMask)\n            )\n\n            // Update free memory pointer based on the size of the bytes array.\n            mstore(FreeMemoryPointerSlot, add(mPtrLength, size))\n        }\n    }\n\n    /**\n     * @dev Takes an offer array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the offer array\n     *                    in calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the offer array in\n     *                    memory which contains the length of the array.\n     */\n    function _decodeOffer(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Retrieve length of array, masking to prevent potential overflow.\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Write the array length to memory.\n            mstore(mPtrLength, arrLength)\n\n            // Derive the head by adding one word to the length pointer.\n            let mPtrHead := add(mPtrLength, OneWord)\n\n            // Derive the tail by adding one word per element (note that structs\n            // are written to memory with an offset per struct element).\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n\n            // Track the next tail, beginning with the initial tail value.\n            let mPtrTailNext := mPtrTail\n\n            // Copy all offer array data into memory at the tail pointer.\n            calldatacopy(\n                mPtrTail,\n                add(cdPtrLength, OneWord),\n                mul(arrLength, OfferItem_size)\n            )\n\n            // Track the next head pointer, starting with initial head value.\n            let mPtrHeadNext := mPtrHead\n\n            // Iterate over each head pointer until it reaches the tail.\n            for {\n\n            } lt(mPtrHeadNext, mPtrTail) {\n\n            } {\n                // Write the next tail pointer to next head pointer in memory.\n                mstore(mPtrHeadNext, mPtrTailNext)\n\n                // Increment the next head pointer by one word.\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n\n                // Increment the next tail pointer by the size of an offer item.\n                mPtrTailNext := add(mPtrTailNext, OfferItem_size)\n            }\n\n            // Update free memory pointer to allocate memory up to end of tail.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a consideration array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the consideration\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the consideration\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeConsideration(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Retrieve length of array, masking to prevent potential overflow.\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Write the array length to memory.\n            mstore(mPtrLength, arrLength)\n\n            // Derive the head by adding one word to the length pointer.\n            let mPtrHead := add(mPtrLength, OneWord)\n\n            // Derive the tail by adding one word per element (note that structs\n            // are written to memory with an offset per struct element).\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n\n            // Track the next tail, beginning with the initial tail value.\n            let mPtrTailNext := mPtrTail\n\n            // Copy all consideration array data into memory at tail pointer.\n            calldatacopy(\n                mPtrTail,\n                add(cdPtrLength, OneWord),\n                mul(arrLength, ConsiderationItem_size)\n            )\n\n            // Track the next head pointer, starting with initial head value.\n            let mPtrHeadNext := mPtrHead\n\n            // Iterate over each head pointer until it reaches the tail.\n            for {\n\n            } lt(mPtrHeadNext, mPtrTail) {\n\n            } {\n                // Write the next tail pointer to next head pointer in memory.\n                mstore(mPtrHeadNext, mPtrTailNext)\n\n                // Increment the next head pointer by one word.\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n\n                // Increment next tail pointer by size of a consideration item.\n                mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\n            }\n\n            // Update free memory pointer to allocate memory up to end of tail.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer and memory pointer and copies a referenced\n     *      OrderParameters struct and associated offer and consideration data\n     *      to memory.\n     *\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\n     * @param mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderParametersTo(\n        CalldataPointer cdPtr,\n        MemoryPointer mPtr\n    ) internal pure {\n        // Copy the full OrderParameters head from calldata to memory.\n        cdPtr.copy(mPtr, OrderParameters_head_size);\n\n        // Resolve the offer calldata offset, use that to decode and copy offer\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_offer_head_offset).write(\n            _decodeOffer(cdPtr.pptr(OrderParameters_offer_head_offset))\n        );\n\n        // Resolve consideration calldata offset, use that to copy consideration\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\n            _decodeConsideration(\n                cdPtr.pptr(OrderParameters_consideration_head_offset)\n            )\n        );\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an OrderParameters struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\n     *\n     * @return mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderParameters(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the OrderParameters head (offer and\n        // consideration are allocated independently).\n        mPtr = malloc(OrderParameters_head_size);\n\n        // Decode and copy the order parameters to the newly allocated memory.\n        _decodeOrderParametersTo(cdPtr, mPtr);\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\n     *      struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the Order struct.\n     *\n     * @return mPtr A memory pointer to the Order struct head.\n     */\n    function _decodeOrder(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the Order head (OrderParameters and\n        // signature are allocated independently).\n        mPtr = malloc(Order_head_size);\n\n        // Resolve OrderParameters calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.write(_decodeOrderParameters(cdPtr.pptr()));\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(Order_signature_offset).write(\n            _decodeBytes(cdPtr.pptr(Order_signature_offset))\n        );\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an AdvancedOrder struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the AdvancedOrder struct.\n     *\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\n     */\n    function _decodeAdvancedOrder(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\n\n        // Use numerator + denominator calldata offset to decode and copy\n        // from calldata and write resultant memory offset to head in memory.\n        cdPtr.offset(AdvancedOrder_numerator_offset).copy(\n            mPtr.offset(AdvancedOrder_numerator_offset),\n            AdvancedOrder_fixed_segment_0\n        );\n\n        // Get pointer to memory immediately after advanced order.\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\n\n        // Write pptr for advanced order parameters to memory.\n        mPtr.write(mPtrParameters);\n\n        // Resolve OrderParameters calldata pointer & write to allocated region.\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_signature_offset).write(\n            _decodeBytes(cdPtr.pptr(AdvancedOrder_signature_offset))\n        );\n\n        // Resolve extraData calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_extraData_offset).write(\n            _decodeBytes(cdPtr.pptr(AdvancedOrder_extraData_offset))\n        );\n    }\n\n    /**\n     * @dev Allocates a single word of empty bytes in memory and returns the\n     *      pointer to that memory region.\n     *\n     * @return mPtr The memory pointer to the new empty word in memory.\n     */\n    function _getEmptyBytesOrArray()\n        internal\n        pure\n        returns (MemoryPointer mPtr)\n    {\n        mPtr = malloc(OneWord);\n        mPtr.write(0);\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\n     *      struct to memory as an AdvancedOrder.\n     *\n     * @param cdPtr A calldata pointer for the Order struct.\n     *\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\n     */\n    function _decodeOrderAsAdvancedOrder(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\n\n        // Get pointer to memory immediately after advanced order.\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\n\n        // Write pptr for advanced order parameters.\n        mPtr.write(mPtrParameters);\n\n        // Resolve OrderParameters calldata pointer & write to allocated region.\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\n\n        // Write default Order numerator and denominator values (e.g. 1/1).\n        mPtr.offset(AdvancedOrder_numerator_offset).write(1);\n        mPtr.offset(AdvancedOrder_denominator_offset).write(1);\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_signature_offset).write(\n            _decodeBytes(cdPtr.pptr(Order_signature_offset))\n        );\n\n        // Resolve extraData calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_extraData_offset).write(\n            _getEmptyBytesOrArray()\n        );\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an array of Order structs and copies the\n     *      decoded array to memory as an array of AdvancedOrder structs.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the array of advanced\n     *                    orders in memory which contains length of the array.\n     */\n    function _decodeOrdersAsAdvancedOrders(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength * OneWord;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Order calldata offset, use it to decode and copy from\n                // calldata, and write resultant AdvancedOrder offset to memory.\n                mPtrHead.offset(offset).write(\n                    _decodeOrderAsAdvancedOrder(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a criteria proof, or an array bytes32\n     *      types, and copies the decoded proof to memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the criteria proof\n     *                    in calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the criteria proof\n     *                    in memory which contains length of the array.\n     */\n    function _decodeCriteriaProof(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive array size based on one word per array element and length.\n            uint256 arrSize = (arrLength + 1) * OneWord;\n\n            // Allocate memory equal to the array size.\n            mPtrLength = malloc(arrSize);\n\n            // Copy the array from calldata into memory.\n            cdPtrLength.copy(mPtrLength, arrSize);\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a CriteriaResolver struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the CriteriaResolver struct.\n     *\n     * @return mPtr A memory pointer to the CriteriaResolver struct head.\n     */\n    function _decodeCriteriaResolver(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the CriteriaResolver head (the criteria\n        // proof bytes32 array is allocated independently).\n        mPtr = malloc(CriteriaResolver_head_size);\n\n        // Decode and copy order index, side, index, and identifier from\n        // calldata and write resultant memory offset to head in memory.\n        cdPtr.copy(mPtr, CriteriaResolver_fixed_segment_0);\n\n        // Resolve criteria proof calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(CriteriaResolver_criteriaProof_offset).write(\n            _decodeCriteriaProof(\n                cdPtr.pptr(CriteriaResolver_criteriaProof_offset)\n            )\n        );\n    }\n\n    /**\n     * @dev Takes an array of criteria resolvers from calldata and copies it\n     *      into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the criteria\n     *                    resolver array in calldata which contains the length\n     *                    of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the criteria resolver\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeCriteriaResolvers(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength * OneWord;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve CriteriaResolver calldata offset, use it to decode\n                // and copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeCriteriaResolver(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of orders from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the orders array\n     *                    in memory which contains the length of the array.\n     */\n    function _decodeOrders(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength * OneWord;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Order calldata offset, use it to decode and copy\n                // from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeOrder(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of fulfillment components from calldata and copies it\n     *      into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the fulfillment\n     *                    components array in calldata which contains the length\n     *                    of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the fulfillment\n     *                    components array in memory which contains the length\n     *                    of the array.\n     */\n    function _decodeFulfillmentComponents(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            mstore(mPtrLength, arrLength)\n            let mPtrHead := add(mPtrLength, OneWord)\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n            let mPtrTailNext := mPtrTail\n            calldatacopy(\n                mPtrTail,\n                add(cdPtrLength, OneWord),\n                shl(FulfillmentComponent_mem_tail_size_shift, arrLength)\n            )\n            let mPtrHeadNext := mPtrHead\n            for {\n\n            } lt(mPtrHeadNext, mPtrTail) {\n\n            } {\n                mstore(mPtrHeadNext, mPtrTailNext)\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n                mPtrTailNext := add(\n                    mPtrTailNext,\n                    FulfillmentComponent_mem_tail_size\n                )\n            }\n\n            // Update the free memory pointer.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a nested array of fulfillment components from calldata and\n     *      copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the nested\n     *                    fulfillment components array in calldata which\n     *                    contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the nested\n     *                    fulfillment components array in memory which\n     *                    contains the length of the array.\n     */\n    function _decodeNestedFulfillmentComponents(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength * OneWord;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve FulfillmentComponents array calldata offset, use it\n                // to decode and copy from calldata, and write memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeFulfillmentComponents(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of advanced orders from calldata and copies it into\n     *      memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the advanced orders\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the advanced orders\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeAdvancedOrders(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength * OneWord;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve AdvancedOrder calldata offset, use it to decode and\n                // copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeAdvancedOrder(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a Fulfillment struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the Fulfillment struct.\n     *\n     * @return mPtr A memory pointer to the Fulfillment struct head.\n     */\n    function _decodeFulfillment(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the Fulfillment head (the fulfillment\n        // components arrays are allocated independently).\n        mPtr = malloc(Fulfillment_head_size);\n\n        // Resolve offerComponents calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.write(_decodeFulfillmentComponents(cdPtr.pptr()));\n\n        // Resolve considerationComponents calldata offset, use it to decode and\n        // copy from calldata, and write resultant memory offset to memory head.\n        mPtr.offset(Fulfillment_considerationComponents_offset).write(\n            _decodeFulfillmentComponents(\n                cdPtr.pptr(Fulfillment_considerationComponents_offset)\n            )\n        );\n    }\n\n    /**\n     * @dev Takes an array of fulfillments from calldata and copies it into\n     *      memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the fulfillments\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the fulfillments\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeFulfillments(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength * OneWord;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Fulfillment calldata offset, use it to decode and\n                // copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeFulfillment(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an OrderComponents struct and copies the\n     *      decoded struct to memory as an OrderParameters struct (with the\n     *      totalOriginalConsiderationItems value set equal to the length of the\n     *      supplied consideration array).\n     *\n     * @param cdPtr A calldata pointer for the OrderComponents struct.\n     *\n     * @return mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderComponentsAsOrderParameters(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for the OrderParameters head.\n        mPtr = malloc(OrderParameters_head_size);\n\n        // Copy the full OrderComponents head from calldata to memory.\n        cdPtr.copy(mPtr, OrderComponents_OrderParameters_common_head_size);\n\n        // Resolve the offer calldata offset, use that to decode and copy offer\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_offer_head_offset).write(\n            _decodeOffer(cdPtr.pptr(OrderParameters_offer_head_offset))\n        );\n\n        // Resolve consideration calldata offset, use that to copy consideration\n        // from calldata, and write resultant memory offset to head in memory.\n        MemoryPointer consideration = _decodeConsideration(\n            cdPtr.pptr(OrderParameters_consideration_head_offset)\n        );\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\n            consideration\n        );\n\n        // Write masked consideration length to totalOriginalConsiderationItems.\n        mPtr\n            .offset(OrderParameters_totalOriginalConsiderationItems_offset)\n            .write(consideration.readUint256());\n    }\n\n    /**\n     * @dev Decodes the returndata from a call to generateOrder, or returns\n     *      empty arrays and a boolean signifying that the returndata does not\n     *      adhere to a valid encoding scheme if it cannot be decoded.\n     *\n     * @return invalidEncoding A boolean signifying whether the returndata has\n     *                         an invalid encoding.\n     * @return offer           The decoded offer array.\n     * @return consideration   The decoded consideration array.\n     */\n    function _decodeGenerateOrderReturndata()\n        internal\n        pure\n        returns (\n            uint256 invalidEncoding,"
    }
  ]
}