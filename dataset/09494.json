{
  "Title": "[N-12] `require()`/`revert()` statements should have descriptive reason strings",
  "Content": "\n1.  File: external/MedianOracle.sol (line [68](https://github.com/ampleforth/market-oracle/blob/5e7fd1506784f074748ab6bd5df740ca2227b14f/contracts/MedianOracle.sol#L68))\n\n```solidity\n        require(reportExpirationTimeSec_ <= MAX_REPORT_EXPIRATION_TIME);\n```\n\n2.  File: external/MedianOracle.sol (line [69](https://github.com/ampleforth/market-oracle/blob/5e7fd1506784f074748ab6bd5df740ca2227b14f/contracts/MedianOracle.sol#L69))\n\n```solidity\n        require(minimumProviders_ > 0);\n```\n\n3.  File: external/MedianOracle.sol (line [84](https://github.com/ampleforth/market-oracle/blob/5e7fd1506784f074748ab6bd5df740ca2227b14f/contracts/MedianOracle.sol#L84))\n\n```solidity\n        require(reportExpirationTimeSec_ <= MAX_REPORT_EXPIRATION_TIME);\n```\n\n4.  File: external/MedianOracle.sol (line [109](https://github.com/ampleforth/market-oracle/blob/5e7fd1506784f074748ab6bd5df740ca2227b14f/contracts/MedianOracle.sol#L109))\n\n```solidity\n        require(minimumProviders_ > 0);\n```\n\n5.  File: external/MedianOracle.sol (line [123](https://github.com/ampleforth/market-oracle/blob/5e7fd1506784f074748ab6bd5df740ca2227b14f/contracts/MedianOracle.sol#L123))\n\n```solidity\n        require(timestamps[0] > 0);\n```\n\n6.  File: external/MedianOracle.sol (line [129](https://github.com/ampleforth/market-oracle/blob/5e7fd1506784f074748ab6bd5df740ca2227b14f/contracts/MedianOracle.sol#L129))\n\n```solidity\n        require(timestamps[index_recent].add(reportDelaySec) <= now);\n```\n\n7.  File: external/MedianOracle.sol (line [143](https://github.com/ampleforth/market-oracle/blob/5e7fd1506784f074748ab6bd5df740ca2227b14f/contracts/MedianOracle.sol#L143))\n\n```solidity\n        require (providerReports[providerAddress][0].timestamp > 0);\n```\n\n8.  File: external/MedianOracle.sol (line [211](https://github.com/ampleforth/market-oracle/blob/5e7fd1506784f074748ab6bd5df740ca2227b14f/contracts/MedianOracle.sol#L211))\n\n```solidity\n        require(providerReports[provider][0].timestamp == 0);\n```\n\n9.  File: external/StakedCitadelLocker.sol (line [126](https://github.com/Citadel-DAO/staked-citadel-locker/blob/980088335adf7fdc62aa9a0c2556b37c01605dd4/src/StakedCitadelLocker.sol#L126))\n\n```solidity\n        require(_stakingToken != address(0)); // dev: _stakingToken address should not be zero\n```\n\n10. File: external/StakedCitadelLocker.sol (line [163](https://github.com/Citadel-DAO/staked-citadel-locker/blob/980088335adf7fdc62aa9a0c2556b37c01605dd4/src/StakedCitadelLocker.sol#L163))\n\n```solidity\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n```\n\n11. File: external/StakedCitadelLocker.sol (line [178](https://github.com/Citadel-DAO/staked-citadel-locker/blob/980088335adf7fdc62aa9a0c2556b37c01605dd4/src/StakedCitadelLocker.sol#L178))\n\n```solidity\n        require(rewardData[_rewardsToken].lastUpdateTime > 0);\n```\n\n12. File: external/StakedCitadelLocker.sol (line [812](https://github.com/Citadel-DAO/staked-citadel-locker/blob/980088335adf7fdc62aa9a0c2556b37c01605dd4/src/StakedCitadelLocker.sol#L812))\n\n```solidity\n        require(rewardDistributors[_rewardsToken][msg.sender]);\n```\n\n13. File: src/lib/GlobalAccessControlManaged.sol (line [81](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/lib/GlobalAccessControlManaged.sol#L81))\n\n```solidity\n        require(gac.hasRole(PAUSER_ROLE, msg.sender));\n```\n\n14. File: src/lib/GlobalAccessControlManaged.sol (line [86](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/lib/GlobalAccessControlManaged.sol#L86))\n\n```solidity\n        require(gac.hasRole(UNPAUSER_ROLE, msg.sender));\n```\n\n15. File: src/StakedCitadel.sol (line [180](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/StakedCitadel.sol#L180))\n\n```solidity\n        require(_token != address(0)); // dev: _token address should not be zero\n```\n\n16. File: src/StakedCitadel.sol (line [181](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/StakedCitadel.sol#L181))\n\n```solidity\n        require(_governance != address(0)); // dev: _governance address should not be zero\n```\n\n17. File: src/StakedCitadel.sol (line [182](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/StakedCitadel.sol#L182))\n\n```solidity\n        require(_keeper != address(0)); // dev: _keeper address should not be zero\n```\n\n18. File: src/StakedCitadel.sol (line [183](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/StakedCitadel.sol#L183))\n\n```solidity\n        require(_guardian != address(0)); // dev: _guardian address should not be zero\n```\n\n19. File: src/StakedCitadel.sol (line [184](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/StakedCitadel.sol#L184))\n\n```solidity\n        require(_treasury != address(0)); // dev: _treasury address should not be zero\n```\n\n20. File: src/StakedCitadel.sol (line [185](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/StakedCitadel.sol#L185))\n\n```solidity\n        require(_strategist != address(0)); // dev: _strategist address should not be zero\n```\n\n21. File: src/StakedCitadel.sol (line [186](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/StakedCitadel.sol#L186))\n\n```solidity\n        require(_badgerTree != address(0)); // dev: _badgerTree address should not be zero\n```\n\n22. File: src/StakedCitadel.sol (line [187](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/StakedCitadel.sol#L187))\n\n```solidity\n        require(_vesting != address(0)); // dev: _vesting address should not be zero\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-badger-citadel",
  "Code": [
    {
      "filename": "contracts/MedianOracle.sol",
      "content": "pragma solidity 0.4.24;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./lib/Select.sol\";\n\n\ninterface IOracle {\n    function getData() external returns (uint256, bool);\n}\n\n\n/**\n * @title Median Oracle\n *\n * @notice Provides a value onchain that's aggregated from a whitelisted set of\n *         providers.\n */\ncontract MedianOracle is Ownable, IOracle {\n    using SafeMath for uint256;\n\n    struct Report {\n        uint256 timestamp;\n        uint256 payload;\n    }\n\n    // Addresses of providers authorized to push reports.\n    address[] public providers;\n\n    // Reports indexed by provider address. Report[0].timestamp > 0\n    // indicates provider existence.\n    mapping (address => Report[2]) public providerReports;\n\n    event ProviderAdded(address provider);\n    event ProviderRemoved(address provider);\n    event ReportTimestampOutOfRange(address provider);\n    event ProviderReportPushed(address indexed provider, uint256 payload, uint256 timestamp);\n\n    // The number of seconds after which the report is deemed expired.\n    uint256 public reportExpirationTimeSec;\n\n    // The number of seconds since reporting that has to pass before a report\n    // is usable.\n    uint256 public reportDelaySec;\n\n    // The minimum number of providers with valid reports to consider the\n    // aggregate report valid.\n    uint256 public minimumProviders = 1;\n\n    // Timestamp of 1 is used to mark uninitialized and invalidated data.\n    // This is needed so that timestamp of 1 is always considered expired.\n    uint256 private constant MAX_REPORT_EXPIRATION_TIME = 520 weeks;\n\n    /**\n    * @param reportExpirationTimeSec_ The number of seconds after which the\n    *                                 report is deemed expired.\n    * @param reportDelaySec_ The number of seconds since reporting that has to\n    *                        pass before a report is usable\n    * @param minimumProviders_ The minimum number of providers with valid\n    *                          reports to consider the aggregate report valid.\n    */\n    constructor(uint256 reportExpirationTimeSec_,\n                uint256 reportDelaySec_,\n                uint256 minimumProviders_)\n        public\n    {\n        require(reportExpirationTimeSec_ <= MAX_REPORT_EXPIRATION_TIME);\n        require(minimumProviders_ > 0);\n        reportExpirationTimeSec = reportExpirationTimeSec_;\n        reportDelaySec = reportDelaySec_;\n        minimumProviders = minimumProviders_;\n    }\n\n     /**\n     * @notice Sets the report expiration period.\n     * @param reportExpirationTimeSec_ The number of seconds after which the\n     *        report is deemed expired.\n     */\n    function setReportExpirationTimeSec(uint256 reportExpirationTimeSec_)\n        external\n        onlyOwner\n    {\n        require(reportExpirationTimeSec_ <= MAX_REPORT_EXPIRATION_TIME);\n        reportExpirationTimeSec = reportExpirationTimeSec_;\n    }\n\n    /**\n    * @notice Sets the time period since reporting that has to pass before a\n    *         report is usable.\n    * @param reportDelaySec_ The new delay period in seconds.\n    */\n    function setReportDelaySec(uint256 reportDelaySec_)\n        external\n        onlyOwner\n    {\n        reportDelaySec = reportDelaySec_;\n    }\n\n    /**\n    * @notice Sets the minimum number of providers with valid reports to\n    *         consider the aggregate report valid.\n    * @param minimumProviders_ The new minimum number of providers.\n    */\n    function setMinimumProviders(uint256 minimumProviders_)\n        external\n        onlyOwner\n    {\n        require(minimumProviders_ > 0);\n        minimumProviders = minimumProviders_;\n    }\n\n    /**\n     * @notice Pushes a report for the calling provider.\n     * @param payload is expected to be 18 decimal fixed point number.\n     */\n    function pushReport(uint256 payload) external\n    {\n        address providerAddress = msg.sender;\n        Report[2] storage reports = providerReports[providerAddress];\n        uint256[2] memory timestamps = [reports[0].timestamp, reports[1].timestamp];\n\n        require(timestamps[0] > 0);\n\n        uint8 index_recent = timestamps[0] >= timestamps[1] ? 0 : 1;\n        uint8 index_past = 1 - index_recent;\n\n        // Check that the push is not too soon after the last one.\n        require(timestamps[index_recent].add(reportDelaySec) <= now);\n\n        reports[index_past].timestamp = now;\n        reports[index_past].payload = payload;\n\n        emit ProviderReportPushed(providerAddress, payload, now);\n    }\n\n    /**\n    * @notice Invalidates the reports of the calling provider.\n    */\n    function purgeReports() external\n    {\n        address providerAddress = msg.sender;\n        require (providerReports[providerAddress][0].timestamp > 0);\n        providerReports[providerAddress][0].timestamp=1;\n        providerReports[providerAddress][1].timestamp=1;\n    }\n\n    /**\n    * @notice Computes median of provider reports whose timestamps are in the\n    *         valid timestamp range.\n    * @return AggregatedValue: Median of providers reported values.\n    *         valid: Boolean indicating an aggregated value was computed successfully.\n    */\n    function getData()\n        external\n        returns (uint256, bool)\n    {\n        uint256 reportsCount = providers.length;\n        uint256[] memory validReports = new uint256[](reportsCount);\n        uint256 size = 0;\n        uint256 minValidTimestamp =  now.sub(reportExpirationTimeSec);\n        uint256 maxValidTimestamp =  now.sub(reportDelaySec);\n\n        for (uint256 i = 0; i < reportsCount; i++) {\n            address providerAddress = providers[i];\n            Report[2] memory reports = providerReports[providerAddress];\n\n            uint8 index_recent = reports[0].timestamp >= reports[1].timestamp ? 0 : 1;\n            uint8 index_past = 1 - index_recent;\n            uint256 reportTimestampRecent = reports[index_recent].timestamp;\n            if (reportTimestampRecent > maxValidTimestamp) {\n                // Recent report is too recent.\n                uint256 reportTimestampPast = providerReports[providerAddress][index_past].timestamp;\n                if (reportTimestampPast < minValidTimestamp) {\n                    // Past report is too old.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else if (reportTimestampPast > maxValidTimestamp) {\n                    // Past report is too recent.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else {\n                    // Using past report.\n                    validReports[size++] = providerReports[providerAddress][index_past].payload;\n                }\n            } else {\n                // Recent report is not too recent.\n                if (reportTimestampRecent < minValidTimestamp) {\n                    // Recent report is too old.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else {\n                    // Using recent report.\n                    validReports[size++] = providerReports[providerAddress][index_recent].payload;\n                }\n            }\n        }\n\n        if (size < minimumProviders) {\n            return (0, false);\n        }\n\n        return (Select.computeMedian(validReports, size), true);\n    }\n\n    /**\n     * @notice Authorizes a provider.\n     * @param provider Address of the provider.\n     */\n    function addProvider(address provider)\n        external\n        onlyOwner\n    {\n        require(providerReports[provider][0].timestamp == 0);\n        providers.push(provider);\n        providerReports[provider][0].timestamp = 1;\n        emit ProviderAdded(provider);\n    }\n\n    /**\n     * @notice Revokes provider authorization.\n     * @param provider Address of the provider.\n     */\n    function removeProvider(address provider)\n        external\n        onlyOwner\n    {\n        delete providerReports[provider];\n        for (uint256 i = 0; i < providers.length; i++) {\n            if (providers[i] == provider) {\n                if (i + 1  != providers.length) {\n                    providers[i] = providers[providers.length-1];\n                }\n                providers.length--;\n                emit ProviderRemoved(provider);\n                break;\n            }\n        }\n    }\n\n    /**\n     * @return The number of authorized providers.\n     */\n    function providersSize()\n        external\n        view\n        returns (uint256)\n    {\n        return providers.length;\n    }\n}"
    },
    {
      "filename": "contracts/MedianOracle.sol",
      "content": "pragma solidity 0.4.24;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./lib/Select.sol\";\n\n\ninterface IOracle {\n    function getData() external returns (uint256, bool);\n}\n\n\n/**\n * @title Median Oracle\n *\n * @notice Provides a value onchain that's aggregated from a whitelisted set of\n *         providers.\n */\ncontract MedianOracle is Ownable, IOracle {\n    using SafeMath for uint256;\n\n    struct Report {\n        uint256 timestamp;\n        uint256 payload;\n    }\n\n    // Addresses of providers authorized to push reports.\n    address[] public providers;\n\n    // Reports indexed by provider address. Report[0].timestamp > 0\n    // indicates provider existence.\n    mapping (address => Report[2]) public providerReports;\n\n    event ProviderAdded(address provider);\n    event ProviderRemoved(address provider);\n    event ReportTimestampOutOfRange(address provider);\n    event ProviderReportPushed(address indexed provider, uint256 payload, uint256 timestamp);\n\n    // The number of seconds after which the report is deemed expired.\n    uint256 public reportExpirationTimeSec;\n\n    // The number of seconds since reporting that has to pass before a report\n    // is usable.\n    uint256 public reportDelaySec;\n\n    // The minimum number of providers with valid reports to consider the\n    // aggregate report valid.\n    uint256 public minimumProviders = 1;\n\n    // Timestamp of 1 is used to mark uninitialized and invalidated data.\n    // This is needed so that timestamp of 1 is always considered expired.\n    uint256 private constant MAX_REPORT_EXPIRATION_TIME = 520 weeks;\n\n    /**\n    * @param reportExpirationTimeSec_ The number of seconds after which the\n    *                                 report is deemed expired.\n    * @param reportDelaySec_ The number of seconds since reporting that has to\n    *                        pass before a report is usable\n    * @param minimumProviders_ The minimum number of providers with valid\n    *                          reports to consider the aggregate report valid.\n    */\n    constructor(uint256 reportExpirationTimeSec_,\n                uint256 reportDelaySec_,\n                uint256 minimumProviders_)\n        public\n    {\n        require(reportExpirationTimeSec_ <= MAX_REPORT_EXPIRATION_TIME);\n        require(minimumProviders_ > 0);\n        reportExpirationTimeSec = reportExpirationTimeSec_;\n        reportDelaySec = reportDelaySec_;\n        minimumProviders = minimumProviders_;\n    }\n\n     /**\n     * @notice Sets the report expiration period.\n     * @param reportExpirationTimeSec_ The number of seconds after which the\n     *        report is deemed expired.\n     */\n    function setReportExpirationTimeSec(uint256 reportExpirationTimeSec_)\n        external\n        onlyOwner\n    {\n        require(reportExpirationTimeSec_ <= MAX_REPORT_EXPIRATION_TIME);\n        reportExpirationTimeSec = reportExpirationTimeSec_;\n    }\n\n    /**\n    * @notice Sets the time period since reporting that has to pass before a\n    *         report is usable.\n    * @param reportDelaySec_ The new delay period in seconds.\n    */\n    function setReportDelaySec(uint256 reportDelaySec_)\n        external\n        onlyOwner\n    {\n        reportDelaySec = reportDelaySec_;\n    }\n\n    /**\n    * @notice Sets the minimum number of providers with valid reports to\n    *         consider the aggregate report valid.\n    * @param minimumProviders_ The new minimum number of providers.\n    */\n    function setMinimumProviders(uint256 minimumProviders_)\n        external\n        onlyOwner\n    {\n        require(minimumProviders_ > 0);\n        minimumProviders = minimumProviders_;\n    }\n\n    /**\n     * @notice Pushes a report for the calling provider.\n     * @param payload is expected to be 18 decimal fixed point number.\n     */\n    function pushReport(uint256 payload) external\n    {\n        address providerAddress = msg.sender;\n        Report[2] storage reports = providerReports[providerAddress];\n        uint256[2] memory timestamps = [reports[0].timestamp, reports[1].timestamp];\n\n        require(timestamps[0] > 0);\n\n        uint8 index_recent = timestamps[0] >= timestamps[1] ? 0 : 1;\n        uint8 index_past = 1 - index_recent;\n\n        // Check that the push is not too soon after the last one.\n        require(timestamps[index_recent].add(reportDelaySec) <= now);\n\n        reports[index_past].timestamp = now;\n        reports[index_past].payload = payload;\n\n        emit ProviderReportPushed(providerAddress, payload, now);\n    }\n\n    /**\n    * @notice Invalidates the reports of the calling provider.\n    */\n    function purgeReports() external\n    {\n        address providerAddress = msg.sender;\n        require (providerReports[providerAddress][0].timestamp > 0);\n        providerReports[providerAddress][0].timestamp=1;\n        providerReports[providerAddress][1].timestamp=1;\n    }\n\n    /**\n    * @notice Computes median of provider reports whose timestamps are in the\n    *         valid timestamp range.\n    * @return AggregatedValue: Median of providers reported values.\n    *         valid: Boolean indicating an aggregated value was computed successfully.\n    */\n    function getData()\n        external\n        returns (uint256, bool)\n    {\n        uint256 reportsCount = providers.length;\n        uint256[] memory validReports = new uint256[](reportsCount);\n        uint256 size = 0;\n        uint256 minValidTimestamp =  now.sub(reportExpirationTimeSec);\n        uint256 maxValidTimestamp =  now.sub(reportDelaySec);\n\n        for (uint256 i = 0; i < reportsCount; i++) {\n            address providerAddress = providers[i];\n            Report[2] memory reports = providerReports[providerAddress];\n\n            uint8 index_recent = reports[0].timestamp >= reports[1].timestamp ? 0 : 1;\n            uint8 index_past = 1 - index_recent;\n            uint256 reportTimestampRecent = reports[index_recent].timestamp;\n            if (reportTimestampRecent > maxValidTimestamp) {\n                // Recent report is too recent.\n                uint256 reportTimestampPast = providerReports[providerAddress][index_past].timestamp;\n                if (reportTimestampPast < minValidTimestamp) {\n                    // Past report is too old.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else if (reportTimestampPast > maxValidTimestamp) {\n                    // Past report is too recent.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else {\n                    // Using past report.\n                    validReports[size++] = providerReports[providerAddress][index_past].payload;\n                }\n            } else {\n                // Recent report is not too recent.\n                if (reportTimestampRecent < minValidTimestamp) {\n                    // Recent report is too old.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else {\n                    // Using recent report.\n                    validReports[size++] = providerReports[providerAddress][index_recent].payload;\n                }\n            }\n        }\n\n        if (size < minimumProviders) {\n            return (0, false);\n        }\n\n        return (Select.computeMedian(validReports, size), true);\n    }\n\n    /**\n     * @notice Authorizes a provider.\n     * @param provider Address of the provider.\n     */\n    function addProvider(address provider)\n        external\n        onlyOwner\n    {\n        require(providerReports[provider][0].timestamp == 0);\n        providers.push(provider);\n        providerReports[provider][0].timestamp = 1;\n        emit ProviderAdded(provider);\n    }\n\n    /**\n     * @notice Revokes provider authorization.\n     * @param provider Address of the provider.\n     */\n    function removeProvider(address provider)\n        external\n        onlyOwner\n    {\n        delete providerReports[provider];\n        for (uint256 i = 0; i < providers.length; i++) {\n            if (providers[i] == provider) {\n                if (i + 1  != providers.length) {\n                    providers[i] = providers[providers.length-1];\n                }\n                providers.length--;\n                emit ProviderRemoved(provider);\n                break;\n            }\n        }\n    }\n\n    /**\n     * @return The number of authorized providers.\n     */\n    function providersSize()\n        external\n        view\n        returns (uint256)\n    {\n        return providers.length;\n    }\n}"
    },
    {
      "filename": "contracts/MedianOracle.sol",
      "content": "pragma solidity 0.4.24;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./lib/Select.sol\";\n\n\ninterface IOracle {\n    function getData() external returns (uint256, bool);\n}\n\n\n/**\n * @title Median Oracle\n *\n * @notice Provides a value onchain that's aggregated from a whitelisted set of\n *         providers.\n */\ncontract MedianOracle is Ownable, IOracle {\n    using SafeMath for uint256;\n\n    struct Report {\n        uint256 timestamp;\n        uint256 payload;\n    }\n\n    // Addresses of providers authorized to push reports.\n    address[] public providers;\n\n    // Reports indexed by provider address. Report[0].timestamp > 0\n    // indicates provider existence.\n    mapping (address => Report[2]) public providerReports;\n\n    event ProviderAdded(address provider);\n    event ProviderRemoved(address provider);\n    event ReportTimestampOutOfRange(address provider);\n    event ProviderReportPushed(address indexed provider, uint256 payload, uint256 timestamp);\n\n    // The number of seconds after which the report is deemed expired.\n    uint256 public reportExpirationTimeSec;\n\n    // The number of seconds since reporting that has to pass before a report\n    // is usable.\n    uint256 public reportDelaySec;\n\n    // The minimum number of providers with valid reports to consider the\n    // aggregate report valid.\n    uint256 public minimumProviders = 1;\n\n    // Timestamp of 1 is used to mark uninitialized and invalidated data.\n    // This is needed so that timestamp of 1 is always considered expired.\n    uint256 private constant MAX_REPORT_EXPIRATION_TIME = 520 weeks;\n\n    /**\n    * @param reportExpirationTimeSec_ The number of seconds after which the\n    *                                 report is deemed expired.\n    * @param reportDelaySec_ The number of seconds since reporting that has to\n    *                        pass before a report is usable\n    * @param minimumProviders_ The minimum number of providers with valid\n    *                          reports to consider the aggregate report valid.\n    */\n    constructor(uint256 reportExpirationTimeSec_,\n                uint256 reportDelaySec_,\n                uint256 minimumProviders_)\n        public\n    {\n        require(reportExpirationTimeSec_ <= MAX_REPORT_EXPIRATION_TIME);\n        require(minimumProviders_ > 0);\n        reportExpirationTimeSec = reportExpirationTimeSec_;\n        reportDelaySec = reportDelaySec_;\n        minimumProviders = minimumProviders_;\n    }\n\n     /**\n     * @notice Sets the report expiration period.\n     * @param reportExpirationTimeSec_ The number of seconds after which the\n     *        report is deemed expired.\n     */\n    function setReportExpirationTimeSec(uint256 reportExpirationTimeSec_)\n        external\n        onlyOwner\n    {\n        require(reportExpirationTimeSec_ <= MAX_REPORT_EXPIRATION_TIME);\n        reportExpirationTimeSec = reportExpirationTimeSec_;\n    }\n\n    /**\n    * @notice Sets the time period since reporting that has to pass before a\n    *         report is usable.\n    * @param reportDelaySec_ The new delay period in seconds.\n    */\n    function setReportDelaySec(uint256 reportDelaySec_)\n        external\n        onlyOwner\n    {\n        reportDelaySec = reportDelaySec_;\n    }\n\n    /**\n    * @notice Sets the minimum number of providers with valid reports to\n    *         consider the aggregate report valid.\n    * @param minimumProviders_ The new minimum number of providers.\n    */\n    function setMinimumProviders(uint256 minimumProviders_)\n        external\n        onlyOwner\n    {\n        require(minimumProviders_ > 0);\n        minimumProviders = minimumProviders_;\n    }\n\n    /**\n     * @notice Pushes a report for the calling provider.\n     * @param payload is expected to be 18 decimal fixed point number.\n     */\n    function pushReport(uint256 payload) external\n    {\n        address providerAddress = msg.sender;\n        Report[2] storage reports = providerReports[providerAddress];\n        uint256[2] memory timestamps = [reports[0].timestamp, reports[1].timestamp];\n\n        require(timestamps[0] > 0);\n\n        uint8 index_recent = timestamps[0] >= timestamps[1] ? 0 : 1;\n        uint8 index_past = 1 - index_recent;\n\n        // Check that the push is not too soon after the last one.\n        require(timestamps[index_recent].add(reportDelaySec) <= now);\n\n        reports[index_past].timestamp = now;\n        reports[index_past].payload = payload;\n\n        emit ProviderReportPushed(providerAddress, payload, now);\n    }\n\n    /**\n    * @notice Invalidates the reports of the calling provider.\n    */\n    function purgeReports() external\n    {\n        address providerAddress = msg.sender;\n        require (providerReports[providerAddress][0].timestamp > 0);\n        providerReports[providerAddress][0].timestamp=1;\n        providerReports[providerAddress][1].timestamp=1;\n    }\n\n    /**\n    * @notice Computes median of provider reports whose timestamps are in the\n    *         valid timestamp range.\n    * @return AggregatedValue: Median of providers reported values.\n    *         valid: Boolean indicating an aggregated value was computed successfully.\n    */\n    function getData()\n        external\n        returns (uint256, bool)\n    {\n        uint256 reportsCount = providers.length;\n        uint256[] memory validReports = new uint256[](reportsCount);\n        uint256 size = 0;\n        uint256 minValidTimestamp =  now.sub(reportExpirationTimeSec);\n        uint256 maxValidTimestamp =  now.sub(reportDelaySec);\n\n        for (uint256 i = 0; i < reportsCount; i++) {\n            address providerAddress = providers[i];\n            Report[2] memory reports = providerReports[providerAddress];\n\n            uint8 index_recent = reports[0].timestamp >= reports[1].timestamp ? 0 : 1;\n            uint8 index_past = 1 - index_recent;\n            uint256 reportTimestampRecent = reports[index_recent].timestamp;\n            if (reportTimestampRecent > maxValidTimestamp) {\n                // Recent report is too recent.\n                uint256 reportTimestampPast = providerReports[providerAddress][index_past].timestamp;\n                if (reportTimestampPast < minValidTimestamp) {\n                    // Past report is too old.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else if (reportTimestampPast > maxValidTimestamp) {\n                    // Past report is too recent.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else {\n                    // Using past report.\n                    validReports[size++] = providerReports[providerAddress][index_past].payload;\n                }\n            } else {\n                // Recent report is not too recent.\n                if (reportTimestampRecent < minValidTimestamp) {\n                    // Recent report is too old.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else {\n                    // Using recent report.\n                    validReports[size++] = providerReports[providerAddress][index_recent].payload;\n                }\n            }\n        }\n\n        if (size < minimumProviders) {\n            return (0, false);\n        }\n\n        return (Select.computeMedian(validReports, size), true);\n    }\n\n    /**\n     * @notice Authorizes a provider.\n     * @param provider Address of the provider.\n     */\n    function addProvider(address provider)\n        external\n        onlyOwner\n    {\n        require(providerReports[provider][0].timestamp == 0);\n        providers.push(provider);\n        providerReports[provider][0].timestamp = 1;\n        emit ProviderAdded(provider);\n    }\n\n    /**\n     * @notice Revokes provider authorization.\n     * @param provider Address of the provider.\n     */\n    function removeProvider(address provider)\n        external\n        onlyOwner\n    {\n        delete providerReports[provider];\n        for (uint256 i = 0; i < providers.length; i++) {\n            if (providers[i] == provider) {\n                if (i + 1  != providers.length) {\n                    providers[i] = providers[providers.length-1];\n                }\n                providers.length--;\n                emit ProviderRemoved(provider);\n                break;\n            }\n        }\n    }\n\n    /**\n     * @return The number of authorized providers.\n     */\n    function providersSize()\n        external\n        view\n        returns (uint256)\n    {\n        return providers.length;\n    }\n}"
    },
    {
      "filename": "contracts/MedianOracle.sol",
      "content": "pragma solidity 0.4.24;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./lib/Select.sol\";\n\n\ninterface IOracle {\n    function getData() external returns (uint256, bool);\n}\n\n\n/**\n * @title Median Oracle\n *\n * @notice Provides a value onchain that's aggregated from a whitelisted set of\n *         providers.\n */\ncontract MedianOracle is Ownable, IOracle {\n    using SafeMath for uint256;\n\n    struct Report {\n        uint256 timestamp;\n        uint256 payload;\n    }\n\n    // Addresses of providers authorized to push reports.\n    address[] public providers;\n\n    // Reports indexed by provider address. Report[0].timestamp > 0\n    // indicates provider existence.\n    mapping (address => Report[2]) public providerReports;\n\n    event ProviderAdded(address provider);\n    event ProviderRemoved(address provider);\n    event ReportTimestampOutOfRange(address provider);\n    event ProviderReportPushed(address indexed provider, uint256 payload, uint256 timestamp);\n\n    // The number of seconds after which the report is deemed expired.\n    uint256 public reportExpirationTimeSec;\n\n    // The number of seconds since reporting that has to pass before a report\n    // is usable.\n    uint256 public reportDelaySec;\n\n    // The minimum number of providers with valid reports to consider the\n    // aggregate report valid.\n    uint256 public minimumProviders = 1;\n\n    // Timestamp of 1 is used to mark uninitialized and invalidated data.\n    // This is needed so that timestamp of 1 is always considered expired.\n    uint256 private constant MAX_REPORT_EXPIRATION_TIME = 520 weeks;\n\n    /**\n    * @param reportExpirationTimeSec_ The number of seconds after which the\n    *                                 report is deemed expired.\n    * @param reportDelaySec_ The number of seconds since reporting that has to\n    *                        pass before a report is usable\n    * @param minimumProviders_ The minimum number of providers with valid\n    *                          reports to consider the aggregate report valid.\n    */\n    constructor(uint256 reportExpirationTimeSec_,\n                uint256 reportDelaySec_,\n                uint256 minimumProviders_)\n        public\n    {\n        require(reportExpirationTimeSec_ <= MAX_REPORT_EXPIRATION_TIME);\n        require(minimumProviders_ > 0);\n        reportExpirationTimeSec = reportExpirationTimeSec_;\n        reportDelaySec = reportDelaySec_;\n        minimumProviders = minimumProviders_;\n    }\n\n     /**\n     * @notice Sets the report expiration period.\n     * @param reportExpirationTimeSec_ The number of seconds after which the\n     *        report is deemed expired.\n     */\n    function setReportExpirationTimeSec(uint256 reportExpirationTimeSec_)\n        external\n        onlyOwner\n    {\n        require(reportExpirationTimeSec_ <= MAX_REPORT_EXPIRATION_TIME);\n        reportExpirationTimeSec = reportExpirationTimeSec_;\n    }\n\n    /**\n    * @notice Sets the time period since reporting that has to pass before a\n    *         report is usable.\n    * @param reportDelaySec_ The new delay period in seconds.\n    */\n    function setReportDelaySec(uint256 reportDelaySec_)\n        external\n        onlyOwner\n    {\n        reportDelaySec = reportDelaySec_;\n    }\n\n    /**\n    * @notice Sets the minimum number of providers with valid reports to\n    *         consider the aggregate report valid.\n    * @param minimumProviders_ The new minimum number of providers.\n    */\n    function setMinimumProviders(uint256 minimumProviders_)\n        external\n        onlyOwner\n    {\n        require(minimumProviders_ > 0);\n        minimumProviders = minimumProviders_;\n    }\n\n    /**\n     * @notice Pushes a report for the calling provider.\n     * @param payload is expected to be 18 decimal fixed point number.\n     */\n    function pushReport(uint256 payload) external\n    {\n        address providerAddress = msg.sender;\n        Report[2] storage reports = providerReports[providerAddress];\n        uint256[2] memory timestamps = [reports[0].timestamp, reports[1].timestamp];\n\n        require(timestamps[0] > 0);\n\n        uint8 index_recent = timestamps[0] >= timestamps[1] ? 0 : 1;\n        uint8 index_past = 1 - index_recent;\n\n        // Check that the push is not too soon after the last one.\n        require(timestamps[index_recent].add(reportDelaySec) <= now);\n\n        reports[index_past].timestamp = now;\n        reports[index_past].payload = payload;\n\n        emit ProviderReportPushed(providerAddress, payload, now);\n    }\n\n    /**\n    * @notice Invalidates the reports of the calling provider.\n    */\n    function purgeReports() external\n    {\n        address providerAddress = msg.sender;\n        require (providerReports[providerAddress][0].timestamp > 0);\n        providerReports[providerAddress][0].timestamp=1;\n        providerReports[providerAddress][1].timestamp=1;\n    }\n\n    /**\n    * @notice Computes median of provider reports whose timestamps are in the\n    *         valid timestamp range.\n    * @return AggregatedValue: Median of providers reported values.\n    *         valid: Boolean indicating an aggregated value was computed successfully.\n    */\n    function getData()\n        external\n        returns (uint256, bool)\n    {\n        uint256 reportsCount = providers.length;\n        uint256[] memory validReports = new uint256[](reportsCount);\n        uint256 size = 0;\n        uint256 minValidTimestamp =  now.sub(reportExpirationTimeSec);\n        uint256 maxValidTimestamp =  now.sub(reportDelaySec);\n\n        for (uint256 i = 0; i < reportsCount; i++) {\n            address providerAddress = providers[i];\n            Report[2] memory reports = providerReports[providerAddress];\n\n            uint8 index_recent = reports[0].timestamp >= reports[1].timestamp ? 0 : 1;\n            uint8 index_past = 1 - index_recent;\n            uint256 reportTimestampRecent = reports[index_recent].timestamp;\n            if (reportTimestampRecent > maxValidTimestamp) {\n                // Recent report is too recent.\n                uint256 reportTimestampPast = providerReports[providerAddress][index_past].timestamp;\n                if (reportTimestampPast < minValidTimestamp) {\n                    // Past report is too old.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else if (reportTimestampPast > maxValidTimestamp) {\n                    // Past report is too recent.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else {\n                    // Using past report.\n                    validReports[size++] = providerReports[providerAddress][index_past].payload;\n                }\n            } else {\n                // Recent report is not too recent.\n                if (reportTimestampRecent < minValidTimestamp) {\n                    // Recent report is too old.\n                    emit ReportTimestampOutOfRange(providerAddress);\n                } else {\n                    // Using recent report."
    }
  ]
}