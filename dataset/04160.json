{
  "Title": "[H02][Fixed] Protocol could become insolvent due to market’s natural movements",
  "Content": "The Protocol uses 2 time-based prices to value all the actions related to assets: live and expired prices.\n\n\nThe [live prices](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/MarginCalculator.sol#L361) are used by the [`getExcessCollateral` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/MarginCalculator.sol#L74) from the `MarginCalculator` contract to calculate the margin of a vault [before](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/MarginCalculator.sol#L157) the oToken expires. After the oToken expires, the [expired price](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/MarginCalculator.sol#L196) is then used to calculate the vault margin.\n\n\nBecause the [collateral asset](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L29) may not be the same as the [strike asset](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L26) or the [underlying asset](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L23), it is not guaranteed that the collateral’s expiration price will be higher than its price in any point in the past, when the oToken has not expired yet, resulting in a possible undercollateralized situation for vaults.\n\n\nEven though collateral assets must be whitelisted to be able to be used in the platform, with the caveat described in the issue ***oToken can be created with a non-whitelisted collateral asset***, assets such as cTokens from Compound that are supposed to gain value over time may suffer a drop in their values due to [market fluctuations or events as the one in early 2020](https://cointelegraph.com/news/maker-debt-crisis-post-mortem-recommends-new-safeguards), which produced a drop in value for cDai token. When the value of all collateral is worth less than the value of all borrowed assets, we say a market is insolvent. In case the platform allows the usage of non-monotonically-increasing price assets, the insolvency may be caused by a simple market price fluctuation.\n\n\nHere are other examples of things that could cause a market to become insolvent:\n\n\n* The price of the underlying (or borrowed) asset makes a big, quick move during a time of high network congestion.\n* The price oracle temporarily goes offline during a time of high market volatility. This could result in the oracle not updating the asset prices until after the market has become insolvent.\n* The admin or oracle steals enough collateral that the market becomes insolvent.\n* Administrators list an ERC20 token with a later-discovered bug that allows minting of arbitrarily many tokens. This bad token is used as collateral to borrow funds that it never intends to repay.\n\n\nIn any case, the effects of an insolvent market could be disastrous. It may result in a “run on the bank” situation, with the last suppliers out losing their money. It is important to know that this risk does exist and it can be difficult to recover from even a small dip into insolvency.\n\n\nAlthough the [`AddressBook` contract includes a slot for a liquidator manager](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/AddressBook.sol#L27), the system currently does not have any liquidation process, any vault is susceptible to becoming insolvent during the payout of the options right after expiration.\n\n\nConsider adding a liquidation process to prevent insolvent vaults, carefully selecting the whitelisted assets for the protocol, adding more test units, and running a testnet version to understand how other assets may cause an undercollateralized scenario.\n\n\n**Update:** *Fixed in [PR355](https://github.com/opynfinance/GammaProtocol/pull/355), the Opyn team restricted all oTokens issued on the protocol to be collateralized with the exact payout asset depending on the oToken type(strike asset for PUT options and underlying asset for CALL options). Although this update restricted what Options the Opyn protocol can issue, it eliminated the risk of protocol become insolvent. We suggest a liquidation component to be ready in the future should the Opyn Team decide to remove PR 355 restriction, and get it thoroughly audited.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/MarginCalculator.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {OtokenInterface} from \"./interfaces/OtokenInterface.sol\";\nimport {OracleInterface} from \"./interfaces/OracleInterface.sol\";\nimport {ERC20Interface} from \"./interfaces/ERC20Interface.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\nimport {FixedPointInt256 as FPI} from \"./libs/FixedPointInt256.sol\";\nimport {MarginVault} from \"./libs/MarginVault.sol\";\n\n/**\n * @title MarginCalculator\n * @author Opyn\n * @notice Calculator module that checks if a given vault is valid, calculates margin requirements, and settlement proceeds\n */\ncontract MarginCalculator {\n    using SafeMath for uint256;\n    using FPI for FPI.FixedPointInt;\n\n    address public addressBook;\n\n    uint256 internal constant BASE = 8;\n    FPI.FixedPointInt internal ZERO = FPI.fromScaledUint(0, BASE);\n\n    constructor(address _addressBook) public {\n        require(_addressBook != address(0), \"MarginCalculator: invalid addressbook\");\n\n        addressBook = _addressBook;\n    }\n\n    /**\n     * @notice return the cash value of an expired oToken, denominated in collateral\n     * @param _otoken oToken address\n     * @return how much collateral can be taken out by 1 otoken unit, scaled by 1e8,\n     * or how much collateral can be taken out for 1 (1e8) oToken\n     */\n    function getExpiredPayoutRate(address _otoken) external view returns (uint256) {\n        require(_otoken != address(0), \"MarginCalculator: Invalid token address\");\n        OtokenInterface otoken = OtokenInterface(_otoken);\n        require(now > otoken.expiryTimestamp(), \"MarginCalculator: Otoken not expired yet\");\n\n        FPI.FixedPointInt memory cashValueInStrike = _getExpiredCashValue(_otoken);\n\n        address strike = otoken.strikeAsset();\n        address collateral = otoken.collateralAsset();\n\n        uint256 expiry = otoken.expiryTimestamp();\n\n        FPI.FixedPointInt memory cashValueInCollateral = _convertAmountOnExpiryPrice(\n            cashValueInStrike,\n            strike,\n            collateral,\n            expiry\n        );\n\n        // the exchangeRate was scaled by 1e8, if 1e8 otoken can take out 1 USDC, the exchangeRate is currently 1e8\n        // we want to return: how much USDC units can be taken out by 1 (1e8 units) oToken\n        uint256 collateralDecimals = uint256(ERC20Interface(collateral).decimals());\n        return cashValueInCollateral.toScaledUint(collateralDecimals, true);\n    }\n\n    /**\n     * @notice returns the amount of collateral that can be removed from an actual or a theoretical vault\n     * @dev return amount is denominated in the collateral asset for the oToken in the vault, or the collateral asset in the vault\n     * @param _vault theoretical vault that needs to be checked\n     * @return excessCollateral the amount by which the margin is above or below the required amount\n     * @return isExcess True if there is excess margin in the vault, False if there is a deficit of margin in the vault\n     * if True, collateral can be taken out from the vault, if False, additional collateral needs to be added to vault\n     */\n    function getExcessCollateral(MarginVault.Vault memory _vault) public view returns (uint256, bool) {\n        // include all the checks for to ensure the vault is valid\n        _checkIsValidVault(_vault);\n\n        bool hasCollateral = _isNotEmpty(_vault.collateralAssets);\n        bool hasShort = _isNotEmpty(_vault.shortOtokens);\n        bool hasLong = _isNotEmpty(_vault.longOtokens);\n\n        // if the vault contains no oTokens, return the amount of collateral\n        if (!hasShort && !hasLong) {\n            uint256 amount = hasCollateral ? _vault.collateralAmounts[0] : 0;\n            return (amount, true);\n        }\n\n        FPI.FixedPointInt memory collateralAmount = ZERO;\n        if (hasCollateral) {\n            uint256 colllateralDecimals = ERC20Interface(_vault.collateralAssets[0]).decimals();\n            collateralAmount = FPI.fromScaledUint(_vault.collateralAmounts[0], colllateralDecimals);\n        }\n\n        // get required margin, denominated in collateral\n        FPI.FixedPointInt memory collateralRequired = _getMarginRequired(_vault);\n        FPI.FixedPointInt memory excessCollateral = collateralAmount.sub(collateralRequired);\n\n        bool isExcess = excessCollateral.isGreaterThanOrEqual(ZERO);\n\n        address otoken = hasLong ? _vault.longOtokens[0] : _vault.shortOtokens[0];\n        uint256 collateralDecimals = ERC20Interface(OtokenInterface(otoken).collateralAsset()).decimals();\n        // if is excess, truncate the tailing digits in excessCollateralExternal calculation\n        uint256 excessCollateralExternal = excessCollateral.toScaledUint(collateralDecimals, isExcess);\n        return (excessCollateralExternal, isExcess);\n    }\n\n    /**\n     * @notice return the cash value of an expired oToken, denominated in strike asset\n     * @dev for a call, return Max (0, underlyingPriceInStrike - otoken.strikePrice)\n     * @dev for a put, return Max(0, otoken.strikePrice - underlyingPriceInStrike)\n     * @param _otoken oToken address\n     * @return cash value of an expired otoken, denominated in the strike asset\n     */\n    function _getExpiredCashValue(address _otoken) internal view returns (FPI.FixedPointInt memory) {\n        OtokenInterface otoken = OtokenInterface(_otoken);\n\n        // strike price is denominated in strike asset\n        FPI.FixedPointInt memory strikePrice = FPI.fromScaledUint(otoken.strikePrice(), BASE);\n\n        FPI.FixedPointInt memory one = FPI.fromScaledUint(1, 0);\n\n        // calculate the value of the underlying asset in terms of the strike asset\n        FPI.FixedPointInt memory underlyingPriceInStrike = _convertAmountOnExpiryPrice(\n            one, // underlying price denominated in underlying\n            otoken.underlyingAsset(),\n            otoken.strikeAsset(),\n            otoken.expiryTimestamp()\n        );\n\n        if (otoken.isPut()) {\n            return strikePrice.isGreaterThan(underlyingPriceInStrike) ? strikePrice.sub(underlyingPriceInStrike) : ZERO;\n        } else {\n            return underlyingPriceInStrike.isGreaterThan(strikePrice) ? underlyingPriceInStrike.sub(strikePrice) : ZERO;\n        }\n    }\n\n    /**\n     * @notice calculate the amount of collateral needed for a vault\n     * @dev vault passed in has already passed the checkIsValidVault function\n     * @param _vault theoretical vault that needs to be checked\n     * @return marginRequired the minimal amount of collateral needed in a vault, denominated in collateral\n     */\n    function _getMarginRequired(MarginVault.Vault memory _vault) internal view returns (FPI.FixedPointInt memory) {\n        // vault has either long oTokens or short oTokens in it\n        bool hasShort = _isNotEmpty(_vault.shortOtokens);\n        bool hasLong = _isNotEmpty(_vault.longOtokens);\n\n        FPI.FixedPointInt memory shortAmount = hasShort ? FPI.fromScaledUint(_vault.shortAmounts[0], BASE) : ZERO;\n        FPI.FixedPointInt memory longAmount = hasLong ? FPI.fromScaledUint(_vault.longAmounts[0], BASE) : ZERO;\n\n        OtokenInterface otoken = hasShort\n            ? OtokenInterface(_vault.shortOtokens[0])\n            : OtokenInterface(_vault.longOtokens[0]);\n        bool expired = now > otoken.expiryTimestamp();\n        bool isPut = otoken.isPut();\n\n        if (!expired) {\n            FPI.FixedPointInt memory shortStrike = hasShort\n                ? FPI.fromScaledUint(OtokenInterface(_vault.shortOtokens[0]).strikePrice(), BASE)\n                : ZERO;\n            FPI.FixedPointInt memory longStrike = hasLong\n                ? FPI.fromScaledUint(OtokenInterface(_vault.longOtokens[0]).strikePrice(), BASE)\n                : ZERO;\n\n            if (isPut) {\n                FPI.FixedPointInt memory strikeNeeded = _getPutSpreadMarginRequired(\n                    shortAmount,\n                    longAmount,\n                    shortStrike,\n                    longStrike\n                );\n                // convert amount to be denominated in collateral\n                return _convertAmountOnLivePrice(strikeNeeded, otoken.strikeAsset(), otoken.collateralAsset());\n            } else {\n                FPI.FixedPointInt memory underlyingNeeded = _getCallSpreadMarginRequired(\n                    shortAmount,\n                    longAmount,\n                    shortStrike,\n                    longStrike\n                );\n                // convert amount to be denominated in collateral\n                return _convertAmountOnLivePrice(underlyingNeeded, otoken.underlyingAsset(), otoken.collateralAsset());\n            }\n        } else {\n            FPI.FixedPointInt memory shortCashValue = hasShort ? _getExpiredCashValue(_vault.shortOtokens[0]) : ZERO;\n            FPI.FixedPointInt memory longCashValue = hasLong ? _getExpiredCashValue(_vault.longOtokens[0]) : ZERO;\n\n            FPI.FixedPointInt memory valueInStrike = _getExpiredSpreadCashValue(\n                shortAmount,\n                longAmount,\n                shortCashValue,\n                longCashValue\n            );\n            // convert amount to be denominated in collateral\n            return\n                _convertAmountOnExpiryPrice(\n                    valueInStrike,\n                    otoken.strikeAsset(),\n                    otoken.collateralAsset(),\n                    otoken.expiryTimestamp()\n                );\n        }\n    }\n\n    /**\n     * @dev returns the strike asset amount of margin required for a put or put spread with the given short oTokens, long oTokens and amounts\n     *\n     * marginRequired = max( (short amount * short strike) - (long strike * min (short amount, long amount)) , 0 )\n     *\n     * @return margin requirement denominated in the strike asset\n     */\n    function _getPutSpreadMarginRequired(\n        FPI.FixedPointInt memory _shortAmount,\n        FPI.FixedPointInt memory _longAmount,\n        FPI.FixedPointInt memory _shortStrike,\n        FPI.FixedPointInt memory _longStrike\n    ) internal view returns (FPI.FixedPointInt memory) {\n        return FPI.max(_shortAmount.mul(_shortStrike).sub(_longStrike.mul(FPI.min(_shortAmount, _longAmount))), ZERO);\n    }\n\n    /**\n     * @dev returns the underlying asset amount required for a call or call spread with the given short oTokens, long oTokens, and amounts\n     *\n     *                           (long strike - short strike) * short amount\n     * marginRequired =  max( ------------------------------------------------- , max (short amount - long amount, 0) )\n     *                                           long strike\n     *\n     * @dev if long strike = 0, return max( short amount - long amount, 0)\n     * @return margin requirement denominated in the underlying asset\n     */\n    function _getCallSpreadMarginRequired(\n        FPI.FixedPointInt memory _shortAmount,\n        FPI.FixedPointInt memory _longAmount,\n        FPI.FixedPointInt memory _shortStrike,\n        FPI.FixedPointInt memory _longStrike\n    ) internal view returns (FPI.FixedPointInt memory) {\n        // max (short amount - long amount , 0)\n        if (_longStrike.isEqual(ZERO)) {\n            return FPI.max(_shortAmount.sub(_longAmount), ZERO);\n        }\n\n        /**\n         *             (long strike - short strike) * short amount\n         * calculate  ----------------------------------------------\n         *                             long strike\n         */\n        FPI.FixedPointInt memory firstPart = _longStrike.sub(_shortStrike).mul(_shortAmount).div(_longStrike);\n\n        /**\n         * calculate max ( short amount - long amount , 0)\n         */\n        FPI.FixedPointInt memory secondPart = FPI.max(_shortAmount.sub(_longAmount), ZERO);\n\n        return FPI.max(firstPart, secondPart);\n    }\n\n    /**\n     * @dev calculate the cash value obligation for an expired vault, where a positive number is an obligation\n     *\n     * Formula: net = (short cash value * short amount) - ( long cash value * long Amount )\n     *\n     * @return cash value obligation denominated in the strike asset\n     */\n    function _getExpiredSpreadCashValue(\n        FPI.FixedPointInt memory _shortAmount,\n        FPI.FixedPointInt memory _longAmount,\n        FPI.FixedPointInt memory _shortCashValue,\n        FPI.FixedPointInt memory _longCashValue\n    ) internal pure returns (FPI.FixedPointInt memory) {\n        return _shortCashValue.mul(_shortAmount).sub(_longCashValue.mul(_longAmount));\n    }\n\n    /**\n     * @dev ensure that:\n     * a) at most 1 asset type used as collateral\n     * b) at most 1 series of option used as the long option\n     * c) at most 1 series of option used as the short option\n     * d) asset array lengths match for long, short and collateral\n     * e) long option and collateral asset is acceptable for margin with short asset\n     * @param _vault the vault to check\n     */\n    function _checkIsValidVault(MarginVault.Vault memory _vault) internal view {\n        // ensure all the arrays in the vault are valid\n        require(_vault.shortOtokens.length <= 1, \"MarginCalculator: Too many short otokens in the vault\");\n        require(_vault.longOtokens.length <= 1, \"MarginCalculator: Too many long otokens in the vault\");\n        require(_vault.collateralAssets.length <= 1, \"MarginCalculator: Too many collateral assets in the vault\");\n\n        require(\n            _vault.shortOtokens.length == _vault.shortAmounts.length,\n            \"MarginCalculator: Short asset and amount mismatch\"\n        );\n        require(\n            _vault.longOtokens.length == _vault.longAmounts.length,\n            \"MarginCalculator: Long asset and amount mismatch\"\n        );\n        require(\n            _vault.collateralAssets.length == _vault.collateralAmounts.length,\n            \"MarginCalculator: Collateral asset and amount mismatch\"\n        );\n\n        // ensure the long asset is valid for the short asset\n        require(_isMarginableLong(_vault), \"MarginCalculator: long asset not marginable for short asset\");\n\n        // ensure that the collateral asset is valid for the short asset\n        require(_isMarginableCollateral(_vault), \"MarginCalculator: collateral asset not marginable for short asset\");\n    }\n\n    /**\n     * @dev if there is a short option and a long option in the vault, ensure that the long option is able to be used as collateral for the short option\n     * @param _vault the vault to check.\n     */\n    function _isMarginableLong(MarginVault.Vault memory _vault) internal view returns (bool) {\n        bool hasLong = _isNotEmpty(_vault.longOtokens);\n        bool hasShort = _isNotEmpty(_vault.shortOtokens);\n        // if vault is missing a long or a short, return True\n        if (!hasLong || !hasShort) return true;\n\n        OtokenInterface long = OtokenInterface(_vault.longOtokens[0]);\n        OtokenInterface short = OtokenInterface(_vault.shortOtokens[0]);\n\n        return\n            long.underlyingAsset() == short.underlyingAsset() &&\n            long.strikeAsset() == short.strikeAsset() &&\n            long.collateralAsset() == short.collateralAsset() &&\n            long.expiryTimestamp() == short.expiryTimestamp() &&\n            long.isPut() == short.isPut();\n    }\n\n    /**\n     * @dev if there is short option and collateral asset in the vault, ensure that the collateral asset is valid for the short option\n     * @param _vault the vault to check.\n     */\n    function _isMarginableCollateral(MarginVault.Vault memory _vault) internal view returns (bool) {\n        bool isMarginable = true;\n\n        bool hasCollateral = _isNotEmpty(_vault.collateralAssets);\n        if (!hasCollateral) return isMarginable;\n\n        bool hasShort = _isNotEmpty(_vault.shortOtokens);\n        bool hasLong = _isNotEmpty(_vault.longOtokens);\n\n        if (hasShort) {\n            OtokenInterface short = OtokenInterface(_vault.shortOtokens[0]);\n            isMarginable = short.collateralAsset() == _vault.collateralAssets[0];\n        } else if (hasLong) {\n            OtokenInterface long = OtokenInterface(_vault.longOtokens[0]);\n            isMarginable = long.collateralAsset() == _vault.collateralAssets[0];\n        }\n\n        return isMarginable;\n    }\n\n    /**\n     * @notice convert an amount in asset A to equivalent amount of asset B, based on a live price\n     * @dev function includes the amount and applies .mul() first to increase the accuracy\n     * @param _amount amount in asset A\n     * @param _assetA asset A\n     * @param _assetB asset B\n     * @return _amount in asset B\n     */\n    function _convertAmountOnLivePrice(\n        FPI.FixedPointInt memory _amount,\n        address _assetA,\n        address _assetB\n    ) internal view returns (FPI.FixedPointInt memory) {\n        OracleInterface oracle = OracleInterface(AddressBookInterface(addressBook).getOracle());\n        if (_assetA == _assetB) {\n            return _amount;\n        }\n        uint256 priceA = oracle.getPrice(_assetA);\n        uint256 priceB = oracle.getPrice(_assetB);\n        // amount A * price A in USD = amount B * price B in USD\n        // amount B = amount A * price A / price B\n        return _amount.mul(FPI.fromScaledUint(priceA, BASE)).div(FPI.fromScaledUint(priceB, BASE));\n    }\n\n    /**\n     * @notice convert an amount in asset A to equivalent amount of asset B, based on an expiry price\n     * @dev function includes the amount and apply .mul() first to increase the accuracy\n     * @param _amount amount in asset A\n     * @param _assetA asset A\n     * @param _assetB asset B\n     * @return _amount in asset B\n     */\n    function _convertAmountOnExpiryPrice(\n        FPI.FixedPointInt memory _amount,\n        address _assetA,\n        address _assetB,\n        uint256 _expiry\n    ) internal view returns (FPI.FixedPointInt memory) {\n        if (_assetA == _assetB) {\n            return _amount;\n        }\n        OracleInterface oracle = OracleInterface(AddressBookInterface(addressBook).getOracle());\n        (uint256 priceA, bool priceAFinalized) = oracle.getExpiryPrice(_assetA, _expiry);\n        (uint256 priceB, bool priceBFinalized) = oracle.getExpiryPrice(_assetB, _expiry);\n        require(priceAFinalized && priceBFinalized, \"MarginCalculator: price at expiry not finalized yet.\");\n        // amount A * price A in USD = amount B * price B in USD\n        // amount B = amount A * price A / price B\n        return _amount.mul(FPI.fromScaledUint(priceA, BASE)).div(FPI.fromScaledUint(priceB, BASE));\n    }\n\n    /**\n     * @dev check if asset array contain a token address\n     * @return True if the array is not empty\n     */\n    function _isNotEmpty(address[] memory _assets) internal pure returns (bool) {\n        return _assets.length > 0 && _assets[0] != address(0);\n    }\n}"
    },
    {
      "filename": "contracts/Otoken.sol",
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity =0.6.10;\n\nimport {ERC20Initializable} from \"./packages/oz/upgradeability/ERC20Initializable.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {Strings} from \"./packages/oz/Strings.sol\";\nimport {BokkyPooBahsDateTimeLibrary} from \"./packages/BokkyPooBahsDateTimeLibrary.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\n\n/**\n * @title Otoken\n * @author Opyn Team\n * @notice Otoken is the ERC20 token for an option\n * @dev The Otoken inherits ERC20Initializable because we need to use the init instead of constructor\n */\ncontract Otoken is ERC20Initializable {\n    using SafeMath for uint256;\n\n    /// @notice address of the AddressBook module\n    address public addressBook;\n\n    /// @notice asset that the option references\n    address public underlyingAsset;\n\n    /// @notice asset that the strike price is denominated in\n    address public strikeAsset;\n\n    /// @notice asset that is held as collateral against short/written options\n    address public collateralAsset;\n\n    /// @notice strike price with decimals = 8\n    uint256 public strikePrice;\n\n    /// @notice expiration timestamp of the option, represented as a unix timestamp\n    uint256 public expiryTimestamp;\n\n    /// @notice True if a put option, False if a call option\n    bool public isPut;\n\n    uint256 private constant STRIKE_PRICE_SCALE = 1e8;\n    uint256 private constant STRIKE_PRICE_DIGITS = 8;\n\n    /**\n     * @notice initialize the oToken\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 8\n     * @param _expiryTimestamp expiration timestamp of the option, represented as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     */\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTimestamp,\n        bool _isPut\n    ) external initializer {\n        addressBook = _addressBook;\n        underlyingAsset = _underlyingAsset;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n        strikePrice = _strikePrice;\n        expiryTimestamp = _expiryTimestamp;\n        isPut = _isPut;\n        (string memory tokenName, string memory tokenSymbol) = _getNameAndSymbol();\n        __ERC20_init_unchained(tokenName, tokenSymbol);\n        _setupDecimals(8);\n    }\n\n    /**\n     * @notice mint oToken for an account\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to mint token to\n     * @param amount amount to mint\n     */\n    function mintOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"Otoken: Only Controller can mint Otokens\"\n        );\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice burn oToken from an account.\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to burn token from\n     * @param amount amount to burn\n     */\n    function burnOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"Otoken: Only Controller can burn Otokens\"\n        );\n        _burn(account, amount);\n    }\n\n    /**\n     * @notice generates the name and symbol for an option\n     * @dev this function uses a named return variable to avoid the stack-too-deep error\n     * @return tokenName (ex: ETHUSDC 05-September-2020 200 Put USDC Collateral)\n     * @return tokenSymbol (ex: oETHUSDC-05SEP20-200P)\n     */\n    function _getNameAndSymbol() internal view returns (string memory tokenName, string memory tokenSymbol) {\n        string memory underlying = ERC20Initializable(underlyingAsset).symbol();\n        string memory strike = ERC20Initializable(strikeAsset).symbol();\n        string memory collateral = ERC20Initializable(collateralAsset).symbol();\n        string memory displayStrikePrice = _getDisplayedStrikePrice(strikePrice);\n\n        // convert expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(expiryTimestamp);\n\n        // get option type string\n        (string memory typeSymbol, string memory typeFull) = _getOptionType(isPut);\n\n        //get option month string\n        (string memory monthSymbol, string memory monthFull) = _getMonth(month);\n\n        // concatenated name string: ETHUSDC 05-September-2020 200 Put USDC Collateral\n        tokenName = string(\n            abi.encodePacked(\n                underlying,\n                strike,\n                \" \",\n                _uintTo2Chars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                typeFull,\n                \" \",\n                collateral,\n                \" Collateral\"\n            )\n        );\n\n        // concatenated symbol string: oETHUSDC-05SEP20-200P\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"o\",\n                underlying,\n                strike,\n                \"-\",\n                _uintTo2Chars(day),\n                monthSymbol,\n                _uintTo2Chars(year),\n                \"-\",\n                displayStrikePrice,\n                typeSymbol\n            )\n        );\n    }\n\n    /**\n     * @dev convert strike price scaled by 1e8 to human readable number string\n     * @param _strikePrice strike price scaled by 1e8\n     * @return strike price string\n     */\n    function _getDisplayedStrikePrice(uint256 _strikePrice) internal pure returns (string memory) {\n        uint256 remainder = _strikePrice.mod(STRIKE_PRICE_SCALE);\n        uint256 quotient = _strikePrice.div(STRIKE_PRICE_SCALE);\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) return quotientStr;\n\n        uint256 trailingZeroes = 0;\n        while (remainder.mod(10) == 0) {\n            remainder = remainder / 10;\n            trailingZeroes += 1;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory tmpStr = Strings.toString(remainder);\n        tmpStr = _slice(tmpStr, 1, 1 + STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory completeStr = string(abi.encodePacked(quotientStr, \".\", tmpStr));\n        return completeStr;\n    }\n\n    /**\n     * @dev return a representation of a number using 2 characters, adds a leading 0 if one digit, uses two trailing digits if a 3 digit number\n     * @return 2 characters that corresponds to a number\n     */\n    function _uintTo2Chars(uint256 number) internal pure returns (string memory) {\n        if (number > 99) number = number % 100;\n        string memory str = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /**\n     * @dev return string representation of option type\n     * @return shortString a 1 character representation of option type (P or C)\n     * @return longString a full length string of option type (Put or Call)\n     */\n    function _getOptionType(bool _isPut) internal pure returns (string memory shortString, string memory longString) {\n        if (_isPut) {\n            return (\"P\", \"Put\");\n        } else {\n            return (\"C\", \"Call\");\n        }\n    }\n\n    /**\n     * @dev cut string s into s[start:end]\n     * @param _s the string to cut\n     * @param _start the starting index\n     * @param _end the ending index (excluded in the substring)\n     */\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure returns (string memory) {\n        bytes memory a = new bytes(_end - _start);\n        for (uint256 i = 0; i < _end - _start; i++) {\n            a[i] = bytes(_s)[_start + i];\n        }\n        return string(a);\n    }\n\n    /**\n     * @dev return string representation of a month\n     * @return shortString a 3 character representation of a month (ex: SEP, DEC, etc)\n     * @return longString a full length string of a month (ex: September, December, etc)\n     */\n    function _getMonth(uint256 _month) internal pure returns (string memory shortString, string memory longString) {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}"
    },
    {
      "filename": "contracts/AddressBook.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\nimport {Ownable} from \"./packages/oz/Ownable.sol\";\nimport {OwnedUpgradeabilityProxy} from \"./packages/oz/upgradeability/OwnedUpgradeabilityProxy.sol\";\n\n/**\n * @author Opyn Team\n * @title AddressBook Module\n */\ncontract AddressBook is Ownable {\n    /// @dev Otoken implementation key\n    bytes32 private constant OTOKEN_IMPL = \"OTOKEN_IMPL\";\n    /// @dev OtokenFactory key\n    bytes32 private constant OTOKEN_FACTORY = \"OTOKEN_FACTORY\";\n    /// @dev Whitelist key\n    bytes32 private constant WHITELIST = \"WHITELIST\";\n    /// @dev Controller key\n    bytes32 private constant CONTROLLER = \"CONTROLLER\";\n    /// @dev MarginPool key\n    bytes32 private constant MARGIN_POOL = \"MARGIN_POOL\";\n    /// @dev MarginCalculator key\n    bytes32 private constant MARGIN_CALCULATOR = \"MARGIN_CALCULATOR\";\n    /// @dev LiquidationManager key\n    bytes32 private constant LIQUIDATION_MANAGER = \"LIQUIDATION_MANAGER\";\n    /// @dev Oracle key\n    bytes32 private constant ORACLE = \"ORACLE\";\n\n    /// @dev mapping between key and address\n    mapping(bytes32 => address) private addresses;\n\n    /// @notice emits an event when a new proxy is created\n    event ProxyCreated(bytes32 id, address proxy);\n    /// @notice emits an event when a new address is added\n    event AddressAdded(bytes32 id, address add);\n\n    /**\n     * @notice return Otoken implementation address\n     * @return Otoken implementation address\n     */\n    function getOtokenImpl() external view returns (address) {\n        return getAddress(OTOKEN_IMPL);\n    }\n\n    /**\n     * @notice return oTokenFactory address\n     * @return OtokenFactory address\n     */\n    function getOtokenFactory() external view returns (address) {\n        return getAddress(OTOKEN_FACTORY);\n    }\n\n    /**\n     * @notice return Whitelist address\n     * @return Whitelist address\n     */\n    function getWhitelist() external view returns (address) {\n        return getAddress(WHITELIST);\n    }\n\n    /**\n     * @notice return Controller address\n     * @return Controller address\n     */\n    function getController() external view returns (address) {\n        return getAddress(CONTROLLER);\n    }\n\n    /**\n     * @notice return MarginPool address\n     * @return MarginPool address\n     */\n    function getMarginPool() external view returns (address) {\n        return getAddress(MARGIN_POOL);\n    }\n\n    /**\n     * @notice return MarginCalculator address\n     * @return MarginCalculator address\n     */\n    function getMarginCalculator() external view returns (address) {\n        return getAddress(MARGIN_CALCULATOR);\n    }\n\n    /**\n     * @notice return LiquidationManager address\n     * @return LiquidationManager address\n     */\n    function getLiquidationManager() external view returns (address) {\n        return getAddress(LIQUIDATION_MANAGER);\n    }\n\n    /**\n     * @notice return Oracle address\n     * @return Oracle address\n     */\n    function getOracle() external view returns (address) {\n        return getAddress(ORACLE);\n    }\n\n    /**\n     * @notice set Otoken implementation address\n     * @dev can only be called by the addressbook owner\n     * @param _otokenImpl Otoken implementation address\n     */\n    function setOtokenImpl(address _otokenImpl) external onlyOwner {\n        setAddress(OTOKEN_IMPL, _otokenImpl);\n    }\n\n    /**\n     * @notice set OtokenFactory address\n     * @dev can only be called by the addressbook owner\n     * @param _otokenFactory OtokenFactory address\n     */\n    function setOtokenFactory(address _otokenFactory) external onlyOwner {\n        setAddress(OTOKEN_FACTORY, _otokenFactory);\n    }\n\n    /**\n     * @notice set Whitelist address\n     * @dev can only be called by the addressbook owner\n     * @param _whitelist Whitelist address\n     */\n    function setWhitelist(address _whitelist) external onlyOwner {\n        setAddress(WHITELIST, _whitelist);\n    }\n\n    /**\n     * @notice set Controller address\n     * @dev can only be called by the addressbook owner\n     * @param _controller Controller address\n     */\n    function setController(address _controller) external onlyOwner {\n        updateImpl(CONTROLLER, _controller);\n    }\n\n    /**\n     * @notice set MarginPool address\n     * @dev can only be called by the addressbook owne"
    }
  ]
}