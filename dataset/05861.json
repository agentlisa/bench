{
  "Title": "[M-01] Chain support cannot be removed or cleared in bridge contracts",
  "Content": "\nDue to how addresses are handled and stored in the configuration settings, it is not possible to remove chain support in both source and destination bridge contracts.\n\nThe Axelar bridge service uses strings to represent addresses: messages sent to another chain need to specify its destination contract as a string. The protocol decided to follow the same representation and contract store addresses as strings as part of their configuration.\n\nChain support in the bridge contracts is then represented by associating the chain name with the address of the contract, stored as a string. This can be seen in the implementation of `setDestinationChainContractAddress()` for the SourceBridge contract, which stores the string, and the implementation of `addChainSupport()` in the DestinationBridge contract, which stores the hash of the string:\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/SourceBridge.sol#L121-L129>\n\n```solidity\n121:   function setDestinationChainContractAddress(\n122:     string memory destinationChain,\n123:     address contractAddress\n124:   ) external onlyOwner {\n125:     destChainToContractAddr[destinationChain] = AddressToString.toString(\n126:       contractAddress\n127:     );\n128:     emit DestinationChainContractAddressSet(destinationChain, contractAddress);\n129:   }\n```\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L234-L240>\n\n```solidity\n234:   function addChainSupport(\n235:     string calldata srcChain,\n236:     string calldata srcContractAddress\n237:   ) external onlyOwner {\n238:     chainToApprovedSender[srcChain] = keccak256(abi.encode(srcContractAddress));\n239:     emit ChainIdSupported(srcChain, srcContractAddress);\n240:   }\n```\n\nThis also means that checks need to be done based on the stored representation. SourceBridge checks the length of the string, while DestinationBridge checks for a `bytes32(0)` value:\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/SourceBridge.sol#L68-L71>\n\n```solidity\n68:     if (bytes(destContract).length == 0) {\n69:       revert DestinationNotSupported();\n70:     }\n71: \n```\n\n<https://github.com/code-423n4/2023-09-ondo/blob/main/contracts/bridge/DestinationBridge.sol#L96-L98>\n\n```solidity\n96:     if (chainToApprovedSender[srcChain] == bytes32(0)) {\n97:       revert ChainNotSupported();\n98:     }\n```\n\nNote that this implies that there is no way to clear these settings and remove chain support. In the case of SourceBridge, any address sent to `setDestinationChainContractAddress()` will be converted to their string representation, which will always have a length greater than zero. For the DestinationBridge, `addChainSupport()` will hash the address parameter and it will be impossible for that hash value to be zero (since it will imply knowing the preimage of zero).\n\n### Proof of Concept\n\n1. Admin configs the destination address in SourceBridge by calling `setDestinationChainContractAddress(\"optimism\", destinationAddress)`.\n2. Admin decides to remove support for Optimism.\n3. Admin calls `setDestinationChainContractAddress(\"optimism\", address(0))`, but this will actually store the string for the zero address `0x0000....000`.\n4. The check `bytes(destContract).length == 0` will fail and messages will still be routed.\n\n### Recommended Mitigation Steps\n\nProvide functions in both contracts to allow the owner to clear the settings by resetting their configuration to the default value.\n\n```solidity\nfunction removeDestinationChainContractAddress(\n  string memory destinationChain\n) external onlyOwner {\n  delete destChainToContractAddr[destinationChain];\n  emit DestinationChainContractAddressRemoved(destinationChain);\n}\n```\n\n```solidity\nfunction removeChainSupport(\n  string calldata srcChain\n) external onlyOwner {\n  delete chainToApprovedSender[srcChain];\n  emit ChainIdRemoved(srcChain);\n}\n```\n\n**[tom2o17 (Ondo) commented](https://github.com/code-423n4/2023-09-ondo-findings/issues/444#issuecomment-1739400196):**\n> @kirk-baird - Can I not set acceptable `srcAddr` to `address(0)` and then, given `address(0)` cannot have a contract deployed to it, this value should not be within the possible ranges of `srcAddr` within the `_execute` function?\n> \n> Granted not super ideal given it will hit a different error message, but functionally, the result is the same.\n\n**[kirk-baird (judge) commented](https://github.com/code-423n4/2023-09-ondo-findings/issues/444#issuecomment-1740049922):**\n> @tom2o17 - My concern here is that there's no way to stop calling `burnAndCallAxelar()`, which would burn tokens on the source chain. These would not be minted on the destination chain and are essentially lost.\n> \n> E.g. If you call `setDestinationChainContractAddress(dstChain, address(0))`, then [Address.toString(address(0))](https://github.com/code-423n4/2023-09-ondo/blob/47d34d6d4a5303af5f46e907ac2292e6a7745f6c/contracts/external/axelar/StringAddressUtils.sol#L34) will encode that to 42 hex characters.\n> \n> So [this check](https://github.com/code-423n4/2023-09-ondo/blob/47d34d6d4a5303af5f46e907ac2292e6a7745f6c/contracts/bridge/SourceBridge.sol#L68) in `burnAndCallAxelar()` will always pass, since `bytes(destContract).length` is 42 bytes.\n\n**[tom2o17 (Ondo) commented](https://github.com/code-423n4/2023-09-ondo-findings/issues/444#issuecomment-1741107906):**\n> @kirk-baird - Ah I see. I am inclined to accept this issue. Apologies, I thought this was referencing the `dstBridge` not the `srcBridge`. As mitigation we would be able to pause the contract, and prevent this functionality, but agree with the auditor that this is not ideal.\n\n**[tom2o17 (Ondo) acknowledged](https://github.com/code-423n4/2023-09-ondo-findings/issues/444#issuecomment-1757755137)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-ondo",
  "Code": [
    {
      "filename": "contracts/bridge/SourceBridge.sol",
      "content": "pragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IAxelarGateway.sol\";\nimport \"contracts/interfaces/IAxelarGasService.sol\";\nimport \"contracts/interfaces/IMulticall.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport {AddressToString} from \"contracts/external/axelar/StringAddressUtils.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/Ownable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/Pausable.sol\";\n\ncontract SourceBridge is Ownable, Pausable, IMulticall {\n  /// @notice Mapping from destination chain to bridge address on that chain\n  /// @dev Axelar uses the string representation of addresses, hence we store\n  ///      the address as a string\n  mapping(string => string) public destChainToContractAddr;\n\n  /// @notice Token contract bridged by this contract\n  IRWALike public immutable TOKEN;\n\n  /// @notice Pointer  to AxelarGateway contract\n  IAxelarGateway public immutable AXELAR_GATEWAY;\n\n  /// @notice Pointer to AxelarGasService contract\n  IAxelarGasService public immutable GAS_RECEIVER;\n\n  /// @notice Versioning for payload\n  bytes32 public constant VERSION = \"1.0\";\n\n  /// @notice Monotonically increasing nonce for each transaction\n  uint256 public nonce;\n\n  /**\n   * @notice Constructor\n   *\n   * @param _token The address of the token bridged\n   * @param _axelarGateway The address of the AxelarGateway contract\n   * @param _gasService The address of the AxelarGasService contract\n   * @param owner The owner of the contract\n   */\n  constructor(\n    address _token,\n    address _axelarGateway,\n    address _gasService,\n    address owner\n  ) {\n    TOKEN = IRWALike(_token);\n    AXELAR_GATEWAY = IAxelarGateway(_axelarGateway);\n    GAS_RECEIVER = IAxelarGasService(_gasService);\n    _transferOwnership(owner);\n  }\n\n  /**\n   * @notice Burns tokens on the source Chain and calls AxelarGateway contract\n   *         to mint tokens on the destination chain\n   *\n   * @param amount The amount of tokens to burn\n   * @param destinationChain The destination chain to mint tokens on\n   *\n   * @dev The amount of tokens to mint is the same as the amount burned\n   */\n  function burnAndCallAxelar(\n    uint256 amount,\n    string calldata destinationChain\n  ) external payable whenNotPaused {\n    // check destinationChain is correct\n    string memory destContract = destChainToContractAddr[destinationChain];\n\n    if (bytes(destContract).length == 0) {\n      revert DestinationNotSupported();\n    }\n\n    if (msg.value == 0) {\n      revert GasFeeTooLow();\n    }\n\n    // burn amount\n    TOKEN.burnFrom(msg.sender, amount);\n\n    bytes memory payload = abi.encode(VERSION, msg.sender, amount, nonce++);\n\n    _payGasAndCallContract(destinationChain, destContract, payload);\n  }\n\n  /**\n   * @notice Helper function that pays gas and calls the AxelarGateway contract\n   *\n   * @param destinationChain The destination chain to mint tokens on\n   * @param destContract The contract address on the destination chain\n   * @param payload The payload to send to the AxelarGateway contract\n   */\n  function _payGasAndCallContract(\n    string calldata destinationChain,\n    string memory destContract,\n    bytes memory payload\n  ) private {\n    GAS_RECEIVER.payNativeGasForContractCall{value: msg.value}(\n      address(this),\n      destinationChain,\n      destContract,\n      payload,\n      msg.sender\n    );\n\n    // Send all information to AxelarGateway contract.\n    AXELAR_GATEWAY.callContract(destinationChain, destContract, payload);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Admin Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the destination chain to contract address mapping\n   *\n   * @param destinationChain The destination chain\n   * @param contractAddress The contract address on the destination chain\n   *\n   * @dev Chain name must come from list of supported chains\n   *      at https://docs.axelar.dev/dev/reference/mainnet-chain-names\n   */\n  function setDestinationChainContractAddress(\n    string memory destinationChain,\n    address contractAddress\n  ) external onlyOwner {\n    destChainToContractAddr[destinationChain] = AddressToString.toString(\n      contractAddress\n    );\n    emit DestinationChainContractAddressSet(destinationChain, contractAddress);\n  }\n\n  /**\n   * @notice Admin function to pause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice Admin function to unpause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  ) external payable override onlyOwner returns (bytes[] memory results) {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           Events & Errors\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Even emitted when the destination chain to contract address mapping is set\n   *\n   * @param destinationChain The destination chain\n   * @param contractAddress The contract address on the destination chain\n   */\n  event DestinationChainContractAddressSet(\n    string indexed destinationChain,\n    address contractAddress\n  );\n\n  // Errors\n  error DestinationNotSupported();\n  error GasFeeTooLow();\n}"
    },
    {
      "filename": "contracts/bridge/DestinationBridge.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IAxelarGateway.sol\";\nimport \"contracts/interfaces/IAxelarGasService.sol\";\nimport \"contracts/external/axelar/AxelarExecutable.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport \"contracts/interfaces/IAllowlist.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/Ownable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/Pausable.sol\";\nimport \"contracts/bridge/MintRateLimiter.sol\";\n\ncontract DestinationBridge is\n  AxelarExecutable,\n  MintTimeBasedRateLimiter,\n  Ownable,\n  Pausable\n{\n  /// @notice Token contract bridged by this contract\n  IRWALike public immutable TOKEN;\n\n  /// @notice Pointer to AxelarGateway contract\n  IAxelarGateway public immutable AXELAR_GATEWAY;\n\n  /// @notice Pointer to USDY allowlist\n  IAllowlist public immutable ALLOWLIST;\n\n  // Mapping used to track approvers, approved msg src's and spent nonces\n  mapping(address => bool) public approvers;\n  mapping(string => bytes32) public chainToApprovedSender;\n  mapping(bytes32 => mapping(uint256 => bool)) public isSpentNonce;\n\n  /// @notice Versioning for payload, must match SourceBridge version\n  bytes32 public constant VERSION = \"1.0\";\n\n  /// @notice Mappings used to track transaction and thresholds\n  mapping(bytes32 => TxnThreshold) public txnToThresholdSet;\n  mapping(string => Threshold[]) public chainToThresholds;\n  mapping(bytes32 => Transaction) public txnHashToTransaction;\n\n  constructor(\n    address _token,\n    address _axelarGateway,\n    address _allowlist,\n    address _ondoApprover,\n    address _owner,\n    uint256 _mintLimit,\n    uint256 _mintDuration\n  )\n    AxelarExecutable(_axelarGateway)\n    MintTimeBasedRateLimiter(_mintDuration, _mintLimit)\n  {\n    TOKEN = IRWALike(_token);\n    AXELAR_GATEWAY = IAxelarGateway(_axelarGateway);\n    ALLOWLIST = IAllowlist(_allowlist);\n    approvers[_ondoApprover] = true;\n    _transferOwnership(_owner);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         Axelar Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Internal overriden function that is executed when contract is called by Axelar Gateway\n   *\n   * @param srcChain The string of the source chain eg: arbitrum\n   * @param srcAddr  The string of the address of the source contract\n   * @param payload  The payload to pass cross chain\n   */\n  function _execute(\n    string calldata srcChain,\n    string calldata srcAddr,\n    bytes calldata payload\n  ) internal override whenNotPaused {\n    (bytes32 version, address srcSender, uint256 amt, uint256 nonce) = abi\n      .decode(payload, (bytes32, address, uint256, uint256));\n\n    if (version != VERSION) {\n      revert InvalidVersion();\n    }\n    if (chainToApprovedSender[srcChain] == bytes32(0)) {\n      revert ChainNotSupported();\n    }\n    if (chainToApprovedSender[srcChain] != keccak256(abi.encode(srcAddr))) {\n      revert SourceNotSupported();\n    }\n    if (isSpentNonce[chainToApprovedSender[srcChain]][nonce]) {\n      revert NonceSpent();\n    }\n\n    isSpentNonce[chainToApprovedSender[srcChain]][nonce] = true;\n\n    bytes32 txnHash = keccak256(payload);\n    txnHashToTransaction[txnHash] = Transaction(srcSender, amt);\n    _attachThreshold(amt, txnHash, srcChain);\n    _approve(txnHash);\n    _mintIfThresholdMet(txnHash);\n    emit MessageReceived(srcChain, srcSender, amt, nonce);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Internal Functions\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Internal function used to attach a specific threshold to a given\n   *         `txnHash`.\n   *\n   * @param amount   The amount of the token being bridged\n   * @param txnHash  The transaction hash to associate the threshold with\n   * @param srcChain The chain corresponding to the chain that the token\n   *                 being bridged originated from.\n   */\n  function _attachThreshold(\n    uint256 amount,\n    bytes32 txnHash,\n    string memory srcChain\n  ) internal {\n    Threshold[] memory thresholds = chainToThresholds[srcChain];\n    for (uint256 i = 0; i < thresholds.length; ++i) {\n      Threshold memory t = thresholds[i];\n      if (amount <= t.amount) {\n        txnToThresholdSet[txnHash] = TxnThreshold(\n          t.numberOfApprovalsNeeded,\n          new address[](0)\n        );\n        break;\n      }\n    }\n    if (txnToThresholdSet[txnHash].numberOfApprovalsNeeded == 0) {\n      revert NoThresholdMatch();\n    }\n  }\n\n  /**\n   * @notice Internal function used to approve and conditionally mint for a\n   *         given txn. Approval is conditional on this approver having not\n   *         previously approved the txn\n   *\n   * @param txnHash The txnHash to approve and conditionally mint to\n   */\n  function _approve(bytes32 txnHash) internal {\n    // Check that the approver has not already approved\n    TxnThreshold storage t = txnToThresholdSet[txnHash];\n    if (t.approvers.length > 0) {\n      for (uint256 i = 0; i < t.approvers.length; ++i) {\n        if (t.approvers[i] == msg.sender) {\n          revert AlreadyApproved();\n        }\n      }\n    }\n    t.approvers.push(msg.sender);\n  }\n\n  /**\n   * @notice Internal function used to check if the approval threshold has been\n   *         met for a given transaction.\n   *\n   * @param txnHash The txnHash to check\n   *\n   * @dev If an approver has been removed, any previous approvals are still valid\n   */\n  function _checkThresholdMet(bytes32 txnHash) internal view returns (bool) {\n    TxnThreshold memory t = txnToThresholdSet[txnHash];\n    if (t.numberOfApprovalsNeeded <= t.approvers.length) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Protected Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Protected Function used to approve messages passed to the\n   *         Receiver contract. This function is able to be called by any\n   *         approver that is added and associated with Ondo.\n   *\n   * @param txnHash The keccak256 hash of the payload\n   */\n  function approve(bytes32 txnHash) external {\n    if (!approvers[msg.sender]) {\n      revert NotApprover();\n    }\n    _approve(txnHash);\n    _mintIfThresholdMet(txnHash);\n  }\n\n  /**\n   * @notice Admin function to add an ondo Signer or Axelar Relayer\n   *\n   * @param approver  The address we would like to add\n   */\n  function addApprover(address approver) external onlyOwner {\n    approvers[approver] = true;\n    emit ApproverAdded(approver);\n  }\n\n  /**\n   * @notice Admin function to remove an approver\n   *\n   * @param approver The address of the approver that we would like to remove\n   */\n  function removeApprover(address approver) external onlyOwner {\n    delete approvers[approver];\n    emit ApproverRemoved(approver);\n  }\n\n  /**\n   * @notice Admin function that will allow bridge calls originating from a given address\n   *         on a given chain.\n   * @notice This will initalize a nested mapping in which spent nonces from this `srcAddress`\n   *         are logged and prevented from being reused\n   *\n   * @param srcChain            The chain to support\n   * @param srcContractAddress  The address of the Ondo Bridge on this chain\n   */\n  function addChainSupport(\n    string calldata srcChain,\n    string calldata srcContractAddress\n  ) external onlyOwner {\n    chainToApprovedSender[srcChain] = keccak256(abi.encode(srcContractAddress));\n    emit ChainIdSupported(srcChain, srcContractAddress);\n  }\n\n  /**\n   * @notice Admin function used to clear and set thresholds corresponding to a chain\n   *\n   * @param srcChain       The chain to set the threshold for\n   * @param amounts        The ordered array of values corresponding to\n   *                       the amount for a given threshold\n   * @param numOfApprovers The ordered array of the number of approvals needed\n   *                       for a given threshold\n   *\n   * @dev This function will remove all previously set thresholds for a given chain\n   *      and will thresholds corresponding to the params of this function. Passing\n   *      in empty arrays will remove all thresholds for a given chain\n   */\n  function setThresholds(\n    string calldata srcChain,\n    uint256[] calldata amounts,\n    uint256[] calldata numOfApprovers\n  ) external onlyOwner {\n    if (amounts.length != numOfApprovers.length) {\n      revert ArrayLengthMismatch();\n    }\n    delete chainToThresholds[srcChain];\n    for (uint256 i = 0; i < amounts.length; ++i) {\n      if (i == 0) {\n        chainToThresholds[srcChain].push(\n          Threshold(amounts[i], numOfApprovers[i])\n        );\n      } else {\n        if (chainToThresholds[srcChain][i - 1].amount > amounts[i]) {\n          revert ThresholdsNotInAscendingOrder();\n        }\n        chainToThresholds[srcChain].push(\n          Threshold(amounts[i], numOfApprovers[i])\n        );\n      }\n    }\n    emit ThresholdSet(srcChain, amounts, numOfApprovers);\n  }\n\n  /**\n   * @notice Admin function used to set the mint limit\n   *\n   * @param mintLimit The new mint limit\n   */\n  function setMintLimit(uint256 mintLimit) external onlyOwner {\n    _setMintLimit(mintLimit);\n  }\n\n  /**\n   * @notice Admin function used to set the mint duration\n   *\n   * @param mintDuration The new mint duration\n   */\n  function setMintLimitDuration(uint256 mintDuration) external onlyOwner {\n    _setMintLimitDuration(mintDuration);\n  }\n\n  /**\n   * @notice Admin function used to pause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice Admin function used to unpause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @notice Admin function used to rescue ERC20 Tokens sent to the contract\n   *\n   * @param _token The address of the token to rescue\n   */\n  function rescueTokens(address _token) external onlyOwner {\n    uint256 balance = IRWALike(_token).balanceOf(address(this));\n    IRWALike(_token).transfer(owner(), balance);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Public Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice internal function to mint a transaction if it has passed the threshold\n   *         for the number of approvers\n   *\n   * @param txnHash The hash of the transaction we wish to mint\n   */\n  function _mintIfThresholdMet(bytes32 txnHash) internal {\n    bool thresholdMet = _checkThresholdMet(txnHash);\n    Transaction memory txn = txnHashToTransaction[txnHash];\n    if (thresholdMet) {\n      _checkAndUpdateInstantMintLimit(txn.amount);\n      if (!ALLOWLIST.isAllowed(txn.sender)) {\n        ALLOWLIST.setAccountStatus(\n          txn.sender,\n          ALLOWLIST.getValidTermIndexes()[0],\n          true\n        );\n      }\n      TOKEN.mint(txn.sender, txn.amount);\n      delete txnHashToTransaction[txnHash];\n      emit BridgeCompleted(txn.sender, txn.amount);\n    }\n  }\n\n  /**\n   * @notice External view function used to get the number of approvers for a\n   *         given txnHash\n   *\n   * @param txnHash The hash to get the number of approvers for\n   */\n  function getNumApproved(bytes32 txnHash) external view returns (uint256) {\n    return txnToThresholdSet[txnHash].approvers.length;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      Structs, Events, Errors\n  //////////////////////////////////////////////////////////////*/\n\n  struct Threshold {\n    uint256 amount;\n    uint256 numberOfApprovalsNeeded;\n  }\n\n  struct TxnThreshold {\n    uint256 numberOfApprovalsNeeded;\n    address[] approvers;\n  }\n\n  struct Transaction {\n    address sender;\n    uint256 amount;\n  }\n\n  /**\n   * @notice event emitted when an address is removed as an approver\n   *\n   * @param approver The address being removed\n   */\n  event ApproverRemoved(address approver);\n\n  /**\n   * @notice event emitted when an address is added as an approver\n   *\n   * @param approver  The address to add\n   */\n  event ApproverAdded(address approver);\n\n  /**\n   * @notice event emitted when a new contract is whitelisted as an approved\n   *         message passer.\n   *\n   * @param srcChain        The chain for the approved address\n   * @param approvedSource  The address corresponding to the source bridge contract\n   */\n  event ChainIdSupported(string srcChain, string approvedSource);\n\n  /**\n   * @notice event emitted when a threshold has been set\n   *\n   * @param chain           The chain for which the threshold was set\n   * @param amounts         The amount of tokens to reach this threshold\n   * @param numOfApprovers  The number of approvals needed\n   */\n  event ThresholdSet(string chain, uint256[] amounts, uint256[] numOfApprovers);\n\n  /**\n   * @notice event emitted when the user has been minted their tokens on the dst chain\n   *\n   * @param user    The recipient address of the newly minted tokens\n   * @param amount  The amount of tokens that have been minted\n   */\n  event BridgeCompleted(address user, uint256 amount);\n\n  /**\n   * @notice event emitted when this bridge contract receives a cross chain message\n   *\n   * @param srcChain  The chain from which the message is originating\n   * @param srcSender The address of the msg.sender on the source chain\n   * @param amt       The amount of tokens being bridged\n   * @param nonce     The nonce corresponding to the contract which originated the msg\n   */\n  event MessageReceived(\n    string srcChain,\n    address srcSender,\n    uint256 amt,\n    uint256 nonce\n  );\n\n  error NotApprover();\n  error NoThresholdMatch();\n  error ThresholdsNotInAscendingOrder();\n\n  error ChainNotSupported();\n  error SourceNotSupported();\n  error NonceSpent();\n  error AlreadyApproved();\n  error InvalidVersion();\n  error ArrayLengthMismatch();\n}"
    },
    {
      "filename": "contracts/bridge/SourceBridge.sol",
      "content": "pragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IAxelarGateway.sol\";\nimport \"contracts/interfaces/IAxelarGasService.sol\";\nimport \"contracts/interfaces/IMulticall.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport {AddressToString} from \"contracts/external/axelar/StringAddressUtils.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/Ownable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/Pausable.sol\";\n\ncontract SourceBridge is Ownable, Pausable, IMulticall {\n  /// @notice Mapping from destination chain to bridge address on that chain\n  /// @dev Axelar uses the string representation of addresses, hence we store\n  ///      the address as a string\n  mapping(string => string) public destChainToContractAddr;\n\n  /// @notice Token contract bridged by this contract\n  IRWALike public immutable TOKEN;\n\n  /// @notice Pointer  to AxelarGateway contract\n  IAxelarGateway public immutable AXELAR_GATEWAY;\n\n  /// @notice Pointer to AxelarGasService contract\n  IAxelarGasService public immutable GAS_RECEIVER;\n\n  /// @notice Versioning for payload\n  bytes32 public constant VERSION = \"1.0\";\n\n  /// @notice Monotonically increasing nonce for each transaction\n  uint256 public nonce;\n\n  /**\n   * @notice Constructor\n   *\n   * @param _token The address of the token bridged\n   * @param _axelarGateway The address of the AxelarGateway contract\n   * @param _gasService The address of the AxelarGasService contract\n   * @param owner The owner of the contract\n   */\n  constructor(\n    address _token,\n    address _axelarGateway,\n    address _gasService,\n    address owner\n  ) {\n    TOKEN = IRWALike(_token);\n    AXELAR_GATEWAY = IAxelarGateway(_axelarGateway);\n    GAS_RECEIVER = IAxelarGasService(_gasService);\n    _transferOwnership(owner);\n  }\n\n  /**\n   * @notice Burns tokens on the source Chain and calls AxelarGateway contract\n   *         to mint tokens on the destination chain\n   *\n   * @param amount The amount of tokens to burn\n   * @param destinationChain The destination chain to mint tokens on\n   *\n   * @dev The amount of tokens to mint is the same as the amount burned\n   */\n  function burnAndCallAxelar(\n    uint256 amount,\n    string calldata destinationChain\n  ) external payable whenNotPaused {\n    // check destinationChain is correct\n    string memory destContract = destChainToContractAddr[destinationChain];\n\n    if (bytes(destContract).length == 0) {\n      revert DestinationNotSupported();\n    }\n\n    if (msg.value == 0) {\n      revert GasFeeTooLow();\n    }\n\n    // burn amount\n    TOKEN.burnFrom(msg.sender, amount);\n\n    bytes memory payload = abi.encode(VERSION, msg.sender, amount, nonce++);\n\n    _payGasAndCallContract(destinationChain, destContract, payload);\n  }\n\n  /**\n   * @notice Helper function that pays gas and calls the AxelarGateway contract\n   *\n   * @param destinationChain The destination chain to mint tokens on\n   * @param destContract The contract address on the destination chain\n   * @param payload The payload to send to the AxelarGateway contract\n   */\n  function _payGasAndCallContract(\n    string calldata destinationChain,\n    string memory destContract,\n    bytes memory payload\n  ) private {\n    GAS_RECEIVER.payNativeGasForContractCall{value: msg.value}(\n      address(this),\n      destinationChain,\n      destContract,\n      payload,\n      msg.sender\n    );\n\n    // Send all information to AxelarGateway contract.\n    AXELAR_GATEWAY.callContract(destinationChain, destContract, payload);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Admin Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the destination chain to contract address mapping\n   *\n   * @param destinationChain The destination chain\n   * @param contractAddress The contract address on the destination chain\n   *\n   * @dev Chain name must come from list of supported chains\n   *      at https://docs.axelar.dev/dev/reference/mainnet-chain-names\n   */\n  function setDestinationChainContractAddress(\n    string memory destinationChain,\n    address contractAddress\n  ) external onlyOwner {\n    destChainToContractAddr[destinationChain] = AddressToString.toString(\n      contractAddress\n    );\n    emit DestinationChainContractAddressSet(destinationChain, contractAddress);\n  }\n\n  /**\n   * @notice Admin function to pause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice Admin function to unpause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  ) external payable override onlyOwner returns (bytes[] memory results) {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           Events & Errors\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Even emitted when the destination chain to contract address mapping is set\n   *\n   * @param destinationChain The destination chain\n   * @param contractAddress The contract address on the destination chain\n   */\n  event DestinationChainContractAddressSet(\n    string indexed destinationChain,\n    address contractAddress\n  );\n\n  // Errors\n  error DestinationNotSupported();\n  error GasFeeTooLow();\n}"
    },
    {
      "filename": "contracts/bridge/DestinationBridge.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IAxelarGateway.sol\";\nimport \"contracts/interfaces/IAxelarGasService.sol\";\nimport \"contracts/external/axelar/AxelarExecutable.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport \"contracts/interfaces/IAllowlist.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/Ownable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/Pausable.sol\";\nimport \"contracts/bridge/MintRateLimiter.sol\";\n\ncontract DestinationBridge is\n  AxelarExecutable,\n  MintTimeBasedRateLimiter,\n  Ownable,\n  Pausable\n{\n  /// @notice Token contract bridged by this contract\n  IRWALike public immutable TOKEN;\n\n  /// @notice Pointer to AxelarGateway contract\n  IAxelarGateway public immutable AXELAR_GATEWAY;\n\n  /// @notice Pointer to USDY allowlist\n  IAllowlist public immutable ALLOWLIST;\n\n  // Mapping used to track approvers, approved msg src's and spent nonces\n  mapping(address => bool) public approvers;\n  mapping(string => bytes32) public chainToApprovedSender;\n  mapping(bytes32 => mapping(uint256 => bool)) public isSpentNonce;\n\n  /// @notice Versioning for payload, must match SourceBridge version\n  bytes32 public constant VERSION = \"1.0\";\n\n  /// @notice Mappings used to track transaction and thresholds\n  mapping(bytes32 => TxnThreshold) public txnToThresholdSet;\n  mapping(string => Threshold[]) public chainToThresholds;\n  mapping(bytes32 => Transaction) public txnHashToTransaction;\n\n  constructor(\n    address _token,\n    address _axelarGateway,\n    address _allowlist,\n    address _ondoApprover,\n    address _owner,\n    uint256 _mintLimit,\n    uint256 _mintDuration\n  )\n    AxelarExecutable(_axelarGateway)\n    MintTimeBasedRateLimiter(_mintDuration, _mintLimit)\n  {\n    TOKEN = IRWALike(_token);\n    AXELAR_GATEWAY = IAxelarGateway(_axelarGateway);\n    ALLOWLIST = IAllowlist(_allowlist);\n    approvers[_ondoApprover] = true;\n    _transferOwnership(_owner);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         Axelar Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Internal overriden function that is executed when contract is called by Axelar Gateway\n   *\n   * @param srcChain The string of the source chain eg: arbitrum\n   * @param srcAddr  The string of the address of the source contract\n   * @param payload  The payload to pass cross chain\n   */\n  function _execute(\n    string calldata srcChain,\n    string calldata srcAddr,\n    bytes calldata payload\n  ) internal override whenNotPaused {\n    (bytes32 version, address srcSender, uint256 amt, uint256 nonce) = abi\n      .decode(payload, (bytes32, address, uint256, uint256));\n\n    if (version != VERSION) {\n      revert InvalidVersion();\n    }\n    if (chainToApprovedSender[srcChain] == bytes32(0)) {\n      revert ChainNotSupported();\n    }\n    if (chainToApprovedSender[srcChain] != keccak256(abi.encode(srcAddr))) {\n      revert SourceNotSupported();\n    }\n    if (isSpentNonce[chainToApprovedSender[srcChain]][nonce]) {\n      revert NonceSpent();\n    }\n\n    isSpentNonce[chainToApprovedSender[srcChain]][nonce] = true;\n\n    bytes32 txnHash = keccak256(payload);\n    txnHashToTransaction[txnHash] = Transaction(srcSender, amt);\n    _attachThreshold(amt, txnHash, srcChain);\n    _approve(txnHash);\n    _mintIfThresholdMet(txnHash);\n    emit MessageReceived(srcChain, srcSender, amt, nonce);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Internal Functions\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Internal function used to attach a specific threshold to a given\n   *         `txnHash`.\n   *\n   * @param amount   The amount of the token being bridged\n   * @param txnHash  The transaction hash to associate the threshold with\n   * @param srcChain The chain corresponding to the chain that the token\n   *                 being bridged originated from.\n   */\n  function _attachThreshold(\n    uint256 amount,\n    bytes32 txnHash,\n    string memory srcChain\n  ) internal {\n    Threshold[] memory thresholds = chainToThresholds[srcChain];\n    for (uint256 i = 0; i < thresholds.length; ++i) {\n      Threshold memory t = thresholds[i];\n      if (amount <= t.amount) {\n        txnToThresholdSet[txnHash] = TxnThreshold(\n          t.numberOfApprovalsNeeded,\n          new address[](0)\n        );\n        break;\n      }\n    }\n    if (txnToThresholdSet[txnHash].numberOfApprovalsNeeded == 0) {\n      revert NoThresholdMatch();\n    }\n  }\n\n  /**\n   * @notice Internal function used to approve and conditionally mint for a\n   *         given txn. Approval is conditional on this approver having not\n   *         previously approved the txn\n   *\n   * @param txnHash The txnHash to approve and conditionally mint to\n   */\n  function _approve(bytes32 txnHash) internal {\n    // Check that the approver has not already approved\n    TxnThreshold storage t = txnToThresholdSet[txnHash];\n    if (t.approvers.length > 0) {\n      for (uint256 i = 0; i < t.approvers.length; ++i) {\n        if (t.approve"
    }
  ]
}