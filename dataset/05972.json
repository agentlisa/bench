{
  "Title": "[G-04] Optimize array comparison",
  "Content": "\nThe following function is not well optimized. First of all, there's no need to check the array twice. This alone reduces the cost by half.\n\n*1 instance*\n\n- [SecurityCouncilMgmtUpgradeLib.sol#L52-L88](https://github.com/arbitrumfoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/gov-action-contracts/AIPs/SecurityCouncilMgmt/SecurityCouncilMgmtUpgradeLib.sol#L52-L88)\n\n```diff\nfunction areAddressArraysEqual(address[] memory array1, address[] memory array2) \n\tpublic \n\tpure \n\treturns (bool)\n{\n\tif (array1.length != array2.length) {\n\t\treturn false;\n\t} \n\t for (uint256 i = 0; i < array1.length; i++) {  \n\t\t bool found = false;  \n\t\t for (uint256 j = 0; j < array2.length; j++) {  \n\t\t\t if (array1[i] == array2[j]) {  \n\t\t\t\t found = true;  \n\t\t\t\t break;  \n\t\t\t }  \n\t\t }  \n\t\t if (!found) {  \n\t\t\t return false;  \n\t\t }  \n\t } \n-\t for (uint256 i = 0; i < array2.length; i++) {  \n-\t\t bool found = false;  \n-\t\t for (uint256 j = 0; j < array1.length; j++) {  \n-\t\t\t if (array2[i] == array1[j]) {  \n-\t\t\t\t found = true;  \n-\t\t\t\t break;  \n-\t\t\t }  \n-\t\t }  \n-\t\t if (!found) {  \n-\t\t\t return false;  \n-\t\t } \n-\t } \n\t return true; \n```\n\nApplying this optimisation, those changes appear in the snapshot:\n\n```\ntestE2E() (gas: -136722 (-0.164%))\nOverall gas change: -136722 (-0.010%)\n```\n\nBut at this point the function is not yet perfectly optimized. it has a complexity of O(n^2). This can be increased by hashing the arrays, but the elements must be ordered. For this, quicksort is the best algorythm (this is obviously not recalled) (address can be compared by converting them to uint160).\n```diff\nfunction areAddressArraysEqual(address[] memory array1, address[] memory array2){\n-    /* */\n+  \t quicksort(array1);\n+        quicksort(array2);\n+\t bytes32 hash1 = keccak256(abi.encode(array1));  \n+\t bytes32 hash2 = keccak256(abi.encode(array2));\n+\t return hash1 == hash2; \n+ }\n```\n\nIn this way, the function would have a theoretical complexity of O(n log n). But in reality this will be more expensive for small arrays than the first alternative. Another way would be to introduce a hash table to compare elements more efficiently without looping (only one array need to be hashed), but this is again uneconomical on small arrays.\nThat's why only a benchmark for the simplest optimization is provided. On tests, the other two worsen costs. But it's useful to know that they exist and could be implemented if this function were to become more important.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-08-arbitrum",
  "Code": [
    {
      "filename": "src/gov-action-contracts/AIPs/SecurityCouncilMgmt/SecurityCouncilMgmtUpgradeLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"../../../security-council-mgmt/interfaces/IGnosisSafe.sol\";\nimport \"../../../interfaces/IUpgradeExecutor.sol\";\n\nlibrary SecurityCouncilMgmtUpgradeLib {\n    function replaceEmergencySecurityCouncil(\n        IGnosisSafe _prevSecurityCouncil,\n        IGnosisSafe _newSecurityCouncil,\n        uint256 _threshold,\n        IUpgradeExecutor _upgradeExecutor\n    ) internal {\n        requireSafesEquivalent(_prevSecurityCouncil, _newSecurityCouncil, _threshold);\n        bytes32 EXECUTOR_ROLE = _upgradeExecutor.EXECUTOR_ROLE();\n        require(\n            _upgradeExecutor.hasRole(EXECUTOR_ROLE, address(_prevSecurityCouncil)),\n            \"SecurityCouncilMgmtUpgradeLib: prev council not executor\"\n        );\n        require(\n            !_upgradeExecutor.hasRole(EXECUTOR_ROLE, address(_newSecurityCouncil)),\n            \"SecurityCouncilMgmtUpgradeLib: new council already executor\"\n        );\n\n        _upgradeExecutor.revokeRole(EXECUTOR_ROLE, address(_prevSecurityCouncil));\n        _upgradeExecutor.grantRole(EXECUTOR_ROLE, address(_newSecurityCouncil));\n    }\n\n    function requireSafesEquivalent(\n        IGnosisSafe _safe1,\n        IGnosisSafe safe2,\n        uint256 _expectedThreshold\n    ) internal view {\n        uint256 newSecurityCouncilThreshold = safe2.getThreshold();\n        require(\n            _safe1.getThreshold() == newSecurityCouncilThreshold,\n            \"SecurityCouncilMgmtUpgradeLib: threshold mismatch\"\n        );\n        require(\n            newSecurityCouncilThreshold == _expectedThreshold,\n            \"SecurityCouncilMgmtUpgradeLib: unexpected threshold\"\n        );\n\n        address[] memory prevOwners = _safe1.getOwners();\n        address[] memory newOwners = safe2.getOwners();\n        require(\n            areAddressArraysEqual(prevOwners, newOwners),\n            \"SecurityCouncilMgmtUpgradeLib: owners mismatch\"\n        );\n    }\n\n    function areAddressArraysEqual(address[] memory array1, address[] memory array2)\n        public\n        pure\n        returns (bool)\n    {\n        if (array1.length != array2.length) {\n            return false;\n        }\n\n        for (uint256 i = 0; i < array1.length; i++) {\n            bool found = false;\n            for (uint256 j = 0; j < array2.length; j++) {\n                if (array1[i] == array2[j]) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n\n        for (uint256 i = 0; i < array2.length; i++) {\n            bool found = false;\n            for (uint256 j = 0; j < array1.length; j++) {\n                if (array2[i] == array1[j]) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}"
    }
  ]
}