{
  "Title": "[L-02] No `deadline` and address zero check for signatures",
  "Content": "\nThere is one instance of this\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/UTBFeeCollector.sol#L44C5-L63C1\n\nThe `collectFees(...)` function of the UTBFeeCollector.sol contract verifies signature without a `deadline`.\n\nSecondly there is no check to ensure the `recovered` address is not zero address. This is because ecrecover can return address zero for invalid signature.\n\nLastly there is no use of nonce for the signatures:\n```\nfunction collectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes memory signature\n    ) public payable onlyUtb {\n        bytes32 constructedHash = keccak256(\n            abi.encodePacked(BANNER, keccak256(packedInfo))\n        );\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n        address recovered = ecrecover(constructedHash, v, r, s);\n        require(recovered == signer, \"Wrong signature\");\n        if (fees.feeToken != address(0)) {\n            IERC20(fees.feeToken).transferFrom(\n                utb,\n                address(this),\n                fees.feeAmount\n            );\n        }\n    }\n```\n\n### Impact: \n\n- Invalid signature can be used before the `signer` state variable is set since it will initially be zero. \n- Signature have no deadline and can be executed anytime\n\n### Recommendation:\n\nImplement `deadline` to signatures and also add address zero check on the recovered address. \n```\nrequire(blocktimestamp >= deadline, \"signature expired\");\nrequire(recovered != address(0), \"signature expired\");\n```\nSee EIP712: https://eips.ethereum.org/EIPS/eip-712\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "src/UTBFeeCollector.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {SwapInstructions, FeeStructure, BridgeInstructions} from \"./CommonTypes.sol\";\nimport {UTBOwned} from \"./UTBOwned.sol\";\n\ncontract UTBFeeCollector is UTBOwned {\n    address signer;\n    string constant BANNER = \"\\x19Ethereum Signed Message:\\n32\";\n\n    constructor() UTBOwned() {}\n\n    /**\n     * @dev Sets the signer used for fee verification.\n     * @param _signer The address of the signer.\n     */\n    function setSigner(address _signer) public onlyOwner {\n        signer = _signer;\n    }\n\n    /**\n     * @dev Splits an Ethereum signature into its components (r, s, v).\n     * @param signature The Ethereum signature.\n     */\n    function splitSignature(\n        bytes memory signature\n    ) private pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(signature.length == 65, \"Invalid signature length\");\n\n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n            v := byte(0, mload(add(signature, 96)))\n        }\n    }\n\n    /**\n     * @dev Receives fees in either native or ERC20.\n     * @param fees The bridge fee in native, as well as UTB fee token and amount.\n     * @param packedInfo The fees and swap instructions used to generate the signature.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function collectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes memory signature\n    ) public payable onlyUtb {\n        bytes32 constructedHash = keccak256(\n            abi.encodePacked(BANNER, keccak256(packedInfo))\n        );\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n        address recovered = ecrecover(constructedHash, v, r, s);\n        require(recovered == signer, \"Wrong signature\");\n        if (fees.feeToken != address(0)) {\n            IERC20(fees.feeToken).transferFrom(\n                utb,\n                address(this),\n                fees.feeAmount\n            );\n        }\n    }\n\n    /**\n     * @dev Redeems collected fees in the specified token and amount.\n     * @param token The address of the token to be redeemed, zero address for native.\n     * @param amount The amount to be redeemed.\n     */\n    function redeemFees(address token, uint amount) public onlyOwner {\n        if (token == address(0)) {\n            payable(owner).transfer(amount);\n        } else {\n            IERC20(token).transfer(owner, amount);\n        }\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    }
  ]
}