{
  "Title": "Ignoring `caseId`value when season is below peg",
  "Content": "# Ignoring `caseId`value when season is below peg\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L240-L252\">https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L240-L252</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L68-L81\">https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L68-L81</a>\n\n\n## Summary\nThe `Sun` contract ignores the current debt level (pre-calculated Weather case) when the season is below peg (pre-calculated deltaB is equal or less than zero). The `Sun.setSoilBelowPeg` function always chooses the minimal value from `instDeltaB` and `twaDeltaB`. This approach is good only for \"Reasonably High\" and \"Excessively High\" debt levels. But in case of \"Excessively Low\" debt level the maximal from `instDeltaB` and `twaDeltaB` can be more appropriate.\n\n## Vulnerability Details\nThe `Sun.stepSun` function uses `caseId` when season is above peg:\n```solidity\n    function stepSun(int256 deltaB, uint256 caseId) internal {\n        // Above peg\n        if (deltaB > 0) {\n            uint256 newHarvestable = rewardBeans(uint256(deltaB));\n            setSoilAbovePeg(newHarvestable, caseId);\n            s.season.abovePeg = true;\n        }\n\n        // Below peg\n        else {\n            setSoilBelowPeg(deltaB);\n            s.season.abovePeg = false;\n        }\n    }\n```\nThis lets to keep the debt at the optimal level by moving the debt to the ideal equilibrium (https://docs.bean.money/almanac/peg-maintenance/temperature#direction).\nBut in case the season is below peg the debt level is ignored and the minimum from `instDeltaB` and `twaDeltaB` amount is set as new soil.\n```solidity\n    function setSoilBelowPeg(int256 twaDeltaB) internal {\n\n        // Calculate deltaB from instantaneous reserves of all whitelisted Wells.\n        int256 instDeltaB;\n        address[] memory tokens = LibWhitelistedTokens.getWhitelistedWellLpTokens();\n        for (uint256 i = 0; i < tokens.length; i++) {\n            int256 wellInstDeltaB = LibWellMinting.instantaneousDeltaB(tokens[i]);\n            instDeltaB = instDeltaB.add(wellInstDeltaB);\n        }\n\n        // Set new soil.\n        setSoil(Math.min(uint256(-twaDeltaB), uint256(-instDeltaB)));\n    }\n```\nWhen the debt level is low, choosing the minimal value can slow down the optimal debt reaching.\n\n## Impact\nUnexpected behavior, debt is increased on a lower amount than the closest to ideal.\n\n## Tools used\nManual Review\n\n## Recommendations\nConsider taking into account the pre-calculated Weather case to choose the most appropriate value from `instDeltaB` and `twaDeltaB`.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clvo5kwin00078k6jhhjobn22",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibFertilizer, SafeMath} from \"contracts/libraries/LibFertilizer.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {Oracle, C} from \"./Oracle.sol\";\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SignedSafeMath} from \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport {LibWellMinting} from \"contracts/libraries/Minting/LibWellMinting.sol\";\nimport {LibWhitelistedTokens} from \"contracts/libraries/Silo/LibWhitelistedTokens.sol\";\n\n/**\n * @title Sun\n * @author Publius\n * @notice Sun controls the minting of new Beans to Fertilizer, the Field, and the Silo.\n */\ncontract Sun is Oracle {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using SignedSafeMath for int256;\n\n    /// @dev When Fertilizer is Active, it receives 1/3 of new Bean mints.\n    uint256 private constant FERTILIZER_DENOMINATOR = 3;\n\n    /// @dev After Fertilizer, Harvestable Pods receive 1/2 of new Bean mints. \n    uint256 private constant HARVEST_DENOMINATOR = 2;\n\n    /// @dev When the Pod Rate is high, issue less Soil.\n    uint256 private constant SOIL_COEFFICIENT_HIGH = 0.5e18;\n    \n    /// @dev When the Pod Rate is low, issue more Soil.\n    uint256 private constant SOIL_COEFFICIENT_LOW = 1.5e18;\n\n    /**\n     * @notice Emitted during Sunrise when Beans are distributed to the Field, the Silo, and Fertilizer.\n     * @param season The Season in which Beans were distributed.\n     * @param toField The number of Beans distributed to the Field.\n     * @param toSilo The number of Beans distributed to the Silo.\n     * @param toFertilizer The number of Beans distributed to Fertilizer.\n     */\n    event Reward(\n        uint32 indexed season,\n        uint256 toField,\n        uint256 toSilo,\n        uint256 toFertilizer\n    );\n\n    /**\n     * @notice Emitted during Sunrise when Beanstalk adjusts the amount of available Soil.\n     * @param season The Season in which Soil was adjusted.\n     * @param soil The new amount of Soil available.\n     */\n    event Soil(\n        uint32 indexed season,\n        uint256 soil\n    );\n\n    //////////////////// SUN INTERNAL ////////////////////\n    \n    /**\n     * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.\n     * @param caseId Pre-calculated Weather case from {Weather.calcCaseId}.\n     */\n    function stepSun(int256 deltaB, uint256 caseId) internal {\n        // Above peg\n        if (deltaB > 0) {\n            uint256 newHarvestable = rewardBeans(uint256(deltaB));\n            setSoilAbovePeg(newHarvestable, caseId);\n            s.season.abovePeg = true;\n        } \n\n        // Below peg\n        else {\n            setSoilBelowPeg(deltaB);\n            s.season.abovePeg = false;\n        }\n    }\n\n    //////////////////// REWARD BEANS ////////////////////\n\n    /**\n     * @dev Mints and distributes Beans to Fertilizer, the Field, and the Silo.\n     */\n    function rewardBeans(uint256 newSupply) internal returns (uint256 newHarvestable) {\n        uint256 newFertilized;\n        \n        C.bean().mint(address(this), newSupply);\n\n        // Distribute first to Fertilizer if some Fertilizer are active\n        if (s.season.fertilizing) {\n            newFertilized = rewardToFertilizer(newSupply);\n            newSupply = newSupply.sub(newFertilized);\n        }\n\n        // Distribute next to the Field if some Pods are still outstanding\n        if (s.f.harvestable < s.f.pods) {\n            newHarvestable = rewardToHarvestable(newSupply);\n            newSupply = newSupply.sub(newHarvestable);\n        }\n\n        // Distribute remainder to the Silo\n        rewardToSilo(newSupply);\n\n        emit Reward(s.season.current, newHarvestable, newSupply, newFertilized);\n    }\n\n    /**\n     * @dev Distributes Beans to Fertilizer.\n     */\n    function rewardToFertilizer(uint256 amount)\n        internal\n        returns (uint256 newFertilized)\n    {\n        // 1/3 of new Beans being minted\n        uint256 maxNewFertilized = amount.div(FERTILIZER_DENOMINATOR);\n\n        // Get the new Beans per Fertilizer and the total new Beans per Fertilizer\n        uint256 newBpf = maxNewFertilized.div(s.activeFertilizer);\n        uint256 oldTotalBpf = s.bpf;\n        uint256 newTotalBpf = oldTotalBpf.add(newBpf);\n\n        // Get the end Beans per Fertilizer of the first Fertilizer to run out.\n        uint256 firstEndBpf = s.fFirst;\n\n        // If the next fertilizer is going to run out, then step BPF according\n        while(newTotalBpf >= firstEndBpf) {\n            // Calculate BPF and new Fertilized when the next Fertilizer ID ends\n            newBpf = firstEndBpf.sub(oldTotalBpf);\n            newFertilized = newFertilized.add(newBpf.mul(s.activeFertilizer));\n\n            // If there is no more fertilizer, end\n            if (!LibFertilizer.pop()) {\n                s.bpf = uint128(firstEndBpf); // SafeCast unnecessary here.\n                s.fertilizedIndex = s.fertilizedIndex.add(newFertilized);\n                require(s.fertilizedIndex == s.unfertilizedIndex, \"Paid != owed\");\n                return newFertilized;\n            }\n\n            // Calculate new Beans per Fertilizer values\n            newBpf = maxNewFertilized.sub(newFertilized).div(s.activeFertilizer);\n            oldTotalBpf = firstEndBpf;\n            newTotalBpf = oldTotalBpf.add(newBpf);\n            firstEndBpf = s.fFirst;\n        }\n\n        // Distribute the rest of the Fertilized Beans\n        s.bpf = uint128(newTotalBpf); // SafeCast unnecessary here.\n        newFertilized = newFertilized.add(newBpf.mul(s.activeFertilizer));\n        s.fertilizedIndex = s.fertilizedIndex.add(newFertilized);\n    }\n\n    /**\n     * @dev Distributes Beans to the Field. The next `amount` Pods in the Pod Line\n     * become Harvestable.\n     */\n    function rewardToHarvestable(uint256 amount)\n        internal    \n        returns (uint256 newHarvestable)\n    {\n        uint256 notHarvestable = s.f.pods - s.f.harvestable; // Note: SafeMath is redundant here.\n        newHarvestable = amount.div(HARVEST_DENOMINATOR);\n        newHarvestable = newHarvestable > notHarvestable\n            ? notHarvestable\n            : newHarvestable;\n        s.f.harvestable = s.f.harvestable.add(newHarvestable);\n    }\n\n    /**\n     * @dev Distribute Beans to the Silo. Stalk & Earned Beans are created here;\n     * Farmers can claim them through {SiloFacet.plant}.\n     */\n    function rewardToSilo(uint256 amount) internal {\n        // NOTE that the Beans have already been minted (see {rewardBeans}).\n        //\n        // `s.earnedBeans` is an accounting mechanism that tracks the total number\n        // of Earned Beans that are claimable by Stalkholders. When claimed via `plant()`,\n        // it is decremented. See {Silo.sol:_plant} for more details.\n        // SafeCast not necessary as `seasonStalk.toUint128();` will fail if amount > type(uint128).max.\n        s.earnedBeans = s.earnedBeans.add(amount.toUint128());\n\n        // Mint Stalk (as Earned Stalk). Farmers can claim their Earned Stalk via {SiloFacet.sol:plant}.\n        //\n        // Stalk is created here, rather than in {rewardBeans}, because only\n        // Beans that are allocated to the Silo will receive Stalk.\n        // Constant is used here rather than s.ss[BEAN].stalkIssuedPerBdv\n        // for gas savings.\n        s.s.stalk = s.s.stalk.add(amount.mul(C.STALK_PER_BEAN));\n\n        // removed at ebip-13. Will be replaced upon seed gauge BIP.\n        // s.newEarnedStalk = seasonStalk.toUint128();\n        // s.vestingPeriodRoots = 0;\n\n        s.siloBalances[C.BEAN].deposited = s\n            .siloBalances[C.BEAN]\n            .deposited\n            .add(amount.toUint128());\n\n        // SafeCast not necessary as the block above will fail if amount > type(uint128).max.\n        s.siloBalances[C.BEAN].depositedBdv = s\n            .siloBalances[C.BEAN]\n            .depositedBdv\n            .add(uint128(amount));\n    }\n\n    //////////////////// SET SOIL ////////////////////\n\n    /**\n     * @param newHarvestable The number of Beans that were minted to the Field.\n     * @param caseId The current Weather Case.\n     * @dev When above peg, Beanstalk wants to gauge demand for Soil. Here it\n     * issues the amount of Soil that would result in the same number of Pods\n     * as became Harvestable during the last Season.\n     * \n     * When the Pod Rate is high, Beanstalk issues less Soil.\n     * When the Pod Rate is low, Beanstalk issues more Soil.\n     */\n    function setSoilAbovePeg(uint256 newHarvestable, uint256 caseId) internal {\n        uint256 newSoil = newHarvestable.mul(100).div(100 + s.w.t);\n        if (caseId >= 24) {\n            newSoil = newSoil.mul(SOIL_COEFFICIENT_HIGH).div(C.PRECISION); // high podrate\n        } else if (caseId < 8) {\n            newSoil = newSoil.mul(SOIL_COEFFICIENT_LOW).div(C.PRECISION); // low podrate\n        }\n        setSoil(newSoil);\n    }\n\n    /**\n    * @param twaDeltaB The time weighted average precalculated deltaB \n    * from {Oracle.stepOracle} at the start of the season.\n    * @dev When below peg, Beanstalk wants to issue debt for beans to be sown(burned),\n    * and removed from the supply, pushing the price up. To avoid soil over issuance,\n    * Beanstalk can read inter-block MEV manipulation resistant instantaneous reserves\n    * for whitelisted Well LP tokens via Multi Flow, compare it to the twaDeltaB calculated\n    * at the start of the season, and pick the minimum of the two.\n    */\n    function setSoilBelowPeg(int256 twaDeltaB) internal {\n\n        // Calculate deltaB from instantaneous reserves of all whitelisted Wells.\n        int256 instDeltaB;\n        address[] memory tokens = LibWhitelistedTokens.getWhitelistedWellLpTokens();\n        for (uint256 i = 0; i < tokens.length; i++) {\n            int256 wellInstDeltaB = LibWellMinting.instantaneousDeltaB(tokens[i]);\n            instDeltaB = instDeltaB.add(wellInstDeltaB);\n        }\n\n        // Set new soil.\n        setSoil(Math.min(uint256(-twaDeltaB), uint256(-instDeltaB)));\n    }\n\n    /**\n    * @param amount The new amount of Soil available.\n    * @dev Sets the amount of Soil available and emits a Soil event.\n    */\n    function setSoil(uint256 amount) internal {\n        s.f.soil = amount.toUint128();\n        emit Soil(s.season.current, amount.toUint128());\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibFertilizer, SafeMath} from \"contracts/libraries/LibFertilizer.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {Oracle, C} from \"./Oracle.sol\";\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SignedSafeMath} from \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport {LibWellMinting} from \"contracts/libraries/Minting/LibWellMinting.sol\";\nimport {LibWhitelistedTokens} from \"contracts/libraries/Silo/LibWhitelistedTokens.sol\";\n\n/**\n * @title Sun\n * @author Publius\n * @notice Sun controls the minting of new Beans to Fertilizer, the Field, and the Silo.\n */\ncontract Sun is Oracle {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using SignedSafeMath for int256;\n\n    /// @dev When Fertilizer is Active, it receives 1/3 of new Bean mints.\n    uint256 private constant FERTILIZER_DENOMINATOR = 3;\n\n    /// @dev After Fertilizer, Harvestable Pods receive 1/2 of new Bean mints. \n    uint256 private constant HARVEST_DENOMINATOR = 2;\n\n    /// @dev When the Pod Rate is high, issue less Soil.\n    uint256 private constant SOIL_COEFFICIENT_HIGH = 0.5e18;\n    \n    /// @dev When the Pod Rate is low, issue more Soil.\n    uint256 private constant SOIL_COEFFICIENT_LOW = 1.5e18;\n\n    /**\n     * @notice Emitted during Sunrise when Beans are distributed to the Field, the Silo, and Fertilizer.\n     * @param season The Season in which Beans were distributed.\n     * @param toField The number of Beans distributed to the Field.\n     * @param toSilo The number of Beans distributed to the Silo.\n     * @param toFertilizer The number of Beans distributed to Fertilizer.\n     */\n    event Reward(\n        uint32 indexed season,\n        uint256 toField,\n        uint256 toSilo,\n        uint256 toFertilizer\n    );\n\n    /**\n     * @notice Emitted during Sunrise when Beanstalk adjusts the amount of available Soil.\n     * @param season The Season in which Soil was adjusted.\n     * @param soil The new amount of Soil available.\n     */\n    event Soil(\n        uint32 indexed season,\n        uint256 soil\n    );\n\n    //////////////////// SUN INTERNAL ////////////////////\n    \n    /**\n     * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.\n     * @param caseId Pre-calculated Weather case from {Weather.calcCaseId}.\n     */\n    function stepSun(int256 deltaB, uint256 caseId) internal {\n        // Above peg\n        if (deltaB > 0) {\n            uint256 newHarvestable = rewardBeans(uint256(deltaB));\n            setSoilAbovePeg(newHarvestable, caseId);\n            s.season.abovePeg = true;\n        } \n\n        // Below peg\n        else {\n            setSoilBelowPeg(deltaB);\n            s.season.abovePeg = false;\n        }\n    }\n\n    //////////////////// REWARD BEANS ////////////////////\n\n    /**\n     * @dev Mints and distributes Beans to Fertilizer, the Field, and the Silo.\n     */\n    function rewardBeans(uint256 newSupply) internal returns (uint256 newHarvestable) {\n        uint256 newFertilized;\n        \n        C.bean().mint(address(this), newSupply);\n\n        // Distribute first to Fertilizer if some Fertilizer are active\n        if (s.season.fertilizing) {\n            newFertilized = rewardToFertilizer(newSupply);\n            newSupply = newSupply.sub(newFertilized);\n        }\n\n        // Distribute next to the Field if some Pods are still outstanding\n        if (s.f.harvestable < s.f.pods) {\n            newHarvestable = rewardToHarvestable(newSupply);\n            newSupply = newSupply.sub(newHarvestable);\n        }\n\n        // Distribute remainder to the Silo\n        rewardToSilo(newSupply);\n\n        emit Reward(s.season.current, newHarvestable, newSupply, newFertilized);\n    }\n\n    /**\n     * @dev Distributes Beans to Fertilizer.\n     */\n    function rewardToFertilizer(uint256 amount)\n        internal\n        returns (uint256 newFertilized)\n    {\n        // 1/3 of new Beans being minted\n        uint256 maxNewFertilized = amount.div(FERTILIZER_DENOMINATOR);\n\n        // Get the new Beans per Fertilizer and the total new Beans per Fertilizer\n        uint256 newBpf = maxNewFertilized.div(s.activeFertilizer);\n        uint256 oldTotalBpf = s.bpf;\n        uint256 newTotalBpf = oldTotalBpf.add(newBpf);\n\n        // Get the end Beans per Fertilizer of the first Fertilizer to run out.\n        uint256 firstEndBpf = s.fFirst;\n\n        // If the next fertilizer is going to run out, then step BPF according\n        while(newTotalBpf >= firstEndBpf) {\n            // Calculate BPF and new Fertilized when the next Fertilizer ID ends\n            newBpf = firstEndBpf.sub(oldTotalBpf);\n            newFertilized = newFertilized.add(newBpf.mul(s.activeFertilizer));\n\n            // If there is no more fertilizer, end\n            if (!LibFertilizer.pop()) {\n                s.bpf = uint128(firstEndBpf); // SafeCast unnecessary here.\n                s.fertilizedIndex = s.fertilizedIndex.add(newFertilized);\n                require(s.fertilizedIndex == s.unfertilizedIndex, \"Paid != owed\");\n                return newFertilized;\n            }\n\n            // Calculate new Beans per Fertilizer values\n            newBpf = maxNewFertilized.sub(newFertilized).div(s.activeFertilizer);\n            oldTotalBpf = firstEndBpf;\n            newTotalBpf = oldTotalBpf.add(newBpf);\n            firstEndBpf = s.fFirst;\n        }\n\n        // Distribute the rest of the Fertilized Beans\n        s.bpf = uint128(newTotalBpf); // SafeCast unnecessary here.\n        newFertilized = newFertilized.add(newBpf.mul(s.activeFertilizer));\n        s.fertilizedIndex = s.fertilizedIndex.add(newFertilized);\n    }\n\n    /**\n     * @dev Distributes Beans to the Field. The next `amount` Pods in the Pod Line\n     * become Harvestable.\n     */\n    function rewardToHarvestable(uint256 amount)\n        internal    \n        returns (uint256 newHarvestable)\n    {\n        uint256 notHarvestable = s.f.pods - s.f.harvestable; // Note: SafeMath is redundant here.\n        newHarvestable = amount.div(HARVEST_DENOMINATOR);\n        newHarvestable = newHarvestable > notHarvestable\n            ? notHarvestable\n            : newHarvestable;\n        s.f.harvestable = s.f.harvestable.add(newHarvestable);\n    }\n\n    /**\n     * @dev Distribute Beans to the Silo. Stalk & Earned Beans are created here;\n     * Farmers can claim them through {SiloFacet.plant}.\n     */\n    function rewardToSilo(uint256 amount) internal {\n        // NOTE that the Beans have already been minted (see {rewardBeans}).\n        //\n        // `s.earnedBeans` is an accounting mechanism that tracks the total number\n        // of Earned Beans that are claimable by Stalkholders. When claimed via `plant()`,\n        // it is decremented. See {Silo.sol:_plant} for more details.\n        // SafeCast not necessary as `seasonStalk.toUint128();` will fail if amount > type(uint128).max.\n        s.earnedBeans = s.earnedBeans.add(amount.toUint128());\n\n        // Mint Stalk (as Earned Stalk). Farmers can claim their Earned Stalk via {SiloFacet.sol:plant}.\n        //\n        // Stalk is created here, rather than in {rewardBeans}, because only\n        // Beans that are allocated to the Silo will receive Stalk.\n        // Constant is used here rather than s.ss[BEAN].stalkIssuedPerBdv\n        // for gas savings.\n        s.s.stalk = s.s.stalk.add(amount.mul(C.STALK_PER_BEAN));\n\n        // removed at ebip-13. Will be replaced upon seed gauge BIP.\n        // s.newEarnedStalk = seasonStalk.toUint128();\n        // s.vestingPeriodRoots = 0;\n\n        s.siloBalances[C.BEAN].deposited = s\n            .siloBalances[C.BEAN]\n            .deposited\n            .add(amount.toUint128());\n\n        // SafeCast not necessary as the block above will fail if amount > type(uint128).max.\n        s.siloBalances[C.BEAN].depositedBdv = s\n            .siloBalances[C.BEAN]\n            .depositedBdv\n            .add(uint128(amount));\n    }\n\n    //////////////////// SET SOIL ////////////////////\n\n    /**\n     * @param newHarvestable The number of Beans that were minted to the Field.\n     * @param caseId The current Weather Case.\n     * @dev When above peg, Beanstalk wants to gauge demand for Soil. Here it\n     * issues the amount of Soil that would result in the same number of Pods\n     * as became Harvestable during the last Season.\n     * \n     * When the Pod Rate is high, Beanstalk issues less Soil.\n     * When the Pod Rate is low, Beanstalk issues more Soil.\n     */\n    function setSoilAbovePeg(uint256 newHarvestable, uint256 caseId) internal {\n        uint256 newSoil = newHarvestable.mul(100).div(100 + s.w.t);\n        if (caseId >= 24) {\n            newSoil = newSoil.mul(SOIL_COEFFICIENT_HIGH).div(C.PRECISION); // high podrate\n        } else if (caseId < 8) {\n            newSoil = newSoil.mul(SOIL_COEFFICIENT_LOW).div(C.PRECISION); // low podrate\n        }\n        setSoil(newSoil);\n    }\n\n    /**\n    * @param twaDeltaB The time weighted average precalculated deltaB \n    * from {Oracle.stepOracle} at the start of the season.\n    * @dev When below peg, Beanstalk wants to issue debt for beans to be sown(burned),\n    * and removed from the supply, pushing the price up. To avoid soil over issuance,\n    * Beanstalk can read inter-block MEV manipulation resistant instantaneous reserves\n    * for whitelisted Well LP tokens via Multi Flow, compare it to the twaDeltaB calculated\n    * at the start of the season, and pick the minimum of the two.\n    */\n    function setSoilBelowPeg(int256 twaDeltaB) internal {\n\n        // Calculate deltaB from instantaneous reserves of all whitelisted Wells.\n        int256 instDeltaB;\n        address[] memory tokens = LibWhitelistedTokens.getWhitelistedWellLpTokens();\n        for (uint256 i = 0; i < tokens.length; i++) {\n            int256 wellInstDeltaB = LibWellMinting.instantaneousDeltaB(tokens[i]);\n            instDeltaB = instDeltaB.add(wellInstDeltaB);\n        }\n\n        // Set new soil.\n        setSoil(Math.min(uint256(-twaDeltaB), uint256(-instDeltaB)));\n    }\n\n    /**\n    * @param amount The new amount of Soil available.\n    * @dev Sets the amount of Soil available and emits a Soil event.\n    */\n    function setSoil(uint256 amount) internal {\n        s.f.soil = amount.toUint128();\n        emit Soil(s.season.current, amount.toUint128());\n    }\n}"
    }
  ]
}