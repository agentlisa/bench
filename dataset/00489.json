{
  "Title": "M-2: Position Manager providing the wrong strike when storing user's position data",
  "Content": "# Issue M-2: Position Manager providing the wrong strike when storing user's position data \n\nSource: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/23 \n\nThe protocol has acknowledged this issue.\n\n## Found by \njennifer37, saidam017\n## Summary\n\nWhen users mint position using `PositionManager`, users can provide strike that want to be used for the trade. However, if the provided strike data is not exactly the same with IG's current strike, the minted position's will be permanently stuck inside the `PositionManager`'s contract.\n\n## Vulnerability Detail\n\nWhen `mint` is called inside `PositionManager`, it will calculate the premium, transfer the required base token, and eventually call `dvp.mint`, providing the user's provided information.\n\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/periphery/PositionManager.sol#L129-L137\n\n```solidity\n    function mint(\n        IPositionManager.MintParams calldata params\n    ) external override returns (uint256 tokenId, uint256 premium) {\n        IDVP dvp = IDVP(params.dvpAddr);\n\n        if (params.tokenId != 0) {\n            tokenId = params.tokenId;\n            ManagedPosition storage position = _positions[tokenId];\n\n            if (ownerOf(tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            // Check token compatibility:\n            if (position.dvpAddr != params.dvpAddr || position.strike != params.strike) {\n                revert InvalidTokenID();\n            }\n            Epoch memory epoch = dvp.getEpoch();\n            if (position.expiry != epoch.current) {\n                revert PositionExpired();\n            }\n        }\n        if ((params.notionalUp > 0 && params.notionalDown > 0) && (params.notionalUp != params.notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        uint256 obtainedPremium;\n        uint256 fee;\n        (obtainedPremium, fee) = dvp.premium(params.strike, params.notionalUp, params.notionalDown);\n\n        // Transfer premium:\n        // NOTE: The PositionManager is just a middleman between the user and the DVP\n        IERC20 baseToken = IERC20(dvp.baseToken());\n        baseToken.safeTransferFrom(msg.sender, address(this), obtainedPremium);\n\n        // Premium already include fee\n        baseToken.safeApprove(params.dvpAddr, obtainedPremium);\n\n==>     premium = dvp.mint(\n            address(this),\n            params.strike,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedPremium,\n            params.maxSlippage,\n            params.nftAccessTokenId\n        );\n\n        // ....\n    }\n```\n\nInside `dvp.mint`, in this case, IG contract's `mint`, will use `financeParameters.currentStrike` instead of the user's provided strike: \nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/IG.sol#L75\n\n```solidity\n    /// @inheritdoc IDVP\n    function mint(\n        address recipient,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown,\n        uint256 expectedPremium,\n        uint256 maxSlippage,\n        uint256 nftAccessTokenId\n    ) external override returns (uint256 premium_) {\n        strike;\n        _checkNFTAccess(nftAccessTokenId, recipient, amountUp + amountDown);\n        Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n\n==>     premium_ = _mint(recipient, financeParameters.currentStrike, amount_, expectedPremium, maxSlippage);\n    }\n```\n\nBut when storing the position's information inside `PositionManager`, it uses user's provided strike instead of IG's current strike : \nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/periphery/PositionManager.sol#L151-L160\n\n```solidity\n    function mint(\n        IPositionManager.MintParams calldata params\n    ) external override returns (uint256 tokenId, uint256 premium) {\n        // ...\n\n        if (obtainedPremium > premium) {\n            baseToken.safeTransferFrom(address(this), msg.sender, obtainedPremium - premium);\n        }\n\n        if (params.tokenId == 0) {\n            // Mint token:\n            tokenId = _nextId++;\n            _mint(params.recipient, tokenId);\n\n            Epoch memory epoch = dvp.getEpoch();\n\n            // Save position:\n            _positions[tokenId] = ManagedPosition({\n                dvpAddr: params.dvpAddr,\n==>             strike: params.strike,\n                expiry: epoch.current,\n                premium: premium,\n                leverage: (params.notionalUp + params.notionalDown) / premium,\n                notionalUp: params.notionalUp,\n                notionalDown: params.notionalDown,\n                cumulatedPayoff: 0\n            });\n        } else {\n            ManagedPosition storage position = _positions[tokenId];\n            // Increase position:\n            position.premium += premium;\n            position.notionalUp += params.notionalUp;\n            position.notionalDown += params.notionalDown;\n            /* NOTE:\n                When, within the same epoch, a user wants to buy, sell partially\n                and then buy again, the leverage computation can fail due to\n                decreased notional; in order to avoid this issue, we have to\n                also adjust (decrease) the premium in the burn flow.\n             */\n            position.leverage = (position.notionalUp + position.notionalDown) / position.premium;\n        }\n\n        emit BuyDVP(tokenId, _positions[tokenId].expiry, params.notionalUp + params.notionalDown);\n        emit Buy(params.dvpAddr, _positions[tokenId].expiry, premium, params.recipient);\n    }\n```\n\n## PoC\n\nAdd the following test to `PositionManagerTest` contract : \n\n```solidity\n    function testMintAndBurnFail() public {\n        (uint256 tokenId, ) = initAndMint();\n        bytes4 PositionNotFound = bytes4(keccak256(\"PositionNotFound()\"));\n\n        vm.prank(alice);\n        vm.expectRevert(PositionNotFound);\n        pm.sell(\n            IPositionManager.SellParams({\n                tokenId: tokenId,\n                notionalUp: 10 ether,\n                notionalDown: 0,\n                expectedMarketValue: 0,\n                maxSlippage: 0.1e18\n            })\n        );\n    }\n```\n\nModify `initAndMint` function to the following : \n\n```solidity\n    function initAndMint() private returns (uint256 tokenId, IG ig) {\n        vm.startPrank(admin);\n        ig = new IG(address(vault), address(ap));\n        ig.grantRole(ig.ROLE_ADMIN(), admin);\n        ig.grantRole(ig.ROLE_EPOCH_ROLLER(), admin);\n        vault.grantRole(vault.ROLE_ADMIN(), admin);\n        vault.setAllowedDVP(address(ig));\n\n        MarketOracle mo = MarketOracle(ap.marketOracle());\n\n        mo.setDelay(ig.baseToken(), ig.sideToken(), ig.getEpoch().frequency, 0, true);\n\n        Utils.skipDay(true, vm);\n        ig.rollEpoch();\n        vm.stopPrank();\n\n        uint256 strike = ig.currentStrike();\n\n        (uint256 expectedMarketValue, ) = ig.premium(0, 10 ether, 0);\n        TokenUtils.provideApprovedTokens(admin, baseToken, DEFAULT_SENDER, address(pm), expectedMarketValue, vm);\n        // NOTE: somehow, the sender is something else without this prank...\n        vm.prank(DEFAULT_SENDER);\n        (tokenId, ) = pm.mint(\n            IPositionManager.MintParams({\n                dvpAddr: address(ig),\n                notionalUp: 10 ether,\n                notionalDown: 0,\n                strike: strike + 1,\n                recipient: alice,\n                tokenId: 0,\n                expectedPremium: expectedMarketValue,\n                maxSlippage: 0.1e18,\n                nftAccessTokenId: 0\n            })\n        );\n        assertGe(1, tokenId);\n        assertGe(1, pm.totalSupply());\n    }\n```\n\nRun the test : \n\n```sh\nforge test --match-contract PositionManagerTest --match-test testMintAndBurnFail -vvv\n```\n\n## Impact\n\nIf the provided strike data does not match IG's current strike price, the user's minted position using `PositionManager` will be stuck and cannot be burned. This happens because when burn is called and `position.strike` is provided, it will revert as it cannot find the corresponding positions inside IG contract.\n\nThis issue directly risking user's funds, consider a scenario where users mint a position near the end of the rolling epoch, providing the old epoch's current price. However, when the user's transaction is executed, the epoch is rolled and new epoch's current price is used, causing the mentioned issue to occur, and users' positions and funds will be stuck.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/periphery/PositionManager.sol#L129-L137\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/IG.sol#L75\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/periphery/PositionManager.sol#L151-L160\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen storing user position data inside PositionManager, query IG's current price and use it instead.\n\n\n```diff\n    function mint(\n        IPositionManager.MintParams calldata params\n    ) external override returns (uint256 tokenId, uint256 premium) {\n        // ...\n\n        if (params.tokenId == 0) {\n            // Mint token:\n            tokenId = _nextId++;\n            _mint(params.recipient, tokenId);\n\n            Epoch memory epoch = dvp.getEpoch();\n+          uint256 currentStrike = dvp.currentStrike();\n\n            // Save position:\n            _positions[tokenId] = ManagedPosition({\n                dvpAddr: params.dvpAddr,\n-                strike: params.strike,\n+                strike: currentStrike,\n                expiry: epoch.current,\n                premium: premium,\n                leverage: (params.notionalUp + params.notionalDown) / premium,\n                notionalUp: params.notionalUp,\n                notionalDown: params.notionalDown,\n                cumulatedPayoff: 0\n            });\n        } else {\n            ManagedPosition storage position = _positions[tokenId];\n            // Increase position:\n            position.premium += premium;\n            position.notionalUp += params.notionalUp;\n            position.notionalDown += params.notionalDown;\n            /* NOTE:\n                When, within the same epoch, a user wants to buy, sell partially\n                and then buy again, the leverage computation can fail due to\n                decreased notional; in order to avoid this issue, we have to\n                also adjust (decrease) the premium in the burn flow.\n             */\n            position.leverage = (position.notionalUp + position.notionalDown) / position.premium;\n        }\n\n        emit BuyDVP(tokenId, _positions[tokenId].expiry, params.notionalUp + params.notionalDown);\n        emit Buy(params.dvpAddr, _positions[tokenId].expiry, premium, params.recipient);\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> low, because it is user error to provide incorrect strike.\n\n**takarez** commented:\n>  valid, this seem valid; high(2)\n\n\n\n**metadato-eth**\n\nSAME AS 65\n\n**said017**\n\nEscalate\n\nThis is not necesseraly require user mistakes, consider a scenario where users mint a position near the end of the rolling epoch, providing the old epoch's current price. However, when the user's transaction is executed, the epoch is rolled and new epoch's current price is used, causing the mentioned issue to occur.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This is not necesseraly require user mistakes, consider a scenario where users mint a position near the end of the rolling epoch, providing the old epoch's current price. However, when the user's transaction is executed, the epoch is rolled and new epoch's current price is used, causing the mentioned issue to occur.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\n> Escalate\n> \n> This is not necesseraly require user mistakes, consider a scenario where users mint a position near the end of the rolling epoch, providing the old epoch's current price. However, when the user's transaction is executed, the epoch is rolled and new epoch's current price is used, causing the mentioned issue to occur.\n\nThis scenario is indeed possible, but it must be a very big coincidence. Considering also the [comment](https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/65#issuecomment-1997062797) from the sponsor then for me the report is more Low than Medium. \n\nHowever, when the Judge resolves the report he has to consider that only this report and #75 explain the scenario, which is not a \"user mistake\".\n\n**Czar102**\n\n@cvetanovv could you elaborate on why do you think this scenario is so improbable (\"a very big coincidence\")?\n\n@panprog can you elaborate on your comment on this issue?\n> low, because it is user error to provide incorrect strike.\n\nWhat do you mean by incorrect? (it may be a dumb question but I'm trying to understand why is there expectation of providing data in line with some contract data instead of reading the contract data)\n\n**panprog**\n\n@Czar102 \nWhen user opens a position via PositionManager, he provides a strike price for the position: this is not any price, it's strictly the price that the protocol supports, currently each epoch has exactly 1 correct strike. Meaning in most cases the loss will simply be by user mistake (who provides strike which protocol doesn't support), and issues from user mistake is invalid by sherlock rules.\n\nThere is another possibility mentioned in the report: when the user opens position at the end of the epoch, providing this epoch's strike, but transaction executes much later, after the next epoch (which has a different correct strike) starts. In such case, the user indeed will lose his funds while providing the correct data. The probability of this is extremely low (prices at the end of epoch are very negatively skewed against the user, so it's very unprofitable to trade at the end of the epoch, epoch is rolled to the next one by the admin, and it doesn't happen instantly, can also take some time, additionally the new epoch's premium to be paid will likely be higher than in previous epoch due to time premium being high at the start of new epoch, so the transaction is also likely to revert due to not enough allowance for the expected premium). But yeah, it's still possible that it happens and in this case it's valid, still low severity or boderline.\n\n**cvetanovv**\n\nBasically, these 4 reports are invalid because of a \"user error\". But two of the reports(23 and 75) mention a case where I quote from this report: \"users mint a position near the end of the rolling epoch, providing the old epoch's current price. However, when the user's transaction is executed, the epoch is rolled and new epoch's current price is used\"\nBy the word \"coincidence\" I mean exactly this scenario which is described only in this report and in #75 \n\n**said017**\n\nThe impact of this issue is a direct freeze of funds, so I'm not sure why it is considered low severity. It is considered best practice to never assume the execution time of a transaction. It is possible that when a transaction is requested, it is not much closer to the epoch change, but executed after the epoch change. So high severity is fair. And this issue has been fixed by the sponsor, so I'm not sure why there is a 'won't fix' flag here.\nhttps://github.com/dverso/smilee-v2-contracts/commit/7226eee8ec1c454ef9f7386b77428a41d91238b4\n\n**Czar102**\n\nIt seems that despite this scenario wouldn't happen often, a severe loss may be inflicted.\n\nI'm planning to consider this and #75 valid Medium severity duplicates and accept the escalation.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [said017](https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/23/#issuecomment-2006264554): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/180",
  "Code": [
    {
      "filename": "smilee-v2-contracts/src/periphery/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.15;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IDVP} from \"../interfaces/IDVP.sol\";\nimport {IPositionManager} from \"../interfaces/IPositionManager.sol\";\nimport {Position} from \"../lib/Position.sol\";\nimport {Epoch} from \"../lib/EpochController.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PositionManager is ERC721Enumerable, Ownable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n    struct ManagedPosition {\n        address dvpAddr;\n        uint256 strike;\n        uint256 expiry;\n        uint256 notionalUp;\n        uint256 notionalDown;\n        uint256 premium;\n        uint256 leverage;\n        uint256 cumulatedPayoff;\n    }\n\n    /// @dev Stored data by position ID\n    mapping(uint256 => ManagedPosition) internal _positions;\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint256 private _nextId;\n\n    // Used by TheGraph for frontend needs:\n    event Buy(address dvp, uint256 epoch, uint256 premium, address creditor);\n    event Sell(address dvp, uint256 epoch, uint256 payoff);\n\n    error CantBurnMoreThanMinted();\n    error InvalidTokenID();\n    error NotOwner();\n    error PositionExpired();\n    error AsymmetricAmount();\n\n    constructor() ERC721Enumerable() ERC721(\"Smilee V0 Trade Positions\", \"SMIL-V0-TRAD\") Ownable() {\n        _nextId = 1;\n    }\n\n    modifier isOwner(uint256 tokenId) {\n        if (ownerOf(tokenId) != msg.sender) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    // modifier isAuthorizedForToken(uint256 tokenId) {\n    //     if (!_isApprovedOrOwner(msg.sender, tokenId)) {\n    //         revert NotApproved();\n    //     }\n    //     _;\n    // }\n\n    /// @inheritdoc IPositionManager\n    function positionDetail(uint256 tokenId) external view override returns (IPositionManager.PositionDetail memory) {\n        ManagedPosition memory position = _positions[tokenId];\n        if (position.dvpAddr == address(0)) {\n            revert InvalidTokenID();\n        }\n\n        IDVP dvp = IDVP(position.dvpAddr);\n\n        Epoch memory epoch = dvp.getEpoch();\n\n        return\n            IPositionManager.PositionDetail({\n                dvpAddr: position.dvpAddr,\n                baseToken: dvp.baseToken(),\n                sideToken: dvp.sideToken(),\n                dvpFreq: epoch.frequency,\n                dvpType: dvp.optionType(),\n                strike: position.strike,\n                expiry: position.expiry,\n                premium: position.premium,\n                leverage: position.leverage,\n                notionalUp: position.notionalUp,\n                notionalDown: position.notionalDown,\n                cumulatedPayoff: position.cumulatedPayoff\n            });\n    }\n\n    /// @inheritdoc IPositionManager\n    function mint(\n        IPositionManager.MintParams calldata params\n    ) external override returns (uint256 tokenId, uint256 premium) {\n        IDVP dvp = IDVP(params.dvpAddr);\n\n        if (params.tokenId != 0) {\n            tokenId = params.tokenId;\n            ManagedPosition storage position = _positions[tokenId];\n\n            if (ownerOf(tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            // Check token compatibility:\n            if (position.dvpAddr != params.dvpAddr || position.strike != params.strike) {\n                revert InvalidTokenID();\n            }\n            Epoch memory epoch = dvp.getEpoch();\n            if (position.expiry != epoch.current) {\n                revert PositionExpired();\n            }\n        }\n        if ((params.notionalUp > 0 && params.notionalDown > 0) && (params.notionalUp != params.notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        uint256 obtainedPremium;\n        uint256 fee;\n        (obtainedPremium, fee) = dvp.premium(params.strike, params.notionalUp, params.notionalDown);\n\n        // Transfer premium:\n        // NOTE: The PositionManager is just a middleman between the user and the DVP\n        IERC20 baseToken = IERC20(dvp.baseToken());\n        baseToken.safeTransferFrom(msg.sender, address(this), obtainedPremium);\n\n        // Premium already include fee\n        baseToken.safeApprove(params.dvpAddr, obtainedPremium);\n\n        premium = dvp.mint(\n            address(this),\n            params.strike,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedPremium,\n            params.maxSlippage,\n            params.nftAccessTokenId\n        );\n\n        if (obtainedPremium > premium) {\n            baseToken.safeTransferFrom(address(this), msg.sender, obtainedPremium - premium);\n        }\n\n        if (params.tokenId == 0) {\n            // Mint token:\n            tokenId = _nextId++;\n            _mint(params.recipient, tokenId);\n\n            Epoch memory epoch = dvp.getEpoch();\n\n            // Save position:\n            _positions[tokenId] = ManagedPosition({\n                dvpAddr: params.dvpAddr,\n                strike: params.strike,\n                expiry: epoch.current,\n                premium: premium,\n                leverage: (params.notionalUp + params.notionalDown) / premium,\n                notionalUp: params.notionalUp,\n                notionalDown: params.notionalDown,\n                cumulatedPayoff: 0\n            });\n        } else {\n            ManagedPosition storage position = _positions[tokenId];\n            // Increase position:\n            position.premium += premium;\n            position.notionalUp += params.notionalUp;\n            position.notionalDown += params.notionalDown;\n            /* NOTE:\n                When, within the same epoch, a user wants to buy, sell partially\n                and then buy again, the leverage computation can fail due to\n                decreased notional; in order to avoid this issue, we have to\n                also adjust (decrease) the premium in the burn flow.\n             */\n            position.leverage = (position.notionalUp + position.notionalDown) / position.premium;\n        }\n\n        emit BuyDVP(tokenId, _positions[tokenId].expiry, params.notionalUp + params.notionalDown);\n        emit Buy(params.dvpAddr, _positions[tokenId].expiry, premium, params.recipient);\n    }\n\n    function payoff(\n        uint256 tokenId,\n        uint256 notionalUp,\n        uint256 notionalDown\n    ) external view returns (uint256 payoff_, uint256 fee) {\n        ManagedPosition storage position = _positions[tokenId];\n        return IDVP(position.dvpAddr).payoff(position.expiry, position.strike, notionalUp, notionalDown);\n    }\n\n    function sell(SellParams calldata params) external isOwner(params.tokenId) returns (uint256 payoff_) {\n        payoff_ = _sell(\n            params.tokenId,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedMarketValue,\n            params.maxSlippage\n        );\n    }\n\n    function sellAll(SellParams[] calldata params) external returns (uint256 totalPayoff_) {\n        uint256 paramsLength = params.length;\n        for (uint256 i = 0; i < paramsLength; i++) {\n            if (ownerOf(params[i].tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            totalPayoff_ += _sell(\n                params[i].tokenId,\n                params[i].notionalUp,\n                params[i].notionalDown,\n                params[i].expectedMarketValue,\n                params[i].maxSlippage\n            );\n        }\n    }\n\n    function _sell(\n        uint256 tokenId,\n        uint256 notionalUp,\n        uint256 notionalDown,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) internal returns (uint256 payoff_) {\n        ManagedPosition storage position = _positions[tokenId];\n        // NOTE: as the positions within the DVP are all of the PositionManager, we must replicate this check here.\n        if (notionalUp > position.notionalUp || notionalDown > position.notionalDown) {\n            revert CantBurnMoreThanMinted();\n        }\n\n        if ((notionalUp > 0 && notionalDown > 0) && (notionalUp != notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        // NOTE: the DVP already checks that the burned notional is lesser or equal to the position notional.\n        // NOTE: the payoff is transferred directly from the DVP\n        payoff_ = IDVP(position.dvpAddr).burn(\n            position.expiry,\n            msg.sender,\n            position.strike,\n            notionalUp,\n            notionalDown,\n            expectedMarketValue,\n            maxSlippage\n        );\n\n        // NOTE: premium fix for the leverage issue annotated in the mint flow.\n        // notional : position.notional = fix : position.premium\n        uint256 premiumFix = ((notionalUp + notionalDown) * position.premium) /\n            (position.notionalUp + position.notionalDown);\n        position.premium -= premiumFix;\n        position.cumulatedPayoff += payoff_;\n        position.notionalUp -= notionalUp;\n        position.notionalDown -= notionalDown;\n\n        if (position.notionalUp == 0 && position.notionalDown == 0) {\n            delete _positions[tokenId];\n            _burn(tokenId);\n        }\n\n        emit SellDVP(tokenId, (notionalUp + notionalDown), payoff_);\n        emit Sell(position.dvpAddr, position.expiry, payoff_);\n    }\n}"
    },
    {
      "filename": "smilee-v2-contracts/src/IG.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {IDVP} from \"./interfaces/IDVP.sol\";\nimport {IDVPAccessNFT} from \"./interfaces/IDVPAccessNFT.sol\";\nimport {IFeeManager} from \"./interfaces/IFeeManager.sol\";\nimport {IMarketOracle} from \"./interfaces/IMarketOracle.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {Amount, AmountHelper} from \"./lib/Amount.sol\";\nimport {Epoch, EpochController} from \"./lib/EpochController.sol\";\nimport {Finance} from \"./lib/Finance.sol\";\nimport {FinanceParameters, FinanceIG, TimeLockedFinanceValues} from \"./lib/FinanceIG.sol\";\nimport {Notional} from \"./lib/Notional.sol\";\nimport {DVP} from \"./DVP.sol\";\nimport {EpochControls} from \"./EpochControls.sol\";\n\ncontract IG is DVP {\n    using AmountHelper for Amount;\n    using EpochController for Epoch;\n    using Notional for Notional.Info;\n\n    FinanceParameters public financeParameters;\n\n    /// @notice A flag to tell if this DVP is currently bound to check access for trade\n    bool public nftAccessFlag = false;\n\n    error NFTAccessDenied();\n\n    // Used by TheGraph for frontend needs:\n    event EpochStrike(uint256 epoch, uint256 strike);\n    event PausedForFinanceApproximation();\n    event ChangedFinanceParameters();\n\n    constructor(address vault_, address addressProvider_) DVP(vault_, false, addressProvider_) {\n        _setParameters(\n            TimeLockedFinanceValues({\n                sigmaMultiplier: 3e18,\n                tradeVolatilityUtilizationRateFactor: 2e18,\n                tradeVolatilityTimeDecay: 0.25e18,\n                volatilityPriceDiscountFactor: 0.9e18,\n                useOracleImpliedVolatility: true\n            })\n        );\n    }\n\n    /**\n        @notice Allows the contract's owner to enable or disable the nft access to trade operations\n     */\n    function setNftAccessFlag(bool flag) external {\n        _checkRole(ROLE_ADMIN);\n\n        nftAccessFlag = flag;\n    }\n\n    /// @notice Common strike price for all impermanent gain positions in this DVP, set at epoch start\n    function currentStrike() external view returns (uint256 strike_) {\n        strike_ = financeParameters.currentStrike;\n    }\n\n    /// @inheritdoc IDVP\n    function mint(\n        address recipient,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown,\n        uint256 expectedPremium,\n        uint256 maxSlippage,\n        uint256 nftAccessTokenId\n    ) external override returns (uint256 premium_) {\n        strike;\n        _checkNFTAccess(nftAccessTokenId, recipient, amountUp + amountDown);\n        Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n\n        premium_ = _mint(recipient, financeParameters.currentStrike, amount_, expectedPremium, maxSlippage);\n    }\n\n    /// @inheritdoc IDVP\n    function burn(\n        uint256 epoch,\n        address recipient,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) external override returns (uint256 paidPayoff) {\n        Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n\n        paidPayoff = _burn(epoch, recipient, strike, amount_, expectedMarketValue, maxSlippage);\n    }\n\n    /// @inheritdoc IDVP\n    function premium(\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown\n    ) public view virtual override returns (uint256 premium_, uint256 fee) {\n        strike;\n\n        uint256 price = IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken);\n        Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n\n        premium_ = _getMarketValue(financeParameters.currentStrike, amount_, true, price);\n        (fee, ) = IFeeManager(_getFeeManager()).tradeBuyFee(\n            address(this),\n            getEpoch().current,\n            amountUp + amountDown,\n            premium_,\n            _baseTokenDecimals\n        );\n        premium_ += fee;\n    }\n\n    /// @inheritdoc IDVP\n    function getUtilizationRate() public view returns (uint256) {\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n        (uint256 used, uint256 total) = liquidity.utilizationRateFactors(financeParameters.currentStrike);\n\n        return Finance.getUtilizationRate(used, total, _baseTokenDecimals);\n    }\n\n    /// @inheritdoc DVP\n    function _getMarketValue(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy,\n        uint256 swapPrice\n    ) internal view virtual override returns (uint256 marketValue) {\n        marketValue = FinanceIG.getMarketValue(\n            financeParameters,\n            amount,\n            getPostTradeVolatility(strike, amount, tradeIsBuy),\n            swapPrice,\n            IMarketOracle(_getMarketOracle()).getRiskFreeRate(baseToken),\n            _baseTokenDecimals\n        );\n    }\n\n    function notional()\n        external\n        view\n        returns (uint256 bearNotional, uint256 bullNotional, uint256 bearAvailNotional, uint256 bullAvailNotional)\n    {\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        Amount memory initial = liquidity.getInitial(financeParameters.currentStrike);\n        Amount memory available = liquidity.available(financeParameters.currentStrike);\n\n        return (initial.down, initial.up, available.down, available.up);\n    }\n\n    // NOTE: public for frontend usage\n    /**\n        @notice Get the estimated implied volatility from a given trade.\n        @param strike The trade strike.\n        @param amount The trade notional.\n        @param tradeIsBuy positive for buy, negative for sell.\n        @return sigma The estimated implied volatility.\n        @dev The oracle must provide an updated baseline volatility, computed just before the start of the epoch.\n        @dev it reverts if there's no previous epoch\n     */\n    function getPostTradeVolatility(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy\n    ) public view returns (uint256 sigma) {\n        strike;\n\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n        uint256 ur = liquidity.postTradeUtilizationRate(\n            financeParameters.currentStrike,\n            amount,\n            tradeIsBuy,\n            _baseTokenDecimals\n        );\n        uint256 t0 = getEpoch().current - getEpoch().frequency;\n\n        return FinanceIG.getPostTradeVolatility(financeParameters, ur, t0);\n    }\n\n    /// @inheritdoc DVP\n    function _deltaHedgePosition(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy\n    ) internal virtual override returns (uint256 swapPrice) {\n        uint256 oraclePrice = IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken);\n\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        // Also update the epoch volatility with the trade effect:\n        uint256 ur = liquidity.postTradeUtilizationRate(\n            financeParameters.currentStrike,\n            amount,\n            tradeIsBuy,\n            _baseTokenDecimals\n        );\n        FinanceIG.updateVolatilityOnTrade(financeParameters, oraclePrice, ur);\n\n        Amount memory availableLiquidity = liquidity.available(strike);\n        (, uint256 sideTokensAmount) = IVault(vault).balances();\n\n        int256 tokensToSwap;\n        tokensToSwap = FinanceIG.getDeltaHedgeAmount(\n            financeParameters,\n            amount,\n            tradeIsBuy,\n            oraclePrice,\n            sideTokensAmount,\n            availableLiquidity,\n            _baseTokenDecimals,\n            _sideTokenDecimals\n        );\n\n        if (tokensToSwap == 0) {\n            return oraclePrice;\n        }\n\n        // NOTE: We negate the value because the protocol will sell side tokens when `h` is positive.\n        uint256 exchangedBaseTokens = IVault(vault).deltaHedge(-tokensToSwap);\n\n        swapPrice = Finance.getSwapPrice(tokensToSwap, exchangedBaseTokens, _sideTokenDecimals, _baseTokenDecimals);\n    }\n\n    /// @inheritdoc DVP\n    function _residualPayoffPerc(\n        uint256 strike,\n        uint256 price\n    ) internal view virtual override returns (uint256, uint256) {\n        strike;\n        return FinanceIG.getPayoffPercentages(financeParameters, price);\n    }\n\n    /// @inheritdoc DVP\n    function _residualPayoff() internal view virtual override returns (uint256 residualPayoff) {\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        residualPayoff = liquidity.getAccountedPayoff(financeParameters.currentStrike).getTotal();\n    }\n\n    /// @inheritdoc DVP\n    function _accountResidualPayoffs(uint256 price) internal virtual override {\n        _accountResidualPayoff(financeParameters.currentStrike, price);\n    }\n\n    /// @inheritdoc EpochControls\n    function _afterRollEpoch() internal virtual override {\n        Epoch memory epoch = getEpoch();\n\n        financeParameters.maturity = epoch.current;\n        financeParameters.currentStrike = IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken);\n        financeParameters.internalVolatilityParameters.epochStart = epoch.current - epoch.frequency; // Not using epoch.previous because epoch may be skipped\n\n        emit EpochStrike(epoch.current, financeParameters.currentStrike);\n\n        {\n            uint256 iv = IMarketOracle(_getMarketOracle()).getImpliedVolatility(\n                baseToken,\n                sideToken,\n                financeParameters.currentStrike,\n                epoch.frequency\n            );\n            FinanceIG.updateParameters(financeParameters, iv);\n        }\n\n        super._afterRollEpoch();\n\n        if (FinanceIG.checkFinanceApprox(financeParameters)) {\n            _pause();\n            emit PausedForFinanceApproximation();\n        }\n\n        // NOTE: initial liquidity is allocated by the DVP call\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n        financeParameters.initialLiquidity = liquidity.getInitial(financeParameters.currentStrike);\n    }\n\n    /// @inheritdoc DVP\n    function _allocateLiquidity(uint256 initialCapital) internal virtual override {\n        // The initialCapital is split 50:50 on the two strategies:\n        uint256 halfInitialCapital = initialCapital / 2;\n        Amount memory allocation = Amount({up: halfInitialCapital, down: initialCapital - halfInitialCapital});\n\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        // The impermanent gain (IG) DVP only has one strike:\n        liquidity.setInitial(financeParameters.currentStrike, allocation);\n    }\n\n    /// @dev parameters must be defined in Wad\n    /// @dev aggregated in order to limit contract size\n    function setParameters(TimeLockedFinanceValues calldata params) external {\n        _checkRole(ROLE_ADMIN);\n        _setParameters(params);\n\n        emit ChangedFinanceParameters();\n    }\n\n    /// @dev parameters must be defined in Wad\n    /// @dev aggregated in order to limit contract size\n    function _setParameters(TimeLockedFinanceValues memory params) internal {\n        uint256 timeToValidity = getEpoch().timeToNextEpoch();\n        FinanceIG.updateTimeLockedParameters(financeParameters.timeLocked, params, timeToValidity);\n    }\n\n    /// @dev Checks if given trade is allowed to be made using nft.checkCap callback func\n    function _checkNFTAccess(uint256 accessTokenId, address receiver, uint256 notionalAmount) internal {\n        if (nftAccessFlag) {\n            IDVPAccessNFT nft = IDVPAccessNFT(_addressProvider.dvpAccessNFT());\n            if (accessTokenId == 0 || nft.ownerOf(accessTokenId) != receiver) {\n                revert NFTAccessDenied();\n            }\n            nft.checkCap(accessTokenId, notionalAmount);\n        }\n    }\n}"
    },
    {
      "filename": "smilee-v2-contracts/src/periphery/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.15;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IDVP} from \"../interfaces/IDVP.sol\";\nimport {IPositionManager} from \"../interfaces/IPositionManager.sol\";\nimport {Position} from \"../lib/Position.sol\";\nimport {Epoch} from \"../lib/EpochController.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PositionManager is ERC721Enumerable, Ownable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n    struct ManagedPosition {\n        address dvpAddr;\n        uint256 strike;\n        uint256 expiry;\n        uint256 notionalUp;\n        uint256 notionalDown;\n        uint256 premium;\n        uint256 leverage;\n        uint256 cumulatedPayoff;\n    }\n\n    /// @dev Stored data by position ID\n    mapping(uint256 => ManagedPosition) internal _positions;\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint256 private _nextId;\n\n    // Used by TheGraph for frontend needs:\n    event Buy(address dvp, uint256 epoch, uint256 premium, address creditor);\n    event Sell(address dvp, uint256 epoch, uint256 payoff);\n\n    error CantBurnMoreThanMinted();\n    error InvalidTokenID();\n    error NotOwner();\n    error PositionExpired();\n    error AsymmetricAmount();\n\n    constructor() ERC721Enumerable() ERC721(\"Smilee V0 Trade Positions\", \"SMIL-V0-TRAD\") Ownable() {\n        _nextId = 1;\n    }\n\n    modifier isOwner(uint256 tokenId) {\n        if (ownerOf(tokenId) != msg.sender) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    // modifier isAuthorizedForToken(uint256 tokenId) {\n    //     if (!_isApprovedOrOwner(msg.sender, tokenId)) {\n    //         revert NotApproved();\n    //     }\n    //     _;\n    // }\n\n    /// @inheritdoc IPositionManager\n    function positionDetail(uint256 tokenId) external view override returns (IPositionManager.PositionDetail memory) {\n        ManagedPosition memory position = _positions[tokenId];\n        if (position.dvpAddr == address(0)) {\n            revert InvalidTokenID();\n        }\n\n        IDVP dvp = IDVP(position.dvpAddr);\n\n        Epoch memory epoch = dvp.getEpoch();\n\n        return\n            IPositionManager.PositionDetail({\n                dvpAddr: position.dvpAddr,\n                baseToken: dvp.baseToken(),\n                sideToken: dvp.sideToken(),\n                dvpFreq: epoch.frequency,\n                dvpType: dvp.optionType(),\n                strike: position.strike,\n                expiry: position.expiry,\n                premium: position.premium,\n                leverage: position.leverage,\n                notionalUp: position.notionalUp,\n                notionalDown: position.notionalDown,\n                cumulatedPayoff: position.cumulatedPayoff\n            });\n    }\n\n    /// @inheritdoc IPositionManager\n    function mint(\n        IPositionManager.MintParams calldata params\n    ) external override returns (uint256 tokenId, uint256 premium) {\n        IDVP dvp = IDVP(params.dvpAddr);\n\n        if (params.tokenId != 0) {\n            tokenId = params.tokenId;\n            ManagedPosition storage position = _positions[tokenId];\n\n            if (ownerOf(tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            // Check token compatibility:\n            if (position.dvpAddr != params.dvpAddr || position.strike != params.strike) {\n                revert InvalidTokenID();\n            }\n            Epoch memory epoch = dvp.getEpoch();\n            if (position.expiry != epoch.current) {\n                revert PositionExpired();\n            }\n        }\n        if ((params.notionalUp > 0 && params.notionalDown > 0) && (params.notionalUp != params.notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        uint256 obtainedPremium;\n        uint256 fee;\n        (obtainedPremium, fee) = dvp.premium(params.strike, params.notionalUp, params.notionalDown);\n\n        // Transfer premium:\n        // NOTE: The PositionManager is just a middleman between the user and the DVP\n        IERC20 baseToken = IERC20(dvp.baseToken());\n        baseToken.safeTransferFrom(msg.sender, address(this), obtainedPremium);\n\n        // Premium already include fee\n        baseToken.safeApprove(params.dvpAddr, obtainedPremium);\n\n        premium = dvp.mint(\n            address(this),\n            params.strike,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedPremium,\n            params.maxSlippage,\n            params.nftAccessTokenId\n        );\n\n        if (obtainedPremium > premium) {\n            baseToken.safeTransferFrom(address(this), msg.sender, obtainedPremium - premium);\n        }\n\n        if (params.tokenId == 0) {\n            // Mint token:\n            tokenId = _nextId++;\n            _mint(params.recipient, tokenId);\n\n            Epoch memory epoch = dvp.getEpoch();\n\n            // Save position:\n            _positions[tokenId] = ManagedPosition({\n                dvpAddr: params.dvpAddr,\n                strike: params.strike,\n                expiry: epoch.current,\n                premium: premium,\n                leverage: (params.notionalUp + params.notionalDown) / premium,\n                notionalUp: params.notionalUp,\n                notionalDown: params.notionalDown,\n                cumulatedPayoff: 0\n            });\n        } else {\n            ManagedPosition storage position = _positions[tokenId];\n            // Increase position:\n            position.premium += premium;\n            position.notionalUp += params.notionalUp;\n            position.notionalDown += params.notionalDown;\n            /* NOTE:\n                When, within the same epoch, a user wants to buy, sell partially\n                and then buy again, the leverage computation can fail due to\n                decreased notional; in order to avoid this issue, we have to\n                also adjust (decrease) the premium in the burn flow.\n             */\n            position.leverage = (position.notionalUp + position.notionalDown) / position.premium;\n        }\n\n        emit BuyDVP(tokenId, _positions[tokenId].expiry, params.notionalUp + params.notionalDown);\n        emit Buy(params.dvpAddr, _positions[tokenId].expiry, premium, params.recipient);\n    }\n\n    function payoff(\n        uint256 tokenId,\n        uint256 notionalUp,\n        uint256 notionalDown\n    ) external view returns (uint256 payoff_, uint256 fee) {\n        ManagedPosition storage position = _positions[tokenId];\n        return IDVP(position.dvpAddr).payoff(position.expiry, position.strike, notionalUp, notionalDown);\n    }\n\n    function sell(SellParams calldata params) external isOwner(params.tokenId) returns (uint256 payoff_) {\n        payoff_ = _sell(\n            params.tokenId,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedMarketValue,\n            params.maxSlippage\n        );\n    }\n\n    function sellAll(SellParams[] calldata params) external returns (uint256 totalPayoff_) {\n        uint256 paramsLength = params.length;\n        for (uint256 i = 0; i < paramsLength; i++) {\n            if (ownerOf(params[i].tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            totalPayoff_ += _sell(\n                params[i].tokenId,\n                params[i].notionalUp,\n                params[i].notionalDown,\n                params[i].expectedMarketValue,\n                params[i].maxSlippage\n            );\n        }\n    }\n\n    function _sell(\n        uint256 tokenId,\n        uint256 notionalUp,\n        uint256 notionalDown,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) internal returns (uint256 payoff_) {\n        ManagedPosition storage position = _positions[tokenId];\n        // NOTE: as the positions within the DVP are all of the PositionManager, we must replicate this check here.\n        if (notionalUp > position.notionalUp || notionalDown > position.notionalDown) {\n            revert CantBurnMoreThanMinted();\n        }\n\n        if ((notionalUp > 0 && notionalDown > 0) && (notionalUp != notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        // NOTE: the DVP already checks that the burned notional is lesser or equal to the position notional.\n        // NOTE: the payoff is transferred directly from the DVP\n        payoff_ = IDVP(position.dvpAddr).burn(\n            position.expiry,\n            msg.sender,\n            position.strike,\n            notionalUp,\n            notionalDown,\n            expectedMarketValue,\n            maxSlippage\n        );\n\n        // NOTE: premium fix for the leverage issue annotated in the mint flow.\n        // notional : position.notional = fix : position.premium\n        uint256 premiumFix = ((notionalUp + notionalDown) * position.premium) /\n            (position.notionalUp + position.notionalDown);\n        position.premium -= premiumFix;\n        position.cumulatedPayoff += payoff_;\n        position.notionalUp -= notionalUp;\n        position.notionalDown -= notionalDown;\n\n        if (position.notionalUp == 0 && position.notionalDown == 0) {\n            delete _positions[tokenId];\n            _burn(tokenId);\n        }\n\n        emit SellDVP(tokenId, (notionalUp + notionalDown), payoff_);\n        emit Sell(position.dvpAddr, position.expiry, payoff_);\n    }\n}"
    },
    {
      "filename": "smilee-v2-contracts/src/periphery/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.15;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IDVP} from \"../interfaces/IDVP.sol\";\nimport {IPositionManager} from \"../interfaces/IPositionManager.sol\";\nimport {Position} from \"../lib/Position.sol\";\nimport {Epoch} from \"../lib/EpochController.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PositionManager is ERC721Enumerable, Ownable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n    struct ManagedPosition {\n        address dvpAddr;\n        uint256 strike;\n        uint256 expiry;\n        uint256 notionalUp;\n        uint256 notionalDown;\n        uint256 premium;\n        uint256 leverage;\n        uint256 cumulatedPayoff;\n    }\n\n    /// @dev Stored data by position ID\n    mapping(uint256 => ManagedPosition) internal _positions;\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint256 private _nextId;\n\n    // Used by TheGraph for frontend needs:\n    event Buy(address dvp, uint256 epoch, uint256 premium, address"
    }
  ]
}