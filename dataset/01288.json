{
  "Title": "H-1: `QVSimpleStrategy` never updates `allocator.voiceCredits`.",
  "Content": "# Issue H-1: `QVSimpleStrategy` never updates `allocator.voiceCredits`. \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/150 \n\n## Found by \n0x00ffDa, 0x3b, 0xMAKEOUTHILL, 0xarno, 0xbepresent, 0xkaden, Arz, BenRai, GimelSec, HChang26, HHK, Kodyvim, Kow, Kral01, Martians, Nyx, WATCHPUG, ZdravkoHr., al88nsk, alexxander, ashirleyshe, ast3ros, bronze\\_pickaxe, carrotsmuggler, chaduke, coffiasd, cu5t0mPe0, dany.armstrong90, detectiveking, dipp, fibonacci, jah, jkoppel, jovi, lemonmon, lil.eth, nobody2018, osmanozdemir1, pengun, pontifex, qbs, rvierdiiev, sandNallani, seeques, simon135, tnquanghuy0512, toshii, wangxx2026\nEvery allocator in `QVSimpleStrategy` has a maximum credit limit. An allocator should not be able to bypass the limit. However, `QVSimpleStrategy` fails to record the allocated votes. An allocator can vote as many as possible.\n\n## Vulnerability Detail\n\n`QVSimpleStrategy._allocate` calls `_hasVoiceCreditsLeft` to check that the recipient has voice credits left to allocate.\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol#L121\n```solidity\n    function _allocate(bytes memory _data, address _sender) internal virtual override {\n        …\n\n        // check that the recipient has voice credits left to allocate\n        if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) revert INVALID();\n\n        _qv_allocate(allocator, recipient, recipientId, voiceCreditsToAllocate, _sender);\n    }\n```\n\n`QVSimpleStrategy._hasVoiceCreditsLeft` checks ` _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator`\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol#L144\n```solidity\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        override\n        returns (bool)\n    {\n        return _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator;\n    }\n```\n\nThe problem is that `allocator.voiceCredits` is always zero. Both `QVSimpleStrategy` and `QVBaseStrategy` don't update `allocator.voiceCredits`. Thus, allocators can cast more votes than `maxVoiceCreditsPerAllocator`.\n\n## Impact\n\nEvery allocator has an unlimited number of votes.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol#L121\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol#L144\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdates `allocator.voiceCredits` in  `QVSimpleStrategy._allocate`.\n\n```diff\n    function _allocate(bytes memory _data, address _sender) internal virtual override {\n        …\n\n        // check that the recipient has voice credits left to allocate\n        if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) revert INVALID();\n+       allocator.voiceCredits += voiceCreditsToAllocate;\n        _qv_allocate(allocator, recipient, recipientId, voiceCreditsToAllocate, _sender);\n    }\n```\n\n\n\n## Discussion\n\n**osmanozdemir1**\n\nEscalate\n\nThis issue should be High. Allocators can have unlimited credit and easily manipulate the whole voting. \n\n**sherlock-admin2**\n\n > Escalate\n> \n> This issue should be High. Allocators can have unlimited credit and easily manipulate the whole voting. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**neeksec**\n\nAgree with the Escalation.\n\n**MLON33**\n\nhttps://github.com/allo-protocol/allo-v2/pull/339\nhttps://github.com/allo-protocol/allo-v2/commit/1efc544fdf988896c89dc2056f7efa114b83aab9\n\n**Evert0x**\n\nPlanning to accept escalation and assign high severity\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [osmanozdemir1](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/150/#issuecomment-1762816604): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {Multicall} from \"openzeppelin-contracts/contracts/utils/Multicall.sol\";\n// Strategy Contracts\nimport {QVBaseStrategy} from \"../qv-base/QVBaseStrategy.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\ncontract QVSimpleStrategy is QVBaseStrategy, Multicall {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when an allocator is added\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorAdded(address indexed allocator, address sender);\n\n    /// @notice Emitted when an allocator is removed\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorRemoved(address indexed allocator, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    /// @notice The maximum voice credits per allocator\n    uint256 public maxVoiceCreditsPerAllocator;\n\n    /// @notice The details of the allowed allocator\n    /// @dev allocator => bool\n    mapping(address => bool) public allowedAllocators;\n\n    /// ======================\n    /// ======= Struct =======\n    /// ======================\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParamsSimple {\n        // slot 0\n        uint256 maxVoiceCreditsPerAllocator;\n        // slot 1..n\n        InitializeParams params;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n    constructor(address _allo, string memory _name) QVBaseStrategy(_allo, _name) {}\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    /// @custom:data (InitializeParamsSimple)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override onlyAllo {\n        (InitializeParamsSimple memory initializeParamsSimple) = abi.decode(_data, (InitializeParamsSimple));\n        __QVBaseStrategy_init(_poolId, initializeParamsSimple.params);\n\n        maxVoiceCreditsPerAllocator = initializeParamsSimple.maxVoiceCreditsPerAllocator;\n    }\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @notice Add allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorAdded` event\n    /// @param _allocator The allocator address\n    function addAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = true;\n\n        emit AllocatorAdded(_allocator, msg.sender);\n    }\n\n    /// @notice Remove allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorRemoved` event\n    /// @param _allocator The allocator address\n    function removeAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = false;\n\n        emit AllocatorRemoved(_allocator, msg.sender);\n    }\n\n    /// @notice Allocate votes to a recipient\n    /// @param _data The data\n    /// @param _sender The sender of the transaction\n    /// @dev Only the pool manager(s) can call this function\n    function _allocate(bytes memory _data, address _sender) internal virtual override {\n        (address recipientId, uint256 voiceCreditsToAllocate) = abi.decode(_data, (address, uint256));\n\n        // spin up the structs in storage for updating\n        Recipient storage recipient = recipients[recipientId];\n        Allocator storage allocator = allocators[_sender];\n\n        // check that the sender can allocate votes\n        if (!_isValidAllocator(_sender)) revert UNAUTHORIZED();\n\n        // check that the recipient is accepted\n        if (!_isAcceptedRecipient(recipientId)) revert RECIPIENT_ERROR(recipientId);\n\n        // check that the recipient has voice credits left to allocate\n        if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) revert INVALID();\n\n        _qv_allocate(allocator, recipient, recipientId, voiceCreditsToAllocate, _sender);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return true if the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view override returns (bool) {\n        return recipients[_recipientId].recipientStatus == Status.Accepted;\n    }\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return true if the allocator is valid\n    function _isValidAllocator(address _allocator) internal view override returns (bool) {\n        return allowedAllocators[_allocator];\n    }\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return true if the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        override\n        returns (bool)\n    {\n        return _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator;\n    }\n}"
    },
    {
      "filename": "allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {Multicall} from \"openzeppelin-contracts/contracts/utils/Multicall.sol\";\n// Strategy Contracts\nimport {QVBaseStrategy} from \"../qv-base/QVBaseStrategy.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\ncontract QVSimpleStrategy is QVBaseStrategy, Multicall {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when an allocator is added\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorAdded(address indexed allocator, address sender);\n\n    /// @notice Emitted when an allocator is removed\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorRemoved(address indexed allocator, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    /// @notice The maximum voice credits per allocator\n    uint256 public maxVoiceCreditsPerAllocator;\n\n    /// @notice The details of the allowed allocator\n    /// @dev allocator => bool\n    mapping(address => bool) public allowedAllocators;\n\n    /// ======================\n    /// ======= Struct =======\n    /// ======================\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParamsSimple {\n        // slot 0\n        uint256 maxVoiceCreditsPerAllocator;\n        // slot 1..n\n        InitializeParams params;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n    constructor(address _allo, string memory _name) QVBaseStrategy(_allo, _name) {}\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    /// @custom:data (InitializeParamsSimple)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override onlyAllo {\n        (InitializeParamsSimple memory initializeParamsSimple) = abi.decode(_data, (InitializeParamsSimple));\n        __QVBaseStrategy_init(_poolId, initializeParamsSimple.params);\n\n        maxVoiceCreditsPerAllocator = initializeParamsSimple.maxVoiceCreditsPerAllocator;\n    }\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @notice Add allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorAdded` event\n    /// @param _allocator The allocator address\n    function addAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = true;\n\n        emit AllocatorAdded(_allocator, msg.sender);\n    }\n\n    /// @notice Remove allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorRemoved` event\n    /// @param _allocator The allocator address\n    function removeAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = false;\n\n        emit AllocatorRemoved(_allocator, msg.sender);\n    }\n\n    /// @notice Allocate votes to a recipient\n    /// @param _data The data\n    /// @param _sender The sender of the transaction\n    /// @dev Only the pool manager(s) can call this function\n    function _allocate(bytes memory _data, address _sender) internal virtual override {\n        (address recipientId, uint256 voiceCreditsToAllocate) = abi.decode(_data, (address, uint256));\n\n        // spin up the structs in storage for updating\n        Recipient storage recipient = recipients[recipientId];\n        Allocator storage allocator = allocators[_sender];\n\n        // check that the sender can allocate votes\n        if (!_isValidAllocator(_sender)) revert UNAUTHORIZED();\n\n        // check that the recipient is accepted\n        if (!_isAcceptedRecipient(recipientId)) revert RECIPIENT_ERROR(recipientId);\n\n        // check that the recipient has voice credits left to allocate\n        if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) revert INVALID();\n\n        _qv_allocate(allocator, recipient, recipientId, voiceCreditsToAllocate, _sender);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return true if the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view override returns (bool) {\n        return recipients[_recipientId].recipientStatus == Status.Accepted;\n    }\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return true if the allocator is valid\n    function _isValidAllocator(address _allocator) internal view override returns (bool) {\n        return allowedAllocators[_allocator];\n    }\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return true if the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        override\n        returns (bool)\n    {\n        return _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator;\n    }\n}"
    },
    {
      "filename": "allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {Multicall} from \"openzeppelin-contracts/contracts/utils/Multicall.sol\";\n// Strategy Contracts\nimport {QVBaseStrategy} from \"../qv-base/QVBaseStrategy.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\ncontract QVSimpleStrategy is QVBaseStrategy, Multicall {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when an allocator is added\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorAdded(address indexed allocator, address sender);\n\n    /// @notice Emitted when an allocator is removed\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorRemoved(address indexed allocator, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    /// @notice The maximum voice credits per allocator\n    uint256 public maxVoiceCreditsPerAllocator;\n\n    /// @notice The details of the allowed allocator\n    /// @dev allocator => bool\n    mapping(address => bool) public allowedAllocators;\n\n    /// ======================\n    /// ======= Struct =======\n    /// ======================\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParamsSimple {\n        // slot 0\n        uint256 maxVoiceCreditsPerAllocator;\n        // slot 1..n\n        InitializeParams params;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n    constructor(address _allo, string memory _name) QVBaseStrategy(_allo, _name) {}\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    /// @custom:data (InitializeParamsSimple)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override onlyAllo {\n        (InitializeParamsSimple memory initializeParamsSimple) = abi.decode(_data, (InitializeParamsSimple));\n        __QVBaseStrategy_init(_poolId, initializeParamsSimple.params);\n\n        maxVoiceCreditsPerAllocator = initializeParamsSimple.maxVoiceCreditsPerAllocator;\n    }\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @notice Add allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorAdded` event\n    /// @param _allocator The allocator address\n    function addAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = true;\n\n        emit AllocatorAdded(_allocator, msg.sender);\n    }\n\n    /// @notice Remove allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorRemoved` event\n    /// @param _allocator The allocator address\n    function removeAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = false;\n\n        emit AllocatorRemoved(_allocator, msg.sender);\n    }\n\n    /// @notice Allocate votes to a recipient\n    /// @param _data The data\n    /// @param _sender The sender of the transaction\n    /// @dev Only the pool manager(s) can call this function\n    function _allocate(bytes memory _data, address _sender) internal virtual override {\n        (address recipientId, uint256 voiceCreditsToAllocate) = abi.decode(_data, (address, uint256));\n\n        // spin up the structs in storage for updating\n        Recipient storage recipient = recipients[recipientId];\n        Allocator storage allocator = allocators[_sender];\n\n        // check that the sender can allocate votes\n        if (!_isValidAllocator(_sender)) revert UNAUTHORIZED();\n\n        // check that the recipient is accepted\n        if (!_isAcceptedRecipient(recipientId)) revert RECIPIENT_ERROR(recipientId);\n\n        // check that the recipient has voice credits left to allocate\n        if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) revert INVALID();\n\n        _qv_allocate(allocator, recipient, recipientId, voiceCreditsToAllocate, _sender);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return true if the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view override returns (bool) {\n        return recipients[_recipientId].recipientStatus == Status.Accepted;\n    }\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return true if the allocator is valid\n    function _isValidAllocator(address _allocator) internal view override returns (bool) {\n        return allowedAllocators[_allocator];\n    }\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return true if the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        override\n        returns (bool)\n    {\n        return _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator;\n    }\n}"
    },
    {
      "filename": "allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {Multicall} from \"openzeppelin-contracts/contracts/utils/Multicall.sol\";\n// Strategy Contracts\nimport {QVBaseStrategy} from \"../qv-base/QVBaseStrategy.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\ncontract QVSimpleStrategy is QVBaseStrategy, Multicall {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when an allocator is added\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorAdded(address indexed allocator, address sender);\n\n    /// @notice Emitted when an allocator is removed\n    /// @param allocator The allocator address\n    /// @param sender The sender of the transaction\n    event AllocatorRemoved(address indexed allocator, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    /// @notice The maximum voice credits per allocator\n    uint256 public maxVoiceCreditsPerAllocator;\n\n    /// @notice The details of the allowed allocator\n    /// @dev allocator => bool\n    mapping(address => bool) public allowedAllocators;\n\n    /// ======================\n    /// ======= Struct =======\n    /// ======================\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParamsSimple {\n        // slot 0\n        uint256 maxVoiceCreditsPerAllocator;\n        // slot 1..n\n        InitializeParams params;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n    constructor(address _allo, string memory _name) QVBaseStrategy(_allo, _name) {}\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    /// @custom:data (InitializeParamsSimple)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override onlyAllo {\n        (InitializeParamsSimple memory initializeParamsSimple) = abi.decode(_data, (InitializeParamsSimple));\n        __QVBaseStrategy_init(_poolId, initializeParamsSimple.params);\n\n        maxVoiceCreditsPerAllocator = initializeParamsSimple.maxVoiceCreditsPerAllocator;\n    }\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @notice Add allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorAdded` event\n    /// @param _allocator The allocator address\n    function addAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = true;\n\n        emit AllocatorAdded(_allocator, msg.sender);\n    }\n\n    /// @notice Remove allocator\n    /// @dev Only the pool manager(s) can call this function and emits an `AllocatorRemoved` event\n    /// @param _allocator The allocator address\n    function removeAllocator(address _allocator) external onlyPoolManager(msg.sender) {\n        allowedAllocators[_allocator] = false;\n\n        emit AllocatorRemoved(_allocator, msg.sender);\n    }\n\n    /// @notice Allocate votes to a recipient\n    /// @param _data The data\n    /// @param _sender The sender of the transaction\n    /// @dev Only the pool manager(s) can call this function\n    function _allocate(bytes memory _data, address _sender) internal virtual override {\n        (address recipientId, uint256 voiceCreditsToAllocate) = abi.decode(_data, (address, uint256));\n\n        // spin up the structs in storage for updating\n        Recipient storage recipient = recipients[recipientId];\n        Allocator storage allocator = allocators[_sender];\n\n        // check that the sender can allocate votes\n        if (!_isValidAllocator(_sender)) revert UNAUTHORIZED();\n\n        // check that the recipient is accepted\n        if (!_isAcceptedRecipient(recipientId)) revert RECIPIENT_ERROR(recipientId);\n\n        // check that the recipient has voice credits left to allocate\n        if (!_hasVoiceCreditsLeft(voiceCreditsToAllocate, allocator.voiceCredits)) revert INVALID();\n\n        _qv_allocate(allocator, recipient, recipientId, voiceCreditsToAllocate, _sender);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return true if the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view override returns (bool) {\n        return recipients[_recipientId].recipientStatus == Status.Accepted;\n    }\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return true if the allocator is valid\n    function _isValidAllocator(address _allocator) internal view override returns (bool) {\n        return allowedAllocators[_allocator];\n    }\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return true if the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        override\n        returns (bool)\n    {\n        return _voiceCreditsToAllocate + _allocatedVoiceCredits <= maxVoiceCreditsPerAllocator;\n    }\n}"
    }
  ]
}