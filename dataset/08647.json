{
  "Title": "[M-26] instantUnstake function can be frontrunned with fee increase",
  "Content": "_Submitted by sashik&#95;eth_\n\n[`instantUnstake()`](https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/LiquidityReserve.sol#L188) allows user to unstake their stakingToken for a fee paid to the liquidity providers. This fee could be changed up to 100% any moment by admin.\n\nMalicious admin could frontrun users [`instantUnstake()`](https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/LiquidityReserve.sol#L188) transaction and set `fee` to any value (using [`setFee()`](https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/LiquidityReserve.sol#L92)) and get all users unstaking asset.\n\nIt's even could lead to a situation when non-malicious admin accidentally frontrun unstaking user by increasing fee to a new rate, which user wasn't expected.\n\n```solidity\n    /**\n        @notice sets Fee (in basis points eg. 100 bps = 1%) for instant unstaking\n        @param _fee uint - fee in basis points\n     */\n    function setFee(uint256 _fee) external onlyOwner {\n        // check range before setting fee\n        require(_fee <= BASIS_POINTS, \"Out of range\");\n        fee = _fee;\n\n        emit FeeChanged(_fee);\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider introducing an upper limit for fees so users can know the maximum fess available in protocol and adding timelock to change fee size.\nThis way, frontrunning will be impossible, and users will know which fee they agree to.\n\n**[toshiSat (Yieldy) acknowledged](https://github.com/code-423n4/2022-06-yieldy-findings/issues/279)** \n\n**[JasoonS (judge) commented](https://github.com/code-423n4/2022-06-yieldy-findings/issues/279#issuecomment-1230586458):**\n > Checks should be in place for this. Saying the code is upgradeable isn't an excuse for not having sanity checks in admin functions in the code.\n> \n> For example script could have a bug that sets this value wrong (for example making it 1e18 times bigger than it should be or something).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-yieldy-contest",
  "Code": [
    {
      "filename": "src/contracts/LiquidityReserve.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/ILiquidityReserve.sol\";\nimport \"./LiquidityReserveStorage.sol\";\n\ncontract LiquidityReserve is\n    LiquidityReserveStorage,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    ILiquidityReserve\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    event FeeChanged(uint256 fee);\n\n    // check if sender is the stakingContract\n    modifier onlyStakingContract() {\n        require(msg.sender == stakingContract, \"Not staking contract\");\n        _;\n    }\n\n    /**\n        @notice initialize by setting stakingContract & setting initial liquidity\n        @param _tokenName name of the lrToken to be created\n        @param _tokenSymbol symbol of the lrToken to be created.\n        @param _stakingToken the staking token in use\n        @param _rewardToken the reward token in use\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _stakingToken,\n        address _rewardToken\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        OwnableUpgradeable.__Ownable_init();\n        require(\n            _stakingToken != address(0) && _rewardToken != address(0),\n            \"Invalid address\"\n        );\n        stakingToken = _stakingToken;\n        rewardToken = _rewardToken;\n    }\n\n    /**\n        @notice callable once after initialized by the owner to set the staking contract and enable\n        our reserve to be used.\n        @param _stakingContract address of the staking contract\n     */\n    function enableLiquidityReserve(address _stakingContract)\n        external\n        onlyOwner\n    {\n        require(!isReserveEnabled, \"Already enabled\");\n        require(_stakingContract != address(0), \"Invalid address\");\n\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            msg.sender\n        );\n        // require address has minimum liquidity\n        require(\n            stakingTokenBalance >= MINIMUM_LIQUIDITY,\n            \"Not enough staking tokens\"\n        );\n        stakingContract = _stakingContract;\n\n        // permanently lock the first MINIMUM_LIQUIDITY of lrTokens\n        IERC20Upgradeable(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            MINIMUM_LIQUIDITY\n        );\n        _mint(address(this), MINIMUM_LIQUIDITY);\n        IERC20Upgradeable(rewardToken).approve(\n            stakingContract,\n            type(uint256).max\n        );\n        isReserveEnabled = true;\n    }\n\n    /**\n        @notice sets Fee (in basis points eg. 100 bps = 1%) for instant unstaking\n        @param _fee uint - fee in basis points\n     */\n    function setFee(uint256 _fee) external onlyOwner {\n        // check range before setting fee\n        require(_fee <= BASIS_POINTS, \"Out of range\");\n        fee = _fee;\n\n        emit FeeChanged(_fee);\n    }\n\n    /**\n        @notice addLiquidity for the stakingToken and receive lrToken in exchange\n        @param _amount uint - amount of staking tokens to add\n     */\n    function addLiquidity(uint256 _amount) external {\n        require(isReserveEnabled, \"Not enabled yet\");\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            address(this)\n        );\n        uint256 rewardTokenBalance = IERC20Upgradeable(rewardToken).balanceOf(\n            address(this)\n        );\n        uint256 lrFoxSupply = totalSupply();\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        uint256 totalLockedValue = stakingTokenBalance +\n            rewardTokenBalance +\n            coolDownAmount;\n\n        uint256 amountToMint = (_amount * lrFoxSupply) / totalLockedValue;\n        IERC20Upgradeable(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        _mint(msg.sender, amountToMint);\n    }\n\n    /**\n        @notice calculate current lrToken withdraw value\n        @param _amount uint - amount of tokens that will be withdrawn\n        @return uint - converted amount of staking tokens to withdraw from lr tokens\n     */\n    function _calculateReserveTokenValue(uint256 _amount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 lrFoxSupply = totalSupply();\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            address(this)\n        );\n        uint256 rewardTokenBalance = IERC20Upgradeable(rewardToken).balanceOf(\n            address(this)\n        );\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        uint256 totalLockedValue = stakingTokenBalance +\n            rewardTokenBalance +\n            coolDownAmount;\n        uint256 convertedAmount = (_amount * totalLockedValue) / lrFoxSupply;\n\n        return convertedAmount;\n    }\n\n    /**\n        @notice removeLiquidity by swapping your lrToken for stakingTokens\n        @param _amount uint - amount of tokens to remove from liquidity reserve\n     */\n    function removeLiquidity(uint256 _amount) external {\n        // check balance before removing liquidity\n        require(_amount <= balanceOf(msg.sender), \"Not enough lr tokens\");\n        // claim the stakingToken from previous unstakes\n        IStaking(stakingContract).claimWithdraw(address(this));\n\n        uint256 amountToWithdraw = _calculateReserveTokenValue(_amount);\n\n        // verify that we have enough stakingTokens\n        require(\n            IERC20Upgradeable(stakingToken).balanceOf(address(this)) >=\n                amountToWithdraw,\n            \"Not enough funds\"\n        );\n\n        _burn(msg.sender, _amount);\n        IERC20Upgradeable(stakingToken).safeTransfer(\n            msg.sender,\n            amountToWithdraw\n        );\n    }\n\n    /**\n        @notice allow instant unstake their stakingToken for a fee paid to the liquidity providers\n        @param _amount uint - amount of tokens to instantly unstake\n        @param _recipient address - address to send staking tokens to\n     */\n    function instantUnstake(uint256 _amount, address _recipient)\n        external\n        onlyStakingContract\n    {\n        require(isReserveEnabled, \"Not enabled yet\");\n        // claim the stakingToken from previous unstakes\n        IStaking(stakingContract).claimWithdraw(address(this));\n\n        uint256 amountMinusFee = _amount - ((_amount * fee) / BASIS_POINTS);\n\n        IERC20Upgradeable(rewardToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        IERC20Upgradeable(stakingToken).safeTransfer(\n            _recipient,\n            amountMinusFee\n        );\n        unstakeAllRewardTokens();\n    }\n\n    /**\n        @notice find balance of reward tokens in contract and unstake them from staking contract\n     */\n    function unstakeAllRewardTokens() public {\n        require(isReserveEnabled, \"Not enabled yet\");\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        if (coolDownAmount == 0) {\n            uint256 amount = IERC20Upgradeable(rewardToken).balanceOf(\n                address(this)\n            );\n            if (amount > 0) IStaking(stakingContract).unstake(amount, false);\n        }\n    }\n}"
    },
    {
      "filename": "src/contracts/LiquidityReserve.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/ILiquidityReserve.sol\";\nimport \"./LiquidityReserveStorage.sol\";\n\ncontract LiquidityReserve is\n    LiquidityReserveStorage,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    ILiquidityReserve\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    event FeeChanged(uint256 fee);\n\n    // check if sender is the stakingContract\n    modifier onlyStakingContract() {\n        require(msg.sender == stakingContract, \"Not staking contract\");\n        _;\n    }\n\n    /**\n        @notice initialize by setting stakingContract & setting initial liquidity\n        @param _tokenName name of the lrToken to be created\n        @param _tokenSymbol symbol of the lrToken to be created.\n        @param _stakingToken the staking token in use\n        @param _rewardToken the reward token in use\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _stakingToken,\n        address _rewardToken\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        OwnableUpgradeable.__Ownable_init();\n        require(\n            _stakingToken != address(0) && _rewardToken != address(0),\n            \"Invalid address\"\n        );\n        stakingToken = _stakingToken;\n        rewardToken = _rewardToken;\n    }\n\n    /**\n        @notice callable once after initialized by the owner to set the staking contract and enable\n        our reserve to be used.\n        @param _stakingContract address of the staking contract\n     */\n    function enableLiquidityReserve(address _stakingContract)\n        external\n        onlyOwner\n    {\n        require(!isReserveEnabled, \"Already enabled\");\n        require(_stakingContract != address(0), \"Invalid address\");\n\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            msg.sender\n        );\n        // require address has minimum liquidity\n        require(\n            stakingTokenBalance >= MINIMUM_LIQUIDITY,\n            \"Not enough staking tokens\"\n        );\n        stakingContract = _stakingContract;\n\n        // permanently lock the first MINIMUM_LIQUIDITY of lrTokens\n        IERC20Upgradeable(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            MINIMUM_LIQUIDITY\n        );\n        _mint(address(this), MINIMUM_LIQUIDITY);\n        IERC20Upgradeable(rewardToken).approve(\n            stakingContract,\n            type(uint256).max\n        );\n        isReserveEnabled = true;\n    }\n\n    /**\n        @notice sets Fee (in basis points eg. 100 bps = 1%) for instant unstaking\n        @param _fee uint - fee in basis points\n     */\n    function setFee(uint256 _fee) external onlyOwner {\n        // check range before setting fee\n        require(_fee <= BASIS_POINTS, \"Out of range\");\n        fee = _fee;\n\n        emit FeeChanged(_fee);\n    }\n\n    /**\n        @notice addLiquidity for the stakingToken and receive lrToken in exchange\n        @param _amount uint - amount of staking tokens to add\n     */\n    function addLiquidity(uint256 _amount) external {\n        require(isReserveEnabled, \"Not enabled yet\");\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            address(this)\n        );\n        uint256 rewardTokenBalance = IERC20Upgradeable(rewardToken).balanceOf(\n            address(this)\n        );\n        uint256 lrFoxSupply = totalSupply();\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        uint256 totalLockedValue = stakingTokenBalance +\n            rewardTokenBalance +\n            coolDownAmount;\n\n        uint256 amountToMint = (_amount * lrFoxSupply) / totalLockedValue;\n        IERC20Upgradeable(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        _mint(msg.sender, amountToMint);\n    }\n\n    /**\n        @notice calculate current lrToken withdraw value\n        @param _amount uint - amount of tokens that will be withdrawn\n        @return uint - converted amount of staking tokens to withdraw from lr tokens\n     */\n    function _calculateReserveTokenValue(uint256 _amount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 lrFoxSupply = totalSupply();\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            address(this)\n        );\n        uint256 rewardTokenBalance = IERC20Upgradeable(rewardToken).balanceOf(\n            address(this)\n        );\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        uint256 totalLockedValue = stakingTokenBalance +\n            rewardTokenBalance +\n            coolDownAmount;\n        uint256 convertedAmount = (_amount * totalLockedValue) / lrFoxSupply;\n\n        return convertedAmount;\n    }\n\n    /**\n        @notice removeLiquidity by swapping your lrToken for stakingTokens\n        @param _amount uint - amount of tokens to remove from liquidity reserve\n     */\n    function removeLiquidity(uint256 _amount) external {\n        // check balance before removing liquidity\n        require(_amount <= balanceOf(msg.sender), \"Not enough lr tokens\");\n        // claim the stakingToken from previous unstakes\n        IStaking(stakingContract).claimWithdraw(address(this));\n\n        uint256 amountToWithdraw = _calculateReserveTokenValue(_amount);\n\n        // verify that we have enough stakingTokens\n        require(\n            IERC20Upgradeable(stakingToken).balanceOf(address(this)) >=\n                amountToWithdraw,\n            \"Not enough funds\"\n        );\n\n        _burn(msg.sender, _amount);\n        IERC20Upgradeable(stakingToken).safeTransfer(\n            msg.sender,\n            amountToWithdraw\n        );\n    }\n\n    /**\n        @notice allow instant unstake their stakingToken for a fee paid to the liquidity providers\n        @param _amount uint - amount of tokens to instantly unstake\n        @param _recipient address - address to send staking tokens to\n     */\n    function instantUnstake(uint256 _amount, address _recipient)\n        external\n        onlyStakingContract\n    {\n        require(isReserveEnabled, \"Not enabled yet\");\n        // claim the stakingToken from previous unstakes\n        IStaking(stakingContract).claimWithdraw(address(this));\n\n        uint256 amountMinusFee = _amount - ((_amount * fee) / BASIS_POINTS);\n\n        IERC20Upgradeable(rewardToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        IERC20Upgradeable(stakingToken).safeTransfer(\n            _recipient,\n            amountMinusFee\n        );\n        unstakeAllRewardTokens();\n    }\n\n    /**\n        @notice find balance of reward tokens in contract and unstake them from staking contract\n     */\n    function unstakeAllRewardTokens() public {\n        require(isReserveEnabled, \"Not enabled yet\");\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        if (coolDownAmount == 0) {\n            uint256 amount = IERC20Upgradeable(rewardToken).balanceOf(\n                address(this)\n            );\n            if (amount > 0) IStaking(stakingContract).unstake(amount, false);\n        }\n    }\n}"
    }
  ]
}