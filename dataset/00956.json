{
  "Title": "min max price on getMarketTokenPrice is not utilized such that deposit and withdrawal can use the same price, leading to free tx for cost-free manipulation",
  "Content": "# min max price on getMarketTokenPrice is not utilized such that deposit and withdrawal can use the same price, leading to free tx for cost-free manipulation\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L167-L176\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L167-L176</a>\n\n\n## Summary\nmin max price on getMarketTokenPrice is not utilized such that deposit and withdrawal can use the same price, leading to free tx for cost-free manipulation\n\nGMX provides getMarketTokenPrice on its synethicReader which leverages MarketUtils. It allows passing in index/long/short token price with min/max. The isDeposit flag would then be used to determine whether the min or max price would be used for calculating marketTokenPrice, this is important to always favor the protocol and prevent MEV.\n\nHowever on the getMarketTokenInfo implemented in GMXOracle, it passes in the same price from the oracle to the min/max price for all long&short/lpToken. This implies the same pricing is used for both deposit and withdrawal, enabling user to freely deposit/withdraw without cost or slippage. Malicious users can use this to trigger rebalance, and hence deposit or withdrawal directly on GMX that benefit the attacker with the use of bundled tx.\n\n```solidity\n    function getMarketTokenPrice(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory indexTokenPrice,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) external view returns (int256, MarketPoolValueInfo.Props memory) {\n        return\n            MarketUtils.getMarketTokenPrice(\n                dataStore,\n                market,\n                indexTokenPrice,\n                longTokenPrice,\n                shortTokenPrice,\n                pnlFactorType,\n                maximize\n            );\n    }\n```\nhttps://github.com/gmx-io/gmx-synthetics/blob/613c72003eafe21f8f80ea951efd14e366fe3a31/contracts/reader/Reader.sol#L187-L206\n\n## Vulnerability Details\n\n## Impact\nfree deposit and withdrawal due to the same token price is used for min or max price, which leading to the same marketTokenPrice calculation for deposit and withdrawal.\n## Tools Used\n\n## Recommendations\nconsider adding a small fee(5bps) to buffer the price returned from `_getTokenPriceMinMaxFormatted` on both sides.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/oracles/GMXOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISyntheticReader } from \"../interfaces/protocols/gmx/ISyntheticReader.sol\";\nimport { IChainlinkOracle } from \"../interfaces/oracles/IChainlinkOracle.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\nimport { console } from \"forge-std/console.sol\";\n\ncontract GMXOracle {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMX DataStore\n  address public immutable dataStore;\n  // GMX Synthetic Reader\n  ISyntheticReader public immutable syntheticReader;\n  // Chainlink oracle\n  IChainlinkOracle public immutable chainlinkOracle;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param _DataStore Address of GMX DataStore\n    * @param _syntheticReader Address of GMX Synthetic Reader\n    * @param _chainlinkOracle Address of Chainlink oracle\n  */\n  constructor(\n    address _DataStore,\n    ISyntheticReader _syntheticReader,\n    IChainlinkOracle _chainlinkOracle\n  ) {\n    if (_DataStore == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_syntheticReader) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_chainlinkOracle) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    dataStore = _DataStore;\n    syntheticReader = _syntheticReader;\n    chainlinkOracle = _chainlinkOracle;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get amountsOut of either the long or short token based on the amountsIn\n    * of either long or short token in the market\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenIn TokenIn address\n    * @param amountIn Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsOut(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenIn,\n    uint256 amountIn\n  ) public view returns (uint256) {\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    ISyntheticReader.MarketPrices memory _prices;\n    _prices.indexTokenPrice = _indexTokenPrice;\n    _prices.longTokenPrice = _longTokenPrice;\n    _prices.shortTokenPrice = _shortTokenPrice;\n\n    address _uiFeeReceiver = address(0);\n\n    (uint256 _amountsOut,,) = syntheticReader.getSwapAmountOut(\n      dataStore,\n      _market,\n      _prices,\n      tokenIn,\n      amountIn,\n      _uiFeeReceiver\n    );\n\n    return _amountsOut;\n  }\n\n  /**\n    * @notice Helper function to calculate amountIn of either long or short token for swapping for\n    * desired amountsOut of long or short token\n    * @notice We utilise GMX's getSwapAmountOut() with tokenOut being tokenIn, multiplying\n    * the amountsOut value by 1.0015x to account for fees and normal chainlink price feed differential\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenOut TokenIn address\n    * @param amountsOut Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsIn(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenOut,\n    uint256 amountsOut\n  ) public view returns (uint256) {\n    return getAmountsOut(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      tokenOut,\n      amountsOut\n    ) * (1e18 + 15e14) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice Get LP (market) token info\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param pnlFactorType P&L Factory type in bytes32 hashed string\n    * @param maximize Min/max price boolean\n    * @return (marketTokenPrice, MarketPoolValueInfoProps MarketInfo)\n  */\n  function getMarketTokenInfo(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bytes32 pnlFactorType,\n    bool maximize\n  ) public view returns (int256, ISyntheticReader.MarketPoolValueInfoProps memory) {\n    if (address(marketToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(indexToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(longToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(shortToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    return syntheticReader.getMarketTokenPrice(\n      dataStore,\n      _market,\n      _indexTokenPrice,\n      _longTokenPrice,\n      _shortTokenPrice,\n      pnlFactorType,\n      maximize\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @return (reserveA, reserveB) Reserve amount of longToken and shortToken respectively\n  */\n  function getLpTokenReserves(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken\n  ) public view returns (uint256, uint256) {\n    // _pnlFactorType value does not matter in getting token reserves\n    bytes32 _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n\n    // _maximize value does not matter in getting token reserves\n    bool _maximize = false;\n\n    (, ISyntheticReader.MarketPoolValueInfoProps memory _marketInfo) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      _maximize\n    );\n\n    return (\n      _marketInfo.longTokenAmount,\n      _marketInfo.shortTokenAmount\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return marketTokenPrice in 1e18\n  */\n  function getLpTokenValue(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    bytes32 _pnlFactorType;\n\n    if (isDeposit) {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n    } else {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\"));\n    }\n\n    (int256 _marketTokenPrice,) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      maximize\n    );\n\n    // If LP token value is negative, return 0\n    if (_marketTokenPrice < 0) {\n      return 0;\n    } else {\n      // Price returned in 1e30, we normalize it to 1e18\n      return uint256(_marketTokenPrice) / 1e12;\n    }\n  }\n\n\n  /**\n    * @notice Get token A and token B's LP token amount required for a given value\n    * @param givenValue Given value needed, expressed in 1e30\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return lpTokenAmount Amount of LP tokens; expressed in 1e18\n  */\n  function getLpTokenAmount(\n    uint256 givenValue,\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    uint256 _lpTokenValue = getLpTokenValue(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      isDeposit,\n      maximize\n    );\n\n    return givenValue * SAFE_MULTIPLIER / _lpTokenValue;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Get token price formatted for GMX mix/max decimals for 1e30 normalization\n    * @dev E.g. if token decimals is 18, to normalize to 1e30, we need to return 30-18 = 1e12\n    * consult() usually returns asset price in 8 decimals, so 30 - tokenDecimals - priceDecimals\n    * should format the decimals correctly for 1e30\n    * @param token Token address\n    * @return tokenPriceMinMaxFormatted\n  */\n  function _getTokenPriceMinMaxFormatted(address token) internal view returns (uint256) {\n    (int256 _price, uint8 _priceDecimals) = chainlinkOracle.consult(token);\n\n    return uint256(_price) * 10 ** (30 - IERC20Metadata(token).decimals() - _priceDecimals);\n  }\n}"
    }
  ]
}