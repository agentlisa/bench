{
  "Title": "H-1: Lender transactions can be front-run, leading to lost funds",
  "Content": "# Issue H-1: Lender transactions can be front-run, leading to lost funds \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/6 \n\n## Found by \nbin2chen, coffiasd\n## Summary\nUsers can mint wfCash tokens via `mintViaUnderlying` by passing a variable `minImpliedRate` to guard against trade slippage. If the market interest is lower than expected by the user, the transaction will revert due to slippage protection. However, if the user mints a share larger than maxFCash, the `minImpliedRate` check is not performed.\n\n## Vulnerability Detail\nUser invoke `mintViaUnderlying` to mint  shares:\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/3bf2fb5d992dfd5aa7343d7788e881d3a4294b13/wrapped-fcash/contracts/wfCashLogic.sol#L25-L33\n```solidity\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate//@audit when lendAmount bigger than maxFCash lack of minRate protect.\n    ) external override {\n        (/* */, uint256 maxFCash) = getTotalFCashAvailable();\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, maxFCash);\n    }\n```\n\nlet's dive into `_mintInternal` we can see if `maxFCash < fCashAmount` , the vaule of `minImpliedRate` is not checked\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/3bf2fb5d992dfd5aa7343d7788e881d3a4294b13/wrapped-fcash/contracts/wfCashLogic.sol#L60-L68\n```solidity\n        if (maxFCash < fCashAmount) {\n            // NOTE: lending at zero\n            uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);//@audit-info fCashAmount * (underlyingTokenDecimals) / 1e8\n            require(fCashAmountExternal <= depositAmountExternal);\n\n            // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n            // back to the account\n            NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);//@audit check this.\n        } \n```\nImagine the following scenario:\n- lender deposit Underlying token to mint some shares and set a `minImpliedRate` to protect the trsanction\n- alice front-run her transaction invoke `mint` to mint some share\n- the shares of lender mint now is bigger than `maxFCash`\n- now the lender `lending at zero`\n\n```solidity\n    function testDepositViaUnderlying() public {\n        address alice = makeAddr(\"alice\");\n        deal(address(asset), LENDER, 8800 * precision, true);\n        deal(address(asset), alice, 5000 * precision, true);\n\n        //alice deal.\n        vm.stopPrank();\n        vm.startPrank(alice);\n        asset.approve(address(w), type(uint256).max);\n        \n        //==============================LENDER START=============================//\n        vm.stopPrank();\n        vm.startPrank(LENDER);\n        asset.approve(address(w), type(uint256).max);\n        //user DAI balance before:\n        assertEq(asset.balanceOf(LENDER), 8800e18);\n\n        (/* */, uint256 maxFCash) = w.getTotalFCashAvailable();\n        console2.log(\"current maxFCash:\",maxFCash);\n\n        //LENDER mintViaUnderlying will revert due to slippage.\n        uint32 minImpliedRate = 0.15e9;\n        vm.expectRevert(\"Trade failed, slippage\");\n        w.mintViaUnderlying(5000e18,5000e8,LENDER,minImpliedRate);\n        //==============================LENDER END=============================//\n\n        //======================alice frontrun to mint some shares.============//\n        vm.stopPrank();\n        vm.startPrank(alice);\n        w.mint(5000e8,alice);\n\n        //==========================LENDER TX =================================//\n        vm.stopPrank();\n        vm.startPrank(LENDER);\n        asset.approve(address(w), type(uint256).max);\n        //user DAI balance before:\n        assertEq(asset.balanceOf(LENDER), 8800e18);\n\n        //LENDER mintViaUnderlying will success.\n        w.mintViaUnderlying(5000e18,5000e8,LENDER,minImpliedRate);\n\n        console2.log(\"lender mint token:\",w.balanceOf(LENDER));\n        console2.log(\"lender cost DAI:\",8800e18 - asset.balanceOf(LENDER));\n    }\n```\n\nFrom the above test, we can observe that if `maxFCasha` is greater than `5000e8`, the lender's transaction will be reverted due to \"Trade failed, slippage.\" Subsequently, if Alice front-runs by invoking `mint` to create some shares before the lender, the lender's transaction will succeed. Therefore, the lender's `minImpliedRate` check will be bypassed, leading to a loss of funds for the lender.\n\n\n## Impact\nlender lost of funds\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/3bf2fb5d992dfd5aa7343d7788e881d3a4294b13/wrapped-fcash/contracts/wfCashLogic.sol#L60-L68\n```solidity\n        if (maxFCash < fCashAmount) {\n            // NOTE: lending at zero\n            uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);//@audit-info fCashAmount * (underlyingTokenDecimals) / 1e8\n            require(fCashAmountExternal <= depositAmountExternal);\n\n            // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n            // back to the account\n            NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);//@audit check this.\n        } \n```\n## Tool used\nFoundry\nManual Review\n\n## Recommendation\nadd a check inside `_mintInternal`\n```diff\n        if (maxFCash < fCashAmount) {\n+          require(minImpliedRate ==0,\"Trade failed, slippage\");            \n            // NOTE: lending at zero\n            uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);//@audit-info fCashAmount * (underlyingTokenDecimals) / 1e8\n            require(fCashAmountExternal <= depositAmountExternal);\n\n            // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n            // back to the account\n            NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);//@audit check this.\n        }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { This is valid as the watson explained how the slippage chack can be bypassed via front-running the users deposit}\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "wrapped-fcash/contracts/wfCashLogic.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashBase(_notional, _weth) {}\n\n    /***** Mint Methods *****/\n\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        (/* */, uint256 maxFCash) = getTotalFCashAvailable();\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, maxFCash);\n    }\n\n    function _mintInternal(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate,\n        uint256 maxFCash\n    ) internal nonReentrant {\n        require(!hasMatured(), \"fCash matured\");\n        (IERC20 token, bool isETH, bool hasTransferFee, uint256 precision) = _getTokenForMintInternal();\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint256 msgValue;\n        uint16 currencyId = getCurrencyId();\n        \n        if (isETH) {\n            // Use WETH if lending ETH. Although Notional natively supports ETH, we use WETH here for integration\n            // contracts so they only have to support ERC20 token transfers.\n            // NOTE: safeTransferFrom not required since WETH is known to be compatible\n            IERC20((address(WETH))).transferFrom(msg.sender, address(this), depositAmountExternal);\n            WETH.withdraw(depositAmountExternal);\n            msgValue = depositAmountExternal;\n        } else {\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n            depositAmountExternal = token.balanceOf(address(this)) - balanceBefore;\n        }\n\n        if (maxFCash < fCashAmount) {\n            // NOTE: lending at zero\n            uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n            require(fCashAmountExternal <= depositAmountExternal);\n\n            // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n            // back to the account\n            NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n        } else if (isETH || hasTransferFee || getCashBalance() > 0) {\n            _lendLegacy(currencyId, depositAmountExternal, fCashAmount, minImpliedRate, msgValue, isETH);\n        } else {\n            // Executes a lending action on Notional. Since this lending action uses an existing cash balance\n            // prior to pulling payment, we cannot use it if there is a cash balance on the wrapper contract,\n            // it will cause existing cash balances to be minted into fCash and create a shortfall. In normal\n            // conditions, this method is more gas efficient.\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\n                currencyId,\n                getMarketIndex(),\n                fCashAmount,\n                minImpliedRate\n            );\n            NotionalV2.batchLend(address(this), action);\n        }\n\n        // Mints ERC20 tokens for the receiver\n        _mint(receiver, fCashAmount);\n\n        // Residual tokens will be sent back to msg.sender, not the receiver. The msg.sender\n        // was used to transfer tokens in and these are any residual tokens left that were not\n        // lent out. Sending these tokens back to the receiver risks them getting locked on a\n        // contract that does not have the capability to transfer them off\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n\n    function _lendLegacy(\n        uint16 currencyId,\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        uint32 minImpliedRate,\n        uint256 msgValue,\n        bool isETH\n    ) internal {\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\n        // ETH. batchLend only supports ERC20 tokens. Since the wrapper is a compatibility\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\n        // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"\n        // is more gas efficient.\n\n        // If deposit amount external is in excess of the cost to purchase fCash amount (often the case),\n        // then we need to return the difference between postTradeCash - preTradeCash. This is done because\n        // the encoded trade does not automatically withdraw the entire cash balance in case the wrapper\n        // is holding a cash balance.\n        uint256 preTradeCash = getCashBalance();\n\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeLegacyLendTrade(\n            currencyId,\n            getMarketIndex(),\n            depositAmountExternal,\n            fCashAmount,\n            minImpliedRate\n        );\n        // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\n        // native ETH tokens will be wrapped back to WETH.\n        NotionalV2.batchBalanceAndTradeAction{value: msgValue}(address(this), action);\n\n        uint256 postTradeCash = getCashBalance();\n\n        if (preTradeCash != postTradeCash) {\n            // If ETH, then redeem to WETH (redeemToUnderlying == false)\n            NotionalV2.withdraw(currencyId, _safeUint88(postTradeCash - preTradeCash), !isETH);\n        }\n    }\n\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\n    /// back to the user.\n    function onERC1155Received(\n        address /* _operator */,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata /* _data */\n    ) external nonReentrant returns (bytes4) {\n        uint256 fCashID = getfCashId();\n        // Only accept erc1155 transfers from NotionalV2\n        require(msg.sender == address(NotionalV2), \"Invalid\");\n        // Only accept the fcash id that corresponds to the listed currency and maturity\n        require(_id == fCashID, \"Invalid\");\n        // Protect against signed value underflows\n        require(int256(_value) > 0, \"Invalid\");\n\n        // Double check the account's position, these are not strictly necessary and add gas costs\n        // but might be good safe guards\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\n        require(ac.hasDebt == 0x00);\n        require(assets.length == 1);\n        require(EncodeDecode.encodeERC1155Id(\n                assets[0].currencyId,\n                assets[0].maturity,\n                assets[0].assetType) == fCashID\n        );\n\n        // Mint ERC20 tokens for the sender\n        _mint(_from, _value);\n\n        // This will allow the fCash to be accepted\n        return ERC1155_ACCEPTED;\n    }\n\n    /***** Redeem (Burn) Methods *****/\n\n    /// @notice Redeems tokens using custom options\n    /// @dev re-entrancy is protected on _burn\n    function redeem(uint256 amount, RedeemOpts memory opts) external override {\n        _burnInternal(msg.sender, amount, opts);\n    }\n\n    /// @notice Redeems tokens to underlying\n    /// @dev re-entrancy is protected on _burn\n    function redeemToUnderlying(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        _burnInternal(\n            msg.sender,\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice This method is here only in the case where someone has transferred invalid fCash\n    /// to the contract and would prevent ERC1155 transfer hooks from succeeding. In this case the\n    /// owner can recover the invalid fCash to a designated receiver. This can only occur if the fCash\n    /// is transferred prior to contract creation.\n    function recoverInvalidfCash(uint256 fCashId, address receiver) external {\n        // Only the Notional owner can call this method\n        require(msg.sender == NotionalV2.owner());\n        // Cannot transfer the native fCash id of this wrapper\n        require(fCashId != getfCashId());\n        uint256 balance = NotionalV2.balanceOf(address(this), fCashId);\n        // There should be a positive balance before we try to transfer this\n        require(balance > 0);\n        NotionalV2.safeTransferFrom(address(this), receiver, fCashId, balance, \"\");\n        \n        // Double check that we don't incur debt\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        require(ac.hasDebt == 0x00);\n    }\n\n    /// @notice Called before tokens are burned (redemption) and so we will handle\n    /// the fCash properly before and after maturity.\n    function _burnInternal(\n        address from,\n        uint256 fCashShares,\n        RedeemOpts memory opts\n    ) internal nonReentrant {\n        require(opts.receiver != address(0), \"Receiver is zero address\");\n        require(opts.redeemToUnderlying || opts.transferfCash);\n        // This will validate that the account has sufficient tokens to burn and make\n        // any relevant underlying stateful changes to balances.\n        super._burn(from, fCashShares);\n\n        if (hasMatured()) {\n            require(opts.transferfCash == false);\n            // If the fCash has matured, then we need to ensure that the account is settled\n            // and then we will transfer back the account's share of asset tokens.\n\n            // This is a noop if the account is already settled, it is cheaper to call this method than\n            // cache it in storage locally\n            NotionalV2.settleAccount(address(this));\n            uint16 currencyId = getCurrencyId();\n            uint256 primeCashClaim = _getMaturedCashValue(fCashShares);\n\n            // Transfer withdrawn tokens to the `from` address\n            _withdrawCashToAccount(currencyId, opts.receiver, _safeUint88(primeCashClaim));\n        } else if (opts.transferfCash) {\n            // If the fCash has not matured, then we can transfer it via ERC1155.\n            // NOTE: this may fail if the destination is a contract and it does not implement \n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\n            // ERC20 transfer on this contract instead.\n            NotionalV2.safeTransferFrom(\n                address(this), // Sending from this contract\n                opts.receiver, // Where to send the fCash\n                getfCashId(), // fCash identifier\n                fCashShares, // Amount of fCash to send\n                \"\"\n            );\n        } else {\n            _sellfCash(opts.receiver, fCashShares, opts.maxImpliedRate);\n        }\n    }\n\n    /// @notice After maturity, withdraw cash back to account\n    function _withdrawCashToAccount(\n        uint16 currencyId,\n        address receiver,\n        uint88 primeCashToWithdraw\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n\n        NotionalV2.withdraw(currencyId, primeCashToWithdraw, !isETH);\n\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    /// @dev Sells an fCash share back on the Notional AMM\n    function _sellfCash(\n        address receiver,\n        uint256 fCashToSell,\n        uint32 maxImpliedRate\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint16 currencyId = getCurrencyId();\n\n        (uint256 initialCashBalance, uint256 fCashBalance) = getBalances();\n        bool hasInsufficientfCash = fCashBalance < fCashToSell;\n\n        uint256 primeCashToWithdraw;\n        if (hasInsufficientfCash) {\n            // If there is insufficient fCash, calculate how much prime cash would be purchased if the\n            // given fCash amount would be sold and that will be how much the wrapper will withdraw and\n            // send to the receiver. Since fCash always sells at a discount to underlying prior to maturity,\n            // the wrapper is guaranteed to have sufficient cash to send to the account.\n            (/* */, primeCashToWithdraw, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                fCashToSell,\n                getMaturity(),\n                0,\n                block.timestamp\n            );\n            // If this is zero then it signifies that the trade will fail.\n            require(primeCashToWithdraw > 0, \"Redeem Failed\");\n\n            // Re-write the fCash to sell to the entire fCash balance.\n            fCashToSell = fCashBalance;\n        }\n\n        if (fCashToSell > 0) {\n            // Sells fCash on Notional AMM (via borrowing)\n            BalanceActionWithTrades[] memory action = EncodeDecode.encodeBorrowTrade(\n                currencyId,\n                getMarketIndex(),\n                _safeUint88(fCashToSell),\n                maxImpliedRate\n            );\n            NotionalV2.batchBalanceAndTradeAction(address(this), action);\n        }\n\n        uint256 postTradeCash = getCashBalance();\n\n        // If the account did not have insufficient fCash, then the amount of cash change here is what\n        // the receiver is owed. In the other case, we transfer to the receiver the total calculated amount\n        // above without modification.\n        if (!hasInsufficientfCash) primeCashToWithdraw = postTradeCash - initialCashBalance;\n        require(primeCashToWithdraw <= postTradeCash);\n\n        // Withdraw the total amount of cash and send it to the receiver\n        NotionalV2.withdraw(currencyId, _safeUint88(primeCashToWithdraw), !isETH);\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    function _sendTokensToReceiver(\n        IERC20 token,\n        address receiver,\n        bool isETH,\n        uint256 balanceBefore\n    ) private returns (uint256 tokensTransferred) {\n        uint256 balanceAfter = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        tokensTransferred = balanceAfter - balanceBefore;\n\n        if (isETH) {\n            // No need to use safeTransfer for WETH since it is known to be compatible\n            IERC20(address(WETH)).transfer(receiver, tokensTransferred);\n        } else if (tokensTransferred > 0) {\n            token.safeTransfer(receiver, tokensTransferred);\n        }\n    }\n\n    function _safeUint88(uint256 x) internal pure returns (uint88) {\n        require(x <= uint256(type(uint88).max));\n        return uint88(x);\n    }\n}"
    },
    {
      "filename": "wrapped-fcash/contracts/wfCashLogic.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashBase(_notional, _weth) {}\n\n    /***** Mint Methods *****/\n\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        (/* */, uint256 maxFCash) = getTotalFCashAvailable();\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, maxFCash);\n    }\n\n    function _mintInternal(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate,\n        uint256 maxFCash\n    ) internal nonReentrant {\n        require(!hasMatured(), \"fCash matured\");\n        (IERC20 token, bool isETH, bool hasTransferFee, uint256 precision) = _getTokenForMintInternal();\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint256 msgValue;\n        uint16 currencyId = getCurrencyId();\n        \n        if (isETH) {\n            // Use WETH if lending ETH. Although Notional natively supports ETH, we use WETH here for integration\n            // contracts so they only have to support ERC20 token transfers.\n            // NOTE: safeTransferFrom not required since WETH is known to be compatible\n            IERC20((address(WETH))).transferFrom(msg.sender, address(this), depositAmountExternal);\n            WETH.withdraw(depositAmountExternal);\n            msgValue = depositAmountExternal;\n        } else {\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n            depositAmountExternal = token.balanceOf(address(this)) - balanceBefore;\n        }\n\n        if (maxFCash < fCashAmount) {\n            // NOTE: lending at zero\n            uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n            require(fCashAmountExternal <= depositAmountExternal);\n\n            // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n            // back to the account\n            NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n        } else if (isETH || hasTransferFee || getCashBalance() > 0) {\n            _lendLegacy(currencyId, depositAmountExternal, fCashAmount, minImpliedRate, msgValue, isETH);\n        } else {\n            // Executes a lending action on Notional. Since this lending action uses an existing cash balance\n            // prior to pulling payment, we cannot use it if there is a cash balance on the wrapper contract,\n            // it will cause existing cash balances to be minted into fCash and create a shortfall. In normal\n            // conditions, this method is more gas efficient.\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\n                currencyId,\n                getMarketIndex(),\n                fCashAmount,\n                minImpliedRate\n            );\n            NotionalV2.batchLend(address(this), action);\n        }\n\n        // Mints ERC20 tokens for the receiver\n        _mint(receiver, fCashAmount);\n\n        // Residual tokens will be sent back to msg.sender, not the receiver. The msg.sender\n        // was used to transfer tokens in and these are any residual tokens left that were not\n        // lent out. Sending these tokens back to the receiver risks them getting locked on a\n        // contract that does not have the capability to transfer them off\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n\n    function _lendLegacy(\n        uint16 currencyId,\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        uint32 minImpliedRate,\n        uint256 msgValue,\n        bool isETH\n    ) internal {\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\n        // ETH. batchLend only supports ERC20 tokens. Since the wrapper is a compatibility\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\n        // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"\n        // is more gas efficient.\n\n        // If deposit amount external is in excess of the cost to purchase fCash amount (often the case),\n        // then we need to return the difference between postTradeCash - preTradeCash. This is done because\n        // the encoded trade does not automatically withdraw the entire cash balance in case the wrapper\n        // is holding a cash balance.\n        uint256 preTradeCash = getCashBalance();\n\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeLegacyLendTrade(\n            currencyId,\n            getMarketIndex(),\n            depositAmountExternal,\n            fCashAmount,\n            minImpliedRate\n        );\n        // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\n        // native ETH tokens will be wrapped back to WETH.\n        NotionalV2.batchBalanceAndTradeAction{value: msgValue}(address(this), action);\n\n        uint256 postTradeCash = getCashBalance();\n\n        if (preTradeCash != postTradeCash) {\n            // If ETH, then redeem to WETH (redeemToUnderlying == false)\n            NotionalV2.withdraw(currencyId, _safeUint88(postTradeCash - preTradeCash), !isETH);\n        }\n    }\n\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\n    /// back to the user.\n    function onERC1155Received(\n        address /* _operator */,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata /* _data */\n    ) external nonReentrant returns (bytes4) {\n        uint256 fCashID = getfCashId();\n        // Only accept erc1155 transfers from NotionalV2\n        require(msg.sender == address(NotionalV2), \"Invalid\");\n        // Only accept the fcash id that corresponds to the listed currency and maturity\n        require(_id == fCashID, \"Invalid\");\n        // Protect against signed value underflows\n        require(int256(_value) > 0, \"Invalid\");\n\n        // Double check the account's position, these are not strictly necessary and add gas costs\n        // but might be good safe guards\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\n        require(ac.hasDebt == 0x00);\n        require(assets.length == 1);\n        require(EncodeDecode.encodeERC1155Id(\n                assets[0].currencyId,\n                assets[0].maturity,\n                assets[0].assetType) == fCashID\n        );\n\n        // Mint ERC20 tokens for the sender\n        _mint(_from, _value);\n\n        // This will allow the fCash to be accepted\n        return ERC1155_ACCEPTED;\n    }\n\n    /***** Redeem (Burn) Methods *****/\n\n    /// @notice Redeems tokens using custom options\n    /// @dev re-entrancy is protected on _burn\n    function redeem(uint256 amount, RedeemOpts memory opts) external override {\n        _burnInternal(msg.sender, amount, opts);\n    }\n\n    /// @notice Redeems tokens to underlying\n    /// @dev re-entrancy is protected on _burn\n    function redeemToUnderlying(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        _burnInternal(\n            msg.sender,\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice This method is here only in the case where someone has transferred invalid fCash\n    /// to the contract and would prevent ERC1155 transfer hooks from succeeding. In this case the\n    /// owner can recover the invalid fCash to a designated receiver. This can only occur if the fCash\n    /// is transferred prior to contract creation.\n    function recoverInvalidfCash(uint256 fCashId, address receiver) external {\n        // Only the Notional owner can call this method\n        require(msg.sender == NotionalV2.owner());\n        // Cannot transfer the native fCash id of this wrapper\n        require(fCashId != getfCashId());\n        uint256 balance = NotionalV2.balanceOf(address(this), fCashId);\n        // There should be a positive balance before we try to transfer this\n        require(balance > 0);\n        NotionalV2.safeTransferFrom(address(this), receiver, fCashId, balance, \"\");\n        \n        // Double check that we don't incur debt\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        require(ac.hasDebt == 0x00);\n    }\n\n    /// @notice Called before tokens are burned (redemption) and so we will handle\n    /// the fCash properly before and after maturity.\n    function _burnInternal(\n        address from,\n        uint256 fCashShares,\n        RedeemOpts memory opts\n    ) internal nonReentrant {\n        require(opts.receiver != address(0), \"Receiver is zero address\");\n        require(opts.redeemToUnderlying || opts.transferfCash);\n        // This will validate that the account has sufficient tokens to burn and make\n        // any relevant underlying stateful changes to balances.\n        super._burn(from, fCashShares);\n\n        if (hasMatured()) {\n            require(opts.transferfCash == false);\n            // If the fCash has matured, then we need to ensure that the account is settled\n            // and then we will transfer back the account's share of asset tokens.\n\n            // This is a noop if the account is already settled, it is cheaper to call this method than\n            // cache it in storage locally\n            NotionalV2.settleAccount(address(this));\n            uint16 currencyId = getCurrencyId();\n            uint256 primeCashClaim = _getMaturedCashValue(fCashShares);\n\n            // Transfer withdrawn tokens to the `from` address\n            _withdrawCashToAccount(currencyId, opts.receiver, _safeUint88(primeCashClaim));\n        } else if (opts.transferfCash) {\n            // If the fCash has not matured, then we can transfer it via ERC1155.\n            // NOTE: this may fail if the destination is a contract and it does not implement \n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\n            // ERC20 transfer on this contract instead.\n            NotionalV2.safeTransferFrom(\n                address(this), // Sending from this contract\n                opts.receiver, // Where to send the fCash\n                getfCashId(), // fCash identifier\n                fCashShares, // Amount of fCash to send\n                \"\"\n            );\n        } else {\n            _sellfCash(opts.receiver, fCashShares, opts.maxImpliedRate);\n        }\n    }\n\n    /// @notice After maturity, withdraw cash back to account\n    function _withdrawCashToAccount(\n        uint16 currencyId,\n        address receiver,\n        uint88 primeCashToWithdraw\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n\n        NotionalV2.withdraw(currencyId, primeCashToWithdraw, !isETH);\n\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    /// @dev Sells an fCash share back on the Notional AMM\n    function _sellfCash(\n        address receiver,\n        uint256 fCashToSell,\n        uint32 maxImpliedRate\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint16 currencyId = getCurrencyId();\n\n        (uint256 initialCashBalance, uint256 fCashBalance) = getBalances();\n        bool hasInsufficientfCash = fCashBalance < fCashToSell;\n\n        uint256 primeCashToWithdraw;\n        if (hasInsufficientfCash) {\n            // If there is insufficient fCash, calculate how much prime cash would be purchased if the\n            // given fCash amount would be sold and that will be how much the wrapper will withdraw and\n            // send to the receiver. Since fCash always sells at a discount to underlying prior to maturity,\n            // the wrapper is guaranteed to have sufficient cash to send to the account.\n            (/* */, primeCashToWithdraw, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                fCashToSell,\n                getMaturity(),\n                0,\n                block.timestamp\n            );\n            // If this is zero then it signifies that the trade will fail.\n            require(primeCashToWithdraw > 0, \"Redeem Failed\");\n\n            // Re-write the fCash to sell to the entire fCash balance.\n            fCashToSell = fCashBalance;\n        }\n\n        if (fCashToSell > 0) {\n            // Sells fCash on Notional AMM (via borrowing)\n            BalanceActionWithTrades[] memory action = EncodeDecode.encodeBorrowTrade(\n                currencyId,\n                getMarketIndex(),\n                _safeUint88(fCashToSell),\n                maxImpliedRate\n            );\n            NotionalV2.batchBalanceAndTradeAction(address(this), action);\n        }\n\n        uint256 postTradeCash = getCashBalance();\n\n        // If the account did not have insufficient fCash, then the amount of cash change here is what\n        // the receiver is owed. In the other case, we transfer to the receiver the total calculated amount\n        // above without modification.\n        if (!hasInsufficientfCash) primeCashToWithdraw = postTradeCash - initialCashBalance;\n        require(primeCashToWithdraw <= postTradeCash);\n\n        // Withdraw the total amount of cash and send it to the receiver\n        NotionalV2.withdraw(currencyId, _safeUint88(primeCashToWithdraw), !isETH);\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    function _sendTokensToReceiver(\n        IERC20 token,\n        address receiver,\n        bool isETH,\n        uint256 balanceBefore\n    ) private returns (uint256 tokensTransferred) {\n        uint256 balanceAfter = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        tokensTransferred = balanceAfter - balanceBefore;\n\n        if (isETH) {\n            // No need to use safeTransfer for WETH since it is known to be compatible\n            IERC20(address(WETH)).transfer(receiver, tokensTransferred);\n        } else if (tokensTransferred > 0) {\n            token.safeTransfer(receiver, tokensTransferred);\n        }\n    }\n\n    function _safeUint88(uint256 x) internal pure returns (uint88) {\n        require(x <= uint256(type(uint88).max));\n        return uint88(x);\n    }\n}"
    },
    {
      "filename": "wrapped-fcash/contracts/wfCashLogic.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon"
    }
  ]
}