{
  "Title": "M-13: Flashloan end result isn't controlled",
  "Content": "# Issue M-13: Flashloan end result isn't controlled \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/101 \n\n## Found by \nhyh, CRYP70, minhtrng, ctf\\_sec\n\n## Summary\n\nFlashLoan logic do not control the end result of transferring tokens out and back in. Given that protocol aims to support arbitrary non-rebasing / without fee on transfer / decimals in `[1, 18]` fungible tokens to be quote and collateral of a pool, this includes any exotic types of behavior, for example, reporting a successful transfer, but not performing internal accounting update for any reason.\n\nAs an example, this can be a kind of wide blacklisting mechanics introduction (i.e. allow this white list of accounts, freeze everyone else type of logic).\n\n## Vulnerability Detail\n\nNow there is no control of the resulting balance, and any token that successfully performs safeTransfer, but for any reason withholds an update of token internal accounting, can successfully steal the whole pool's balance of any Ajna pool. This can be initiated by an attacker unrelated to token itself as griefing.\n\nAs many core token contracts are upgradable (USDC, USDT and so forth), such behaviour can be not in place right now, but can be introduced in the future.\n\n## Impact\n\nSome fungible tokens that qualify for Ajna pools (including not imposing any fee on transfers) may not return the whole amount back, but will report successful safeTransfer(), i.e. up to the whole balance of Ajna pool for such ERC20 token can be stolen.\n\nThis can take place in a situation when a popular token was upgraded and the consequences of the internal logic change weren't fully understood by wide market initially and most depositors remained in the corresponding Ajna pool, then someone calls a flash loan as a griefing attack that will result in the token freezing the balancer of the pool. Or it was understood, but the griefer was quicker.\n\nAs the probability of such internal mechanics introduction is low, but the impact is up to full loss of user's funds, setting the severity to be medium.\n\n## Code Snippet\n\nFlash loan functions do not employ any checks after ERC20 token was received back:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L236-L256\n\n```solidity\n    /// @inheritdoc FlashloanablePool\n    function flashLoan(\n        IERC3156FlashBorrower receiver_,\n        address token_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external override(IERC3156FlashLender, FlashloanablePool) nonReentrant returns (bool) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS)) return _flashLoanQuoteToken(receiver_, token_, amount_, data_);\n\n        if (token_ == _getArgAddress(COLLATERAL_ADDRESS)) {\n            _transferCollateral(address(receiver_), amount_);\n\n            if (receiver_.onFlashLoan(msg.sender, token_, amount_, 0, data_) !=\n                keccak256(\"ERC3156FlashBorrower.onFlashLoan\")) revert FlashloanCallbackFailed();\n\n            _transferCollateralFrom(address(receiver_), amount_);\n            return true;\n        }\n\n        revert FlashloanUnavailableForToken();\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/FlashloanablePool.sol#L33-L45\n\n```solidity\n    function _flashLoanQuoteToken(IERC3156FlashBorrower receiver_,\n        address token_,\n        uint256 amount_,\n        bytes calldata data_\n    ) internal returns (bool) {\n        _transferQuoteToken(address(receiver_), amount_);\n        \n        if (receiver_.onFlashLoan(msg.sender, token_, amount_, 0, data_) != \n            keccak256(\"ERC3156FlashBorrower.onFlashLoan\")) revert FlashloanCallbackFailed();\n\n        _transferQuoteTokenFrom(address(receiver_), amount_);\n        return true;\n    }\n```\n\nFlash loan safety is now controlled by safeTransfer() only, which internal mechanics can vary between ERC20 tokens:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L502-L508\n\n```solidity\n    function _transferQuoteTokenFrom(address from_, uint256 amount_) internal {\n        IERC20(_getArgAddress(QUOTE_ADDRESS)).safeTransferFrom(from_, address(this), amount_ / _getArgUint256(QUOTE_SCALE));\n    }\n\n    function _transferQuoteToken(address to_, uint256 amount_) internal {\n        IERC20(_getArgAddress(QUOTE_ADDRESS)).safeTransfer(to_, amount_ / _getArgUint256(QUOTE_SCALE));\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a balance control check to ensure that flash loan invariant remains: record contract balance before `receiver_.onFlashLoan(...)` callback and record it after `_transferQuoteTokenFrom(address(receiver_), amount_)`, require that resulting token balance ends up being not less than initial.\n\nThis applies both to ERC20Pool's flashLoan() and FlashloanablePool's _flashLoanQuoteToken().\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/ERC20Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }    from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { \n    IERC20Pool,\n    IERC20PoolBorrowerActions,\n    IERC20PoolImmutables,\n    IERC20PoolLenderActions\n}                              from './interfaces/pool/erc20/IERC20Pool.sol';\nimport { IERC20Taker }         from './interfaces/pool/erc20/IERC20Taker.sol';\n\nimport {\n    IPoolLenderActions,\n    IPoolLiquidationActions,\n    IERC20Token\n}                            from './interfaces/pool/IPool.sol';\nimport {\n    IERC3156FlashBorrower,\n    IERC3156FlashLender\n}                            from './interfaces/pool/IERC3156FlashLender.sol';\n\nimport {\n    DrawDebtResult,\n    BucketTakeResult,\n    RepayDebtResult,\n    SettleParams,\n    TakeResult\n}                    from './interfaces/pool/commons/IPoolInternals.sol';\nimport { PoolState } from './interfaces/pool/commons/IPoolState.sol';\n\nimport { FlashloanablePool } from './base/FlashloanablePool.sol';\n\nimport {\n    _getCollateralDustPricePrecisionAdjustment,\n    _roundToScale,\n    _roundUpToScale\n}                                               from './libraries/helpers/PoolHelper.sol';\nimport { _revertIfAuctionClearable }            from './libraries/helpers/RevertsHelper.sol';\n\nimport { Loans }    from './libraries/internal/Loans.sol';\nimport { Deposits } from './libraries/internal/Deposits.sol';\nimport { Maths }    from './libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from './libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from './libraries/external/LenderActions.sol';\nimport { Auctions }        from './libraries/external/Auctions.sol';\n\n/**\n *  @title  ERC20 Pool contract\n *  @notice Entrypoint of ERC20 Pool actions for pool actors:\n *          - Lenders: add, remove and move quote tokens; transfer LPs\n *          - Borrowers: draw and repay debt\n *          - Traders: add, remove and move quote tokens; add and remove collateral\n *          - Kickers: kick undercollateralized loans; settle auctions; claim bond rewards\n *          - Bidders: take auctioned collateral\n *          - Reserve purchasers: start auctions; take reserves\n *          - Flash borrowers: initiate flash loans on quote tokens and collateral\n *  @dev    Contract is FlashloanablePool with flash loan logic.\n *  @dev    Contract is base Pool with logic to handle ERC20 collateral.\n *  @dev    Calls logic from external PoolCommons, LenderActions, BorrowerActions and Auctions libraries.\n */\ncontract ERC20Pool is FlashloanablePool, IERC20Pool {\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant COLLATERAL_SCALE = 93;\n\n    /****************************/\n    /*** Initialize Functions ***/\n    /****************************/\n\n    /// @inheritdoc IERC20Pool\n    function initialize(\n        uint256 rate_\n    ) external override {\n        if (isPoolInitialized) revert AlreadyInitialized();\n\n        inflatorState.inflator       = uint208(1e18);\n        inflatorState.inflatorUpdate = uint48(block.timestamp);\n\n        interestState.interestRate       = uint208(rate_);\n        interestState.interestRateUpdate = uint48(block.timestamp);\n\n        Loans.init(loans);\n\n        // increment initializations count to ensure these values can't be updated\n        isPoolInitialized = true;\n    }\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IERC20PoolImmutables\n    function collateralScale() external pure override returns (uint256) {\n        return _getArgUint256(COLLATERAL_SCALE);\n    }\n\n    /// @inheritdoc IERC20Pool\n    function bucketCollateralDust(uint256 bucketIndex) external pure override returns (uint256) {\n        return _bucketCollateralDust(bucketIndex);\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - increment poolBalances.pledgedCollateral accumulator\n     *          - increment poolBalances.t0Debt accumulator\n     *  @dev emit events:\n     *          - DrawDebt\n     */\n    function drawDebt(\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure the borrower is not credited with a fractional amount of collateral smaller than the token scale\n        collateralToPledge_ = _roundToScale(collateralToPledge_, _bucketCollateralDust(0));\n\n        DrawDebtResult memory result = BorrowerActions.drawDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            amountToBorrow_,\n            limitIndex_,\n            collateralToPledge_\n        );\n\n        emit DrawDebt(borrowerAddress_, amountToBorrow_, collateralToPledge_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (collateralToPledge_ != 0) {\n            // update pool balances state\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n            poolBalances.pledgedCollateral += collateralToPledge_;\n\n            // move collateral from sender to pool\n            _transferCollateralFrom(msg.sender, collateralToPledge_);\n        }\n\n        if (amountToBorrow_ != 0) {\n            // update pool balances state\n            poolBalances.t0Debt += result.t0DebtChange;\n\n            // move borrowed amount from pool to sender\n            _transferQuoteToken(msg.sender, amountToBorrow_);\n        }\n    }\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     *  @dev emit events:\n     *          - RepayDebt\n     */\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure accounting is performed using the appropriate token scale\n        maxQuoteTokenAmountToRepay_ = _roundToScale(maxQuoteTokenAmountToRepay_, _getArgUint256(QUOTE_SCALE));\n        collateralAmountToPull_     = _roundToScale(collateralAmountToPull_,     _bucketCollateralDust(0));\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            collateralAmountToPull_\n        );\n\n        emit RepayDebt(borrowerAddress_, result.quoteTokenToRepay, collateralAmountToPull_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.quoteTokenToRepay != 0) {\n            // update pool balances state\n            poolBalances.t0Debt -= result.t0RepaidDebt;\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n\n            // move amount to repay from sender to pool\n            _transferQuoteTokenFrom(msg.sender, result.quoteTokenToRepay);\n        }\n        if (collateralAmountToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = result.poolCollateral;\n\n            // move collateral from pool to sender\n            _transferCollateral(msg.sender, collateralAmountToPull_);\n        }\n    }\n\n    /************************************/\n    /*** Flashloan External Functions ***/\n    /************************************/\n\n    /// @inheritdoc FlashloanablePool\n    function flashLoan(\n        IERC3156FlashBorrower receiver_,\n        address token_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external override(IERC3156FlashLender, FlashloanablePool) nonReentrant returns (bool) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS)) return _flashLoanQuoteToken(receiver_, token_, amount_, data_);\n\n        if (token_ == _getArgAddress(COLLATERAL_ADDRESS)) {\n            _transferCollateral(address(receiver_), amount_);\n\n            if (receiver_.onFlashLoan(msg.sender, token_, amount_, 0, data_) !=\n                keccak256(\"ERC3156FlashBorrower.onFlashLoan\")) revert FlashloanCallbackFailed();\n\n            _transferCollateralFrom(address(receiver_), amount_);\n            return true;\n        }\n\n        revert FlashloanUnavailableForToken();\n    }\n\n    /// @inheritdoc FlashloanablePool\n    function flashFee(\n        address token_,\n        uint256\n    ) external pure override(IERC3156FlashLender, FlashloanablePool) returns (uint256) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS) || token_ == _getArgAddress(COLLATERAL_ADDRESS)) return 0;\n        revert FlashloanUnavailableForToken();\n    }\n\n    /// @inheritdoc FlashloanablePool\n    function maxFlashLoan(\n        address token_\n    ) external view override(IERC3156FlashLender, FlashloanablePool) returns (uint256 maxLoan_) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS) || token_ == _getArgAddress(COLLATERAL_ADDRESS)) {\n            maxLoan_ = IERC20Token(token_).balanceOf(address(this));\n        }\n    }\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolLenderActions\n     *  @dev reverts on:\n     *          - DustAmountNotExceeded()\n     *  @dev emit events:\n     *          - AddCollateral\n     */\n    function addCollateral(\n        uint256 amountToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // revert if the dust amount was not exceeded, but round on the scale amount\n        if (amountToAdd_ != 0 && amountToAdd_ < _bucketCollateralDust(index_)) revert DustAmountNotExceeded();\n        amountToAdd_ = _roundToScale(amountToAdd_, _getArgUint256(COLLATERAL_SCALE));\n\n        bucketLPs_ = LenderActions.addCollateral(\n            buckets,\n            deposits,\n            amountToAdd_,\n            index_\n        );\n\n        emit AddCollateral(msg.sender, index_, amountToAdd_, bucketLPs_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move required collateral from sender to pool\n        _transferCollateralFrom(msg.sender, amountToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev emit events:\n     *          - RemoveCollateral\n     */\n    function removeCollateral(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 collateralAmount_, uint256 lpAmount_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round the collateral amount appropriately based on token precision\n        maxAmount_ = _roundToScale(maxAmount_, _getArgUint256(COLLATERAL_SCALE));\n\n        (collateralAmount_, lpAmount_) = LenderActions.removeMaxCollateral(\n            buckets,\n            deposits,\n            maxAmount_,\n            index_\n        );\n\n        emit RemoveCollateral(msg.sender, index_, collateralAmount_, lpAmount_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move collateral from pool to lender\n        _transferCollateral(msg.sender, collateralAmount_);\n    }\n\n    /*******************************/\n    /*** Pool Auctions Functions ***/\n    /*******************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function settle(\n        address borrowerAddress_,\n        uint256 maxDepth_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();\n\n        uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;\n\n        (\n            ,\n            ,\n            uint256 collateralSettled,\n            uint256 t0DebtSettled\n        ) = Auctions.settlePoolDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            SettleParams({\n                borrower:    borrowerAddress_,\n                reserves:    (assets > liabilities) ? (assets - liabilities) : 0,\n                inflator:    poolState.inflator,\n                bucketDepth: maxDepth_,\n                poolType:    poolState.poolType\n            })\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt            -= t0DebtSettled;\n        poolBalances.t0DebtInAuction   -= t0DebtSettled;\n        poolBalances.pledgedCollateral -= collateralSettled;\n\n        // update pool interest rate state\n        poolState.debt       -= Maths.wmul(t0DebtSettled, poolState.inflator);\n        poolState.collateral -= collateralSettled;\n        _updateInterestState(poolState, _lup(poolState.debt));\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function take(\n        address        borrowerAddress_,\n        uint256        collateral_,\n        address        callee_,\n        bytes calldata data_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 collateralDust = _bucketCollateralDust(0);\n\n        // round requested collateral to an amount which can actually be transferred\n        collateral_ = _roundToScale(collateral_, collateralDust);\n\n        TakeResult memory result = Auctions.take(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            collateral_,\n            collateralDust\n        );\n        // round quote token up to cover the cost of purchasing the collateral\n        result.quoteTokenAmount = _roundUpToScale(result.quoteTokenAmount, _getArgUint256(QUOTE_SCALE));\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       =  result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        _transferCollateral(callee_, result.collateralAmount);\n\n        if (data_.length != 0) {\n            IERC20Taker(callee_).atomicSwapCallback(\n                result.collateralAmount / _getArgUint256(COLLATERAL_SCALE), \n                result.quoteTokenAmount / _getArgUint256(QUOTE_SCALE), \n                data_\n            );\n        }\n\n        _transferQuoteTokenFrom(callee_, result.quoteTokenAmount);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function bucketTake(\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_\n    ) external override nonReentrant {\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        BucketTakeResult memory result = Auctions.bucketTake(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            depositTake_,\n            index_,\n            _bucketCollateralDust(0)\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    function _transferCollateralFrom(address from_, uint256 amount_) internal {\n        IERC20(_getArgAddress(COLLATERAL_ADDRESS)).safeTransferFrom(from_, address(this), amount_ / _getArgUint256(COLLATERAL_SCALE));\n    }\n\n    function _transferCollateral(address to_, uint256 amount_) internal {\n        IERC20(_getArgAddress(COLLATERAL_ADDRESS)).safeTransfer(to_, amount_ / _getArgUint256(COLLATERAL_SCALE));\n    }\n\n    function _bucketCollateralDust(uint256 bucketIndex) internal pure returns (uint256) {\n        // price precision adjustment will always be 0 for encumbered collateral\n        uint256 pricePrecisionAdjustment = _getCollateralDustPricePrecisionAdjustment(bucketIndex);\n        // difference between the normalized scale and the collateral token's scale\n        return Maths.max(_getArgUint256(COLLATERAL_SCALE), 10 ** pricePrecisionAdjustment);\n    } \n}"
    },
    {
      "filename": "contracts/src/base/FlashloanablePool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { Pool }                  from './Pool.sol';\nimport { IERC3156FlashBorrower } from '../interfaces/pool/IERC3156FlashBorrower.sol';\n\n/**\n *  @title  Flashloanable Pool Contract\n *  @notice Pool contract with IERC3156 flash loans capabilities.\n *  @notice No fee is charged for taking flash loans from pool.\n *  @notice Flash loans can be taking in ERC20 quote and ERC20 collateral tokens.\n */\nabstract contract FlashloanablePool is Pool {\n    /**\n     *  @notice Called by flashloan borrowers to borrow liquidity which must be repaid in the same transaction.\n     *  @param  receiver_ Address of the contract which implements the appropriate interface to receive tokens.\n     *  @param  token_    Address of the ERC20 token caller wants to borrow.\n     *  @param  amount_   The amount of tokens to borrow.\n     *  @param  data_     User-defined calldata passed to the receiver.\n     *  @return True if successful.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver_,\n        address token_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external virtual override nonReentrant returns (bool) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS)) return _flashLoanQuoteToken(receiver_, token_, amount_, data_);\n        revert FlashloanUnavailableForToken();\n    }\n\n    function _flashLoanQuoteToken(IERC3156FlashBorrower receiver_,\n        address token_,\n        uint256 amount_,\n        bytes calldata data_\n    ) internal returns (bool) {\n        _transferQuoteToken(address(receiver_), amount_);\n        \n        if (receiver_.onFlashLoan(msg.sender, token_, amount_, 0, data_) != \n            keccak256(\"ERC3156FlashBorrower.onFlashLoan\")) revert FlashloanCallbackFailed();\n\n        _transferQuoteTokenFrom(address(receiver_), amount_);\n        return true;\n    }\n\n    /**\n     *  @notice Returns 0, as no fee is charged for flashloans.\n     */\n    function flashFee(\n        address token_,\n        uint256\n    ) external virtual view override returns (uint256) {\n        if (token_ != _getArgAddress(QUOTE_ADDRESS)) revert FlashloanUnavailableForToken();\n        return 0;\n    }\n\n    /**\n     *  @notice Returns the amount of tokens available to be lent.\n     *  @param  token_   Address of the ERC20 token to be lent.\n     *  @return maxLoan_ The amount of `token_` that can be lent.\n     */\n     function maxFlashLoan(\n        address token_\n    ) external virtual view override returns (uint256 maxLoan_) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS)) maxLoan_ = _getPoolQuoteTokenBalance();\n    }\n}"
    },
    {
      "filename": "contracts/src/base/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { Clone }           from '@clones/Clone.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { SafeERC20 }       from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }          from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {\n    IPool,\n    IPoolImmutables,\n    IPoolLenderActions,\n    IPoolState,\n    IPoolLiquidationActions,\n    IPoolReserveAuctionActions,\n    IPoolDerivedState,\n    IERC20Token\n}                                    from '../interfaces/pool/IPool.sol';\nimport {\n    PoolState,\n    AuctionsState,\n    DepositsState,\n    LoansState,\n    InflatorState,\n    InterestState,\n    PoolBalancesState,\n    ReserveAuctionState,\n    Bucket,\n    BurnEvent,\n    Liquidation\n}                                    from '../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    RemoveQuoteParams,\n    MoveQuoteParams,\n    AddQuoteParams\n}                                    from '../interfaces/pool/commons/IPoolInternals.sol';\nimport { StartReserveAuctionParams } from '../interfaces/pool/commons/IPoolReserveAuctionActions.sol';\n\nimport {\n    _priceAt,\n    _roundToScale\n}                               from '../libraries/helpers/PoolHelper.sol';\nimport {\n    _revertIfAuctionDebtLocked,\n    _revertIfAuctionClearable\n}                               from '../libraries/helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../libraries/internal/Buckets.sol';\nimport { Deposits } from '../libraries/internal/Deposits.sol';\nimport { Loans }    from '../libraries/internal/Loans.sol';\nimport { Maths }    from '../libraries/internal/Maths.sol';\n\nimport { Auctions }        from '../libraries/external/Auctions.sol';\nimport { BorrowerActions } from '../libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from '../libraries/external/LenderActions.sol';\nimport { PoolCommons }     from '../libraries/external/PoolCommons.sol';\n\n/**\n *  @title  Pool Contract\n *  @dev    Base contract and entrypoint for commong logic of both ERC20 and ERC721 pools.\n */\nabstract contract Pool is Clone, ReentrancyGuard, Multicall, IPool {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant POOL_TYPE          = 0;\n    uint256 internal constant AJNA_ADDRESS       = 1;\n    uint256 internal constant COLLATERAL_ADDRESS = 21;\n    uint256 internal constant QUOTE_ADDRESS      = 41;\n    uint256 internal constant QUOTE_SCALE        = 61;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    AuctionsState       internal auctions;\n    DepositsState       internal deposits;\n    LoansState          internal loans;\n    InflatorState       internal inflatorState;\n    InterestState       internal interestState;\n    PoolBalancesState   internal poolBalances;\n    ReserveAuctionState internal reserveAuction;\n\n    mapping(uint256 => Bucket) internal buckets;   // deposit index -> bucket\n\n    bool internal isPoolInitialized;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _lpTokenAllowances; // owner address -> new owner address -> deposit index -> allowed amount\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IPoolImmutables\n    function poolType() external pure override returns (uint8) {\n        return _getArgUint8(POOL_TYPE);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function collateralAddress() external pure override returns (address) {\n        return _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenAddress() external pure override returns (address) {\n        return _getArgAddress(QUOTE_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenScale() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n    function quoteTokenDust() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /// @inheritdoc IPoolLenderActions\n    function addQuoteToken(\n        uint256 quoteTokenAmountToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round to token precision\n        quoteTokenAmountToAdd_ = _roundToScale(quoteTokenAmountToAdd_, poolState.quoteDustLimit);\n\n        uint256 newLup;\n        (bucketLPs_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount: quoteTokenAmountToAdd_,\n                index:  index_\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from lender to pool\n        _transferQuoteTokenFrom(msg.sender, quoteTokenAmountToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev write state:\n     *          - _lpTokenAllowances mapping\n     */\n    function approveLpOwnership(\n        address allowedNewOwner_,\n        uint256 index_,\n        uint256 lpsAmountToApprove_\n    ) external nonReentrant {\n        _lpTokenAllowances[msg.sender][allowedNewOwner_][index_] = lpsAmountToApprove_;\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function moveQuoteToken(\n        uint256 maxAmountToMove_,\n        uint256 fromIndex_,\n        uint256 toIndex_\n    ) external override nonReentrant returns (uint256 fromBucketLPs_, uint256 toBucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolBalances, fromIndex_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            fromBucketLPs_,\n            toBucketLPs_,\n            newLup\n        ) = LenderActions.moveQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            MoveQuoteParams({\n                maxAmountToMove: maxAmountToMove_,\n                fromIndex:       fromIndex_,\n                toIndex:         toIndex_,\n                thresholdPrice:  Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function removeQuoteToken(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLPs_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolBalances, index_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            removedAmount_,\n            redeemedLPs_,\n            newLup\n        ) = LenderActions.removeQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            RemoveQuoteParams({\n                maxAmount:      maxAmount_,\n                index:          index_,\n                thresholdPrice: Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from pool to lender\n        _transferQuoteToken(msg.sender, removedAmount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function transferLPs(\n        address owner_,\n        address newOwner_,\n        uint256[] calldata indexes_\n    ) external override nonReentrant {\n        LenderActions.transferLPs(\n            buckets,\n            _lpTokenAllowances,\n            owner_,\n            newOwner_,\n            indexes_\n        );\n    }\n\n    /*****************************/\n    /*** Liquidation Functions ***/\n    /*****************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - increment poolBalances.t0DebtInAuction and poolBalances.t0Debt accumulators\n     */\n    function kick(\n        address borrowerAddress_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auction\n        KickResult memory result = Auctions.kick(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_\n        );\n\n        // update pool balances state\n        poolBalances.t0DebtInAuction += result.t0KickedDebt;\n        poolBalances.t0Debt          += result.t0KickPenalty;\n\n        // update pool interest rate state\n        poolState.debt += result.kickPenalty;\n        _updateInterestState(poolState, result.lup);\n\n        if(result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - increment poolBalances.t0DebtInAuction and poolBalances.t0Debt accumulators\n     */\n    function kickWithDeposit(\n        uint256 index_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auctions\n        KickResult memory result = Auctions.kickWithDeposit(\n            auctions,\n            deposits,\n            buckets,\n            loans,\n            poolState,\n            index_\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt          += result.t0KickPenalty;\n        poolBalances.t0DebtInAuction += result.t0KickedDebt;\n\n        // update pool interest rate state\n        poolState.debt += result.kickPenalty;\n        _updateInterestState(poolState, result.lup);\n\n        // transfer from kicker to pool the difference to cover bond\n        if(result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - reset kicker's claimable accumulator\n     */\n    function withdrawBonds() external {\n        uint256 claimable = auctions.kickers[msg.sender].claimable;\n        auctions.kickers[msg.sender].claimable = 0;\n        _transferQuoteToken(msg.sender, claimable);\n    }\n\n    /*********************************/\n    /*** Reserve Auction Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IPoolReserveAuctionActions\n     *  @dev  write state:\n     *          - increment latestBurnEpoch counter\n     *          - update reserveAuction.latestBurnEventEpoch and burn event ti"
    }
  ]
}