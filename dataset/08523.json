{
  "Title": "[H-15] Failed proposal can be committed again",
  "Content": "_Submitted by 0x52, also found by hansfriese_\n\nFailed proposal can be committed again and eth stolen from migration contract in combination with other vulnerabilities submitted.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L194>\n\nCommit can be called as long as it has been less than 7 days from the start time. The buyout period is specified as 4 days in the buyout contract. This means that as long as proposal is committed within 3 days of starting, commit can be called again after a failed buyout (4 days) because the current time will still be less than 7 days from the start time.\n\nThis can be used in combination with a vulnerability I previously reported. The contract does not account for the actual number of fractions that it receives back from a failed buyout. If it sent 10 fractions and 3 eth to a buyout it may receive back 15 fractions and 2 eth due to trading against the buyout. Because commit can called again on the same proposal, the second time it will try to send the fraction balance of the contract, now 15, and the value of the eth in the proposal, 3 eth. This transaction will either revert due to not having enough eth or it will send 3 eth pulling from eth deposited to other migration proposals.\n\nThis could be exploited by creating a vault and immediately migrating it. Once the migration starts the user could sell fractions to themselves and get eth, making sure to keep the number of fractions under 51%, to prevent a successful buyout. After the buyout fails they can then call the commit function again and more eth will be sent. They can then sell fractions to themselves netting more eth than they initially supplied. This could be done repeatedly until all eth has been stolen from the migration contract.\n\n### Recommended Mitigation Steps\n\nChange the length of either the migration period or the buyout period to match so that a proposal can't be replayed.\n\n**[stevennevins (Fractional) confirmed](https://github.com/code-423n4/2022-07-fractional-findings/issues/251)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/124#issuecomment-1212251002):**\n> Committing a failed proposal multiple times can steal funds from the migration contract. Agree this is High risk.\n> \n> Making this submission the primary for talking through the potential vulnerability here.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/modules/Migration.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {IFERC1155} from \"../interfaces/IFERC1155.sol\";\nimport {IMigration, Proposal} from \"../interfaces/IMigration.sol\";\nimport {IModule} from \"../interfaces/IModule.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {Minter} from \"./Minter.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\n/// @title Migration\n/// @author Fractional Art\n/// @notice Module contract for vaults to migrate to a new set of permissions\n/// - A fractional holder creates a proposal with a target price and list of modules\n/// - For 7 days, users can contribute their fractions / ether to signal support\n/// - If the target price is reached then a buyout can be triggered and trading\n///   against the proposed buyout price can take place to resolve the outcome\n/// - If a proposal holds more than 51% of the total supply, the buyout succeeds, a new vault can\n///   be created and the underlying assets (ERC-20, ERC-721 and ERC-1155 tokens) can be migrated\ncontract Migration is\n    IMigration,\n    MerkleBase,\n    Minter,\n    Multicall,\n    NFTReceiver,\n    ReentrancyGuard\n{\n    /// @notice Address of Buyout module contract\n    address payable public buyout;\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Counter used to assign IDs to new proposals\n    uint256 public nextId;\n    /// @notice The length for the migration proposal period\n    uint256 public constant PROPOSAL_PERIOD = 7 days;\n    /// @notice Mapping of a vault to it's proposal migration information\n    mapping(address => mapping(uint256 => Proposal)) public migrationInfo;\n    /// @notice Mapping of a proposal ID to a user's ether contribution\n    mapping(uint256 => mapping(address => uint256)) private userProposalEth;\n    /// @notice Mapping of a proposal ID to a user's fractions contribution\n    mapping(uint256 => mapping(address => uint256))\n        private userProposalFractions;\n\n    /// @notice Initializes buyout, registry, and supply contracts\n    constructor(\n        address _buyout,\n        address _registry,\n        address _supply\n    ) Minter(_supply) {\n        buyout = payable(_buyout);\n        registry = _registry;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a set of modules and plugins to migrate a vault to\n    /// @param _vault Address of the vault\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    /// @param _newFractionSupply New supply of fractional tokens\n    /// @param _targetPrice Target price of the buyout\n    function propose(\n        address _vault,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Initializes migration proposal info\n        Proposal storage proposal = migrationInfo[_vault][++nextId];\n        proposal.startTime = block.timestamp;\n        proposal.targetPrice = _targetPrice;\n        proposal.modules = _modules;\n        proposal.plugins = _plugins;\n        proposal.selectors = _selectors;\n        proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(\n            _vault\n        );\n        proposal.newFractionSupply = _newFractionSupply;\n    }\n\n    /// @notice Joins a migration proposal by contributing ether and fractional tokens\n    /// @param _vault The address of the vault\n    /// @param _proposalId ID of the proposal being contributed to\n    /// @param _amount Number of fractions being contributed\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable nonReentrant {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates ether balances of the proposal and caller\n        proposal.totalEth += msg.value;\n        userProposalEth[_proposalId][msg.sender] += msg.value;\n        // Deposits fractional tokens into contract\n        IFERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates fraction balances of the proposal and caller\n        proposal.totalFractions += _amount;\n        userProposalFractions[_proposalId][msg.sender] += _amount;\n    }\n\n    /// @notice Leaves a proposed migration with contribution amount\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being left\n    function leave(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates fraction balances of the proposal and caller\n        uint256 amount = userProposalFractions[_proposalId][msg.sender];\n        proposal.totalFractions -= amount;\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Updates ether balances of the proposal and caller\n        uint256 ethAmount = userProposalEth[_proposalId][msg.sender];\n        proposal.totalEth -= ethAmount;\n        userProposalEth[_proposalId][msg.sender] = 0;\n\n        // Withdraws fractions from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(ethAmount);\n    }\n\n    /// @notice Kicks off the buyout process for a migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being committed to\n    /// @return started Bool status of starting the buyout process\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started)\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if migration is passed proposal period\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (block.timestamp > proposal.startTime + PROPOSAL_PERIOD)\n            revert ProposalOver();\n\n        // Calculates current price of the proposal based on total supply\n        uint256 currentPrice = _calculateTotal(\n            100,\n            IVaultRegistry(registry).totalSupply(_vault),\n            proposal.totalEth,\n            proposal.totalFractions\n        );\n\n        // Checks if the current price is greater than target price of the proposal\n        if (currentPrice > proposal.targetPrice) {\n            // Sets token approval to the buyout contract\n            IFERC1155(token).setApprovalFor(address(buyout), id, true);\n            // Starts the buyout process\n            IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n            proposal.isCommited = true;\n            started = true;\n        }\n    }\n\n    /// @notice Settles a migration by ending the buyout\n    /// @dev Succeeds if buyout goes through, fails otherwise\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being settled\n    function settleVault(address _vault, uint256 _proposalId) external {\n        // Reverts if the migration was not proposed\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (!(proposal.isCommited)) revert NotProposed();\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if the new vault has already been deployed\n        if (proposal.newVault != address(0))\n            revert NewVaultAlreadyDeployed(proposal.newVault);\n\n        // Gets the merkle root for the vault and given proposal ID\n        bytes32[] memory merkleTree = generateMerkleTree(proposal.modules);\n        bytes32 merkleRoot = getRoot(merkleTree);\n        // Deploys a new vault with set permissions and plugins\n        address newVault = IVaultRegistry(registry).create(\n            merkleRoot,\n            proposal.plugins,\n            proposal.selectors\n        );\n        // Sets address of the newly deployed vault\n        proposal.newVault = newVault;\n        // Emits event for settling the new vault\n        emit VaultMigrated(\n            _vault,\n            newVault,\n            _proposalId,\n            proposal.modules,\n            proposal.plugins,\n            proposal.selectors\n        );\n    }\n\n    /// @notice Mints the fractional tokens for a new vault\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _mintProof Merkle proof for minting fractional tokens\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] calldata _mintProof\n    ) external {\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if there is no new vault to migrate to\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (proposal.newVault == address(0)) revert NoVaultToMigrateTo();\n        // Reverts if fractions of the new vault have already been minted\n        if (proposal.fractionsMigrated) revert NewFractionsAlreadyMinted();\n\n        // Mints initial supply of fractions for the new vault\n        _mintFractions(\n            proposal.newVault,\n            address(this),\n            proposal.newFractionSupply,\n            _mintProof\n        );\n\n        migrationInfo[_vault][_proposalId].fractionsMigrated = true;\n        // Emits event for minting fractional tokens for the new vault\n        emit FractionsMigrated(\n            _vault,\n            proposal.newVault,\n            _proposalId,\n            proposal.newFractionSupply\n        );\n    }\n\n    /// @notice Retrieves ether and fractions deposited from an unsuccessful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the failed proposal\n    function withdrawContribution(address _vault, uint256 _proposalId)\n        external\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if caller has no fractional balance to withdraw\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (\n            current != State.INACTIVE ||\n            migrationInfo[_vault][_proposalId].newVault != address(0)\n        ) revert NoContributionToWithdraw();\n\n        // Temporarily store user's fractions for the transfer\n        uint256 userFractions = userProposalFractions[_proposalId][msg.sender];\n        // Updates fractional balance of caller\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Withdraws fractional tokens from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            userFractions,\n            \"\"\n        );\n\n        // Temporarily store user's eth for the transfer\n        uint256 userEth = userProposalEth[_proposalId][msg.sender];\n        // Udpates ether balance of caller\n        userProposalEth[_proposalId][msg.sender] = 0;\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(userEth);\n    }\n\n    /// @notice Migrates an ERC-20 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-20 token\n    /// @param _amount Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-20 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC20(\n            _vault,\n            _token,\n            newVault,\n            _amount,\n            _erc20TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-721 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-721 token\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC721(\n            _vault,\n            _token,\n            newVault,\n            _tokenId,\n            _erc721TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-1155 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _id ID of the token\n    /// @param _amount amount to be transferred\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function migrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _id,\n        uint256 _amount,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-1155 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _id,\n            _amount,\n            _erc1155TransferProof\n        );\n    }\n\n    /// @notice Batch migrates multiple ERC-1155 tokens to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _ids IDs of each token type\n    /// @param _amounts Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for batch transferring multiple ERC-1155 tokens\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Batch withdraws multiple ERC-1155 tokens from the old vault and transfers to the new vault\n        IBuyout(buyout).batchWithdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _ids,\n            _amounts,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Migrates the caller's fractions from an old vault to a new one after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    function migrateFractions(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not successful\n        (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        State required = State.SUCCESS;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if proposer of buyout is not this contract\n        if (proposer != address(this)) revert NotProposalBuyout();\n\n        // Gets the last total supply of fractions for the vault\n        (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        // Calculates the total ether amount of a successful proposal\n        uint256 totalInEth = _calculateTotal(\n            1 ether,\n            lastTotalSupply,\n            migrationInfo[_vault][_proposalId].totalEth,\n            migrationInfo[_vault][_proposalId].totalFractions\n        );\n        // Calculates balance of caller based on ether contribution\n        uint256 balanceContributedInEth = _calculateContribution(\n            totalInEth,\n            lastTotalSupply,\n            userProposalEth[_proposalId][msg.sender],\n            userProposalFractions[_proposalId][msg.sender]\n        );\n\n        // Gets the token and fraction ID of the new vault\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        (address token, uint256 newFractionId) = IVaultRegistry(registry)\n            .vaultToToken(newVault);\n        // Calculates share amount of fractions for the new vault based on the new total supply\n        uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);\n        uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /\n            totalInEth;\n\n        // Transfers fractional tokens to caller based on share amount\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            newFractionId,\n            shareAmount,\n            \"\"\n        );\n    }\n\n    /// @notice Generates the merkle tree of a given proposal\n    /// @param _modules List of module contracts\n    /// @return hashes Combined list of leaf nodes\n    function generateMerkleTree(address[] memory _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 treeLength;\n        uint256 modulesLength = _modules.length;\n\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                treeLength += IModule(_modules[i]).getLeafNodes().length;\n            }\n        }\n\n        uint256 counter;\n        hashes = new bytes32[](treeLength);\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                uint256 leavesLength = leaves.length;\n                for (uint256 j; j < leavesLength; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates the total amount of ether\n    /// @param _scalar Scalar used for multiplication\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _totalEth Total ether balance of the proposal\n    /// @param _totalFractions Total fractional balance of the proposal\n    /// @return Total amount of ether\n    function _calculateTotal(\n        uint256 _scalar,\n        uint256 _lastTotalSupply,\n        uint256 _totalEth,\n        uint256 _totalFractions\n    ) private pure returns (uint256) {\n        return\n            (_totalEth * _scalar) /\n            (_scalar - ((_totalFractions * _scalar) / _lastTotalSupply));\n    }\n\n    /// @notice Calculates the amount of ether contributed by the user\n    /// @param _totalInEth Total amount of ether\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _userProposalEth User balance of ether for the proposal\n    /// @param _userProposalFractions User balance of fractions for the proposal\n    /// @return Total contribution amount\n    function _calculateContribution(\n        uint256 _totalInEth,\n        uint256 _lastTotalSupply,\n        uint256 _userProposalEth,\n        uint256 _userProposalFractions\n    ) private pure returns (uint256) {\n        return\n            _userProposalEth +\n            (_userProposalFractions * _totalInEth) /\n            _lastTotalSupply;\n    }\n}"
    }
  ]
}