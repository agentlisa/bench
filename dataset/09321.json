{
  "Title": "[M-04] `RewardsController` Emission Manager Can Authorize Users to Claim on Behalf of the `AaveV3YieldSource` Contract and Siphon Yield",
  "Content": "_Submitted by leastwood_\n\n[aave/RewardsController.sol#L190-L193](https://github.com/aave/aave-v3-periphery/blob/master/contracts/rewards/RewardsController.sol#L190-L193)<br>\n[aave/RewardsController.sol#L39-L42](https://github.com/aave/aave-v3-periphery/blob/master/contracts/rewards/RewardsController.sol#L39-L42)<br>\n[aave/RewardsController.sol#L133-L143](https://github.com/aave/aave-v3-periphery/blob/master/contracts/rewards/RewardsController.sol#L133-L143)<br>\n[AaveV3YieldSource.sol#L275-L286](https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L275-L286)<br>\n\nThe `AaveV3YieldSource` contract allows the manager or owner of the contract to claim rewards from  Aave's rewards controller. However, there is an external dependency on this periphery Aave contract such that the emission manager of the `RewardsController` contract may allows other users to be authorized claimers.\n\nAuthorized claimers can claim rewards on behalf of the `AaveV3YieldSource` contract, effectively bypassing any restrictions put in place by this proprietary contract and its `claimRewards()` function. A malicious emissions manager can effectively siphon yield away from the `AaveV3YieldSource` contract and redirect it to them-self.\n\n### Recommended Mitigation Steps\n\nEnsure this is understood and enforce that the `RewardsController` contract is owner by PoolTogether's multisig.\n\n**[PierrickGT (PoolTogether) acknowledged and commented](https://github.com/code-423n4/2022-04-pooltogether-findings/issues/70#issuecomment-1116758270):**\n > Exactly, we will need to whitelist an address by calling the `setClaimer` function: [aave/RewardsController.sol#L190](https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/rewards/RewardsController.sol#L190)<br>\n> We will probably setup a contract that can claim for various yield sources.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-04-pooltogether",
  "Code": [
    {
      "filename": "contracts/rewards/RewardsController.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {SafeCast} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {IScaledBalanceToken} from '@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol';\nimport {RewardsDistributor} from './RewardsDistributor.sol';\nimport {IRewardsController} from './interfaces/IRewardsController.sol';\nimport {ITransferStrategyBase} from './interfaces/ITransferStrategyBase.sol';\nimport {RewardsDataTypes} from './libraries/RewardsDataTypes.sol';\nimport {IEACAggregatorProxy} from '../misc/interfaces/IEACAggregatorProxy.sol';\n\n/**\n * @title RewardsController\n * @notice Abstract contract template to build Distributors contracts for ERC20 rewards to protocol participants\n * @author Aave\n **/\ncontract RewardsController is RewardsDistributor, VersionedInitializable, IRewardsController {\n  using SafeCast for uint256;\n\n  uint256 public constant REVISION = 1;\n\n  // This mapping allows whitelisted addresses to claim on behalf of others\n  // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\n  mapping(address => address) internal _authorizedClaimers;\n\n  // reward => transfer strategy implementation contract\n  // The TransferStrategy contract abstracts the logic regarding\n  // the source of the reward and how to transfer it to the user.\n  mapping(address => ITransferStrategyBase) internal _transferStrategy;\n\n  // This mapping contains the price oracle per reward.\n  // A price oracle is enforced for integrators to be able to show incentives at\n  // the current Aave UI without the need to setup an external price registry\n  // At the moment of reward configuration, the Incentives Controller performs\n  // a check to see if the provided reward oracle contains `latestAnswer`.\n  mapping(address => IEACAggregatorProxy) internal _rewardOracle;\n\n  modifier onlyAuthorizedClaimers(address claimer, address user) {\n    require(_authorizedClaimers[user] == claimer, 'CLAIMER_UNAUTHORIZED');\n    _;\n  }\n\n  constructor(address emissionManager) RewardsDistributor(emissionManager) {}\n\n  /**\n   * @dev Initialize for RewardsController\n   * @dev It expects an address as argument since its initialized via PoolAddressesProvider._updateImpl()\n   **/\n  function initialize(address) external initializer {}\n\n  /// @inheritdoc IRewardsController\n  function getClaimer(address user) external view override returns (address) {\n    return _authorizedClaimers[user];\n  }\n\n  /**\n   * @dev Returns the revision of the implementation contract\n   * @return uint256, current revision version\n   */\n  function getRevision() internal pure override returns (uint256) {\n    return REVISION;\n  }\n\n  /// @inheritdoc IRewardsController\n  function getRewardOracle(address reward) external view override returns (address) {\n    return address(_rewardOracle[reward]);\n  }\n\n  /// @inheritdoc IRewardsController\n  function getTransferStrategy(address reward) external view override returns (address) {\n    return address(_transferStrategy[reward]);\n  }\n\n  /// @inheritdoc IRewardsController\n  function configureAssets(\n    RewardsDataTypes.RewardsConfigInput[] memory config\n  ) external override onlyEmissionManager {\n    for (uint256 i = 0; i < config.length; i++) {\n      // Get the current Scaled Total Supply of AToken or Debt token\n      config[i].totalSupply = IScaledBalanceToken(config[i].asset).scaledTotalSupply();\n\n      // Install TransferStrategy logic at IncentivesController\n      _installTransferStrategy(config[i].reward, config[i].transferStrategy);\n\n      // Set reward oracle, enforces input oracle to have latestPrice function\n      _setRewardOracle(config[i].reward, config[i].rewardOracle);\n    }\n    _configureAssets(config);\n  }\n\n  /// @inheritdoc IRewardsController\n  function setTransferStrategy(\n    address reward,\n    ITransferStrategyBase transferStrategy\n  ) external onlyEmissionManager {\n    _installTransferStrategy(reward, transferStrategy);\n  }\n\n  /// @inheritdoc IRewardsController\n  function setRewardOracle(\n    address reward,\n    IEACAggregatorProxy rewardOracle\n  ) external onlyEmissionManager {\n    _setRewardOracle(reward, rewardOracle);\n  }\n\n  /// @inheritdoc IRewardsController\n  function handleAction(address user, uint256 totalSupply, uint256 userBalance) external override {\n    _updateData(msg.sender, user, userBalance, totalSupply);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to,\n    address reward\n  ) external override returns (uint256) {\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, msg.sender, to, reward);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to,\n    address reward\n  ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\n    require(user != address(0), 'INVALID_USER_ADDRESS');\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, user, to, reward);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimRewardsToSelf(\n    address[] calldata assets,\n    uint256 amount,\n    address reward\n  ) external override returns (uint256) {\n    return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender, reward);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimAllRewards(\n    address[] calldata assets,\n    address to\n  ) external override returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimAllRewards(assets, msg.sender, msg.sender, to);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimAllRewardsOnBehalf(\n    address[] calldata assets,\n    address user,\n    address to\n  )\n    external\n    override\n    onlyAuthorizedClaimers(msg.sender, user)\n    returns (address[] memory rewardsList, uint256[] memory claimedAmounts)\n  {\n    require(user != address(0), 'INVALID_USER_ADDRESS');\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimAllRewards(assets, msg.sender, user, to);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimAllRewardsToSelf(\n    address[] calldata assets\n  ) external override returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n    return _claimAllRewards(assets, msg.sender, msg.sender, msg.sender);\n  }\n\n  /// @inheritdoc IRewardsController\n  function setClaimer(address user, address caller) external override onlyEmissionManager {\n    _authorizedClaimers[user] = caller;\n    emit ClaimerSet(user, caller);\n  }\n\n  /**\n   * @dev Get user balances and total supply of all the assets specified by the assets parameter\n   * @param assets List of assets to retrieve user balance and total supply\n   * @param user Address of the user\n   * @return userAssetBalances contains a list of structs with user balance and total supply of the given assets\n   */\n  function _getUserAssetBalances(\n    address[] calldata assets,\n    address user\n  ) internal view override returns (RewardsDataTypes.UserAssetBalance[] memory userAssetBalances) {\n    userAssetBalances = new RewardsDataTypes.UserAssetBalance[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      userAssetBalances[i].asset = assets[i];\n      (userAssetBalances[i].userBalance, userAssetBalances[i].totalSupply) = IScaledBalanceToken(\n        assets[i]\n      ).getScaledUserBalanceAndSupply(user);\n    }\n    return userAssetBalances;\n  }\n\n  /**\n   * @dev Claims one type of reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards.\n   * @param assets List of assets to check eligible distributions before claiming rewards\n   * @param amount Amount of rewards to claim\n   * @param claimer Address of the claimer who claims rewards on behalf of user\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @param reward Address of the reward token\n   * @return Rewards claimed\n   **/\n  function _claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address claimer,\n    address user,\n    address to,\n    address reward\n  ) internal returns (uint256) {\n    if (amount == 0) {\n      return 0;\n    }\n    uint256 totalRewards;\n\n    _updateDataMultiple(user, _getUserAssetBalances(assets, user));\n    for (uint256 i = 0; i < assets.length; i++) {\n      address asset = assets[i];\n      totalRewards += _assets[asset].rewards[reward].usersData[user].accrued;\n\n      if (totalRewards <= amount) {\n        _assets[asset].rewards[reward].usersData[user].accrued = 0;\n      } else {\n        uint256 difference = totalRewards - amount;\n        totalRewards -= difference;\n        _assets[asset].rewards[reward].usersData[user].accrued = difference.toUint128();\n        break;\n      }\n    }\n\n    if (totalRewards == 0) {\n      return 0;\n    }\n\n    _transferRewards(to, reward, totalRewards);\n    emit RewardsClaimed(user, reward, to, claimer, totalRewards);\n\n    return totalRewards;\n  }\n\n  /**\n   * @dev Claims one type of reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards.\n   * @param assets List of assets to check eligible distributions before claiming rewards\n   * @param claimer Address of the claimer on behalf of user\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return\n   *   rewardsList List of reward addresses\n   *   claimedAmount List of claimed amounts, follows \"rewardsList\" items order\n   **/\n  function _claimAllRewards(\n    address[] calldata assets,\n    address claimer,\n    address user,\n    address to\n  ) internal returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n    uint256 rewardsListLength = _rewardsList.length;\n    rewardsList = new address[](rewardsListLength);\n    claimedAmounts = new uint256[](rewardsListLength);\n\n    _updateDataMultiple(user, _getUserAssetBalances(assets, user));\n\n    for (uint256 i = 0; i < assets.length; i++) {\n      address asset = assets[i];\n      for (uint256 j = 0; j < rewardsListLength; j++) {\n        if (rewardsList[j] == address(0)) {\n          rewardsList[j] = _rewardsList[j];\n        }\n        uint256 rewardAmount = _assets[asset].rewards[rewardsList[j]].usersData[user].accrued;\n        if (rewardAmount != 0) {\n          claimedAmounts[j] += rewardAmount;\n          _assets[asset].rewards[rewardsList[j]].usersData[user].accrued = 0;\n        }\n      }\n    }\n    for (uint256 i = 0; i < rewardsListLength; i++) {\n      _transferRewards(to, rewardsList[i], claimedAmounts[i]);\n      emit RewardsClaimed(user, rewardsList[i], to, claimer, claimedAmounts[i]);\n    }\n    return (rewardsList, claimedAmounts);\n  }\n\n  /**\n   * @dev Function to transfer rewards to the desired account using delegatecall and\n   * @param to Account address to send the rewards\n   * @param reward Address of the reward token\n   * @param amount Amount of rewards to transfer\n   */\n  function _transferRewards(address to, address reward, uint256 amount) internal {\n    ITransferStrategyBase transferStrategy = _transferStrategy[reward];\n\n    bool success = transferStrategy.performTransfer(to, reward, amount);\n\n    require(success == true, 'TRANSFER_ERROR');\n  }\n\n  /**\n   * @dev Returns true if `account` is a contract.\n   * @param account The address of the account\n   * @return bool, true if contract, false otherwise\n   */\n  function _isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n\n    uint256 size;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  /**\n   * @dev Internal function to call the optional install hook at the TransferStrategy\n   * @param reward The address of the reward token\n   * @param transferStrategy The address of the reward TransferStrategy\n   */\n  function _installTransferStrategy(\n    address reward,\n    ITransferStrategyBase transferStrategy\n  ) internal {\n    require(address(transferStrategy) != address(0), 'STRATEGY_CAN_NOT_BE_ZERO');\n    require(_isContract(address(transferStrategy)) == true, 'STRATEGY_MUST_BE_CONTRACT');\n\n    _transferStrategy[reward] = transferStrategy;\n\n    emit TransferStrategyInstalled(reward, address(transferStrategy));\n  }\n\n  /**\n   * @dev Update the Price Oracle of a reward token. The Price Oracle must follow Chainlink IEACAggregatorProxy interface.\n   * @notice The Price Oracle of a reward is used for displaying correct data about the incentives at the UI frontend.\n   * @param reward The address of the reward token\n   * @param rewardOracle The address of the price oracle\n   */\n\n  function _setRewardOracle(address reward, IEACAggregatorProxy rewardOracle) internal {\n    require(rewardOracle.latestAnswer() > 0, 'ORACLE_MUST_RETURN_PRICE');\n    _rewardOracle[reward] = rewardOracle;\n    emit RewardOracleUpdated(reward, address(rewardOracle));\n  }\n}"
    },
    {
      "filename": "contracts/rewards/RewardsController.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {SafeCast} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {IScaledBalanceToken} from '@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol';\nimport {RewardsDistributor} from './RewardsDistributor.sol';\nimport {IRewardsController} from './interfaces/IRewardsController.sol';\nimport {ITransferStrategyBase} from './interfaces/ITransferStrategyBase.sol';\nimport {RewardsDataTypes} from './libraries/RewardsDataTypes.sol';\nimport {IEACAggregatorProxy} from '../misc/interfaces/IEACAggregatorProxy.sol';\n\n/**\n * @title RewardsController\n * @notice Abstract contract template to build Distributors contracts for ERC20 rewards to protocol participants\n * @author Aave\n **/\ncontract RewardsController is RewardsDistributor, VersionedInitializable, IRewardsController {\n  using SafeCast for uint256;\n\n  uint256 public constant REVISION = 1;\n\n  // This mapping allows whitelisted addresses to claim on behalf of others\n  // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\n  mapping(address => address) internal _authorizedClaimers;\n\n  // reward => transfer strategy implementation contract\n  // The TransferStrategy contract abstracts the logic regarding\n  // the source of the reward and how to transfer it to the user.\n  mapping(address => ITransferStrategyBase) internal _transferStrategy;\n\n  // This mapping contains the price oracle per reward.\n  // A price oracle is enforced for integrators to be able to show incentives at\n  // the current Aave UI without the need to setup an external price registry\n  // At the moment of reward configuration, the Incentives Controller performs\n  // a check to see if the provided reward oracle contains `latestAnswer`.\n  mapping(address => IEACAggregatorProxy) internal _rewardOracle;\n\n  modifier onlyAuthorizedClaimers(address claimer, address user) {\n    require(_authorizedClaimers[user] == claimer, 'CLAIMER_UNAUTHORIZED');\n    _;\n  }\n\n  constructor(address emissionManager) RewardsDistributor(emissionManager) {}\n\n  /**\n   * @dev Initialize for RewardsController\n   * @dev It expects an address as argument since its initialized via PoolAddressesProvider._updateImpl()\n   **/\n  function initialize(address) external initializer {}\n\n  /// @inheritdoc IRewardsController\n  function getClaimer(address user) external view override returns (address) {\n    return _authorizedClaimers[user];\n  }\n\n  /**\n   * @dev Returns the revision of the implementation contract\n   * @return uint256, current revision version\n   */\n  function getRevision() internal pure override returns (uint256) {\n    return REVISION;\n  }\n\n  /// @inheritdoc IRewardsController\n  function getRewardOracle(address reward) external view override returns (address) {\n    return address(_rewardOracle[reward]);\n  }\n\n  /// @inheritdoc IRewardsController\n  function getTransferStrategy(address reward) external view override returns (address) {\n    return address(_transferStrategy[reward]);\n  }\n\n  /// @inheritdoc IRewardsController\n  function configureAssets(\n    RewardsDataTypes.RewardsConfigInput[] memory config\n  ) external override onlyEmissionManager {\n    for (uint256 i = 0; i < config.length; i++) {\n      // Get the current Scaled Total Supply of AToken or Debt token\n      config[i].totalSupply = IScaledBalanceToken(config[i].asset).scaledTotalSupply();\n\n      // Install TransferStrategy logic at IncentivesController\n      _installTransferStrategy(config[i].reward, config[i].transferStrategy);\n\n      // Set reward oracle, enforces input oracle to have latestPrice function\n      _setRewardOracle(config[i].reward, config[i].rewardOracle);\n    }\n    _configureAssets(config);\n  }\n\n  /// @inheritdoc IRewardsController\n  function setTransferStrategy(\n    address reward,\n    ITransferStrategyBase transferStrategy\n  ) external onlyEmissionManager {\n    _installTransferStrategy(reward, transferStrategy);\n  }\n\n  /// @inheritdoc IRewardsController\n  function setRewardOracle(\n    address reward,\n    IEACAggregatorProxy rewardOracle\n  ) external onlyEmissionManager {\n    _setRewardOracle(reward, rewardOracle);\n  }\n\n  /// @inheritdoc IRewardsController\n  function handleAction(address user, uint256 totalSupply, uint256 userBalance) external override {\n    _updateData(msg.sender, user, userBalance, totalSupply);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to,\n    address reward\n  ) external override returns (uint256) {\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, msg.sender, to, reward);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to,\n    address reward\n  ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\n    require(user != address(0), 'INVALID_USER_ADDRESS');\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, user, to, reward);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimRewardsToSelf(\n    address[] calldata assets,\n    uint256 amount,\n    address reward\n  ) external override returns (uint256) {\n    return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender, reward);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimAllRewards(\n    address[] calldata assets,\n    address to\n  ) external override returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimAllRewards(assets, msg.sender, msg.sender, to);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimAllRewardsOnBehalf(\n    address[] calldata assets,\n    address user,\n    address to\n  )\n    external\n    override\n    onlyAuthorizedClaimers(msg.sender, user)\n    returns (address[] memory rewardsList, uint256[] memory claimedAmounts)\n  {\n    require(user != address(0), 'INVALID_USER_ADDRESS');\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimAllRewards(assets, msg.sender, user, to);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimAllRewardsToSelf(\n    address[] calldata assets\n  ) external override returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n    return _claimAllRewards(assets, msg.sender, msg.sender, msg.sender);\n  }\n\n  /// @inheritdoc IRewardsController\n  function setClaimer(address user, address caller) external override onlyEmissionManager {\n    _authorizedClaimers[user] = caller;\n    emit ClaimerSet(user, caller);\n  }\n\n  /**\n   * @dev Get user balances and total supply of all the assets specified by the assets parameter\n   * @param assets List of assets to retrieve user balance and total supply\n   * @param user Address of the user\n   * @return userAssetBalances contains a list of structs with user balance and total supply of the given assets\n   */\n  function _getUserAssetBalances(\n    address[] calldata assets,\n    address user\n  ) internal view override returns (RewardsDataTypes.UserAssetBalance[] memory userAssetBalances) {\n    userAssetBalances = new RewardsDataTypes.UserAssetBalance[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      userAssetBalances[i].asset = assets[i];\n      (userAssetBalances[i].userBalance, userAssetBalances[i].totalSupply) = IScaledBalanceToken(\n        assets[i]\n      ).getScaledUserBalanceAndSupply(user);\n    }\n    return userAssetBalances;\n  }\n\n  /**\n   * @dev Claims one type of reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards.\n   * @param assets List of assets to check eligible distributions before claiming rewards\n   * @param amount Amount of rewards to claim\n   * @param claimer Address of the claimer who claims rewards on behalf of user\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @param reward Address of the reward token\n   * @return Rewards claimed\n   **/\n  function _claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address claimer,\n    address user,\n    address to,\n    address reward\n  ) internal returns (uint256) {\n    if (amount == 0) {\n      return 0;\n    }\n    uint256 totalRewards;\n\n    _updateDataMultiple(user, _getUserAssetBalances(assets, user));\n    for (uint256 i = 0; i < assets.length; i++) {\n      address asset = assets[i];\n      totalRewards += _assets[asset].rewards[reward].usersData[user].accrued;\n\n      if (totalRewards <= amount) {\n        _assets[asset].rewards[reward].usersData[user].accrued = 0;\n      } else {\n        uint256 difference = totalRewards - amount;\n        totalRewards -= difference;\n        _assets[asset].rewards[reward].usersData[user].accrued = difference.toUint128();\n        break;\n      }\n    }\n\n    if (totalRewards == 0) {\n      return 0;\n    }\n\n    _transferRewards(to, reward, totalRewards);\n    emit RewardsClaimed(user, reward, to, claimer, totalRewards);\n\n    return totalRewards;\n  }\n\n  /**\n   * @dev Claims one type of reward for a user on behalf, on all the assets of the pool, accumulating the pending rewards.\n   * @param assets List of assets to check eligible distributions before claiming rewards\n   * @param claimer Address of the claimer on behalf of user\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return\n   *   rewardsList List of reward addresses\n   *   claimedAmount List of claimed amounts, follows \"rewardsList\" items order\n   **/\n  function _claimAllRewards(\n    address[] calldata assets,\n    address claimer,\n    address user,\n    address to\n  ) internal returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n    uint256 rewardsListLength = _rewardsList.length;\n    rewardsList = new address[](rewardsListLength);\n    claimedAmounts = new uint256[](rewardsListLength);\n\n    _updateDataMultiple(user, _getUserAssetBalances(assets, user));\n\n    for (uint256 i = 0; i < assets.length; i++) {\n      address asset = assets[i];\n      for (uint256 j = 0; j < rewardsListLength; j++) {\n        if (rewardsList[j] == address(0)) {\n          rewardsList[j] = _rewardsList[j];\n        }\n        uint256 rewardAmount = _assets[asset].rewards[rewardsList[j]].usersData[user].accrued;\n        if (rewardAmount != 0) {\n          claimedAmounts[j] += rewardAmount;\n          _assets[asset].rewards[rewardsList[j]].usersData[user].accrued = 0;\n        }\n      }\n    }\n    for (uint256 i = 0; i < rewardsListLength; i++) {\n      _transferRewards(to, rewardsList[i], claimedAmounts[i]);\n      emit RewardsClaimed(user, rewardsList[i], to, claimer, claimedAmounts[i]);\n    }\n    return (rewardsList, claimedAmounts);\n  }\n\n  /**\n   * @dev Function to transfer rewards to the desired account using delegatecall and\n   * @param to Account address to send the rewards\n   * @param reward Address of the reward token\n   * @param amount Amount of rewards to transfer\n   */\n  function _transferRewards(address to, address reward, uint256 amount) internal {\n    ITransferStrategyBase transferStrategy = _transferStrategy[reward];\n\n    bool success = transferStrategy.performTransfer(to, reward, amount);\n\n    require(success == true, 'TRANSFER_ERROR');\n  }\n\n  /**\n   * @dev Returns true if `account` is a contract.\n   * @param account The address of the account\n   * @return bool, true if contract, false otherwise\n   */\n  function _isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n\n    uint256 size;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  /**\n   * @dev Internal function to call the optional install hook at the TransferStrategy\n   * @param reward The address of the reward token\n   * @param transferStrategy The address of the reward TransferStrategy\n   */\n  function _installTransferStrategy(\n    address reward,\n    ITransferStrategyBase transferStrategy\n  ) internal {\n    require(address(transferStrategy) != address(0), 'STRATEGY_CAN_NOT_BE_ZERO');\n    require(_isContract(address(transferStrategy)) == true, 'STRATEGY_MUST_BE_CONTRACT');\n\n    _transferStrategy[reward] = transferStrategy;\n\n    emit TransferStrategyInstalled(reward, address(transferStrategy));\n  }\n\n  /**\n   * @dev Update the Price Oracle of a reward token. The Price Oracle must follow Chainlink IEACAggregatorProxy interface.\n   * @notice The Price Oracle of a reward is used for displaying correct data about the incentives at the UI frontend.\n   * @param reward The address of the reward token\n   * @param rewardOracle The address of the price oracle\n   */\n\n  function _setRewardOracle(address reward, IEACAggregatorProxy rewardOracle) internal {\n    require(rewardOracle.latestAnswer() > 0, 'ORACLE_MUST_RETURN_PRICE');\n    _rewardOracle[reward] = rewardOracle;\n    emit RewardOracleUpdated(reward, address(rewardOracle));\n  }\n}"
    },
    {
      "filename": "contracts/rewards/RewardsController.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {SafeCast} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {IScaledBalanceToken} from '@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol';\nimport {RewardsDistributor} from './RewardsDistributor.sol';\nimport {IRewardsController} from './interfaces/IRewardsController.sol';\nimport {ITransferStrategyBase} from './interfaces/ITransferStrategyBase.sol';\nimport {RewardsDataTypes} from './libraries/RewardsDataTypes.sol';\nimport {IEACAggregatorProxy} from '../misc/interfaces/IEACAggregatorProxy.sol';\n\n/**\n * @title RewardsController\n * @notice Abstract contract template to build Distributors contracts for ERC20 rewards to protocol participants\n * @author Aave\n **/\ncontract RewardsController is RewardsDistributor, VersionedInitializable, IRewardsController {\n  using SafeCast for uint256;\n\n  uint256 public constant REVISION = 1;\n\n  // This mapping allows whitelisted addresses to claim on behalf of others\n  // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\n  mapping(address => address) internal _authorizedClaimers;\n\n  // reward => transfer strategy implementation contract\n  // The TransferStrategy contract abstracts the logic regarding\n  // the source of the reward and how to transfer it to the user.\n  mapping(address => ITransferStrategyBase) internal _transferStrategy;\n\n  // This mapping contains the price oracle per reward.\n  // A price oracle is enforced for integrators to be able to show incentives at\n  // the current Aave UI without the need to setup an external price registry\n  // At the moment of reward configuration, the Incentives Controller performs\n  // a check to see if the provided reward oracle contains `latestAnswer`.\n  mapping(address => IEACAggregatorProxy) internal _rewardOracle;\n\n  modifier onlyAuthorizedClaimers(address claimer, address user) {\n    require(_authorizedClaimers[user] == claimer, 'CLAIMER_UNAUTHORIZED');\n    _;\n  }\n\n  constructor(address emissionManager) RewardsDistributor(emissionManager) {}\n\n  /**\n   * @dev Initialize for RewardsController\n   * @dev It expects an address as argument since its initialized via PoolAddressesProvider._updateImpl()\n   **/\n  function initialize(address) external initializer {}\n\n  /// @inheritdoc IRewardsController\n  function getClaimer(address user) external view override returns (address) {\n    return _authorizedClaimers[user];\n  }\n\n  /**\n   * @dev Returns the revision of the implementation contract\n   * @return uint256, current revision version\n   */\n  function getRevision() internal pure override returns (uint256) {\n    return REVISION;\n  }\n\n  /// @inheritdoc IRewardsController\n  function getRewardOracle(address reward) external view override returns (address) {\n    return address(_rewardOracle[reward]);\n  }\n\n  /// @inheritdoc IRewardsController\n  function getTransferStrategy(address reward) external view override returns (address) {\n    return address(_transferStrategy[reward]);\n  }\n\n  /// @inheritdoc IRewardsController\n  function configureAssets(\n    RewardsDataTypes.RewardsConfigInput[] memory config\n  ) external override onlyEmissionManager {\n    for (uint256 i = 0; i < config.length; i++) {\n      // Get the current Scaled Total Supply of AToken or Debt token\n      config[i].totalSupply = IScaledBalanceToken(config[i].asset).scaledTotalSupply();\n\n      // Install TransferStrategy logic at IncentivesController\n      _installTransferStrategy(config[i].reward, config[i].transferStrategy);\n\n      // Set reward oracle, enforces input oracle to have latestPrice function\n      _setRewardOracle(config[i].reward, config[i].rewardOracle);\n    }\n    _configureAssets(config);\n  }\n\n  /// @inheritdoc IRewardsController\n  function setTransferStrategy(\n    address reward,\n    ITransferStrategyBase transferStrategy\n  ) external onlyEmissionManager {\n    _installTransferStrategy(reward, transferStrategy);\n  }\n\n  /// @inheritdoc IRewardsController\n  function setRewardOracle(\n    address reward,\n    IEACAggregatorProxy rewardOracle\n  ) external onlyEmissionManager {\n    _setRewardOracle(reward, rewardOracle);\n  }\n\n  /// @inheritdoc IRewardsController\n  function handleAction(address user, uint256 totalSupply, uint256 userBalance) external override {\n    _updateData(msg.sender, user, userBalance, totalSupply);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to,\n    address reward\n  ) external override returns (uint256) {\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, msg.sender, to, reward);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to,\n    address reward\n  ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\n    require(user != address(0), 'INVALID_USER_ADDRESS');\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, user, to, reward);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimRewardsToSelf(\n    address[] calldata assets,\n    uint256 amount,\n    address reward\n  ) external override returns (uint256) {\n    return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender, reward);\n  }\n\n  /// @inheritdoc IRewardsController\n  function claimAllRewards(\n    address[] calldata assets,\n    address to\n  ) external override returns (address[] memory rewardsList, uint256[] memory claimedAmounts) {\n    require(to !="
    }
  ]
}