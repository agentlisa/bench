{
  "Title": "[L04] No return values for some functions",
  "Content": "Saddle’s [`Swap` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol) interface is intended to closely match that of Curve’s [`SwapTemplateBase` contract](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy). However, a number of functions return a value in Curve’s implementation, while their equivalents in Saddle do not return a value. The following sets of functions return a value in Curve, but do not in Saddle:\n\n\n* The [`swap` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L302) in Saddle and the [`exchange` function](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L433) in Curve.\n* The [`addLiquidity` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L315) in Saddle and the [`add_liquidity` function](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L285) in Curve.\n* The [`removeLiquidity` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L342) in Saddle and the [`remove_liquidity` function](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L500) in Curve.\n* The [`removeLiquidityOneToken` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L355) in Saddle and the [`remove_liquidity_one_coin` function](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L695) in Curve.\n* The [`removeLiquidityImbalance` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L370) in Saddle and the [`remove_liquidity_imbalance` function](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L539) in Curve.\n\n\nSince these functions are supposed to mimic those of Curve, they should return values like the functions in Curve do. Importantly, this will provide those values for smart contracts that interact with the Saddle code to trade or provide liquidity, and will result in less confusion for users who are expecting a similar interface to that of Curve.\n\n\nConsider implementing return values for the functions highlighted above.\n\n\n***Update:** Fixed in [pull request 196](https://github.com/saddle-finance/saddle-contract/pull/196/files#).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Swap.sol",
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./OwnerPausable.sol\";\nimport \"./SwapUtils.sol\";\nimport \"./MathUtils.sol\";\nimport \"./Allowlist.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happen, a set fee incurs which effectively get\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract Swap is OwnerPausable, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n    using SwapUtils for SwapUtils.Swap;\n\n    SwapUtils.Swap public swapStorage;\n    IAllowlist public allowlist;\n    bool public isGuarded = true;\n    mapping(address => uint8) private tokenIndexes;\n\n    /*** EVENTS ***/\n\n    // events replicated fromm SwapUtils to make the ABI easier for dumb\n    // clients\n    event TokenSwap(address indexed buyer, uint256 tokensSold,\n        uint256 tokensBought, uint128 soldId, uint128 boughtId\n    );\n    event AddLiquidity(address indexed provider, uint256[] tokenAmounts,\n        uint256[] fees, uint256 invariant, uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(address indexed provider, uint256 lpTokenAmount,\n        uint256 lpTokenSupply, uint256 boughtId, uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(address indexed provider,\n        uint256[] tokenAmounts, uint256[] fees, uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n    event StopRampA(uint256 A, uint256 time);\n\n    /**\n     * @notice Deploys this Swap contract with given parameters as default\n     * values. This will also deploy a LPToken that represents users\n     * LP position. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint new tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param precisions the precision to use for each pooled token,\n     * eg 10 ** 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _A the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param _withdrawFee default withdrawFee to be initliazed with\n     * @param _allowlist address of allowlist contract for guarded launch\n     */\n    constructor(\n        IERC20[] memory _pooledTokens, uint256[] memory precisions,\n        string memory lpTokenName, string memory lpTokenSymbol, uint256 _A,\n        uint256 _fee, uint256 _adminFee, uint256 _withdrawFee, IAllowlist _allowlist\n    ) public OwnerPausable() ReentrancyGuard() {\n        require(\n            _pooledTokens.length > 1,\n            \"Pools must contain more than 1 token\"\n        );\n        require(\n            _pooledTokens.length <= 32,\n            \"Pools with over 32 tokens aren't supported\"\n        );\n        require(\n            _pooledTokens.length == precisions.length,\n            \"Each pooled token needs a specified precision\"\n        );\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                require(tokenIndexes[address(_pooledTokens[i])] == 0, \"Pools cannot have duplicate tokens\");\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                precisions[i] <= 10 ** uint256(SwapUtils.getPoolPrecisionDecimals()),\n                \"Token precision can't be higher than the pool precision\"\n            );\n            precisions[i] = (10 ** uint256(SwapUtils.getPoolPrecisionDecimals())).div(precisions[i]);\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        swapStorage = SwapUtils.Swap({\n            lpToken: new LPToken(lpTokenName, lpTokenSymbol, SwapUtils.getPoolPrecisionDecimals()),\n            pooledTokens: _pooledTokens,\n            tokenPrecisionMultipliers: precisions,\n            balances: new uint256[](_pooledTokens.length),\n            initialA: _A.mul(SwapUtils.getAPrecision()),\n            futureA: _A.mul(SwapUtils.getAPrecision()),\n            initialATime: 0,\n            futureATime: 0,\n            swapFee: _fee,\n            adminFee: _adminFee,\n            defaultWithdrawFee: _withdrawFee\n        });\n\n        allowlist = _allowlist;\n        require(allowlist.getPoolCap(address(0x0)) == uint256(0x54dd1e), \"Allowlist check failed\");\n        isGuarded = true;\n    }\n\n    /*** MODIFIERS ***/\n\n    /**\n     * @notice Modifier to check deadline against current timestamp\n     * @param deadline latest timestamp to accept this transaction\n     */\n    modifier deadlineCheck(uint256 deadline) {\n        require(block.timestamp <= deadline, \"Deadline not met\");\n        _;\n    }\n\n    /*** VIEW FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function getA() external view returns (uint256) {\n        return swapStorage.getA();\n    }\n\n    /**\n     * @notice Return A in its raw precision form\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise() external view returns (uint256) {\n        return swapStorage.getAPrecise();\n    }\n\n    /**\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n     * @param index the index of the token\n     * @return address of the token at given index\n     */\n    function getToken(uint8 index) public view returns (IERC20) {\n        require(index < swapStorage.pooledTokens.length, \"Out of range\");\n        return swapStorage.pooledTokens[index];\n    }\n\n    /**\n     * @notice Return the index of the given token address. Reverts if no matching\n     * token is found.\n     * @param tokenAddress address of the token\n     * @return the index of the given token address\n     */\n    function getTokenIndex(address tokenAddress) external view returns (uint8) {\n        uint8 index = tokenIndexes[tokenAddress];\n        require(address(getToken(index)) == tokenAddress, \"Token does not exist\");\n        return index;\n    }\n\n    /**\n     * @notice Return timestamp of last deposit of given address\n     * @return timestamp of the last deposit made by the given address\n     */\n    function getDepositTimestamp(address user) external view returns (uint256) {\n        return swapStorage.getDepositTimestamp(user);\n    }\n\n    /**\n     * @notice Return current balance of the pooled token at given index\n     * @param index the index of the token\n     * @return current balance of the pooled token at given index with token's native precision\n     */\n    function getTokenBalance(uint8 index) external view returns (uint256) {\n        require(index < swapStorage.pooledTokens.length, \"Index out of range\");\n        return swapStorage.balances[index];\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice() external view returns (uint256) {\n        return swapStorage.getVirtualPrice();\n    }\n\n    /**\n     * @notice calculate amount of tokens you receive on swap\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwap(uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx\n    ) external view returns(uint256) {\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n    external view returns(uint256) {\n        return swapStorage.calculateTokenAmount(amounts, deposit);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param amount the amount of LP tokens that would be burned on withdrawal\n     * @return array of balances of tokens that user will receive\n     */\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory) {\n        return swapStorage.calculateRemoveLiquidity(amount);\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenIndex index of which token will be withdrawn\n     * @return availableTokenAmount calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount) {\n        (availableTokenAmount, ) = swapStorage.calculateWithdrawOneToken(tokenAmount, tokenIndex);\n    }\n\n    /**\n     * @notice Calculate the fee that is applied when the given user withdraws. The withdraw fee\n     * decays linearly over period of 4 weeks. For example, depositing and withdrawing right away\n     * will charge you the full amount of withdraw fee. But withdrawing after 4 weeks will charge you\n     * no additional fees.\n     * @dev returned value should be divided by FEE_DENOMINATOR to convert to correct decimals\n     * @param user address you want to calculate withdraw fee of\n     * @return current withdraw fee of the user\n     */\n    function calculateCurrentWithdrawFee(address user) external view returns (uint256) {\n        return swapStorage.calculateCurrentWithdrawFee(user);\n    }\n\n    /**\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\n     * @param index Index of the pooled token\n     * @return admin's token balance in the token's precision\n     */\n    function getAdminBalance(uint256 index) external view returns (uint256) {\n        return swapStorage.getAdminBalance(index);\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice Swap two tokens using this pool\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx, uint256 minDy, uint256 deadline\n    ) external nonReentrant onlyUnpaused deadlineCheck(deadline) {\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n    }\n\n    /**\n     * @notice Add liquidity to the pool with given amounts\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function addLiquidity(uint256[] calldata amounts, uint256 minToMint, uint256 deadline)\n        external nonReentrant onlyUnpaused deadlineCheck(deadline) {\n        swapStorage.addLiquidity(amounts, minToMint);\n\n        if (isGuarded) {\n            // Check per user deposit limit\n            require(\n                allowlist.getAllowedAmount(address(this), msg.sender) >= swapStorage.lpToken.balanceOf(msg.sender),\n                \"Deposit limit reached\"\n            );\n            // Check pool's TVL cap limit via totalSupply of the pool token\n            require(\n                allowlist.getPoolCap(address(this)) >= swapStorage.lpToken.totalSupply(),\n                \"Pool TVL cap reached\"\n            );\n        }\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     *        acceptable for this burn. Useful as a front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function removeLiquidity(uint256 amount, uint256[] calldata minAmounts, uint256 deadline)\n        external nonReentrant deadlineCheck(deadline) {\n        return swapStorage.removeLiquidity(amount, minAmounts);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param tokenAmount the amount of the token you want to receive\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function removeLiquidityOneToken(\n        uint256 tokenAmount, uint8 tokenIndex, uint256 minAmount, uint256 deadline\n    ) external nonReentrant onlyUnpaused deadlineCheck(deadline) {\n        return swapStorage.removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts, uint256 maxBurnAmount, uint256 deadline\n    ) external nonReentrant onlyUnpaused deadlineCheck(deadline) {\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\n    }\n\n    /*** ADMIN FUNCTIONS ***/\n\n    /**\n     * @notice Updates the user withdraw fee. This function can only be called by\n     * the pool token. Should be used to update the withdraw fee on transfer of pool tokens.\n     * Transferring your pool token will reset the 4 weeks period. If the recipient is already\n     * holding some pool tokens, the withdraw fee will be discounted in respective amounts.\n     * @param recipient address of the recipient of pool token\n     * @param transferAmount amount of pool token to transfer\n     */\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount) external {\n        require(msg.sender == address(swapStorage.lpToken), \"Only token transfers can update withdraw fee\");\n        swapStorage.updateUserWithdrawFee(recipient, transferAmount);\n    }\n\n    /**\n     * @notice Withdraw all admin fees to the contract owner\n     */\n    function withdrawAdminFees() external onlyOwner {\n        swapStorage.withdrawAdminFees(owner());\n    }\n\n    /**\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(uint256 newAdminFee) external onlyOwner {\n        swapStorage.setAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice Update the swap fee to be applied on swaps\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(uint256 newSwapFee) external onlyOwner {\n        swapStorage.setSwapFee(newSwapFee);\n    }\n\n    /**\n     * @notice Update the withdraw fee. This fee decays linearly over 4 weeks since\n     * user's last deposit.\n     * @param newWithdrawFee new withdraw fee to be applied on future deposits\n     */\n    function setDefaultWithdrawFee(uint256 newWithdrawFee) external onlyOwner {\n        swapStorage.setDefaultWithdrawFee(newWithdrawFee);\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param futureA the new A to ramp towards\n     * @param futureTime timestamp when the new A should be reached\n     */\n    function rampA(uint256 futureA, uint256 futureTime) external onlyOwner {\n        swapStorage.rampA(futureA, futureTime);\n    }\n\n    /**\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n     */\n    function stopRampA() external onlyOwner {\n        swapStorage.stopRampA();\n    }\n\n    /**\n     * @notice Update the guarded status of the pool deposits\n     * @param isGuarded_ boolean value indicating whether the deposits should be guarded\n     */\n    function setIsGuarded(bool isGuarded_) external onlyOwner {\n        isGuarded = isGuarded_;\n    }\n}"
    },
    {
      "filename": "contracts/Swap.sol",
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./OwnerPausable.sol\";\nimport \"./SwapUtils.sol\";\nimport \"./MathUtils.sol\";\nimport \"./Allowlist.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happen, a set fee incurs which effectively get\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract Swap is OwnerPausable, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n    using SwapUtils for SwapUtils.Swap;\n\n    SwapUtils.Swap public swapStorage;\n    IAllowlist public allowlist;\n    bool public isGuarded = true;\n    mapping(address => uint8) private tokenIndexes;\n\n    /*** EVENTS ***/\n\n    // events replicated fromm SwapUtils to make the ABI easier for dumb\n    // clients\n    event TokenSwap(address indexed buyer, uint256 tokensSold,\n        uint256 tokensBought, uint128 soldId, uint128 boughtId\n    );\n    event AddLiquidity(address indexed provider, uint256[] tokenAmounts,\n        uint256[] fees, uint256 invariant, uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(address indexed provider, uint256 lpTokenAmount,\n        uint256 lpTokenSupply, uint256 boughtId, uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(address indexed provider,\n        uint256[] tokenAmounts, uint256[] fees, uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n    event StopRampA(uint256 A, uint256 time);\n\n    /**\n     * @notice Deploys this Swap contract with given parameters as default\n     * values. This will also deploy a LPToken that represents users\n     * LP position. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint new tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param precisions the precision to use for each pooled token,\n     * eg 10 ** 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _A the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param _withdrawFee default withdrawFee to be initliazed with\n     * @param _allowlist address of allowlist contract for guarded launch\n     */\n    constructor(\n        IERC20[] memory _pooledTokens, uint256[] memory precisions,\n        string memory lpTokenName, string memory lpTokenSymbol, uint256 _A,\n        uint256 _fee, uint256 _adminFee, uint256 _withdrawFee, IAllowlist _allowlist\n    ) public OwnerPausable() ReentrancyGuard() {\n        require(\n            _pooledTokens.length > 1,\n            \"Pools must contain more than 1 token\"\n        );\n        require(\n            _pooledTokens.length <= 32,\n            \"Pools with over 32 tokens aren't supported\"\n        );\n        require(\n            _pooledTokens.length == precisions.length,\n            \"Each pooled token needs a specified precision\"\n        );\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                require(tokenIndexes[address(_pooledTokens[i])] == 0, \"Pools cannot have duplicate tokens\");\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                precisions[i] <= 10 ** uint256(SwapUtils.getPoolPrecisionDecimals()),\n                \"Token precision can't be higher than the pool precision\"\n            );\n            precisions[i] = (10 ** uint256(SwapUtils.getPoolPrecisionDecimals())).div(precisions[i]);\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        swapStorage = SwapUtils.Swap({\n            lpToken: new LPToken(lpTokenName, lpTokenSymbol, SwapUtils.getPoolPrecisionDecimals()),\n            pooledTokens: _pooledTokens,\n            tokenPrecisionMultipliers: precisions,\n            balances: new uint256[](_pooledTokens.length),\n            initialA: _A.mul(SwapUtils.getAPrecision()),\n            futureA: _A.mul(SwapUtils.getAPrecision()),\n            initialATime: 0,\n            futureATime: 0,\n            swapFee: _fee,\n            adminFee: _adminFee,\n            defaultWithdrawFee: _withdrawFee\n        });\n\n        allowlist = _allowlist;\n        require(allowlist.getPoolCap(address(0x0)) == uint256(0x54dd1e), \"Allowlist check failed\");\n        isGuarded = true;\n    }\n\n    /*** MODIFIERS ***/\n\n    /**\n     * @notice Modifier to check deadline against current timestamp\n     * @param deadline latest timestamp to accept this transaction\n     */\n    modifier deadlineCheck(uint256 deadline) {\n        require(block.timestamp <= deadline, \"Deadline not met\");\n        _;\n    }\n\n    /*** VIEW FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function getA() external view returns (uint256) {\n        return swapStorage.getA();\n    }\n\n    /**\n     * @notice Return A in its raw precision form\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise() external view returns (uint256) {\n        return swapStorage.getAPrecise();\n    }\n\n    /**\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n     * @param index the index of the token\n     * @return address of the token at given index\n     */\n    function getToken(uint8 index) public view returns (IERC20) {\n        require(index < swapStorage.pooledTokens.length, \"Out of range\");\n        return swapStorage.pooledTokens[index];\n    }\n\n    /**\n     * @notice Return the index of the given token address. Reverts if no matching\n     * token is found.\n     * @param tokenAddress address of the token\n     * @return the index of the given token address\n     */\n    function getTokenIndex(address tokenAddress) external view returns (uint8) {\n        uint8 index = tokenIndexes[tokenAddress];\n        require(address(getToken(index)) == tokenAddress, \"Token does not exist\");\n        return index;\n    }\n\n    /**\n     * @notice Return timestamp of last deposit of given address\n     * @return timestamp of the last deposit made by the given address\n     */\n    function getDepositTimestamp(address user) external view returns (uint256) {\n        return swapStorage.getDepositTimestamp(user);\n    }\n\n    /**\n     * @notice Return current balance of the pooled token at given index\n     * @param index the index of the token\n     * @return current balance of the pooled token at given index with token's native precision\n     */\n    function getTokenBalance(uint8 index) external view returns (uint256) {\n        require(index < swapStorage.pooledTokens.length, \"Index out of range\");\n        return swapStorage.balances[index];\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice() external view returns (uint256) {\n        return swapStorage.getVirtualPrice();\n    }\n\n    /**\n     * @notice calculate amount of tokens you receive on swap\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwap(uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx\n    ) external view returns(uint256) {\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n    external view returns(uint256) {\n        return swapStorage.calculateTokenAmount(amounts, deposit);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param amount the amount of LP tokens that would be burned on withdrawal\n     * @return array of balances of tokens that user will receive\n     */\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory) {\n        return swapStorage.calculateRemoveLiquidity(amount);\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenIndex index of which token will be withdrawn\n     * @return availableTokenAmount calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount) {\n        (availableTokenAmount, ) = swapStorage.calculateWithdrawOneToken(tokenAmount, tokenIndex);\n    }\n\n    /**\n     * @notice Calculate the fee that is applied when the given user withdraws. The withdraw fee\n     * decays linearly over period of 4 weeks. For example, depositing and withdrawing right away\n     * will charge you the full amount of withdraw fee. But withdrawing after 4 weeks will charge you\n     * no additional fees.\n     * @dev returned value should be divided by FEE_DENOMINATOR to convert to correct decimals\n     * @param user address you want to calculate withdraw fee of\n     * @return current withdraw fee of the user\n     */\n    function calculateCurrentWithdrawFee(address user) external view returns (uint256) {\n        return swapStorage.calculateCurrentWithdrawFee(user);\n    }\n\n    /**\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\n     * @param index Index of the pooled token\n     * @return admin's token balance in the token's precision\n     */\n    function getAdminBalance(uint256 index) external view returns (uint256) {\n        return swapStorage.getAdminBalance(index);\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice Swap two tokens using this pool\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx, uint256 minDy, uint256 deadline\n    ) external nonReentrant onlyUnpaused deadlineCheck(deadline) {\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n    }\n\n    /**\n     * @notice Add liquidity to the pool with given amounts\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function addLiquidity(uint256[] calldata amounts, uint256 minToMint, uint256 deadline)\n        external nonReentrant onlyUnpaused deadlineCheck(deadline) {\n        swapStorage.addLiquidity(amounts, minToMint);\n\n        if (isGuarded) {\n            // Check per user deposit limit\n            require(\n                allowlist.getAllowedAmount(address(this), msg.sender) >= swapStorage.lpToken.balanceOf(msg.sender),\n                \"Deposit limit reached\"\n            );\n            // Check pool's TVL cap limit via totalSupply of the pool token\n            require(\n                allowlist.getPoolCap(address(this)) >= swapS"
    }
  ]
}