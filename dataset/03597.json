{
  "Title": "[L09] Inconsistently formatted, unhelpful, or missing revert messages",
  "Content": "Many of the error messages in `require` statements throughout the codebase were found to be too generic, not accurately notifying users of the actual failing condition causing the transaction to revert. Additionally, error messages throughout the codebase were found to be inconsistently formatted.\n\n\nFor instance, the `require` statements throughout [`GnosisAuction`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/GnosisAuction.sol) contain entire equations along with their error messages, but elsewhere the `require` error messages, like [these in `ShareMath`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/ShareMath.sol#L86-L90) and [this in `RibbonVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L551), are very short and non-descriptive.\n\n\nThe `require` statements on [line 129](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L129) and [line 149](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L149) of [`RibbonThetaVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol) both check that a premium discount is within the correct range, but provide different error messages.\n\n\nFinally, the `require` statement on [line 123](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/utils/StrikeSelection.sol#L123) of `StrikeSelection` does not provide any error message at all.\n\n\nError messages are intended to notify users about failing conditions, so they should provide enough information so that appropriate corrections can be made to interact with the system. Uninformative error messages greatly damage the overall user experience, thus lowering the systemâ€™s quality. Therefore, consider reviewing the entire codebase to make sure every `require` has an error message that is consistently formatted, informative, and user-friendly.\n\n\n**Update**: *Partially fixed in [commit `b52498add9d7f4c467ec5ca9d4288568010e26b2` of PR#96](https://github.com/ribbon-finance/ribbon-v2/pull/96/commits/b52498add9d7f4c467ec5ca9d4288568010e26b2). Although the specific instances we flagged above were addressed, the codebase is still inconsistent. Some error message are helpful and others are single word error messages prefixed with an exclamation point.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/RibbonThetaVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../libraries/GnosisAuction.sol\";\nimport {OptionsThetaVaultStorage} from \"../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\n\ncontract RibbonThetaVault is RibbonVault, OptionsThetaVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    // oTokenFactory is the factory contract used to spawn otokens. Used to lookup otokens.\n    address public immutable OTOKEN_FACTORY;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address manager\n    );\n\n    event NewOptionStrikeSelected(uint256 strikePrice, uint256 delta);\n\n    event PremiumDiscountSet(\n        uint256 premiumDiscount,\n        uint256 newPremiumDiscount\n    );\n\n    event AuctionDurationSet(\n        uint256 auctionDuration,\n        uint256 newAuctionDuration\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint16 round\n    );\n\n    event InitiateGnosisAuction(\n        address auctioningToken,\n        address biddingToken,\n        uint256 auctionCounter,\n        address manager\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _oTokenFactory is the contract address for minting new opyn option types (strikes, asset, expiry)\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction\n        )\n    {\n        require(_oTokenFactory != address(0), \"!_oTokenFactory\");\n        OTOKEN_FACTORY = _oTokenFactory;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function initialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        address _optionsPremiumPricer,\n        address _strikeSelection,\n        uint32 _premiumDiscount,\n        uint256 _auctionDuration,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n        require(_optionsPremiumPricer != address(0), \"!_optionsPremiumPricer\");\n        require(_strikeSelection != address(0), \"!_strikeSelection\");\n        require(\n            _premiumDiscount > 0 && _premiumDiscount < 1000,\n            \"!_premiumDiscount\"\n        );\n        require(_auctionDuration >= 1 hours, \"!_auctionDuration\");\n        optionsPremiumPricer = _optionsPremiumPricer;\n        strikeSelection = _strikeSelection;\n        premiumDiscount = _premiumDiscount;\n        auctionDuration = _auctionDuration;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new discount on premiums for options we are selling\n     * @param newPremiumDiscount is the premium discount\n     */\n    function setPremiumDiscount(uint16 newPremiumDiscount) external onlyOwner {\n        require(\n            newPremiumDiscount > 0 && newPremiumDiscount < 1000,\n            \"Invalid discount\"\n        );\n\n        emit PremiumDiscountSet(premiumDiscount, newPremiumDiscount);\n\n        premiumDiscount = newPremiumDiscount;\n    }\n\n    /**\n     * @notice Sets the new auction duration\n     * @param newAuctionDuration is the auction duration\n     */\n    function setAuctionDuration(uint256 newAuctionDuration) external onlyOwner {\n        require(newAuctionDuration >= 1 hours, \"Invalid auction duration\");\n\n        emit AuctionDurationSet(auctionDuration, newAuctionDuration);\n\n        auctionDuration = newAuctionDuration;\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function withdrawInstantly(uint256 amount) external nonReentrant {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        uint16 currentRound = vaultState.round;\n        require(amount > 0, \"!amount\");\n        require(depositReceipt.round == currentRound, \"Invalid round\");\n\n        uint104 receiptAmount = depositReceipt.amount;\n        require(receiptAmount >= amount, \"Exceed amount\");\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        depositReceipt.amount = uint104(uint256(receiptAmount).sub(amount));\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).sub(amount)\n        );\n\n        emit InstantWithdraw(msg.sender, amount, currentRound);\n\n        transferAsset(msg.sender, amount);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and closes the existing short.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external onlyOwner nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        VaultLifecycle.CloseParams memory closeParams =\n            VaultLifecycle.CloseParams({\n                OTOKEN_FACTORY: OTOKEN_FACTORY,\n                USDC: USDC,\n                currentOption: oldOption,\n                delay: delay,\n                lastStrikeOverride: lastStrikeOverride,\n                overriddenStrikePrice: overriddenStrikePrice\n            });\n\n        (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        ) =\n            VaultLifecycle.commitAndClose(\n                strikeSelection,\n                optionsPremiumPricer,\n                premiumDiscount,\n                closeParams,\n                vaultParams,\n                vaultState\n            );\n\n        emit NewOptionStrikeSelected(strikePrice, delta);\n\n        ShareMath.assertUint104(premium);\n        currentOtokenPremium = uint104(premium);\n        optionState.nextOption = otokenAddress;\n        optionState.nextOptionReadyAt = uint32(block.timestamp.add(delay));\n\n        _closeShort(oldOption);\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort(address oldOption) private {\n        optionState.currentOption = address(0);\n\n        uint104 lockedAmount = vaultState.lockedAmount;\n        vaultState.lastLockedAmount = lockedAmount > 0\n            ? lockedAmount\n            : vaultState.lastLockedAmount;\n\n        vaultState.lockedAmount = 0;\n\n        if (oldOption != address(0)) {\n            uint256 withdrawAmount =\n                VaultLifecycle.settleShort(GAMMA_CONTROLLER);\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextOption() external nonReentrant {\n        (address newOption, uint256 lockedBalance) = _rollToNextOption();\n\n        vaultState.lockedAmount = uint104(lockedBalance);\n\n        emit OpenShort(newOption, lockedBalance, msg.sender);\n\n        VaultLifecycle.createShort(\n            GAMMA_CONTROLLER,\n            MARGIN_POOL,\n            newOption,\n            lockedBalance\n        );\n\n        startAuction();\n    }\n\n    /**\n     * @notice Initiate the gnosis auction.\n     */\n    function startAuction() public onlyOwner {\n        GnosisAuction.AuctionDetails memory auctionDetails;\n\n        uint256 currOtokenPremium = currentOtokenPremium;\n\n        require(currOtokenPremium > 0, \"!currentOtokenPremium\");\n\n        auctionDetails.oTokenAddress = optionState.currentOption;\n        auctionDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        auctionDetails.asset = vaultParams.asset;\n        auctionDetails.assetDecimals = vaultParams.decimals;\n        auctionDetails.oTokenPremium = currOtokenPremium;\n        auctionDetails.duration = auctionDuration;\n\n        optionAuctionID = VaultLifecycle.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from gnosis auction.\n     */\n    function burnRemainingOTokens() external onlyOwner nonReentrant {\n        uint256 numOTokensToBurn =\n            IERC20(optionState.currentOption).balanceOf(address(this));\n        require(numOTokensToBurn > 0, \"!otokens\");\n        uint256 unlockedAssedAmount =\n            VaultLifecycle.burnOtokens(GAMMA_CONTROLLER, numOTokensToBurn);\n        vaultState.lockedAmount = uint104(\n            uint256(vaultState.lockedAmount).sub(unlockedAssedAmount)\n        );\n    }\n\n    /**\n     * @notice Optionality to set strike price manually\n     * @param strikePrice is the strike price of the new oTokens (decimals = 8)\n     */\n    function setStrikePrice(uint128 strikePrice)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(strikePrice > 0, \"!strikePrice\");\n        overriddenStrikePrice = strikePrice;\n        lastStrikeOverride = vaultState.round;\n    }\n}"
    },
    {
      "filename": "contracts/utils/StrikeSelection.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IOtoken} from \"../interfaces/GammaInterface.sol\";\nimport {\n    IPriceOracle\n} from \"@ribbon-finance/rvol/contracts/interfaces/IPriceOracle.sol\";\nimport {DSMath} from \"../vendor/DSMath.sol\";\nimport {IOptionsPremiumPricer} from \"../interfaces/IRibbon.sol\";\nimport {\n    IVolatilityOracle\n} from \"@ribbon-finance/rvol/contracts/interfaces/IVolatilityOracle.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract StrikeSelection is DSMath, Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * Immutables\n     */\n    IOptionsPremiumPricer public immutable optionsPremiumPricer;\n    IVolatilityOracle public immutable volatilityOracle;\n\n    // delta for options strike price selection. 1 is 10000\n    uint256 public delta;\n    // step in absolute terms at which we will increment\n    // (ex: 100 * 10 ** assetOracleDecimals means we will move at increments of 100 points)\n    uint256 public step;\n    // multiplier to shift asset prices\n    uint256 private immutable assetOracleMultiplier;\n\n    event DeltaSet(uint256 oldDelta, uint256 newDelta, address owner);\n    event StepSet(uint256 oldStep, uint256 newStep, address owner);\n\n    constructor(\n        address _optionsPremiumPricer,\n        uint256 _delta,\n        uint256 _step\n    ) {\n        require(_optionsPremiumPricer != address(0), \"!_optionsPremiumPricer\");\n        require(_delta > 0, \"!_delta\");\n        require(_step > 0, \"!_step\");\n        optionsPremiumPricer = IOptionsPremiumPricer(_optionsPremiumPricer);\n        volatilityOracle = IVolatilityOracle(\n            IOptionsPremiumPricer(_optionsPremiumPricer).volatilityOracle()\n        );\n        // ex: delta = 7500 (.75)\n        delta = _delta;\n        uint256 _assetOracleMultiplier =\n            10 **\n                IPriceOracle(\n                    IOptionsPremiumPricer(_optionsPremiumPricer).priceOracle()\n                )\n                    .decimals();\n\n        // ex: step = 1000\n        step = _step.mul(_assetOracleMultiplier);\n\n        assetOracleMultiplier = _assetOracleMultiplier;\n    }\n\n    /**\n     * @notice Gets the strike price satisfying the delta value\n     * given the expiry timestamp and whether option is call or put\n     * @param expiryTimestamp is the unix timestamp of expiration\n     * @param isPut is whether option is put or call\n     */\n\n    function getStrikePrice(uint256 expiryTimestamp, bool isPut)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        require(\n            expiryTimestamp > block.timestamp,\n            \"Expiry must be in the future!\"\n        );\n\n        // asset price\n        uint256 assetPrice = optionsPremiumPricer.getUnderlyingPrice();\n\n        // asset's annualized volatility\n        uint256 annualizedVol =\n            volatilityOracle.annualizedVol(optionsPremiumPricer.pool()).mul(\n                10**10\n            );\n\n        // For each asset prices with step of 'step' (down if put, up if call)\n        //   if asset's getOptionDelta(currStrikePrice, spotPrice, annualizedVol, t) == (isPut ? 1 - delta:delta)\n        //   with certain margin of error\n        //        return strike price\n\n        uint256 strike =\n            isPut\n                ? assetPrice.sub(assetPrice % step)\n                : assetPrice.add(step - (assetPrice % step));\n        uint256 targetDelta = isPut ? uint256(10000).sub(delta) : delta;\n        uint256 prevDelta = 10000;\n\n        while (true) {\n            uint256 currDelta =\n                optionsPremiumPricer.getOptionDelta(\n                    assetPrice.mul(10**8).div(assetOracleMultiplier),\n                    strike,\n                    annualizedVol,\n                    expiryTimestamp\n                );\n            //  If the current delta is between the previous\n            //  strike price delta and current strike price delta\n            //  then we are done\n            bool foundTargetStrikePrice =\n                isPut\n                    ? targetDelta >= prevDelta && targetDelta <= currDelta\n                    : targetDelta <= prevDelta && targetDelta >= currDelta;\n\n            if (foundTargetStrikePrice) {\n                uint256 finalDelta =\n                    _getBestDelta(prevDelta, currDelta, targetDelta, isPut);\n                uint256 finalStrike =\n                    _getBestStrike(finalDelta, prevDelta, strike, isPut);\n                require(\n                    isPut\n                        ? finalStrike <= assetPrice\n                        : finalStrike >= assetPrice\n                );\n                // make decimals consistent with oToken strike price decimals (10 ** 8)\n                return (\n                    finalStrike.mul(10**8).div(assetOracleMultiplier),\n                    finalDelta\n                );\n            }\n\n            strike = isPut ? strike.sub(step) : strike.add(step);\n\n            prevDelta = currDelta;\n        }\n    }\n\n    /**\n     * @notice Rounds to best delta value\n     * @param prevDelta is the delta of the previous strike price\n     * @param currDelta is delta of the current strike price\n     * @param targetDelta is the delta we are targeting\n     * @param isPut is whether its a put\n     */\n    function _getBestDelta(\n        uint256 prevDelta,\n        uint256 currDelta,\n        uint256 targetDelta,\n        bool isPut\n    ) private pure returns (uint256 finalDelta) {\n        uint256 upperBoundDiff =\n            isPut ? sub(currDelta, targetDelta) : sub(prevDelta, targetDelta);\n        uint256 lowerBoundDiff =\n            isPut ? sub(targetDelta, prevDelta) : sub(targetDelta, currDelta);\n\n        // for tie breaks (ex: 0.05 <= 0.1 <= 0.15) round to higher strike price\n        // for calls and lower strike price for puts for deltas\n        finalDelta = lowerBoundDiff <= upperBoundDiff\n            ? (isPut ? prevDelta : currDelta)\n            : (isPut ? currDelta : prevDelta);\n    }\n\n    /**\n     * @notice Rounds to best delta value\n     * @param finalDelta is the best delta value we found\n     * @param prevDelta is delta of the previous strike price\n     * @param strike is the strike of the previous iteration\n     * @param isPut is whether its a put\n     */\n    function _getBestStrike(\n        uint256 finalDelta,\n        uint256 prevDelta,\n        uint256 strike,\n        bool isPut\n    ) private view returns (uint256 finalStrike) {\n        if (isPut) {\n            if (finalDelta == prevDelta) {\n                finalStrike = strike.add(step);\n            } else {\n                finalStrike = strike;\n            }\n        } else {\n            if (finalDelta == prevDelta) {\n                finalStrike = strike.sub(step);\n            } else {\n                finalStrike = strike;\n            }\n        }\n    }\n\n    /**\n     * @notice Sets new delta value\n     * @param newDelta is the new delta value\n     */\n    function setDelta(uint256 newDelta) external onlyOwner {\n        uint256 oldDelta = delta;\n        delta = newDelta;\n        emit DeltaSet(oldDelta, newDelta, msg.sender);\n    }\n\n    /**\n     * @notice Sets new step value\n     * @param newStep is the new step value\n     */\n    function setStep(uint256 newStep) external onlyOwner {\n        uint256 oldStep = step;\n        step = newStep.mul(assetOracleMultiplier);\n        emit StepSet(oldStep, newStep, msg.sender);\n    }\n}"
    }
  ]
}