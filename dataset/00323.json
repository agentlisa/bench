{
  "Title": "H-2: Eligibility of cancelled proposals makes it possible for `proposalEligibilityQuorumBps` controlling actor to create multiple eligible proposals, stealing rewards from all others",
  "Content": "# Issue H-2: Eligibility of cancelled proposals makes it possible for `proposalEligibilityQuorumBps` controlling actor to create multiple eligible proposals, stealing rewards from all others \n\nSource: https://github.com/sherlock-audit/2024-03-nouns-dao-2-judging/issues/51 \n\n## Found by \nhyh\n## Summary\n\nActor controlling more than `proposalEligibilityQuorumBps` can spam eligible proposals via creation, voting and canceling them, stealing proposal based rewards from all other participants. Since `proposalEligibilityQuorumBps` is set to `10%`, it can require colluding of the several Nouns holders. Spamming here means that this have much shorter turnaround time compared to usual workflow and has a potential of heavily diluting the rewards for all others.\n\n## Vulnerability Detail\n\nSuppose an actor is affiliated with `clientId` being `approved` and controls (directly or indirectly via collusion) more than `proposalEligibilityQuorumBps` of the current total supply. They can repeat `(create, vote, cancel)` cycle over time obtaining a significant share of proposal rewards since this will produce eligible proposals substantially faster compared to the normal lifecycle as full `votingPeriod` is omitted.\n\nIn order to conceal the manipulation this can be intermixed with other activities: i.e. before most valid proposal's, having target `clientId`, voting and execution there might be some deliberately broken versions of this proposal being posted, then voted on and cancelled like if the inconsistency was just being discovered. This can be done gradually in order to avoid raising red flags and keep `clientId` valid.\n\n## Impact\n\nThe only prerequisite is some arrangement of Nouns holders in order in exceed `proposalEligibilityQuorumBps` bar. All the rest can be done routinely. The manipulation will not be evident on rewards allocation as `updateRewardsForProposalWritingAndVoting()` will count manipulated proposals automatically.\n\nIncreasing the number of eligible proposals has substantial impact on rewards calculation, so the impact on the other client id owners' reward revenue is high.\n\nLikelihood: Medium + Impact: High = Severity: High.\n\n## Code Snippet\n\nCancelled proposals will be deemed valid and will dilute the proposal rewards base:\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/client-incentives/Rewards.sol#L352-L368\n\n```solidity\n        for (uint256 i; i < proposals.length; ++i) {\n            // make sure proposal finished voting\n            uint endBlock = max(proposals[i].endBlock, proposals[i].objectionPeriodEndBlock);\n>>          require(block.number > endBlock, 'all proposals must be done with voting');\n\n            // skip non eligible proposals\n>>          if (proposals[i].forVotes < (proposals[i].totalSupply * proposalEligibilityQuorumBps_) / 10_000) {\n                delete proposals[i];\n                continue;\n            }\n\n            // proposal is eligible for reward\n            ++t.numEligibleProposals;\n\n            uint256 votesInProposal = proposals[i].forVotes + proposals[i].againstVotes + proposals[i].abstainVotes;\n            t.numEligibleVotes += votesInProposal;\n        }\n```\n\nProposals can be cancelled by `proposer` early on (whenever in a non-final state), i.e. right after `proposalUpdatablePeriodInBlocks + votingDelay` passed and proposal becomes `Active`, so it can be voted on and cancelled:\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/governance/NounsDAOProposals.sol#L518-L547\n\n```solidity\n    function cancel(NounsDAOTypes.Storage storage ds, uint256 proposalId) external {\n        NounsDAOTypes.ProposalState proposalState = stateInternal(ds, proposalId);\n        if (\n            proposalState == NounsDAOTypes.ProposalState.Canceled ||\n            proposalState == NounsDAOTypes.ProposalState.Defeated ||\n            proposalState == NounsDAOTypes.ProposalState.Expired ||\n            proposalState == NounsDAOTypes.ProposalState.Executed ||\n            proposalState == NounsDAOTypes.ProposalState.Vetoed\n        ) {\n>>          revert CantCancelProposalAtFinalState();\n        }\n\n        NounsDAOTypes.Proposal storage proposal = ds._proposals[proposalId];\n        address proposer = proposal.proposer;\n        NounsTokenLike nouns = ds.nouns;\n\n        uint256 votes = nouns.getPriorVotes(proposer, block.number - 1);\n        bool msgSenderIsProposer = proposer == msg.sender;\n        address[] memory signers = proposal.signers;\n        for (uint256 i = 0; i < signers.length; ++i) {\n            msgSenderIsProposer = msgSenderIsProposer || msg.sender == signers[i];\n            votes += nouns.getPriorVotes(signers[i], block.number - 1);\n        }\n\n        require(\n>>          msgSenderIsProposer || votes <= proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n>>      proposal.canceled = true;\n```\n\nAfter that proposer and other backers can immediately create new proposal since the state of their current one is `Canceled` and the corresponding check is satisfied:\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/governance/NounsDAOProposals.sol#L778-L789\n\n```solidity\n>>  function checkNoActiveProp(NounsDAOTypes.Storage storage ds, address proposer) internal view {\n        uint256 latestProposalId = ds.latestProposalIds[proposer];\n        if (latestProposalId != 0) {\n            NounsDAOTypes.ProposalState proposersLatestProposalState = stateInternal(ds, latestProposalId);\n            if (\n>>              proposersLatestProposalState == NounsDAOTypes.ProposalState.ObjectionPeriod ||\n>>              proposersLatestProposalState == NounsDAOTypes.ProposalState.Active ||\n>>              proposersLatestProposalState == NounsDAOTypes.ProposalState.Pending ||\n>>              proposersLatestProposalState == NounsDAOTypes.ProposalState.Updatable\n            ) revert ProposerAlreadyHasALiveProposal();\n        }\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/governance/NounsDAOProposals.sol#L582-L592\n\n```solidity\n    function stateInternal(\n        NounsDAOTypes.Storage storage ds,\n        uint256 proposalId\n    ) internal view returns (NounsDAOTypes.ProposalState) {\n        require(ds.proposalCount >= proposalId, 'NounsDAO::state: invalid proposal id');\n        NounsDAOTypes.Proposal storage proposal = ds._proposals[proposalId];\n\n        if (proposal.vetoed) {\n            return NounsDAOTypes.ProposalState.Vetoed;\n        } else if (proposal.canceled) {\n>>          return NounsDAOTypes.ProposalState.Canceled;\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider ignoring cancelled proposals, e.g.:\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/governance/NounsDAOProposals.sol#L719-L732\n\n```diff\n    function proposalDataForRewards(\n        ...\n    ) internal view returns (NounsDAOTypes.ProposalForRewards[] memory) {\n        require(lastProposalId >= firstProposalId, 'lastProposalId >= firstProposalId');\n        uint256 numProposals = lastProposalId - firstProposalId + 1;\n        NounsDAOTypes.ProposalForRewards[] memory data = new NounsDAOTypes.ProposalForRewards[](numProposals);\n\n        NounsDAOTypes.Proposal storage proposal;\n        uint256 i;\n        for (uint256 pid = firstProposalId; pid <= lastProposalId; ++pid) {\n            proposal = ds._proposals[pid];\n+           if (proposal.canceled) continue;            \n```\n\nRationale is that cancelled proposal is a kind of discarded draft, even if it was voted on, and is to be replaced by another, corrected, version, so including both in the proposal rewards is essentially double counting.\n\nVetoed ones can stay as is since, apart from veto power holder being trusted, in order to require a veto the proposal needs to be executable, so there looks to be no possibility to quickly iterate many such proposals and dilute the rewards. I.e. canceling provides a significant speed up for eligible proposals making, while vetoing doesn't.\n\nAlso, as a simplification and a mitigation for other issues, the eligibility threshold can be passed to `proposalDataForRewards()` and non-eligible proposals can be excluded early on, e.g.:\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/client-incentives/Rewards.sol#L323-L327\n\n```diff\n        NounsDAOTypes.ProposalForRewards[] memory proposals = nounsDAO.proposalDataForRewards(\n            t.nextProposalIdToReward,\n            lastProposalId,\n+           $.params.proposalEligibilityQuorumBps,\n            votingClientIds\n        );\n```\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/governance/NounsDAOProposals.sol#L719-L737\n\n```diff\n    function proposalDataForRewards(\n        NounsDAOTypes.Storage storage ds,\n        uint256 firstProposalId,\n        uint256 lastProposalId,\n+       uint16 proposalEligibilityQuorumBps,\n        uint32[] calldata votingClientIds\n    ) internal view returns (NounsDAOTypes.ProposalForRewards[] memory) {\n        require(lastProposalId >= firstProposalId, 'lastProposalId >= firstProposalId');\n        uint256 numProposals = lastProposalId - firstProposalId + 1;\n        NounsDAOTypes.ProposalForRewards[] memory data = new NounsDAOTypes.ProposalForRewards[](numProposals);\n\n        NounsDAOTypes.Proposal storage proposal;\n        uint256 i;\n        for (uint256 pid = firstProposalId; pid <= lastProposalId; ++pid) {\n            proposal = ds._proposals[pid];\n+           if (proposal.canceled || proposals.forVotes < (proposals.totalSupply * proposalEligibilityQuorumBps) / 10_000) continue;\n\n            NounsDAOTypes.ClientVoteData[] memory c = new NounsDAOTypes.ClientVoteData[](votingClientIds.length);\n            for (uint256 j; j < votingClientIds.length; ++j) {\n                c[j] = proposal.voteClients[votingClientIds[j]];\n            }\n```\n\nKeeping `endBlock > 0` just in case, while the rest is already checked:\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/client-incentives/Rewards.sol#L355-L361\n\n```diff\n-           require(block.number > endBlock, 'all proposals must be done with voting');\n+           require(endBlock > 0 && block.number > endBlock, 'all voting must be completed');\n\n-           // skip non eligible proposals\n-           if (proposals[i].forVotes < (proposals[i].totalSupply * proposalEligibilityQuorumBps_) / 10_000) {\n-               delete proposals[i];\n-               continue;\n-           }\n```\n\nhttps://github.com/sherlock-audit/2024-03-nouns-dao-2/blob/main/nouns-monorepo/packages/nouns-contracts/contracts/client-incentives/Rewards.sol#L411-L413\n\n```diff\n        for (uint256 i; i < proposals.length; ++i) {\n-           // skip non eligible deleted proposals\n-           if (proposals[i].endBlock == 0) continue;\n```\n\n\n\n## Discussion\n\n**eladmallel**\n\nWe are working on a fix that will better filter out proposals.\n\nStill wanted to highlight that we think severity should be lower because likelihood is very low, and that's because an attacker needs to have at least `totalSupply * proposalEligibilityQuorumBps / 10_000` votes.\n\n**WangSecurity**\n\nYeam, it seems the likelihood should indeed be low + high impact = medium. \n\n**WangSecurity**\n\nComment from LSW:\n\n\"the 10% requirement is for coalition that nouns holders can make, not necessary for one attacker. Also, total supply is decreased by forking. Overall, this is a somewhat higher ask, but in the same time the manipulation surface itself is somewhat bigger, as natural proposal count is low enough, so cancelled proposals can have substantial impact (say, 2-3x reward depression for the honest ones)\".\n\nUnder these reasons, the report remains High severity.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/nounsDAO/nouns-monorepo/pull/839\n\n\n**dmitriia**\n\nFix looks ok: cancelled proposals are now filtered out in `proposalDataForRewards()`.\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/202",
  "Code": [
    {
      "filename": "nouns-monorepo/packages/nouns-contracts/contracts/client-incentives/Rewards.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The client incentives rewards logic\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport { INounsDAOLogic } from '../interfaces/INounsDAOLogic.sol';\nimport { INounsAuctionHouseV2 } from '../interfaces/INounsAuctionHouseV2.sol';\nimport { NounsDAOTypes } from '../governance/NounsDAOInterfaces.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { UUPSUpgradeable } from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { PausableUpgradeable } from '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport { ClientRewardsMemoryMapping } from '../libs/ClientRewardsMemoryMapping.sol';\nimport { GasRefund } from '../libs/GasRefund.sol';\nimport { INounsClientTokenDescriptor } from './INounsClientTokenDescriptor.sol';\nimport { INounsClientTokenTypes } from './INounsClientTokenTypes.sol';\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport { ERC721Upgradeable } from '@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol';\nimport { SafeCast } from '@openzeppelin/contracts/utils/math/SafeCast.sol';\n\ncontract Rewards is\n    UUPSUpgradeable,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    ERC721Upgradeable,\n    INounsClientTokenTypes\n{\n    using SafeERC20 for IERC20;\n    using ClientRewardsMemoryMapping for ClientRewardsMemoryMapping.Mapping;\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   EVENTS\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    event ClientRegistered(uint32 indexed clientId, string name, string description);\n    event ClientUpdated(uint32 indexed clientId, string name, string description);\n    event ClientRewarded(uint32 indexed clientId, uint256 amount);\n    event ClientBalanceWithdrawal(uint32 indexed clientId, uint256 amount, address to);\n    event AuctionRewardsUpdated(uint256 firstAuctionId, uint256 lastAuctionId);\n    event ProposalRewardsUpdated(\n        uint32 firstProposalId,\n        uint32 lastProposalId,\n        uint256 firstAuctionIdForRevenue,\n        uint256 lastAuctionIdForRevenue,\n        uint256 auctionRevenue,\n        uint256 rewardPerProposal,\n        uint256 rewardPerVote\n    );\n    event ClientApprovalSet(uint32 indexed clientId, bool approved);\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   IMMUTABLES\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    INounsDAOLogic public immutable nounsDAO;\n\n    INounsAuctionHouseV2 public immutable auctionHouse;\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   STORAGE VARIABLES\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    struct RewardParams {\n        /// @dev Used for proposal rewards\n        /// @dev The minimum reward period for proposal updates if number of proposals is below `numProposalsEnoughForReward`\n        uint32 minimumRewardPeriod;\n        /// @dev The number of proposals required for an update before `minimumRewardPeriod` has passed\n        uint8 numProposalsEnoughForReward;\n        /// @dev How much bips out of the auction revenue during this period to use for rewarding proposal creation\n        uint16 proposalRewardBps;\n        /// @dev How much bips out of the auction revenue during this period to use for rewarding proposal voting\n        uint16 votingRewardBps;\n        /// @dev How many (in bips) FOR votes out of total votes are required for a proposal to be eligible for rewards\n        uint16 proposalEligibilityQuorumBps;\n        /// @dev Used for auction rewards\n        /// @dev How much bips out of auction revnue to use for rewarding auction bidding\n        uint16 auctionRewardBps;\n        /// @dev Minimum number of auctions between updates. Zero means 1 auction is enough.\n        uint8 minimumAuctionsBetweenUpdates;\n    }\n\n    /// @custom:storage-location erc7201:nouns.rewards\n    struct RewardsStorage {\n        /// @dev The next client token id to be minted\n        uint32 nextTokenId;\n        /// @dev Used for auction rewards state\n        uint32 nextAuctionIdToReward;\n        /// @dev Used for proposal rewards state\n        uint32 nextProposalIdToReward;\n        /// @dev The first auction id to consider for revenue tracking on the next proposal rewards update\n        uint32 nextProposalRewardFirstAuctionId;\n        /// @dev Last time the proposal rewards update was performed\n        uint40 lastProposalRewardsUpdate;\n        /// @dev Params for both auction & rewards\n        RewardParams params;\n        /// @dev An ETH pegged ERC20 token to use for rewarding\n        IERC20 ethToken;\n        /// @dev admin account able to pause/unpause the contract in case of a quick response is needed\n        address admin;\n        /// @dev client metadata per clientId, including rewards balances, name, description\n        mapping(uint32 clientId => ClientMetadata) _clientMetadata;\n        /// @dev The client NFT descriptor\n        address descriptor;\n    }\n\n    /// @dev This is a ERC-7201 storage location, calculated using:\n    /// @dev keccak256(abi.encode(uint256(keccak256(\"nouns.rewards\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 public constant RewardsStorageLocation = 0x9a06af3161ac5b0c3de4e6c981ab9d9f60b530386f5eaae00d541393fbecd700;\n\n    function _getRewardsStorage() private pure returns (RewardsStorage storage $) {\n        assembly {\n            $.slot := RewardsStorageLocation\n        }\n    }\n\n    /**\n     * @dev Reverts if called by any account other than the owner or admin.\n     */\n    modifier onlyOwnerOrAdmin() {\n        RewardsStorage storage $ = _getRewardsStorage();\n        require(owner() == _msgSender() || $.admin == _msgSender(), 'Caller must be owner or admin');\n        _;\n    }\n\n    constructor(address nounsDAO_, address auctionHouse_) initializer {\n        nounsDAO = INounsDAOLogic(nounsDAO_);\n        auctionHouse = INounsAuctionHouseV2(auctionHouse_);\n    }\n\n    function initialize(\n        address owner,\n        address admin_,\n        address ethToken_,\n        uint32 nextProposalIdToReward_,\n        uint32 nextAuctionIdToReward_,\n        uint32 nextProposalRewardFirstAuctionId_,\n        RewardParams memory rewardParams,\n        address descriptor_\n    ) public initializer {\n        __Pausable_init_unchained();\n        __ERC721_init('Nouns Client Token', 'NOUNSCLIENT');\n\n        RewardsStorage storage $ = _getRewardsStorage();\n        $.nextTokenId = 1;\n        $.lastProposalRewardsUpdate = uint40(block.timestamp);\n\n        _transferOwnership(owner);\n        $.admin = admin_;\n        $.ethToken = IERC20(ethToken_);\n        $.nextProposalIdToReward = nextProposalIdToReward_;\n        $.nextAuctionIdToReward = nextAuctionIdToReward_;\n        $.nextProposalRewardFirstAuctionId = nextProposalRewardFirstAuctionId_;\n        $.params = rewardParams;\n        $.descriptor = descriptor_;\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   PUBLIC WRITE\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    /**\n     * @notice Register a client, mints an NFT and assigns a clientId\n     * @return uint32 the newly assigned clientId\n     */\n    function registerClient(string calldata name, string calldata description) external whenNotPaused returns (uint32) {\n        RewardsStorage storage $ = _getRewardsStorage();\n\n        uint32 tokenId = $.nextTokenId;\n        $.nextTokenId = tokenId + 1;\n        _mint(msg.sender, tokenId);\n\n        ClientMetadata storage md = $._clientMetadata[tokenId];\n        md.name = name;\n        md.description = description;\n\n        emit ClientRegistered(tokenId, name, description);\n\n        return tokenId;\n    }\n\n    /**\n     * @notice Update the metadata of a client\n     * @dev Only the owner of the client token can update the metadata.\n     * @param tokenId The token ID of the client\n     * @param name The new name of the client\n     * @param description The new description of the client\n     */\n    function updateClientMetadata(uint32 tokenId, string calldata name, string calldata description) external {\n        RewardsStorage storage $ = _getRewardsStorage();\n\n        require(ownerOf(tokenId) == msg.sender, 'NounsClientToken: not owner');\n        ClientMetadata storage md = $._clientMetadata[tokenId];\n        md.name = name;\n        md.description = description;\n\n        emit ClientUpdated(tokenId, name, description);\n    }\n\n    /**\n     * @notice Distribute rewards for auction bidding since the last update until auction with id `lastNounId`\n     * If an auction's winning bid was called with a clientId, that client will be reward with `params.auctionRewardBps`\n     * bips of the auction's settlement amount.\n     * At least `minimumAuctionsBetweenUpdates` must happen between updates.\n     * Gas spent is refunded in `ethToken`.\n     * @param lastNounId the last auction id to reward client for. must be already settled.\n     * @dev Gas is refunded if at least one auction was rewarded\n     */\n    function updateRewardsForAuctions(uint32 lastNounId) public whenNotPaused {\n        uint256 startGas = gasleft();\n        RewardsStorage storage $ = _getRewardsStorage();\n\n        bool sawValidClientId = false;\n        uint256 nextAuctionIdToReward_ = $.nextAuctionIdToReward;\n        require(\n            lastNounId >= nextAuctionIdToReward_ + $.params.minimumAuctionsBetweenUpdates,\n            'lastNounId must be higher'\n        );\n        $.nextAuctionIdToReward = lastNounId + 1;\n\n        INounsAuctionHouseV2.Settlement[] memory settlements = auctionHouse.getSettlements(\n            nextAuctionIdToReward_,\n            lastNounId + 1,\n            true\n        );\n        INounsAuctionHouseV2.Settlement memory lastSettlement = settlements[settlements.length - 1];\n        require(lastSettlement.nounId == lastNounId && lastSettlement.blockTimestamp > 1, 'lastNounId must be settled');\n\n        uint32 maxClientId = nextTokenId() - 1;\n        ClientRewardsMemoryMapping.Mapping memory m = ClientRewardsMemoryMapping.createMapping({\n            maxClientId: maxClientId\n        });\n\n        for (uint256 i; i < settlements.length; ++i) {\n            INounsAuctionHouseV2.Settlement memory settlement = settlements[i];\n            if (settlement.clientId != 0 && settlement.clientId <= maxClientId) {\n                sawValidClientId = true;\n                m.inc(settlement.clientId, settlement.amount);\n            }\n        }\n\n        uint16 auctionRewardBps = $.params.auctionRewardBps;\n        uint256 numValues = m.numValues();\n        for (uint32 i = 0; i < numValues; ++i) {\n            ClientRewardsMemoryMapping.ClientBalance memory cb = m.getValue(i);\n            uint256 reward = (cb.balance * auctionRewardBps) / 10_000;\n            $._clientMetadata[cb.clientId].rewarded += SafeCast.toUint96(reward);\n\n            emit ClientRewarded(cb.clientId, reward);\n        }\n\n        emit AuctionRewardsUpdated(nextAuctionIdToReward_, lastNounId);\n\n        if (sawValidClientId) {\n            // refund gas only if we're actually rewarding a client, not just moving the pointer\n            GasRefund.refundGas($.ethToken, startGas);\n        }\n    }\n\n    /// @dev struct used to avoid stack-too-deep errors\n    struct Temp {\n        uint32 maxClientId;\n        uint256 numEligibleVotes;\n        uint256 numEligibleProposals;\n        uint256 rewardPerProposal;\n        uint256 rewardPerVote;\n        uint256 proposalRewardForPeriod;\n        uint256 votingRewardForPeriod;\n        uint32 nextProposalIdToReward;\n        uint256 firstAuctionIdForRevenue;\n        NounsDAOTypes.ProposalForRewards lastProposal;\n    }\n\n    /**\n     * @notice Distribute rewards for proposal creation and voting from the last update until `lastProposalId`.\n     * A proposal is eligible for rewards if for-votes/total-votes >= params.proposalEligibilityQuorumBps.\n     * Rewards are calculated by the auctions revenue during the period between the creation time of last proposal in\n     * the previous update until the current last proposal with id `lastProposalId`.\n     * Gas spent is refunded in `ethToken`.\n     * @param lastProposalId id of the last proposal to include in the rewards distribution. all proposals up to and\n     * including this id must have ended voting.\n     * @param votingClientIds array of sorted client ids that were used to vote on the eligible proposals in\n     * this rewards distribution. reverts if contains duplicates. reverts if not sorted. reverts if a clientId had zero votes.\n     * You may use `getVotingClientIds` as a convenience function to get the correct `votingClientIds`.\n     */\n    function updateRewardsForProposalWritingAndVoting(\n        uint32 lastProposalId,\n        uint32[] calldata votingClientIds\n    ) public whenNotPaused {\n        uint256 startGas = gasleft();\n        RewardsStorage storage $ = _getRewardsStorage();\n\n        Temp memory t;\n\n        t.maxClientId = nextTokenId() - 1;\n        t.nextProposalIdToReward = $.nextProposalIdToReward;\n\n        require(lastProposalId <= nounsDAO.proposalCount(), 'bad lastProposalId');\n        require(lastProposalId >= t.nextProposalIdToReward, 'bad lastProposalId');\n        require(isSortedAndNoDuplicates(votingClientIds), 'must be sorted & unique');\n\n        NounsDAOTypes.ProposalForRewards[] memory proposals = nounsDAO.proposalDataForRewards(\n            t.nextProposalIdToReward,\n            lastProposalId,\n            votingClientIds\n        );\n        $.nextProposalIdToReward = lastProposalId + 1;\n\n        t.lastProposal = proposals[proposals.length - 1];\n\n        t.firstAuctionIdForRevenue = $.nextProposalRewardFirstAuctionId;\n        (uint256 auctionRevenue, uint256 lastAuctionIdForRevenue) = getAuctionRevenue({\n            firstNounId: t.firstAuctionIdForRevenue,\n            endTimestamp: t.lastProposal.creationTimestamp\n        });\n        $.nextProposalRewardFirstAuctionId = uint32(lastAuctionIdForRevenue) + 1;\n\n        require(auctionRevenue > 0, 'auctionRevenue must be > 0');\n\n        t.proposalRewardForPeriod = (auctionRevenue * $.params.proposalRewardBps) / 10_000;\n        t.votingRewardForPeriod = (auctionRevenue * $.params.votingRewardBps) / 10_000;\n\n        uint16 proposalEligibilityQuorumBps_ = $.params.proposalEligibilityQuorumBps;\n\n        //// First loop over the proposals:\n        //// 1. Make sure all proposals have finished voting.\n        //// 2. Delete (zero out) proposals that are non elgibile (i.e. not enough For votes).\n        //// 3. Count the number of eligible proposals.\n        //// 4. Count the number of votes in eligible proposals.\n\n        for (uint256 i; i < proposals.length; ++i) {\n            // make sure proposal finished voting\n            uint endBlock = max(proposals[i].endBlock, proposals[i].objectionPeriodEndBlock);\n            require(block.number > endBlock, 'all proposals must be done with voting');\n\n            // skip non eligible proposals\n            if (proposals[i].forVotes < (proposals[i].totalSupply * proposalEligibilityQuorumBps_) / 10_000) {\n                delete proposals[i];\n                continue;\n            }\n\n            // proposal is eligible for reward\n            ++t.numEligibleProposals;\n\n            uint256 votesInProposal = proposals[i].forVotes + proposals[i].againstVotes + proposals[i].abstainVotes;\n            t.numEligibleVotes += votesInProposal;\n        }\n\n        //// Check that distribution is allowed:\n        //// 1. At least one eligible proposal.\n        //// 2. One of the two conditions must be true:\n        //// 2.a. Number of eligible proposals is at least `numProposalsEnoughForReward`.\n        //// 2.b. At least `minimumRewardPeriod` seconds have passed since the last update.\n\n        require(t.numEligibleProposals > 0, 'at least one eligible proposal');\n        if (t.numEligibleProposals < $.params.numProposalsEnoughForReward) {\n            require(\n                t.lastProposal.creationTimestamp > $.lastProposalRewardsUpdate + $.params.minimumRewardPeriod,\n                'not enough time passed'\n            );\n        }\n        $.lastProposalRewardsUpdate = uint40(t.lastProposal.creationTimestamp);\n\n        // Calculate the reward per proposal and per vote\n        t.rewardPerProposal = t.proposalRewardForPeriod / t.numEligibleProposals;\n        t.rewardPerVote = t.votingRewardForPeriod / t.numEligibleVotes;\n\n        emit ProposalRewardsUpdated(\n            t.nextProposalIdToReward,\n            lastProposalId,\n            t.firstAuctionIdForRevenue,\n            lastAuctionIdForRevenue,\n            auctionRevenue,\n            t.rewardPerProposal,\n            t.rewardPerVote\n        );\n\n        //// Second loop over the proposals:\n        //// 1. Skip proposals that were deleted for non eligibility.\n        //// 2. Reward proposal's clientId.\n        //// 3. Reward the clientIds that faciliated voting.\n        //// 4. Make sure all voting clientIds were included. This is meant to avoid griefing. Otherwises one could pass\n        ////    a large array of votingClientIds, spend a lot of gas, and have that gas refunded.\n\n        ClientRewardsMemoryMapping.Mapping memory m = ClientRewardsMemoryMapping.createMapping({\n            maxClientId: t.maxClientId\n        });\n        bool[] memory didClientIdHaveVotes = new bool[](votingClientIds.length);\n\n        for (uint256 i; i < proposals.length; ++i) {\n            // skip non eligible deleted proposals\n            if (proposals[i].endBlock == 0) continue;\n\n            uint32 clientId = proposals[i].clientId;\n            if (clientId != 0 && clientId <= t.maxClientId) {\n                m.inc(clientId, t.rewardPerProposal);\n            }\n\n            uint256 votesInProposal;\n            NounsDAOTypes.ClientVoteData[] memory voteData = proposals[i].voteData;\n            for (uint256 j; j < votingClientIds.length; ++j) {\n                clientId = votingClientIds[j];\n                uint256 votes = voteData[j].votes;\n                didClientIdHaveVotes[j] = didClientIdHaveVotes[j] || votes > 0;\n                if (clientId != 0 && clientId <= t.maxClientId) {\n                    m.inc(clientId, votes * t.rewardPerVote);\n                }\n                votesInProposal += votes;\n            }\n            require(\n                votesInProposal == proposals[i].forVotes + proposals[i].againstVotes + proposals[i].abstainVotes,\n                'not all votes accounted'\n            );\n        }\n\n        for (uint256 i = 0; i < didClientIdHaveVotes.length; ++i) {\n            require(didClientIdHaveVotes[i], 'all clientId must have votes');\n        }\n\n        uint256 numValues = m.numValues();\n        for (uint32 i = 0; i < numValues; ++i) {\n            ClientRewardsMemoryMapping.ClientBalance memory cb = m.getValue(i);\n            $._clientMetadata[cb.clientId].rewarded += SafeCast.toUint96(cb.balance);\n            emit ClientRewarded(cb.clientId, cb.balance);\n        }\n\n        GasRefund.refundGas($.ethToken, startGas);\n    }\n\n    /**\n     * @notice Withdraws the balance of a client\n     * @dev The caller must be the owner of the NFT with id `clientId` and the client must be approved by the DAO.\n     * @param clientId Which client balance to withdraw\n     * @param to the address to withdraw to\n     * @param amount amount to withdraw\n     */\n    function withdrawClientBalance(uint32 clientId, address to, uint96 amount) public whenNotPaused {\n        RewardsStorage storage $ = _getRewardsStorage();\n        ClientMetadata storage md = $._clientMetadata[clientId];\n\n        require(ownerOf(clientId) == msg.sender, 'must be client NFT owner');\n        require(md.approved, 'client not approved');\n\n        uint96 withdrawnCache = md.withdrawn;\n        require(amount <= md.rewarded - withdrawnCache, 'amount too large');\n\n        md.withdrawn = withdrawnCache + amount;\n\n        emit ClientBalanceWithdrawal(clientId, amount, to);\n\n        $.ethToken.safeTransfer(to, amount);\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   PUBLIC READ\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    /**\n     * @notice Returns the withdrawable balance of client with id `clientId`\n     */\n    function clientBalance(uint32 clientId) public view returns (uint96) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        ClientMetadata storage md = $._clientMetadata[clientId];\n        return md.rewarded - md.withdrawn;\n    }\n\n    /**\n     * @notice Returns the clientIds that are needed to be passed as a parameter to updateRewardsForProposalWritingAndVoting\n     * @dev This is not meant to be called onchain because it may be very gas intensive.\n     */\n    function getVotingClientIds(uint32 lastProposalId) public view returns (uint32[] memory) {\n        RewardsStorage storage $ = _getRewardsStorage();\n\n        uint256 numClientIds = nextTokenId();\n        uint32[] memory allClientIds = new uint32[](numClientIds);\n        for (uint32 i; i < numClientIds; ++i) {\n            allClientIds[i] = i;\n        }\n        NounsDAOTypes.ProposalForRewards[] memory proposals = nounsDAO.proposalDataForRewards(\n            $.nextProposalIdToReward,\n            lastProposalId,\n            allClientIds\n        );\n\n        uint32[] memory sumVotes = new uint32[](numClientIds);\n        for (uint256 i; i < proposals.length; ++i) {\n            for (uint256 j; j < numClientIds; ++j) {\n                sumVotes[j] += proposals[i].voteData[j].votes;\n            }\n        }\n\n        uint256 idx;\n        uint32[] memory nonZeroClientIds = new uint32[](numClientIds);\n        for (uint32 i; i < numClientIds; ++i) {\n            if (sumVotes[i] > 0) nonZeroClientIds[idx++] = i;\n        }\n\n        assembly {\n            mstore(nonZeroClientIds, idx)\n        }\n\n        return nonZeroClientIds;\n    }\n\n    /**\n     * Returns the sum of revenue via auctions from auctioning noun with id `firstNounId` until timestamp of `endTimestamp\n     */\n    function getAuctionRevenue(\n        uint256 firstNounId,\n        uint256 endTimestamp\n    ) public view returns (uint256 sumRevenue, uint256 lastAuctionId) {\n        INounsAuctionHouseV2.Settlement[] memory s = auctionHouse.getSettlementsFromIdtoTimestamp(\n            firstNounId,\n            endTimestamp,\n            true\n        );\n        sumRevenue = sumAuctions(s);\n        lastAuctionId = s[s.length - 1].nounId;\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   PUBLIC READ - STORAGE GETTERS\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    function nextAuctionIdToReward() public view returns (uint256) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.nextAuctionIdToReward;\n    }\n\n    function nextProposalIdToReward() public view returns (uint32) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.nextProposalIdToReward;\n    }\n\n    function nextProposalRewardFirstAuctionId() public view returns (uint256) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.nextProposalRewardFirstAuctionId;\n    }\n\n    function lastProposalRewardsUpdate() public view returns (uint256) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.lastProposalRewardsUpdate;\n    }\n\n    function getParams() public view returns (RewardParams memory) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.params;\n    }\n\n    function ethToken() public view returns (IERC20) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.ethToken;\n    }\n\n    function admin() public view returns (address) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.admin;\n    }\n\n    /**\n     * @notice Get the metadata of a client\n     */\n    function clientMetadata(uint32 tokenId) public view returns (ClientMetadata memory) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $._clientMetadata[tokenId];\n    }\n\n    /**\n     * @notice Get the URI of a client token\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return INounsClientTokenDescriptor($.descriptor).tokenURI(tokenId, $._clientMetadata[uint32(tokenId)]);\n    }\n\n    /**\n     * @notice Get the descriptor for the client token\n     */\n    function descriptor() public view returns (address) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.descriptor;\n    }\n\n    /**\n     * @notice Get the next token ID\n     */\n    function nextTokenId() public view returns (uint32) {\n        RewardsStorage storage $ = _getRewardsStorage();\n        return $.nextTokenId;\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   ADMIN\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    /**\n     * @notice Set whether the client is approved to withdraw their reward balance.\n     * Anyone can mint a client NFT and start earning rewards, but only approved clients can withdraw.\n     * This way the DAO helps mitigate abuse.\n     * @dev Only `owner` can call this function\n     */\n    function setClientApproval(uint32 clientId, bool approved) public onlyOwner {\n        RewardsStorage storage $ = _getRewardsStorage();\n        $._clientMetadata[clientId].approved = approved;\n        emit ClientApprovalSet(clientId, approved);\n    }\n\n    /**\n     * @dev Only `owner` can call this function\n     */\n    function setParams(RewardParams calldata newParams) public onlyOwner {\n        RewardsStorage storage $ = _getRewardsStorage();\n        $.params = newParams;\n    }\n\n    /**\n     * @dev Only `owner` can call this function\n     */\n    function setAdmin(address newAdmin) public onlyOwner {\n        RewardsStorage storage $ = _getRewardsStorage();\n        $.admin = newAdmin;\n    }\n\n    /**\n     * @dev Only `owner` can call this function\n     */\n    function setETHToken(address newToken) public onlyOwner {\n        RewardsStorage storage $ = _getRewardsStorage();\n        $.ethToken = IERC20(newToken);\n    }\n\n    /**\n     * @dev Only `owner` can call this function\n     */\n    function withdrawToken(address token, address to, uint256 amount) public onlyOwner {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @dev Only `owner` or `admin` can call this function\n     */\n    function pause() public onlyOwnerOrAdmin {\n        _pause();\n    }\n\n    /**\n     * @dev Only `owner` or `admin` can call this function\n     */\n    function unpause() public onlyOwnerOrAdmin {\n        _unpause();\n    }\n\n    /**\n     * @notice Set the descriptor for the client token\n     */\n    function setDescriptor(address descriptor_) public onlyOwner {\n        RewardsStorage storage $ = _getRewardsStorage();\n        $.descriptor = descriptor_;\n    }\n\n    /**\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     *   INTERNAL\n     * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n     */\n\n    function sumAuctions(INounsAuctionHouseV2.Settlement[] memory s) internal pure returns (uint256 sum) {\n        for (uint256 i = 0; i < s.length; ++i) {\n            sum += s[i].amount;\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev returns true if ids is an array of increasing unique values, i.e. sorted ascending and no duplicates\n     */\n    function isSortedAndNoDuplicates(uint32[] memory ids) internal pure returns (bool) {\n        uint256 len = ids.length;\n        uint32 prevValue = ids[0];\n        for (uint256 i = 1; i < len; ++i) {\n            uint32 nextValue = ids[i];\n            if (nextValue <= prevValue) return false;\n            prevValue = nextValue;\n        }\n        return true;\n    }\n\n    /**\n     * Only `owner` can perform an upgrade\n     */\n    function _authorizeUpgrade(address) internal view override onlyOwner {}\n}"
    },
    {
      "filename": "nouns-monorepo/packages/nouns-contracts/contracts/governance/NounsDAOProposals.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title Library for Nouns DAO Logic containing the proposal lifecycle code\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport './NounsDAOInterfaces.sol';\nimport { NounsDAODynamicQuorum } from './NounsDAODynamicQuorum.sol';\nimport { NounsDAOFork } from './fork/NounsDAOFork.sol';\nimport { SignatureChecker } from '../external/openzeppelin/SignatureChecker.sol';\nimport { ECDSA } from '../external/openzeppelin/ECDSA.sol';\nimport { SafeCast } from '@openzeppelin/contracts/utils/math/SafeCast.sol';\n\nlibrary NounsDAOProposals {\n    using NounsDAODynamicQuorum for NounsDAOTypes.Storage;\n    using NounsDAOFork for NounsDAOTypes.Storage;\n\n    error CantCancelProposalAtFinalState();\n    error ProposalInfoArityMismatch();\n    error MustProvideActions();\n    error TooManyActions();\n    error ProposerAlreadyHasALiveProposal();\n    error InvalidSignature();\n    error SignatureExpired();\n    error CanOnlyEditUpdatableProposals();\n    error OnlyProposerCanEdit();\n    error SignerCountMismtach();\n    error ProposerCannotUpdateProposalWithSigners();\n    error MustProvideSignatures();\n    error SignatureIsCancelled();\n    error CannotExecuteDuringForkingPeriod();\n    error VetoerBurned();\n    error VetoerOnly();\n    error CantVetoExecutedProposal();\n    error VotesBelowProposalThreshold();\n\n    // Created to solve stack-too-deep errors\n    struct ProposalTxs {\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n    }\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant PROPOSAL_MAX_OPERATIONS = 10; // 10 actions\n\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    bytes32 public constant PROPOSAL_TYPEHASH =\n        keccak256(\n            'Proposal(address proposer,address[] targets,uint256[] values,string[] signatures,bytes[] calldatas,string description,uint256 expiry)'\n        );\n\n    bytes32 public constant UPDATE_PROPOSAL_TYPEHASH =\n        keccak256(\n            'UpdateProposal(uint256 proposalId,address proposer,address[] targets,uint256[] values,string[] signatures,bytes[] calldatas,string description,uint256 expiry)'\n        );\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param txs Target addresses, eth values, function signatures and calldatas for proposal calls\n     * @param description String description of the proposal\n     * @param clientId The ID of the client that faciliated posting the proposal onchain\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        NounsDAOTypes.Storage storage ds,\n        ProposalTxs memory txs,\n        string memory description,\n        uint32 clientId\n    ) internal returns (uint256) {\n        uint256 adjustedTotalSupply = ds.adjustedTotalSupply();\n        uint256 proposalThreshold_ = checkPropThreshold(\n            ds,\n            ds.nouns.getPriorVotes(msg.sender, block.number - 1),\n            adjustedTotalSupply\n        );\n        checkProposalTxs(txs);\n        checkNoActiveProp(ds, msg.sender);\n\n        ds.proposalCount = ds.proposalCount + 1;\n        uint32 proposalId = SafeCast.toUint32(ds.proposalCount);\n        NounsDAOTypes.Proposal storage newProposal = createNewProposal(\n            ds,\n            proposalId,\n            proposalThreshold_,\n            adjustedTotalSupply,\n            txs,\n            clientId\n        );\n        ds.latestProposalIds[msg.sender] = proposalId;\n\n        emitNewPropEvents(\n            newProposal,\n            new address[](0),\n            ds.minQuorumVotes(adjustedTotalSupply),\n            txs,\n            description,\n            clientId\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold.\n     * This proposal would be executed via th"
    }
  ]
}