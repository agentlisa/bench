{
  "Title": "[M-12] Approved address can approve other addresses for an owner's safe",
  "Content": "\nAn owner of a safe can give permissions/approval of their safe to another address (let's say address B) through the [allowSafe() function](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L105) in the ODSafeManager.sol contract. But this other address (address B) also gets the power to approve other addresses for the owner's safe. This is a permissioning problem in the `allowSafe()` function (specifically the `safeAllowed()` modifier) which creates a security risk for the owner's safe.\n\n### Proof of Concept\n\nHere is the whole process:\n\n<https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L105C1-L109C4>\n\n1.  Owner of the safe gives permission/approval to `address _usr` (address 0x01 for example purposes) for `uint256 _safe` through the `allowSafe()` function.\n\n*   On Line 107, `safeCan[_owner][_safe][_usr] = _ok;` is set to any value other than 0 to represent approval.\n\n```solidity\nFile: ODSafeManager.sol\n105:   function allowSAFE(uint256 _safe, address _usr, uint256 _ok) external safeAllowed(_safe) {\n106:     address _owner = _safeData[_safe].owner;\n107:     safeCan[_owner][_safe][_usr] = _ok;\n108:     emit AllowSAFE(msg.sender, _safe, _usr, _ok);\n109:   }\n```\n\n2.  The previously set `address _usr` (address 0x01) can now call the `allowSafe()` function with parameters `uint256 _safe` which will be the owner's safe and another `address _usr` (address 0x02), which will give address 0x02 permissions/approval for the owner's safe.\n\n3.  This issue arises because of how the checks are evaluated in the [safeAllowed() modifier](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L49C1-L53C4). Here is what happens:\n\n*   On Line 50, the owner of the safe is extracted.\n*   On Line 51, there are two conditions present that are separated by the && operator.\n*   On Line 51, the first check evaluates to true, since the msg.sender (address 0x01) is not the owner of the safe\n*   On Line 51, the second check evaluates to false, since the msg.sender (address 0x01) was previously approved by the owner in step 1 above.\n*   Since true && false = false, we do not revert and this gives address 0x02 permissions to the owner's safe in the `allowSafe()` function.\n\n```solidity\nFile: ODSafeManager.sol\n49:   modifier safeAllowed(uint256 _safe) {\n50:     address _owner = _safeData[_safe].owner;\n51:     if (msg.sender != _owner && safeCan[_owner][_safe][msg.sender] == 0) revert SafeNotAllowed();\n52:     _;\n53:   } \n```\n\n### Recommended Mitigation Steps\n\nConsider implementing a separate modifier for the `allowSafe()` function that only checks if the msg.sender is the owner. If true, then allow execution but if not then revert.\n\nSolution:\n\n```solidity\nFile: ODSafeManager.sol\nmodifier onlySafeOwner(uint256 _safe) {\n    address _owner = _safeData[_safe].owner;\n    if (msg.sender != _owner) revert SafeNotAllowed();\n    _;\n}\n```\n\n**[pi0neerpat (OpenDollar) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/171#issuecomment-1783564235):**\n > Medium vulnerability recommended. Safe access is still limited, requiring user confirmation. The design could be improved, as described here, to remove the unexpected behavior of allowing additional approvals beyond the initial recipient.\n\n**[MiloTruck (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/171#issuecomment-1790107095):**\n > The warden has demonstrated how incorrect use of the `safeAllowed()` modifier on the `allowSAFE()` function allows permissioned addresses that are not the safe owner to give permissions to other addresses, which is not intended.\n> \n> As this finding is contingent on the owner granting permissions to an address that becomes malicious, I believe medium severity is appropriate.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/proxies/ODSafeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {SAFEHandler} from '@contracts/proxies/SAFEHandler.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ILiquidationEngine} from '@interfaces/ILiquidationEngine.sol';\nimport {IVault721} from '@interfaces/proxies/IVault721.sol';\n\nimport {Math} from '@libraries/Math.sol';\nimport {EnumerableSet} from '@openzeppelin/utils/structs/EnumerableSet.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\n\n/**\n * @title  ODSafeManager\n * @notice This contract acts as interface to the SAFEEngine, facilitating the management of SAFEs\n * @dev    This contract is meant to be used by users that interact with the protocol through a proxy contract\n */\ncontract ODSafeManager is IODSafeManager {\n  using Math for uint256;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using Assertions for address;\n\n  /// @inheritdoc IODSafeManager\n  address public safeEngine;\n\n  // --- ERC721 ---\n  IVault721 public vault721;\n\n  uint256 internal _safeId; // Auto incremental\n  mapping(address _safeOwner => EnumerableSet.UintSet) private _usrSafes;\n  /// @notice Mapping of user addresses to their enumerable set of safes per collateral type\n  mapping(address _safeOwner => mapping(bytes32 _cType => EnumerableSet.UintSet)) private _usrSafesPerCollat;\n  /// @notice Mapping of safe ids to their data\n  mapping(uint256 _safeId => SAFEData) internal _safeData;\n\n  /// @inheritdoc IODSafeManager\n  mapping(address _owner => mapping(uint256 _safeId => mapping(address _caller => uint256 _ok))) public safeCan;\n  /// @inheritdoc IODSafeManager\n  mapping(address _safeHandler => mapping(address _caller => uint256 _ok)) public handlerCan;\n\n  // --- Modifiers ---\n\n  /**\n   * @notice Checks if the sender is the owner of the safe or the safe has permissions to call the function\n   * @param  _safe Id of the safe to check if msg.sender has permissions for\n   */\n  modifier safeAllowed(uint256 _safe) {\n    address _owner = _safeData[_safe].owner;\n    if (msg.sender != _owner && safeCan[_owner][_safe][msg.sender] == 0) revert SafeNotAllowed();\n    _;\n  }\n\n  /**\n   * @notice Checks if the sender is the safe handler has permissions to call the function\n   * @param  _handler Address of the handler to check if msg.sender has permissions for\n   */\n  modifier handlerAllowed(address _handler) {\n    if (msg.sender != _handler && handlerCan[_handler][msg.sender] == 0) revert HandlerNotAllowed();\n    _;\n  }\n\n  constructor(address _safeEngine, address _vault721) {\n    safeEngine = _safeEngine.assertNonNull();\n    vault721 = IVault721(_vault721);\n    vault721.initializeManager();\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafes[_usr].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr, bytes32 _cType) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafesPerCollat[_usr][_cType].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafesData(address _usr)\n    external\n    view\n    returns (uint256[] memory _safes, address[] memory _safeHandlers, bytes32[] memory _cTypes)\n  {\n    _safes = _usrSafes[_usr].values();\n    _safeHandlers = new address[](_safes.length);\n    _cTypes = new bytes32[](_safes.length);\n    for (uint256 _i; _i < _safes.length; _i++) {\n      _safeHandlers[_i] = _safeData[_safes[_i]].safeHandler;\n      _cTypes[_i] = _safeData[_safes[_i]].collateralType;\n    }\n  }\n\n  /// @inheritdoc IODSafeManager\n  function safeData(uint256 _safe) external view returns (SAFEData memory _sData) {\n    _sData = _safeData[_safe];\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IODSafeManager\n  function allowSAFE(uint256 _safe, address _usr, uint256 _ok) external safeAllowed(_safe) {\n    address _owner = _safeData[_safe].owner;\n    safeCan[_owner][_safe][_usr] = _ok;\n    emit AllowSAFE(msg.sender, _safe, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function allowHandler(address _usr, uint256 _ok) external {\n    handlerCan[msg.sender][_usr] = _ok;\n    emit AllowHandler(msg.sender, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function openSAFE(bytes32 _cType, address _usr) external returns (uint256 _id) {\n    if (_usr == address(0)) revert ZeroAddress();\n\n    ++_safeId;\n    address _safeHandler = address(new SAFEHandler(safeEngine));\n\n    _safeData[_safeId] = SAFEData({owner: _usr, safeHandler: _safeHandler, collateralType: _cType});\n\n    _usrSafes[_usr].add(_safeId);\n    _usrSafesPerCollat[_usr][_cType].add(_safeId);\n\n    vault721.mint(_usr, _safeId);\n\n    emit OpenSAFE(msg.sender, _usr, _safeId);\n    return _safeId;\n  }\n\n  // Give the safe ownership to a dst address.\n  function transferSAFEOwnership(uint256 _safe, address _dst) external {\n    require(msg.sender == address(vault721), 'SafeMngr: Only Vault721');\n\n    if (_dst == address(0)) revert ZeroAddress();\n    SAFEData memory _sData = _safeData[_safe];\n    if (_dst == _sData.owner) revert AlreadySafeOwner();\n\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n\n    _usrSafes[_dst].add(_safe);\n    _usrSafesPerCollat[_dst][_sData.collateralType].add(_safe);\n\n    _safeData[_safe].owner = _dst;\n\n    emit TransferSAFEOwnership(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function modifySAFECollateralization(\n    uint256 _safe,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).modifySAFECollateralization(\n      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_sData.collateralType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(bytes32 _cType, uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_cType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _cType, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferInternalCoins(uint256 _safe, address _dst, uint256 _rad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferInternalCoins(_sData.safeHandler, _dst, _rad);\n    emit TransferInternalCoins(msg.sender, _safe, _dst, _rad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function quitSystem(uint256 _safe, address _dst) external safeAllowed(_safe) handlerAllowed(_dst) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _sData.safeHandler, _dst, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n    emit QuitSystem(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function enterSystem(address _src, uint256 _safe) external handlerAllowed(_src) safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _src, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit EnterSystem(msg.sender, _src, _safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function moveSAFE(uint256 _safeSrc, uint256 _safeDst) external safeAllowed(_safeSrc) safeAllowed(_safeDst) {\n    SAFEData memory _srcData = _safeData[_safeSrc];\n    SAFEData memory _dstData = _safeData[_safeDst];\n    if (_srcData.collateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcData.collateralType, _srcData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _srcData.collateralType, _srcData.safeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_srcData.owner].remove(_safeSrc);\n    _usrSafesPerCollat[_srcData.owner][_srcData.collateralType].remove(_safeSrc);\n    emit MoveSAFE(msg.sender, _safeSrc, _safeDst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function addSAFE(uint256 _safe) external {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[msg.sender].add(_safe);\n    _usrSafesPerCollat[msg.sender][_sData.collateralType].add(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function removeSAFE(uint256 _safe) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function protectSAFE(uint256 _safe, address _liquidationEngine, address _saviour) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ILiquidationEngine(_liquidationEngine).protectSAFE(_sData.collateralType, _sData.safeHandler, _saviour);\n    emit ProtectSAFE(msg.sender, _safe, _liquidationEngine, _saviour);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/ODSafeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {SAFEHandler} from '@contracts/proxies/SAFEHandler.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ILiquidationEngine} from '@interfaces/ILiquidationEngine.sol';\nimport {IVault721} from '@interfaces/proxies/IVault721.sol';\n\nimport {Math} from '@libraries/Math.sol';\nimport {EnumerableSet} from '@openzeppelin/utils/structs/EnumerableSet.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\n\n/**\n * @title  ODSafeManager\n * @notice This contract acts as interface to the SAFEEngine, facilitating the management of SAFEs\n * @dev    This contract is meant to be used by users that interact with the protocol through a proxy contract\n */\ncontract ODSafeManager is IODSafeManager {\n  using Math for uint256;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using Assertions for address;\n\n  /// @inheritdoc IODSafeManager\n  address public safeEngine;\n\n  // --- ERC721 ---\n  IVault721 public vault721;\n\n  uint256 internal _safeId; // Auto incremental\n  mapping(address _safeOwner => EnumerableSet.UintSet) private _usrSafes;\n  /// @notice Mapping of user addresses to their enumerable set of safes per collateral type\n  mapping(address _safeOwner => mapping(bytes32 _cType => EnumerableSet.UintSet)) private _usrSafesPerCollat;\n  /// @notice Mapping of safe ids to their data\n  mapping(uint256 _safeId => SAFEData) internal _safeData;\n\n  /// @inheritdoc IODSafeManager\n  mapping(address _owner => mapping(uint256 _safeId => mapping(address _caller => uint256 _ok))) public safeCan;\n  /// @inheritdoc IODSafeManager\n  mapping(address _safeHandler => mapping(address _caller => uint256 _ok)) public handlerCan;\n\n  // --- Modifiers ---\n\n  /**\n   * @notice Checks if the sender is the owner of the safe or the safe has permissions to call the function\n   * @param  _safe Id of the safe to check if msg.sender has permissions for\n   */\n  modifier safeAllowed(uint256 _safe) {\n    address _owner = _safeData[_safe].owner;\n    if (msg.sender != _owner && safeCan[_owner][_safe][msg.sender] == 0) revert SafeNotAllowed();\n    _;\n  }\n\n  /**\n   * @notice Checks if the sender is the safe handler has permissions to call the function\n   * @param  _handler Address of the handler to check if msg.sender has permissions for\n   */\n  modifier handlerAllowed(address _handler) {\n    if (msg.sender != _handler && handlerCan[_handler][msg.sender] == 0) revert HandlerNotAllowed();\n    _;\n  }\n\n  constructor(address _safeEngine, address _vault721) {\n    safeEngine = _safeEngine.assertNonNull();\n    vault721 = IVault721(_vault721);\n    vault721.initializeManager();\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafes[_usr].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr, bytes32 _cType) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafesPerCollat[_usr][_cType].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafesData(address _usr)\n    external\n    view\n    returns (uint256[] memory _safes, address[] memory _safeHandlers, bytes32[] memory _cTypes)\n  {\n    _safes = _usrSafes[_usr].values();\n    _safeHandlers = new address[](_safes.length);\n    _cTypes = new bytes32[](_safes.length);\n    for (uint256 _i; _i < _safes.length; _i++) {\n      _safeHandlers[_i] = _safeData[_safes[_i]].safeHandler;\n      _cTypes[_i] = _safeData[_safes[_i]].collateralType;\n    }\n  }\n\n  /// @inheritdoc IODSafeManager\n  function safeData(uint256 _safe) external view returns (SAFEData memory _sData) {\n    _sData = _safeData[_safe];\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IODSafeManager\n  function allowSAFE(uint256 _safe, address _usr, uint256 _ok) external safeAllowed(_safe) {\n    address _owner = _safeData[_safe].owner;\n    safeCan[_owner][_safe][_usr] = _ok;\n    emit AllowSAFE(msg.sender, _safe, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function allowHandler(address _usr, uint256 _ok) external {\n    handlerCan[msg.sender][_usr] = _ok;\n    emit AllowHandler(msg.sender, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function openSAFE(bytes32 _cType, address _usr) external returns (uint256 _id) {\n    if (_usr == address(0)) revert ZeroAddress();\n\n    ++_safeId;\n    address _safeHandler = address(new SAFEHandler(safeEngine));\n\n    _safeData[_safeId] = SAFEData({owner: _usr, safeHandler: _safeHandler, collateralType: _cType});\n\n    _usrSafes[_usr].add(_safeId);\n    _usrSafesPerCollat[_usr][_cType].add(_safeId);\n\n    vault721.mint(_usr, _safeId);\n\n    emit OpenSAFE(msg.sender, _usr, _safeId);\n    return _safeId;\n  }\n\n  // Give the safe ownership to a dst address.\n  function transferSAFEOwnership(uint256 _safe, address _dst) external {\n    require(msg.sender == address(vault721), 'SafeMngr: Only Vault721');\n\n    if (_dst == address(0)) revert ZeroAddress();\n    SAFEData memory _sData = _safeData[_safe];\n    if (_dst == _sData.owner) revert AlreadySafeOwner();\n\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n\n    _usrSafes[_dst].add(_safe);\n    _usrSafesPerCollat[_dst][_sData.collateralType].add(_safe);\n\n    _safeData[_safe].owner = _dst;\n\n    emit TransferSAFEOwnership(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function modifySAFECollateralization(\n    uint256 _safe,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).modifySAFECollateralization(\n      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_sData.collateralType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(bytes32 _cType, uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_cType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _cType, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferInternalCoins(uint256 _safe, address _dst, uint256 _rad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferInternalCoins(_sData.safeHandler, _dst, _rad);\n    emit TransferInternalCoins(msg.sender, _safe, _dst, _rad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function quitSystem(uint256 _safe, address _dst) external safeAllowed(_safe) handlerAllowed(_dst) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _sData.safeHandler, _dst, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n    emit QuitSystem(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function enterSystem(address _src, uint256 _safe) external handlerAllowed(_src) safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _src, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit EnterSystem(msg.sender, _src, _safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function moveSAFE(uint256 _safeSrc, uint256 _safeDst) external safeAllowed(_safeSrc) safeAllowed(_safeDst) {\n    SAFEData memory _srcData = _safeData[_safeSrc];\n    SAFEData memory _dstData = _safeData[_safeDst];\n    if (_srcData.collateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcData.collateralType, _srcData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _srcData.collateralType, _srcData.safeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_srcData.owner].remove(_safeSrc);\n    _usrSafesPerCollat[_srcData.owner][_srcData.collateralType].remove(_safeSrc);\n    emit MoveSAFE(msg.sender, _safeSrc, _safeDst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function addSAFE(uint256 _safe) external {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[msg.sender].add(_safe);\n    _usrSafesPerCollat[msg.sender][_sData.collateralType].add(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function removeSAFE(uint256 _safe) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function protectSAFE(uint256 _safe, address _liquidationEngine, address _saviour) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ILiquidationEngine(_liquidationEngine).protectSAFE(_sData.collateralType, _sData.safeHandler, _saviour);\n    emit ProtectSAFE(msg.sender, _safe, _liquidationEngine, _saviour);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/ODSafeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {SAFEHandler} from '@contracts/proxies/SAFEHandler.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ILiquidationEngine} from '@interfaces/ILiquidationEngine.sol';\nimport {IVault721} from '@interfaces/proxies/IVault721.sol';\n\nimport {Math} from '@libraries/Math.sol';\nimport {EnumerableSet} from '@openzeppelin/utils/structs/EnumerableSet.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\n\n/**\n * @title  ODSafeManager\n * @notice This contract acts as interface to the SAFEEngine, facilitating the management of SAFEs\n * @dev    This contract is meant to be used by users that interact with the protocol through a proxy contract\n */\ncontract ODSafeManager is IODSafeManager {\n  using Math for uint256;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using Assertions for address;\n\n  /// @inheritdoc IODSafeManager\n  address public safeEngine;\n\n  // --- ERC721 ---\n  IVault721 public vault721;\n\n  uint256 internal _safeId; // Auto incremental\n  mapping(address _safeOwner => EnumerableSet.UintSet) private _usrSafes;\n  /// @notice Mapping of user addresses to their enumerable set of safes per collateral type\n  mapping(address _safeOwner => mapping(bytes32 _cType => EnumerableSet.UintSet)) private _usrSafesPerCollat;\n  /// @notice Mapping of safe ids to their data\n  mapping(uint256 _safeId => SAFEData) internal _safeData;\n\n  /// @inheritdoc IODSafeManager\n  mapping(address _owner => mapping(uint256 _safeId => mapping(address _caller => uint256 _ok))) public safeCan;\n  /// @inheritdoc IODSafeManager\n  mapping(address _safeHandler => mapping(address _caller => uint256 _ok)) public handlerCan;\n\n  // --- Modifiers ---\n\n  /**\n   * @notice Checks if the sender is the owner of the safe or the safe has permissions to call the function\n   * @param  _safe Id of the safe to check if msg.sender has permissions for\n   */\n  modifier safeAllowed(uint256 _safe) {\n    address _owner = _safeData[_safe].owner;\n    if (msg.sender != _owner && safeCan[_owner][_safe][msg.sender] == 0) revert SafeNotAllowed();\n    _;\n  }\n\n  /**\n   * @notice Checks if the sender is the safe handler has permissions to call the function\n   * @param  _handler Address of the handler to check if msg.sender has permissions for\n   */\n  modifier handlerAllowed(address _handler) {\n    if (msg.sender != _handler && handlerCan[_handler][msg.sender] == 0) revert HandlerNotAllowed();\n    _;\n  }\n\n  constructor(address _safeEngine, address _vault721) {\n    safeEngine = _safeEngine.assertNonNull();\n    vault721 = IVault721(_vault721);\n    vault721.initializeManager();\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafes[_usr].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr, bytes32 _cType) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafesPerCollat[_usr][_cType].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafesData(address _usr)\n    external\n    view\n    returns (uint256[] memory _safes, address[] memory _safeHandlers, bytes32[] memory _cTypes)\n  {\n    _safes = _usrSafes[_usr].values();\n    _safeHandlers = new address[](_safes.length);\n    _cTypes = new bytes32[](_safes.length);\n    for (uint256 _i; _i < _safes.length; _i++) {\n      _safeHandlers[_i] = _safeData[_safes[_i]].safeHandler;\n      _cTypes[_i] = _safeData[_safes[_i]].collateralType;\n    }\n  }\n\n  /// @inheritdoc IODSafeManager\n  function safeData(uint256 _safe) external view returns (SAFEData memory _sData) {\n    _sData = _safeData[_safe];\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IODSafeManager\n  function allowSAFE(uint256 _safe, address _usr, uint256 _ok) external safeAllowed(_safe) {\n    address _owner = _safeData[_safe].owner;\n    safeCan[_owner][_safe][_usr] = _ok;\n    emit AllowSAFE(msg.sender, _safe, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function allowHandler(address _usr, uint256 _ok) external {\n    handlerCan[msg.sender][_usr] = _ok;\n    emit AllowHandler(msg.sender, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function openSAFE(bytes32 _cType, address _usr) external returns (uint256 _id) {\n    if (_usr == address(0)) revert ZeroAddress();\n\n    ++_safeId;\n    address _safeHandler = address(new SAFEHandler(safeEngine));\n\n    _safeData[_safeId] = SAFEData({owner: _usr, safeHandler: _safeHandler, collateralType: _cType});\n\n    _usrSafes[_usr].add(_safeId);\n    _usrSafesPerCollat[_usr][_cType].add(_safeId);\n\n    vault721.mint(_usr, _safeId);\n\n    emit OpenSAFE(msg.sender, _usr, _safeId);\n    return _safeId;\n  }\n\n  // Give the safe ownership to a dst address.\n  function transferSAFEOwnership(uint256 _safe, address _dst) external {\n    require(msg.sender == address(vault721), 'SafeMngr: Only Vault721');\n\n    if (_dst == address(0)) revert ZeroAddress();\n    SAFEData memory _sData = _safeData[_safe];\n    if (_dst == _sData.owner) revert AlreadySafeOwner();\n\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n\n    _usrSafes[_dst].add(_safe);\n    _usrSafesPerCollat[_dst][_sData.collateralType].add(_safe);\n\n    _safeData[_safe].owner = _dst;\n\n    emit TransferSAFEOwnership(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function modifySAFECollateralization(\n    uint256 _safe,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).modifySAFECollateralization(\n      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_sData.collateralType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(bytes32 _cType, uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_cType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _cType, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferInternalCoins(uint256 _safe, address _dst, uint256 _rad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferInternalCoins(_sData.safeHandler, _dst, _rad);\n    emit TransferInternalCoins(msg.sender, _safe, _dst, _rad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function quitSystem(uint256 _safe, address _dst) external safeAllowed(_safe) handlerAllowed(_dst) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _sData.safeHandler, _dst, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n    emit QuitSystem(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function enterSystem(address _src, uint256 _safe) external handlerAllowed(_src) safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _src, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit EnterSystem(msg.sender, _src, _safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function moveSAFE(uint256 _safeSrc, uint256 _safeDst) external safeAllowed(_safeSrc) safeAllowed(_safeDst) {\n    SAFEData memory _srcData = _safeData[_safeSrc];\n    SAFEData memory _dstData = _safeData[_safeDst];\n    if (_srcData.collateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcData.collateralType, _srcData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _srcData.collateralType, _srcData.safeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_srcData.owner].remove(_safeSrc);\n    _usrSafesPerCollat[_srcData.owner][_srcData.collateralType].remove(_safeSrc);\n    emit MoveSAFE(msg.sender, _safeSrc, _safeDst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function addSAFE(uint256 _safe) external {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[msg.sender].add(_safe);\n    _usrSafesPerCollat[msg.sender][_sData.collateralType].add(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function removeSAFE(uint256 _safe) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function protectSAFE(uint256 _safe, address _liquidationEngine, address _saviour) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ILiquidationEngine(_liquidationEngine).protectSAFE(_sData.collateralType, _sData.safeHandler, _saviour);\n    emit ProtectSAFE(msg.sender, _safe, _liquidationEngine, _saviour);\n  }\n}"
    }
  ]
}