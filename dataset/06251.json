{
  "Title": "[H-53] Potential 99.5% loss in `emergencyWithdraw()` of two Yieldbox strategies",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/lido/LidoEthStrategy.sol#L108> \n\n<https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/convex/ConvexTricryptoStrategy.sol#L154>\n\n99.5% of user funds are lost to slippage in two Yieldbox strategies in case of [`emergencyWithdraw()`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/convex/ConvexTricryptoStrategy.sol#L148-L156)\n\n### Description\n\nSlippage is incorrectly calculated where `minAmount` is intended to be 99.5%, however it's calculated to be only 0.5%, making the other 99.5% sandwichable. The usual correct `minAmount` slippage calculation in other Yieldbox strategy contracts is\\\n`uint256 minAmount = calcAmount - (calcAmount * 50) / 10_000;`\n\n### Calculation logic\n\nIn [`ConvexTriCryptoStrategy`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/convex/ConvexTricryptoStrategy.sol#L154) and [`LidoEthStrategy`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/lido/LidoEthStrategy.sol#L108) - [`emergencyWithdraw()`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/convex/ConvexTricryptoStrategy.sol#L148-L156) allows the owner to withdraw all funds from the external pools. the amount withdrawn from the corresponding pool is calculated to be: [`uint256 minAmount = (calcWithdraw * 50) / 10_000;`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/convex/ConvexTricryptoStrategy.sol#L154). This is incorrect and only 0.5% of the withdrawal.\n\nLet's calculate with `calcWithdraw = 1000` as the amount to withdrawn from the pool.\n`uint256 incorrectMinAmount = (1000 * 50) / 10_000 = 5`\n\nThe correct calculation would look like this:\n`uint256 correctMinAmount = calcWithdraw - (calcWithdraw * 50) / 10_000` aka\n`uint256 correctMinAmount = 1000 - (1000 * 50) / 10_000 = 995`\n\n### Withdrawal logic\n\n[`emergencyWithdraw()`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/convex/ConvexTricryptoStrategy.sol#L148-L156) of Yieldbox Strategy contracts is meant to remove all liquidity from the corresponding strategy contract's liquidity pool.\n\nIn the case of [`LidoStrategy`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/lido/LidoEthStrategy.sol) the actual withdraw is [`curveStEthPool.exchange(1, 0, toWithdraw, minAmount)`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/lido/LidoEthStrategy.sol#L109) which directly withdraws from the Curve StEth pool.\n\nIn the case of [`ConvexTriCryptoStrategy`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/convex/ConvexTricryptoStrategy.sol) it's [`lpGetter.removeLiquidityWeth(lpBalance, minAmount)`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/convex/ConvexTricryptoStrategy.sol#L155) and lpGetter withdraws from the Curve Tri Crypto (USDT/WBTC/WETH) pool via [`removeLiquidityWeth()`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/curve/TricryptoLPGetter.sol#L142-L147) -> [`_removeLiquidity()`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/curve/TricryptoLPGetter.sol#L234-L257) -> [`liquidityPool.remove_liquidity_one_coin(_amount, _index, _min)`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/curve/TricryptoLPGetter.sol#L246).\n\nThese transactions are vulnerable to front-running and [sandwich attacks](https://medium.com/coinmonks/defi-sandwich-attack-explain-776f6f43b2fd) so the amount withdrawn is only guaranteed to withdraw the `minAmount` aka 0.5% from the pool which makes the other 99.5% user funds likely to be lost.\n\n### Recommended Mitigation Steps\n\nFix the incorrect `minAmount` calculation to be `uint256 minAmount = calcAmount - (calcAmount * 50) / 10_000;` in [ConvexTriCryptoStrategy](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/convex/ConvexTricryptoStrategy.sol#L154) and [LidoEthStrategy](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/lido/LidoEthStrategy.sol#L108).\n\n**[0xRektora (Tapioca) confirmed via duplicate issue 408](https://github.com/code-423n4/2023-07-tapioca-findings/issues/408)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/lido/LidoEthStrategy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/strategies/BaseStrategy.sol\";\n\nimport \"./interfaces/IStEth.sol\";\nimport \"./interfaces/ICurveEthStEthPool.sol\";\nimport \"../../tapioca-periph/contracts/interfaces/INative.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\n//TODO: update withdrawal and currentBalance after Lido allows withdrawals\ncontract LidoEthStrategy is BaseERC20Strategy, BoringOwnable, ReentrancyGuard {\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    IERC20 public immutable wrappedNative;\n    IStEth public immutable stEth;\n    ICurveEthStEthPool public curveStEthPool;\n\n    /// @notice Queues tokens up to depositThreshold\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to AAVE is performed\n    uint256 public depositThreshold;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    event DepositThreshold(uint256 _old, uint256 _new);\n    event AmountQueued(uint256 amount);\n    event AmountDeposited(uint256 amount);\n    event AmountWithdrawn(address indexed to, uint256 amount);\n\n    constructor(\n        IYieldBox _yieldBox,\n        address _token,\n        address _stEth,\n        address _curvePool\n    ) BaseERC20Strategy(_yieldBox, _token) {\n        wrappedNative = IERC20(_token);\n        stEth = IStEth(_stEth);\n        curveStEthPool = ICurveEthStEthPool(_curvePool);\n\n        IERC20(_stEth).approve(_curvePool, type(uint256).max);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice Returns the name of this strategy\n    function name() external pure override returns (string memory name_) {\n        return \"Lido-ETH\";\n    }\n\n    /// @notice Returns the description of this strategy\n    function description()\n        external\n        pure\n        override\n        returns (string memory description_)\n    {\n        return \"Lido-ETH strategy for wrapped native assets\";\n    }\n\n    /// @notice returns compounded amounts in wrappedNative\n    function compoundAmount() public pure returns (uint256 result) {\n        return 0;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Sets the deposit threshold\n    /// @param amount The new threshold amount\n    function setDepositThreshold(uint256 amount) external onlyOwner {\n        emit DepositThreshold(depositThreshold, amount);\n        depositThreshold = amount;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    function compound(bytes memory) public {}\n\n    /// @notice withdraws everythig from the strategy\n    function emergencyWithdraw() external onlyOwner returns (uint256 result) {\n        compound(\"\");\n\n        uint256 toWithdraw = stEth.balanceOf(address(this));\n        uint256 minAmount = (toWithdraw * 50) / 10_000; //0.5%\n        result = curveStEthPool.exchange(1, 0, toWithdraw, minAmount);\n\n        INative(address(wrappedNative)).deposit{value: result}();\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    /// @dev queries Lido and Curve Eth/STEth pools\n    function _currentBalance() internal view override returns (uint256 amount) {\n        uint256 stEthBalance = stEth.balanceOf(address(this));\n        uint256 calcEth = stEthBalance > 0\n            ? curveStEthPool.get_dy(1, 0, stEthBalance)\n            : 0;\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        return calcEth + queued;\n    }\n\n    /// @dev deposits to Lido or queues tokens if the 'depositThreshold' has not been met yet\n    function _deposited(uint256 amount) internal override nonReentrant {\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (queued > depositThreshold) {\n            require(!stEth.isStakingPaused(), \"LidoStrategy: staking paused\");\n            INative(address(wrappedNative)).withdraw(queued);\n            stEth.submit{value: queued}(address(0)); //1:1 between eth<>stEth\n            emit AmountDeposited(queued);\n            return;\n        }\n        emit AmountQueued(amount);\n    }\n\n    /// @dev swaps StEth with Eth\n    function _withdraw(\n        address to,\n        uint256 amount\n    ) internal override nonReentrant {\n        uint256 available = _currentBalance();\n        require(available >= amount, \"LidoStrategy: amount not valid\");\n\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (amount > queued) {\n            uint256 toWithdraw = amount - queued; //1:1 between eth<>stEth\n            uint256 minAmount = toWithdraw - (toWithdraw * 250) / 10_000; //2.5%\n            uint256 obtainedEth = curveStEthPool.exchange(\n                1,\n                0,\n                toWithdraw,\n                minAmount\n            );\n\n            INative(address(wrappedNative)).deposit{value: obtainedEth}();\n        }\n        queued = wrappedNative.balanceOf(address(this));\n        require(queued >= amount, \"LidoStrategy: not enough\");\n\n        wrappedNative.safeTransfer(to, amount);\n\n        emit AmountWithdrawn(to, amount);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/convex/ConvexTricryptoStrategy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/strategies/BaseStrategy.sol\";\nimport \"../../tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport \"../curve/interfaces/ITricryptoLPGetter.sol\";\n\nimport \"./interfaces/IConvexBooster.sol\";\nimport \"./interfaces/IConvexRewardPool.sol\";\nimport \"./interfaces/IConvexZap.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\ncontract ConvexTricryptoStrategy is\n    BaseERC20Strategy,\n    BoringOwnable,\n    ReentrancyGuard\n{\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    IERC20 public immutable wrappedNative;\n    ISwapper public swapper;\n\n    ITricryptoLPGetter public lpGetter;\n    IConvexBooster public immutable booster;\n    IConvexRewardPool public immutable rewardPool;\n    IConvexZap public immutable zap;\n    uint256 public immutable pid;\n\n    IERC20 public immutable lpToken;\n    // IERC20 public immutable receiptToken;\n    IERC20 public immutable rewardToken;\n\n    /// @notice Queues tokens up to depositThreshold\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to AAVE is performed\n    uint256 public depositThreshold;\n\n    struct ClaimTempData {\n        address[] rewardContracts;\n        address[] extraRewardContracts;\n        address[] tokenRewardContracts;\n        address[] tokens;\n        address[] tokenRewardTokens;\n        bytes extras;\n    }\n    struct ClaimExtrasTempData {\n        uint256 depositCrvMaxAmount;\n        uint256 minAmountOut;\n        uint256 depositCvxMaxAmount;\n        uint256 spendCvxAmount;\n        uint256 options;\n    }\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    event MultiSwapper(address indexed _old, address indexed _new);\n    event DepositThreshold(uint256 _old, uint256 _new);\n    event LPGetterSet(address indexed _old, address indexed _new);\n    event AmountQueued(uint256 amount);\n    event AmountDeposited(uint256 amount);\n    event AmountWithdrawn(address indexed to, uint256 amount);\n\n    constructor(\n        IYieldBox _yieldBox,\n        address _token,\n        address _rewadPool,\n        address _booster,\n        address _zap,\n        address _lpGetter,\n        address _multiSwapper\n    ) BaseERC20Strategy(_yieldBox, _token) {\n        wrappedNative = IERC20(_token);\n        swapper = ISwapper(_multiSwapper);\n\n        zap = IConvexZap(_zap);\n        booster = IConvexBooster(_booster);\n        lpGetter = ITricryptoLPGetter(_lpGetter);\n        rewardPool = IConvexRewardPool(_rewadPool);\n        pid = rewardPool.pid();\n\n        lpToken = IERC20(booster.poolInfo(pid).lptoken);\n        rewardToken = IERC20(rewardPool.rewardToken());\n\n        wrappedNative.approve(_lpGetter, type(uint256).max);\n        lpToken.approve(_lpGetter, type(uint256).max);\n        lpToken.approve(_booster, type(uint256).max);\n        rewardToken.approve(_multiSwapper, type(uint256).max);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice Returns the name of this strategy\n    function name() external pure override returns (string memory name_) {\n        return \"Convex-Tricrypto\";\n    }\n\n    /// @notice Returns the description of this strategy\n    function description()\n        external\n        pure\n        override\n        returns (string memory description_)\n    {\n        return \"Convex-Tricrypto strategy for wrapped native assets\";\n    }\n\n    /// @notice returns compounded amounts in wrappedNative\n    function compoundAmount() public view returns (uint256 result) {\n        uint256 claimable = rewardPool.rewards(address(this));\n        result = 0;\n        if (claimable > 0) {\n            ISwapper.SwapData memory swapData = swapper.buildSwapData(\n                address(rewardToken),\n                address(wrappedNative),\n                claimable,\n                0,\n                false,\n                false\n            );\n            result = swapper.getOutputAmount(swapData, \"\");\n            result = result - (result * 50) / 10_000; //0.5%\n        }\n    }\n\n    /// @notice withdraws everythig from the strategy\n    function emergencyWithdraw() external onlyOwner returns (uint256 result) {\n        compound(\"\");\n\n        uint256 lpBalance = rewardPool.balanceOf(address(this));\n        rewardPool.withdrawAndUnwrap(lpBalance, false);\n        uint256 calcWithdraw = lpGetter.calcLpToWeth(lpBalance);\n        uint256 minAmount = (calcWithdraw * 50) / 10_000; //0.5%\n        result = lpGetter.removeLiquidityWeth(lpBalance, minAmount);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Sets the deposit threshold\n    /// @param amount The new threshold amount\n    function setDepositThreshold(uint256 amount) external onlyOwner {\n        emit DepositThreshold(depositThreshold, amount);\n        depositThreshold = amount;\n    }\n\n    /// @notice Sets the Swapper address\n    /// @param _swapper The new swapper address\n    function setMultiSwapper(address _swapper) external onlyOwner {\n        emit MultiSwapper(address(swapper), _swapper);\n        rewardToken.approve(address(swapper), 0);\n        swapper = ISwapper(_swapper);\n        rewardToken.approve(_swapper, type(uint256).max);\n    }\n\n    /// @notice Sets the Tricrypto LP Getter\n    /// @param _lpGetter the new address\n    function setTricryptoLPGetter(address _lpGetter) external onlyOwner {\n        emit LPGetterSet(address(lpGetter), _lpGetter);\n        wrappedNative.approve(address(lpGetter), 0);\n        lpGetter = ITricryptoLPGetter(_lpGetter);\n        wrappedNative.approve(_lpGetter, type(uint256).max);\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    function compound(bytes memory data) public {\n        if (data.length == 0) return;\n        (uint256[] memory rewards, address[] memory tokens) = _executeClaim(\n            data\n        );\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (rewards[i] > 0) {\n                _safeApprove(tokens[i], address(swapper), rewards[i]);\n                ISwapper.SwapData memory swapData = swapper.buildSwapData(\n                    tokens[i],\n                    address(wrappedNative),\n                    rewards[i],\n                    0,\n                    false,\n                    false\n                );\n                uint256 calcAmount = swapper.getOutputAmount(swapData, \"\");\n                uint256 minAmount = calcAmount - (calcAmount * 50) / 10_000; //0.5%\n                swapper.swap(swapData, minAmount, address(this), \"\");\n            }\n        }\n\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        _addLiquidityAndStake(queued);\n        emit AmountDeposited(queued);\n    }\n\n    function _executeClaim(\n        bytes memory data\n    ) private returns (uint256[] memory, address[] memory) {\n        ClaimTempData memory tempData;\n\n        (\n            tempData.rewardContracts,\n            tempData.extraRewardContracts,\n            tempData.tokenRewardContracts,\n            tempData.tokens,\n            tempData.tokenRewardTokens,\n            tempData.extras\n        ) = abi.decode(\n            data,\n            (address[], address[], address[], address[], address[], bytes)\n        );\n        ClaimExtrasTempData memory extrasTempData;\n        (\n            extrasTempData.depositCrvMaxAmount,\n            extrasTempData.minAmountOut,\n            extrasTempData.depositCvxMaxAmount,\n            extrasTempData.spendCvxAmount,\n            extrasTempData.options\n        ) = abi.decode(\n            tempData.extras,\n            (uint256, uint256, uint256, uint256, uint256)\n        );\n\n        require(\n            tempData.rewardContracts.length == tempData.tokens.length,\n            \"ConvexTricryptoStrategy: claim data not valid\"\n        );\n        require(\n            tempData.rewardContracts.length > 0,\n            \"ConvexTricryptoStrategy: nothing to claim for\"\n        );\n\n        uint256[] memory balancesBefore = new uint256[](tempData.tokens.length);\n        for (uint256 i = 0; i < tempData.tokens.length; i++) {\n            balancesBefore[i] = IERC20(tempData.tokens[i]).balanceOf(\n                address(this)\n            );\n        }\n\n        zap.claimRewards(\n            tempData.rewardContracts,\n            tempData.extraRewardContracts,\n            tempData.tokenRewardContracts,\n            tempData.tokenRewardTokens,\n            extrasTempData.depositCrvMaxAmount,\n            extrasTempData.minAmountOut,\n            extrasTempData.depositCvxMaxAmount,\n            extrasTempData.spendCvxAmount,\n            extrasTempData.options\n        );\n        uint256[] memory balancesAfter = new uint256[](tempData.tokens.length);\n        for (uint256 i = 0; i < tempData.tokens.length; i++) {\n            balancesAfter[i] = IERC20(tempData.tokens[i]).balanceOf(\n                address(this)\n            );\n        }\n\n        uint256[] memory finalBalances = new uint256[](tempData.tokens.length);\n        for (uint256 i = 0; i < tempData.tokens.length; i++) {\n            finalBalances[i] = balancesAfter[i] - balancesBefore[i];\n        }\n\n        return (finalBalances, tempData.tokens);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    /// @dev queries total staked\n    function _currentBalance() internal view override returns (uint256 amount) {\n        uint256 lpBalance = rewardPool.balanceOf(address(this));\n        uint256 assetAmount = lpGetter.calcLpToWeth(lpBalance);\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        uint256 _compoundAmount = compoundAmount();\n        return assetAmount + queued + _compoundAmount;\n    }\n\n    /// @dev deposits to Curve Tricrypto to get the LP and stakes it into Convex\n    function _deposited(uint256 amount) internal override nonReentrant {\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (queued > depositThreshold) {\n            _addLiquidityAndStake(queued);\n            emit AmountDeposited(queued);\n            return;\n        }\n        emit AmountQueued(amount);\n    }\n\n    function _addLiquidityAndStake(uint256 amount) private {\n        uint256 calcAmount = lpGetter.calcWethToLp(amount);\n        if (calcAmount >= 1e18) {\n            uint256 minAmount = calcAmount - (calcAmount * 50) / 10_000; //0.5%\n            uint256 lpAmount = lpGetter.addLiquidityWeth(amount, minAmount);\n            booster.deposit(pid, lpAmount, true);\n        }\n    }\n\n    /// @dev unstakes from Convex and withdraws from Curve\n    function _withdraw(\n        address to,\n        uint256 amount\n    ) internal override nonReentrant {\n        uint256 available = _currentBalance();\n        require(\n            available >= amount,\n            \"ConvexTricryptoStrategy: amount not valid\"\n        );\n\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (amount > queued) {\n            compound(bytes(\"\"));\n            uint256 lpBalance = rewardPool.balanceOf(address(this));\n            rewardPool.withdrawAndUnwrap(lpBalance, false);\n            uint256 calcWithdraw = lpGetter.calcLpToWeth(lpBalance);\n            uint256 minAmount = calcWithdraw - (calcWithdraw * 50) / 10_000; //0.5%\n            lpGetter.removeLiquidityWeth(lpBalance, minAmount);\n        }\n\n        require(\n            wrappedNative.balanceOf(address(this)) >= amount,\n            \"ConvexTricryptoStrategy: not enough\"\n        );\n        wrappedNative.safeTransfer(to, amount);\n\n        queued = wrappedNative.balanceOf(address(this));\n        if (queued > depositThreshold) {\n            _addLiquidityAndStake(queued);\n            emit AmountDeposited(queued);\n        }\n        emit AmountWithdrawn(to, amount);\n    }\n\n    function _safeApprove(address token, address to, uint256 value) private {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool successEmtptyApproval, ) = token.call(\n            abi.encodeWithSelector(\n                bytes4(keccak256(\"approve(address,uint256)\")),\n                to,\n                0\n            )\n        );\n        require(\n            successEmtptyApproval,\n            \"OperationsLib::safeApprove: approval reset failed\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(\n                bytes4(keccak256(\"approve(address,uint256)\")),\n                to,\n                value\n            )\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"OperationsLib::safeApprove: approve failed\"\n        );\n    }\n}"
    },
    {
      "filename": "contracts/convex/ConvexTricryptoStrategy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/strategies/BaseStrategy.sol\";\nimport \"../../tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport \"../curve/interfaces/ITricryptoLPGetter.sol\";\n\nimport \"./interfaces/IConvexBooster.sol\";\nimport \"./interfaces/IConvexRewardPool.sol\";\nimport \"./interfaces/IConvexZap.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\ncontract ConvexTricryptoStrategy is\n    BaseERC20Strategy,\n    BoringOwnable,\n    ReentrancyGuard\n{\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    IERC20 public immutable wrappedNative;\n    ISwapper public swapper;\n\n    ITricryptoLPGetter public lpGetter;\n    IConvexBooster public immutable booster;\n    IConvexRewardPool public immutable rewardPool;\n    IConvexZap public immutable zap;\n    uint256 public immutable pid;\n\n    IERC20 public immutable lpToken;\n    // IERC20 public immutable receiptToken;\n    IERC20 public immutable rewardToken;\n\n    /// @notice Queues tokens up to depositThreshold\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to AAVE is performed\n    uint256 public depositThreshold;\n\n    struct ClaimTempData {\n        address[] rewardContracts;\n        address[] extraRewardContracts;\n        address[] tokenRewardContracts;\n        address[] tokens;\n        address[] tokenRewardTokens;\n        bytes extras;\n    }\n    struct ClaimExtrasTempData {\n        uint256 depositCrvMaxAmount;\n        uint256 minAmountOut;\n        uint256 depositCvxMaxAmount;\n        uint256 spendCvxAmount;\n        uint256 options;\n    }\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    event MultiSwapper(address indexed _old, address indexed _new);\n    event DepositThreshold(uint256 _old, uint256 _new);\n    event LPGetterSet(address indexed _old, address indexed _new);\n    event AmountQueued(uint256 amount);\n    event AmountDeposited(uint256 amount);\n    event AmountWithdrawn(address indexed to, uint256 amount);\n\n    constructor(\n        IYieldBox _yieldBox,\n        address _token,\n        address _rewadPool,\n        address _booster,\n        address _zap,\n        address _lpGetter,\n        address _multiSwapper\n    ) BaseERC20Strategy(_yieldBox, _token) {\n        wrappedNative = IERC20(_token);\n        swapper = ISwapper(_multiSwapper);\n\n        zap = IConvexZap(_zap);\n        booster = IConvexBooster(_booster);\n        lpGetter = ITricryptoLPGetter(_lpGetter);\n        rewardPool = IConvexRewardPool(_rewadPool);\n        pid = rewardPool.pid();\n\n        lpToken = IERC20(booster.poolInfo(pid).lptoken);\n        rewardToken = IERC20(rewardPool.rewardToken());\n\n        wrappedNative.approve(_lpGetter, type(uint256).max);\n        lpToken.approve(_lpGetter, type(uint256).max);\n        lpToken.approve(_booster, type(uint256).max);\n        rewardToken.approve(_multiSwapper, type(uint256).max);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice Returns the name of this strategy\n    function name() external pure override returns (string memory name_) {\n        return \"Convex-Tricrypto\";\n    }\n\n    /// @notice Returns the description of this strategy\n    function description()\n        external\n        pure\n        override\n        returns (string memory description_)\n    {\n        return \"Convex-Tricrypto strategy for wrapped native assets\";\n    }\n\n    /// @notice returns compounded amounts in wrappedNative\n    function compoundAmount() public view returns (uint256 result) {\n        uint256 claimable = rewardPool.rewards(address(this));\n        result = 0;\n        if (claimable > 0) {\n            ISwapper.SwapData memory swapData = swapper.buildSwapData(\n                address(rewardToken),\n                address(wrappedNative),\n                claimable,\n                0,\n                false,\n                false\n            );\n            result = swapper.getOutputAmount(swapData, \"\");\n            result = result - (result * 50) / 10_000; //0.5%\n        }\n    }\n\n    /// @notice withdraws everythig from the strategy\n    function emergencyWithdraw() external onlyOwner returns (uint256 result) {\n        compound(\"\");\n\n        uint256 lpBalance = rewardPool.balanceOf(address(this));\n        rewardPool.withdrawAndUnwrap(lpBalance, false);\n        uint256 calcWithdraw = lpGetter.calcLpToWeth(lpBalance);\n        uint256 minAmount = (calcWithdraw * 50) / 10_000; //0.5%\n        result = lpGetter.removeLiquidityWeth(lpBalance, minAmount);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Sets the deposit threshold\n    /// @param amount The new threshold amount\n    function setDepositThreshold(uint256 amount) external onlyOwner {\n        emit DepositThreshold(depositThreshold, amount);\n        depositThreshold = amount;\n    }\n\n    /// @notice Sets the Swapper address\n    /// @param _swapper The new swapper address\n    function setMultiSwapper(address _swapper) external onlyOwner {\n        emit MultiSwapper(address(swapper), _swapper);\n        rewardToken.approve(address(swapper), 0);\n        swapper = ISwapper(_swapper);\n        rewardToken.approve(_swapper, type(uint256).max);\n    }\n\n    /// @notice Sets the Tricrypto LP Getter\n    /// @param _lpGetter the new address\n    function setTricryptoLPGetter(address _lpGetter) external onlyOwner {\n        emit LPGetterSet(address(lpGetter), _lpGetter);\n        wrappedNative.approve(address(lpGetter), 0);\n        lpGetter = ITricryptoLPGetter(_lpGetter);\n        wrappedNative.approve(_lpGetter, type(uint256).max);\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    function compound(bytes memory data) public {\n        if (data.length == 0) return;\n        (uint256[] memory rewards, address[] memory tokens) = _executeClaim(\n            data\n        );\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (rewards[i] > 0) {\n                _safeApprove(tokens[i], address(swapper), rewards[i]);\n                ISwapper.SwapData memory swapData = swapper.buildSwapData(\n                    tokens[i],\n                    address(wrappedNative),\n                    rewards[i],\n                    0,\n                    false,\n                    false\n                );\n                uint256 calcAmount = swapper.getOutputAmount(swapData, \"\");\n                uint256 minAmount = calcAmount - (calcAmount * 50) / 10_000; //0.5%\n                swapper.swap(swapData, minAmount, address(this), \"\");\n            }\n        }\n\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        _addLiquidityAndStake(queued);\n        emit AmountDeposited(queued);\n    }\n\n    function _executeClaim(\n        bytes memory data\n    ) private returns (uint256[] memory, address[] memory) {\n        ClaimTempData memory tempData;\n\n        (\n            tempData.rewardContracts,\n            tempData.extraRewardContracts,\n            tempData.tokenRewardContracts,\n            tempData.tokens,\n            tempData.tokenRewardTokens,\n            tempData.extras\n        ) = abi.decode(\n            data,\n            (address[], address[], address[], address[], address[], bytes)\n        );\n        ClaimExtrasTempData memory extrasTempData;\n        (\n            extrasTempData.depositCrvMaxAmount,\n            extrasTempData.minAmountOut,\n            extrasTempData.depositCvxMaxAmount,\n            extrasTempData.spendCvxAmount,\n            extrasTempData.options\n        ) = abi.decode(\n            tempData.extras,\n            (uint256, uint256, uint256, uint256, uint256)\n        );\n\n        require(\n            tempData.rewardContracts.length == tempData.tokens.length,\n            \"ConvexTricryptoStrategy: claim data not valid\"\n        );\n        require(\n            tempData.rewardContracts.length > 0,\n            \"ConvexTricryptoStrategy: nothing to claim for\"\n        );\n\n        uint256[] memory balancesBefore = new uint256[](tempData.tokens.length);\n        for (uint256 i = 0; i < tempData.tokens.length; i++) {\n            balancesBefore[i] = IERC20(tempData.tokens[i]).balanceOf(\n                address(this)\n            );\n        }\n\n        zap.claimRewards(\n            tempData.rewardContracts,\n            tempData.extraRewardContracts,\n            tempData.tokenRewardContracts,\n            tempData.tokenRewardTokens,\n            extrasTempData.depositCrvMaxAmount,\n            extrasTempData.minAmountOut,\n            extrasTempData.depositCvxMaxAmount,\n            extrasTempData.spendCvxAmount,\n            extrasTempData.options\n        );\n        uint256[] memory balancesAfter = new uint256[](tempData.tokens.length);\n        for (uint256 i = 0; i < tempData.tokens.length; i++) {\n            balancesAfter[i] = IERC20(tempData.tokens[i]).balanceOf(\n                address(this)\n            );\n        }\n\n        uint256[] memory finalBalances = new uint256[](tempData.tokens.length);\n        for (uint256 i = 0; i < tempData.tokens.length; i++) {\n            finalBalances[i] = balancesAfter[i] - balancesBefore[i];\n        }\n\n        return (finalBalances, tempData.tokens);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    /// @dev queries total staked\n    function _currentBalance() internal view override returns (uint256 amount) {\n        uint256 lpBalance = rewardPool.balanceOf(address(this));\n        uint256 assetAmount = lpGetter.calcLpToWeth(lpBalance);\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        uint256 _compoundAmount = compoundAmount();\n        return assetAmount + queued + _compoundAmount;\n    }\n\n    /// @dev deposits to Curve Tricrypto to get the LP and stakes it into Convex\n    function _deposited(uint256 amount) internal override nonReentrant {\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (queued > depositThreshold) {\n            _addLiquidityAndStake(queued);"
    }
  ]
}