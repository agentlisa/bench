{
  "Title": "[01] Set treasury missing check `address(0)`",
  "Content": "\nThe code should validate _treasury address is not address(0) when setting Treasury in [lending pool](https://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/lending_pool/LendingPool.sol#L243).\n\n```solidity\nfunction setTreasury(address _treasury) external accrue onlyGovernor {\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n```\n\nTn fact by default the treasury address is not set, and accrue interest would revert when [minting interest to treasury address(0)](https://github.com/code-423n4/2024-01-init-capital-invitational/blob/a01c4de620be98f9e57a60cf6a82d4feaec54f58/contracts/lending_pool/LendingPool.sol#L160).\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f6f59bf10f40e06111c66e2fadf652a47919d2f6/contracts/token/ERC20/ERC20Upgradeable.sol#L251\n\n```solidity\nfunction _mint(address account, uint256 value) internal {\n\tif (account == address(0)) {\n\t\trevert ERC20InvalidReceiver(address(0));\n\t}\n\t_update(address(0), account, value);\n}\n```\n\nThe reward token is never removed, but the problem is that the master chef admin can [remove extra reward or update extra reward](https://github.com/traderjoe-xyz/moe-core/blob/5eb20a10cbe4ee01f8db20da950309cb297e3c09/src/MasterChef.sol#L417).\n\nSuppose the reward token list has [MOE, and WETH], WETH is the extra reward, then the extra reward changes to [JOE], then WETH token data is considered outdated.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-init-capital-invitational",
  "Code": [
    {
      "filename": "contracts/lending_pool/LendingPool.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IIRM} from '../interfaces/lending_pool/IIRM.sol';\n\nimport {ERC20Upgradeable} from '@openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {IERC20Metadata} from '@openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {MathUpgradeable} from '@openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol';\n\ncontract LendingPool is ERC20Upgradeable, ILendingPool, UnderACM {\n    using SafeERC20 for IERC20;\n    using MathUpgradeable for uint;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    uint8 private constant VIRTUAL_SHARE_DECIMALS = 8;\n    uint private constant VIRTUAL_SHARES = 10 ** VIRTUAL_SHARE_DECIMALS;\n    uint private constant VIRTUAL_ASSETS = 1;\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n    bytes32 private constant GOVERNOR = keccak256('governor');\n\n    // immutables\n    address public immutable core;\n\n    // storages\n    address public underlyingToken; // underlying tokens\n    uint public cash; // total cash\n    uint public totalDebt; // total debt\n    uint public totalDebtShares; // total debt shares\n    address public irm; // interest rate model\n    uint public lastAccruedTime; // last accrued timestamp\n    uint public reserveFactor_e18; // reserve factor\n    address public treasury; // treasury address\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyGovernor() {\n        ACM.checkRole(GOVERNOR, msg.sender);\n        _;\n    }\n\n    modifier onlyCore() {\n        _require(msg.sender == core, Errors.NOT_INIT_CORE);\n        _;\n    }\n\n    modifier accrue() {\n        accrueInterest();\n        _;\n    }\n\n    // constructor\n    constructor(address _core, address _acm) UnderACM(_acm) {\n        _disableInitializers();\n        core = _core;\n    }\n\n    // initializer\n    /// @dev initialize contract and setup underlying token, name, symbol\n    ///     interest rate model, reserver factor and treasury\n    /// @param _underlyingToken underlying token address\n    /// @param _name lending pool's name\n    /// @param _symbol lending pool's symbol\n    /// @param _irm interest rate model address\n    /// @param _reserveFactor_e18 reserve factor in 1e18 (1e18 = 100%)\n    /// @param _treasury treasury address\n    function initialize(\n        address _underlyingToken,\n        string calldata _name,\n        string calldata _symbol,\n        address _irm,\n        uint _reserveFactor_e18,\n        address _treasury\n    ) external initializer {\n        underlyingToken = _underlyingToken;\n        __ERC20_init(_name, _symbol);\n        irm = _irm;\n        treasury = _treasury;\n        lastAccruedTime = block.timestamp;\n        reserveFactor_e18 = _reserveFactor_e18;\n        // approve core to enable flashloan\n        IERC20(_underlyingToken).safeApprove(core, type(uint).max);\n    }\n\n    // functions\n    /// @inheritdoc ERC20Upgradeable\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(underlyingToken).decimals() + VIRTUAL_SHARE_DECIMALS;\n    }\n\n    /// @inheritdoc ILendingPool\n    function mint(address _receiver) external onlyCore accrue returns (uint shares) {\n        uint _cash = cash;\n        uint newCash = IERC20(underlyingToken).balanceOf(address(this));\n        uint amt = newCash - _cash;\n        shares = _toShares(amt, _cash + totalDebt, totalSupply());\n        _require(shares != 0, Errors.ZERO_VALUE);\n        _mint(_receiver, shares);\n        cash = newCash;\n    }\n\n    /// @inheritdoc ILendingPool\n    function burn(address _receiver) external onlyCore accrue returns (uint amt) {\n        uint sharesToBurn = balanceOf(address(this));\n        uint _cash = cash;\n        _require(sharesToBurn != 0, Errors.ZERO_VALUE);\n        amt = _toAmt(sharesToBurn, _cash + totalDebt, totalSupply());\n        _require(amt <= _cash, Errors.NOT_ENOUGH_CASH);\n        unchecked {\n            cash = _cash - amt;\n        }\n        _burn(address(this), sharesToBurn);\n        IERC20(underlyingToken).safeTransfer(_receiver, amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function borrow(address _receiver, uint _amt) external onlyCore accrue returns (uint shares) {\n        _require(_amt <= cash, Errors.NOT_ENOUGH_CASH);\n        uint _totalDebt = totalDebt;\n        shares = _totalDebt > 0 ? _amt.mulDiv(totalDebtShares, _totalDebt, MathUpgradeable.Rounding.Up) : _amt;\n        totalDebtShares += shares;\n        totalDebt = _totalDebt + _amt;\n        unchecked {\n            cash -= _amt;\n        }\n        IERC20(underlyingToken).safeTransfer(_receiver, _amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function repay(uint _shares) external onlyCore accrue returns (uint amt) {\n        uint _totalDebtShares = totalDebtShares;\n        uint _totalDebt = totalDebt;\n        uint _cash = cash;\n        amt = _shares.mulDiv(_totalDebt, _totalDebtShares, MathUpgradeable.Rounding.Up);\n        _require(amt <= IERC20(underlyingToken).balanceOf(address(this)) - _cash, Errors.INVALID_AMOUNT_TO_REPAY);\n        totalDebtShares = _totalDebtShares - _shares;\n        totalDebt = _totalDebt > amt ? _totalDebt - amt : 0;\n        cash = _cash + amt;\n    }\n\n    /// @inheritdoc ILendingPool\n    function accrueInterest() public {\n        uint _lastAccruedTime = lastAccruedTime;\n        if (block.timestamp != _lastAccruedTime) {\n            uint _totalDebt = totalDebt;\n            uint _cash = cash;\n            uint borrowRate_e18 = IIRM(irm).getBorrowRate_e18(_cash, _totalDebt);\n            uint accruedInterest = (borrowRate_e18 * (block.timestamp - _lastAccruedTime) * _totalDebt) / ONE_E18;\n            uint reserve = (accruedInterest * reserveFactor_e18) / ONE_E18;\n            if (reserve > 0) {\n                _mint(treasury, _toShares(reserve, _cash + _totalDebt + accruedInterest - reserve, totalSupply()));\n            }\n            totalDebt = _totalDebt + accruedInterest;\n            lastAccruedTime = block.timestamp;\n        }\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtAmtToShareStored(uint _amt) public view returns (uint shares) {\n        shares = totalDebt > 0 ? _amt.mulDiv(totalDebtShares, totalDebt, MathUpgradeable.Rounding.Up) : _amt;\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtAmtToShareCurrent(uint _amt) external accrue returns (uint shares) {\n        shares = debtAmtToShareStored(_amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtShareToAmtStored(uint _shares) public view returns (uint amt) {\n        amt = totalDebtShares > 0 ? _shares.mulDiv(totalDebt, totalDebtShares, MathUpgradeable.Rounding.Up) : 0;\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtShareToAmtCurrent(uint _shares) external accrue returns (uint amt) {\n        amt = debtShareToAmtStored(_shares);\n    }\n\n    /// @inheritdoc ILendingPool\n    function toShares(uint _amt) public view returns (uint shares) {\n        shares = _toShares(_amt, totalAssets(), totalSupply());\n    }\n\n    /// @inheritdoc ILendingPool\n    function toAmt(uint _shares) public view returns (uint amt) {\n        amt = _toAmt(_shares, totalAssets(), totalSupply());\n    }\n\n    /// @inheritdoc ILendingPool\n    function toSharesCurrent(uint _amt) external accrue returns (uint shares) {\n        shares = toShares(_amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function toAmtCurrent(uint _shares) external accrue returns (uint amt) {\n        amt = toAmt(_shares);\n    }\n\n    /// @inheritdoc ILendingPool\n    function getSupplyRate_e18() external view returns (uint supplyRate_e18) {\n        uint _totalDebt = totalDebt;\n        uint _cash = cash;\n        uint borrowRate_e18 = IIRM(irm).getBorrowRate_e18(_cash, _totalDebt);\n        // supply rate = borrow rate * (1 - reserve factor) * totalDebt / (cash + totalDebt)\n        supplyRate_e18 = _cash + _totalDebt > 0\n            ? (borrowRate_e18 * (ONE_E18 - reserveFactor_e18) * _totalDebt) / ((_cash + _totalDebt) * ONE_E18)\n            : 0;\n    }\n\n    /// @inheritdoc ILendingPool\n    function getBorrowRate_e18() external view returns (uint borrowRate_e18) {\n        borrowRate_e18 = IIRM(irm).getBorrowRate_e18(cash, totalDebt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function totalAssets() public view returns (uint) {\n        return cash + totalDebt;\n    }\n\n    /// @inheritdoc ILendingPool\n    function setIrm(address _irm) external accrue onlyGuardian {\n        irm = _irm;\n        emit SetIrm(_irm);\n    }\n\n    /// @inheritdoc ILendingPool\n    function setReserveFactor_e18(uint _reserveFactor_e18) external accrue onlyGuardian {\n        _require(_reserveFactor_e18 <= ONE_E18, Errors.INPUT_TOO_HIGH);\n        reserveFactor_e18 = _reserveFactor_e18;\n        emit SetReserveFactor_e18(_reserveFactor_e18);\n    }\n\n    /// @inheritdoc ILendingPool\n    function setTreasury(address _treasury) external accrue onlyGovernor {\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n\n    /// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\n    /// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\n    /// @param _amt The amount of assets to convert to shares.\n    /// @param _totalAssets The total amount of assets in the pool.\n    /// @param _totalShares The total amount of shares in the pool.\n    /// @return shares the amount of shares\n    function _toShares(uint _amt, uint _totalAssets, uint _totalShares) internal pure returns (uint shares) {\n        return _amt.mulDiv(_totalShares + VIRTUAL_SHARES, _totalAssets + VIRTUAL_ASSETS);\n    }\n\n    /// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\n    /// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\n    /// @param _shares The amount of shares to convert to assets.\n    /// @param _totalAssets The total amount of assets in the pool.\n    /// @param _totalShares The total amount of shares in the pool.\n    /// @return amt the token amount\n    function _toAmt(uint _shares, uint _totalAssets, uint _totalShares) internal pure returns (uint amt) {\n        return _shares.mulDiv(_totalAssets + VIRTUAL_ASSETS, _totalShares + VIRTUAL_SHARES);\n    }\n}"
    },
    {
      "filename": "contracts/lending_pool/LendingPool.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IIRM} from '../interfaces/lending_pool/IIRM.sol';\n\nimport {ERC20Upgradeable} from '@openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {IERC20Metadata} from '@openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {MathUpgradeable} from '@openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol';\n\ncontract LendingPool is ERC20Upgradeable, ILendingPool, UnderACM {\n    using SafeERC20 for IERC20;\n    using MathUpgradeable for uint;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    uint8 private constant VIRTUAL_SHARE_DECIMALS = 8;\n    uint private constant VIRTUAL_SHARES = 10 ** VIRTUAL_SHARE_DECIMALS;\n    uint private constant VIRTUAL_ASSETS = 1;\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n    bytes32 private constant GOVERNOR = keccak256('governor');\n\n    // immutables\n    address public immutable core;\n\n    // storages\n    address public underlyingToken; // underlying tokens\n    uint public cash; // total cash\n    uint public totalDebt; // total debt\n    uint public totalDebtShares; // total debt shares\n    address public irm; // interest rate model\n    uint public lastAccruedTime; // last accrued timestamp\n    uint public reserveFactor_e18; // reserve factor\n    address public treasury; // treasury address\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyGovernor() {\n        ACM.checkRole(GOVERNOR, msg.sender);\n        _;\n    }\n\n    modifier onlyCore() {\n        _require(msg.sender == core, Errors.NOT_INIT_CORE);\n        _;\n    }\n\n    modifier accrue() {\n        accrueInterest();\n        _;\n    }\n\n    // constructor\n    constructor(address _core, address _acm) UnderACM(_acm) {\n        _disableInitializers();\n        core = _core;\n    }\n\n    // initializer\n    /// @dev initialize contract and setup underlying token, name, symbol\n    ///     interest rate model, reserver factor and treasury\n    /// @param _underlyingToken underlying token address\n    /// @param _name lending pool's name\n    /// @param _symbol lending pool's symbol\n    /// @param _irm interest rate model address\n    /// @param _reserveFactor_e18 reserve factor in 1e18 (1e18 = 100%)\n    /// @param _treasury treasury address\n    function initialize(\n        address _underlyingToken,\n        string calldata _name,\n        string calldata _symbol,\n        address _irm,\n        uint _reserveFactor_e18,\n        address _treasury\n    ) external initializer {\n        underlyingToken = _underlyingToken;\n        __ERC20_init(_name, _symbol);\n        irm = _irm;\n        treasury = _treasury;\n        lastAccruedTime = block.timestamp;\n        reserveFactor_e18 = _reserveFactor_e18;\n        // approve core to enable flashloan\n        IERC20(_underlyingToken).safeApprove(core, type(uint).max);\n    }\n\n    // functions\n    /// @inheritdoc ERC20Upgradeable\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(underlyingToken).decimals() + VIRTUAL_SHARE_DECIMALS;\n    }\n\n    /// @inheritdoc ILendingPool\n    function mint(address _receiver) external onlyCore accrue returns (uint shares) {\n        uint _cash = cash;\n        uint newCash = IERC20(underlyingToken).balanceOf(address(this));\n        uint amt = newCash - _cash;\n        shares = _toShares(amt, _cash + totalDebt, totalSupply());\n        _require(shares != 0, Errors.ZERO_VALUE);\n        _mint(_receiver, shares);\n        cash = newCash;\n    }\n\n    /// @inheritdoc ILendingPool\n    function burn(address _receiver) external onlyCore accrue returns (uint amt) {\n        uint sharesToBurn = balanceOf(address(this));\n        uint _cash = cash;\n        _require(sharesToBurn != 0, Errors.ZERO_VALUE);\n        amt = _toAmt(sharesToBurn, _cash + totalDebt, totalSupply());\n        _require(amt <= _cash, Errors.NOT_ENOUGH_CASH);\n        unchecked {\n            cash = _cash - amt;\n        }\n        _burn(address(this), sharesToBurn);\n        IERC20(underlyingToken).safeTransfer(_receiver, amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function borrow(address _receiver, uint _amt) external onlyCore accrue returns (uint shares) {\n        _require(_amt <= cash, Errors.NOT_ENOUGH_CASH);\n        uint _totalDebt = totalDebt;\n        shares = _totalDebt > 0 ? _amt.mulDiv(totalDebtShares, _totalDebt, MathUpgradeable.Rounding.Up) : _amt;\n        totalDebtShares += shares;\n        totalDebt = _totalDebt + _amt;\n        unchecked {\n            cash -= _amt;\n        }\n        IERC20(underlyingToken).safeTransfer(_receiver, _amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function repay(uint _shares) external onlyCore accrue returns (uint amt) {\n        uint _totalDebtShares = totalDebtShares;\n        uint _totalDebt = totalDebt;\n        uint _cash = cash;\n        amt = _shares.mulDiv(_totalDebt, _totalDebtShares, MathUpgradeable.Rounding.Up);\n        _require(amt <= IERC20(underlyingToken).balanceOf(address(this)) - _cash, Errors.INVALID_AMOUNT_TO_REPAY);\n        totalDebtShares = _totalDebtShares - _shares;\n        totalDebt = _totalDebt > amt ? _totalDebt - amt : 0;\n        cash = _cash + amt;\n    }\n\n    /// @inheritdoc ILendingPool\n    function accrueInterest() public {\n        uint _lastAccruedTime = lastAccruedTime;\n        if (block.timestamp != _lastAccruedTime) {\n            uint _totalDebt = totalDebt;\n            uint _cash = cash;\n            uint borrowRate_e18 = IIRM(irm).getBorrowRate_e18(_cash, _totalDebt);\n            uint accruedInterest = (borrowRate_e18 * (block.timestamp - _lastAccruedTime) * _totalDebt) / ONE_E18;\n            uint reserve = (accruedInterest * reserveFactor_e18) / ONE_E18;\n            if (reserve > 0) {\n                _mint(treasury, _toShares(reserve, _cash + _totalDebt + accruedInterest - reserve, totalSupply()));\n            }\n            totalDebt = _totalDebt + accruedInterest;\n            lastAccruedTime = block.timestamp;\n        }\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtAmtToShareStored(uint _amt) public view returns (uint shares) {\n        shares = totalDebt > 0 ? _amt.mulDiv(totalDebtShares, totalDebt, MathUpgradeable.Rounding.Up) : _amt;\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtAmtToShareCurrent(uint _amt) external accrue returns (uint shares) {\n        shares = debtAmtToShareStored(_amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtShareToAmtStored(uint _shares) public view returns (uint amt) {\n        amt = totalDebtShares > 0 ? _shares.mulDiv(totalDebt, totalDebtShares, MathUpgradeable.Rounding.Up) : 0;\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtShareToAmtCurrent(uint _shares) external accrue returns (uint amt) {\n        amt = debtShareToAmtStored(_shares);\n    }\n\n    /// @inheritdoc ILendingPool\n    function toShares(uint _amt) public view returns (uint shares) {\n        shares = _toShares(_amt, totalAssets(), totalSupply());\n    }\n\n    /// @inheritdoc ILendingPool\n    function toAmt(uint _shares) public view returns (uint amt) {\n        amt = _toAmt(_shares, totalAssets(), totalSupply());\n    }\n\n    /// @inheritdoc ILendingPool\n    function toSharesCurrent(uint _amt) external accrue returns (uint shares) {\n        shares = toShares(_amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function toAmtCurrent(uint _shares) external accrue returns (uint amt) {\n        amt = toAmt(_shares);\n    }\n\n    /// @inheritdoc ILendingPool\n    function getSupplyRate_e18() external view returns (uint supplyRate_e18) {\n        uint _totalDebt = totalDebt;\n        uint _cash = cash;\n        uint borrowRate_e18 = IIRM(irm).getBorrowRate_e18(_cash, _totalDebt);\n        // supply rate = borrow rate * (1 - reserve factor) * totalDebt / (cash + totalDebt)\n        supplyRate_e18 = _cash + _totalDebt > 0\n            ? (borrowRate_e18 * (ONE_E18 - reserveFactor_e18) * _totalDebt) / ((_cash + _totalDebt) * ONE_E18)\n            : 0;\n    }\n\n    /// @inheritdoc ILendingPool\n    function getBorrowRate_e18() external view returns (uint borrowRate_e18) {\n        borrowRate_e18 = IIRM(irm).getBorrowRate_e18(cash, totalDebt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function totalAssets() public view returns (uint) {\n        return cash + totalDebt;\n    }\n\n    /// @inheritdoc ILendingPool\n    function setIrm(address _irm) external accrue onlyGuardian {\n        irm = _irm;\n        emit SetIrm(_irm);\n    }\n\n    /// @inheritdoc ILendingPool\n    function setReserveFactor_e18(uint _reserveFactor_e18) external accrue onlyGuardian {\n        _require(_reserveFactor_e18 <= ONE_E18, Errors.INPUT_TOO_HIGH);\n        reserveFactor_e18 = _reserveFactor_e18;\n        emit SetReserveFactor_e18(_reserveFactor_e18);\n    }\n\n    /// @inheritdoc ILendingPool\n    function setTreasury(address _treasury) external accrue onlyGovernor {\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n\n    /// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\n    /// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\n    /// @param _amt The amount of assets to convert to shares.\n    /// @param _totalAssets The total amount of assets in the pool.\n    /// @param _totalShares The total amount of shares in the pool.\n    /// @return shares the amount of shares\n    function _toShares(uint _amt, uint _totalAssets, uint _totalShares) internal pure returns (uint shares) {\n        return _amt.mulDiv(_totalShares + VIRTUAL_SHARES, _totalAssets + VIRTUAL_ASSETS);\n    }\n\n    /// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\n    /// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\n    /// @param _shares The amount of shares to convert to assets.\n    /// @param _totalAssets The total amount of assets in the pool.\n    /// @param _totalShares The total amount of shares in the pool.\n    /// @return amt the token amount\n    function _toAmt(uint _shares, uint _totalAssets, uint _totalShares) internal pure returns (uint amt) {\n        return _shares.mulDiv(_totalAssets + VIRTUAL_ASSETS, _totalShares + VIRTUAL_SHARES);\n    }\n}"
    },
    {
      "filename": "contracts/token/ERC20/ERC20Upgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the ERC may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the ERC. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApp"
    }
  ]
}