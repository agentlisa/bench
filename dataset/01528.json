{
  "Title": "M-3: In `PriceTierVesting` there is no check if the Sequenzer for L2s is up when calling the oralce",
  "Content": "# Issue M-3: In `PriceTierVesting` there is no check if the Sequenzer for L2s is up when calling the oralce \n\nSource: https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/64 \n\n## Found by \nAvci, BenRai, auditsea, magellanXtrachev, pks\\_, smbv-1919, stopthecap\n## Summary\n\nPrice from oracle on L2s can be invalid/stale if the sequencer is down. This could lead to users being able to claim tokens that they should not be able to claim.\n\n## Vulnerability Detail\n\nIf the sequencer of the L2s were to go offline the Chainlink oracle may return an invalid/stale\nprice. This could lead to users being able to claim tokens that they should not be able to claim.\n\nFor example, if the last reference price recorded by the oracle was above the final tier price, this would have unlocked all tokens to be claimable. If the sequencer goes and in the meantime down the reference price falls below the final tier price , the oracle would still return the high price even though the price is lower now and not all tokens should be claimable.   \n\nIt should always be checked if the sequencer is up before consuming any data from Chainlink. For more details on L2 Sequencer Uptime Feeds check the Chainlink docs(https://docs.chain.link/data-feeds/l2-sequencer-feeds) specify more details.\n\n## Impact\n\nReceivers can claim tokens they should not be able to claim \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/1f58ddb066ab383c416cfcbf95c9902683506e96/contracts/contracts/claim/abstract/PriceTierVesting.sol#L30-L45 \n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInclude a check if the sequencer is up. If it is down, revert when calling `getVestedFraction` in `PriceTierVesting` \n\n\n\n## Discussion\n\n**BenRai1**\n\nEscalate\n\nAccording to the judge, the issue was excluded because `PriceTierVesting.sol` is out of scope for the contest. \nEven though `PriceTierVesting.sol` was not explicitly mentioned as in scope, deriving from the following issue in the Teller contest, (https://github.com/sherlock-audit/2023-03-teller-judging/issues/328), `PriceTierVesting.sol` is implicitly in scope because ` PriceTierVestingSale_2_0.sol` is in scope and it is inheriting from `PriceTierVesting`. This means all behaviour of `PriceTierVesting` that affects `PriceTierVestingSale_2_0` should also be in scope.\n\nTherefore in my opinion, this issue should be considered as valid.\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> According to the judge, the issue was excluded because `PriceTierVesting.sol` is out of scope for the contest. \n> Even though `PriceTierVesting.sol` was not explicitly mentioned as in scope, deriving from the following issue in the Teller contest, (https://github.com/sherlock-audit/2023-03-teller-judging/issues/328), `PriceTierVesting.sol` is implicitly in scope because ` PriceTierVestingSale_2_0.sol` is in scope and it is inheriting from `PriceTierVesting`. This means all behaviour of `PriceTierVesting` that affects `PriceTierVestingSale_2_0` should also be in scope.\n> \n> Therefore in my opinion, this issue should be considered as valid.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**jkoppel**\n\nDuplicate: #22, #38, #48, #218, #229, #38, #163\n\n**Shogoki**\n\n**Regarding scoping:**\n \nIn my opinion every contract in scope should be listed explicitly as in scope. I do get that it might makes sense to have some rules to have this contract implicitly in scope, but it creates uncertainty as it is nowhere documented. I raised this concern in discord [here](https://discord.com/channels/812037309376495636/881726370370158592/1138377679868006430) I will leave the final decision on the scope for this on sherlock, as there are good points for both sides, i guess. But the following discussions in discord should also be taken into account:\n\nhttps://discord.com/channels/812037309376495636/1130514276570906685/1138286182254522531\nhttps://discord.com/channels/812037309376495636/1130514276570906685/1131243195817283604\n\nHowever this is decided at the end, we should take this as a chance to improve the guidelines for scope in future contests.\n\n**Regarding the Issue:**\n\nThis can be a valid Medium \n\n**hrishibhat**\n\nResult: \nMedium\nHas duplicates\nSince `PriceTierVesting` is in scope because `PriceTierVestingSale_2_0` is in scope. This is a valid medium\nAgree with the @Shogoki comments that the scoping rules should be improved to avoid such confusion\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [BenRai1](https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/64/#issuecomment-1667745005): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/100",
  "Code": [
    {
      "filename": "contracts/contracts/claim/abstract/PriceTierVesting.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport { AdvancedDistributor, Distributor, IERC20 } from \"./AdvancedDistributor.sol\";\nimport { IPriceTierVesting, PriceTier } from \"../../interfaces/IPriceTierVesting.sol\";\n\nabstract contract PriceTierVesting is AdvancedDistributor, IPriceTierVesting {\n\tPriceTier[] private tiers;\n\tuint256 private start; // time vesting begins\n\tuint256 private end; // time vesting ends (all tokens are claimable)\n\tAggregatorV3Interface private oracle; // oracle providing prices\n\n\tconstructor(\n\t\tIERC20 _token,\n\t\tuint256 _total,\n\t\tstring memory _uri, // information on the sale (e.g. merkle proofs)\n\t\tuint256 _voteFactor,\n\t\tuint256 _start,\n\t\tuint256 _end,\n\t\tAggregatorV3Interface _oracle,\n\t\tPriceTier[] memory _tiers,\n    uint160 _maxDelayTime,\n\t\tuint160 _salt\n\t) AdvancedDistributor(_token, _total, _uri, _voteFactor, 10000, _maxDelayTime, _salt) {\n\t\t_setPriceTiers(_start, _end, _oracle, _tiers);\n\t}\n\n\tfunction _getOraclePrice() private view returns (uint256) {\n\t\t(\n\t\t\tuint80 roundID,\n\t\t\tint256 _price,\n\t\t\tuint256 startedAt,\n\t\t\tuint256 timeStamp,\n\t\t\tuint80 answeredInRound\n\t\t) = oracle.latestRoundData();\n\n\t\trequire(_price > 0, \"negative price\");\n\t\trequire(answeredInRound != 0, \"answer == 0\");\n\t\trequire(timeStamp != 0, \"round not complete\");\n\t\trequire(answeredInRound >= roundID, \"stale price\");\n\n\t\treturn uint256(_price);\n\t}\n\n\tfunction getStart() external view override returns (uint256) {\n\t\treturn start;\n\t}\n\n\tfunction getEnd() external view override returns (uint256) {\n\t\treturn end;\n\t}\n\n\tfunction getOracle() external view override returns (AggregatorV3Interface) {\n\t\treturn oracle;\n\t}\n\n\tfunction getPriceTier(uint256 i) public view returns (PriceTier memory) {\n\t\treturn tiers[i];\n\t}\n\n\tfunction getPriceTiers() public view returns (PriceTier[] memory) {\n\t\treturn tiers;\n\t}\n\n\tfunction getVestedFraction(\n\t\taddress beneficiary,\n\t\tuint256 time // time in seconds past epoch\n\t) public view override returns (uint256) {\n\t\t// shift this user's time by their fair delay\n\t\tuint256 delayedTime = time - getFairDelayTime(beneficiary);\n\n\t\t// no tokens are vested\n\t\tif (delayedTime < start) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// all tokens are vested\n\t\tif (delayedTime >= end) {\n\t\t\treturn fractionDenominator;\n\t\t}\n\n\t\tuint256 price = _getOraclePrice();\n\n\t\tfor (uint256 i = tiers.length; i != 0; ) {\n\t\t\tunchecked {\n\t\t\t\t--i;\n\t\t\t}\n\t\t\tif (price > tiers[i].price) {\n\t\t\t\treturn tiers[i].vestedFraction;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction _setPriceTiers(\n\t\tuint256 _start,\n\t\tuint256 _end,\n\t\tAggregatorV3Interface _oracle,\n\t\tPriceTier[] memory _tiers\n\t) private {\n\t\trequire(_tiers.length > 0, \"1+ price tiers required\");\n\n\t\tdelete tiers;\n\n\t\tuint128 highestPrice = 0;\n\t\tuint128 highestFraction = 0;\n\n\t\tfor (uint256 i = 0; i < _tiers.length; ) {\n\t\t\trequire(_tiers[i].price > highestPrice, \"tier prices decrease\");\n\t\t\trequire(_tiers[i].vestedFraction > highestFraction, \"vested fraction decreases\");\n\t\t\thighestPrice = _tiers[i].price;\n\t\t\thighestFraction = _tiers[i].vestedFraction;\n\n\t\t\ttiers.push(_tiers[i]);\n\n\t\t\tunchecked {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\n\t\trequire(highestFraction == fractionDenominator, \"highest price tier must vest all tokens\");\n\t\trequire(address(_oracle) != address(0), \"oracle == address(0)\");\n\n\t\tstart = _start;\n\t\tend = _end;\n\t\toracle = _oracle;\n\t\temit SetPriceTierConfig(start, end, oracle, tiers);\n\t}\n\n\t// Adjustable admin functions\n\tfunction setPriceTiers(\n\t\tuint256 _start,\n\t\tuint256 _end,\n\t\tAggregatorV3Interface _oracle,\n\t\tPriceTier[] memory _tiers\n\t) external onlyOwner {\n\t\t_setPriceTiers(_start, _end, _oracle, _tiers);\n\t}\n}"
    }
  ]
}