{
  "Title": "M-1: Calculation underflow/overflow in BalancerPairOracle, which will affect pools in Aura Finance",
  "Content": "# Issue M-1: Calculation underflow/overflow in BalancerPairOracle, which will affect pools in Aura Finance \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/11 \n\n## Found by \nn1punp\n## Summary\nLP price calculation for Balancer Pair in BalancerPairOracle will produce calculation underflow/overflow (so Aura pools won't work too).\n\n## Vulnerability Detail\n- The values r0, r1 can underflow, e.g. if resA < resB --> r0 = 0, so it'll go to the else case --> and so `ratio` will be 0 --> `fairResA` calculation will revert upon dividing by 0.\n- There are also other math calculations there that will cause reverts, e.g. ratio ** wB will lead to overflow. What you'd need here is Balancer's implementation of `bpow` or similar.\n\n## Impact\nLP price for Balancer-like collateral token will revert in most cases, if not all.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L53-L64\n\n## Tool used\n\nManual Review\n\n## Recommendation\n- Change the calculation logic so it aligns with Alpha's original implementation (with precision control), e.g. https://github.com/AlphaFinanceLab/alpha-homora-v2-contract/blob/master/contracts/oracle/BalancerPairOracle.sol#L42-L53 (you can see there's BONE extra precision in each step)\n\n\n\n## Discussion\n\n**n1punp**\n\nEscalate for 10 USDC.\nI think this is incorrectly **excluded**. The issue is not related to **flashloan** via **BalancerPairOracle**, but rather an organic math overflow/underflow, since the implementation is directly using 0.8.x's default SafeMath mode. Upon certain conditions (e.g. `resA < resB` the calculation will always revert).\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> I think this is incorrectly **excluded**. The issue is not related to **flashloan** via **BalancerPairOracle**, but rather an organic math overflow/underflow, since the implementation is directly using 0.8.x's default SafeMath mode. Upon certain conditions (e.g. `resA < resB` the calculation will always revert).\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI don't think this report has sufficient prove\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue a valid medium \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue a valid medium \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/BalancerPairOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/balancer/IBalancerVault.sol\";\n\n/**\n * @author BlueberryProtocol\n * @title Balancer Pair Oracle\n * @notice Oracle contract which privides price feeds of Balancer Pair tokens\n * @dev Implented Fair Lp Pricing\n *      Ref: https://blog.alphaventuredao.io/fair-lp-token-pricing/\n */\ncontract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /// @notice Return fair reserve amounts given spot reserves, weights, and fair prices.\n    /// @param resA Reserve of the first asset\n    /// @param resB Reserve of the second asset\n    /// @param wA Weight of the first asset\n    /// @param wB Weight of the second asset\n    /// @param pxA Fair price of the first asset\n    /// @param pxB Fair price of the second asset\n    function computeFairReserves(\n        uint256 resA,\n        uint256 resB,\n        uint256 wA,\n        uint256 wB,\n        uint256 pxA,\n        uint256 pxB\n    ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n        // NOTE: wA + wB = 1 (normalize weights)\n        // constant product = resA^wA * resB^wB\n        // constraints:\n        // - fairResA^wA * fairResB^wB = constant product\n        // - fairResA * pxA / wA = fairResB * pxB / wB\n        // Solving equations:\n        // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n        // --> fairResA / r1^wB = constant product\n        // --> fairResA = resA^wA * resB^wB * r1^wB\n        // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n        uint256 r0 = resA / resB;\n        uint256 r1 = (wA * pxB) / (wB * pxA);\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = r1 / r0;\n            fairResA = resA * (ratio ** wB);\n            fairResB = resB / (ratio ** wA);\n        } else {\n            uint256 ratio = r0 / r1;\n            fairResA = resA / (ratio ** wB);\n            fairResB = resB * (ratio ** wA);\n        }\n    }\n\n    /// @notice Return the USD value of given Curve Lp, with 18 decimals of precision.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external view override returns (uint256) {\n        IBalancerPool pool = IBalancerPool(token);\n        IBalancerVault vault = IBalancerVault(pool.getVault());\n        (address[] memory tokens, uint256[] memory balances, ) = vault\n            .getPoolTokens(pool.getPoolId());\n        uint256[] memory weights = pool.getNormalizedWeights();\n        require(tokens.length == 2, \"num tokens must be 2\");\n        address tokenA = tokens[0];\n        address tokenB = tokens[1];\n        uint256 price0 = base.getPrice(tokenA);\n        uint256 price1 = base.getPrice(tokenB);\n        (uint256 fairResA, uint256 fairResB) = computeFairReserves(\n            balances[0],\n            balances[1],\n            weights[0],\n            weights[1],\n            price0,\n            price1\n        );\n        // use fairReserveA and fairReserveB to compute LP token price\n        // LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n        return (fairResA * price0 + fairResB * price1) / pool.totalSupply();\n    }\n}"
    },
    {
      "filename": "contracts/oracle/BalancerPairOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.4.0/contracts/math/SafeMath.sol';\n\nimport './UsingBaseOracle.sol';\nimport '../utils/BNum.sol';\nimport '../../interfaces/IBaseOracle.sol';\nimport '../../interfaces/IBalancerPool.sol';\n\ncontract BalancerPairOracle is UsingBaseOracle, IBaseOracle, BNum {\n  using SafeMath for uint;\n\n  constructor(IBaseOracle _base) public UsingBaseOracle(_base) {}\n\n  /// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.\n  /// @param resA Reserve of the first asset\n  /// @param resB Reserve of the second asset\n  /// @param wA Weight of the first asset\n  /// @param wB Weight of the second asset\n  /// @param pxA Fair price of the first asset\n  /// @param pxB Fair price of the second asset\n  function computeFairReserves(\n    uint resA,\n    uint resB,\n    uint wA,\n    uint wB,\n    uint pxA,\n    uint pxB\n  ) internal pure returns (uint fairResA, uint fairResB) {\n    // NOTE: wA + wB = 1 (normalize weights)\n    // constant product = resA^wA * resB^wB\n    // constraints:\n    // - fairResA^wA * fairResB^wB = constant product\n    // - fairResA * pxA / wA = fairResB * pxB / wB\n    // Solving equations:\n    // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n    // --> fairResA / r1^wB = constant product\n    // --> fairResA = resA^wA * resB^wB * r1^wB\n    // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n    uint r0 = bdiv(resA, resB);\n    uint r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\n    // fairResA = resA * (r1 / r0) ^ wB\n    // fairResB = resB * (r0 / r1) ^ wA\n    if (r0 > r1) {\n      uint ratio = bdiv(r1, r0);\n      fairResA = bmul(resA, bpow(ratio, wB));\n      fairResB = bdiv(resB, bpow(ratio, wA));\n    } else {\n      uint ratio = bdiv(r0, r1);\n      fairResA = bdiv(resA, bpow(ratio, wB));\n      fairResB = bmul(resB, bpow(ratio, wA));\n    }\n  }\n\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\n  /// @param token The ERC-20 token to check the value.\n  function getETHPx(address token) external view override returns (uint) {\n    IBalancerPool pool = IBalancerPool(token);\n    require(pool.getNumTokens() == 2, 'num tokens must be 2');\n    address[] memory tokens = pool.getFinalTokens();\n    address tokenA = tokens[0];\n    address tokenB = tokens[1];\n    uint pxA = base.getETHPx(tokenA);\n    uint pxB = base.getETHPx(tokenB);\n    (uint fairResA, uint fairResB) =\n      computeFairReserves(\n        pool.getBalance(tokenA),\n        pool.getBalance(tokenB),\n        pool.getNormalizedWeight(tokenA),\n        pool.getNormalizedWeight(tokenB),\n        pxA,\n        pxB\n      );\n    // use fairReserveA and fairReserveB to compute LP token price\n    // LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n    return fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply());\n  }\n}"
    }
  ]
}