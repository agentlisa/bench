{
  "Title": "[G-04] State variables can be packed into fewer storage slots",
  "Content": "If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/p1/StRSR.sol\n\n/// @audit Variable ordering with 21 slots instead of the current 22:\n///           string(32):name, string(32):symbol, uint256(32):era, mapping(32):stakes, uint256(32):totalStakes, uint256(32):stakeRSR, mapping(32):_allowances, uint256(32):draftEra, mapping(32):draftQueues, mapping(32):firstRemainingDraft, uint256(32):totalDrafts, uint256(32):draftRSR, mapping(32):_nonces, uint256(32):rsrRewardsAtLastPayout, uint192(24):stakeRate, uint48(6):unstakingDelay, uint192(24):draftRate, uint48(6):rewardPeriod, uint192(24):rewardRatio, uint48(6):payoutLastPaid, address(20):assetRegistry, address(20):backingManager, address(20):basketHandler, user-defined(20):rsr\n42:       string public name; // mutable\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L42\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-reserve",
  "Code": [
    {
      "filename": "contracts/p1/StRSR.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IStRSR.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"../libraries/Permit.sol\";\nimport \"./mixins/Component.sol\";\n\n/*\n * @title StRSRP1\n * @notice StRSR is an ERC20 token contract that allows people to stake their RSR as\n *   over-collateralization behind an RToken. As compensation stakers receive a share of revenues\n *   in the form of RSR. Balances are generally non-rebasing. As rewards are paid out StRSR becomes\n *   redeemable for increasing quantities of RSR.\n *\n * The one time that StRSR will rebase is if the entirety of over-collateralization RSR is seized.\n *   If this happens, users balances are zereod out and StRSR is re-issued at a 1:1 exchange rate\n *   with RSR.\n *\n * There's an important asymmetry in StRSR: when RSR is added it must be split only\n *   across non-withdrawing stakes, while when RSR is seized it is seized uniformly from both\n *   stakes that are in the process of being withdrawn and those that are not.\n */\n// solhint-disable max-states-count\nabstract contract StRSRP1 is Initializable, ComponentP1, IStRSR, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint48 public constant MAX_UNSTAKING_DELAY = 31536000; // {s} 1 year\n    uint48 public constant MAX_REWARD_PERIOD = 31536000; // {s} 1 year\n    uint192 public constant MAX_REWARD_RATIO = FIX_ONE; // {1} 100%\n\n    // === ERC20 ===\n    string public name; // mutable\n    string public symbol; // mutable\n    // solhint-disable const-name-snakecase\n    uint8 public constant decimals = 18;\n\n    // Component addresses, immutable after init()\n    IAssetRegistry private assetRegistry;\n    IBackingManager private backingManager;\n    IBasketHandler private basketHandler;\n    IERC20 private rsr;\n\n    /// === Financial State: Stakes (balances) ===\n    // Era. If stake balances are wiped out due to RSR seizure, increment the era to zero balances.\n    // Only ever directly written by beginEra()\n    uint256 internal era;\n\n    // Typically: \"balances\". These are the tokenized staking positions!\n    // era => ({account} => {qStRSR})\n    mapping(uint256 => mapping(address => uint256)) private stakes; // Stakes per account {qStRSR}\n    uint256 internal totalStakes; // Total of all stakes {qStRSR}\n    uint256 internal stakeRSR; // Amount of RSR backing all stakes {qRSR}\n    uint192 public stakeRate; // The exchange rate between stakes and RSR. D18{qStRSR/qRSR}\n\n    uint192 private constant MAX_STAKE_RATE = 1e9 * FIX_ONE; // 1e9 D18{qStRSR/qRSR}\n\n    // era => (owner => (spender => {qStRSR}))\n    mapping(uint256 => mapping(address => mapping(address => uint256))) private _allowances;\n\n    // === Financial State: Drafts ===\n    // Era. If drafts get wiped out due to RSR seizure, increment the era to zero draft values.\n    // Only ever directly written by beginDraftEra()\n    uint256 internal draftEra;\n    // Drafts: share of the withdrawing tokens. Not transferrable and not revenue-earning.\n    struct CumulativeDraft {\n        // Avoid re-using uint192 in order to avoid confusion with our type system; 176 is enough\n        uint176 drafts; // Total amount of drafts that will become available // {qDraft}\n        uint64 availableAt; // When the last of the drafts will become available\n    }\n    // draftEra => ({account} => {drafts})\n    mapping(uint256 => mapping(address => CumulativeDraft[])) public draftQueues; // {drafts}\n    mapping(uint256 => mapping(address => uint256)) public firstRemainingDraft; // draft index\n    uint256 internal totalDrafts; // Total of all drafts {qDrafts}\n    uint256 internal draftRSR; // Amount of RSR backing all drafts {qRSR}\n    uint192 public draftRate; // The exchange rate between drafts and RSR. D18{qDrafts/qRSR}\n\n    uint192 private constant MAX_DRAFT_RATE = 1e9 * FIX_ONE; // 1e9 D18{qDrafts/qRSR}\n\n    // ==== Analysis Definitions for Financial State ====\n    // Let `bal` be the map stakes[era]; so, bal[acct] == balanceOf(acct)\n\n    // Entirely different concepts for the Drafts:\n    // `draft[acct]` is a \"draft record\". If, say, r = draft[acct], then:\n    //   Let `r.queue` be the map draftQueues[era][acct]\n    //   Let `r.left` be the value firstRemainingDraft[era][acct] // ( minus 1? )\n    //   Let `r.right` be the value draftsQueues[era][acct].length\n    //   We further define r.queue[-1].drafts to be 0.\n    //\n    // So, for any keyval pair (acct, r) in draft:\n    // r.left <= r.right\n    // for all i and j with r.left <= i < j < r.right:\n    //   r.queue[i].drafts < r.queue[j].drafts, and\n    //   r.queue[i].availableAt <= r.queue[j].availableAt\n    //\n    // Define draftSum, the total amount of drafts eventually due to the account holder of record r:\n    // Let draftSum(r:draftRecord) =\n    //   r.queue[r.right-1].drafts - r.queue[r.left-1].drafts\n\n    // ==== Invariants ====\n    // [total-stakes]: totalStakes == sum(bal[acct] for acct in bal)\n    // [max-stake-rate]: 0 < stakeRate <= MAX_STAKE_RATE\n    // [stake-rate]: if totalStakes == 0, then stakeRSR == 0 and stakeRate == FIX_ONE\n    //               else, stakeRSR * stakeRate >= totalStakes * 1e18\n    //               (ie, stakeRSR covers totalStakes at stakeRate)\n    //\n    // [total-drafts]: totalDrafts == sum(draftSum(draft[acct]) for acct in draft)\n    // [max-draft-rate]: 0 < draftRate <= MAX_DRAFT_RATE\n    // [draft-rate]: if totalDrafts == 0, then draftRSR == 0 and draftRate == FIX_ONE\n    //               else, draftRSR * draftRate >= totalDrafts * 1e18\n    //               (ie, draftRSR covers totalDrafts at draftRate)\n    //\n    // === ERC20Permit ===\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    // ==== Gov Params ====\n    // Promise: Each gov param is set _only_ by the appropriate \"set\" function.\n    // Invariant: rewardPeriod * 2 <= unstakingDelay\n    uint48 public unstakingDelay; // {s} The minimum length of time spent in the draft queue\n    uint48 public rewardPeriod; // {s} The number of seconds between revenue payout events\n    uint192 public rewardRatio; // {1} The fraction of the revenue balance to handout per period\n\n    // === Rewards Cache ===\n    // Promise: The two *payout* vars are modified only by init() and _payoutRewards()\n    //   init() pretends that the \"first\" payout happens at initialization time\n    //   _payoutRewards() updates them as described.\n    // When init() or _payoutRewards() was last called:\n    //     payoutLastPaid was the timestamp when the last paid-up block ended\n    //     rsrRewardsAtLastPayout was the value of rsrRewards() at that time\n\n    // {seconds} The last time when rewards were paid out\n    uint48 public payoutLastPaid;\n\n    // {qRSR} How much reward RSR was held the last time rewards were paid out\n    uint256 internal rsrRewardsAtLastPayout;\n\n    // ======================\n\n    // init() can only be called once (initializer)\n    // ==== Financial State:\n    // effects:\n    //   draft' = {}, bal' = {}, all totals zero, all rates FIX_ONE.\n    //   payoutLastPaid' = now\n    //   rsrRewardsAtLastPayout' = current RSR balance ( == rsrRewards() given the above )\n    function init(\n        IMain main_,\n        string calldata name_,\n        string calldata symbol_,\n        uint48 unstakingDelay_,\n        uint48 rewardPeriod_,\n        uint192 rewardRatio_\n    ) external initializer {\n        require(bytes(name_).length > 0, \"name empty\");\n        require(bytes(symbol_).length > 0, \"symbol empty\");\n        __Component_init(main_);\n        __EIP712_init(name_, \"1\");\n        name = name_;\n        symbol = symbol_;\n\n        assetRegistry = main_.assetRegistry();\n        backingManager = main_.backingManager();\n        basketHandler = main_.basketHandler();\n        rsr = IERC20(address(main_.rsr()));\n\n        payoutLastPaid = uint48(block.timestamp);\n        rsrRewardsAtLastPayout = main_.rsr().balanceOf(address(this));\n        setUnstakingDelay(unstakingDelay_);\n        setRewardPeriod(rewardPeriod_);\n        setRewardRatio(rewardRatio_);\n\n        beginEra();\n        beginDraftEra();\n    }\n\n    /// Assign reward payouts to the staker pool\n    /// @custom:refresher\n    function payoutRewards() external notPausedOrFrozen {\n        _payoutRewards();\n    }\n\n    /// Stakes an RSR `amount` on the corresponding RToken to earn yield and over-collateralize\n    /// the system\n    /// @param rsrAmount {qRSR}\n    /// @dev Staking continues while paused/frozen, without reward handouts\n    /// @custom:interaction CEI\n    // checks:\n    //   0 < rsrAmount\n    //\n    // effects:\n    //   stakeRSR' = stakeRSR + rsrAmount\n    //   totalStakes' = stakeRSR' * stakeRate / 1e18   (as required by invariant)\n    //   bal'[caller] = bal[caller] + (totalStakes' - totalStakes)\n    //   stakeRate' = stakeRate     (this could go without saying, but it's important!)\n    //\n    // actions:\n    //   rsr.transferFrom(account, this, rsrAmount)\n    function stake(uint256 rsrAmount) external {\n        require(rsrAmount > 0, \"Cannot stake zero\");\n\n        if (!main.pausedOrFrozen()) _payoutRewards();\n\n        // Compute stake amount\n        // This is not an overflow risk according to our expected ranges:\n        //   rsrAmount <= 1e29, totalStaked <= 1e38, 1e29 * 1e38 < 2^256.\n        // stakeAmount: how many stRSR the user shall receive.\n        // pick stakeAmount as big as we can such that (newTotalStakes <= newStakeRSR * stakeRate)\n        uint256 newStakeRSR = stakeRSR + rsrAmount;\n        // newTotalStakes: {qStRSR} = D18{qStRSR/qRSR} * {qRSR} / D18\n        uint256 newTotalStakes = (stakeRate * newStakeRSR) / FIX_ONE;\n        uint256 stakeAmount = newTotalStakes - totalStakes;\n\n        // Update staked\n        address account = _msgSender();\n        stakeRSR += rsrAmount;\n        _mint(account, stakeAmount);\n\n        // Transfer RSR from account to this contract\n        emit Staked(era, account, rsrAmount, stakeAmount);\n\n        // == Interactions ==\n        IERC20Upgradeable(address(rsr)).safeTransferFrom(account, address(this), rsrAmount);\n    }\n\n    /// Begins a delayed unstaking for `amount` StRSR\n    /// @param stakeAmount {qStRSR}\n    // checks:\n    //   not paused or frozen\n    //   0 < stakeAmount <= bal[caller]\n    //\n    // effects:\n    //   totalStakes' = totalStakes - stakeAmount\n    //   bal'[caller] = bal[caller] - stakeAmount\n    //   stakeRSR' = ceil(totalStakes' * 1e18 / stakeRate)\n    //   stakeRate' = stakeRate (no change)\n    //\n    //   draftRSR' + stakeRSR' = draftRSR + stakeRSR\n    //   draftRate' = draftRate (no change)\n    //   totalDrafts' = floor(draftRSR' + draftRate' / 1e18)\n    //\n    //   A draft for (totalDrafts' - totalDrafts) drafts\n    //   is freshly appended to the caller's draft record.\n    function unstake(uint256 stakeAmount) external notPausedOrFrozen {\n        address account = _msgSender();\n        require(stakeAmount > 0, \"Cannot withdraw zero\");\n        require(stakes[era][account] >= stakeAmount, \"Not enough balance\");\n\n        _payoutRewards();\n\n        // ==== Compute changes to stakes and RSR accounting\n        // rsrAmount: how many RSR to move from the stake pool to the draft pool\n        // pick rsrAmount as big as we can such that (newTotalStakes <= newStakeRSR * stakeRate)\n        _burn(account, stakeAmount);\n\n        // newStakeRSR: {qRSR} = D18 * {qStRSR} / D18{qStRSR/qRSR}\n        uint256 newStakeRSR = (FIX_ONE_256 * totalStakes + (stakeRate - 1)) / stakeRate;\n        uint256 rsrAmount = stakeRSR - newStakeRSR;\n        stakeRSR = newStakeRSR;\n\n        // Create draft\n        (uint256 index, uint64 availableAt) = pushDraft(account, rsrAmount);\n        emit UnstakingStarted(index, era, account, rsrAmount, stakeAmount, availableAt);\n    }\n\n    /// Complete an account's unstaking; callable by anyone\n    /// @custom:interaction RCEI\n    // Let:\n    //   r = draft[account]\n    //   draftAmount = r.queue[endId - 1].drafts - r.queue[r.left-1].drafts\n    //\n    // checks:\n    //   RToken is fully collateralized and the basket is sound.\n    //   The system is not paused or frozen.\n    //   endId <= r.right\n    //   r.queue[endId - 1].availableAt <= now\n    //\n    // effects:\n    //   r'.left = max(endId, r.left)\n    //   draftSum'(account) = draftSum(account) + draftAmount)\n    //   r'.right = r.right\n    //   totalDrafts' = totalDrafts - draftAmount\n    //   draftRSR' = ceil(totalDrafts' * 1e18 / draftRate)\n    //\n    // actions:\n    //   rsr.transfer(account, rsrOut)\n    function withdraw(address account, uint256 endId) external notPausedOrFrozen {\n        // == Refresh ==\n        assetRegistry.refresh();\n\n        // == Checks + Effects ==\n        require(basketHandler.fullyCollateralized(), \"RToken uncollateralized\");\n        require(basketHandler.status() == CollateralStatus.SOUND, \"basket defaulted\");\n\n        uint256 firstId = firstRemainingDraft[draftEra][account];\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n        if (endId == 0 || firstId >= endId) return;\n\n        require(endId <= queue.length, \"index out-of-bounds\");\n        require(queue[endId - 1].availableAt <= block.timestamp, \"withdrawal unavailable\");\n\n        uint192 oldDrafts = firstId > 0 ? queue[firstId - 1].drafts : 0;\n        uint192 draftAmount = queue[endId - 1].drafts - oldDrafts;\n\n        // advance queue past withdrawal\n        firstRemainingDraft[draftEra][account] = endId;\n\n        // ==== Compute RSR amount\n        uint256 newTotalDrafts = totalDrafts - draftAmount;\n        // newDraftRSR: {qRSR} = {qDrafts} * D18 / D18{qDrafts/qRSR}\n        uint256 newDraftRSR = (newTotalDrafts * FIX_ONE_256 + (draftRate - 1)) / draftRate;\n        uint256 rsrAmount = draftRSR - newDraftRSR;\n\n        if (rsrAmount == 0) return;\n\n        // ==== Transfer RSR from the draft pool\n        totalDrafts = newTotalDrafts;\n        draftRSR = newDraftRSR;\n\n        emit UnstakingCompleted(firstId, endId, draftEra, account, rsrAmount);\n\n        // == Interaction ==\n        IERC20Upgradeable(address(rsr)).safeTransfer(account, rsrAmount);\n    }\n\n    /// @param rsrAmount {qRSR}\n    /// Must seize at least `rsrAmount`, or revert\n    /// @custom:protected\n    // let:\n    //   keepRatio = 1 - (rsrAmount / rsr.balanceOf(this))\n    //\n    // checks:\n    //   0 < rsrAmount <= rsr.balanceOf(this)\n    //   not paused or frozen\n    //   caller is backingManager\n    //\n    // effects, in two phases. Phase 1: (from x to x')\n    //   stakeRSR' = floor(stakeRSR * keepRatio)\n    //   totalStakes' = totalStakes\n    //   stakeRate' = ceil(totalStakes' * 1e18 / stakeRSR')\n    //\n    //   draftRSR' = floor(draftRSR * keepRatio)\n    //   totalDrafts' = totalDrafts\n    //   draftRate' = ceil(totalDrafts' * 1e18 / draftRSR')\n    //\n    //   let fromRewards = floor(rsrRewards() * (1 - keepRatio))\n    //\n    // effects phase 2: (from x' to x'')\n    //   draftRSR'' = (draftRSR' <= MAX_DRAFT_RATE) ? draftRSR' : 0\n    //   if draftRSR'' = 0, then totalDrafts'' = 0 and draftRate'' = FIX_ONE\n    //   stakeRSR'' = (stakeRSR' <= MAX_STAKE_RATE) ? stakeRSR' : 0\n    //   if stakeRSR'' = 0, then totalStakes'' = 0 and stakeRate'' = FIX_ONE\n    //\n    // actions:\n    //   as (this), rsr.transfer(backingManager, seized)\n    //   where seized = draftRSR - draftRSR'' + stakeRSR - stakeRSR'' + fromRewards\n    //\n    // other properties:\n    //   seized >= rsrAmount, which should be a logical consequence of the above effects\n\n    function seizeRSR(uint256 rsrAmount) external notPausedOrFrozen {\n        require(_msgSender() == address(backingManager), \"not backing manager\");\n        require(rsrAmount > 0, \"Amount cannot be zero\");\n        uint192 initRate = exchangeRate();\n\n        uint256 rsrBalance = rsr.balanceOf(address(this));\n        require(rsrAmount <= rsrBalance, \"Cannot seize more RSR than we hold\");\n\n        uint256 seizedRSR;\n        uint256 rewards = rsrRewards();\n\n        // Remove RSR from stakeRSR\n        uint256 stakeRSRToTake = (stakeRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n        stakeRSR -= stakeRSRToTake;\n        seizedRSR = stakeRSRToTake;\n\n        // update stakeRate, possibly beginning a new stake era\n        if (stakeRSR > 0) {\n            // Downcast is safe: totalStakes is 1e38 at most so expression maximum value is 1e56\n            stakeRate = uint192((FIX_ONE_256 * totalStakes + (stakeRSR - 1)) / stakeRSR);\n        }\n        if (stakeRSR == 0 || stakeRate > MAX_STAKE_RATE) {\n            seizedRSR += stakeRSR;\n            beginEra();\n        }\n\n        // Remove RSR from draftRSR\n        uint256 draftRSRToTake = (draftRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n        draftRSR -= draftRSRToTake;\n        seizedRSR += draftRSRToTake;\n\n        // update draftRate, possibly beginning a new draft era\n        if (draftRSR > 0) {\n            // Downcast is safe: totalDrafts is 1e38 at most so expression maximum value is 1e56\n            draftRate = uint192((FIX_ONE_256 * totalDrafts + (draftRSR - 1)) / draftRSR);\n        }\n\n        if (draftRSR == 0 || draftRate > MAX_DRAFT_RATE) {\n            seizedRSR += draftRSR;\n            beginDraftEra();\n        }\n\n        // Remove RSR from yet-unpaid rewards (implicitly)\n        seizedRSR += (rewards * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n\n        // Transfer RSR to caller\n        emit ExchangeRateSet(initRate, exchangeRate());\n        IERC20Upgradeable(address(rsr)).safeTransfer(_msgSender(), seizedRSR);\n    }\n\n    /// @return D18{qRSR/qStRSR} The exchange rate between RSR and StRSR\n    function exchangeRate() public view returns (uint192) {\n        // D18{qRSR/qStRSR} = D18 * D18 / D18{qStRSR/qRSR}\n        return (FIX_SCALE_SQ + (stakeRate / 2)) / stakeRate; // ROUND method\n    }\n\n    /// Return the maximum value of endId such that withdraw(endId) can immediately work\n    // let r = draft[account]\n    // returns:\n    //   if r.left == r.right: r.right (i.e, withdraw 0 drafts)\n    //   else: the least id such that r.left <= id <= r.right and r.queue[id].availableAt > now\n    function endIdForWithdraw(address account) external view returns (uint256) {\n        uint256 time = block.timestamp;\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n\n        // Bounds our search for the current cumulative draft\n        (uint256 left, uint256 right) = (firstRemainingDraft[draftEra][account], queue.length);\n\n        // If there are no drafts to be found, return 0 drafts\n        if (left >= right) return right;\n        if (queue[left].availableAt > time) return left;\n\n        // Otherwise, there *are* drafts with left <= index < right and availableAt <= time.\n        // Binary search:\n        uint256 test;\n        while (left < right - 1) {\n            // Loop invariants, because without great care a binary search is usually wrong:\n            // - queue[left].availableAt <= time\n            // - either right == queue.length or queue[right].availableAt > time\n            test = (left + right) / 2; // left < test < right because left < right - 1\n            if (queue[test].availableAt <= time) left = test;\n            else right = test;\n        }\n        return right;\n    }\n\n    /// Used by FacadeP1\n    /// @return The length of the draft queue for an account in an era\n    function draftQueueLen(uint256 era_, address account) external view returns (uint256) {\n        return draftQueues[era_][account].length;\n    }\n\n    // ==== Internal Functions ====\n\n    /// Assign reward payouts to the staker pool\n    /// @dev do this by effecting stakeRSR and payoutLastPaid as appropriate, given the current\n    /// value of rsrRewards()\n    /// @dev perhaps astonishingly, this _isn't_ a refresher\n\n    // let\n    //   N = numPeriods; the number of whole rewardPeriods since the last payout\n    //   payout = rsrRewards() * (1 - (1 - rewardRatio)^N)  (see [strsr-payout-formula])\n    //\n    // effects:\n    //   stakeRSR' = stakeRSR + payout\n    //   rsrRewards'() = rsrRewards() - payout   (implicit in the code, but true)\n    //   stakeRate' = ceil(totalStakes' * 1e18 / stakeRSR')  (because [stake-rate])\n    //     unless totalStakes == 0 or stakeRSR == 0, in which case stakeRate' = FIX_ONE\n    //   totalStakes' = totalStakes\n    //\n    // [strsr-payout-formula]:\n    //   The process we're modelling is:\n    //     N = number of whole rewardPeriods since last _payoutRewards() call\n    //     rewards_0 = rsrRewards()\n    //     payout_{i+1} = rewards_i * payoutRatio\n    //     rewards_{i+1} = rewards_i - payout_{i+1}\n    //     payout = sum{payout_i for i in [1...N]}\n    //   thus:\n    //     rewards_N = rewards_0 - payout\n    //     rewards_{i+1} = rewards_i - rewards_i * payoutRatio = rewards_i * (1-payoutRatio)\n    //     rewards_N = rewards_0 * (1-payoutRatio) ^ N\n    //     payout = rewards_N - rewards_0 = rewards_0 * (1 - (1-payoutRatio)^N)\n    function _payoutRewards() internal {\n        if (block.timestamp < payoutLastPaid + rewardPeriod) return;\n        uint48 numPeriods = (uint48(block.timestamp) - payoutLastPaid) / rewardPeriod;\n\n        uint192 initRate = exchangeRate();\n        uint256 payout;\n\n        // Do an actual payout if and only if stakers exist!\n        if (totalStakes > 0) {\n            // Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.\n            // Apply payout to RSR backing\n            // payoutRatio: D18 = FIX_ONE: D18 - FixLib.powu(): D18\n            // Both uses of uint192(-) are fine, as it's equivalent to FixLib.sub().\n            uint192 payoutRatio = FIX_ONE - FixLib.powu(FIX_ONE - rewardRatio, numPeriods);\n\n            // payout: {qRSR} = D18{1} * {qRSR} / D18\n            payout = (payoutRatio * rsrRewardsAtLastPayout) / FIX_ONE;\n            stakeRSR += payout;\n        }\n\n        payoutLastPaid += numPeriods * rewardPeriod;\n        rsrRewardsAtLastPayout = rsrRewards();\n\n        // stakeRate else case: D18{qStRSR/qRSR} = {qStRSR} * D18 / {qRSR}\n        // downcast is safe: it's at most 1e38 * 1e18 = 1e56\n        // untestable:\n        //      the second half of the OR comparison is untestable because of the invariant:\n        //      if totalStakes == 0, then stakeRSR == 0\n        stakeRate = (stakeRSR == 0 || totalStakes == 0)\n            ? FIX_ONE\n            : uint192((totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR);\n\n        emit RewardsPaid(payout);\n        emit ExchangeRateSet(initRate, exchangeRate());\n    }\n\n    /// @param rsrAmount {qRSR}\n    /// @return index The index of the draft\n    /// @return availableAt {s} The timestamp the cumulative draft vests\n    // effects:\n    //   draftRSR' = draftRSR + rsrAmount\n    //   draftRate' = draftRate    (ie, unchanged)\n    //   totalDrafts' = floor(draftRSR' * draftRate' / 1e18)\n    //   r'.left = r.left\n    //   r'.right = r.right + 1\n    //   r'.queue is r.queue with a new entry appeneded for (totalDrafts' - totalDraft) drafts\n    //   where r = draft[account] and r' = draft'[account]\n    function pushDraft(address account, uint256 rsrAmount)\n        internal\n        returns (uint256 index, uint64 availableAt)\n    {\n        // draftAmount: how many drafts to create and assign to the user\n        // pick draftAmount as big as we can such that (newTotalDrafts <= newDraftRSR * draftRate)\n        draftRSR += rsrAmount;\n        // newTotalDrafts: {qDrafts} = D18{qDrafts/qRSR} * {qRSR} / D18\n        uint256 newTotalDrafts = (draftRate * draftRSR) / FIX_ONE;\n        uint256 draftAmount = newTotalDrafts - totalDrafts;\n        totalDrafts = newTotalDrafts;\n\n        // Push drafts into account's draft queue\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n        index = queue.length;\n\n        uint192 oldDrafts = index > 0 ? queue[index - 1].drafts : 0;\n        uint64 lastAvailableAt = index > 0 ? queue[index - 1].availableAt : 0;\n        availableAt = uint64(block.timestamp) + unstakingDelay;\n        if (lastAvailableAt > availableAt) {\n            availableAt = lastAvailableAt;\n        }\n\n        queue.push(CumulativeDraft(uint176(oldDrafts + draftAmount), availableAt));\n    }\n\n    /// Zero all stakes and withdrawals\n    /// Overriden in StRSRVotes to handle rebases\n    // effects:\n    //   stakeRSR' = totalStakes' = 0\n    //   stakeRate' = FIX_ONE\n    function beginEra() internal virtual {\n        stakeRSR = 0;\n        totalStakes = 0;\n        stakeRate = FIX_ONE;\n        era++;\n\n        emit AllBalancesReset(era);\n    }\n\n    // effects:\n    //  draftRSR' = totalDrafts' = 0\n    //  draftRate' = FIX_ONE\n    function beginDraftEra() internal virtual {\n        draftRSR = 0;\n        totalDrafts = 0;\n        draftRate = FIX_ONE;\n        draftEra++;\n\n        emit AllUnstakingReset(draftEra);\n    }\n\n    /// @return {qRSR} The balance of RSR that this contract owns dedicated to future RSR rewards.\n    function rsrRewards() internal view returns (uint256) {\n        return rsr.balanceOf(address(this)) - stakeRSR - draftRSR;\n    }\n\n    // ==== ERC20 ====\n    // This section extracted from ERC20; adjusted to work with stakes/eras\n    // name(), symbol(), and decimals() are all auto-generated\n\n    function totalSupply() public view returns (uint256) {\n        return totalStakes;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return stakes[era][account];\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[era][owner][spender];\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        _spendAllowance(from, _msgSender(), amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[era][owner][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[era][owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    // checks: from != 0, to != 0,\n    // effects: bal[from] -= amount; bal[to] += amount;\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        mapping(address => uint256) storage eraStakes = stakes[era];\n        uint256 fromBalance = eraStakes[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            eraStakes[from] = fromBalance - amount;\n        }\n        eraStakes[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    // checks: account != 0; totalStakes' < 2^224 - 1  (for StRSRVotes)\n    // effects: bal[account] += amount; totalStakes += amount\n    // this must only be called from a function that will fixup stakeRSR/Rate\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        assert(totalStakes + amount < type(uint224).max);\n\n        stakes[era][account] += amount;\n        totalStakes += amount;\n\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    // checks: account != 0; bal[account] >= amount\n    // effects: bal[account] -= amount; totalStakes -= amount;\n    // this must only be called from a function that will fixup stakeRSR/Rate\n    function _burn(address account, uint256 amount) internal virtual {\n        // untestable:\n        //      _burn is only called from unstake(), which uses msg.sender as `account`\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        mapping(address => uint256) storage eraStakes = stakes[era];\n        uint256 accountBalance = eraStakes[account];\n        // untestable:\n        //      _burn is only called from unstake(), which already checks this\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            eraStakes[account] = accountBalance - amount;\n        }\n        totalStakes -= amount;\n\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[era][owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 currentAllowance = _allowances[era][owner][spender];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /// Used by StRSRVotes to track voting\n    // solhint-disable no-empty-blocks\n    function _afterTokenTransfer(\n        address,\n        address to,\n        uint256\n    ) internal virtual {\n        require(to != address(this), \"StRSR transfer to self\");\n    }\n\n    // === ERC20Permit ===\n    // This section extracted from OZ:ERC20PermitUpgradeable\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\n        );\n\n        PermitLib.requireSignature(owner, _hashTypedDataV4(structHash), v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    function nonces(address owner) public view returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function _useNonce(address owner) internal returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    // ==== Gov Param Setters ====\n\n    function setName(string calldata name_) external governance {\n        name = name_;\n    }\n\n    function setSymbol(string calldata symbol_) external governance {\n        symbol = symbol_;\n    }\n\n    /// @custom:governance\n    function setUnstakingDelay(uint48 val) public gove"
    }
  ]
}