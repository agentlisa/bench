{
  "Title": "[M-04] `safeSymbol()` can revert causing DoS",
  "Content": "_Submitted by sirhashalot_\n\nThe `safeSymbol()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `symbol()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `symbol()` function should return a string and not revert.\n\nThe root cause of the issue is that the `safeSymbol()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `symbol()` functions in the Timeswap ERC20 contracts to revert.\n\nBecause this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeSymbol()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeSymbol()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name:\n<https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39>\n\n#### Proof of Concept\n\nThe root cause is [line 20](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L20)  of the `safeSymbol()` function in SafeMetadata.sol\n\nThe `safeSymbol()` function is called in:\n\n*   [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L27-L31)\n*   [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L38-L42)\n*   [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L29-L33)\n*   [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L31-L35)\n\n#### Recommended Mitigation Steps\n\nUse the BoringCrypto `safeSymbol()` function code with the `returnDataToString()` parsing function to handle the case of a bytes32 return value:\n<https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39>\n\n**[Mathepreneur (Timeswap) confirmed and resolved](https://github.com/code-423n4/2022-01-timeswap-findings/issues/114):**\n > https://github.com/Timeswap-Labs/Timeswap-V1-Convenience/pull/59\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-timeswap",
  "Code": [
    {
      "filename": "contracts/libraries/BoringERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while (i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to check.\n    /// @return amount The token amount.\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\n        require(success && data.length >= 32, \"BoringERC20: BalanceOf failed\");\n        amount = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\nlibrary SafeMetadata {\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(IERC20Metadata.name.selector)\n        );\n        if (success) return abi.decode(data, (string));\n        return 'Token';\n    }\n\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(IERC20Metadata.symbol.selector)\n        );\n        if (success) return abi.decode(data, (string));\n        return 'TKN';\n    }\n\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\n        );\n        if (success && data.length >= 32) return abi.decode(data, (uint8));\n        return 18;\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IClaim} from './interfaces/IClaim.sol';\nimport {IConvenience} from './interfaces/IConvenience.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {ERC20Permit} from './base/ERC20Permit.sol';\nimport {SafeMetadata} from './libraries/SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\n\ncontract Bond is IClaim, ERC20Permit {\n    using SafeMetadata for IERC20;\n    using Strings for uint256;\n\n    IConvenience public immutable override convenience;\n    IPair public immutable override pair;\n    uint256 public immutable override maturity;\n\n    function name() external view override returns (string memory) {\n        string memory assetName = pair.asset().safeName();\n        string memory collateralName = pair.collateral().safeName();\n        return\n            string(abi.encodePacked('Timeswap Bond - ', assetName, ' - ', collateralName, ' - ', maturity.toString()));\n    }\n\n    function symbol() external view override returns (string memory) {\n        string memory assetSymbol = pair.asset().safeSymbol();\n        string memory collateralSymbol = pair.collateral().safeSymbol();\n        return string(abi.encodePacked('TS-BND-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));\n    }\n\n    function decimals() external view override returns (uint8) {\n        return pair.asset().safeDecimals();\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return pair.claimsOf(maturity, address(this)).bond;\n    }\n\n    constructor(\n        IConvenience _convenience,\n        IPair _pair,\n        uint256 _maturity\n    ) ERC20Permit('Timeswap Bond') {\n        convenience = _convenience;\n        pair = _pair;\n        maturity = _maturity;\n    }\n\n    modifier onlyConvenience() {\n        require(msg.sender == address(convenience), 'E403');\n        _;\n    }\n\n    function mint(address to, uint128 amount) external override onlyConvenience {\n        _mint(to, amount);\n    }\n\n    function burn(\n        address from,\n        address to,\n        uint128 amount\n    ) external override onlyConvenience returns (uint128 tokenOut) {\n        _burn(from, amount);\n\n        tokenOut = pair.withdraw(maturity, to, to, IPair.Claims(amount, 0)).asset;\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IDue} from './interfaces/IDue.sol';\nimport {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport {IConvenience} from './interfaces/IConvenience.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC721Permit} from './base/ERC721Permit.sol';\nimport {SafeMetadata} from './libraries/SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {NFTTokenURIScaffold} from './libraries/NFTTokenURIScaffold.sol';\n\ncontract CollateralizedDebt is IDue, ERC721Permit {\n    using Strings for uint256;\n    using SafeMetadata for IERC20;\n\n    IConvenience public immutable override convenience;\n    IPair public immutable override pair;\n    uint256 public immutable override maturity;\n\n    function name() external view override returns (string memory) {\n        string memory assetName = pair.asset().safeName();\n        string memory collateralName = pair.collateral().safeName();\n        return\n            string(\n                abi.encodePacked(\n                    'Timeswap Collateralized Debt - ',\n                    assetName,\n                    ' - ',\n                    collateralName,\n                    ' - ',\n                    maturity.toString()\n                )\n            );\n    }\n\n    function symbol() external view override returns (string memory) {\n        string memory assetSymbol = pair.asset().safeSymbol();\n        string memory collateralSymbol = pair.collateral().safeSymbol();\n        return string(abi.encodePacked('TS-CDT-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));\n    }\n\n    function tokenURI(uint256 id) external view override returns (string memory) {\n        require(ownerOf[id] != address(0), 'E404');\n        return NFTTokenURIScaffold.tokenURI(id, pair, dueOf(id), maturity);\n    }\n\n    function assetDecimals() external view override returns (uint8) {\n        return pair.asset().safeDecimals();\n    }\n\n    function collateralDecimals() external view override returns (uint8) {\n        return pair.collateral().safeDecimals();\n    }\n\n    function dueOf(uint256 id) public view override returns (IPair.Due memory) {\n        return pair.dueOf(maturity, address(this), id);\n    }\n\n    constructor(\n        IConvenience _convenience,\n        IPair _pair,\n        uint256 _maturity\n    ) ERC721Permit('Timeswap Collateralized Debt') {\n        convenience = _convenience;\n        pair = _pair;\n        maturity = _maturity;\n    }\n\n    modifier onlyConvenience() {\n        require(msg.sender == address(convenience), 'E403');\n        _;\n    }\n\n    function mint(address to, uint256 id) external override onlyConvenience {\n        _safeMint(to, id);\n    }\n\n    function burn(\n        address to,\n        uint256[] memory ids,\n        uint112[] memory assetsIn,\n        uint112[] memory collateralsOut,\n        bytes calldata data\n    ) external override onlyConvenience returns (uint128 assetIn, uint128 collateralOut) {\n        (assetIn, collateralOut) = pair.pay(maturity, to, address(this), ids, assetsIn, collateralsOut, data);\n    }\n\n    function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {\n        require(msg.sender == address(pair), 'E401');\n\n        convenience.collateralizedDebtCallback(pair, maturity, assetIn, data);\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IClaim} from './interfaces/IClaim.sol';\nimport {IConvenience} from './interfaces/IConvenience.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {ERC20Permit} from './base/ERC20Permit.sol';\nimport {SafeMetadata} from './libraries/SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\n\ncontract Insurance is IClaim, ERC20Permit {\n    using SafeMetadata for IERC20;\n    using Strings for uint256;\n\n    IConvenience public immutable override convenience;\n    IPair public immutable override pair;\n    uint256 public immutable override maturity;\n\n    function name() external view override returns (string memory) {\n        string memory assetName = pair.asset().safeName();\n        string memory collateralName = pair.collateral().safeName();\n        return\n            string(\n                abi.encodePacked('Timeswap Insurance - ', assetName, ' - ', collateralName, ' - ', maturity.toString())\n            );\n    }\n\n    function symbol() external view override returns (string memory) {\n        string memory assetSymbol = pair.asset().safeSymbol();\n        string memory collateralSymbol = pair.collateral().safeSymbol();\n        return string(abi.encodePacked('TS-INS-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));\n    }\n\n    function decimals() external view override returns (uint8) {\n        return pair.collateral().safeDecimals();\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return pair.claimsOf(maturity, address(this)).insurance;\n    }\n\n    constructor(\n        IConvenience _convenience,\n        IPair _pair,\n        uint256 _maturity\n    ) ERC20Permit('Timeswap Insurance') {\n        convenience = _convenience;\n        pair = _pair;\n        maturity = _maturity;\n    }\n\n    modifier onlyConvenience() {\n        require(msg.sender == address(convenience), 'E403');\n        _;\n    }\n\n    function mint(address to, uint128 amount) external override onlyConvenience {\n        _mint(to, amount);\n    }\n\n    function burn(\n        address from,\n        address to,\n        uint128 amount\n    ) external override onlyConvenience returns (uint128 tokenOut) {\n        _burn(from, amount);\n\n        tokenOut = pair.withdraw(maturity, to, to, IPair.Claims(0, amount)).collateral;\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {ILiquidity} from './interfaces/ILiquidity.sol';\nimport {IConvenience} from './interfaces/IConvenience.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {ERC20Permit} from './base/ERC20Permit.sol';\nimport {SafeMetadata} from './libraries/SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\n\ncontract Liquidity is ILiquidity, ERC20Permit {\n    using SafeMetadata for IERC20;\n    using Strings for uint256;\n\n    IConvenience public immutable override convenience;\n    IPair public immutable override pair;\n    uint256 public immutable override maturity;\n\n    uint8 public constant override decimals = 18;\n\n    function name() external view override returns (string memory) {\n        string memory assetName = pair.asset().safeName();\n        string memory collateralName = pair.collateral().safeName();\n        return\n            string(\n                abi.encodePacked('Timeswap Liquidity - ', assetName, ' - ', collateralName, ' - ', maturity.toString())\n            );\n    }\n\n    function symbol() external view override returns (string memory) {\n        string memory assetSymbol = pair.asset().safeSymbol();\n        string memory collateralSymbol = pair.collateral().safeSymbol();\n        return string(abi.encodePacked('TS-LIQ-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return pair.liquidityOf(maturity, address(this));\n    }\n\n    constructor(\n        IConvenience _convenience,\n        IPair _pair,\n        uint256 _maturity\n    ) ERC20Permit('Timeswap Liquidity') {\n        convenience = _convenience;\n        pair = _pair;\n        maturity = _maturity;\n    }\n\n    modifier onlyConvenience() {\n        require(msg.sender == address(convenience), 'E403');\n        _;\n    }\n\n    function mint(address to, uint256 amount) external override onlyConvenience {\n        _mint(to, amount);\n    }\n\n    function burn(\n        address from,\n        address assetTo,\n        address collateralTo,\n        uint256 amount\n    ) external override onlyConvenience returns (IPair.Tokens memory tokensOut) {\n        _burn(from, amount);\n\n        tokensOut = pair.burn(maturity, assetTo, collateralTo, amount);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/BoringERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while (i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to check.\n    /// @return amount The token amount.\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\n        require(success && data.length >= 32, \"BoringERC20: BalanceOf failed\");\n        amount = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}"
    }
  ]
}