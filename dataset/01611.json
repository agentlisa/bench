{
  "Title": "H-7: Liquidation can be blocked by incrementing the nonce",
  "Content": "# Issue H-7: Liquidation can be blocked by incrementing the nonce \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/233 \n\n## Found by \n0xcrunch, AkshaySrivastav, Jiamin, Juntao, Ruhum, berndartmueller, bin2chen, cergyk, circlelooper, mstpr-brainbot, nobody2018, p0wd3r, rvierdiiev, shaka, simon135, volodya, xiaoming90\n## Summary\n\nMalicious users could block liquidators from liquidating their accounts, which creates unfairness in the system and lead to a loss of profits to the counterparty.\n\n## Vulnerability Detail\n\n#### Instance 1 - Blocking liquidation of PartyA\n\nA liquidatable PartyA can block liquidators from liquidating its account.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L20\n\n```solidity\nFile: LiquidationFacetImpl.sol\n20:     function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n21:         MAStorage.Layout storage maLayout = MAStorage.layout();\n22: \n23:         LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n24:         int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n25:             upnlSig.upnl,\n26:             partyA\n27:         );\n28:         require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n29:         maLayout.liquidationStatus[partyA] = true;\n30:         maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n31:         AccountStorage.layout().liquidators[partyA].push(msg.sender);\n32:     }\n```\n\nWithin the `liquidatePartyA` function, it calls the `LibMuon.verifyPartyAUpnl` function.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibMuon.sol#L87\n\n```solidity\nFile: LibMuon.sol\n087:     function verifyPartyAUpnl(SingleUpnlSig memory upnlSig, address partyA) internal view {\n088:         MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n089: //        require(\n090: //            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n091: //            \"LibMuon: Expired signature\"\n092: //        );\n093:         bytes32 hash = keccak256(\n094:             abi.encodePacked(\n095:                 muonLayout.muonAppId,\n096:                 upnlSig.reqId,\n097:                 address(this),\n098:                 partyA,\n099:                 AccountStorage.layout().partyANonces[partyA],\n100:                 upnlSig.upnl,\n101:                 upnlSig.timestamp,\n102:                 getChainId()\n103:             )\n104:         );\n105:         verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n106:     }\n```\n\nThe `verifyPartyAUpnl` function will take the current nonce of PartyA (`AccountStorage.layout().partyANonces[partyA]`) to build the hash needed for verification.\n\nWhen the PartyA becomes liquidatable or near to becoming liquidatable, it could start to monitor the mempool for any transaction that attempts to liquidate their accounts. Whenever a liquidator submits a `liquidatePartyA` transaction to liquidate their accounts, they could front-run it and submit a transaction to increment their nonce. When the liquidator's transaction is executed, the on-chain PartyA's nonce will differ from the nonce in the signature, and the liquidation transaction will revert.\n\nFor those chains that do not have a public mempool, they can possibly choose to submit a transaction that increments their nonce in every block as long as it is economically feasible to obtain the same result. \n\nGas fees that PartyA spent might be cheap compared to the number of assets they will lose if their account is liquidated. Additionally, gas fees are cheap on L2 or side-chain (The protocol intended to support Arbitrum One, Arbitrum Nova, Fantom, Optimism, BNB chain, Polygon, Avalanche as per the contest details).\n\nThere are a number of methods for PartyA to increment their nonce, this includes but not limited to the following:\n\n- Allocate or deallocate dust amount\n- Lock and unlock the dummy position\n- Calls `requestToClosePosition` followed by `requestToCancelCloseRequest` immediately\n\n#### Instance 2 - Blocking liquidation of PartyB\n\nThe same exploit can be used to block the liquidation of PartyB since the `liquidatePartyB` function also relies on the `LibMuon.verifyPartyBUpnl,` which uses the on-chain nonce of PartyB for signature verification.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L240\n\n```solidity\nFile: LiquidationFacetImpl.sol\n240:     function liquidatePartyB(\n..SNIP..\n249:         LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n```\n\n## Impact\n\nPartyA can block their accounts from being liquidated by liquidators. With the ability to liquidate the insolvent PartyA, the unrealized profits of all PartyBs cannot be realized, and thus they will not be able to withdraw the profits.\n\nPartyA could also exploit this issue to block their account from being liquidated to:\n\n- Wait for their positions to recover to reduce their losses\n- Buy time to obtain funds from elsewhere to inject into their accounts to bring the account back to a healthy level\n\nSince this is a zero-sum game, the above-mentioned create unfairness to PartyB and reduce their profits.\n\nThe impact is the same for the blocking of PartyB liquidation.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L20\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L240\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn most protocols, whether an account is liquidatable is determined on-chain, and this issue will not surface. However, the architecture of Symmetrical protocol relies on off-chain and on-chain components to determine if an account is liquidatable, which can introduce a number of race conditions such as the one mentioned in this report. \n\nConsider reviewing the impact of malicious users attempting to increment the nonce in order to block certain actions in the protocols since most functions rely on the fact that the on-chain nonce must be in sync with the signature's nonce and update the architecture/contracts of the protocol accordingly.\n\n\n\n## Discussion\n\n**KuTuGu**\n\nEscalate\nThis is a DOS grief attack, which is invalid according to sherlock's criteria.\n> Could Denial-of-Service (DOS), griefing, or locking of contracts count as a Medium (or High) issue? It would not count if the DOS, etc. lasts a known, finite amount of time <1 year. If it will result in funds being inaccessible for >=1 year, then it would count as a loss of funds and be eligible for a Medium or High designation. The greater the cost of the attack for an attacker, the less severe the issue becomes.\n\nAnd it's not like a locked offer where partA has to wait for a cool period of to cancel lock. The liquidator can send the liquidation request again immediately after partA maliciously adds the nonce, and it is nearly impossible to prevent the liquidation continuously.\n\n**sherlock-admin2**\n\n > Escalate\n> This is a DOS grief attack, which is invalid according to sherlock's criteria.\n> > Could Denial-of-Service (DOS), griefing, or locking of contracts count as a Medium (or High) issue? It would not count if the DOS, etc. lasts a known, finite amount of time <1 year. If it will result in funds being inaccessible for >=1 year, then it would count as a loss of funds and be eligible for a Medium or High designation. The greater the cost of the attack for an attacker, the less severe the issue becomes.\n> \n> And it's not like a locked offer where partA has to wait for a cool period of to cancel lock. The liquidator can send the liquidation request again immediately after partA maliciously adds the nonce, and it is nearly impossible to prevent the liquidation continuously.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**JeffCX**\n\n> And it's not like a locked offer where partA has to wait for a cool period of to cancel lock. The liquidator can send the liquidation request again immediately after partA maliciously adds the nonce, and it is nearly impossible to prevent the liquidation continuously.\n\nThen the party A can increment nonce again:\n\n> There are a number of methods for PartyA to increment their nonce, this includes but not limited to the following:\n\n> Allocate or deallocate dust amount\n> Lock and unlock the dummy position\n> Calls requestToClosePosition followed by requestToCancelCloseRequest immediately\n\nRecommend maintaining high severity\n\n**KuTuGu**\n\nThis is why DOS is invalid, anyone can send a transaction again, unless DOS can be in effect for a year, otherwise it should be considered invalid due to the huge cost.\n\n**juntzhan**\n\nBy increasing nonce, PartyA is actually buying himself the time to get account back to health level (front-run to deposit more funds), then he won't be liquidated by anyone and that's how liquidator is DOSed.\nAs liquidation is a core function of this protocol, this issue should be a valid high.\n\n**hrishibhat**\n\n@KuTuGu \n\n**KuTuGu**\n\nI don't think the duration of DOS can affect the liquidation:\n1. Malicious users must DOS each block to avoid liquidation, which is costly and will not last long;\n2. If users have the ability to frontrun to DOS the liquidation, they are more likely to liquidate themselves or repay their loans, rather than the continued pointless DOS\n\n \n\n**securitygrid**\n\nMalicious user can DOS the liquidation by frontrun until he can make a profit.\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nI think the DOS rule is misinterpreted. The DOS rule of 1 year is considered for only related to access to locked funds that does not affect the normal contract functioning. \nIn this case, the severity is clearly high as this affects normal functioning resulting in losses as shown in the issue and duplicates. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [kutugu](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/233/#issuecomment-1653618473): rejected\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/22\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary LiquidationFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyA\n        );\n        require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n        maLayout.liquidationStatus[partyA] = true;\n        maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    }\n\n    function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        LibMuon.verifyPrices(priceSig, partyA);\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        require(\n            priceSig.timestamp <=\n                maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n            accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n                priceSig.prices[index],\n                maLayout.liquidationTimestamp[partyA]\n            );\n        }\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            priceSig.upnl,\n            partyA\n        );\n        if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n            accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n                liquidationType: LiquidationType.NONE,\n                upnl: priceSig.upnl,\n                totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n                deficit: 0,\n                liquidationFee: 0\n            });\n            if (availableBalance >= 0) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf -\n                    uint256(-availableBalance);\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (\n                uint256(-availableBalance) <=\n                accountLayout.lockedBalances[partyA].lf + accountLayout.lockedBalances[partyA].cva\n            ) {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.LATE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            } else {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf -\n                    accountLayout.lockedBalances[partyA].cva;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.OVERDUE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            }\n            AccountStorage.layout().liquidators[partyA].push(msg.sender);\n        } else {\n            require(\n                accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n                    accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n                    priceSig.totalUnrealizedLoss,\n                \"LiquidationFacet: Invalid upnl sig\"\n            );\n        }\n    }\n\n    function liquidatePendingPositionsPartyA(address partyA) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        require(\n            MAStorage.layout().liquidationStatus[partyA],\n            \"LiquidationFacet: PartyA is solvent\"\n        );\n        for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n            Quote storage quote = quoteLayout.quotes[\n                quoteLayout.partyAPendingQuotes[partyA][index]\n            ];\n            if (\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n                quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n            ) {\n                delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n                AccountStorage\n                .layout()\n                .partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n            }\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n        AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n        delete quoteLayout.partyAPendingQuotes[partyA];\n    }\n\n    function liquidatePositionsPartyA(\n        address partyA,\n        uint256[] memory quoteIds\n    ) internal returns (bool) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        for (uint256 index = 0; index < quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(quote.partyA == partyA, \"LiquidationFacet: Invalid party\");\n            require(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].timestamp ==\n                    maLayout.liquidationTimestamp[partyA],\n                \"LiquidationFacet: Price should be set\"\n            );\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].price,\n                LibQuote.quoteOpenAmount(quote),\n                quote\n            );\n            if (hasMadeProfit) {\n                accountLayout.totalUnplForLiquidation[partyA] += int256(amount);\n            } else {\n                accountLayout.totalUnplForLiquidation[partyA] -= int256(amount);\n            }\n\n            if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote\n                    .lockedValues\n                    .cva;\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.LATE\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                    quote.lockedValues.cva -\n                    ((quote.lockedValues.cva * accountLayout.liquidationDetails[partyA].deficit) /\n                        accountLayout.lockedBalances[partyA].cva);\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.OVERDUE\n            ) {\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                        amount -\n                        ((amount * accountLayout.liquidationDetails[partyA].deficit) /\n                            uint256(-accountLayout.liquidationDetails[partyA].totalUnrealizedLoss));\n                }\n            }\n            accountLayout.partyBLockedBalances[quote.partyB][partyA].subQuote(quote);\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    accountLayout.symbolsPrices[partyA][quote.symbolId].price) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][partyA] -= 1;\n        }\n        if (quoteLayout.partyAPositionsCount[partyA] == 0) {\n            require(\n                quoteLayout.partyAPendingQuotes[partyA].length == 0,\n                \"LiquidationFacet: Pending quotes should be liquidated first\"\n            );\n            accountLayout.allocatedBalances[partyA] = 0;\n            accountLayout.lockedBalances[partyA].makeZero();\n\n            uint256 lf = accountLayout.liquidationDetails[partyA].liquidationFee;\n            if (lf > 0) {\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][0]] += lf / 2;\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][1]] += lf / 2;\n            }\n            delete accountLayout.liquidators[partyA];\n            maLayout.liquidationStatus[partyA] = false;\n            maLayout.liquidationTimestamp[partyA] = 0;\n            accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NONE;\n            if (\n                accountLayout.totalUnplForLiquidation[partyA] !=\n                accountLayout.liquidationDetails[partyA].upnl\n            ) {\n                accountLayout.totalUnplForLiquidation[partyA] = 0;\n                return false;\n            }\n            accountLayout.totalUnplForLiquidation[partyA] = 0;\n        }\n        return true;\n    }\n\n    function liquidatePartyB(\n        address partyB,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyB,\n            partyA\n        );\n\n        require(availableBalance < 0, \"LiquidationFacet: partyB is solvent\");\n        uint256 liquidatorShare;\n        uint256 remainingLf;\n        if (uint256(-availableBalance) < accountLayout.partyBLockedBalances[partyB][partyA].lf) {\n            remainingLf =\n                accountLayout.partyBLockedBalances[partyB][partyA].lf -\n                uint256(-availableBalance);\n            liquidatorShare = (remainingLf * maLayout.liquidatorShare) / 1e18;\n\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] =\n                (remainingLf - liquidatorShare) /\n                quoteLayout.partyBPositionsCount[partyB][partyA];\n        } else {\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = 0;\n        }\n\n        maLayout.partyBLiquidationStatus[partyB][partyA] = true;\n        maLayout.partyBLiquidationTimestamp[partyB][partyA] = upnlSig.timestamp;\n\n        uint256[] storage pendingQuotes = quoteLayout.partyAPendingQuotes[partyA];\n\n        for (uint256 index = 0; index < pendingQuotes.length; ) {\n            Quote storage quote = quoteLayout.quotes[pendingQuotes[index]];\n            if (\n                quote.partyB == partyB &&\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING)\n            ) {\n                accountLayout.pendingLockedBalances[partyA].subQuote(quote);\n\n                pendingQuotes[index] = pendingQuotes[pendingQuotes.length - 1];\n                pendingQuotes.pop();\n                quote.quoteStatus = QuoteStatus.LIQUIDATED;\n                quote.modifyTimestamp = block.timestamp;\n            } else {\n                index++;\n            }\n        }\n        accountLayout.allocatedBalances[partyA] +=\n            accountLayout.partyBAllocatedBalances[partyB][partyA] -\n            remainingLf;\n\n        delete quoteLayout.partyBPendingQuotes[partyB][partyA];\n        accountLayout.partyBAllocatedBalances[partyB][partyA] = 0;\n        accountLayout.partyBLockedBalances[partyB][partyA].makeZero();\n        accountLayout.partyBPendingLockedBalances[partyB][partyA].makeZero();\n\n        if (liquidatorShare > 0) {\n            accountLayout.allocatedBalances[msg.sender] += liquidatorShare;\n        }\n    }\n\n    function liquidatePositionsPartyB(\n        address partyB,\n        address partyA,\n        QuotePriceSig memory priceSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyQuotePrices(priceSig);\n        require(\n            priceSig.timestamp <=\n                maLayout.partyBLiquidationTimestamp[partyB][partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        require(\n            maLayout.partyBLiquidationStatus[partyB][partyA],\n            \"LiquidationFacet: PartyB is solvent\"\n        );\n        require(\n            block.timestamp <= priceSig.timestamp + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired price sig\"\n        );\n        for (uint256 index = 0; index < priceSig.quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[priceSig.quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(\n                quote.partyA == partyA && quote.partyB == partyB,\n                \"LiquidationFacet: Invalid party\"\n            );\n\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            // accountLayout.allocatedBalances[partyA] += quote.lockedValues.cva;\n            accountLayout.lockedBalances[partyA].subQuote(quote);\n\n            // (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n            //     priceSig.prices[index],\n            //     LibQuote.quoteOpenAmount(quote),\n            //     quote\n            // );\n\n            // if (hasMadeProfit) {\n            //     accountLayout.allocatedBalances[partyA] += amount;\n            // } else {\n            //     accountLayout.allocatedBalances[partyA] -= amount;\n            // }\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    priceSig.prices[index]) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[partyB][partyA] -= 1;\n        }\n        if (maLayout.partyBPositionLiquidatorsShare[partyB][partyA] > 0) {\n            accountLayout.allocatedBalances[msg.sender] +=\n                maLayout.partyBPositionLiquidatorsShare[partyB][partyA] *\n                priceSig.quoteIds.length;\n        }\n\n        if (quoteLayout.partyBPositionsCount[partyB][partyA] == 0) {\n            maLayout.partyBLiquidationStatus[partyB][partyA] = false;\n            maLayout.partyBLiquidationTimestamp[partyB][partyA] = 0;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/libraries/LibMuon.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../libraries/LibMuonV04ClientBase.sol\";\nimport \"../storages/MuonStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\n\nlibrary LibMuon {\n    using ECDSA for bytes32;\n\n    function getChainId() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    // CONTEXT for commented out lines\n    // We're utilizing muon signatures for asset pricing and user uPNLs calculations. \n    // Even though these signatures are necessary for full testing of the system, particularly when invoking various methods.\n    // The process of creating automated functional signature for tests has proven to be either impractical or excessively time-consuming. therefore, we've established commenting out the necessary code as a workaround specifically for testing.\n    // Essentially, during testing, we temporarily disable the code sections responsible for validating these signatures. The sections I'm referring to are located within the LibMuon file. Specifically, the body of the 'verifyTSSAndGateway' method is a prime candidate for temporary disablement. In addition, several 'require' statements within other functions of this file, which examine the signatures' expiration status, also need to be temporarily disabled.\n    // However, it is crucial to note that these lines should not be disabled in the production deployed version. \n    // We emphasize this because they are only disabled for testing purposes.\n\n    function verifyTSSAndGateway(\n        bytes32 hash,\n        SchnorrSign memory sign,\n        bytes memory gatewaySignature\n    ) internal view {\n//       bool verified = LibMuonV04ClientBase.muonVerify(\n//           uint256(hash),\n//           sign,\n//           MuonStorage.layout().muonPublicKey\n//       );\n//       require(verified, \"LibMuon: TSS not verified\");\n//\n//       hash = hash.toEthSignedMessageHash();\n//       address gatewaySignatureSigner = hash.recover(gatewaySignature);\n//\n//       require(\n//           gatewaySignatureSigner == MuonStorage.layout().validGateway,\n//           \"LibMuon: Gateway is not valid\"\n//       );\n    }\n\n    function verifyPrices(PriceSig memory priceSig, address partyA) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        require(priceSig.prices.length == priceSig.symbolIds.length, \"LibMuon: Invalid length\");\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                priceSig.reqId,\n                address(this),\n                partyA,\n                priceSig.upnl,\n                priceSig.totalUnrealizedLoss,\n                priceSig.symbolIds,\n                priceSig.prices,\n                priceSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n    }\n\n    function verifyQuotePrices(QuotePriceSig memory priceSig) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        require(priceSig.prices.length == priceSig.quoteIds.length, \"LibMuon: Invalid length\");\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                priceSig.reqId,\n                address(this),\n                priceSig.quoteIds,\n                priceSig.prices,\n                priceSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n    }\n\n    function verifyPartyAUpnl(SingleUpnlSig memory upnlSig, address partyA) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyA,\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnl,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPartyAUpnlAndPrice(\n        SingleUpnlAndPriceSig memory upnlSig,\n        address partyA,\n        uint256 symbolId\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyA,\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnl,\n                symbolId,\n                upnlSig.price,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPartyBUpnl(\n        SingleUpnlSig memory upnlSig,\n        address partyB,\n        address partyA\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                upnlSig.upnl,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPairUpnlAndPrice(\n        PairUpnlAndPriceSig memory upnlSig,\n        address partyB,\n        address partyA,\n        uint256 symbolId\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnlPartyB,\n                upnlSig.upnlPartyA,\n                symbolId,\n                upnlSig.price,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPairUpnl(\n        PairUpnlSig memory upnlSig,\n        address partyB,\n        address partyA\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnlPartyB,\n                upnlSig.upnlPartyA,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary LiquidationFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyA\n        );\n        require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n        maLayout.liquidationStatus[partyA] = true;\n        maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    }\n\n    function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        LibMuon.verifyPrices(priceSig, partyA);\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        require(\n            priceSig.timestamp <=\n                maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n            accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n                priceSig.prices[index],\n                maLayout.liquidationTimestamp[partyA]\n            );\n        }\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            priceSig.upnl,\n            partyA\n        );\n        if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n            accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n                liquidationType: LiquidationType.NONE,\n                upnl: priceSig.upnl,\n                totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n                deficit: 0,\n                liquidationFee: 0\n            });\n            if (availableBalance >= 0) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf -\n                    uint256(-availableBalance);\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (\n                uint256(-availableBalance) <=\n                accountLayout.lockedBalances[partyA].lf + accountLayout.lockedBalances[partyA].cva\n            ) {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.LATE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            } else {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf -\n                    accountLayout.lockedBalances[partyA].cva;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.OVERDUE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            }\n            AccountStorage.layout().liquidators[partyA].push(msg.sender);\n        } else {\n            require(\n                accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n                    accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n                    priceSig.totalUnrealizedLoss,\n                \"LiquidationFacet: Invalid upnl sig\"\n            );\n        }\n    }\n\n    function liquidatePendingPositionsPartyA(address partyA) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        require(\n            MAStorage.layout().liquidationStatus[partyA],\n            \"LiquidationFacet: PartyA is solvent\"\n        );\n        for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n            Quote storage quote = quoteLayout.quotes[\n                quoteLayout.partyAPendingQuotes[partyA][index]\n            ];\n            if (\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n                quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n            ) {\n                delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n                AccountStorage\n                .layout()\n                .partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n            }\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n        AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n        delete quoteLayout.partyAPendingQuotes[partyA];\n    }\n\n    function liquidatePositionsPartyA(\n        address partyA,\n        uint256[] memory quoteIds\n    ) internal returns (bool) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        for (uint256 index = 0; index < quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[quoteIds[index]"
    }
  ]
}