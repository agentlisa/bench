{
  "Title": "Interest Rate Miscalculation Due to Stale Debt Values",
  "Content": "##### Description\n\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/lendingpool/LendingPoolCollateralManager.sol#L227-L232\n\n```solidity\nprincipalReserve.updateInterestRates(\n  principal,\n  principalReserve.aTokenAddress,\n  vars.actualAmountToLiquidate,\n  0\n);\n\nif (vars.userVariableDebt >= vars.actualAmountToLiquidate) {\n  IVariableDebtToken(principalReserve.variableDebtTokenAddress).burn(\n    user,\n    vars.actualAmountToLiquidate,\n    principalReserve.variableBorrowIndex\n  );\n} else {\n  IVariableDebtToken(principalReserve.variableDebtTokenAddress).burn(\n    user,\n    vars.userVariableDebt,\n    principalReserve.variableBorrowIndex\n  );\n\n  IStableDebtToken(principalReserve.stableDebtTokenAddress).burn(\n    user,\n    vars.actualAmountToLiquidate.sub(vars.userVariableDebt)\n  );\n}\n```\n\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/lendingpool/LendingPoolCollateralManager.sol#L409-L414\n\n```solidity\ndebtReserve.updateInterestRates(\n  principal,\n  vars.principalAToken,\n  vars.actualAmountToLiquidate,\n  0\n);\nIERC20(principal).safeTransferFrom(receiver, vars.principalAToken, vars.actualAmountToLiquidate);\n\nif (vars.userVariableDebt >= vars.actualAmountToLiquidate) {\n  IVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\n    user,\n    vars.actualAmountToLiquidate,\n    debtReserve.variableBorrowIndex\n  );\n} else {\n  IVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\n    user,\n    vars.userVariableDebt,\n    debtReserve.variableBorrowIndex\n  );\n  IStableDebtToken(debtReserve.stableDebtTokenAddress).burn(\n    user,\n    vars.actualAmountToLiquidate.sub(vars.userVariableDebt)\n  );\n}\n```\n\nDebt reserve interest rates are updated before debt burning takes place.\n\nAs a result, stale total debt values are used during interest rates calculation. \n\n##### Recommendation\nWe suggest switching `updateInterestRates` and the `if` statement.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/lendingpool/LendingPoolCollateralManager.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {\n  VersionedInitializable\n} from '../libraries/openzeppelin-upgradeability/VersionedInitializable.sol';\nimport {IAToken} from '../tokenization/interfaces/IAToken.sol';\nimport {IStableDebtToken} from '../tokenization/interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../tokenization/interfaces/IVariableDebtToken.sol';\nimport {DebtTokenBase} from '../tokenization/base/DebtTokenBase.sol';\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\nimport {GenericLogic} from '../libraries/logic/GenericLogic.sol';\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol';\nimport {Helpers} from '../libraries/helpers/Helpers.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ISwapAdapter} from '../interfaces/ISwapAdapter.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {ValidationLogic} from '../libraries/logic/ValidationLogic.sol';\nimport {LendingPoolStorage} from './LendingPoolStorage.sol';\n\n/**\n * @title LendingPoolCollateralManager contract\n * @author Aave\n * @notice Implements actions involving management of collateral in the protocol.\n * @notice this contract will be ran always through delegatecall\n * @dev LendingPoolCollateralManager inherits VersionedInitializable from OpenZeppelin to have the same storage layout as LendingPool\n **/\ncontract LendingPoolCollateralManager is VersionedInitializable, LendingPoolStorage {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n\n  // IMPORTANT The storage layout of the LendingPool is reproduced here because this contract\n  // is gonna be used through DELEGATECALL\n\n  uint256 internal constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 5000;\n\n  /**\n   * @dev emitted when a borrower is liquidated\n   * @param collateral the address of the collateral being liquidated\n   * @param principal the address of the reserve\n   * @param user the address of the user being liquidated\n   * @param purchaseAmount the total amount liquidated\n   * @param liquidatedCollateralAmount the amount of collateral being liquidated\n   * @param liquidator the address of the liquidator\n   * @param receiveAToken true if the liquidator wants to receive aTokens, false otherwise\n   **/\n  event LiquidationCall(\n    address indexed collateral,\n    address indexed principal,\n    address indexed user,\n    uint256 purchaseAmount,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n    @dev emitted when a borrower/liquidator repays with the borrower's collateral\n    @param collateral the address of the collateral being swapped to repay\n    @param principal the address of the reserve of the debt\n    @param user the borrower's address\n    @param liquidator the address of the liquidator, same as the one of the borrower on self-repayment\n    @param principalAmount the amount of the debt finally covered\n    @param swappedCollateralAmount the amount of collateral finally swapped\n  */\n  event RepaidWithCollateral(\n    address indexed collateral,\n    address indexed principal,\n    address indexed user,\n    address liquidator,\n    uint256 principalAmount,\n    uint256 swappedCollateralAmount\n  );\n\n  struct LiquidationCallLocalVars {\n    uint256 userCollateralBalance;\n    uint256 userStableDebt;\n    uint256 userVariableDebt;\n    uint256 maxPrincipalAmountToLiquidate;\n    uint256 actualAmountToLiquidate;\n    uint256 liquidationRatio;\n    uint256 maxAmountCollateralToLiquidate;\n    ReserveLogic.InterestRateMode borrowRateMode;\n    uint256 userStableRate;\n    uint256 maxCollateralToLiquidate;\n    uint256 principalAmountNeeded;\n    uint256 healthFactor;\n    IAToken collateralAtoken;\n    bool isCollateralEnabled;\n    address principalAToken;\n    uint256 errorCode;\n    string errorMsg;\n  }\n\n  struct SwapLiquidityLocalVars {\n    uint256 healthFactor;\n    uint256 amountToReceive;\n    uint256 userBalanceBefore;\n    IAToken fromReserveAToken;\n    IAToken toReserveAToken;\n    uint256 errorCode;\n    string errorMsg;\n  }\n\n  struct AvailableCollateralToLiquidateLocalVars {\n    uint256 userCompoundedBorrowBalance;\n    uint256 liquidationBonus;\n    uint256 collateralPrice;\n    uint256 principalCurrencyPrice;\n    uint256 maxAmountCollateralToLiquidate;\n    uint256 principalDecimals;\n    uint256 collateralDecimals;\n  }\n\n  /**\n   * @dev as the contract extends the VersionedInitializable contract to match the state\n   * of the LendingPool contract, the getRevision() function is needed.\n   */\n  function getRevision() internal override pure returns (uint256) {\n    return 0;\n  }\n\n  /**\n   * @dev users can invoke this function to liquidate an undercollateralized position.\n   * @param collateral the address of the collateral to liquidated\n   * @param principal the address of the principal reserve\n   * @param user the address of the borrower\n   * @param purchaseAmount the amount of principal that the liquidator wants to repay\n   * @param receiveAToken true if the liquidators wants to receive the aTokens, false if\n   * he wants to receive the underlying asset directly\n   **/\n  function liquidationCall(\n    address collateral,\n    address principal,\n    address user,\n    uint256 purchaseAmount,\n    bool receiveAToken\n  ) external returns (uint256, string memory) {\n    ReserveLogic.ReserveData storage collateralReserve = _reserves[collateral];\n    ReserveLogic.ReserveData storage principalReserve = _reserves[principal];\n    UserConfiguration.Map storage userConfig = _usersConfig[user];\n\n    LiquidationCallLocalVars memory vars;\n\n    (, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData(\n      user,\n      _reserves,\n      _usersConfig[user],\n      _reservesList,\n      _addressesProvider.getPriceOracle()\n    );\n\n    //if the user hasn't borrowed the specific currency defined by asset, it cannot be liquidated\n    (vars.userStableDebt, vars.userVariableDebt) = Helpers.getUserCurrentDebt(\n      user,\n      principalReserve\n    );\n\n    (vars.errorCode, vars.errorMsg) = ValidationLogic.validateLiquidationCall(\n      collateralReserve,\n      principalReserve,\n      userConfig,\n      vars.healthFactor,\n      vars.userStableDebt,\n      vars.userVariableDebt\n    );\n\n    if (Errors.CollateralManagerErrors(vars.errorCode) != Errors.CollateralManagerErrors.NO_ERROR) {\n      return (vars.errorCode, vars.errorMsg);\n    }\n\n    vars.collateralAtoken = IAToken(collateralReserve.aTokenAddress);\n\n    vars.userCollateralBalance = vars.collateralAtoken.balanceOf(user);\n\n    vars.maxPrincipalAmountToLiquidate = vars.userStableDebt.add(vars.userVariableDebt).percentMul(\n      LIQUIDATION_CLOSE_FACTOR_PERCENT\n    );\n\n    vars.actualAmountToLiquidate = purchaseAmount > vars.maxPrincipalAmountToLiquidate\n      ? vars.maxPrincipalAmountToLiquidate\n      : purchaseAmount;\n\n    (\n      vars.maxCollateralToLiquidate,\n      vars.principalAmountNeeded\n    ) = calculateAvailableCollateralToLiquidate(\n      collateralReserve,\n      principalReserve,\n      collateral,\n      principal,\n      vars.actualAmountToLiquidate,\n      vars.userCollateralBalance\n    );\n\n    //if principalAmountNeeded < vars.ActualAmountToLiquidate, there isn't enough\n    //of collateral to cover the actual amount that is being liquidated, hence we liquidate\n    //a smaller amount\n\n    if (vars.principalAmountNeeded < vars.actualAmountToLiquidate) {\n      vars.actualAmountToLiquidate = vars.principalAmountNeeded;\n    }\n\n    //if liquidator reclaims the underlying asset, we make sure there is enough available collateral in the reserve\n    if (!receiveAToken) {\n      uint256 currentAvailableCollateral = IERC20(collateral).balanceOf(\n        address(vars.collateralAtoken)\n      );\n      if (currentAvailableCollateral < vars.maxCollateralToLiquidate) {\n        return (\n          uint256(Errors.CollateralManagerErrors.NOT_ENOUGH_LIQUIDITY),\n          Errors.NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE\n        );\n      }\n    }\n\n    //update the principal reserve\n    principalReserve.updateState();\n\n    principalReserve.updateInterestRates(\n      principal,\n      principalReserve.aTokenAddress,\n      vars.actualAmountToLiquidate,\n      0\n    );\n\n    if (vars.userVariableDebt >= vars.actualAmountToLiquidate) {\n      IVariableDebtToken(principalReserve.variableDebtTokenAddress).burn(\n        user,\n        vars.actualAmountToLiquidate,\n        principalReserve.variableBorrowIndex\n      );\n    } else {\n      IVariableDebtToken(principalReserve.variableDebtTokenAddress).burn(\n        user,\n        vars.userVariableDebt,\n        principalReserve.variableBorrowIndex\n      );\n\n      IStableDebtToken(principalReserve.stableDebtTokenAddress).burn(\n        user,\n        vars.actualAmountToLiquidate.sub(vars.userVariableDebt)\n      );\n    }\n\n    //if liquidator reclaims the aToken, he receives the equivalent atoken amount\n    if (receiveAToken) {\n      vars.collateralAtoken.transferOnLiquidation(user, msg.sender, vars.maxCollateralToLiquidate);\n    } else {\n      //otherwise receives the underlying asset\n\n      //updating collateral reserve\n      collateralReserve.updateState();\n      collateralReserve.updateInterestRates(\n        collateral,\n        address(vars.collateralAtoken),\n        0,\n        vars.maxCollateralToLiquidate\n      );\n\n      //burn the equivalent amount of atoken\n      vars.collateralAtoken.burn(\n        user,\n        msg.sender,\n        vars.maxCollateralToLiquidate,\n        collateralReserve.liquidityIndex\n      );\n    }\n\n    //transfers the principal currency to the aToken\n    IERC20(principal).safeTransferFrom(\n      msg.sender,\n      principalReserve.aTokenAddress,\n      vars.actualAmountToLiquidate\n    );\n\n    emit LiquidationCall(\n      collateral,\n      principal,\n      user,\n      vars.actualAmountToLiquidate,\n      vars.maxCollateralToLiquidate,\n      msg.sender,\n      receiveAToken\n    );\n\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.NO_ERRORS);\n  }\n\n  /**\n   * @dev flashes the underlying collateral on an user to swap for the owed asset and repay\n   * - Both the owner of the position and other liquidators can execute it.\n   * - The owner can repay with his collateral at any point, no matter the health factor.\n   * - Other liquidators can only use this function below 1 HF. To liquidate 50% of the debt > HF 0.98 or the whole below.\n   * @param collateral The address of the collateral asset.\n   * @param principal The address of the owed asset.\n   * @param user Address of the borrower.\n   * @param principalAmount Amount of the debt to repay.\n   * @param receiver Address of the contract receiving the collateral to swap.\n   * @param params Variadic bytes param to pass with extra information to the receiver\n   **/\n  function repayWithCollateral(\n    address collateral,\n    address principal,\n    address user,\n    uint256 principalAmount,\n    address receiver,\n    bytes calldata params\n  ) external returns (uint256, string memory) {\n    ReserveLogic.ReserveData storage collateralReserve = _reserves[collateral];\n    ReserveLogic.ReserveData storage debtReserve = _reserves[principal];\n    UserConfiguration.Map storage userConfig = _usersConfig[user];\n\n    LiquidationCallLocalVars memory vars;\n\n    (, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData(\n      user,\n      _reserves,\n      _usersConfig[user],\n      _reservesList,\n      _addressesProvider.getPriceOracle()\n    );\n\n    (vars.userStableDebt, vars.userVariableDebt) = Helpers.getUserCurrentDebt(user, debtReserve);\n\n    (vars.errorCode, vars.errorMsg) = ValidationLogic.validateRepayWithCollateral(\n      collateralReserve,\n      debtReserve,\n      userConfig,\n      user,\n      vars.healthFactor,\n      vars.userStableDebt,\n      vars.userVariableDebt\n    );\n\n    if (Errors.CollateralManagerErrors(vars.errorCode) != Errors.CollateralManagerErrors.NO_ERROR) {\n      return (vars.errorCode, vars.errorMsg);\n    }\n\n    vars.maxPrincipalAmountToLiquidate = vars.userStableDebt.add(vars.userVariableDebt);\n\n    vars.actualAmountToLiquidate = principalAmount > vars.maxPrincipalAmountToLiquidate\n      ? vars.maxPrincipalAmountToLiquidate\n      : principalAmount;\n\n    vars.collateralAtoken = IAToken(collateralReserve.aTokenAddress);\n    vars.userCollateralBalance = vars.collateralAtoken.balanceOf(user);\n\n    (\n      vars.maxCollateralToLiquidate,\n      vars.principalAmountNeeded\n    ) = calculateAvailableCollateralToLiquidate(\n      collateralReserve,\n      debtReserve,\n      collateral,\n      principal,\n      vars.actualAmountToLiquidate,\n      vars.userCollateralBalance\n    );\n\n    //if principalAmountNeeded < vars.ActualAmountToLiquidate, there isn't enough\n    //of collateral to cover the actual amount that is being liquidated, hence we liquidate\n    //a smaller amount\n    if (vars.principalAmountNeeded < vars.actualAmountToLiquidate) {\n      vars.actualAmountToLiquidate = vars.principalAmountNeeded;\n    }\n    //updating collateral reserve indexes\n    collateralReserve.updateState();\n\n    //updating collateral reserve interest rates\n    collateralReserve.updateInterestRates(\n      collateral,\n      address(vars.collateralAtoken),\n      0,\n      vars.maxCollateralToLiquidate\n    );\n\n    vars.collateralAtoken.burn(\n      user,\n      receiver,\n      vars.maxCollateralToLiquidate,\n      collateralReserve.liquidityIndex\n    );\n\n    if (vars.userCollateralBalance == vars.maxCollateralToLiquidate) {\n      _usersConfig[user].setUsingAsCollateral(collateralReserve.id, false);\n    }\n\n    vars.principalAToken = debtReserve.aTokenAddress;\n\n    // Notifies the receiver to proceed, sending as param the underlying already transferred\n    ISwapAdapter(receiver).executeOperation(\n      collateral,\n      principal,\n      vars.maxCollateralToLiquidate,\n      address(this),\n      params\n    );\n\n    //updating debt reserve\n    debtReserve.updateState();\n    debtReserve.updateInterestRates(\n      principal,\n      vars.principalAToken,\n      vars.actualAmountToLiquidate,\n      0\n    );\n    IERC20(principal).safeTransferFrom(receiver, vars.principalAToken, vars.actualAmountToLiquidate);\n\n    if (vars.userVariableDebt >= vars.actualAmountToLiquidate) {\n      IVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\n        user,\n        vars.actualAmountToLiquidate,\n        debtReserve.variableBorrowIndex\n      );\n    } else {\n      IVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\n        user,\n        vars.userVariableDebt,\n        debtReserve.variableBorrowIndex\n      );\n      IStableDebtToken(debtReserve.stableDebtTokenAddress).burn(\n        user,\n        vars.actualAmountToLiquidate.sub(vars.userVariableDebt)\n      );\n    }\n\n    emit RepaidWithCollateral(\n      collateral,\n      principal,\n      user,\n      msg.sender,\n      vars.actualAmountToLiquidate,\n      vars.maxCollateralToLiquidate\n    );\n\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.NO_ERRORS);\n  }\n\n  /**\n   * @dev Allows an user to release one of his assets deposited in the protocol, even if it is used as collateral, to swap for another.\n   * - It's not possible to release one asset to swap for the same\n   * @param receiverAddress The address of the contract receiving the funds. The receiver should implement the ISwapAdapter interface\n   * @param fromAsset Asset to swap from\n   * @param toAsset Asset to swap to\n   * @param params a bytes array to be sent (if needed) to the receiver contract with extra data\n   **/\n  function swapLiquidity(\n    address receiverAddress,\n    address fromAsset,\n    address toAsset,\n    uint256 amountToSwap,\n    bytes calldata params\n  ) external returns (uint256, string memory) {\n    ReserveLogic.ReserveData storage fromReserve = _reserves[fromAsset];\n    ReserveLogic.ReserveData storage toReserve = _reserves[toAsset];\n\n    SwapLiquidityLocalVars memory vars;\n\n    (vars.errorCode, vars.errorMsg) = ValidationLogic.validateSwapLiquidity(\n      fromReserve,\n      toReserve,\n      fromAsset,\n      toAsset\n    );\n\n    if (Errors.CollateralManagerErrors(vars.errorCode) != Errors.CollateralManagerErrors.NO_ERROR) {\n      return (vars.errorCode, vars.errorMsg);\n    }\n\n    vars.fromReserveAToken = IAToken(fromReserve.aTokenAddress);\n    vars.toReserveAToken = IAToken(toReserve.aTokenAddress);\n\n    fromReserve.updateState();\n    toReserve.updateState();\n\n    if (vars.fromReserveAToken.balanceOf(msg.sender) == amountToSwap) {\n      _usersConfig[msg.sender].setUsingAsCollateral(fromReserve.id, false);\n    }\n\n    fromReserve.updateInterestRates(fromAsset, address(vars.fromReserveAToken), 0, amountToSwap);\n\n    vars.fromReserveAToken.burn(\n      msg.sender,\n      receiverAddress,\n      amountToSwap,\n      fromReserve.liquidityIndex\n    );\n    // Notifies the receiver to proceed, sending as param the underlying already transferred\n    ISwapAdapter(receiverAddress).executeOperation(\n      fromAsset,\n      toAsset,\n      amountToSwap,\n      address(this),\n      params\n    );\n\n    vars.amountToReceive = IERC20(toAsset).balanceOf(receiverAddress);\n    if (vars.amountToReceive != 0) {\n      IERC20(toAsset).safeTransferFrom(\n        receiverAddress,\n        address(vars.toReserveAToken),\n        vars.amountToReceive\n      );\n\n      if (vars.toReserveAToken.balanceOf(msg.sender) == 0) {\n        _usersConfig[msg.sender].setUsingAsCollateral(toReserve.id, true);\n      }\n\n      vars.toReserveAToken.mint(msg.sender, vars.amountToReceive, toReserve.liquidityIndex);\n      toReserve.updateInterestRates(\n        toAsset,\n        address(vars.toReserveAToken),\n        vars.amountToReceive,\n        0\n      );\n    }\n\n    (, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData(\n      msg.sender,\n      _reserves,\n      _usersConfig[msg.sender],\n      _reservesList,\n      _addressesProvider.getPriceOracle()\n    );\n\n    if (vars.healthFactor < GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD) {\n      return (\n        uint256(Errors.CollateralManagerErrors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD),\n        Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n      );\n    }\n\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.NO_ERRORS);\n  }\n\n  /**\n   * @dev calculates how much of a specific collateral can be liquidated, given\n   * a certain amount of principal currency. This function needs to be called after\n   * all the checks to validate the liquidation have been performed, otherwise it might fail.\n   * @param collateralAddress the collateral to be liquidated\n   * @param principalAddress the principal currency to be liquidated\n   * @param purchaseAmount the amount of principal being liquidated\n   * @param userCollateralBalance the collatera balance for the specific collateral asset of the user being liquidated\n   * @return collateralAmount the maximum amount that is possible to liquidated given all the liquidation constraints (user balance, close factor)\n   * @return principalAmountNeeded the purchase amount\n   **/\n  function calculateAvailableCollateralToLiquidate(\n    ReserveLogic.ReserveData storage collateralReserve,\n    ReserveLogic.ReserveData storage principalReserve,\n    address collateralAddress,\n    address principalAddress,\n    uint256 purchaseAmount,\n    uint256 userCollateralBalance\n  ) internal view returns (uint256, uint256) {\n    uint256 collateralAmount = 0;\n    uint256 principalAmountNeeded = 0;\n    IPriceOracleGetter oracle = IPriceOracleGetter(_addressesProvider.getPriceOracle());\n\n    AvailableCollateralToLiquidateLocalVars memory vars;\n\n    vars.collateralPrice = oracle.getAssetPrice(collateralAddress);\n    vars.principalCurrencyPrice = oracle.getAssetPrice(principalAddress);\n\n    (, , vars.liquidationBonus, vars.collateralDecimals) = collateralReserve\n      .configuration\n      .getParams();\n    vars.principalDecimals = principalReserve.configuration.getDecimals();\n\n    //this is the maximum possible amount of the selected collateral that can be liquidated, given the\n    //max amount of principal currency that is available for liquidation.\n    vars.maxAmountCollateralToLiquidate = vars\n      .principalCurrencyPrice\n      .mul(purchaseAmount)\n      .mul(10**vars.collateralDecimals)\n      .div(vars.collateralPrice.mul(10**vars.principalDecimals))\n      .percentMul(vars.liquidationBonus);\n\n    if (vars.maxAmountCollateralToLiquidate > userCollateralBalance) {\n      collateralAmount = userCollateralBalance;\n      principalAmountNeeded = vars\n        .collateralPrice\n        .mul(collateralAmount)\n        .mul(10**vars.principalDecimals)\n        .div(vars.principalCurrencyPrice.mul(10**vars.collateralDecimals))\n        .percentDiv(vars.liquidationBonus);\n    } else {\n      collateralAmount = vars.maxAmountCollateralToLiquidate;\n      principalAmountNeeded = purchaseAmount;\n    }\n    return (collateralAmount, principalAmountNeeded);\n  }\n}"
    },
    {
      "filename": "contracts/lendingpool/LendingPoolCollateralManager.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {\n  VersionedInitializable\n} from '../libraries/openzeppelin-upgradeability/VersionedInitializable.sol';\nimport {IAToken} from '../tokenization/interfaces/IAToken.sol';\nimport {IStableDebtToken} from '../tokenization/interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../tokenization/interfaces/IVariableDebtToken.sol';\nimport {DebtTokenBase} from '../tokenization/base/DebtTokenBase.sol';\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\nimport {GenericLogic} from '../libraries/logic/GenericLogic.sol';\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol';\nimport {Helpers} from '../libraries/helpers/Helpers.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ISwapAdapter} from '../interfaces/ISwapAdapter.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {ValidationLogic} from '../libraries/logic/ValidationLogic.sol';\nimport {LendingPoolStorage} from './LendingPoolStorage.sol';\n\n/**\n * @title LendingPoolCollateralManager contract\n * @author Aave\n * @notice Implements actions involving management of collateral in the protocol.\n * @notice this contract will be ran always through delegatecall\n * @dev LendingPoolCollateralManager inherits VersionedInitializable from OpenZeppelin to have the same storage layout as LendingPool\n **/\ncontract LendingPoolCollateralManager is VersionedInitializable, LendingPoolStorage {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n\n  // IMPORTANT The storage layout of the LendingPool is reproduced here because this contract\n  // is gonna be used through DELEGATECALL\n\n  uint256 internal constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 5000;\n\n  /**\n   * @dev emitted when a borrower is liquidated\n   * @param collateral the address of the collateral being liquidated\n   * @param principal the address of the reserve\n   * @param user the address of the user being liquidated\n   * @param purchaseAmount the total amount liquidated\n   * @param liquidatedCollateralAmount the amount of collateral being liquidated\n   * @param liquidator the address of the liquidator\n   * @param receiveAToken true if the liquidator wants to receive aTokens, false otherwise\n   **/\n  event LiquidationCall(\n    address indexed collateral,\n    address indexed principal,\n    address indexed user,\n    uint256 purchaseAmount,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n    @dev emitted when a borrower/liquidator repays with the borrower's collateral\n    @param collateral the address of the collateral being swapped to repay\n    @param principal the address of the reserve of the debt\n    @param user the borrower's address\n    @param liquidator the address of the liquidator, same as the one of the borrower on self-repayment\n    @param principalAmount the amount of the debt finally covered\n    @param swappedCollateralAmount the amount of collateral finally swapped\n  */\n  event RepaidWithCollateral(\n    address indexed collateral,\n    address indexed principal,\n    address indexed user,\n    address liquidator,\n    uint256 principalAmount,\n    uint256 swappedCollateralAmount\n  );\n\n  struct LiquidationCallLocalVars {\n    uint256 userCollateralBalance;\n    uint256 userStableDebt;\n    uint256 userVariableDebt;\n    uint256 maxPrincipalAmountToLiquidate;\n    uint256 actualAmountToLiquidate;\n    uint256 liquidationRatio;\n    uint256 maxAmountCollateralToLiquidate;\n    ReserveLogic.InterestRateMode borrowRateMode;\n    uint256 userStableRate;\n    uint256 maxCollateralToLiquidate;\n    uint256 principalAmountNeeded;\n    uint256 healthFactor;\n    IAToken collateralAtoken;\n    bool isCollateralEnabled;\n    address principalAToken;\n    uint256 errorCode;\n    string errorMsg;\n  }\n\n  struct SwapLiquidityLocalVars {\n    uint256 healthFactor;\n    uint256 amountToReceive;\n    uint256 userBalanceBefore;\n    IAToken fromReserveAToken;\n    IAToken toReserveAToken;\n    uint256 errorCode;\n    string errorMsg;\n  }\n\n  struct AvailableCollateralToLiquidateLocalVars {\n    uint256 userCompoundedBorrowBalance;\n    uint256 liquidationBonus;\n    uint256 collateralPrice;\n    uint256 principalCurrencyPrice;\n    uint256 maxAmountCollateralToLiquidate;\n    uint256 principalDecimals;\n    uint256 collateralDecimals;\n  }\n\n  /**\n   * @dev as the contract extends the VersionedInitializable contract to match the state\n   * of the LendingPool contract, the getRevision() function is needed.\n   */\n  function getRevision() internal override pure returns (uint256) {\n    return 0;\n  }\n\n  /**\n   * @dev users can invoke this function to liquidate an undercollateralized position.\n   * @param collateral the address of the collateral to liquidated\n   * @param principal the address of the principal reserve\n   * @param user the address of the borrower\n   * @param purchaseAmount the amount of principal that the liquidator wants to repay\n   * @param receiveAToken true if the liquidators wants to receive the aTokens, false if\n   * he wants to receive the underlying asset directly\n   **/\n  function liquidationCall(\n    address collateral,\n    address principal,\n    address user,\n    uint256 purchaseAmount,\n    bool receiveAToken\n  ) external returns (uint256, string memory) {\n    ReserveLogic.ReserveData storage collateralReserve = _reserves[collateral];\n    ReserveLogic.ReserveData storage principalReserve = _reserves[principal];\n    UserConfiguration.Map storage userConfig = _usersConfig[user];\n\n    LiquidationCallLocalVars memory vars;\n\n    (, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData(\n      user,\n      _reserves,\n      _usersConfig[user],\n      _reservesList,\n      _addressesProvider.getPriceOracle()\n    );\n\n    //if the user hasn't borrowed the specific currency defined by asset, it cannot be liquidated\n    (vars.userStableDebt, vars.userVariableDebt) = Helpers.getUserCurrentDebt(\n      user,\n      principalReserve\n    );\n\n    (vars.errorCode, vars.errorMsg) = ValidationLogic.validateLiquidationCall(\n      collateralReserve,\n      principalReserve,\n      userConfig,\n      vars.healthFactor,\n      vars.userStableDebt,\n      vars.userVariableDebt\n    );\n\n    if (Errors.CollateralManagerErrors(vars.errorCode) != Errors.CollateralManagerErrors.NO_ERROR) {\n      return (vars.errorCode, vars.errorMsg);\n    }\n\n    vars.collateralAtoken = IAToken(collateralReserve.aTokenAddress);\n\n    vars.userCollateralBalance = vars.collateralAtoken.balanceOf(user);\n\n    vars.maxPrincipalAmountToLiquidate = vars.userStableDebt.add(vars.userVariableDebt).percentMul(\n      LIQUIDATION_CLOSE_FACTOR_PERCENT\n    );\n\n    vars.actualAmountToLiquidate = purchaseAmount > vars.maxPrincipalAmountToLiquidate\n      ? vars.maxPrincipalAmountToLiquidate\n      : purchaseAmount;\n\n    (\n      vars.maxCollateralToLiquidate,\n      vars.principalAmountNeeded\n    ) = calculateAvailableCollateralToLiquidate(\n      collateralReserve,\n      principalReserve,\n      collateral,\n      principal,\n      vars.actualAmountToLiquidate,\n      vars.userCollateralBalance\n    );\n\n    //if principalAmountNeeded < vars.ActualAmountToLiquidate, there isn't enough\n    //of collateral to cover the actual amount that is being liquidated, hence we liquidate\n    //a smaller amount\n\n    if (vars.principalAmountNeeded < vars.actualAmountToLiquidate) {\n      vars.actualAmountToLiquidate = vars.principalAmountNeeded;\n    }\n\n    //if liquidator reclaims the underlying asset, we make sure there is enough available collateral in the reserve\n    if (!receiveAToken) {\n      uint256 currentAvailableCollateral = IERC20(collateral).balanceOf(\n        address(vars.collateralAtoken)\n      );\n      if (currentAvailableCollateral < vars.maxCollateralToLiquidate) {\n        return (\n          uint256(Errors.CollateralManagerErrors.NOT_ENOUGH_LIQUIDITY),\n          Errors.NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE\n        );\n      }\n    }\n\n    //update the principal reserve\n    principalReserve.updateState();\n\n    principalReserve.updateInterestRates(\n      principal,\n      principalReserve.aTokenAddress,\n      vars.actualAmountToLiquidate,\n      0\n    );\n\n    if (vars.userVariableDebt >= vars.actualAmountToLiquidate) {\n      IVariableDebtToken(principalReserve.variableDebtTokenAddress).burn(\n        user,\n        vars.actualAmountToLiquidate,\n        principalReserve.variableBorrowIndex\n      );\n    } else {\n      IVariableDebtToken(principalReserve.variableDebtTokenAddress).burn(\n        user,\n        vars.userVariableDebt,\n        principalReserve.variableBorrowIndex\n      );\n\n      IStableDebtToken(principalReserve.stableDebtTokenAddress).burn(\n        user,\n        vars.actualAmountToLiquidate.sub(vars.userVariableDebt)\n      );\n    }\n\n    //if liquidator reclaims the aToken, he receives the equivalent atoken amount\n    if (receiveAToken) {\n      vars.collateralAtoken.transferOnLiquidation(user, msg.sender, vars.maxCollateralToLiquidate);\n    } else {\n      //otherwise receives the underlying asset\n\n      //updating collateral reserve\n      collateralReserve.updateState();\n      collateralReserve.updateInterestRates(\n        collateral,\n        address(vars.collateralAtoken),\n        0,\n        vars.maxCollateralToLiquidate\n      );\n\n      //burn the equivalent amount of atoken\n      vars.collateralAtoken.burn(\n        user,\n        msg.sender,\n        vars.maxCollateralToLiquidate,\n        collateralReserve.liquidityIndex\n      );\n    }\n\n    //transfers the principal currency to the aToken\n    IERC20(principal).safeTransferFrom(\n      msg.sender,\n      principalReserve.aTokenAddress,\n      vars.actualAmountToLiquidate\n    );\n\n    emit LiquidationCall(\n      collateral,\n      principal,\n      user,\n      vars.actualAmountToLiquidate,\n      vars.maxCollateralToLiquidate,\n      msg.sender,\n      receiveAToken\n    );\n\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.NO_ERRORS);\n  }\n\n  /**\n   * @dev flashes the underlying collateral on an user to swap for the owed asset and repay\n   * - Both the owner of the position and other liquidators can execute it.\n   * - The owner can repay with his collateral at any point, no matter the health factor.\n   * - Other liquidators can only use this function below 1 HF. To liquidate 50% of the debt > HF 0.98 or the whole below.\n   * @param collateral The address of the collateral asset.\n   * @param principal The address of the owed asset.\n   * @param user Address of the borrower.\n   * @param principalAmount Amount of the debt to repay.\n   * @param receiver Address of the contract receiving the collateral to swap.\n   * @param params Variadic bytes param to pass with extra information to the receiver\n   **/\n  function repayWithCollateral(\n    address collateral,\n    address principal,\n    address user,\n    uint256 principalAmount,\n    address receiver,\n    bytes calldata params\n  )"
    }
  ]
}