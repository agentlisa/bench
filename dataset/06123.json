{
  "Title": "[M-01] Identifying publications using its ID makes the protocol vulnerable to blockchain re-orgs",
  "Content": "\nIn the protocol, publications are uniquely identified through the publisher's profile ID and the publication's ID. For example, when a user calls `act()`, the publication being acted on is determined by `publicationActedProfileId` and `publicationActedId`:\n\n[ActionLib.sol#L23-L26](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/ActionLib.sol#L23-L26)\n\n```solidity\n        Types.Publication storage _actedOnPublication = StorageLib.getPublication(\n            publicationActionParams.publicationActedProfileId,\n            publicationActionParams.publicationActedId\n        );\n```\n\nHowever, as publication IDs are not based on the publication's data, this could cause users to act on the wrong publication in the event a blockchain re-org occurs.\n\nFor example:\n\n*   Assume the following transactions occur in separate blocks:\n    *   Block 1: Alice calls `post()` to create a post; its publication ID is 20.\n    *   Block 2: Bob is interested in the post, he calls `act()` with `publicationActedId = 20` to act on the post.\n    *   Block 3: Alice calls `comment()` separately, which creates another publication; its publication ID is 21.\n*   A blockchain re-org occurs; block 1 is dropped in place of block 3:\n    *   Alice's comment now has the publication ID 20 instead of 21.\n*   Bob's call to `act()` in block 2 is applied on top of the re-orged blockchain:\n    *   This causes him to act on the comment instead of the post he intended to, as it now has the publication ID 20.\n\nIn this scenario, due to the blockchain re-org, Bob calls `act()` on a different publication than the one he wanted. This could have severe impacts depending on the action module being called; if the action module is used to collect and pay fees to the publisher and referrals (eg. [`MultirecipientFeeCollectModule.sol`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/modules/act/collect/MultirecipientFeeCollectModule.sol)), Bob could have lost funds.\n\nNote that this also applies to [`comment()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L247-L255), [`mirror`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L270-L278) and [`quote()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L293-L301), as they can be called with reference modules with sensitive logic as well.\n\n### Impact\n\nIf a blockchain re-org occurs, users could potentially act/comment/mirror/quote on the wrong publication, which has varying impacts depending on the action or reference module being used, such as a loss of funds due to paying fees.\n\nGiven that Lens Protocol is deployed on Poylgon, which has [experienced large re-orgs in the past](https://forum.polygon.technology/t/157-block-reorg-at-block-height-39599624/11388), the likelihood of the scenario described above occuring due to a blockchain re-org is not low.\n\n### Recommended Mitigation\n\nConsider identifying publications with a method that is dependent on its contents. For example, users could be expected to provide the `keccak256` hash of a publication's contents alongside its publication ID.\n\nThis would prevent users from acting on the wrong publication should a publication's contents change despite having the same ID.\n\n**[donosonaumczuk (Lens) disputed and commented](https://github.com/code-423n4/2023-07-lens-findings/issues/148#issuecomment-1669778308):**\n > We disagree with the validity of this issue.\n> \n> Transactions will have a nonce (even when meta-txs), so each profile will already have a specific order for each of their publications, which means that the IDs of the publications will be asigned correctly to those profiles, whenever the transactions get confirmed.\n> \n> What can happen, is that the re-org ends up executing the \"act\" transaction before the \"post/quote/comment\" that is being acted on is created, leading the \"act\" transaction to revert. It shouldn't be likely to occur.\n> \n> For the described issue to happen, a really weird edge case needs to occur, a re-org that also includes a transaction replacement (override) for the \"post/quote/comment\". This is very unlikely and the harm caused is also not clear.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-07-lens-findings/issues/148#issuecomment-1695853088):**\n > > *Transactions will have a nonce (even when meta-txs), so each profile will already have a specific order for each of their publications, which means that the IDs of the publications will be asigned correctly to those profiles, whenever the transactions get confirmed.*\n> \n> As it may happen that multiple addresses have the right to post (for example delegated executors and owners), I think the described scenario is valid and it's possible to have multiple publications being reordered in a different order. So to me this finding is valid. Let me know if I am missing something!\n\n**[donosonaumczuk (Lens) commented](https://github.com/code-423n4/2023-07-lens-findings/issues/148#issuecomment-1699465260):**\n > > *As it may happen that multiple addresses have the right to post (for example delegated executors and owners) I think the described scenario is valid.*\n> \n> Yes, I did not consider that detail. What you have said is correct and then the issue is valid.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/libraries/ActionLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\nimport {IPublicationActionModule} from 'contracts/interfaces/IPublicationActionModule.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {Events} from 'contracts/libraries/constants/Events.sol';\n\nlibrary ActionLib {\n    function act(\n        Types.PublicationActionParams calldata publicationActionParams,\n        address transactionExecutor,\n        address actorProfileOwner\n    ) external returns (bytes memory) {\n        ValidationLib.validateNotBlocked({\n            profile: publicationActionParams.actorProfileId,\n            byProfile: publicationActionParams.publicationActedProfileId\n        });\n\n        Types.Publication storage _actedOnPublication = StorageLib.getPublication(\n            publicationActionParams.publicationActedProfileId,\n            publicationActionParams.publicationActedId\n        );\n\n        address actionModuleAddress = publicationActionParams.actionModuleAddress;\n        uint256 actionModuleId = StorageLib.actionModuleWhitelistData()[actionModuleAddress].id;\n\n        if (!_isActionEnabled(_actedOnPublication, actionModuleId)) {\n            // This will also revert for:\n            //   - Non-existent action modules\n            //   - Non-existent publications\n            //   - Legacy V1 publications\n            // Because the storage will be empty.\n            revert Errors.ActionNotAllowed();\n        }\n\n        Types.PublicationType[] memory referrerPubTypes = ValidationLib.validateReferrersAndGetReferrersPubTypes(\n            publicationActionParams.referrerProfileIds,\n            publicationActionParams.referrerPubIds,\n            publicationActionParams.publicationActedProfileId,\n            publicationActionParams.publicationActedId\n        );\n\n        bytes memory actionModuleReturnData = IPublicationActionModule(actionModuleAddress).processPublicationAction(\n            Types.ProcessActionParams({\n                publicationActedProfileId: publicationActionParams.publicationActedProfileId,\n                publicationActedId: publicationActionParams.publicationActedId,\n                actorProfileId: publicationActionParams.actorProfileId,\n                actorProfileOwner: actorProfileOwner,\n                transactionExecutor: transactionExecutor,\n                referrerProfileIds: publicationActionParams.referrerProfileIds,\n                referrerPubIds: publicationActionParams.referrerPubIds,\n                referrerPubTypes: referrerPubTypes,\n                actionModuleData: publicationActionParams.actionModuleData\n            })\n        );\n        emit Events.Acted(publicationActionParams, actionModuleReturnData, block.timestamp);\n\n        return actionModuleReturnData;\n    }\n\n    function _isActionEnabled(Types.Publication storage _publication, uint256 actionModuleId)\n        private\n        view\n        returns (bool)\n    {\n        if (actionModuleId == 0) {\n            return false;\n        }\n        uint256 actionModuleIdBitmapMask = 1 << (actionModuleId - 1);\n        return actionModuleIdBitmapMask & _publication.enabledActionModulesBitmap != 0;\n    }\n}"
    },
    {
      "filename": "contracts/LensHub.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n// Interfaces\nimport {ILensProtocol} from 'contracts/interfaces/ILensProtocol.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\n\n// Constants\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\n\n// Lens Hub Components\nimport {LensHubStorage} from 'contracts/base/LensHubStorage.sol';\nimport {LensImplGetters} from 'contracts/base/LensImplGetters.sol';\nimport {LensGovernable} from 'contracts/base/LensGovernable.sol';\nimport {LensProfiles} from 'contracts/base/LensProfiles.sol';\nimport {LensHubEventHooks} from 'contracts/base/LensHubEventHooks.sol';\n\n// Libraries\nimport {ActionLib} from 'contracts/libraries/ActionLib.sol';\nimport {LegacyCollectLib} from 'contracts/libraries/LegacyCollectLib.sol';\nimport {FollowLib} from 'contracts/libraries/FollowLib.sol';\nimport {MetaTxLib} from 'contracts/libraries/MetaTxLib.sol';\nimport {ProfileLib} from 'contracts/libraries/ProfileLib.sol';\nimport {PublicationLib} from 'contracts/libraries/PublicationLib.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\n\n// Lens Migrations V1 to V2\nimport {LensV2Migration} from 'contracts/misc/LensV2Migration.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entry point of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke a LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is\n    LensProfiles,\n    LensGovernable,\n    LensV2Migration,\n    LensImplGetters,\n    LensHubEventHooks,\n    LensHubStorage,\n    ILensProtocol\n{\n    modifier onlyProfileOwnerOrDelegatedExecutor(address expectedOwnerOrDelegatedExecutor, uint256 profileId) {\n        ValidationLib.validateAddressIsProfileOwnerOrDelegatedExecutor(expectedOwnerOrDelegatedExecutor, profileId);\n        _;\n    }\n\n    modifier whenPublishingEnabled() {\n        if (StorageLib.getState() != Types.ProtocolState.Unpaused) {\n            revert Errors.PublishingPaused();\n        }\n        _;\n    }\n\n    constructor(\n        address moduleGlobals,\n        address followNFTImpl,\n        address collectNFTImpl, // We still pass the deprecated CollectNFTImpl for legacy Collects to work\n        address lensHandlesAddress,\n        address tokenHandleRegistryAddress,\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule,\n        uint256 tokenGuardianCooldown\n    )\n        LensProfiles(moduleGlobals, tokenGuardianCooldown)\n        LensV2Migration(\n            legacyFeeFollowModule,\n            legacyProfileFollowModule,\n            newFeeFollowModule,\n            lensHandlesAddress,\n            tokenHandleRegistryAddress\n        )\n        LensImplGetters(followNFTImpl, collectNFTImpl)\n    {}\n\n    /// @inheritdoc ILensProtocol\n    function createProfile(Types.CreateProfileParams calldata createProfileParams)\n        external\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        ValidationLib.validateProfileCreatorWhitelisted(msg.sender);\n        unchecked {\n            uint256 profileId = ++_profileCounter;\n            _mint(createProfileParams.to, profileId);\n            ProfileLib.createProfile(createProfileParams, profileId);\n            return profileId;\n        }\n    }\n\n    ///////////////////////////////////////////\n    ///        PROFILE OWNER FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURI(uint256 profileId, string calldata metadataURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileMetadataURISignature(signature, profileId, metadataURI);\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId) {\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModuleWithSig(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetFollowModuleSignature(signature, profileId, followModule, followModuleInitData);\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeDelegatedExecutorsConfig(delegatorProfileId, delegatedExecutors, approvals);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfigWithSig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwner(signature.signer, delegatorProfileId) {\n        MetaTxLib.validateChangeDelegatedExecutorsConfigSignature(\n            signature,\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURIWithSig(\n        uint256 profileId,\n        string calldata imageURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileImageURISignature(signature, profileId, imageURI);\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    ////////////////////////////////////////\n    ///        PUBLISHING FUNCTIONS      ///\n    ////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function post(Types.PostParams calldata postParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, postParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.post({postParams: postParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function postWithSig(Types.PostParams calldata postParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, postParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validatePostSignature(signature, postParams);\n        return PublicationLib.post({postParams: postParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function comment(Types.CommentParams calldata commentParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, commentParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function commentWithSig(Types.CommentParams calldata commentParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, commentParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateCommentSignature(signature, commentParams);\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirror(Types.MirrorParams calldata mirrorParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, mirrorParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirrorWithSig(Types.MirrorParams calldata mirrorParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, mirrorParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateMirrorSignature(signature, mirrorParams);\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quote(Types.QuoteParams calldata quoteParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, quoteParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quoteWithSig(Types.QuoteParams calldata quoteParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, quoteParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateQuoteSignature(signature, quoteParams);\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: signature.signer});\n    }\n\n    /////////////////////////////////////////////////\n    ///        PROFILE INTERACTION FUNCTIONS      ///\n    /////////////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function follow(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, followerProfileId)\n        returns (uint256[] memory)\n    {\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: msg.sender\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function followWithSig(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, followerProfileId)\n        returns (uint256[] memory)\n    {\n        MetaTxLib.validateFollowSignature(signature, followerProfileId, idsOfProfilesToFollow, followTokenIds, datas);\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: signature.signer\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollow(uint256 unfollowerProfileId, uint256[] calldata idsOfProfilesToUnfollow)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, unfollowerProfileId)\n    {\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: msg.sender\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollowWithSig(\n        uint256 unfollowerProfileId,\n        uint256[] calldata idsOfProfilesToUnfollow,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, unfollowerProfileId) {\n        MetaTxLib.validateUnfollowSignature(signature, unfollowerProfileId, idsOfProfilesToUnfollow);\n\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: signature.signer\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatus(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, byProfileId) {\n        return ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatusWithSig(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, byProfileId) {\n        MetaTxLib.validateSetBlockStatusSignature(signature, byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n        return ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collect(Types.CollectParams calldata collectParams)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: msg.sender,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collectWithSig(Types.CollectParams calldata collectParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateLegacyCollectSignature(signature, collectParams);\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: signature.signer,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function act(Types.PublicationActionParams calldata publicationActionParams)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: msg.sender,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function actWithSig(\n        Types.PublicationActionParams calldata publicationActionParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        MetaTxLib.validateActSignature(signature, publicationActionParams);\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: signature.signer,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    ///////////////////////////////////////////\n    ///        EXTERNAL VIEW FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function isFollowing(uint256 followerProfileId, uint256 followedProfileId) external view returns (bool) {\n        address followNFT = _profiles[followedProfileId].followNFT;\n        return followNFT != address(0) && IFollowNFT(followNFT).isFollowing(followerProfileId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(\n        uint256 delegatorProfileId,\n        address delegatedExecutor,\n        uint64 configNumber\n    ) external view returns (bool) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).isApproved[configNumber][delegatedExecutor];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(uint256 delegatorProfileId, address delegatedExecutor)\n        external\n        view\n        returns (bool)\n    {\n        return ProfileLib.isExecutorApproved(delegatorProfileId, delegatedExecutor);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).configNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsPrevConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).prevConfigNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsMaxConfigNumberSet(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).maxConfigNumberSet;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isBlocked(uint256 profileId, uint256 byProfileId) external view returns (bool) {\n        return _blockedStatus[byProfileId][profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getContentURI(uint256 profileId, uint256 pubId) external view override returns (string memory) {\n        // This function is used by the Collect NFTs' tokenURI function.\n        return PublicationLib.getContentURI(profileId, pubId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getProfile(uint256 profileId) external view override returns (Types.Profile memory) {\n        return _profiles[profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublication(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (Types.Publication memory)\n    {\n        return _publications[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublicationType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (Types.PublicationType)\n    {\n        return PublicationLib.getPublicationType(profileId, pubId);\n    }\n\n    function getActionModuleById(uint256 id) external view override returns (address) {\n        return _actionModules[id];\n    }\n}"
    }
  ]
}