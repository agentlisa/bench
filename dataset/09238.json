{
  "Title": "[G-24] `abi.encode()` is less efficient than `abi.encodePacked()`",
  "Content": "\n```solidity\nFile: contracts-full/AutoleverageBase.sol   #1\n\n102           bytes memory params = abi.encode(Details({\n103               pool: pool,\n104               poolInputIndex: poolInputIndex,\n105               poolOutputIndex: poolOutputIndex,\n106               alchemist: alchemist,\n107               yieldToken: yieldToken,\n108               recipient: msg.sender,\n109               targetDebt: targetDebt\n110           }));\n```\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L102-L110>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-full/AutoleverageBase.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {IAlchemistV2} from \"./interfaces/IAlchemistV2.sol\";\nimport {IAaveFlashLoanReceiver} from \"./interfaces/IAaveFlashLoanReceiver.sol\";\nimport {IAaveLendingPool} from \"./interfaces/IAaveLendingPool.sol\";\nimport {IWhitelist} from \"./interfaces/IWhitelist.sol\";\n\n/// @title A zapper for leveraged deposits into the Alchemist\nabstract contract AutoleverageBase is IAaveFlashLoanReceiver {\n\n    IWhitelist constant whitelist = IWhitelist(0xA3dfCcbad1333DC69997Da28C961FF8B2879e653);\n    IAaveLendingPool constant flashLender = IAaveLendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n\n    struct Details {\n        address pool;\n        int128 poolInputIndex;\n        int128 poolOutputIndex;\n        address alchemist;\n        address yieldToken;\n        address recipient;\n        uint256 targetDebt;\n    }\n\n    /// @notice When the msg.sender is not whitelisted\n    error Unauthorized(address sender);\n\n    /// @notice When we're passed invalid parameters\n    error IllegalArgument(string reason);\n    \n    /// @notice When the yieldToken has no underlyingToken in the alchemist\n    error UnsupportedYieldToken(address yieldToken);\n\n    /// @notice When the collateral is insufficient to mint targetDebt\n    error MintFailure();\n\n    /// @notice When the helper contract ends up with too few or too many tokens\n    error InexactTokens(uint256 currentBalance, uint256 repayAmount);\n\n    /// @notice Either convert received eth to weth, or transfer ERC20 from the msg.sender to this contract\n    /// @param underlyingToken The ERC20 desired to transfer\n    /// @param collateralInitial The amount of tokens taken from the user\n    function _transferTokensToSelf(address underlyingToken, uint256 collateralInitial) internal virtual;\n\n    /// @notice Convert received eth to weth, or do nothing\n    /// @param amountOut The amount received from the curve swap\n    function _maybeConvertCurveOutput(uint256 amountOut) internal virtual;\n\n    /// @notice Swap on curve using the supplied params\n    /// @param poolAddress Curve pool address\n    /// @param debtToken The alAsset debt token address\n    /// @param i Curve swap param\n    /// @param j Curve swap param\n    /// @param minAmountOut Minimum amount received from swap\n    /// @return amountOut The actual amount received from swap\n    function _curveSwap(address poolAddress, address debtToken, int128 i, int128 j, uint256 minAmountOut) internal virtual returns (uint256 amountOut);\n\n    /// @notice Approve a contract to spend tokens\n    function approve(address token, address spender) internal {\n        IERC20(token).approve(spender, type(uint256).max);\n    }\n\n    /// @notice Transfer tokens from msg.sender here, then call flashloan which calls callback\n    /// @dev Must have targetDebt > collateralTotal - collateralInitial, otherwise flashloan payback will fail\n    /// @param pool The address of the curve pool to swap on\n    /// @param poolInputIndex The `i` param for the curve swap\n    /// @param poolOutputIndex The `j` param for the curve swap\n    /// @param alchemist The alchemist to deposit and mint from\n    /// @param yieldToken The yieldToken to convert deposits into\n    /// @param collateralInitial The amount of tokens that will be taken from the user\n    /// @param collateralTotal The amount of tokens that will be deposited as collateral for the user\n    /// @param targetDebt The amount of debt that the user will incur\n    function autoleverage(\n        address pool,\n        int128 poolInputIndex,\n        int128 poolOutputIndex,\n        address alchemist,\n        address yieldToken,\n        uint256 collateralInitial,\n        uint256 collateralTotal,\n        uint256 targetDebt\n    ) external payable {\n        // Gate on EOA or whitelisted\n        if (!(tx.origin == msg.sender || whitelist.isWhitelisted(msg.sender))) revert Unauthorized(msg.sender);\n\n        // Get underlying token from alchemist\n        address underlyingToken = IAlchemistV2(alchemist).getYieldTokenParameters(yieldToken).underlyingToken;\n        if (underlyingToken == address(0)) revert UnsupportedYieldToken(yieldToken);\n\n        _transferTokensToSelf(underlyingToken, collateralInitial);\n\n        // Take out flashloan\n        address[] memory assets = new address[](1);\n        assets[0] = underlyingToken;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = collateralTotal - collateralInitial;\n        uint256[] memory modes = new uint256[](1);\n        modes[0] = 0;\n\n        bytes memory params = abi.encode(Details({\n            pool: pool,\n            poolInputIndex: poolInputIndex,\n            poolOutputIndex: poolOutputIndex,\n            alchemist: alchemist,\n            yieldToken: yieldToken,\n            recipient: msg.sender,\n            targetDebt: targetDebt\n        }));\n\n        flashLender.flashLoan(\n            address(this),\n            assets,\n            amounts,\n            modes,\n            address(0), // onBehalfOf, not used here\n            params, // params, passed to callback func to decode as struct\n            0 // referralCode\n        );\n    }\n\n    /// @notice Flashloan callback receiver, will be called by IAaveLendingPool.flashloan()\n    /// @dev Never call this function directly\n    /// @param assets An array of length 1, pointing to the ERC20 received in the flashloan\n    /// @param amounts An array of length 1, with the ERC20 amount received in the flashloan\n    /// @param premiums An array of length 1, with the flashloan fee. We will pay back amounts[0] + premiums[0] to the flashloan provider\n    /// @param initiator Points to who initiated the flashloan\n    /// @param params ABI-encoded `Details` struct containing many details about desired functionality\n    /// @return success Always true unless reverts, required by Aave flashloan\n    function executeOperation(\n        address[] calldata assets,\n        uint[] calldata amounts,\n        uint[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool) {\n        // Only called by flashLender\n        if (msg.sender != address(flashLender)) revert Unauthorized(msg.sender);\n        if (initiator != address(this)) revert IllegalArgument(\"flashloan initiator must be self\");\n        Details memory details = abi.decode(params, (Details));\n        uint256 repayAmount = amounts[0] + premiums[0];\n\n        uint256 collateralBalance = IERC20(assets[0]).balanceOf(address(this));\n\n        // Deposit into recipient's account\n        approve(assets[0], details.alchemist);\n        IAlchemistV2(details.alchemist).depositUnderlying(details.yieldToken, collateralBalance, details.recipient, 0);\n\n        // Mint from recipient's account\n        try IAlchemistV2(details.alchemist).mintFrom(details.recipient, details.targetDebt, address(this)) {\n\n        } catch {\n            revert MintFailure();\n        }\n\n        {\n            address debtToken = IAlchemistV2(details.alchemist).debtToken();\n            uint256 amountOut = _curveSwap(\n                details.pool, \n                debtToken, \n                details.poolInputIndex, \n                details.poolOutputIndex, \n                repayAmount\n            );\n\n            _maybeConvertCurveOutput(amountOut);\n\n\n            // Deposit excess assets into the alchemist on behalf of the user\n            uint256 excessCollateral = amountOut - repayAmount;\n            if (excessCollateral > 0) {\n                IAlchemistV2(details.alchemist).depositUnderlying(details.yieldToken, excessCollateral, details.recipient, 0);\n            }\n        }\n\n        // Approve the LendingPool contract allowance to *pull* the owed amount\n        approve(assets[0], address(flashLender));\n        uint256 balance = IERC20(assets[0]).balanceOf(address(this));\n        if (balance != repayAmount) {\n            revert InexactTokens(balance, repayAmount);\n        }\n\n        return true;\n    }\n\n}"
    }
  ]
}