{
  "Title": "H-9: Uniswap v3 pool token balance proportion does not necessarily correspond to the price, and it is easy to manipulate.",
  "Content": "# Issue H-9: Uniswap v3 pool token balance proportion does not necessarily correspond to the price, and it is easy to manipulate. \n\nSource: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/808 \n\n## Found by \n0xRan4212, Bahurum, VAD37, WATCHPUG, curiousapple, mahdikarimi, n33k, nobody2018, simon135\n## Summary\n\n`getSupplyProportion()` retrieves Uniswap v3 pool balances, but the proportion of pool tokens doesn't always correspond to the price. If `ownval` is less than `1e6 - threshold`, `USSDamount` may be lower than `DAIamount`, causing L97 `USSDamount - DAIamount` to revert due to underflow. Proportion can be easily manipulated, which can be exploited by attackers.\n\n## Vulnerability Detail\n\n`getSupplyProportion()` retrieves the balances of the Uniswap v3 pool. However, due to the different designs of Uniswap v3 and Uniswap v2, the proportion of pool tokens does not necessarily correspond to the price.\n\nAs a result, if `ownval` is less than `1e6 - threshold` (e.g. 0.95), `USSDamount` may be lower than `DAIamount`, causing L97 `USSDamount - DAIamount` to revert due to underflow.\n\nAdditionally, the pool contract holds accumulative fees on its balances, which are not impacted by price changes.\n\n---\n\nFurthermore, the proportion can be easily manipulated with minimal cost, which can be exploited by attackers.\n\nIf the price of USSD goes over-peg (which can happen naturally), an attacker can take advantage by following these steps:\n\n1. Add single leg liquidity of DAI to the DAI/USSD pool at an exorbitantly high price range, such as 1 DAI == 1000-2000 USSD.\n2. Manipulate the price of the collateral asset, such as WETH, to a higher price.\n3. Place a limit-order like JIT liquidity at a higher price in the WETH/DAI pool.\n4. Trigger `rebalance() -> SellUSSDBuyCollateral()`, but it will mint and sell much more than expected (the amount needed to bring the peg back) as the `DAIamount` is significantly higher than `USSDamount` at a manipulated high price. This will buy the limit order from step 3.\n5. Reverse the price of WETH/DAI and remove the liquidity placed at step 1.\n\n## Impact\n\n1. `rebalance()` may malfunction if the proportion is not as expected.\n2. Manipulating the proportion can result in the protocol selling a significantly larger amount of collateral assets than intended. If the collateral asset is also manipulated, it would be sold at a manipulated price, causing even larger damage to the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L13-L16\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSDRebalancer.sol#L83-L107\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of using the pool balances to calculate the delta amount required to restore the peg, a more complex formula that considers the liquidity range should be used.\n\n\n\n## Discussion\n\n**0xJuancito**\n\nEscalate for 10 USDC\n\nThis issue is already addressed on #451 and its duplicates\n\nAll of them refer to manipulation of Uniswap v3 pool and calling `rebalance()` to manipulate USSD price. Other duplicate findings address the same issue as here with `getSupplyProportion ()` as well, like https://github.com/sherlock-audit/2023-05-USSD-judging/issues/92, https://github.com/sherlock-audit/2023-05-USSD-judging/issues/731, https://github.com/sherlock-audit/2023-05-USSD-judging/issues/733 just to give some examples.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This issue is already addressed on #451 and its duplicates\n> \n> All of them refer to manipulation of Uniswap v3 pool and calling `rebalance()` to manipulate USSD price. Other duplicate findings address the same issue as here with `getSupplyProportion ()` as well, like https://github.com/sherlock-audit/2023-05-USSD-judging/issues/92, https://github.com/sherlock-audit/2023-05-USSD-judging/issues/731, https://github.com/sherlock-audit/2023-05-USSD-judging/issues/733 just to give some examples.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**bahurum**\n\nEscalate for 10 USDC\n\nThis isssue  is not a duplicate of #451 as claimed by @0xJuancito.\n\nThe problem here is not the usage of `slot0()` but calculating the price of a Uniswap V3 pool as ratio of pool reserves, which is fundamentally wrong.\nAlso, while this issue allows an attack vector which involves manipulation of the price of the pool, the issue already exists without manipulation as the rebalancing will be completely off or would not work at all, and this for any normal non-manipulated pool.\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This isssue  is not a duplicate of #451 as claimed by @0xJuancito.\n> \n> The problem here is not the usage of `slot0()` but calculating the price of a Uniswap V3 pool as ratio of pool reserves, which is fundamentally wrong.\n> Also, while this issue allows an attack vector which involves manipulation of the price of the pool, the issue already exists without manipulation as the rebalancing will be completely off or would not work at all, and this for any normal non-manipulated pool.\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xJuancito**\n\nEscalate for 10 USDC\n\nFor clarification from my previous comment, I'm pointing that many issues have been judged as a duplicate of #451 as stated on my comment due to this root cause as well, not necessarily with `slot0`, but the current use of the pool.\n\n> This issue is already addressed on https://github.com/sherlock-audit/2023-05-USSD-judging/issues/451 and its duplicates\n\nJust to give some examples:\n\n- https://github.com/sherlock-audit/2023-05-USSD-judging/issues/731\n\n> getSupplyProportion uses Uniswap V3 pool tokens balances which are easily manipulated. The protocol rebalances the USSD/DAI token proportion to 50/50 to rebalance the USSD/DAI price. This works for Uniswap V2 pools but does not work for Uniswap V3 pools.\n\n- https://github.com/sherlock-audit/2023-05-USSD-judging/issues/733\n\n> The getSupplyProportion() function, using the balanceOf() function, is designed to maintain the balance of the USSD/DAI pool in order to stabilize the USSD value at $1.\n\n> However, this balance can be manipulated, particularly through UniswapPool flashloan, which facilitates the alteration of the balanceOf() value of both USSD and DAI in the pool. This then tricks the USSDRebalancer.rebalance() function into swapping half the total pool value.\n\nMy suggestion is to keep the consistency in the judging and group them all, as similar issues have been already grouped under #451.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> For clarification from my previous comment, I'm pointing that many issues have been judged as a duplicate of #451 as stated on my comment due to this root cause as well, not necessarily with `slot0`, but the current use of the pool.\n> \n> > This issue is already addressed on https://github.com/sherlock-audit/2023-05-USSD-judging/issues/451 and its duplicates\n> \n> Just to give some examples:\n> \n> - https://github.com/sherlock-audit/2023-05-USSD-judging/issues/731\n> \n> > getSupplyProportion uses Uniswap V3 pool tokens balances which are easily manipulated. The protocol rebalances the USSD/DAI token proportion to 50/50 to rebalance the USSD/DAI price. This works for Uniswap V2 pools but does not work for Uniswap V3 pools.\n> \n> - https://github.com/sherlock-audit/2023-05-USSD-judging/issues/733\n> \n> > The getSupplyProportion() function, using the balanceOf() function, is designed to maintain the balance of the USSD/DAI pool in order to stabilize the USSD value at $1.\n> \n> > However, this balance can be manipulated, particularly through UniswapPool flashloan, which facilitates the alteration of the balanceOf() value of both USSD and DAI in the pool. This then tricks the USSDRebalancer.rebalance() function into swapping half the total pool value.\n> \n> My suggestion is to keep the consistency in the judging and group them all, as similar issues have been already grouped under #451.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nConsider this not a duplicate of #451 \n\nand will redo some duplicate later\n\n**0xRan4212**\n\nEscalate for 10 USDC\n\nhttps://github.com/sherlock-audit/2023-05-USSD-judging/issues/931 is a dup of this issue.\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nThis issue is not a duplicate of #451, some of the duplications are changed accordingly. \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xJuancito](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/808/#issuecomment-1605929297): accepted\n- [bahurum](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/808/#issuecomment-1605947205): accepted\n- [0xJuancito](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/808/#issuecomment-1606170316): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/82",
  "Code": [
    {
      "filename": "ussd-contracts/contracts/USSDRebalancer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n    @dev rebalancer module for USSD ERC20 token. Performs swaps to return USSD/DAI pool balance 1-to-1\n         selling USSD for buying collateral or buying and burning USSD for selling collateral\n */\ncontract USSDRebalancer is AccessControlUpgradeable, IUSSDRebalancer {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // main USSD/DAI pool\n    IUniswapV3Pool public uniPool;\n\n    // USSD token\n    address public USSD;\n\n    // boundary to make rebalancing\n    uint256 private threshold;\n\n    // ratios of collateralization for different collateral accumulating\n    uint256[] public flutterRatios;\n    \n    // base asset for other pool leg (DAI)\n    address private baseAsset;\n\n    // role to perform rebalancer management functions\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(address _ussd) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        threshold = 1e4;\n        USSD = _ussd;\n    }\n\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    function setPoolAddress(address _pool) public onlyControl {\n      uniPool = IUniswapV3Pool(_pool);\n    }\n\n    function getPool() public view override returns (address) {\n        return address(uniPool);\n    }\n\n    function setTreshold(uint256 _threshold) public onlyControl {\n      threshold = _threshold;\n    }\n\n    function setFlutterRatios(uint256[] calldata _flutterRatios) public onlyControl {\n      flutterRatios = _flutterRatios;\n    }\n\n    function setBaseAsset(address _baseAsset) public onlyControl {\n      baseAsset = _baseAsset;\n    }\n\n    /// @dev get price estimation to DAI using pool address and uniswap price\n    function getOwnValuation() public view returns (uint256 price) {\n      (uint160 sqrtPriceX96,,,,,,) =  uniPool.slot0();\n      if(uniPool.token0() == USSD) {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))/(1e6) >> (96 * 2);\n      } else {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))*(1e18 /* 1e12 + 1e6 decimal representation */) >> (96 * 2);\n        // flip the fraction\n        price = (1e24 / price) / 1e12;\n      }\n    }\n\n    /// @dev return pool balances with USSD first\n    function getSupplyProportion() public view returns (uint256, uint256) {\n      uint256 vol1 = IERC20Upgradeable(uniPool.token0()).balanceOf(address(uniPool));\n      uint256 vol2 = IERC20Upgradeable(uniPool.token1()).balanceOf(address(uniPool));\n      if (uniPool.token0() == USSD) {\n        return (vol1, vol2);\n      }\n      return (vol2, vol1);\n    }\n\n    function rebalance() override public {\n      uint256 ownval = getOwnValuation();\n      (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion();\n      if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12)/2);\n      } else if (ownval > 1e6 + threshold) {\n        // mint and buy collateral\n        // never sell too much USSD for DAI so it 'overshoots' (becomes more in quantity than DAI on the pool)\n        // otherwise could be arbitraged through mint/redeem\n        // the execution difference due to fee should be taken into accounting too\n        // take 1% safety margin (estimated as 2 x 0.5% fee)\n        IUSSD(USSD).mintRebalancer(((DAIamount / 1e12 - USSDamount)/2) * 99 / 100); // mint ourselves amount till balance recover\n        SellUSSDBuyCollateral();\n      }\n    }\n\n    function BuyUSSDSellCollateral(uint256 amountToBuy) internal {\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      //uint amountToBuyLeftUSD = amountToBuy * 1e12 * 1e6 / getOwnValuation();\n      uint amountToBuyLeftUSD = amountToBuy * 1e12;\n      uint DAItosell = 0;\n      // Sell collateral in order of collateral array\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval > amountToBuyLeftUSD) {\n          // sell a portion of collateral and exit\n          if (collateral[i].pathsell.length > 0) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          } else {\n            // no need to swap DAI\n            DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n          }\n          break;\n        } else {\n          // sell all or skip (if collateral is too little, 5% treshold)\n          if (collateralval >= amountToBuyLeftUSD / 20) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            // sell all collateral and move to next one\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          }\n        }\n      }\n\n      // buy USSD (sell DAI) to burn\n      // never sell too much DAI so USSD 'overshoots' (becomes less in quantity than DAI on the pool)\n      // otherwise could be arbitraged through mint/redeem\n      // the remainder (should be small, due to oracle twap lag) to be left as DAI collateral\n      // the execution difference due to fee should be taken into accounting too\n      // take 1% safety margin (estimated as 2 x 0.5% fee)\n      if (DAItosell > amountToBuy * 1e12 * 99 / 100) {\n        DAItosell = amountToBuy * 1e12 * 99 / 100;\n      }\n\n      if (DAItosell > 0) {\n        if (uniPool.token0() == USSD) {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), DAItosell);\n        } else {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), DAItosell);\n        }\n      }\n\n      IUSSD(USSD).burnRebalancer(IUSSD(USSD).balanceOf(USSD));\n    }\n\n    function SellUSSDBuyCollateral() internal {\n      uint256 amount = IUSSD(USSD).balanceOf(USSD);\n      // sell for DAI then swap by DAI routes\n      uint256 daibought = 0;\n      if (uniPool.token0() == USSD) {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      } else {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      }\n\n      // total collateral portions\n      uint256 cf = IUSSD(USSD).collateralFactor();\n      uint256 flutter = 0;\n      for (flutter = 0; flutter < flutterRatios.length; flutter++) {\n        if (cf < flutterRatios[flutter]) {\n          break;\n        }\n      }\n\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      uint portions = 0;\n      uint ownval = (getOwnValuation() * 1e18 / 1e6) * IUSSD(USSD).totalSupply() / 1e6; // 1e18 total USSD value\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          portions++;\n        }\n      }\n\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          if (collateral[i].token != uniPool.token0() || collateral[i].token != uniPool.token1()) {\n            // don't touch DAI if it's needed to be bought (it's already bought)\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought/portions);\n          }\n        }\n      }\n    }\n}"
    },
    {
      "filename": "ussd-contracts/contracts/USSDRebalancer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n    @dev rebalancer module for USSD ERC20 token. Performs swaps to return USSD/DAI pool balance 1-to-1\n         selling USSD for buying collateral or buying and burning USSD for selling collateral\n */\ncontract USSDRebalancer is AccessControlUpgradeable, IUSSDRebalancer {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // main USSD/DAI pool\n    IUniswapV3Pool public uniPool;\n\n    // USSD token\n    address public USSD;\n\n    // boundary to make rebalancing\n    uint256 private threshold;\n\n    // ratios of collateralization for different collateral accumulating\n    uint256[] public flutterRatios;\n    \n    // base asset for other pool leg (DAI)\n    address private baseAsset;\n\n    // role to perform rebalancer management functions\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(address _ussd) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        threshold = 1e4;\n        USSD = _ussd;\n    }\n\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    function setPoolAddress(address _pool) public onlyControl {\n      uniPool = IUniswapV3Pool(_pool);\n    }\n\n    function getPool() public view override returns (address) {\n        return address(uniPool);\n    }\n\n    function setTreshold(uint256 _threshold) public onlyControl {\n      threshold = _threshold;\n    }\n\n    function setFlutterRatios(uint256[] calldata _flutterRatios) public onlyControl {\n      flutterRatios = _flutterRatios;\n    }\n\n    function setBaseAsset(address _baseAsset) public onlyControl {\n      baseAsset = _baseAsset;\n    }\n\n    /// @dev get price estimation to DAI using pool address and uniswap price\n    function getOwnValuation() public view returns (uint256 price) {\n      (uint160 sqrtPriceX96,,,,,,) =  uniPool.slot0();\n      if(uniPool.token0() == USSD) {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))/(1e6) >> (96 * 2);\n      } else {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))*(1e18 /* 1e12 + 1e6 decimal representation */) >> (96 * 2);\n        // flip the fraction\n        price = (1e24 / price) / 1e12;\n      }\n    }\n\n    /// @dev return pool balances with USSD first\n    function getSupplyProportion() public view returns (uint256, uint256) {\n      uint256 vol1 = IERC20Upgradeable(uniPool.token0()).balanceOf(address(uniPool));\n      uint256 vol2 = IERC20Upgradeable(uniPool.token1()).balanceOf(address(uniPool));\n      if (uniPool.token0() == USSD) {\n        return (vol1, vol2);\n      }\n      return (vol2, vol1);\n    }\n\n    function rebalance() override public {\n      uint256 ownval = getOwnValuation();\n      (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion();\n      if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12)/2);\n      } else if (ownval > 1e6 + threshold) {\n        // mint and buy collateral\n        // never sell too much USSD for DAI so it 'overshoots' (becomes more in quantity than DAI on the pool)\n        // otherwise could be arbitraged through mint/redeem\n        // the execution difference due to fee should be taken into accounting too\n        // take 1% safety margin (estimated as 2 x 0.5% fee)\n        IUSSD(USSD).mintRebalancer(((DAIamount / 1e12 - USSDamount)/2) * 99 / 100); // mint ourselves amount till balance recover\n        SellUSSDBuyCollateral();\n      }\n    }\n\n    function BuyUSSDSellCollateral(uint256 amountToBuy) internal {\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      //uint amountToBuyLeftUSD = amountToBuy * 1e12 * 1e6 / getOwnValuation();\n      uint amountToBuyLeftUSD = amountToBuy * 1e12;\n      uint DAItosell = 0;\n      // Sell collateral in order of collateral array\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval > amountToBuyLeftUSD) {\n          // sell a portion of collateral and exit\n          if (collateral[i].pathsell.length > 0) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          } else {\n            // no need to swap DAI\n            DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n          }\n          break;\n        } else {\n          // sell all or skip (if collateral is too little, 5% treshold)\n          if (collateralval >= amountToBuyLeftUSD / 20) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            // sell all collateral and move to next one\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          }\n        }\n      }\n\n      // buy USSD (sell DAI) to burn\n      // never sell too much DAI so USSD 'overshoots' (becomes less in quantity than DAI on the pool)\n      // otherwise could be arbitraged through mint/redeem\n      // the remainder (should be small, due to oracle twap lag) to be left as DAI collateral\n      // the execution difference due to fee should be taken into accounting too\n      // take 1% safety margin (estimated as 2 x 0.5% fee)\n      if (DAItosell > amountToBuy * 1e12 * 99 / 100) {\n        DAItosell = amountToBuy * 1e12 * 99 / 100;\n      }\n\n      if (DAItosell > 0) {\n        if (uniPool.token0() == USSD) {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), DAItosell);\n        } else {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), DAItosell);\n        }\n      }\n\n      IUSSD(USSD).burnRebalancer(IUSSD(USSD).balanceOf(USSD));\n    }\n\n    function SellUSSDBuyCollateral() internal {\n      uint256 amount = IUSSD(USSD).balanceOf(USSD);\n      // sell for DAI then swap by DAI routes\n      uint256 daibought = 0;\n      if (uniPool.token0() == USSD) {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      } else {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      }\n\n      // total collateral portions\n      uint256 cf = IUSSD(USSD).collateralFactor();\n      uint256 flutter = 0;\n      for (flutter = 0; flutter < flutterRatios.length; flutter++) {\n        if (cf < flutterRatios[flutter]) {\n          break;\n        }\n      }\n\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      uint portions = 0;\n      uint ownval = (getOwnValuation() * 1e18 / 1e6) * IUSSD(USSD).totalSupply() / 1e6; // 1e18 total USSD value\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          portions++;\n        }\n      }\n\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          if (collateral[i].token != uniPool.token0() || collateral[i].token != uniPool.token1()) {\n            // don't touch DAI if it's needed to be bought (it's already bought)\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought/portions);\n          }\n        }\n      }\n    }\n}"
    }
  ]
}