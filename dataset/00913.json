{
  "Title": "M-8: `MultiInvoker._latest` will return `latestPrice = 0` when latest oracle version is invalid causing liquidation to send 0 fee to liquidator or incorrect order execution",
  "Content": "# Issue M-8: `MultiInvoker._latest` will return `latestPrice = 0` when latest oracle version is invalid causing liquidation to send 0 fee to liquidator or incorrect order execution \n\nSource: https://github.com/sherlock-audit/2023-10-perennial-judging/issues/31 \n\n## Found by \npanprog\n## Summary\n\nThere was a slight change of oracle versions handling in 2.1: now each requested oracle version must be commited, either as valid or invalid. This means that now the latest version can be invalid (`price = 0`). This is handled correctly in `Market`, which only uses timestamp from the latest oracle version, but the price comes either from latest version (if valid) or `global.latestPrice` (if invalid).\n\nHowever, `MultiInvoker` always uses price from `oracle.latest` without verifying if it's valid, meaning it will return `latestPrice = 0` if the latest oracle version is invalid. This is returned from the `_latest` function.\n\nSuch latest price = 0 leads to 2 main problems:\n- Liquidations orders in MultiInvoker will send 0 liquidation fee to liquidator (will liquidate for free)\n- Some `TriggerOrder`s will trigger incorrectly (`canExecuteOrder` will return true when the real price didn't reach the trigger price, or false even if the real prices reached the trigger price)\n\n## Vulnerability Detail\n\n`MultiInvoker._latest` has the following code for latest price assignment:\n```solidity\nOracleVersion memory latestOracleVersion = market.oracle().latest();\nlatestPrice = latestOracleVersion.price;\nIPayoffProvider payoff = market.payoff();\nif (address(payoff) != address(0)) latestPrice = payoff.payoff(latestPrice);\n```\n\nThis `latestPrice` is what's returned from the `_latest`, it isn't changed anywhere else. Notice that there is no check for latest oracle version validity.\n\nAnd this is the code for `KeeperOracle._commitRequested`:\n```solidity\nfunction _commitRequested(OracleVersion memory version) private returns (bool) {\n    if (block.timestamp <= (next() + timeout)) {\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\n        _prices[version.timestamp] = version.price;\n    }\n    _global.latestIndex++;\n    return true;\n}\n```\n\nNotice that commits made outside the timeout window simply increase `_global.latestIndex` without assigning `_prices`, meaning it remains 0 (invalid). This means that latest oracle version will return price=0 and will be invalid if commited after the timeout from request time has passed.\n\nPrice returned by `_latest` is used when calculating liquidationFee:\n```solidity\nfunction _liquidationFee(IMarket market, address account) internal view returns (Position memory, UFixed6, UFixed6) {\n    // load information about liquidation\n    RiskParameter memory riskParameter = market.riskParameter();\n@@@ (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) = _latest(market, account);\n\n    // create placeholder order for liquidation fee calculation (fee is charged the same on all sides)\n    Order memory placeholderOrder;\n    placeholderOrder.maker = Fixed6Lib.from(closableAmount);\n\n    return (\n        latestPosition,\n        placeholderOrder\n@@@         .liquidationFee(OracleVersion(latestPosition.timestamp, latestPrice, true), riskParameter)\n            .min(UFixed6Lib.from(market.token().balanceOf(address(market)))),\n        closableAmount\n    );\n}\n```\n\n`liquidationFee` calculation in order multiplies order size by `latestPrice`, meaning it will be 0 when price = 0. This liquidation fee is then used in `market.update` for liquidation fee to receive by liquidator:\n```solidity\n    function _liquidate(IMarket market, address account, bool revertOnFailure) internal isMarketInstance(market) {\n@@@     (Position memory latestPosition, UFixed6 liquidationFee, UFixed6 closable) = _liquidationFee(market, account);\n        Position memory currentPosition = market.pendingPositions(account, market.locals(account).currentId);\n        currentPosition.adjust(latestPosition);\n\n        try market.update(\n                account,\n                currentPosition.maker.isZero() ? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n                currentPosition.long.isZero() ? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n                currentPosition.short.isZero() ? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n@@@             Fixed6Lib.from(-1, liquidationFee),\n                true\n```\n\nThis means liquidator will receive 0 fee for the liquidation.\n\nIt is also used in `canExecuteOrder`:\n```solidity\n    function _executeOrder(address account, IMarket market, uint256 nonce) internal {\n        if (!canExecuteOrder(account, market, nonce)) revert MultiInvokerCantExecuteError();\n...\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) public view returns (bool) {\n        TriggerOrder memory order = orders(account, market, nonce);\n        if (order.fee.isZero()) return false;\n@@@     (, Fixed6 latestPrice, ) = _latest(market, account);\n@@@     return order.fillable(latestPrice);\n    }\n```\n\nMeaning `canExecuteOrder` will do comparision with price = 0 instead of real latest price. For example: limit buy order to buy when price <= 1000 (when current price = 1100) will trigger and execute buy at the price = 1100 instead of 1000 or lower.\n\n## Impact\n\n- liquidation done after invalid oracle version via `MultiInvoker` `LIQUIDATE` action will charge and send 0 liquidation fee from the liquidating account, thus liquidator loses these funds.\n- some orders with comparison of type -1 (<= price) will incorrectly trigger and will be executed when price is far from reaching the trigger price. This loses user funds due to unexpected execution price of the pending order.\n\n## Code Snippet\n\n`_latest` simply takes `oracle.latest` price, which can be 0, without any check for oracle version validity:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L394-L402\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`_latest` should replicate the process for the latest price from `Market` instead of using price from the oracle's latest version:\n- if the latest oracle version is valid, then use its price\n- if the latest oracle version is invalid, then iterate all global pending positions backwards and use price of any valid oracle version at the position.\n- if all pending positions are at invalid oracles, use market's `global.latestPrice`\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/123",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { IBatcher } from \"@equilibria/emptyset-batcher/interfaces/IBatcher.sol\";\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { IPythFactory } from \"@equilibria/perennial-v2-oracle/contracts/interfaces/IPythFactory.sol\";\nimport { IVault } from \"@equilibria/perennial-v2-vault/contracts/interfaces/IVault.sol\";\nimport \"./interfaces/IMultiInvoker.sol\";\nimport \"./types/TriggerOrder.sol\";\nimport \"./types/InterfaceFee.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title MultiInvoker\n/// @notice Extension to handle batched calls to the Perennial protocol\ncontract MultiInvoker is IMultiInvoker, Kept {\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Protocol factory to validate market approvals\n    IFactory public immutable marketFactory;\n\n    /// @dev Vault factory to validate vault approvals\n    IFactory public immutable vaultFactory;\n\n    /// @dev Batcher address\n    IBatcher public immutable batcher;\n\n    /// @dev Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev The fixed gas buffer that is added to the keeper reward\n    uint256 public immutable keepBufferBase;\n\n    /// @dev The fixed gas buffer that is added to the calldata portion of  the keeper reward\n    uint256 public immutable keepBufferCalldata;\n\n    /// @dev UID for an order\n    uint256 public latestNonce;\n\n    /// @dev State for the order data\n    mapping(address => mapping(IMarket => mapping(uint256 => TriggerOrderStorage))) private _orders;\n\n    /// @notice Constructs the MultiInvoker contract\n    /// @param usdc_ USDC stablecoin address\n    /// @param dsu_ DSU address\n    /// @param marketFactory_ Protocol factory to validate market approvals\n    /// @param vaultFactory_ Protocol factory to validate vault approvals\n    /// @param batcher_ Batcher address\n    /// @param reserve_ Reserve address\n    /// @param keepBufferBase_ The fixed gas buffer that is added to the keeper reward\n    /// @param keepBufferCalldata_ The fixed calldata buffer that is added to the keeper reward\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        uint256 keepBufferBase_,\n        uint256 keepBufferCalldata_\n    ) {\n        USDC = usdc_;\n        DSU = dsu_;\n        marketFactory = marketFactory_;\n        vaultFactory = vaultFactory_;\n        batcher = batcher_;\n        reserve = reserve_;\n        keepBufferBase = keepBufferBase_;\n        keepBufferCalldata = keepBufferCalldata_;\n    }\n\n    /// @notice Initialize the contract\n    /// @param ethOracle_ Chainlink ETH/USD oracle address\n    function initialize(AggregatorV3Interface ethOracle_) external initializer(1) {\n        __Kept__initialize(ethOracle_, DSU);\n\n        if (address(batcher) != address(0)) {\n            DSU.approve(address(batcher));\n            USDC.approve(address(batcher));\n        }\n\n        DSU.approve(address(reserve));\n        USDC.approve(address(reserve));\n    }\n\n    /// @notice View function to get order state\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    function orders(address account, IMarket market, uint256 nonce) public view returns (TriggerOrder memory) {\n        return _orders[account][market][nonce].read();\n    }\n\n    /// @notice Returns whether an order can be executed\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    /// @return canFill Whether the order can be executed\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) public view returns (bool) {\n        TriggerOrder memory order = orders(account, market, nonce);\n        if (order.fee.isZero()) return false;\n        (, Fixed6 latestPrice, ) = _latest(market, account);\n        return order.fillable(latestPrice);\n    }\n\n    /// @notice entry to perform invocations\n    /// @param invocations List of actions to execute in order\n    function invoke(Invocation[] calldata invocations) external payable {\n        for(uint i = 0; i < invocations.length; ++i) {\n            Invocation memory invocation = invocations[i];\n\n            if (invocation.action == PerennialAction.UPDATE_POSITION) {\n                (\n                    // update data\n                    IMarket market,\n                    UFixed6 newMaker,\n                    UFixed6 newLong,\n                    UFixed6 newShort,\n                    Fixed6 collateral,\n                    bool wrap,\n                    InterfaceFee memory interfaceFee\n                ) = abi.decode(invocation.args, (IMarket, UFixed6, UFixed6, UFixed6, Fixed6, bool, InterfaceFee));\n\n                _update(msg.sender, market, newMaker, newLong, newShort, collateral, wrap, interfaceFee);\n            } else if (invocation.action == PerennialAction.UPDATE_VAULT) {\n                (IVault vault, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets, bool wrap)\n                    = abi.decode(invocation.args, (IVault, UFixed6, UFixed6, UFixed6, bool));\n\n                _vaultUpdate(vault, depositAssets, redeemShares, claimAssets, wrap);\n            } else if (invocation.action == PerennialAction.PLACE_ORDER) {\n                (IMarket market, TriggerOrder memory order) = abi.decode(invocation.args, (IMarket, TriggerOrder));\n\n                _placeOrder(msg.sender, market, order);\n            } else if (invocation.action == PerennialAction.CANCEL_ORDER) {\n                (IMarket market, uint256 nonce) = abi.decode(invocation.args, (IMarket, uint256));\n\n                _cancelOrder(msg.sender, market, nonce);\n            } else if (invocation.action == PerennialAction.EXEC_ORDER) {\n                (address account, IMarket market, uint256 nonce)\n                    = abi.decode(invocation.args, (address, IMarket, uint256));\n\n                _executeOrder(account, market, nonce);\n            } else if (invocation.action == PerennialAction.COMMIT_PRICE) {\n                (address oracleProviderFactory, uint256 value, bytes32[] memory ids, uint256 version, bytes memory data, bool revertOnFailure) =\n                    abi.decode(invocation.args, (address, uint256, bytes32[], uint256, bytes, bool));\n\n                _commitPrice(oracleProviderFactory, value, ids, version, data, revertOnFailure);\n            } else if (invocation.action == PerennialAction.LIQUIDATE) {\n                (IMarket market, address account, bool revertOnFailure) = abi.decode(invocation.args, (IMarket, address, bool));\n\n                _liquidate(market, account, revertOnFailure);\n            } else if (invocation.action == PerennialAction.APPROVE) {\n                (address target) = abi.decode(invocation.args, (address));\n\n                _approve(target);\n            }\n\n            // Eth must not remain in this contract at rest\n            payable(msg.sender).transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Updates market on behalf of account\n    /// @param account Address of account to update\n    /// @param market Address of market up update\n    /// @param newMaker New maker position for account in `market`\n    /// @param newLong New long position for account in `market`\n    /// @param newShort New short position for account in `market`\n    /// @param collateral Net change in collateral for account in `market`\n    /// @param wrap Wheather to wrap/unwrap collateral on deposit/withdrawal\n    /// @param interfaceFee Interface fee to charge\n    function _update(\n        address account,\n        IMarket market,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool wrap,\n        InterfaceFee memory interfaceFee\n    ) internal isMarketInstance(market) {\n        Fixed18 balanceBefore =  Fixed18Lib.from(DSU.balanceOf());\n\n        // collateral is transferred here as DSU then an optional interface fee is charged from it\n        if (collateral.sign() == 1) _deposit(collateral.abs(), wrap);\n\n        market.update(account, newMaker, newLong, newShort, collateral, false);\n\n        Fixed6 withdrawAmount = Fixed6Lib.from(Fixed18Lib.from(DSU.balanceOf()).sub(balanceBefore));\n        if (!withdrawAmount.isZero()) _withdraw(account, withdrawAmount.abs(), wrap);\n\n        // charge interface fee\n        _chargeFee(account, market, interfaceFee);\n    }\n\n    /// @notice Update vault on behalf of msg.sender\n    /// @param vault Address of vault to update\n    /// @param depositAssets Amount of assets to deposit into vault\n    /// @param redeemShares Amount of shares to redeem from vault\n    /// @param claimAssets Amount of assets to claim from vault\n    /// @param wrap Whether to wrap assets before depositing\n    function _vaultUpdate(\n        IVault vault,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets,\n        bool wrap\n    ) internal isVaultInstance(vault) {\n        if (!depositAssets.isZero()) {\n            _deposit(depositAssets, wrap);\n        }\n\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        vault.update(msg.sender, depositAssets, redeemShares, claimAssets);\n\n        // handle socialization, settlement fees, and magic values\n        UFixed6 claimAmount = claimAssets.isZero() ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(DSU.balanceOf().sub(balanceBefore));\n\n        if (!claimAmount.isZero()) {\n            _withdraw(msg.sender, claimAmount, wrap);\n        }\n    }\n\n    /// @notice Liquidates an account for a specific market\n    /// @param market Market to liquidate account in\n    /// @param account Address of market to liquidate\n    function _liquidate(IMarket market, address account, bool revertOnFailure) internal isMarketInstance(market) {\n        (Position memory latestPosition, UFixed6 liquidationFee, UFixed6 closable) = _liquidationFee(market, account);\n        Position memory currentPosition = market.pendingPositions(account, market.locals(account).currentId);\n        currentPosition.adjust(latestPosition);\n\n        try market.update(\n                account,\n                currentPosition.maker.isZero() ? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n                currentPosition.long.isZero() ? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n                currentPosition.short.isZero() ? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n                Fixed6Lib.from(-1, liquidationFee),\n                true\n        ) {\n            _withdraw(msg.sender, liquidationFee, true);\n        } catch (bytes memory reason) {\n            if (revertOnFailure) Address.verifyCallResult(false, reason, \"\");\n        }\n    }\n\n    /// @notice Helper to max approve DSU for usage in a market or vault deployed by the registered factories\n    /// @param target Market or Vault to approve\n    function _approve(address target) internal {\n        if (\n            !marketFactory.instances(IInstance(target)) &&\n            !vaultFactory.instances(IInstance(target))\n        ) revert MultiInvokerInvalidInstanceError();\n\n        DSU.approve(target);\n    }\n\n    /// @notice Charges an interface fee from collateral in this address during an update to a receiver\n    /// @param account Account to charge fee from\n    /// @param market Market to charge fee from\n    /// @param interfaceFee Interface fee to charge\n    function _chargeFee(address account, IMarket market, InterfaceFee memory interfaceFee) internal {\n        if (interfaceFee.amount.isZero()) return;\n\n        market.update(\n            account,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            Fixed6Lib.from(-1, interfaceFee.amount),\n            false\n        );\n\n        if (interfaceFee.unwrap) _unwrap(interfaceFee.receiver, UFixed18Lib.from(interfaceFee.amount));\n        else DSU.push(interfaceFee.receiver, UFixed18Lib.from(interfaceFee.amount));\n\n        emit InterfaceFeeCharged(account, market, interfaceFee);\n    }\n\n    /// @notice Pull DSU or wrap and deposit USDC from msg.sender to this address for market usage\n    /// @param amount Amount to transfer\n    /// @param wrap Flag to wrap USDC to DSU\n    function _deposit(UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            USDC.pull(msg.sender, amount);\n            _wrap(address(this), UFixed18Lib.from(amount));\n        } else {\n            DSU.pull(msg.sender, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Push DSU or unwrap DSU to push USDC from this address to `account`\n    /// @param account Account to push DSU or USDC to\n    /// @param amount Amount to transfer\n    /// @param wrap flag to unwrap DSU to USDC\n    function _withdraw(address account, UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            _unwrap(account, UFixed18Lib.from(amount));\n        } else {\n            DSU.push(account, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Helper function to wrap `amount` USDC from `address(this)` into DSU using the batcher or reserve\n    /// @param receiver Address to receive the DSU\n    /// @param amount Amount of USDC to wrap\n    function _wrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or  doesn't have enough for this wrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(DSU.balanceOf(address(batcher)))) {\n            reserve.mint(amount);\n            if (receiver != address(this)) DSU.push(receiver, amount);\n        } else {\n            // Wrap the USDC into DSU and return to the receiver\n            batcher.wrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to unwrap `amount` DSU into USDC and send to `receiver`\n    /// @param receiver Address to receive the USDC\n    /// @param amount Amount of DSU to unwrap\n    function _unwrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or doesn't have enough for this unwrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(UFixed18Lib.from(USDC.balanceOf(address(batcher))))) {\n            reserve.redeem(amount);\n            if (receiver != address(this)) USDC.push(receiver, UFixed6Lib.from(amount));\n        } else {\n            // Unwrap the DSU into USDC and return to the receiver\n            batcher.unwrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to commit a price to an oracle\n    /// @param oracleProviderFactory Address of oracle provider factory\n    /// @param value The ether value to pass on with the commit sub-call\n    /// @param version Version of oracle to commit to\n    /// @param data Data to commit to oracle\n    /// @param revertOnFailure Whether to revert on sub-call failure\n    function _commitPrice(\n        address oracleProviderFactory,\n        uint256 value,\n        bytes32[] memory ids,\n        uint256 version,\n        bytes memory data,\n        bool revertOnFailure\n    ) internal {\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        try IPythFactory(oracleProviderFactory).commit{value: value}(ids, version, data) {\n            // Return through keeper reward if any\n            DSU.push(msg.sender, DSU.balanceOf().sub(balanceBefore));\n        } catch (bytes memory reason) {\n            if (revertOnFailure) Address.verifyCallResult(false, reason, \"\");\n        }\n    }\n\n    /// @notice Helper function to compute the liquidation fee for an account\n    /// @param market Market to compute liquidation fee for\n    /// @param account Account to compute liquidation fee for\n    /// @return liquidationFee Liquidation fee for the account\n    /// @return closable The amount of the position that can be closed\n    function _liquidationFee(IMarket market, address account) internal view returns (Position memory, UFixed6, UFixed6) {\n        // load information about liquidation\n        RiskParameter memory riskParameter = market.riskParameter();\n        (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) = _latest(market, account);\n\n        // create placeholder order for liquidation fee calculation (fee is charged the same on all sides)\n        Order memory placeholderOrder;\n        placeholderOrder.maker = Fixed6Lib.from(closableAmount);\n\n        return (\n            latestPosition,\n            placeholderOrder\n                .liquidationFee(OracleVersion(latestPosition.timestamp, latestPrice, true), riskParameter)\n                .min(UFixed6Lib.from(market.token().balanceOf(address(market)))),\n            closableAmount\n        );\n    }\n\n    /// @notice Helper function to compute the latest position and oracle version without a settlement\n    /// @param market Market to compute latest position and oracle version for\n    /// @param account Account to compute latest position and oracle version for\n    /// @return latestPosition Latest position for the account\n    /// @return latestPrice Latest oracle price for the account\n    /// @return closableAmount Amount of position that can be closed\n    function _latest(\n        IMarket market,\n        address account\n    ) internal view returns (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) {\n        // load latest price\n        OracleVersion memory latestOracleVersion = market.oracle().latest();\n        latestPrice = latestOracleVersion.price;\n        IPayoffProvider payoff = market.payoff();\n        if (address(payoff) != address(0)) latestPrice = payoff.payoff(latestPrice);\n\n        // load latest settled position\n        uint256 latestTimestamp = latestOracleVersion.timestamp;\n        latestPosition = market.positions(account);\n        closableAmount = latestPosition.magnitude();\n        UFixed6 previousMagnitude = closableAmount;\n\n        // scan pending position for any ready-to-be-settled positions\n        Local memory local = market.locals(account);\n        for (uint256 id = local.latestId + 1; id <= local.currentId; id++) {\n\n            // load pending position\n            Position memory pendingPosition = market.pendingPositions(account, id);\n            pendingPosition.adjust(latestPosition);\n\n            // virtual settlement\n            if (pendingPosition.timestamp <= latestTimestamp) {\n                if (!market.oracle().at(pendingPosition.timestamp).valid) latestPosition.invalidate(pendingPosition);\n                latestPosition.update(pendingPosition);\n\n                previousMagnitude = latestPosition.magnitude();\n                closableAmount = previousMagnitude;\n\n            // process pending positions\n            } else {\n                closableAmount = closableAmount\n                    .sub(previousMagnitude.sub(pendingPosition.magnitude().min(previousMagnitude)));\n                previousMagnitude = latestPosition.magnitude();\n            }\n        }\n    }\n\n    /**\n     * @notice executes an `account's` open order for a `market` and pays a fee to `msg.sender`\n     * @param account Account to execute order of\n     * @param market Market to execute order for\n     * @param nonce Id of open order to index\n     */\n    function _executeOrder(address account, IMarket market, uint256 nonce) internal {\n        if (!canExecuteOrder(account, market, nonce)) revert MultiInvokerCantExecuteError();\n\n        TriggerOrder memory order = orders(account, market, nonce);\n        // Pay out keeper fee based on static gas buffer\n        _handleKeep(account, market, order.fee);\n\n        (Position memory latestPosition, , ) = _latest(market, account);\n        Position memory currentPosition = market.pendingPositions(account, market.locals(account).currentId);\n        currentPosition.adjust(latestPosition);\n\n        order.execute(currentPosition);\n\n        _update(\n            account,\n            market,\n            currentPosition.maker,\n            currentPosition.long,\n            currentPosition.short,\n            currentPosition.collateral,\n            true,\n            order.interfaceFee\n        );\n\n        delete _orders[account][market][nonce];\n        emit OrderExecuted(account, market, nonce);\n    }\n\n    /// @notice Handles paying out keeper reward for an order exection\n    function _handleKeep(address account, IMarket market, UFixed6 fee)\n        private\n        keep(\n            KeepConfig(\n                UFixed18Lib.ZERO,\n                keepBufferBase,\n                UFixed18Lib.ZERO,\n                keepBufferCalldata\n            ),\n            msg.data[0:0],\n            0,\n            abi.encode(account, market, fee)\n        )\n    { }\n\n    /// @notice Helper function to raise keeper fee\n    /// @param keeperFee Keeper fee to raise\n    /// @param data Data to raise keeper fee with\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory data) internal override {\n        (address account, IMarket market, UFixed6 fee) = abi.decode(data, (address, IMarket, UFixed6));\n        if (keeperFee.gt(UFixed18Lib.from(fee))) revert MultiInvokerMaxFeeExceededError();\n\n        market.update(\n            account,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            Fixed6Lib.from(Fixed18Lib.from(-1, keeperFee), true),\n            false\n        );\n    }\n\n    /// @notice Places order on behalf of msg.sender from the invoker\n    /// @param account Account to place order for\n    /// @param market Market to place order in\n    /// @param order Order state to place\n    function _placeOrder(\n        address account,\n        IMarket market,\n        TriggerOrder memory order\n    ) internal isMarketInstance(market) {\n        if (order.fee.isZero()) revert MultiInvokerInvalidOrderError();\n        if (order.comparison != -1 && order.comparison != 1) revert MultiInvokerInvalidOrderError();\n        if (\n            order.side > 3 ||                                       // Invalid side\n            (order.side == 3 && order.delta.gte(Fixed6Lib.ZERO))    // Disallow placing orders that increase collateral\n        ) revert MultiInvokerInvalidOrderError();\n\n        _orders[account][market][++latestNonce].store(order);\n        emit OrderPlaced(account, market, latestNonce, order);\n    }\n\n    /// @notice Cancels an open order for msg.sender\n    /// @param account Account to cancel order for\n    /// @param market Market order is open in\n    /// @param nonce UID of order\n    function _cancelOrder(address account, IMarket market, uint256 nonce) internal {\n        delete _orders[account][market][nonce];\n        emit OrderCancelled(account, market, nonce);\n    }\n\n    /// @notice Target market must be created by MarketFactory\n    modifier isMarketInstance(IMarket market) {\n        if (!marketFactory.instances(market))\n            revert MultiInvokerInvalidInstanceError();\n        _;\n    }\n\n    /// @notice Target vault must be created by VaultFactory\n    modifier isVaultInstance(IVault vault) {\n        if (!vaultFactory.instances(vault))\n            revert MultiInvokerInvalidInstanceError();\n        _;\n    }\n\n}"
    }
  ]
}