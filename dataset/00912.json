{
  "Title": "M-7: Pending keeper and position fees are not accounted for in vault collateral calculation which can be abused to liquidate vault when it's small",
  "Content": "# Issue M-7: Pending keeper and position fees are not accounted for in vault collateral calculation which can be abused to liquidate vault when it's small \n\nSource: https://github.com/sherlock-audit/2023-10-perennial-judging/issues/28 \n\n## Found by \npanprog\n## Summary\n\nVault opens positions in the underlying markets trying to keep leverage at the level set for each market by the owner. However, it uses sum of market collaterals which exclude keeper and position fees. But pending fees are included in account health calculations in the `Market` itself.\n\nWhen vault TVL is high, this difference is mostly unnoticable. However, if vault is small and keeper fee is high enough, it's possible to intentionally add keeper fees by depositing minimum amounts from different accounts in the same oracle version. This keeps/increases vault calculated collateral, but its pending collateral in underlying markets reduces due to fees, which increases actual vault leverage, so it's possible to increase vault leverage up to maximum leverage possible and even intentionally liquidate the vault.\n\nEven when the vault TVL is not low but keeper fee is large enough, the other issue reported allows to set vault leverage to max (according to margined amount) and then this issue allows to reduce vault collateral even further down to maintained amount and then commit slightly worse price and liquidate the vault.\n\n## Vulnerability Detail\n\nWhen vault leverage is calculated, it uses collateral equal to sum of collaterals of all markets, loaded as following:\n```solidity\n// local\nLocal memory local = registration.market.locals(address(this));\ncontext.latestIds.update(marketId, local.latestId);\ncontext.currentIds.update(marketId, local.currentId);\ncontext.collaterals[marketId] = local.collateral;\n```\n\nHowever, market's `local.collateral` excludes pending keeper and position fees. But pending fees are included in account health calculations in the `Market` itself (when loading pending positions):\n```solidity\n    context.pendingCollateral = context.pendingCollateral\n        .sub(newPendingPosition.fee)\n        .sub(Fixed6Lib.from(newPendingPosition.keeper));\n...\n    if (protected && (\n        !context.closable.isZero() || // @audit-issue even if closable is 0, position can still increase\n        context.latestPosition.local.maintained(\n            context.latestVersion,\n            context.riskParameter,\n@@@         context.pendingCollateral.sub(collateral)\n        ) ||\n        collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context, newOrder)))\n    )) revert MarketInvalidProtectionError();\n...\n    if (\n@@@     !context.currentPosition.local.margined(context.latestVersion, context.riskParameter, context.pendingCollateral)\n    ) revert MarketInsufficientMarginError();\n\n    if (\n@@@     !PositionLib.maintained(context.maxPendingMagnitude, context.latestVersion, context.riskParameter, context.pendingCollateral)\n    ) revert MarketInsufficientMaintenanceError();\n```\n\nThis means that small vault deposits from different accounts will be used for fees, but these fees will not be counted in vault underlying markets leverage calculations, allowing to increase vault's actual leverage.\n\n## Impact\n\nWhen vault TVL is small and keeper fees are high enough, it's possible to intentionally increase actual vault leverage and liquidate the vault by creating many small deposits from different user accounts, making the vault users lose their funds.\n\n## Code Snippet\n\nVault allocations to markets is calculated using collateral value:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L121-L126\n\nThis collateral value is calculated as the sum of collaterals in underlying markets (`local.collateral`):\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/Vault.sol#L501-L505\n\n`context.collaterals` is loaded as following:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/Vault.sol#L456-L460\n\n`local.collateral` excludes pending fees. Pending fees are added as seen in Market:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L249-L251\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider subtracting pending fees when loading underlying markets data context in the vault.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/123",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/Registration.sol\";\n\n/// @dev The context of an underlying market\nstruct MarketStrategyContext {\n    /// @dev The market parameter set\n    MarketParameter marketParameter;\n\n    /// @dev The risk parameter set\n    RiskParameter riskParameter;\n\n    /// @dev The local state of the vault\n    Local local;\n\n    /// @dev The vault's current account position\n    Position currentAccountPosition;\n\n    /// @dev The vault's latest account position\n    Position latestAccountPosition;\n\n    /// @dev The current global position\n    Position currentPosition;\n\n    /// @dev The latest valid price\n    Fixed6 latestPrice;\n\n    /// @dev The margin requirement of the vault\n    UFixed6 margin;\n\n    /// @dev The current closable amount of the vault\n    UFixed6 closable;\n}\n\nstruct Strategy {\n    MarketStrategyContext[] marketContexts;\n}\nusing StrategyLib for Strategy global;\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @dev Internal struct to avoid stack to deep error\n    struct _AllocateLocals {\n        UFixed6 marketCollateral;\n        UFixed6 marketAssets;\n        UFixed6 minPosition;\n        UFixed6 maxPosition;\n        UFixed6 minAssets;\n        uint256 totalWeight;\n        UFixed6 totalMargin;\n    }\n\n    function load(Registration[] memory registrations) internal view returns (Strategy memory strategy) {\n        strategy.marketContexts = new MarketStrategyContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++)\n            strategy.marketContexts[marketId] = _loadContext(registrations[marketId]);\n    }\n\n    function maxRedeem(\n        Strategy memory strategy,\n        Registration[] memory registrations,\n        uint256 totalWeight\n    ) internal pure returns (UFixed6 redemptionAssets) {\n        redemptionAssets = UFixed6Lib.MAX;\n        for (uint256 marketId; marketId < strategy.marketContexts.length; marketId++) {\n            MarketStrategyContext memory marketContext = strategy.marketContexts[marketId];\n            Registration memory registration = registrations[marketId];\n\n            // If market has 0 weight, leverage, or position, skip\n            if (\n                registration.weight == 0 ||\n                registration.leverage.isZero() || (\n                    marketContext.latestAccountPosition.maker.isZero() &&\n                    marketContext.currentAccountPosition.maker.isZero()\n                )\n            ) continue;\n\n            UFixed6 collateral = marketContext.currentPosition.maker\n                .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))  // available maker\n                .min(marketContext.closable.mul(StrategyLib.LEVERAGE_BUFFER))                       // available closable\n                .muldiv(marketContext.latestPrice.abs(), registration.leverage)                     // available collateral\n                .muldiv(totalWeight, registration.weight);                                          // collateral in market\n\n            redemptionAssets = redemptionAssets.min(collateral);\n        }\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param strategy The strategy of the vault\n    /// @param registrations The registrations of the markets\n    /// @param collateral The amount of collateral to allocate\n    /// @param assets The amount of collateral that is eligible for positions\n    function allocate(\n        Strategy memory strategy,\n        Registration[] memory registrations,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) internal pure returns (MarketTarget[] memory targets) {\n        _AllocateLocals memory _locals;\n        (_locals.totalWeight, _locals.totalMargin) = _aggregate(registrations, strategy.marketContexts);\n\n        targets = new MarketTarget[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n\n            _locals.marketCollateral = strategy.marketContexts[marketId].margin\n                .add(collateral.sub(_locals.totalMargin).muldiv(registrations[marketId].weight, _locals.totalWeight));\n\n            _locals.marketAssets = assets\n                .muldiv(registrations[marketId].weight, _locals.totalWeight)\n                .min(_locals.marketCollateral.mul(LEVERAGE_BUFFER));\n\n            _locals.minAssets = strategy.marketContexts[marketId].riskParameter.minMargin\n                .unsafeDiv(registrations[marketId].leverage.mul(strategy.marketContexts[marketId].riskParameter.maintenance));\n            if (strategy.marketContexts[marketId].marketParameter.closed || _locals.marketAssets.lt(_locals.minAssets))\n                _locals.marketAssets = UFixed6Lib.ZERO;\n\n            (_locals.minPosition, _locals.maxPosition) = _positionLimit(strategy.marketContexts[marketId]);\n\n            (targets[marketId].collateral, targets[marketId].position) = (\n                Fixed6Lib.from(_locals.marketCollateral).sub(strategy.marketContexts[marketId].local.collateral),\n                _locals.marketAssets\n                    .muldiv(registrations[marketId].leverage, strategy.marketContexts[marketId].latestPrice.abs())\n                    .min(_locals.maxPosition)\n                    .max(_locals.minPosition)\n            );\n        }\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return marketContext The context of the market\n    function _loadContext(Registration memory registration) private view returns (MarketStrategyContext memory marketContext) {\n        marketContext.marketParameter = registration.market.parameter();\n        marketContext.riskParameter = registration.market.riskParameter();\n        marketContext.local = registration.market.locals(address(this));\n        Global memory global = registration.market.global();\n        marketContext.latestPrice = global.latestPrice;\n\n        // latest position\n        UFixed6 previousClosable;\n        previousClosable = _loadPosition(\n            marketContext,\n            marketContext.latestAccountPosition = registration.market.positions(address(this)),\n            previousClosable\n        );\n        marketContext.closable = marketContext.latestAccountPosition.maker;\n\n        // pending positions\n        for (uint256 id = marketContext.local.latestId + 1; id <= marketContext.local.currentId; id++)\n            previousClosable = _loadPosition(\n                marketContext,\n                marketContext.currentAccountPosition = registration.market.pendingPositions(address(this), id),\n                previousClosable\n            );\n\n        // current position\n        Position memory latestPosition = registration.market.position();\n        marketContext.currentPosition = registration.market.pendingPosition(global.currentId);\n        marketContext.currentPosition.adjust(latestPosition);\n    }\n\n    /// @notice Loads one position for the context calculation\n    /// @param marketContext The context of the market\n    /// @param position The position to load\n    /// @param previousMaker The previous maker position\n    /// @return nextMaker The next maker position\n    function _loadPosition(\n        MarketStrategyContext memory marketContext,\n        Position memory position,\n        UFixed6 previousMaker\n    ) private pure returns (UFixed6 nextMaker) {\n        position.adjust(marketContext.latestAccountPosition);\n\n        marketContext.margin = position\n            .margin(OracleVersion(0, marketContext.latestPrice, true), marketContext.riskParameter)\n            .max(marketContext.margin);\n        marketContext.closable = marketContext.closable.sub(previousMaker.sub(position.maker.min(previousMaker)));\n        nextMaker = position.maker;\n    }\n\n    /// @notice Aggregate the context of all markets\n    /// @param registrations The registrations of the markets\n    /// @param marketContexts The contexts of the markets\n    /// @return totalWeight The total weight of all markets\n    /// @return totalMargin The total margin of all markets\n    function _aggregate(\n        Registration[] memory registrations,\n        MarketStrategyContext[] memory marketContexts\n    ) private pure returns (uint256 totalWeight, UFixed6 totalMargin) {\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            totalWeight += registrations[marketId].weight;\n            totalMargin = totalMargin.add(marketContexts[marketId].margin);\n        }\n    }\n\n    /// @notice Compute the position limit of a market\n    /// @param marketContext The context of the market\n    /// @return The minimum position size before crossing the net position\n    /// @return The maximum position size before crossing the maker limit\n    function _positionLimit(MarketStrategyContext memory marketContext) private pure returns (UFixed6, UFixed6) {\n        return (\n            // minimum position size before crossing the net position\n            marketContext.currentAccountPosition.maker.sub(\n            marketContext.currentPosition.maker\n                    .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))\n                    .min(marketContext.currentAccountPosition.maker)\n                    .min(marketContext.closable)\n            ),\n            // maximum position size before crossing the maker limit\n            marketContext.currentAccountPosition.maker.add(\n            marketContext.riskParameter.makerLimit\n                    .sub(marketContext.currentPosition.maker.min(marketContext.riskParameter.makerLimit))\n            )\n        );\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/Vault.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IVaultFactory.sol\";\nimport \"./types/Account.sol\";\nimport \"./types/Checkpoint.sol\";\nimport \"./types/Registration.sol\";\nimport \"./types/Mapping.sol\";\nimport \"./types/VaultParameter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./lib/StrategyLib.sol\";\n\n/// @title Vault\n/// @notice Deploys underlying capital by weight in maker positions across registered markets\n/// @dev Vault deploys and rebalances collateral between the registered markets, while attempting to\n///      maintain `targetLeverage` with its open maker positions at any given time. Deposits are only gated in so much\n///      as to cap the maximum amount of assets in the vault.\n///\n///      All registered markets are expected to be on the same \"clock\", i.e. their oracle.current() is always equal.\n///\n///      The vault has a \"delayed settlement\" mechanism. After depositing to or redeeming from the vault, a user must\n///      wait until the next settlement of all underlying markets in order for vault settlement to be available.\ncontract Vault is IVault, Instance {\n    /// @dev The vault's name\n    string private _name;\n\n    /// @dev The underlying asset\n    Token18 public asset;\n\n    /// @dev The vault parameter set\n    VaultParameterStorage private _parameter;\n\n    /// @dev The total number of registered markets\n    uint256 public totalMarkets;\n\n    /// @dev Per-market registration state variables\n    mapping(uint256 => RegistrationStorage) private _registrations;\n\n    /// @dev Per-account accounting state variables\n    mapping(address => AccountStorage) private _accounts;\n\n    /// @dev Per-id accounting state variables\n    mapping(uint256 => CheckpointStorage) private _checkpoints;\n\n    /// @dev Per-id id-mapping state variables\n    mapping(uint256 => MappingStorage) private _mappings;\n\n    /// @notice Initializes the vault\n    /// @param asset_ The underlying asset\n    /// @param initialMarket The initial market to register\n    /// @param name_ The vault's name\n    function initialize(\n        Token18 asset_,\n        IMarket initialMarket,\n        UFixed6 cap,\n        string calldata name_\n    ) external initializer(1) {\n        __Instance__initialize();\n\n        asset = asset_;\n        _name = name_;\n        _register(initialMarket);\n        _updateMarket(0, 1, UFixed6Lib.ZERO);\n        _updateParameter(VaultParameter(cap));\n    }\n\n    /// @notice Returns the vault parameter set\n    /// @return The vault parameter set\n    function parameter() external view returns (VaultParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the registration for a given market\n    /// @param marketId The market id\n    /// @return The registration for the given market\n    function registrations(uint256 marketId) external view returns (Registration memory) {\n        return _registrations[marketId].read();\n    }\n\n    /// @notice Returns the account state for a account\n    /// @param account The account to query\n    /// @return The account state for the given account\n    function accounts(address account) external view returns (Account memory) {\n        return _accounts[account].read();\n    }\n\n    /// @notice Returns the checkpoint for a given id\n    /// @param id The id to query\n    /// @return The checkpoint for the given id\n    function checkpoints(uint256 id) external view returns (Checkpoint memory) {\n        return _checkpoints[id].read();\n    }\n\n    /// @notice Returns the mapping for a given id\n    /// @param id The id to query\n    /// @return The mapping for the given id\n    function mappings(uint256 id) external view returns (Mapping memory) {\n        return _mappings[id].read();\n    }\n\n    /// @notice Returns the name of the vault\n    /// @return The name of the vault\n    function name() external view returns (string memory) {\n        return string(abi.encodePacked(\"Perennial V2 Vault: \", _name));\n    }\n\n    /// @notice Returns the total number of underlying assets at the last checkpoint\n    /// @return The total number of underlying assets at the last checkpoint\n    function totalAssets() public view returns (Fixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.assets\n            .add(Fixed6Lib.from(checkpoint.deposit))\n            .sub(Fixed6Lib.from(checkpoint.toAssetsGlobal(checkpoint.redemption)));\n    }\n\n    /// @notice Returns the total number of shares at the last checkpoint\n    /// @return The total number of shares at the last checkpoint\n    function totalShares() public view returns (UFixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.shares\n            .add(checkpoint.toSharesGlobal(checkpoint.deposit))\n            .sub(checkpoint.redemption);\n    }\n\n    /// @notice Converts a given amount of assets to shares\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets\n    function convertToShares(UFixed6 assets) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.from(totalAssets().max(Fixed6Lib.ZERO)), totalShares());\n        return _totalShares.isZero() ? assets : assets.muldiv(_totalShares, _totalAssets);\n    }\n\n    /// @notice Converts a given amount of shares to assets\n    /// @param shares Number of shares to convert to assets\n    /// @return Amount of assets for the given shares\n    function convertToAssets(UFixed6 shares) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.from(totalAssets().max(Fixed6Lib.ZERO)), totalShares());\n        return _totalShares.isZero() ? shares : shares.muldiv(_totalAssets, _totalShares);\n    }\n\n    /// @notice Registers a new market\n    /// @param market The market to register\n    function register(IMarket market) external onlyOwner {\n        settle(address(0));\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            if (_registrations[marketId].read().market == market) revert VaultMarketExistsError();\n        }\n\n        _register(market);\n    }\n\n    /// @notice Handles the registration for a new market\n    /// @param market The market to register\n    function _register(IMarket market) private {\n        if (!IVaultFactory(address(factory())).marketFactory().instances(market)) revert VaultNotMarketError();\n        if (!market.token().eq(asset)) revert VaultIncorrectAssetError();\n\n        asset.approve(address(market));\n\n        uint256 newMarketId = totalMarkets++;\n        _registrations[newMarketId].store(Registration(market, 0, UFixed6Lib.ZERO));\n        emit MarketRegistered(newMarketId, market);\n    }\n\n    /// @notice Settles, then updates the registration parameters for a given market\n    /// @param marketId The market id\n    /// @param newWeight The new weight\n    /// @param newLeverage The new leverage\n    function updateMarket(uint256 marketId, uint256 newWeight, UFixed6 newLeverage) external onlyOwner {\n        settle(address(0));\n        _updateMarket(marketId, newWeight, newLeverage);\n    }\n\n    /// @notice Updates the registration parameters for a given market\n    /// @param marketId The market id\n    /// @param newWeight The new weight\n    /// @param newLeverage The new leverage\n    function _updateMarket(uint256 marketId, uint256 newWeight, UFixed6 newLeverage) private {\n        if (marketId >= totalMarkets) revert VaultMarketDoesNotExistError();\n\n        Registration memory registration = _registrations[marketId].read();\n        registration.weight = newWeight;\n        registration.leverage = newLeverage;\n        _registrations[marketId].store(registration);\n        emit MarketUpdated(marketId, newWeight, newLeverage);\n    }\n\n    /// @notice Settles, then updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function updateParameter(VaultParameter memory newParameter) external onlyOwner {\n        settle(address(0));\n        _updateParameter(newParameter);\n    }\n\n    /// @notice Updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function _updateParameter(VaultParameter memory newParameter) private {\n        _parameter.store(newParameter);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Claims the accrued rewards for each registered market\n    /// @dev Callable by owner in case vault accrues rewards, since it is not able to disperse them itself\n    function claimReward() external onlyOwner {\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            _registrations[marketId].read().market.claimReward();\n            _registrations[marketId].read().market.reward().push(factory().owner());\n        }\n    }\n\n    /// @notice Syncs `account`'s state up to current\n    /// @dev Also rebalances the collateral and position of the vault without a deposit or withdraw\n    /// @param account The account that should be synced\n    function settle(address account) public whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _manage(context, UFixed6Lib.ZERO, false);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates `account`, depositing `depositAssets` assets, redeeming `redeemShares` shares, and claiming `claimAssets` assets\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function update(\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) external whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _checkpoint(context);\n        _update(context, account, depositAssets, redeemShares, claimAssets);\n        _saveContext(context, account);\n    }\n\n    /// @notice loads or initializes the current checkpoint\n    /// @param context The context to use\n    function _checkpoint(Context memory context) private {\n        context.currentId = context.global.current;\n        if (_mappings[context.currentId].read().next(context.currentIds)) {\n            context.currentId++;\n            context.currentCheckpoint.initialize(context.global, asset.balanceOf());\n            _mappings[context.currentId].store(context.currentIds);\n        } else {\n            context.currentCheckpoint = _checkpoints[context.currentId].read();\n        }\n    }\n\n    /// @notice Handles updating the account's position\n    /// @param context The context to use\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) private {\n        // load strategy\n        context.strategy = StrategyLib.load(context.registrations);\n\n        // magic values\n        if (claimAssets.eq(UFixed6Lib.MAX)) claimAssets = context.local.assets;\n        if (redeemShares.eq(UFixed6Lib.MAX)) redeemShares = context.local.shares;\n\n        // invariant\n        if (msg.sender != account && !IVaultFactory(address(factory())).operators(account, msg.sender))\n            revert VaultNotOperatorError();\n        if (!depositAssets.add(redeemShares).add(claimAssets).eq(depositAssets.max(redeemShares).max(claimAssets)))\n            revert VaultNotSingleSidedError();\n        if (depositAssets.gt(_maxDeposit(context)))\n            revert VaultDepositLimitExceededError();\n        if (redeemShares.gt(_maxRedeem(context)))\n            revert VaultRedemptionLimitExceededError();\n        if (!depositAssets.isZero() && depositAssets.lt(context.settlementFee))\n            revert VaultInsufficientMinimumError();\n        if (!redeemShares.isZero() && context.latestCheckpoint.toAssets(redeemShares, context.settlementFee).isZero())\n            revert VaultInsufficientMinimumError();\n        if (context.local.current != context.local.latest) revert VaultExistingOrderError();\n\n        // asses socialization and settlement fee\n        UFixed6 claimAmount = _socialize(context, depositAssets, redeemShares, claimAssets);\n\n        // update positions\n        context.global.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.local.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.currentCheckpoint.update(depositAssets, redeemShares);\n\n        // manage assets\n        asset.pull(msg.sender, UFixed18Lib.from(depositAssets));\n        _manage(context, claimAmount, true);\n        asset.push(msg.sender, UFixed18Lib.from(claimAmount));\n\n        emit Updated(msg.sender, account, context.currentId, depositAssets, redeemShares, claimAssets);\n    }\n\n    /// @notice Returns the claim amount after socialization and settlement fee\n    /// @param context The context to use\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function _socialize(\n        Context memory context,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) private view returns (UFixed6 claimAmount) {\n        UFixed6 totalCollateral = UFixed6Lib.from(_collateral(context).max(Fixed6Lib.ZERO));\n        claimAmount = context.global.assets.isZero() ?\n            UFixed6Lib.ZERO :\n            claimAssets.muldiv(totalCollateral.min(context.global.assets), context.global.assets);\n\n        if (depositAssets.isZero() && redeemShares.isZero()) claimAmount = claimAmount.sub(context.settlementFee);\n    }\n\n    /// @notice Handles settling the vault's underlying markets\n    function _settleUnderlying() private {\n        for (uint256 marketId; marketId < totalMarkets; marketId++)\n            _registrations[marketId].read().market.update(\n                address(this),\n                UFixed6Lib.MAX,\n                UFixed6Lib.ZERO,\n                UFixed6Lib.ZERO,\n                Fixed6Lib.ZERO,\n                false\n            );\n    }\n\n    /// @notice Handles settling the vault state\n    /// @dev Run before every stateful operation to settle up the latest global state of the vault\n    /// @param context The context to use\n    function _settle(Context memory context, address account) private {\n        // settle global positions\n        while (\n            context.global.current > context.global.latest &&\n            _mappings[context.global.latest + 1].read().ready(context.latestIds)\n        ) {\n            uint256 newLatestId = context.global.latest + 1;\n            context.latestCheckpoint = _checkpoints[newLatestId].read();\n            (Fixed6 collateralAtId, UFixed6 feeAtId, UFixed6 keeperAtId) = _collateralAtId(context, newLatestId);\n            context.latestCheckpoint.complete(collateralAtId, feeAtId, keeperAtId);\n\n            context.global.processGlobal(\n                newLatestId,\n                context.latestCheckpoint,\n                context.latestCheckpoint.deposit,\n                context.latestCheckpoint.redemption\n            );\n            _checkpoints[newLatestId].store(context.latestCheckpoint);\n        }\n\n        if (account == address(0)) return;\n\n        // settle local position\n        if (\n            context.local.current > context.local.latest &&\n            _mappings[context.local.current].read().ready(context.latestIds)\n        ) {\n            uint256 newLatestId = context.local.current;\n            Checkpoint memory checkpoint = _checkpoints[newLatestId].read();\n            context.local.processLocal(\n                newLatestId,\n                checkpoint,\n                context.local.deposit,\n                context.local.redemption\n            );\n        }\n    }\n\n    /// @notice Manages the internal collateral and position strategy of the vault\n    /// @param withdrawAmount The amount of assets that need to be withdrawn from the markets into the vault\n    /// @param rebalance Whether to rebalance the vault's position\n    function _manage(Context memory context, UFixed6 withdrawAmount, bool rebalance) private {\n        (Fixed6 collateral, UFixed6 assets) = _treasury(context, withdrawAmount);\n\n        if (!rebalance || collateral.lt(Fixed6Lib.ZERO)) return;\n\n        StrategyLib.MarketTarget[] memory targets = context.strategy.allocate(\n            context.registrations,\n            UFixed6Lib.from(collateral.max(Fixed6Lib.ZERO)),\n            assets\n        );\n\n        for (uint256 marketId; marketId < context.registrations.length; marketId++)\n            if (targets[marketId].collateral.lt(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId]);\n        for (uint256 marketId; marketId < context.registrations.length; marketId++)\n            if (targets[marketId].collateral.gte(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId]);\n    }\n\n    /// @notice Returns the amount of collateral and assets in the vault\n    /// @param context The context to use\n    /// @param withdrawAmount The amount of assets that need to be withdrawn from the markets into the vault\n    function _treasury(Context memory context, UFixed6 withdrawAmount) private view returns (Fixed6 collateral, UFixed6 assets) {\n        collateral = _collateral(context).sub(Fixed6Lib.from(withdrawAmount));\n\n        // collateral currently deployed\n        Fixed6 liabilities = Fixed6Lib.from(context.global.assets.add(context.global.deposit));\n        // net assets\n        assets = UFixed6Lib.from(collateral.sub(liabilities).max(Fixed6Lib.ZERO))\n            // approximate assets up for redemption\n            .mul(context.global.shares.unsafeDiv(context.global.shares.add(context.global.redemption)))\n            // deploy assets up for deposit\n            .add(context.global.deposit);\n    }\n\n    /// @notice Adjusts the position on `market` to `targetPosition`\n    /// @param target The new state to target\n    function _retarget(Registration memory registration, StrategyLib.MarketTarget memory target) private {\n        registration.market.update(\n            address(this),\n            target.position,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            target.collateral,\n            false\n        );\n    }\n\n    /// @notice Loads the context for the given `account`\n    /// @param account Account to load the context for\n    /// @return context The context\n    function _loadContext(address account) private view returns (Context memory context) {\n        context.parameter = _parameter.read();\n\n        context.currentIds.initialize(totalMarkets);\n        context.latestIds.initialize(totalMarkets);\n        context.registrations = new Registration[](totalMarkets);\n        context.collaterals = new Fixed6[](totalMarkets);\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            // parameter\n            Registration memory registration = _registrations[marketId].read();\n            MarketParameter memory marketParameter = registration.market.parameter();\n\n            context.registrations[marketId] = registration;\n            context.totalWeight += registration.weight;\n            context.settlementFee = context.settlementFee.add(marketParameter.settlementFee);\n\n            // local\n            Local memory local = registration.market.locals(address(this));\n            context.latestIds.update(marketId, local.latestId);\n            context.currentIds.update(marketId, local.currentId);\n            context.collaterals[marketId] = local.collateral;\n        }\n\n        if (account != address(0)) context.local = _accounts[account].read();\n        context.global = _accounts[address(0)].read();\n        context.latestCheckpoint = _checkpoints[context.global.latest].read();\n    }\n\n    /// @notice Saves the context into storage\n    /// @param context Context to use\n    /// @param account Account to save the context for\n    function _saveContext(Context memory context, address account) private {\n        if (account != address(0)) _accounts[account].store(context.local);\n        _accounts[address(0)].store(context.global);\n        _checkpoints[context.currentId].store(context.currentCheckpoint);\n    }\n\n    /// @notice The maximum available deposit amount\n    /// @param context Context to use in calculation\n    /// @return Maximum available deposit amount\n    function _maxDeposit(Context memory context) private view returns (UFixed6) {\n        if (context.latestCheckpoint.unhealthy()) return UFixed6Lib.ZERO;\n        UFixed6 collateral = UFixed6Lib.from(totalAssets().max(Fixed6Lib.ZERO)).add(context.global.deposit);\n        return context.global.assets.add(context.parameter.cap.sub(collateral.min(context.parameter.cap)));\n    }\n\n    /// @notice The maximum available redemption amount for `account`\n    /// @param context Context to use\n    /// @return redemptionAmount Maximum available redemption amount\n    function _maxRedeem(Context memory context) private pure returns (UFixed6) {\n        if (context.latestCheckpoint.unhealthy()) return UFixed6Lib.ZERO;\n        UFixed6 maxRedeemAssets = context.strategy.maxRedeem(context.registrations, context.totalWeight);\n        UFixed6 maxRedeemShares = maxRedeemAssets.eq(UFixed6Lib.MAX) ?\n            UFixed6Lib.MAX :\n            context.latestCheckpoint.toShares(maxRedeemAssets, UFixed6Lib.ZERO);\n\n        return maxRedeemShares.min(context.local.shares);\n    }\n\n    /// @notice Returns the real amount of collateral in the vault\n    /// @return value The real amount of collateral in the vault\n    function _collateral(Context memory context) public view returns (Fixed6 value) {\n        value = Fixed6Lib.from(UFixed6Lib.from(asset.balanceOf()));\n        for (uint2"
    }
  ]
}