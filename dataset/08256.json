{
  "Title": "[12] Simplify `supportsInterface` check",
  "Content": "\n### 12.1 NFTDropCollection.sol\n\n`NFTDropCollection.supportsInterface` (lines [284-295](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L284-L295)) can be changed to:\n\n```solidity\nfunction supportsInterface(bytes4 interfaceId)\n\tpublic\n\tview\n\toverride(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n\treturns (bool)\n{\n\treturn (\n\t\tinterfaceId == type(INFTDropCollectionMint).interfaceId || \n\t\tsuper.supportsInterface(interfaceId);\n\t);\n}\n```\n\n### 12.2 CollectionRoyalties.sol\n\n`CollectionRoyalties.supportsInterface` (lines [80-91](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/collections/CollectionRoyalties.sol#L80-L91)) can be changed to:\n\n```solidity\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\treturn (\n\t\tinterfaceId == type(IRoyaltyInfo).interfaceId ||\n\t\tinterfaceId == type(ITokenCreator).interfaceId ||\n\t\tinterfaceId == type(IGetRoyalties).interfaceId ||\n\t\tinterfaceId == type(IGetFees).interfaceId ||\n\t\tinterfaceSupported = super.supportsInterface(interfaceId)\n\t)\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-foundation",
  "Code": [
    {
      "filename": "contracts/NFTDropCollection.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTDropCollectionMint.sol\";\n\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/roles/AdminRole.sol\";\nimport \"./mixins/roles/MinterRole.sol\";\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A contract to batch mint a collection of NFTs.\n * @notice A 10% royalty to the creator is included which may be split with collaborators.\n * @dev A collection can have up to 4,294,967,295 (2^32-1) tokens\n */\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ContextUpgradeable,\n  ERC165Upgradeable,\n  AccessControlUpgradeable,\n  AdminRole,\n  MinterRole,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using Strings for uint256;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address to pay the proceeds/royalties for the collection.\n   * @dev If this is set to address(0) then the proceeds go to the creator.\n   */\n  address payable private paymentAddress;\n  // 96 bits free space\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `<tokenId>.json` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for `tokenId`: \"1\" with `baseURI`: \"ipfs://foo/\" is \"ipfs://foo/1.json\".\n   * @return The base URI used by this collection.\n   */\n  string public baseURI;\n\n  /****** Slot 2 ******/\n  /**\n   * @notice The hash of the revealed baseURI for the collection.\n   * @dev This can be used to verify that the content was not changed after NFTs were minted.\n   * @return bytes32(0) if the content has been revealed.\n   * In pre-reveal state this is set to bytes32(1) when the final content is unknown\n   * otherwise set to keccak256(finalContentBaseURI).\n   */\n  bytes32 public postRevealBaseURIHash;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice Emitted when the collection is revealed.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  event URIUpdated(string baseURI, bytes32 postRevealBaseURIHash);\n\n  modifier validBaseURI(string calldata _baseURI) {\n    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\n    _;\n  }\n\n  modifier onlyWhileUnrevealed() {\n    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\n    _;\n  }\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * This account is the default admin for this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   * @param _baseURI The base URI for the collection.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param _maxTokenId The max token id for this collection.\n   * @param _approvedMinter An optional address to grant the MINTER_ROLE.\n   * Set to address(0) if only admins should be granted permission to mint.\n   * @param _paymentAddress The address that will receive royalties and mint payments.\n   */\n  function initialize(\n    address payable _creator,\n    string calldata _name,\n    string calldata _symbol,\n    string calldata _baseURI,\n    bytes32 _postRevealBaseURIHash,\n    uint32 _maxTokenId,\n    address _approvedMinter,\n    address payable _paymentAddress\n  ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\n    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n\n    // Initialize the NFT\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, _maxTokenId);\n\n    // Initialize royalties\n    if (_paymentAddress != address(0)) {\n      // If no payment address was defined, use the creator's address.\n      paymentAddress = _paymentAddress;\n    }\n\n    // Initialize URI\n    baseURI = _baseURI;\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n\n    // Initialize access control\n    AdminRole._initializeAdminRole(_creator);\n    if (_approvedMinter != address(0)) {\n      MinterRole._initializeMinterRole(_approvedMinter);\n    }\n  }\n\n  /**\n   * @notice Allows the collection admin to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyAdmin` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyAdmin {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint `count` number of NFTs for the `to` address.\n   * @dev This is only callable by an address with either the MINTER_ROLE or the DEFAULT_ADMIN_ROLE.\n   * @param count The number of NFTs to mint.\n   * @param to The address to mint the NFTs for.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   */\n  function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n    unchecked {\n      // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n      firstTokenId = latestTokenId + 1;\n    }\n    latestTokenId = latestTokenId + count;\n    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n    for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n      _mint(to, i);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Allows a collection admin to reveal the collection's final content.\n   * @dev Once revealed, the collection's content is immutable.\n   * Use `updatePreRevealContent` to update content while unrevealed.\n   * @param _baseURI The base URI of the final content for this collection.\n   */\n  function reveal(string calldata _baseURI) external onlyAdmin validBaseURI(_baseURI) onlyWhileUnrevealed {\n    // `postRevealBaseURIHash` == 0 indicates that the collection has been revealed.\n    delete postRevealBaseURIHash;\n\n    // Set the new base URI.\n    baseURI = _baseURI;\n    emit URIUpdated(_baseURI, \"\");\n  }\n\n  /**\n   * @notice Allows a collection admin to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyAdmin {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyAdmin {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  /**\n   * @notice Allows a collection admin to update the pre-reveal content.\n   * @dev Use `reveal` to reveal the final content for this collection.\n   * @param _baseURI The base URI of the pre-reveal content.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n    external\n    validBaseURI(_baseURI)\n    onlyWhileUnrevealed\n    onlyAdmin\n  {\n    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n    baseURI = _baseURI;\n    emit URIUpdated(baseURI, postRevealBaseURIHash);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(\n    uint256 /* tokenId */\n  ) public view override returns (address payable creatorPaymentAddress) {\n    creatorPaymentAddress = paymentAddress;\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @notice Returns whether the collection has been revealed.\n   * @dev Once revealed, the collection's content is immutable.\n   * @return revealed True if the collection has been revealed.\n   */\n  function isRevealed() external view returns (bool revealed) {\n    revealed = postRevealBaseURIHash == bytes32(0);\n  }\n\n  /**\n   * @notice Get the number of tokens which can still be minted.\n   * @return count The max number of additional NFTs that can be minted by this collection.\n   */\n  function numberOfTokensAvailableToMint() external view returns (uint256 count) {\n    // Mint ensures that latestTokenId is always <= maxTokenId\n    unchecked {\n      count = maxTokenId - latestTokenId;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    if (interfaceId == type(INFTDropCollectionMint).interfaceId) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    _requireMinted(tokenId);\n\n    return string.concat(baseURI, tokenId.toString(), \".json\");\n  }\n}"
    },
    {
      "filename": "contracts/mixins/collections/CollectionRoyalties.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport \"../../interfaces/IGetFees.sol\";\nimport \"../../interfaces/IGetRoyalties.sol\";\nimport \"../../interfaces/IRoyaltyInfo.sol\";\nimport \"../../interfaces/ITokenCreator.sol\";\n\nimport \"../shared/Constants.sol\";\n\n/**\n * @title Defines various royalty APIs for broad marketplace support.\n */\nabstract contract CollectionRoyalties is IGetRoyalties, IGetFees, IRoyaltyInfo, ITokenCreator, ERC165Upgradeable {\n  /**\n   * @inheritdoc IGetFees\n   */\n  function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory recipients) {\n    recipients = new address payable[](1);\n    recipients[0] = getTokenCreatorPaymentAddress(tokenId);\n  }\n\n  /**\n   * @inheritdoc IGetFees\n   * @dev The tokenId param is ignored since all NFTs return the same value.\n   */\n  function getFeeBps(\n    uint256 /* tokenId */\n  ) external pure returns (uint256[] memory royaltiesInBasisPoints) {\n    royaltiesInBasisPoints = new uint256[](1);\n    royaltiesInBasisPoints[0] = ROYALTY_IN_BASIS_POINTS;\n  }\n\n  /**\n   * @inheritdoc IGetRoyalties\n   */\n  function getRoyalties(uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory royaltiesInBasisPoints)\n  {\n    recipients = new address payable[](1);\n    recipients[0] = getTokenCreatorPaymentAddress(tokenId);\n    royaltiesInBasisPoints = new uint256[](1);\n    royaltiesInBasisPoints[0] = ROYALTY_IN_BASIS_POINTS;\n  }\n\n  /**\n   * @notice The address to pay the creator proceeds/royalties for the collection.\n   * @param tokenId The ID of the NFT to get the creator payment address for.\n   * @return creatorPaymentAddress The address to which royalties should be paid.\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    virtual\n    returns (address payable creatorPaymentAddress);\n\n  /**\n   * @inheritdoc IRoyaltyInfo\n   */\n  function royaltyInfo(uint256 tokenId, uint256 salePrice)\n    external\n    view\n    returns (address receiver, uint256 royaltyAmount)\n  {\n    receiver = getTokenCreatorPaymentAddress(tokenId);\n    unchecked {\n      royaltyAmount = salePrice / ROYALTY_RATIO;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   * @dev Checks the supported royalty interfaces.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool interfaceSupported) {\n    if (\n      interfaceId == type(IRoyaltyInfo).interfaceId ||\n      interfaceId == type(ITokenCreator).interfaceId ||\n      interfaceId == type(IGetRoyalties).interfaceId ||\n      interfaceId == type(IGetFees).interfaceId\n    ) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n}"
    }
  ]
}