{
  "Title": "Lack of input validation",
  "Content": "The [`AcceleratingDistributor`](https://github.com/across-protocol/across-token/blob/dde7aedc766bf69f1cb0eb791b60259c705baa26/contracts/AcceleratingDistributor.sol#L19) contract includes some functions that do not properly validate their input parameters. Specifically:\n\n\n* The [`stakeFor`](https://github.com/across-protocol/across-token/blob/dde7aedc766bf69f1cb0eb791b60259c705baa26/contracts/AcceleratingDistributor.sol#L197) function does not check that the `beneficiary` address is not the zero address.\n* The [`unstake`](https://github.com/across-protocol/across-token/blob/dde7aedc766bf69f1cb0eb791b60259c705baa26/contracts/AcceleratingDistributor.sol#L210) and [`_stake`](https://github.com/across-protocol/across-token/blob/dde7aedc766bf69f1cb0eb791b60259c705baa26/contracts/AcceleratingDistributor.sol#L393) functions do not verify that the input `amount` is greater than zero.\n\n\nEven though these issues do not pose a security risk, the lack of validation on user-controlled parameters may result in erroneous transactions. Consider implementing appropriate validation on the input arguments for the cases listed above.\n\n\n***Update:** Resolved in [pull request #47](https://github.com/across-protocol/across-token/pull/47) with commit [d38d4cd](https://github.com/across-protocol/across-token/commit/d38d4cdd4797bd15f402cb17b02ef02beecf2557).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/AcceleratingDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\n\n/**\n * @notice Across token distribution contract. Contract is inspired by Synthetix staking contract and Ampleforth geyser.\n * Stakers start by earning their pro-rata share of a baseEmissionRate per second which increases based on how long\n * they have staked in the contract, up to a max emission rate of baseEmissionRate * maxMultiplier. Multiple LP tokens\n * can be staked in this contract enabling depositors to batch stake and claim via multicall. Note that this contract is\n * only compatible with standard ERC20 tokens, and not tokens that charge fees on transfers, dynamically change\n * balance, or have double entry-points. It's up to the contract owner to ensure they only add supported tokens.\n */\n\ncontract AcceleratingDistributor is ReentrancyGuard, Ownable, Multicall {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n\n    // Each User deposit is tracked with the information below.\n    struct UserDeposit {\n        uint256 cumulativeBalance;\n        uint256 averageDepositTime;\n        uint256 rewardsAccumulatedPerToken;\n        uint256 rewardsOutstanding;\n    }\n\n    struct StakingToken {\n        bool enabled;\n        uint256 baseEmissionRate;\n        uint256 maxMultiplier;\n        uint256 secondsToMaxMultiplier;\n        uint256 cumulativeStaked;\n        uint256 rewardPerTokenStored;\n        uint256 lastUpdateTime;\n        mapping(address => UserDeposit) stakingBalances;\n    }\n\n    mapping(address => StakingToken) public stakingTokens;\n\n    modifier onlyEnabled(address stakedToken) {\n        require(stakingTokens[stakedToken].enabled, \"stakedToken not enabled\");\n        _;\n    }\n\n    modifier onlyInitialized(address stakedToken) {\n        require(stakingTokens[stakedToken].lastUpdateTime != 0, \"stakedToken not initialized\");\n        _;\n    }\n\n    constructor(address _rewardToken) {\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /**************************************\n     *               EVENTS               *\n     **************************************/\n\n    event TokenConfiguredForStaking(\n        address indexed token,\n        bool enabled,\n        uint256 baseEmissionRate,\n        uint256 maxMultiplier,\n        uint256 secondsToMaxMultiplier,\n        uint256 lastUpdateTime\n    );\n    event RecoverToken(address indexed token, uint256 amount);\n    event Stake(\n        address indexed token,\n        address indexed user,\n        uint256 amount,\n        uint256 averageDepositTime,\n        uint256 cumulativeBalance,\n        uint256 tokenCumulativeStaked\n    );\n    event Unstake(\n        address indexed token,\n        address indexed user,\n        uint256 amount,\n        uint256 remainingCumulativeBalance,\n        uint256 tokenCumulativeStaked\n    );\n    event RewardsWithdrawn(\n        address indexed token,\n        address indexed user,\n        uint256 rewardsToSend,\n        uint256 tokenLastUpdateTime,\n        uint256 tokenRewardPerTokenStored,\n        uint256 userRewardsOutstanding,\n        uint256 userRewardsPaidPerToken\n    );\n    event Exit(address indexed token, address indexed user, uint256 tokenCumulativeStaked);\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Enable a token for staking.\n     * @dev The owner should ensure that the token enabled is a standard ERC20 token to ensure correct functionality.\n     * @param stakedToken The address of the token that can be staked.\n     * @param enabled Whether the token is enabled for staking.\n     * @param baseEmissionRate The base emission rate for staking the token. This is split pro-rata between all users.\n     * @param maxMultiplier The maximum multiplier for staking which increases your rewards the longer you stake.\n     * @param secondsToMaxMultiplier The number of seconds needed to stake to reach the maximum multiplier.\n     */\n    function configureStakingToken(\n        address stakedToken,\n        bool enabled,\n        uint256 baseEmissionRate,\n        uint256 maxMultiplier,\n        uint256 secondsToMaxMultiplier\n    ) external onlyOwner {\n        // Validate input to ensure system stability and avoid unexpected behavior. Note we dont place a lower bound on\n        // the baseEmissionRate. If this value is less than 1e18 then you will slowly loose your staking rewards over time.\n        // Because of the way balances are managed, the staked token cannot be the reward token. Otherwise, reward\n        // payouts could eat into user balances. We choose not to constrain `maxMultiplier` to be > 1e18 so that\n        // admin can choose to allow decreasing emissions over time. This is not the intended use case, but we see no\n        // benefit to removing this additional flexibility. If set < 1e18, then user's rewards outstanding will\n        // decrease over time. Incentives for stakers would look different if `maxMultiplier` were set < 1e18\n        require(stakedToken != address(rewardToken), \"Staked token is reward token\");\n        require(maxMultiplier < 1e36, \"maxMultiplier can not be set too large\");\n        require(secondsToMaxMultiplier > 0, \"secondsToMaxMultiplier must be greater than 0\");\n        require(baseEmissionRate < 1e27, \"baseEmissionRate can not be set too large\");\n\n        StakingToken storage stakingToken = stakingTokens[stakedToken];\n\n        // If this token is already initialized, make sure we update the rewards before modifying any params.\n        if (stakingToken.lastUpdateTime != 0) _updateReward(stakedToken, address(0));\n\n        stakingToken.enabled = enabled;\n        stakingToken.baseEmissionRate = baseEmissionRate;\n        stakingToken.maxMultiplier = maxMultiplier;\n        stakingToken.secondsToMaxMultiplier = secondsToMaxMultiplier;\n        stakingToken.lastUpdateTime = getCurrentTime();\n\n        emit TokenConfiguredForStaking(\n            stakedToken,\n            enabled,\n            baseEmissionRate,\n            maxMultiplier,\n            secondsToMaxMultiplier,\n            stakingToken.lastUpdateTime\n        );\n    }\n\n    /**\n     * @notice Enables the owner to recover tokens dropped onto the contract. This could be used to remove unclaimed\n     * staking rewards or recover excess LP tokens that were inadvertently dropped onto the contract. Importantly, the\n     * contract will only let the owner recover staked excess tokens above what the contract thinks it should have. i.e\n     * the owner cant use this method to steal staked tokens, only recover excess ones mistakenly sent to the contract.\n     * @param token The address of the token to skim.\n     */\n    function recoverToken(address token) external onlyOwner {\n        // If the token is an enabled staking token then we want to preform a skim action where we send back any extra\n        // tokens that are not accounted for in the cumulativeStaked variable. This lets the owner recover extra tokens\n        // sent to the contract that were not explicitly staked. if the token is not enabled for staking then we simply\n        // send back the full amount of tokens that the contract has.\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        if (stakingTokens[token].lastUpdateTime != 0) amount -= stakingTokens[token].cumulativeStaked;\n        require(amount > 0, \"Can't recover 0 tokens\");\n        IERC20(token).safeTransfer(owner(), amount);\n        emit RecoverToken(token, amount);\n    }\n\n    /**************************************\n     *          STAKER FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Stake tokens for rewards.\n     * @dev The caller of this function must approve this contract to spend amount of stakedToken.\n     * @param stakedToken The address of the token to stake.\n     * @param amount The amount of the token to stake.\n     */\n    function stake(address stakedToken, uint256 amount) external nonReentrant onlyEnabled(stakedToken) {\n        _stake(stakedToken, amount, msg.sender);\n    }\n\n    /**\n     * @notice Stake tokens for rewards on behalf of `beneficiary`.\n     * @dev The caller of this function must approve this contract to spend amount of stakedToken.\n     * @dev The caller of this function is effectively donating their tokens to the beneficiary. The beneficiary\n     * can then unstake or claim rewards as they wish.\n     * @param stakedToken The address of the token to stake.\n     * @param amount The amount of the token to stake.\n     * @param beneficiary User that caller wants to stake on behalf of.\n     */\n    function stakeFor(\n        address stakedToken,\n        uint256 amount,\n        address beneficiary\n    ) external nonReentrant onlyEnabled(stakedToken) {\n        _stake(stakedToken, amount, beneficiary);\n    }\n\n    /**\n     * @notice Withdraw staked tokens.\n     * @param stakedToken The address of the token to withdraw.\n     * @param amount The amount of the token to withdraw.\n     */\n    function unstake(address stakedToken, uint256 amount) public nonReentrant onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];\n\n        // Note: these will revert if underflow so you cant unstake more than your cumulativeBalance.\n        userDeposit.cumulativeBalance -= amount;\n        stakingTokens[stakedToken].cumulativeStaked -= amount;\n\n        IERC20(stakedToken).safeTransfer(msg.sender, amount);\n\n        emit Unstake(\n            stakedToken,\n            msg.sender,\n            amount,\n            userDeposit.cumulativeBalance,\n            stakingTokens[stakedToken].cumulativeStaked\n        );\n    }\n\n    /**\n     * @notice Get entitled rewards for the staker.\n     * @dev Calling this method will reset the caller's reward multiplier.\n     * @param stakedToken The address of the token to get rewards for.\n     */\n    function withdrawReward(address stakedToken) public nonReentrant onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];\n\n        uint256 rewardsToSend = userDeposit.rewardsOutstanding;\n        if (rewardsToSend > 0) {\n            userDeposit.rewardsOutstanding = 0;\n            userDeposit.averageDepositTime = getCurrentTime();\n            rewardToken.safeTransfer(msg.sender, rewardsToSend);\n        }\n\n        emit RewardsWithdrawn(\n            stakedToken,\n            msg.sender,\n            rewardsToSend,\n            stakingTokens[stakedToken].lastUpdateTime,\n            stakingTokens[stakedToken].rewardPerTokenStored,\n            userDeposit.rewardsOutstanding,\n            userDeposit.rewardsAccumulatedPerToken\n        );\n    }\n\n    /**\n     * @notice Exits a staking position by unstaking and getting rewards. This totally exits the staking position.\n     * @dev Calling this method will reset the caller's reward multiplier.\n     * @param stakedToken The address of the token to get rewards for.\n     */\n    function exit(address stakedToken) external onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        unstake(stakedToken, stakingTokens[stakedToken].stakingBalances[msg.sender].cumulativeBalance);\n        withdrawReward(stakedToken);\n\n        emit Exit(stakedToken, msg.sender, stakingTokens[stakedToken].cumulativeStaked);\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Returns the total staked for a given stakedToken.\n     * @param stakedToken The address of the staked token to query.\n     * @return uint256 Total amount staked of the stakedToken.\n     */\n    function getCumulativeStaked(address stakedToken) external view returns (uint256) {\n        return stakingTokens[stakedToken].cumulativeStaked;\n    }\n\n    /**\n     * @notice Returns all the information associated with a user's stake.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of user to query.\n     * @return UserDeposit Struct with: {cumulativeBalance,averageDepositTime,rewardsAccumulatedPerToken,rewardsOutstanding}\n     */\n    function getUserStake(address stakedToken, address account) external view returns (UserDeposit memory) {\n        return stakingTokens[stakedToken].stakingBalances[account];\n    }\n\n    /**\n     * @notice Returns the base rewards per staked token for a given staking token. This factors in the last time\n     * any internal logic was called on this contract to correctly attribute retroactive cumulative rewards.\n     * @dev the value returned is represented by a uint256 with fixed precision of 18 decimals.\n     * @param stakedToken The address of the staked token to query.\n     * @return uint256 Total base reward per token that will be applied, pro-rata, to stakers.\n     */\n    function baseRewardPerToken(address stakedToken) public view returns (uint256) {\n        StakingToken storage stakingToken = stakingTokens[stakedToken];\n        if (stakingToken.cumulativeStaked == 0) return stakingToken.rewardPerTokenStored;\n\n        return\n            stakingToken.rewardPerTokenStored +\n            ((getCurrentTime() - stakingToken.lastUpdateTime) * stakingToken.baseEmissionRate * 1e18) /\n            stakingToken.cumulativeStaked;\n    }\n\n    /**\n     * @notice Returns the multiplier applied to the base reward per staked token for a given staking token and account.\n     * The longer a user stakes the higher their multiplier up to maxMultiplier for that given staking token.\n     * any internal logic was called on this contract to correctly attribute retroactive cumulative rewards.\n     * @dev the value returned is represented by a uint256 with fixed precision of 18 decimals.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     * @return uint256 User multiplier, applied to the baseRewardPerToken, when claiming rewards.\n     */\n    function getUserRewardMultiplier(address stakedToken, address account) public view returns (uint256) {\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];\n        if (userDeposit.averageDepositTime == 0 || userDeposit.cumulativeBalance == 0) return 1e18;\n        uint256 fractionOfMaxMultiplier = ((getTimeSinceAverageDeposit(stakedToken, account)) * 1e18) /\n            stakingTokens[stakedToken].secondsToMaxMultiplier;\n\n        // At maximum, the multiplier should be equal to the maxMultiplier.\n        if (fractionOfMaxMultiplier > 1e18) fractionOfMaxMultiplier = 1e18;\n        return 1e18 + (fractionOfMaxMultiplier * (stakingTokens[stakedToken].maxMultiplier - 1e18)) / (1e18);\n    }\n\n    /**\n     * @notice Returns the total outstanding rewards entitled to a user for a given staking token. This factors in the\n     * users staking duration (and therefore reward multiplier) and their pro-rata share of the total rewards.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     * @return uint256 Total outstanding rewards entitled to user.\n     */\n    function getOutstandingRewards(address stakedToken, address account) public view returns (uint256) {\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];\n\n        uint256 userRewardMultiplier = getUserRewardMultiplier(stakedToken, account);\n\n        uint256 newUserRewards = (userDeposit.cumulativeBalance *\n            (baseRewardPerToken(stakedToken) - userDeposit.rewardsAccumulatedPerToken) *\n            userRewardMultiplier) / (1e18 * 1e18);\n\n        return newUserRewards + userDeposit.rewardsOutstanding;\n    }\n\n    /**\n     * @notice Returns the time that has elapsed between the current time and the last users average deposit time.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     *@return uint256 Time, in seconds, between the users average deposit time and the current time.\n     */\n    function getTimeSinceAverageDeposit(address stakedToken, address account) public view returns (uint256) {\n        return getCurrentTime() - stakingTokens[stakedToken].stakingBalances[account].averageDepositTime;\n    }\n\n    /**\n     * @notice Returns a users new average deposit time, considering the addition of a new deposit. This factors in the\n     * cumulative previous deposits, new deposit and time from the last deposit.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of the user to query.\n     * @return uint256 Average post deposit time, considering all deposits to date.\n     */\n    function getAverageDepositTimePostDeposit(\n        address stakedToken,\n        address account,\n        uint256 amount\n    ) public view returns (uint256) {\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[account];\n        if (amount == 0) return userDeposit.averageDepositTime;\n        uint256 amountWeightedTime = (((amount * 1e18) / (userDeposit.cumulativeBalance + amount)) *\n            (getTimeSinceAverageDeposit(stakedToken, account))) / 1e18;\n        return userDeposit.averageDepositTime + amountWeightedTime;\n    }\n\n    /**************************************\n     *         INTERNAL FUNCTIONS         *\n     **************************************/\n\n    // Update the internal counters for a given stakedToken and user.\n    function _updateReward(address stakedToken, address account) internal {\n        StakingToken storage stakingToken = stakingTokens[stakedToken];\n        stakingToken.rewardPerTokenStored = baseRewardPerToken(stakedToken);\n        stakingToken.lastUpdateTime = getCurrentTime();\n        if (account != address(0)) {\n            UserDeposit storage userDeposit = stakingToken.stakingBalances[account];\n            userDeposit.rewardsOutstanding = getOutstandingRewards(stakedToken, account);\n            userDeposit.rewardsAccumulatedPerToken = stakingToken.rewardPerTokenStored;\n        }\n    }\n\n    function _stake(\n        address stakedToken,\n        uint256 amount,\n        address staker\n    ) internal {\n        _updateReward(stakedToken, staker);\n\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[staker];\n\n        uint256 averageDepositTime = getAverageDepositTimePostDeposit(stakedToken, staker, amount);\n\n        userDeposit.averageDepositTime = averageDepositTime;\n        userDeposit.cumulativeBalance += amount;\n        stakingTokens[stakedToken].cumulativeStaked += amount;\n\n        IERC20(stakedToken).safeTransferFrom(msg.sender, address(this), amount);\n        emit Stake(\n            stakedToken,\n            staker,\n            amount,\n            averageDepositTime,\n            userDeposit.cumulativeBalance,\n            stakingTokens[stakedToken].cumulativeStaked\n        );\n    }\n}"
    },
    {
      "filename": "contracts/AcceleratingDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\n\n/**\n * @notice Across token distribution contract. Contract is inspired by Synthetix staking contract and Ampleforth geyser.\n * Stakers start by earning their pro-rata share of a baseEmissionRate per second which increases based on how long\n * they have staked in the contract, up to a max emission rate of baseEmissionRate * maxMultiplier. Multiple LP tokens\n * can be staked in this contract enabling depositors to batch stake and claim via multicall. Note that this contract is\n * only compatible with standard ERC20 tokens, and not tokens that charge fees on transfers, dynamically change\n * balance, or have double entry-points. It's up to the contract owner to ensure they only add supported tokens.\n */\n\ncontract AcceleratingDistributor is ReentrancyGuard, Ownable, Multicall {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n\n    // Each User deposit is tracked with the information below.\n    struct UserDeposit {\n        uint256 cumulativeBalance;\n        uint256 averageDepositTime;\n        uint256 rewardsAccumulatedPerToken;\n        uint256 rewardsOutstanding;\n    }\n\n    struct StakingToken {\n        bool enabled;\n        uint256 baseEmissionRate;\n        uint256 maxMultiplier;\n        uint256 secondsToMaxMultiplier;\n        uint256 cumulativeStaked;\n        uint256 rewardPerTokenStored;\n        uint256 lastUpdateTime;\n        mapping(address => UserDeposit) stakingBalances;\n    }\n\n    mapping(address => StakingToken) public stakingTokens;\n\n    modifier onlyEnabled(address stakedToken) {\n        require(stakingTokens[stakedToken].enabled, \"stakedToken not enabled\");\n        _;\n    }\n\n    modifier onlyInitialized(address stakedToken) {\n        require(stakingTokens[stakedToken].lastUpdateTime != 0, \"stakedToken not initialized\");\n        _;\n    }\n\n    constructor(address _rewardToken) {\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /**************************************\n     *               EVENTS               *\n     **************************************/\n\n    event TokenConfiguredForStaking(\n        address indexed token,\n        bool enabled,\n        uint256 baseEmissionRate,\n        uint256 maxMultiplier,\n        uint256 secondsToMaxMultiplier,\n        uint256 lastUpdateTime\n    );\n    event RecoverToken(address indexed token, uint256 amount);\n    event Stake(\n        address indexed token,\n        address indexed user,\n        uint256 amount,\n        uint256 averageDepositTime,\n        uint256 cumulativeBalance,\n        uint256 tokenCumulativeStaked\n    );\n    event Unstake(\n        address indexed token,\n        address indexed user,\n        uint256 amount,\n        uint256 remainingCumulativeBalance,\n        uint256 tokenCumulativeStaked\n    );\n    event RewardsWithdrawn(\n        address indexed token,\n        address indexed user,\n        uint256 rewardsToSend,\n        uint256 tokenLastUpdateTime,\n        uint256 tokenRewardPerTokenStored,\n        uint256 userRewardsOutstanding,\n        uint256 userRewardsPaidPerToken\n    );\n    event Exit(address indexed token, address indexed user, uint256 tokenCumulativeStaked);\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Enable a token for staking.\n     * @dev The owner should ensure that the token enabled is a standard ERC20 token to ensure correct functionality.\n     * @param stakedToken The address of the token that can be staked.\n     * @param enabled Whether the token is enabled for staking.\n     * @param baseEmissionRate The base emission rate for staking the token. This is split pro-rata between all users.\n     * @param maxMultiplier The maximum multiplier for staking which increases your rewards the longer you stake.\n     * @param secondsToMaxMultiplier The number of seconds needed to stake to reach the maximum multiplier.\n     */\n    function configureStakingToken(\n        address stakedToken,\n        bool enabled,\n        uint256 baseEmissionRate,\n        uint256 maxMultiplier,\n        uint256 secondsToMaxMultiplier\n    ) external onlyOwner {\n        // Validate input to ensure system stability and avoid unexpected behavior. Note we dont place a lower bound on\n        // the baseEmissionRate. If this value is less than 1e18 then you will slowly loose your staking rewards over time.\n        // Because of the way balances are managed, the staked token cannot be the reward token. Otherwise, reward\n        // payouts could eat into user balances. We choose not to constrain `maxMultiplier` to be > 1e18 so that\n        // admin can choose to allow decreasing emissions over time. This is not the intended use case, but we see no\n        // benefit to removing this additional flexibility. If set < 1e18, then user's rewards outstanding will\n        // decrease over time. Incentives for stakers would look different if `maxMultiplier` were set < 1e18\n        require(stakedToken != address(rewardToken), \"Staked token is reward token\");\n        require(maxMultiplier < 1e36, \"maxMultiplier can not be set too large\");\n        require(secondsToMaxMultiplier > 0, \"secondsToMaxMultiplier must be greater than 0\");\n        require(baseEmissionRate < 1e27, \"baseEmissionRate can not be set too large\");\n\n        StakingToken storage stakingToken = stakingTokens[stakedToken];\n\n        // If this token is already initialized, make sure we update the rewards before modifying any params.\n        if (stakingToken.lastUpdateTime != 0) _updateReward(stakedToken, address(0));\n\n        stakingToken.enabled = enabled;\n        stakingToken.baseEmissionRate = baseEmissionRate;\n        stakingToken.maxMultiplier = maxMultiplier;\n        stakingToken.secondsToMaxMultiplier = secondsToMaxMultiplier;\n        stakingToken.lastUpdateTime = getCurrentTime();\n\n        emit TokenConfiguredForStaking(\n            stakedToken,\n            enabled,\n            baseEmissionRate,\n            maxMultiplier,\n            secondsToMaxMultiplier,\n            stakingToken.lastUpdateTime\n        );\n    }\n\n    /**\n     * @notice Enables the owner to recover tokens dropped onto the contract. This could be used to remove unclaimed\n     * staking rewards or recover excess LP tokens that were inadvertently dropped onto the contract. Importantly, the\n     * contract will only let the owner recover staked excess tokens above what the contract thinks it should have. i.e\n     * the owner cant use this method to steal staked tokens, only recover excess ones mistakenly sent to the contract.\n     * @param token The address of the token to skim.\n     */\n    function recoverToken(address token) external onlyOwner {\n        // If the token is an enabled staking token then we want to preform a skim action where we send back any extra\n        // tokens that are not accounted for in the cumulativeStaked variable. This lets the owner recover extra tokens\n        // sent to the contract that were not explicitly staked. if the token is not enabled for staking then we simply\n        // send back the full amount of tokens that the contract has.\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        if (stakingTokens[token].lastUpdateTime != 0) amount -= stakingTokens[token].cumulativeStaked;\n        require(amount > 0, \"Can't recover 0 tokens\");\n        IERC20(token).safeTransfer(owner(), amount);\n        emit RecoverToken(token, amount);\n    }\n\n    /**************************************\n     *          STAKER FUNCTIONS          *\n     **************************************/\n\n    /**\n     * @notice Stake tokens for rewards.\n     * @dev The caller of this function must approve this contract to spend amount of stakedToken.\n     * @param stakedToken The address of the token to stake.\n     * @param amount The amount of the token to stake.\n     */\n    function stake(address stakedToken, uint256 amount) external nonReentrant onlyEnabled(stakedToken) {\n        _stake(stakedToken, amount, msg.sender);\n    }\n\n    /**\n     * @notice Stake tokens for rewards on behalf of `beneficiary`.\n     * @dev The caller of this function must approve this contract to spend amount of stakedToken.\n     * @dev The caller of this function is effectively donating their tokens to the beneficiary. The beneficiary\n     * can then unstake or claim rewards as they wish.\n     * @param stakedToken The address of the token to stake.\n     * @param amount The amount of the token to stake.\n     * @param beneficiary User that caller wants to stake on behalf of.\n     */\n    function stakeFor(\n        address stakedToken,\n        uint256 amount,\n        address beneficiary\n    ) external nonReentrant onlyEnabled(stakedToken) {\n        _stake(stakedToken, amount, beneficiary);\n    }\n\n    /**\n     * @notice Withdraw staked tokens.\n     * @param stakedToken The address of the token to withdraw.\n     * @param amount The amount of the token to withdraw.\n     */\n    function unstake(address stakedToken, uint256 amount) public nonReentrant onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];\n\n        // Note: these will revert if underflow so you cant unstake more than your cumulativeBalance.\n        userDeposit.cumulativeBalance -= amount;\n        stakingTokens[stakedToken].cumulativeStaked -= amount;\n\n        IERC20(stakedToken).safeTransfer(msg.sender, amount);\n\n        emit Unstake(\n            stakedToken,\n            msg.sender,\n            amount,\n            userDeposit.cumulativeBalance,\n            stakingTokens[stakedToken].cumulativeStaked\n        );\n    }\n\n    /**\n     * @notice Get entitled rewards for the staker.\n     * @dev Calling this method will reset the caller's reward multiplier.\n     * @param stakedToken The address of the token to get rewards for.\n     */\n    function withdrawReward(address stakedToken) public nonReentrant onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];\n\n        uint256 rewardsToSend = userDeposit.rewardsOutstanding;\n        if (rewardsToSend > 0) {\n            userDeposit.rewardsOutstanding = 0;\n            userDeposit.averageDepositTime = getCurrentTime();\n            rewardToken.safeTransfer(msg.sender, rewardsToSend);\n        }\n\n        emit RewardsWithdrawn(\n            stakedToken,\n            msg.sender,\n            rewardsToSend,\n            stakingTokens[stakedToken].lastUpdateTime,\n            stakingTokens[stakedToken].rewardPerTokenStored,\n            userDeposit.rewardsOutstanding,\n            userDeposit.rewardsAccumulatedPerToken\n        );\n    }\n\n    /**\n     * @notice Exits a staking position by unstaking and getting rewards. This totally exits the staking position.\n     * @dev Calling this method will reset the caller's reward multiplier.\n     * @param stakedToken The address of the token to get rewards for.\n     */\n    function exit(address stakedToken) external onlyInitialized(stakedToken) {\n        _updateReward(stakedToken, msg.sender);\n        unstake(stakedToken, stakingTokens[stakedToken].stakingBalances[msg.sender].cumulativeBalance);\n        withdrawReward(stakedToken);\n\n        emit Exit(stakedToken, msg.sender, stakingTokens[stakedToken].cumulativeStaked);\n    }\n\n    /**************************************\n     *           VIEW FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Returns the total staked for a given stakedToken.\n     * @param stakedToken The address of the staked token to query.\n     * @return uint256 Total amount staked of the stakedToken.\n     */\n    function getCumulativeStaked(address stakedToken) external view returns (uint256) {\n        return stakingTokens[stakedToken].cumulativeStaked;\n    }\n\n    /**\n     * @notice Returns all the information associated with a user's stake.\n     * @param stakedToken The address of the staked token to query.\n     * @param account The address of user to query.\n     * @return UserDeposit Struct with: {cumulativeBalance,averageDepositTime,rewardsAccumulatedPerToken,rewardsOutstanding}\n     */\n    function getUserStake(address stakedToken, address account) external view returns (UserDeposit memory) {\n        return stakingTokens[stakedToken].stakingBalances[account];\n    }\n\n    /**\n     * @notice Returns the base rewards per staked token for a given staking token. This factors in the last time\n     * any internal logic was called on this contract to correctly attribute retroactive cumulative rewards.\n     *"
    }
  ]
}