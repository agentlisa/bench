{
  "Title": "H-2: Calls to liquidate don't write down totalBorrows which breaks exchange rate",
  "Content": "# Issue H-2: Calls to liquidate don't write down totalBorrows which breaks exchange rate \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/46 \n\n## Found by \ndirk\\_y, seeques\n## Summary\nWhen a pool is liquidated, the `totalBorrows` storage slot for the token in question should be decremented by `debtToCover` in order to keep the exchange rate of the corresponding `pToken` correct.\n\n## Vulnerability Detail\nWhen users call `liquidate` to liquidate a pool, they specify the amount of debt they want to cover. In the end this is used to write down the borrow amount of the pool in question:\n\n```solidity\nrecord.amount = borrows - debtToCover;\n```\n\nHowever, the `totalBorrows` of the token isn't written down as well (like it should be). The `finishLiquidation` method correctly writes down the `totalBorrows` state. \n\n## Impact\nWhen a user calls `liquidate` to liquidate a pool, the exchange rate of the token (from its pToken) remains high (because the `totalBorrows` for the token isn't decremented). The result is that users that have deposited this ERC20 token are receiving a higher rate of interest than they should. Because this interest is not being covered by anyone the end result is that the last withdrawer from the vault will not be able to redeem their pTokens because there isn't enough of the underlying ERC20 token available. The longer the period over which interest accrues, the greater the incentive for LPs to withdraw early. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol#L57\n\n## Tool used\nManual Review\n\n## Recommendation\nThe `liquidate` method should include the following line to write down the total borrow amount of the debt token being liquidated:\n\n```solidity\ninfo.totalBorrows = info.totalBorrows - debtToCover;\n```\n\n\n\n\n## Discussion\n\n**djb15**\n\nEscalate\n\nThis is not a duplicate of #211. I believe this and #157 should be grouped together separately.\n\n#211 is about the vault token balance not being updated during liquidations which allows users to claim more dTokens than they should with new deposits.\n\nThis issue (and #157) is about the exchange rate for the token being broken during liquidations due to a different variable not being updated. The solution for this issue is different to the solution to #211. The only similarity is that both issues occur during calls to `liquidate`.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is not a duplicate of #211. I believe this and #157 should be grouped together separately.\n> \n> #211 is about the vault token balance not being updated during liquidations which allows users to claim more dTokens than they should with new deposits.\n> \n> This issue (and #157) is about the exchange rate for the token being broken during liquidations due to a different variable not being updated. The solution for this issue is different to the solution to #211. The only similarity is that both issues occur during calls to `liquidate`.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**maarcweiss**\n\nAgree with escalation. #157  and #211 do not describe the same issue as #46 and should be duped together\n\n**djb15**\n\n@maarcweiss Just to confirm, I'm suggesting #46 and #157 are duped together, and #211 is duped with #68, #122 and #156. I.e.\n\nIssue A: #46, #157\nIssue B: #211, #68, #122, #156\n\nJust thought I'd check as the above message seems to suggest the opposite :)\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates \nAgree with the above escalation and comments and two separate sets of issues that should be valid issues\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [djb15](https://github.com/sherlock-audit/2023-06-dodo-judging/issues/46/#issuecomment-1648199664): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"./D3VaultFunding.sol\";\n\ncontract D3VaultLiquidation is D3VaultFunding {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    function isPositiveNetWorthAsset(address pool, address token) internal view returns (bool) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        return balance >= borrows;\n    }\n\n    function getPositiveNetWorthAsset(address pool, address token) internal view returns (uint256) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        if (balance > borrows) {\n            return balance - borrows;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice public liquidate function, repay pool negative worth token and get collateral tokens with discount\n    /// @param pool pool address, must be in belowMM\n    /// @param collateral pool collateral, any positive worth token pool has\n    /// @param collateralAmount collateral amount liquidator claim\n    /// @param debt pool debt, any negative worth token pool has\n    /// @param debtToCover debt amount liquidator repay\n    function liquidate(\n        address pool,\n        address collateral,\n        uint256 collateralAmount,\n        address debt,\n        uint256 debtToCover\n    ) external nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(!checkBadDebtAfterAccrue(pool), Errors.HAS_BAD_DEBT);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        require(isPositiveNetWorthAsset(pool, collateral), Errors.INVALID_COLLATERAL_TOKEN);\n        require(!isPositiveNetWorthAsset(pool, debt), Errors.INVALID_DEBT_TOKEN);\n        require(getPositiveNetWorthAsset(pool, collateral) >= collateralAmount, Errors.COLLATERAL_AMOUNT_EXCEED);\n        \n        uint256 collateralTokenPrice = ID3Oracle(_ORACLE_).getPrice(collateral);\n        uint256 debtTokenPrice = ID3Oracle(_ORACLE_).getPrice(debt);\n        uint256 collateralAmountMax = debtToCover.mul(debtTokenPrice).div(collateralTokenPrice.mul(DISCOUNT));\n        require(collateralAmount <= collateralAmountMax, Errors.COLLATERAL_AMOUNT_EXCEED);\n\n        AssetInfo storage info = assetInfo[debt];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(debtToCover <= borrows, Errors.DEBT_TO_COVER_EXCEED);\n        IERC20(debt).transferFrom(msg.sender, address(this), debtToCover);\n\n        record.amount = borrows - debtToCover;\n        record.interestIndex = info.borrowIndex;\n        IERC20(collateral).transferFrom(pool, msg.sender, collateralAmount);\n        ID3MM(pool).updateReserveByVault(collateral);\n    }\n\n    // ---------- Liquidate by DODO team ----------\n    /// @notice if occuring bad debt, dodo team will start liquidation to balance debt\n    function startLiquidation(address pool) external onlyLiquidator nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        ID3MM(pool).startLiquidation();\n\n        uint256 totalAssetValue = getTotalAssetsValue(pool);\n        uint256 totalDebtValue = _getTotalDebtValue(pool);\n        require(totalAssetValue < totalDebtValue, Errors.NO_BAD_DEBT);\n\n        uint256 ratio = totalAssetValue.div(totalDebtValue);\n\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 debt = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex).mul(ratio);\n            liquidationTarget[pool][token] = debt;\n        }\n    }\n\n    function liquidateByDODO(\n        address pool,\n        LiquidationOrder calldata order,\n        bytes calldata routeData,\n        address router\n    ) external onlyLiquidator nonReentrant {\n        uint256 toTokenReserve = IERC20(order.toToken).balanceOf(address(this));\n        uint256 fromTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.fromToken), order.fromAmount);\n\n        // swap using Route\n        {\n            IERC20(order.fromToken).transferFrom(pool, router, order.fromAmount);\n            (bool success, bytes memory data) = router.call(routeData);\n            if (!success) {\n                assembly {\n                    revert(add(data, 32), mload(data))\n                }\n            }\n        }\n\n        // the transferred-in toToken USD value should not be less than 95% of the transferred-out fromToken\n        uint256 receivedToToken = IERC20(order.toToken).balanceOf(address(this)) - toTokenReserve;\n        uint256 toTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.toToken), receivedToToken);\n\n        require(toTokenValue.div(fromTokenValue) >= DISCOUNT, Errors.EXCEED_DISCOUNT);\n        IERC20(order.toToken).safeTransfer(pool, receivedToToken);\n        ID3MM(pool).updateReserveByVault(order.fromToken);\n        ID3MM(pool).updateReserveByVault(order.toToken);\n    }\n\n    function finishLiquidation(address pool) external onlyLiquidator nonReentrant {\n        require(ID3MM(pool).isInLiquidation(), Errors.NOT_IN_LIQUIDATION);\n        accrueInterests();\n\n        bool hasPositiveBalance;\n        bool hasNegativeBalance;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            uint256 balance = IERC20(token).balanceOf(pool);\n            uint256 debt = liquidationTarget[pool][token];\n            int256 difference = int256(balance) - int256(debt);\n            if (difference > 0) {\n                require(!hasNegativeBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasPositiveBalance = true;\n            } else if (difference < 0) {\n                require(!hasPositiveBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasNegativeBalance = true;\n                debt = balance; // if balance is less than target amount, just repay with balance\n            }\n\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 borrows = record.amount;\n            if (borrows == 0) continue;\n\n            // note: During liquidation process, the pool's debt will slightly increase due to the generated interests. \n            // The liquidation process will not repay the interests. Thus all dToken holders will share the loss equally.\n            uint256 realDebt = borrows.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n            IERC20(token).transferFrom(pool, address(this), debt);\n\n            info.totalBorrows = info.totalBorrows - realDebt;\n            record.amount = 0;\n        }\n\n        ID3MM(pool).finishLiquidation();\n    }\n}"
    }
  ]
}