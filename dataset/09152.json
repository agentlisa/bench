{
  "Title": "[N-12] Use a more recent version of solidity",
  "Content": "\nUse a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/AuraMerkleDrop.sol   #1\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraMerkleDrop.sol#L2>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/AuraMerkleDrop.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { MerkleProof } from \"@openzeppelin/contracts-0.8/utils/cryptography/MerkleProof.sol\";\nimport { IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   AuraMerkleDrop\n * @dev     Forked from convex-platform/contracts/contracts/MerkleAirdrop.sol. Changes:\n *            - solc 0.8.11 & OpenZeppelin MerkleDrop\n *            - Delayed start w/ trigger\n *            - EndTime for withdrawal to treasuryDAO\n *            - Penalty on claim & AuraLocker lock (only if address(auraLocker) != 0)\n *            - Non custodial (cannot change root)\n */\ncontract AuraMerkleDrop {\n    using SafeERC20 for IERC20;\n\n    address public dao;\n    bytes32 public merkleRoot;\n\n    IERC20 public immutable aura;\n    IAuraLocker public auraLocker;\n\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n\n    uint256 public startTime;\n    uint256 public immutable expiryTime;\n\n    mapping(address => bool) public hasClaimed;\n\n    event DaoSet(address newDao);\n    event RootSet(bytes32 newRoot);\n    event StartedEarly();\n    event ExpiredWithdrawn(uint256 amount);\n    event LockerSet(address newLocker);\n    event Claimed(address addr, uint256 amt, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @param _dao              The Aura Dao\n     * @param _merkleRoot       Merkle root\n     * @param _aura             Aura token\n     * @param _auraLocker       Aura locker contract\n     * @param _penaltyForwarder PenaltyForwarded contract\n     * @param _startDelay       Delay until claim is live\n     * @param _expiresAfter     Timestamp claim expires\n     */\n    constructor(\n        address _dao,\n        bytes32 _merkleRoot,\n        address _aura,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay,\n        uint256 _expiresAfter\n    ) {\n        dao = _dao;\n        merkleRoot = _merkleRoot;\n        aura = IERC20(_aura);\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        startTime = block.timestamp + _startDelay;\n\n        require(_expiresAfter > 2 weeks, \"!expiry\");\n        expiryTime = startTime + _expiresAfter;\n    }\n\n    /***************************************\n                    CONFIG\n    ****************************************/\n\n    function setDao(address _newDao) external {\n        require(msg.sender == dao, \"!auth\");\n        dao = _newDao;\n        emit DaoSet(_newDao);\n    }\n\n    function setRoot(bytes32 _merkleRoot) external {\n        require(msg.sender == dao, \"!auth\");\n        require(merkleRoot == bytes32(0), \"already set\");\n        merkleRoot = _merkleRoot;\n        emit RootSet(_merkleRoot);\n    }\n\n    function startEarly() external {\n        require(msg.sender == dao, \"!auth\");\n        startTime = block.timestamp;\n        emit StartedEarly();\n    }\n\n    function withdrawExpired() external {\n        require(msg.sender == dao, \"!auth\");\n        require(block.timestamp > expiryTime, \"!expired\");\n        uint256 amt = aura.balanceOf(address(this));\n        aura.safeTransfer(dao, amt);\n        emit ExpiredWithdrawn(amt);\n    }\n\n    function setLocker(address _newLocker) external {\n        require(msg.sender == dao, \"!auth\");\n        auraLocker = IAuraLocker(_newLocker);\n        emit LockerSet(_newLocker);\n    }\n\n    /***************************************\n                    CLAIM\n    ****************************************/\n\n    function claim(\n        bytes32[] calldata _proof,\n        uint256 _amount,\n        bool _lock\n    ) public returns (bool) {\n        require(merkleRoot != bytes32(0), \"!root\");\n        require(block.timestamp > startTime, \"!started\");\n        require(block.timestamp < expiryTime, \"!active\");\n        require(_amount > 0, \"!amount\");\n        require(hasClaimed[msg.sender] == false, \"already claimed\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verify(_proof, merkleRoot, leaf), \"invalid proof\");\n\n        hasClaimed[msg.sender] = true;\n\n        if (_lock) {\n            aura.safeApprove(address(auraLocker), 0);\n            aura.safeApprove(address(auraLocker), _amount);\n            auraLocker.lock(msg.sender, _amount);\n        } else {\n            // If there is an address for auraLocker, and not locking, apply 20% penalty\n            uint256 penalty = address(auraLocker) == address(0) ? 0 : (_amount * 2) / 10;\n            pendingPenalty += penalty;\n            aura.safeTransfer(msg.sender, _amount - penalty);\n        }\n\n        emit Claimed(msg.sender, _amount, _lock);\n        return true;\n    }\n\n    /***************************************\n                    FORWARD\n    ****************************************/\n\n    function forwardPenalty() public {\n        uint256 toForward = pendingPenalty;\n        pendingPenalty = 0;\n        require(penaltyForwarder != address(0), \"!forwarder\");\n        aura.safeTransfer(penaltyForwarder, toForward);\n        emit PenaltyForwarded(toForward);\n    }\n}"
    }
  ]
}