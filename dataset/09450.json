{
  "Title": "[G-19] Functions guaranteed to revert when called by normal users can be marked `payable`",
  "Content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.\n\n1.  File: contracts/PhuturePriceOracle.sol (line [55](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/PhuturePriceOracle.sol#L55))\n\n```solidity\n    function setOracleOf(address _asset, address _oracle) external override onlyRole(ASSET_MANAGER_ROLE) {\n```\n\n2.  File: contracts/PhuturePriceOracle.sol (line [62](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/PhuturePriceOracle.sol#L62))\n\n```solidity\n    function removeOracleOf(address _asset) external override onlyRole(ASSET_MANAGER_ROLE) {\n```\n\n3.  File: contracts/TopNMarketCapIndex.sol (line [68](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/TopNMarketCapIndex.sol#L68))\n\n```solidity\n    function reweight() external override onlyRole(ORDERER_ROLE) {\n```\n\n4.  File: contracts/TrackedIndex.sol (line [57](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/TrackedIndex.sol#L57))\n\n```solidity\n    function reweight() external override onlyRole(ORDERER_ROLE) {\n```\n\n5.  File: contracts/vToken.sol (lines [81-85](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L81-L85))\n\n```solidity\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _shares\n    ) external override nonReentrant onlyRole(ORDERER_ROLE) {\n```\n\n6.  File: contracts/vToken.sol (line [90](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L90))\n\n```solidity\n    function mint() external override nonReentrant onlyRole(INDEX_ROLE) returns (uint shares) {\n```\n\n7.  File: contracts/vToken.sol (line [95](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L95))\n\n```solidity\n    function burn(address _recipient) external override nonReentrant onlyRole(INDEX_ROLE) returns (uint amount) {\n```\n\n8.  File: contracts/vToken.sol (line [100](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L100))\n\n```solidity\n    function mintFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {\n```\n\n9.  File: contracts/vToken.sol (line [105](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L105))\n\n```solidity\n    function burnFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-04-phuture-finance-contest",
  "Code": [
    {
      "filename": "contracts/PhuturePriceOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\n/// @title Phuture price oracle\n/// @notice Aggregates all price oracles and works with them through IPriceOracle interface\ncontract PhuturePriceOracle is IPhuturePriceOracle {\n    using ERC165Checker for address;\n\n    /// @notice Role allows configure asset related data/components\n    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(\"ASSET_MANAGER_ROLE\");\n\n    /// @notice Base asset address\n    address public base;\n\n    /// @notice Index registry address\n    address public registry;\n\n    /// @inheritdoc IPhuturePriceOracle\n    mapping(address => address) public override priceOracleOf;\n\n    /// @notice Decimals of base asset\n    uint8 private baseDecimals;\n\n    /// @notice Requires msg.sender to have `_role` role\n    /// @param _role Required role\n    modifier onlyRole(bytes32 _role) {\n        require(IAccessControl(registry).hasRole(_role, msg.sender), \"PhuturePriceOracle: FORBIDDEN\");\n        _;\n    }\n\n    constructor(address _registry, address _base) {\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        interfaceIds[0] = type(IAccessControl).interfaceId;\n        interfaceIds[1] = type(IIndexRegistry).interfaceId;\n        require(_registry.supportsAllInterfaces(interfaceIds), \"PhuturePriceOracle: INTERFACE\");\n        require(_base != address(0), \"PhuturePriceOracle: ZERO\");\n\n        base = _base;\n        baseDecimals = IERC20Metadata(_base).decimals();\n        registry = _registry;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function setOracleOf(address _asset, address _oracle) external override onlyRole(ASSET_MANAGER_ROLE) {\n        require(_oracle.supportsInterface(type(IPriceOracle).interfaceId), \"PhuturePriceOracle: INTERFACE\");\n\n        priceOracleOf[_asset] = _oracle;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function removeOracleOf(address _asset) external override onlyRole(ASSET_MANAGER_ROLE) {\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        delete priceOracleOf[_asset];\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function convertToIndex(uint _baseAmount, uint8 _indexDecimals) external view override returns (uint) {\n        return (_baseAmount * 10**_indexDecimals) / 10**baseDecimals;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function containsOracleOf(address _asset) external view override returns (bool) {\n        return priceOracleOf[_asset] != address(0) || _asset == base;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {\n        if (_asset == base) {\n            return FixedPoint112.Q112;\n        }\n\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        return IPriceOracle(priceOracleOf[_asset]).refreshedAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {\n        if (_asset == base) {\n            return FixedPoint112.Q112;\n        }\n\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        return IPriceOracle(priceOracleOf[_asset]).lastAssetPerBaseInUQ(_asset);\n    }\n}"
    },
    {
      "filename": "contracts/PhuturePriceOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\n/// @title Phuture price oracle\n/// @notice Aggregates all price oracles and works with them through IPriceOracle interface\ncontract PhuturePriceOracle is IPhuturePriceOracle {\n    using ERC165Checker for address;\n\n    /// @notice Role allows configure asset related data/components\n    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(\"ASSET_MANAGER_ROLE\");\n\n    /// @notice Base asset address\n    address public base;\n\n    /// @notice Index registry address\n    address public registry;\n\n    /// @inheritdoc IPhuturePriceOracle\n    mapping(address => address) public override priceOracleOf;\n\n    /// @notice Decimals of base asset\n    uint8 private baseDecimals;\n\n    /// @notice Requires msg.sender to have `_role` role\n    /// @param _role Required role\n    modifier onlyRole(bytes32 _role) {\n        require(IAccessControl(registry).hasRole(_role, msg.sender), \"PhuturePriceOracle: FORBIDDEN\");\n        _;\n    }\n\n    constructor(address _registry, address _base) {\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        interfaceIds[0] = type(IAccessControl).interfaceId;\n        interfaceIds[1] = type(IIndexRegistry).interfaceId;\n        require(_registry.supportsAllInterfaces(interfaceIds), \"PhuturePriceOracle: INTERFACE\");\n        require(_base != address(0), \"PhuturePriceOracle: ZERO\");\n\n        base = _base;\n        baseDecimals = IERC20Metadata(_base).decimals();\n        registry = _registry;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function setOracleOf(address _asset, address _oracle) external override onlyRole(ASSET_MANAGER_ROLE) {\n        require(_oracle.supportsInterface(type(IPriceOracle).interfaceId), \"PhuturePriceOracle: INTERFACE\");\n\n        priceOracleOf[_asset] = _oracle;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function removeOracleOf(address _asset) external override onlyRole(ASSET_MANAGER_ROLE) {\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        delete priceOracleOf[_asset];\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function convertToIndex(uint _baseAmount, uint8 _indexDecimals) external view override returns (uint) {\n        return (_baseAmount * 10**_indexDecimals) / 10**baseDecimals;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function containsOracleOf(address _asset) external view override returns (bool) {\n        return priceOracleOf[_asset] != address(0) || _asset == base;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {\n        if (_asset == base) {\n            return FixedPoint112.Q112;\n        }\n\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        return IPriceOracle(priceOracleOf[_asset]).refreshedAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {\n        if (_asset == base) {\n            return FixedPoint112.Q112;\n        }\n\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        return IPriceOracle(priceOracleOf[_asset]).lastAssetPerBaseInUQ(_asset);\n    }\n}"
    },
    {
      "filename": "contracts/TopNMarketCapIndex.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"./interfaces/IIndexFactory.sol\";\nimport \"./interfaces/IReweightableIndex.sol\";\nimport \"./interfaces/ITopNMarketCapIndexReweightingLogic.sol\";\n\nimport \"./BaseIndex.sol\";\n\n/// @title Top N market capitalization index\n/// @notice Contains initialization and reweighting logic\n/// @dev This index reweighs according to the latest data from the TopNMarketCapCategories contract\ncontract TopNMarketCapIndex is IReweightableIndex, BaseIndex {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Orderer role\n    bytes32 internal constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n\n    /// @notice Number of assets used in the index\n    uint8 public topN;\n    /// @notice Category identifier used for the given index\n    uint public category;\n\n    /// @notice Latest category snapshot to track diff\n    uint private snapshot;\n\n    constructor() BaseIndex(msg.sender) {}\n\n    /// @notice Initializes index with provided set of parameters\n    /// @param _topN Number of assets used in the index\n    /// @param _category Category identifier used for the given index\n    /// @param _snapshot Initial snapshot from the category\n    /// @param _assets Assets list\n    /// @param _capitalizations List of corresponding assets capitalizations\n    /// @param _totalCapitalization Total capitalization of assets\n    function initialize(\n        uint8 _topN,\n        uint _category,\n        uint _snapshot,\n        address[] calldata _assets,\n        uint[] calldata _capitalizations,\n        uint _totalCapitalization\n    ) external {\n        require(msg.sender == factory, \"TopNMarketCapIndex: FORBIDDEN\");\n\n        uint8 _totalWeight;\n        for (uint i; i < _assets.length; ++i) {\n            uint _i = _assets.length - 1 - i;\n            address asset = _assets[_i];\n            uint8 weight = _i == 0\n                ? IndexLibrary.MAX_WEIGHT - _totalWeight\n                : uint8((_capitalizations[_i] * type(uint8).max) / _totalCapitalization);\n            weightOf[asset] = weight;\n            require(asset != address(0), \"TopNMarketCapIndex: ZERO\");\n            if (weight > 0) {\n                assets.add(asset);\n                _totalWeight += weight;\n                emit UpdateAnatomy(asset, weight);\n            }\n        }\n        snapshot = _snapshot;\n        category = _category;\n        topN = _topN;\n    }\n\n    /// @notice Reweighs index assets according to the latest market cap data for specified category\n    function reweight() external override onlyRole(ORDERER_ROLE) {\n        (bool success, bytes memory data) = IIndexFactory(factory).reweightingLogic().delegatecall(\n            abi.encodeWithSelector(ITopNMarketCapIndexReweightingLogic.reweight.selector, category, snapshot, topN)\n        );\n        if (!success) {\n            if (data.length == 0) {\n                revert(\"TopNMarketCapIndex: REWEIGH_FAILED\");\n            } else {\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n        snapshot = abi.decode(data, (uint));\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IReweightableIndex).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/TrackedIndex.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"./interfaces/IIndexFactory.sol\";\nimport \"./interfaces/IReweightableIndex.sol\";\nimport \"./interfaces/ITrackedIndexReweightingLogic.sol\";\n\nimport \"./BaseIndex.sol\";\n\n/// @title Tracked index\n/// @notice  Contains initialization and reweighting logic\ncontract TrackedIndex is IReweightableIndex, BaseIndex {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Orderer role\n    bytes32 internal constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n\n    constructor() BaseIndex(msg.sender) {}\n\n    /// @notice Initializes index with provided set of parameters\n    /// @param _assets Assets list\n    /// @param _capitalizations List of corresponding assets capitalizations\n    /// @param _totalCapitalization Total capitalization of assets\n    function initialize(\n        address[] calldata _assets,\n        uint[] calldata _capitalizations,\n        uint _totalCapitalization\n    ) external {\n        require(msg.sender == factory, \"TrackedIndex: FORBIDDEN\");\n\n        uint8 totalWeight;\n        uint maxCapitalization = _capitalizations[0];\n        address maxCapitalizationAsset = _assets[0];\n        for (uint i; i < _assets.length; ++i) {\n            address asset = _assets[i];\n            uint8 weight = uint8((_capitalizations[i] * type(uint8).max) / _totalCapitalization);\n            if (_capitalizations[i] > maxCapitalization) {\n                emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);\n                maxCapitalization = _capitalizations[i];\n                maxCapitalizationAsset = asset;\n            }\n            weightOf[asset] = weight;\n            totalWeight += weight;\n            assets.add(asset);\n            if (asset != maxCapitalizationAsset) {\n                emit UpdateAnatomy(asset, weight);\n            }\n        }\n        if (totalWeight < IndexLibrary.MAX_WEIGHT) {\n            weightOf[maxCapitalizationAsset] += IndexLibrary.MAX_WEIGHT - totalWeight;\n        }\n        emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);\n    }\n\n    /// @notice Reweighs index assets according to the latest market cap data\n    function reweight() external override onlyRole(ORDERER_ROLE) {\n        (bool success, bytes memory data) = IIndexFactory(factory).reweightingLogic().delegatecall(\n            abi.encodeWithSelector(ITrackedIndexReweightingLogic.reweight.selector)\n        );\n        if (!success) {\n            if (data.length == 0) {\n                revert(\"TrackedIndex: REWEIGH_FAILED\");\n            } else {\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IReweightableIndex).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/vToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport \"./libraries/BP.sol\";\nimport \"./libraries/NAV.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\n\n/// @title Vault token\n/// @notice Contains logic for index's asset management\ncontract vToken is IvToken, Initializable, ReentrancyGuardUpgradeable, ERC165Upgradeable {\n    using NAV for NAV.Data;\n    using SafeERC20 for IERC20;\n    using ERC165CheckerUpgradeable for address;\n\n    /// @notice Index role\n    bytes32 private constant INDEX_ROLE = keccak256(\"INDEX_ROLE\");\n    /// @notice Oracle role\n    bytes32 private constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    /// @notice Orderer role\n    bytes32 private constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n    /// @notice Role allows configure reserve related data/components\n    bytes32 private constant RESERVE_MANAGER_ROLE = keccak256(\"RESERVE_MANAGER_ROLE\");\n\n    /// @inheritdoc IvToken\n    address public override asset;\n    /// @inheritdoc IvToken\n    address public override registry;\n\n    /// @notice NAV library used to track contract shares between indexes\n    NAV.Data internal _NAV;\n\n    /// @notice Requires msg.sender to have `_role` role\n    /// @param _role Required role\n    modifier onlyRole(bytes32 _role) {\n        require(IAccessControl(registry).hasRole(_role, msg.sender), \"vToken: FORBIDDEN\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc IvToken\n    /// @dev also sets initial values for public variables\n    function initialize(address _asset, address _registry) external override initializer {\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        interfaceIds[0] = type(IAccessControl).interfaceId;\n        interfaceIds[1] = type(IIndexRegistry).interfaceId;\n        require(_registry.supportsAllInterfaces(interfaceIds), \"vToken: INTERFACE\");\n        require(_asset != address(0), \"vToken: ZERO\");\n\n        __ERC165_init();\n        __ReentrancyGuard_init();\n\n        asset = _asset;\n        registry = _registry;\n    }\n\n    /// @inheritdoc IvToken\n    function transferAsset(address _recipient, uint _amount) external override nonReentrant {\n        require(msg.sender == IIndexRegistry(registry).orderer(), \"vToken: FORBIDDEN\");\n        _transferAsset(_recipient, _amount);\n    }\n\n    /// @inheritdoc IvToken\n    function transfer(address _recipient, uint _amount) external override nonReentrant {\n        _transfer(msg.sender, _recipient, _amount);\n    }\n\n    /// @inheritdoc IvToken\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _shares\n    ) external override nonReentrant onlyRole(ORDERER_ROLE) {\n        _transfer(_from, _to, _shares);\n    }\n\n    /// @inheritdoc IvToken\n    function mint() external override nonReentrant onlyRole(INDEX_ROLE) returns (uint shares) {\n        return _mint(msg.sender);\n    }\n\n    /// @inheritdoc IvToken\n    function burn(address _recipient) external override nonReentrant onlyRole(INDEX_ROLE) returns (uint amount) {\n        return _burn(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function mintFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {\n        return _mint(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function burnFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {\n        return _burn(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function sync() external override nonReentrant {\n        _NAV.sync(totalAssetSupply());\n    }\n\n    /// @inheritdoc IvToken\n    function balanceOf(address _account) external view override returns (uint) {\n        return _NAV.balanceOf[_account];\n    }\n\n    /// @inheritdoc IvToken\n    function lastBalance() external view override returns (uint) {\n        return _NAV.lastBalance;\n    }\n\n    /// @inheritdoc IvToken\n    function mintableShares(uint _amount) external view override returns (uint) {\n        return _NAV.mintableShares(_amount);\n    }\n\n    /// @inheritdoc IvToken\n    function totalSupply() external view override returns (uint) {\n        return _NAV.totalSupply;\n    }\n\n    /// @inheritdoc IvToken\n    function lastAssetBalanceOf(address _account) external view override returns (uint) {\n        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], _NAV.lastBalance);\n    }\n\n    /// @inheritdoc IvToken\n    function assetBalanceOf(address _account) external view override returns (uint) {\n        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], totalAssetSupply());\n    }\n\n    /// @inheritdoc IvToken\n    function assetDataOf(address _account, uint _shares) external view override returns (AssetData memory) {\n        _shares = Math.min(_shares, _NAV.balanceOf[_account]);\n        uint amountInAsset = _NAV.assetBalanceForShares(_shares, totalAssetSupply());\n        return AssetData({ maxShares: _shares, amountInAsset: amountInAsset });\n    }\n\n    /// @inheritdoc IvToken\n    function shareChange(address _account, uint _amountInAsset)\n        external\n        view\n        override\n        returns (uint newShares, uint oldShares)\n    {\n        oldShares = _NAV.balanceOf[_account];\n        uint _totalSupply = _NAV.totalSupply;\n        if (_totalSupply > 0) {\n            uint _balance = _NAV.balanceOf[_account];\n            uint _assetBalance = totalAssetSupply();\n            uint availableAssets = (_balance * _assetBalance) / _totalSupply;\n            newShares = (_amountInAsset * (_totalSupply - oldShares)) / (_assetBalance - availableAssets);\n        } else {\n            newShares = _amountInAsset < NAV.INITIAL_QUANTITY ? 0 : _amountInAsset - NAV.INITIAL_QUANTITY;\n        }\n    }\n\n    /// @inheritdoc IvToken\n    function totalAssetSupply() public view override returns (uint) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IvToken).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Mints shares to `_recipient` address\n    /// @param _recipient Shares recipient\n    /// @return shares Amount of minted shares\n    function _mint(address _recipient) internal returns (uint shares) {\n        uint _totalAssetSupply = totalAssetSupply();\n        shares = _NAV.mint(_totalAssetSupply, _recipient);\n        _NAV.sync(_totalAssetSupply);\n        emit VTokenTransfer(address(0), _recipient, shares);\n    }\n\n    /// @notice Burns shares from `_recipient` address\n    /// @param _recipient Recipient of assets from burnt shares\n    /// @return amount Amount of asset for burnt shares\n    function _burn(address _recipient) internal returns (uint amount) {\n        uint shares = _NAV.balanceOf[address(this)];\n        amount = _NAV.burn(totalAssetSupply());\n        _transferAsset(_recipient, amount);\n        _NAV.sync(totalAssetSupply());\n        emit VTokenTransfer(_recipient, address(0), shares);\n    }\n\n    /// @notice Transfers `_amount` of shares from one address to another\n    /// @param _from Address to transfer shares from\n    /// @param _to Address to transfer shares to\n    /// @param _amount Amount of shares to transfer\n    function _transfer(\n        address _from,\n        address _to,\n        uint _amount\n    ) internal {\n        _NAV.transfer(_from, _to, _amount);\n        emit VTokenTransfer(_from, _to, _amount);\n    }\n\n    /// @notice Transfers `_amount` of asset to `_recipient` address\n    /// @param _recipient Recipient of assets\n    /// @param _amount Amount of assets to transfer\n    function _transferAsset(address _recipient, uint _amount) internal {\n        uint balance = IERC20(asset).balanceOf(address(this));\n        IERC20(asset).safeTransfer(_recipient, Math.min(_amount, balance));\n    }\n\n    uint256[42] private __gap;\n}"
    },
    {
      "filename": "contracts/vToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport \"./libraries/BP.sol\";\nimport \"./libraries/NAV.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\n\n/// @title Vault token\n/// @notice Contains logic for index's asset management\ncontract vToken is IvToken, Initializable, ReentrancyGuardUpgradeable, ERC165Upgradeable {\n    using NAV for NAV.Data;\n    using SafeERC20 for IERC20;\n    using ERC165CheckerUpgradeable for address;\n\n    /// @notice Index role\n    bytes32 private constant INDEX_ROLE = keccak256(\"INDEX_ROLE\");\n    /// @notice Oracle role\n    bytes32 private constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    /// @notice Orderer role\n    bytes32 private constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n    /// @notice Role allows configure reserve related data/components\n    bytes32 private constant RESERVE_MANAGER_ROLE = keccak256(\"RESERVE_MANAGER_ROLE\");\n\n    /// @inheritdoc IvToken\n    address public override asset;\n    /// @inheritdoc IvToken\n    address public override registry;\n\n    /// @notice NAV library used to track contract shares between indexes\n    NAV.Data internal _NAV;\n\n    /// @notice Requires msg.sender to have `_role` role\n    /// @param _role Required role\n    modifier onlyRole(bytes32 _role) {\n        require(IAccessControl(registry).hasRole(_role, msg.sender), \"vToken: FORBIDDEN\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc IvToken\n    /// @dev also sets initial values for public variables\n    function initialize(address _asset, address _registry) external override initializer {\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        interfaceIds[0] = type(IAccessControl).interfaceId;\n        interfaceIds[1] = type(IIndexRegistry).interfaceId;\n        require(_registry.supportsAllInterfaces(interfaceIds), \"vToken: INTERFACE\");\n        require(_asset != address(0), \"vToken: ZERO\");\n\n        __ERC165_init();\n        __ReentrancyGuard_init();\n\n        asset = _asset;\n        registry = _registry;\n    }\n\n    /// @inheritdoc IvToken\n    function transferAsset(address _recipient, uint _amount) external override nonReentrant {\n        require(msg.sender == IIndexRegistry(registry).orderer(), \"vToken: FORBIDDEN\");\n        _transferAsset(_recipient, _amount);\n    }\n\n    /// @inheritdoc IvToken\n    function transfer(address _recipient, uint _amount) external override nonReentrant {\n        _transfer(msg.sender, _recipient, _amount);\n    }\n\n    /// @inheritdoc IvToken\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _shares\n    ) external override nonReentrant onlyRole(ORDERER_ROLE) {\n        _transfer(_from, _to, _shares);\n    }\n\n    /// @inheritdoc IvToken\n    function mint() external override nonReentrant onlyRole(INDEX_ROLE) returns (uint shares) {\n        return _mint(msg.sender);\n    }\n\n    /// @inheritdoc IvToken\n    function burn(address _recipient) external override nonReentrant onlyRole(INDEX_ROLE) returns (uint amount) {\n        return _burn(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function mintFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {\n        return _mint(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function burnFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {\n        return _burn(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function sync() external override nonReentrant {\n        _NAV.sync(totalAssetSupply());\n    }\n\n    /// @inheritdoc IvToken\n    function balanceOf(address _account) external view override returns (uint) {\n        return _NAV.balanceOf[_account];\n    }\n\n    /// @inheritdoc IvToken\n    function lastBalance() external view override returns (uint) {\n        return _NAV.lastBalance;\n    }\n\n    /// @inheritdoc IvToken\n    function mintableShares(uint _amount) external view override returns (uint) {\n        return _NAV.mintableShares(_amount);\n    }\n\n    /// @inheritdoc IvToken\n    function totalSupply() external view override returns (uint) {\n        return _NAV.totalSupply;\n    }\n\n    /// @inheritdoc IvToken\n    function lastAssetBalanceOf(address _account) external view override returns (uint) {\n        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], _NAV.lastBalance);\n    }\n\n    /// @inheritdoc IvToken\n    function assetBalanceOf(address _account) external view override returns (uint) {\n        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], totalAssetSupply());\n    }\n\n    /// @inheritdoc IvToken\n    function assetDataOf(address _account, uint _shares) external view override returns (AssetData memory) {\n        _shares = Math.min(_shares, _NAV.balanceOf[_account]);\n        uint amountInAsset = _NAV.assetBalanceForShares(_shares, totalAssetSupply());\n        return AssetData({ maxShares: _shares, amountInAsset: amountInAsset });\n    }\n\n    /// @inheritdoc IvToken\n    function shareChange(address _account, uint _amountInAsset)\n        external\n        view\n        override\n        returns (uint newShares, uint oldShares)\n    {\n        oldShares = _NAV.balanceOf[_account];\n        uint _totalSupply = _NAV.totalSupply;\n        if (_totalSupply > 0) {\n            uint _balance = _NAV.balanceOf[_account];\n            uint _assetBalance = totalAssetSupply();\n            uint availableAssets = (_balance * _assetBalance) / _totalSupply;\n            newShares = (_amountInAsset * (_totalSupply - oldShares)) / (_assetBalance - availableAssets);\n        } else {\n            newShares = _amountInAsset < NAV.INITIAL_QUANTITY ? 0 : _amountInAsset - NAV.INITIAL_QUANTITY;\n        }\n    }\n\n    /// @inheritdoc IvToken\n    function totalAssetSupply() public view override returns (uint) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IvToken).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Mints shares to `_recipient` address\n    /// @param _recipient Shares recipient\n    /// @return shares Amount of minted shares\n    function _mint(address _recipient) internal returns (uint shares) {\n        uint _totalAssetSupply = totalAssetSupply();\n        shares = _NAV.mint(_totalAssetSupply, _recipient);\n        _NAV.sync(_totalAssetSupply);\n        emit VTokenTransfer(address(0), _recipient, shares);\n    }\n\n    /// @notice Burns shares from `_recipient` address\n    /// @param _recipient Recipient of assets from burnt shares\n    /// @return amount Amount of asset for burnt shares\n    function _burn(address _recipient) internal returns (uint amount) {\n        uint shares = _NAV.balanceOf[address(this)];\n        amount = _NAV.burn(totalAssetSupply());\n        _transferAsset(_recipient, amount);\n        _NAV.sync(totalAssetSupply());\n        emit VTokenTransfer(_recipient, address(0), shares);\n    }\n\n    /// @notice Transfers `_amount` of shares from one address to another\n    /// @param _from Address to transfer shares from\n    /// @param _to Address to transfer shares to\n    /// @param _amount Amount of shares to transfer\n    function _transfer(\n        address _from,\n        address _to,\n        uint _amount\n    ) internal {\n        _NAV.transfer(_from, _to, _amount);\n        emit VTokenTransfer(_from, _to, _amount);\n    }\n\n    /// @notice Transfers `_amount` of asset to `_recipient` address\n    /// @param _recipient Recipient of assets\n    /// @param _amount Amount of assets to transfer\n    function _transferAsset(address _recipient, uint _amount) internal {\n        uint balance = IERC20(asset).balanceOf(address(this));\n        IERC20(asset).safeTransfer(_recipient, Math.min(_amount, balance));\n    }\n\n    uint256[42] private __gap;\n}"
    },
    {
      "filename": "contracts/vToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport \"./libraries/BP.sol\";\nimport \"./libraries/NAV.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\n\n/// @title Vault token\n/// @notice Contains logic for index's asset management\ncontract vToken is IvToken, Initializable, ReentrancyGuardUpgradeable, ERC165Upgradeable {\n    using NAV for NAV.Data;\n    using SafeERC20 for IERC20;\n    using ERC165CheckerUpgradeable for address;\n\n    /// @notice Index role\n    bytes32 private constant INDEX_ROLE = keccak256(\"INDEX_ROLE\");\n    /// @notice Oracle role\n    bytes32 private constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    /// @notice Orderer role\n    bytes32 private constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n    /// @notice Role allows configure reserve related data/components\n    bytes32 private constant RESERVE_MANAGER_ROLE = keccak256(\"RESERVE_MANAGER_ROLE\");\n\n    /// @inheritdoc IvToken\n    address public override asset;\n    /// @inheritdoc IvToken\n    address public override registry;\n\n    /// @notice NAV library used to track contract shares between indexes\n    NAV.Data internal _NAV;\n\n    /// @notice Requires msg.sender to have `_role` role\n    /// @param _role Required role\n    modifier onlyRole(bytes32 _role) {\n        require(IAccessControl(registry).hasRole(_role, msg.sender), \"vToken: FORBIDDEN\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc"
    }
  ]
}