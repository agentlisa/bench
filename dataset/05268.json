{
  "Title": "[L-10] - Arbitrage profit is not calculated correctly when there is an index with an `INVALID_POOL_ID`",
  "Content": "\n### Impact\n\n1/3 to 2/3 of arbitrage profit may not be distributed\n\n### Proof of Concept\n\nArbitrage profit is always divided by 3, despite some indicies might have an `INVALID_POOL_ID`. That means if an index has an invalid pool id, that 33% of arbitrage profits will not be distributed.\n\n```solidity\n    // Split the arbitrage profit between all the pools that contributed to generating the arbitrage for the referenced pool.\nðŸ‘‰  uint256 arbitrageProfit = _arbitrageProfits[poolID] / 3;\n    if ( arbitrageProfit > 0 )\n        {\n        ArbitrageIndicies memory indicies = _arbitrageIndicies[poolID];\n\n        if ( indicies.index1 != INVALID_POOL_ID )\nðŸ‘‰          _calculatedProfits[indicies.index1] += arbitrageProfit;\n\n        if ( indicies.index2 != INVALID_POOL_ID )\nðŸ‘‰          _calculatedProfits[indicies.index2] += arbitrageProfit;\n\n        if ( indicies.index3 != INVALID_POOL_ID )\nðŸ‘‰          _calculatedProfits[indicies.index3] += arbitrageProfit;\n        }\n    }\n```\n\n[PoolStats.sol#L111-L126](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/pools/PoolStats.sol#L111-L126)\n\n### Recommendation\n\nCount the number of indicies without an `INVALID_POOL_ID`, and then distribute the profit evenly among them\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/pools/PoolStats.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IPoolsConfig.sol\";\nimport \"./interfaces/IPoolStats.sol\";\nimport \"./PoolUtils.sol\";\n\n\n// Keeps track of the arbitrage profits generated by pools (for rewards distribution proportional to the profits generated per pool).\nabstract contract PoolStats is IPoolStats\n\t{\n\tuint64 constant INVALID_POOL_ID = type(uint64).max;\n\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIERC20 immutable public _weth;\n\n\t// poolID(arbToken2, arbToken3) => arbitrage profits contributed since the last performUpkeep\n\tmapping(bytes32=>uint256) public _arbitrageProfits;\n\n\t// Maps poolID(arbToken2, arbToken3) => the indicies (within the whitelistedPools array) of the pools involved in WETH->arbToken2->arbToken3->WETH\n\tmapping(bytes32=>ArbitrageIndicies) public _arbitrageIndicies;\n\n\n    constructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig )\n    \t{\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\n\t\t_weth = exchangeConfig.weth();\n    \t}\n\n\n\t// Record that arbitrageProfit was generated and the a specific arbitrage path generated it (which is defined by the middle two tokens in WETH->arbToken2->arbToken3->WETH)\n\tfunction _updateProfitsFromArbitrage( IERC20 arbToken2, IERC20 arbToken3, uint256 arbitrageProfit ) internal\n\t\t{\n\t\t// Though three pools contributed to the arbitrage we can record just the middle one as we know the input and output token will be WETH\n\t\tbytes32 poolID = PoolUtils._poolID( arbToken2, arbToken3 );\n\n\t\t_arbitrageProfits[poolID] += arbitrageProfit;\n\t\t}\n\n\n\t// Called at the end of Upkeep.performUpkeep to reset the arbitrage stats for the pools\n\tfunction clearProfitsForPools() external\n\t\t{\n\t\trequire(msg.sender == address(exchangeConfig.upkeep()), \"PoolStats.clearProfitsForPools is only callable from the Upkeep contract\" );\n\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t_arbitrageProfits[ poolIDs[i] ] = 0;\n\t\t}\n\n\n\t// The index of pool tokenA/tokenB within the whitelistedPools array.\n\t// Should always find a value as only whitelisted pools are used in the arbitrage path.\n\t// Returns uint64.max in the event of failed lookup\n\tfunction _poolIndex( IERC20 tokenA, IERC20 tokenB, bytes32[] memory poolIDs ) internal pure returns (uint64 index)\n\t\t{\n\t\tbytes32 poolID = PoolUtils._poolID( tokenA, tokenB );\n\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tif (poolID == poolIDs[i])\n\t\t\t\treturn uint64(i);\n\t\t\t}\n\n\t\treturn INVALID_POOL_ID;\n\t\t}\n\n\n\t// Traverse the current whitelisted poolIDs and update the indicies of each pool that would contribute to arbitrage for it.\n\t// Maps poolID(arbToken2, arbToken3) => the indicies (within the whitelistedPools array) of the pools involved in WETH->arbToken2->arbToken3->WETH arbitrage.\n\tfunction updateArbitrageIndicies() public\n\t\t{\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\t\t\t(IERC20 arbToken2, IERC20 arbToken3) = poolsConfig.underlyingTokenPair(poolID);\n\n\t\t\t// The middle two tokens can never be WETH in a valid arbitrage path as the path is WETH->arbToken2->arbToken3->WETH.\n\t\t\tif ( (arbToken2 != _weth) && (arbToken3 != _weth) )\n\t\t\t\t{\n\t\t\t\tuint64 poolIndex1 = _poolIndex( _weth, arbToken2, poolIDs );\n\t\t\t\tuint64 poolIndex2 = _poolIndex( arbToken2, arbToken3, poolIDs );\n\t\t\t\tuint64 poolIndex3 = _poolIndex( arbToken3, _weth, poolIDs );\n\n\t\t\t\t// Check if the indicies in storage have the correct values - and if not then update them\n\t\t\t\tArbitrageIndicies memory indicies = _arbitrageIndicies[poolID];\n\t\t\t\tif ( ( poolIndex1 != indicies.index1 ) || ( poolIndex2 != indicies.index2 ) || ( poolIndex3 != indicies.index3 ) )\n\t\t\t\t\t_arbitrageIndicies[poolID] = ArbitrageIndicies(poolIndex1, poolIndex2, poolIndex3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t// Examine the arbitrage that has been generated since the last Upkeep.performUpkeep call and credit the pools that have contributed towards it.\n\t// The calculated sums for each pool will then be used to proportionally distribute SALT rewards to each of the contributing pools.\n\tfunction _calculateArbitrageProfits( bytes32[] memory poolIDs, uint256[] memory _calculatedProfits ) internal view\n\t\t{\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\t// references poolID(arbToken2, arbToken3) which defines the arbitage path of WETH->arbToken2->arbToken3->WETH\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\t// Split the arbitrage profit between all the pools that contributed to generating the arbitrage for the referenced pool.\n\t\t\tuint256 arbitrageProfit = _arbitrageProfits[poolID] / 3;\n\t\t\tif ( arbitrageProfit > 0 )\n\t\t\t\t{\n\t\t\t\tArbitrageIndicies memory indicies = _arbitrageIndicies[poolID];\n\n\t\t\t\tif ( indicies.index1 != INVALID_POOL_ID )\n\t\t\t\t\t_calculatedProfits[indicies.index1] += arbitrageProfit;\n\n\t\t\t\tif ( indicies.index2 != INVALID_POOL_ID )\n\t\t\t\t\t_calculatedProfits[indicies.index2] += arbitrageProfit;\n\n\t\t\t\tif ( indicies.index3 != INVALID_POOL_ID )\n\t\t\t\t\t_calculatedProfits[indicies.index3] += arbitrageProfit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// Look at the arbitrage that has been generated since the last performUpkeep and determine how much each of the pools contributed to those generated profits.\n\t// Returns the profits for all of the current whitelisted pools\n\tfunction profitsForWhitelistedPools() external view returns (uint256[] memory _calculatedProfits)\n\t\t{\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\n\t\t_calculatedProfits = new uint256[](poolIDs.length);\n\t\t_calculateArbitrageProfits( poolIDs, _calculatedProfits );\n\t\t}\n\n\n\tfunction arbitrageIndicies(bytes32 poolID) external view returns (ArbitrageIndicies memory)\n\t\t{\n\t\treturn _arbitrageIndicies[poolID];\n\t\t}\n\t}"
    }
  ]
}