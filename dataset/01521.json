{
  "Title": "Ownership Transfer in changeSphereXAdmin Method is Error-Prone",
  "Content": "The [`changeSphereXAdmin`](https://github.com/spherex-collab/spherex-protect/blob/5b134b2b176deb94e75417ed9b9d3670444a4167/src/SphereXProtected.sol#L99) method currently allows for a single-step ownership transfer, which can be risky due to potential mistakes leading to loss of control to update the Admin or the Engine address and thus losing the ability to opt out of the SphereX Protect.\n\n\nConsider using a two-step ownership transfer to provide a safer mechanism. Moreover, the method should also validate that the proposed address conforms to the expected contract interface to ensure correct functionality. Lastly, the method should be made `virtual` to permit override by integrating contracts with their own access control measures.\n\n\n***Update**: Resolved in [pull request #14](https://github.com/spherex-collab/spherex-protect/pull/14) at commit [ec71add](https://github.com/spherex-collab/spherex-protect/pull/14/commits/ec71add1e2367db3162e5a62ff786531b0d4642c).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/SphereXProtected.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\n\npragma solidity >=0.5.0;\n\nimport \"./ISphereXEngine.sol\";\n\n/**\n * @title SphereX base Customer contract template\n * @dev notice this is an abstract\n */\nabstract contract SphereXProtected {\n    /**\n     * @dev we would like to avoid occupying storage slots\n     * @dev to easily incorporate with existing contracts\n     */\n    bytes32 private constant SPHEREX_ADMIN_STORAGE_SLOT = bytes32(uint256(keccak256(\"eip1967.spherex.spherex\")) - 1);\n    bytes32 private constant SPHEREX_ENGINE_STORAGE_SLOT =\n        bytes32(uint256(keccak256(\"eip1967.spherex.spherex_engine\")) - 1);\n\n    /**\n     * @dev this struct is used to reduce the stack usage of the modifiers.\n     */\n    struct ModifierLocals {\n        bytes32[] storageSlots;\n        bytes32[] valuesBefore;\n        uint256 gas;\n    }\n\n    /**\n     * @dev used when the client doesn't use a proxy\n     * @notice constructor visibality is required to support all compiler versions\n     */\n    constructor() internal {\n        __SphereXProtected_init();\n    }\n\n    /**\n     * @dev used when the client uses a proxy - should be called by the inhereter initialization\n     */\n    function __SphereXProtected_init() internal {\n        if (_getAddress(SPHEREX_ADMIN_STORAGE_SLOT) == address(0)) {\n            _setAddress(SPHEREX_ADMIN_STORAGE_SLOT, msg.sender);\n        }\n    }\n\n    // ============ Helper functions ============\n\n    function _sphereXEngine() private view returns (ISphereXEngine) {\n        return ISphereXEngine(_getAddress(SPHEREX_ENGINE_STORAGE_SLOT));\n    }\n\n    /**\n     * Stores a new address in an abitrary slot\n     * @param slot where to store the address\n     * @param newAddress address to store in given slot\n     */\n    function _setAddress(bytes32 slot, address newAddress) private {\n        // solhint-disable-next-line no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            sstore(slot, newAddress)\n        }\n    }\n\n    /**\n     * Returns an address from an arbitrary slot.\n     * @param slot to read an address from\n     */\n    function _getAddress(bytes32 slot) private view returns (address addr) {\n        // solhint-disable-next-line no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            addr := sload(slot)\n        }\n    }\n\n    // ============ Local modifiers ============\n\n    modifier onlySphereXAdmin() {\n        require(msg.sender == _getAddress(SPHEREX_ADMIN_STORAGE_SLOT), \"!SX:SPHEREX\");\n        _;\n    }\n\n    modifier returnsIfNotActivated() {\n        if (address(_sphereXEngine()) == address(0)) {\n            return;\n        }\n\n        _;\n    }\n\n    // ============ Management ============\n\n    /**\n     *\n     * @param newSphereXAdmin new address of the new admin account\n     */\n    function changeSphereXAdmin(address newSphereXAdmin) external onlySphereXAdmin {\n        _setAddress(SPHEREX_ADMIN_STORAGE_SLOT, newSphereXAdmin);\n    }\n\n    /**\n     *\n     * @param newSphereXEngine new address of the spherex engine\n     * @dev this is also used to actually enable the defence\n     * (because as long is this address is 0, the protection is disabled).\n     */\n    function changeSphereXEngine(address newSphereXEngine) external onlySphereXAdmin {\n        _setAddress(SPHEREX_ENGINE_STORAGE_SLOT, newSphereXEngine);\n    }\n\n    // ============ Hooks ============\n\n    /**\n     * @dev internal function for engine communication. We use it to reduce contract size.\n     *  Should be called before the code of a function.\n     * @param num function identifier\n     * @param isExternalCall set to true if this was called externally\n     *  or a 'public' function from another address\n     */\n    function _sphereXValidatePre(int16 num, bool isExternalCall)\n        internal\n        returnsIfNotActivated\n        returns (ModifierLocals memory locals)\n    {\n        ISphereXEngine sphereXEngine = _sphereXEngine();\n        if (isExternalCall) {\n            locals.storageSlots = sphereXEngine.sphereXValidatePre(num, msg.sender, msg.data);\n            locals.valuesBefore = _readStorage(locals.storageSlots);\n        } else {\n            sphereXEngine.sphereXValidateInternalPre(num);\n        }\n        locals.gas = gasleft();\n        return locals;\n    }\n\n    /**\n     * @dev internal function for engine communication. We use it to reduce contract size.\n     *  Should be called after the code of a function.\n     * @param num function identifier\n     * @param isExternalCall set to true if this was called externally\n     *  or a 'public' function from another address\n     */\n    function _sphereXValidatePost(int16 num, bool isExternalCall, ModifierLocals memory locals)\n        internal\n        returnsIfNotActivated\n    {\n        uint256 gas = locals.gas - gasleft();\n        ISphereXEngine sphereXEngine = _sphereXEngine();\n        if (isExternalCall) {\n            bytes32[] memory valuesAfter;\n            valuesAfter = _readStorage(locals.storageSlots);\n            sphereXEngine.sphereXValidatePost(num, gas, locals.valuesBefore, valuesAfter);\n        } else {\n            sphereXEngine.sphereXValidateInternalPost(num, gas);\n        }\n    }\n\n    /**\n     * @dev internal function for engine communication. We use it to reduce contract size.\n     *  Should be called before the code of a function.\n     * @param num function identifier\n     * @return gas used before calling the original function body\n     */\n    function _sphereXValidateInternalPre(int16 num) internal returnsIfNotActivated returns(uint256){\n        _sphereXEngine().sphereXValidateInternalPre(num);\n        return gasleft();\n    }\n\n    /**\n     * @dev internal function for engine communication. We use it to reduce contract size.\n     *  Should be called after the code of a function.\n     * @param num function identifier\n     * @param gas the gas saved before the original function nody run\n     */\n    function _sphereXValidateInternalPost(int16 num, uint256 gas) internal returnsIfNotActivated {\n        _sphereXEngine().sphereXValidateInternalPost(num, gas - gasleft());\n    }\n\n    /**\n     *  @dev Modifier to be incorporated in all internal protected non-view functions\n     */\n    modifier sphereXGuardInternal(int16 num) {\n        uint256 gas = _sphereXValidateInternalPre(num);\n        _;\n        _sphereXValidateInternalPost(-num, gas);\n    }\n\n    /**\n     *  @dev Modifier to be incorporated in all external protected non-view functions\n     */\n    modifier sphereXGuardExternal(int16 num) {\n        ModifierLocals memory locals = _sphereXValidatePre(num, true);\n        _;\n        _sphereXValidatePost(-num, true, locals);\n    }\n\n    /**\n     *  @dev Modifier to be incorporated in all public rotected non-view functions\n     */\n    modifier sphereXGuardPublic(int16 num, bytes4 selector) {\n        ModifierLocals memory locals = _sphereXValidatePre(num, msg.sig == selector);\n        _;\n        _sphereXValidatePost(-num, msg.sig == selector, locals);\n    }\n\n    // ============ Internal Storage logic ============\n\n    /**\n     * Internal function that reads values from given storage slots and returns them\n     * @param storageSlots list of storage slots to read\n     * @return list of values read from the various storage slots\n     */\n    function _readStorage(bytes32[] memory storageSlots) internal view returns (bytes32[] memory) {\n        uint256 arrayLength = storageSlots.length;\n        bytes32[] memory values = new bytes32[](arrayLength);\n        // create the return array data\n\n        for (uint256 i = 0; i < arrayLength; i++) {\n            bytes32 slot = storageSlots[i];\n            bytes32 temp_value;\n            // solhint-disable-next-line no-inline-assembly\n            // slither-disable-next-line assembly\n            assembly {\n                temp_value := sload(slot)\n            }\n\n            values[i] = temp_value;\n        }\n        return values;\n    }\n}"
    }
  ]
}