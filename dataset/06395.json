{
  "Title": "[M-10] An oracle deprecation might lead the protocol to sell assets for a low price",
  "Content": "\nDuring a Dutch Auction, if a user places a bid, the trade is settled in the same transaction. As part of this process, the backing manager tries to call the `rebalance()` function again.\nThe call to `rebalance()` is wrapped in a try-catch block, if an error occurs and the error data is empty, the function will revert.\n\nThe assumption is that if the error data is empty that means it was due to an out-of-gas error, this assumption isn't always true as mentioned in a [previous issue](https://github.com/code-423n4/2023-01-reserve-findings/issues/234) (that wasn't mitigated).\nIn the case of this issue, this can result in a case where users can't bid on an auction for some time, ending up selling an asset for a price lower than the market price.\n\n### Impact\n\nProtocol's assets will be auctioned for a price lower than the market price.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n*   Chainlink announces that an oracle will get deprecated\n*   Governance passes a proposal to update the asset registry with a new oracle\n*   A re-balancing is required and executed with a Dutch Auction\n*   The oracle deprecation happens before the auction price reaches a reasonable value\n*   Any bid while the oracle is deprecated will revert\n*   Right before the auction ends the proposal to update the asset becomes available for execution (after the timelock delay has passed). Somebody executes it, bids, and enjoys the low price of the auction.\n\n### Recommended Mitigation Steps\n\nOn top of checking that the error data is empty, compare the gas before and after to ensure this is an out-of-gas error.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1586331887):**\n > On the fence on this one, it is based off a known issue from a previous Audit but does show a new problem stemming from the same problem of oracle deprecation. \n> \n> Look forward to sponsor comment. \n\n**[tbrent (Reserve) disputed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1589910605):**\n > The PoC does not function as specified. Specifically, [bidding on an auction](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/trading/DutchTrade.sol#L146) does not involve the price at the time of the tx. The price is set at the beginning of the dutch auction in the `init()` function. Therefore, it is the starting of new auctions that will revert while the oracle is deprecated, while bids will succeed and simply fail to start the next auction. \n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1633780455):**\n > > Therefore, it is the starting of new auctions that will revert while the oracle is deprecated, while bids will succeed and simply fail to start the next auction.\n> \n> Hey @tbrent - \n> I didn't quite understand the dispute here, if starting the next auction will fail/revert then the bid will revert too.<br>\n> `bid()` calls `origin.settleTrade()` and `settleTrade()` calls `rebalance()`.<br>\n> If `rebalance()` reverts due to a deprecated oracle then `settleTrade()` will revert too (`rebalance()` will revert with empty data, and therefore the catch block will trigger a revert [here](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BackingManager.sol#L94)).\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1636182107):**\n > @0xA5DF - Ah, understood now. Agree this is Medium and think it should be counted as a new finding since the consequence (dutch auction economics break) is novel. \n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1662674844):**\n > Hey @0xa5df -- we're having some confusion around exactly what happens when a chainlink oracle is deprecated. Do you have details to share about what this ends up looking like? \n> \n> We're having trouble finding documentation on this, and it feels like the aggregator contract should just stay there and return a stale value. Is that not right? Has this happened in the past or has Chainlink committed to a particular approach for deprecating?\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1662876091):**\n > Hey - It's a bit difficult to track deprecated Chainlink oracles since Chainlink removes the announcement once they're deprecated.<br>\n> I was able to track one Oracle that was deprecated during the first audit, from the original issue this seems to be [this one](https://polygonscan.com/address/0x2E5B04aDC0A3b7dB5Fd34AE817c7D0993315A8a6#readContract#F10).<br>\n> It seems that what happens is that Chainlink sets the aggregator address to the zero address, which makes the call to `latestRoundData()` to revert without any data (I guess this is due to the way Solidity handles calls to a non-contract address).<br>\n> See also the PoC in the [original issue](https://github.com/code-423n4/2023-01-reserve-findings/issues/234) in the January audit.\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1662939816):**\n > Got it, checks out. Thanks!\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Add oracle deprecation check.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/886\n\n**Status:** Mitigation confirmed. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/35), [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/28), and [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/17) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/trading/DutchTrade.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"../../interfaces/ITrade.sol\";\n\nuint192 constant FORTY_PERCENT = 4e17; // {1} 0.4\nuint192 constant SIXTY_PERCENT = 6e17; // {1} 0.6\n\n// Exponential price decay with base (999999/1000000). Price starts at 1000x and decays to 1x\n//   A 30-minute auction on a chain with a 12-second blocktime has a ~10.87% price drop per block\n//   during the geometric/exponential period and a 0.05% drop during the linear period.\n//   30-minutes is the recommended length of auction for a chain with 12-second blocktimes, but\n//   longer and shorter times can be used as well. The pricing algorithm does not degrade\n//   beyond the degree to which less overall blocktime means necessarily larger price drops.\nuint192 constant MAX_EXP = 6907752 * FIX_ONE; // {1} (1000000/999999)^6907752 = ~1000x\nuint192 constant BASE = 999999e12; // {1} (999999/1000000)\n\n/**\n * @title DutchTrade\n * @notice Implements a wholesale dutch auction via a piecewise falling-price mechansim.\n *   Over the first 40% of the auction the price falls from ~1000x the best plausible price\n *   down to the best plausible price in a geometric series. The price decreases by the same %\n *   each time. At 30 minutes the decreases are 10.87% per block. Longer auctions have\n *   smaller price decreases, and shorter auctions have larger price decreases.\n *   This period DOES NOT expect to receive a bid; it just defends against manipulated prices.\n *\n *   Over the last 60% of the auction the price falls from the best plausible price to the worst\n *   price, linearly. The worst price is further discounted by the maxTradeSlippage as a fraction\n *   of how far from minTradeVolume to maxTradeVolume the trade lies.\n *   At maxTradeVolume, no further discount is applied.\n *\n * To bid:\n * - Call `bidAmount()` view to check prices at various timestamps\n * - Wait until a desirable block is reached (hopefully not in the first 40% of the auction)\n * - Provide approval of buy tokens and call bid(). The swap will be atomic\n */\ncontract DutchTrade is ITrade {\n    using FixLib for uint192;\n    using SafeERC20 for IERC20Metadata;\n\n    TradeKind public constant KIND = TradeKind.DUTCH_AUCTION;\n\n    TradeStatus public status; // reentrancy protection\n\n    ITrading public origin; // the address that initialized the contract\n\n    // === Auction ===\n    IERC20Metadata public sell;\n    IERC20Metadata public buy;\n    uint192 public sellAmount; // {sellTok}\n\n    // The auction runs from [startTime, endTime], inclusive\n    uint48 public startTime; // {s} when the dutch auction begins (12s after init())\n    uint48 public endTime; // {s} when the dutch auction ends if no bids are received\n\n    // highPrice is always 1000x the middlePrice, so we don't need to track it explicitly\n    uint192 public middlePrice; // {buyTok/sellTok} The price at which the function is piecewise\n    uint192 public lowPrice; // {buyTok/sellTok} The price the auction ends at\n\n    // === Bid ===\n    address public bidder;\n    // the bid amount is just whatever token balance is in the contract at settlement time\n\n    // This modifier both enforces the state-machine pattern and guards against reentrancy.\n    modifier stateTransition(TradeStatus begin, TradeStatus end) {\n        require(status == begin, \"Invalid trade state\");\n        status = TradeStatus.PENDING;\n        _;\n        assert(status == TradeStatus.PENDING);\n        status = end;\n    }\n\n    // === Public Bid Helper ===\n\n    /// Calculates how much buy token is needed to purchase the lot, at a particular timestamp\n    /// @param timestamp {s} The block timestamp to get price for\n    /// @return {qBuyTok} The amount of buy tokens required to purchase the lot\n    function bidAmount(uint48 timestamp) public view returns (uint256) {\n        require(timestamp >= startTime, \"auction not started\");\n        require(timestamp <= endTime, \"auction over\");\n\n        // {buyTok/sellTok}\n        uint192 price = _price(timestamp);\n\n        // {qBuyTok} = {sellTok} * {buyTok/sellTok} * {qBuyTok/buyTok}\n        return sellAmount.mul(price, CEIL).shiftl_toUint(int8(buy.decimals()), CEIL);\n    }\n\n    // === External ===\n\n    /// @param origin_ The Trader that originated the trade\n    /// @param sell_ The asset being sold by the protocol\n    /// @param buy_ The asset being bought by the protocol\n    /// @param sellAmount_ {qSellTok} The amount to sell in the auction, in token quanta\n    /// @param auctionLength {s} How many seconds the dutch auction should run for\n    function init(\n        ITrading origin_,\n        IAsset sell_,\n        IAsset buy_,\n        uint256 sellAmount_,\n        uint48 auctionLength\n    ) external stateTransition(TradeStatus.NOT_STARTED, TradeStatus.OPEN) {\n        assert(\n            address(sell_) != address(0) &&\n                address(buy_) != address(0) &&\n                auctionLength >= 2 * ONE_BLOCK\n        ); // misuse by caller\n\n        // Only start dutch auctions under well-defined prices\n        (uint192 sellLow, uint192 sellHigh) = sell_.price(); // {UoA/sellTok}\n        (uint192 buyLow, uint192 buyHigh) = buy_.price(); // {UoA/buyTok}\n        require(sellLow > 0 && sellHigh < FIX_MAX, \"bad sell pricing\");\n        require(buyLow > 0 && buyHigh < FIX_MAX, \"bad buy pricing\");\n\n        origin = origin_;\n        sell = sell_.erc20();\n        buy = buy_.erc20();\n\n        require(sellAmount_ <= sell.balanceOf(address(this)), \"unfunded trade\");\n        sellAmount = shiftl_toFix(sellAmount_, -int8(sell.decimals())); // {sellTok}\n        startTime = uint48(block.timestamp) + ONE_BLOCK; // start in the next block\n        endTime = startTime + auctionLength;\n\n        // {1}\n        uint192 slippage = _slippage(\n            sellAmount.mul(sellHigh, FLOOR), // auctionVolume\n            origin.minTradeVolume(), // minTradeVolume\n            fixMin(sell_.maxTradeVolume(), buy_.maxTradeVolume()) // maxTradeVolume\n        );\n\n        // {buyTok/sellTok} = {UoA/sellTok} * {1} / {UoA/buyTok}\n        lowPrice = sellLow.mulDiv(FIX_ONE - slippage, buyHigh, FLOOR);\n        middlePrice = sellHigh.div(buyLow, CEIL); // no additional slippage\n        // highPrice = 1000 * middlePrice\n\n        assert(lowPrice <= middlePrice);\n    }\n\n    /// Bid for the auction lot at the current price; settling atomically via a callback\n    /// @dev Caller must have provided approval\n    /// @return amountIn {qBuyTok} The quantity of tokens the bidder paid\n    function bid() external returns (uint256 amountIn) {\n        require(bidder == address(0), \"bid already received\");\n\n        // {qBuyTok}\n        amountIn = bidAmount(uint48(block.timestamp)); // enforces auction ongoing\n\n        // Transfer in buy tokens\n        bidder = msg.sender;\n        buy.safeTransferFrom(bidder, address(this), amountIn);\n\n        // status must begin OPEN\n        assert(status == TradeStatus.OPEN);\n\n        // settle() via callback\n        origin.settleTrade(sell);\n\n        // confirm callback succeeded\n        assert(status == TradeStatus.CLOSED);\n    }\n\n    /// Settle the auction, emptying the contract of balances\n    /// @return soldAmt {qSellTok} Token quantity sold by the protocol\n    /// @return boughtAmt {qBuyTok} Token quantity purchased by the protocol\n    function settle()\n        external\n        stateTransition(TradeStatus.OPEN, TradeStatus.CLOSED)\n        returns (uint256 soldAmt, uint256 boughtAmt)\n    {\n        require(msg.sender == address(origin), \"only origin can settle\");\n\n        // Received bid\n        if (bidder != address(0)) {\n            sell.safeTransfer(bidder, sellAmount);\n        } else {\n            require(block.timestamp >= endTime, \"auction not over\");\n        }\n\n        uint256 sellBal = sell.balanceOf(address(this));\n        soldAmt = sellAmount > sellBal ? sellAmount - sellBal : 0;\n        boughtAmt = buy.balanceOf(address(this));\n\n        // Transfer balances back to origin\n        buy.safeTransfer(address(origin), boughtAmt);\n        sell.safeTransfer(address(origin), sellBal);\n    }\n\n    /// Anyone can transfer any ERC20 back to the origin after the trade has been closed\n    /// @dev Escape hatch in case of accidentally transferred tokens after auction end\n    /// @custom:interaction CEI (and respects the state lock)\n    function transferToOriginAfterTradeComplete(IERC20Metadata erc20) external {\n        require(status == TradeStatus.CLOSED, \"only after trade is closed\");\n        erc20.safeTransfer(address(origin), erc20.balanceOf(address(this)));\n    }\n\n    /// @return True if the trade can be settled.\n    // Guaranteed to be true some time after init(), until settle() is called\n    function canSettle() external view returns (bool) {\n        return status == TradeStatus.OPEN && (bidder != address(0) || block.timestamp > endTime);\n    }\n\n    // === Private ===\n\n    /// Return a sliding % from 0 (at maxTradeVolume) to maxTradeSlippage (at minTradeVolume)\n    /// @param auctionVolume {UoA} The actual auction volume\n    /// @param minTradeVolume {UoA} The minimum trade volume\n    /// @param maxTradeVolume {UoA} The maximum trade volume\n    /// @return slippage {1} The fraction of auctionVolume that should be permitted as slippage\n    function _slippage(\n        uint192 auctionVolume,\n        uint192 minTradeVolume,\n        uint192 maxTradeVolume\n    ) private view returns (uint192 slippage) {\n        slippage = origin.maxTradeSlippage(); // {1}\n        if (maxTradeVolume <= minTradeVolume || auctionVolume < minTradeVolume) return slippage;\n        if (auctionVolume > maxTradeVolume) return 0; // 0% slippage beyond maxTradeVolume\n\n        // {1} = {1} * ({UoA} - {UoA}} / ({UoA} - {UoA})\n        return\n            slippage.mul(\n                FIX_ONE - divuu(auctionVolume - minTradeVolume, maxTradeVolume - minTradeVolume)\n            );\n    }\n\n    /// Return the price of the auction at a particular timestamp\n    /// @param timestamp {s} The block timestamp\n    /// @return {buyTok/sellTok}\n    function _price(uint48 timestamp) private view returns (uint192) {\n        /// Price Curve:\n        ///   - first 40%: geometrically decrease the price from 1000x the middlePrice to 1x\n        ///   - last 60: decrease linearly from middlePrice to lowPrice\n\n        uint192 progression = divuu(timestamp - startTime, endTime - startTime); // {1}\n\n        // Fast geometric decay -- 0%-40% of auction\n        if (progression < FORTY_PERCENT) {\n            uint192 exp = MAX_EXP.mulDiv(FORTY_PERCENT - progression, FORTY_PERCENT, ROUND);\n\n            // middlePrice * ((1000000/999999) ^ exp) = middlePrice / ((999999/1000000) ^ exp)\n            // safe uint48 downcast: exp is at-most 6907752\n            // {buyTok/sellTok} = {buyTok/sellTok} / {1} ^ {1}\n            return middlePrice.div(BASE.powu(uint48(exp.toUint(ROUND))), CEIL);\n            // this reverts for middlePrice >= 6.21654046e36 * FIX_ONE\n        }\n\n        // Slow linear decay -- 40%-100% of auction\n        return\n            middlePrice -\n            (middlePrice - lowPrice).mulDiv(progression - FORTY_PERCENT, SIXTY_PERCENT);\n    }\n}"
    },
    {
      "filename": "contracts/p1/BackingManager.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IAsset.sol\";\nimport \"../interfaces/IBackingManager.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Array.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Trading.sol\";\nimport \"./mixins/RecollateralizationLib.sol\";\n\n/**\n * @title BackingManager\n * @notice The backing manager holds + manages the backing for an RToken\n */\n\n/// @custom:oz-upgrades-unsafe-allow external-library-linking\ncontract BackingManagerP1 is TradingP1, IBackingManager {\n    using FixLib for uint192;\n    using SafeERC20 for IERC20;\n\n    // Cache of peer components\n    IAssetRegistry private assetRegistry;\n    IBasketHandler private basketHandler;\n    IDistributor private distributor;\n    IRToken private rToken;\n    IERC20 private rsr;\n    IStRSR private stRSR;\n    IRevenueTrader private rsrTrader;\n    IRevenueTrader private rTokenTrader;\n    uint48 public constant MAX_TRADING_DELAY = 31536000; // {s} 1 year\n    uint192 public constant MAX_BACKING_BUFFER = FIX_ONE; // {1} 100%\n\n    uint48 public tradingDelay; // {s} how long to wait until resuming trading after switching\n    uint192 public backingBuffer; // {1} how much extra backing collateral to keep\n\n    // === 3.0.0 ===\n    IFurnace private furnace;\n    mapping(TradeKind => uint48) private tradeEnd; // {s} last endTime() of an auction per kind\n\n    // ==== Invariants ====\n    // tradingDelay <= MAX_TRADING_DELAY and backingBuffer <= MAX_BACKING_BUFFER\n\n    function init(\n        IMain main_,\n        uint48 tradingDelay_,\n        uint192 backingBuffer_,\n        uint192 maxTradeSlippage_,\n        uint192 minTradeVolume_\n    ) external initializer {\n        __Component_init(main_);\n        __Trading_init(main_, maxTradeSlippage_, minTradeVolume_);\n\n        cacheComponents();\n        setTradingDelay(tradingDelay_);\n        setBackingBuffer(backingBuffer_);\n    }\n\n    /// Give RToken max allowance over the registered token `erc20`\n    /// @custom:interaction CEI\n    // checks: erc20 in assetRegistry\n    // action: set allowance on erc20 for rToken to UINT_MAX\n    // Using two safeApprove calls instead of safeIncreaseAllowance to support USDT\n    function grantRTokenAllowance(IERC20 erc20) external notFrozen {\n        require(assetRegistry.isRegistered(erc20), \"erc20 unregistered\");\n        // == Interaction ==\n        IERC20(address(erc20)).safeApprove(address(main.rToken()), 0);\n        IERC20(address(erc20)).safeApprove(address(main.rToken()), type(uint256).max);\n    }\n\n    /// Settle a single trade. If the caller is the trade, try chaining into rebalance()\n    /// While this function is not nonReentrant, its two subsets each individually are\n    /// @param sell The sell token in the trade\n    /// @return trade The ITrade contract settled\n    /// @custom:interaction\n    function settleTrade(IERC20 sell)\n        public\n        override(ITrading, TradingP1)\n        notTradingPausedOrFrozen\n        returns (ITrade trade)\n    {\n        trade = super.settleTrade(sell); // nonReentrant\n\n        // if the settler is the trade contract itself, try chaining with another rebalance()\n        if (_msgSender() == address(trade)) {\n            // solhint-disable-next-line no-empty-blocks\n            try this.rebalance(trade.KIND()) {} catch (bytes memory errData) {\n                // prevent MEV searchers from providing less gas on purpose by reverting if OOG\n                // untested:\n                //     OOG pattern tested in other contracts, cost to test here is high\n                // see: docs/solidity-style.md#Catching-Empty-Data\n                if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            }\n        }\n    }\n\n    /// Apply the overall backing policy using the specified TradeKind, taking a haircut if unable\n    /// @param kind TradeKind.DUTCH_AUCTION or TradeKind.BATCH_AUCTION\n    /// @custom:interaction not RCEI; nonReentrant\n    // untested:\n    //      OZ nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function rebalance(TradeKind kind) external nonReentrant notTradingPausedOrFrozen {\n        // == Refresh ==\n        assetRegistry.refresh();\n        furnace.melt();\n\n        // DoS prevention: unless caller is self, require 1 empty block between like-kind auctions\n        // Assumption: chain has <= 12s blocktimes\n        require(\n            _msgSender() == address(this) || tradeEnd[kind] + ONE_BLOCK < block.timestamp,\n            \"already rebalancing\"\n        );\n\n        require(tradesOpen == 0, \"trade open\");\n        require(basketHandler.isReady(), \"basket not ready\");\n        require(block.timestamp >= basketHandler.timestamp() + tradingDelay, \"trading delayed\");\n\n        BasketRange memory basketsHeld = basketHandler.basketsHeldBy(address(this));\n        require(basketsHeld.bottom < rToken.basketsNeeded(), \"already collateralized\");\n        // require(!basketHandler.fullyCollateralized())\n\n        // First dissolve any held RToken balance (above Distributor-dust)\n        // gas-optimization: 1 whole RToken must be worth 100 trillion dollars for this to skip $1\n        uint256 balance = main.rToken().balanceOf(address(this));\n        if (balance >= MAX_DISTRIBUTION * MAX_DESTINATIONS) main.rToken().dissolve(balance);\n        if (basketsHeld.bottom >= rToken.basketsNeeded()) return; // return if now capitalized\n\n        /*\n         * Recollateralization\n         *\n         * Strategy: iteratively move the system on a forgiving path towards collateralization\n         * through a narrowing BU price band. The initial large spread reflects the\n         * uncertainty associated with the market price of defaulted/volatile collateral, as\n         * well as potential losses due to trading slippage. In the absence of further\n         * collateral default, the size of the BU price band should decrease with each trade\n         * until it is 0, at which point collateralization is restored.\n         *\n         * If we run out of capital and are still undercollateralized, we compromise\n         * rToken.basketsNeeded to the current basket holdings. Haircut time.\n         */\n\n        (bool doTrade, TradeRequest memory req) = RecollateralizationLibP1\n            .prepareRecollateralizationTrade(this, basketsHeld);\n\n        if (doTrade) {\n            // Seize RSR if needed\n            if (req.sell.erc20() == rsr) {\n                uint256 bal = req.sell.erc20().balanceOf(address(this));\n                if (req.sellAmount > bal) stRSR.seizeRSR(req.sellAmount - bal);\n            }\n\n            // Execute Trade\n            ITrade trade = tryTrade(kind, req);\n            tradeEnd[kind] = trade.endTime();\n        } else {\n            // Haircut time\n            compromiseBasketsNeeded(basketsHeld.bottom);\n        }\n    }\n\n    /// Forward revenue to RevenueTraders; reverts if not fully collateralized\n    /// @param erc20s The tokens to forward\n    /// @custom:interaction not RCEI; nonReentrant\n    // untested:\n    //      OZ nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function forwardRevenue(IERC20[] calldata erc20s)\n        external\n        nonReentrant\n        notTradingPausedOrFrozen\n    {\n        require(ArrayLib.allUnique(erc20s), \"duplicate tokens\");\n\n        assetRegistry.refresh();\n        furnace.melt();\n\n        BasketRange memory basketsHeld = basketHandler.basketsHeldBy(address(this));\n\n        require(tradesOpen == 0, \"trade open\");\n        require(basketHandler.isReady(), \"basket not ready\");\n        require(block.timestamp >= basketHandler.timestamp() + tradingDelay, \"trading delayed\");\n        require(basketsHeld.bottom >= rToken.basketsNeeded(), \"undercollateralized\");\n        // require(basketHandler.fullyCollateralized())\n\n        /**\n         * Assumptions:\n         *   - Fully collateralized. All collateral meet balance requirements.\n         *   - All backing capital is held at BackingManager's address. No capital is out on-trade\n         *   - Neither RToken nor RSR are in the basket\n         *   - Each address in erc20s is unique\n         *\n         * Steps:\n         *   1. Forward all held RSR to the RSR trader to prevent using it for RToken appreciation\n         *      (action: send rsr().balanceOf(this) to rsrTrader)\n         *   2. Using whatever balances of collateral are there, fast-issue all RToken possible.\n         *      (in detail: mint RToken and set basketsNeeded so that the BU/rtok exchange rate is\n         *       roughly constant, and strictly does not decrease,\n         *   3. Handout all RToken held above the backingBuffer portion of the supply, and all\n         *      non-RToken surplus asset balances to the RSR and\n         *      RToken traders according to the distribution totals.\n         */\n\n        // Forward any RSR held to StRSR pool; RSR should never be sold for RToken yield\n        if (rsr.balanceOf(address(this)) > 0) {\n            // For CEI, this is an interaction \"within our system\" even though RSR is already live\n            IERC20(address(rsr)).safeTransfer(address(stRSR), rsr.balanceOf(address(this)));\n        }\n\n        // Mint revenue RToken\n        // Keep backingBuffer worth of collateral before recognizing revenue\n        uint192 needed = rToken.basketsNeeded().mul(FIX_ONE + backingBuffer); // {BU}\n        if (basketsHeld.bottom > needed) {\n            rToken.mint(basketsHeld.bottom - needed);\n            needed = rToken.basketsNeeded().mul(FIX_ONE + backingBuffer); // keep buffer\n        }\n\n        // At this point, even though basketsNeeded may have changed, we are:\n        // - We're fully collateralized\n        // - The BU exchange rate {BU/rTok} did not decrease\n\n        // Handout surplus assets + newly minted RToken\n\n        uint256 length = erc20s.length;\n        RevenueTotals memory totals = distributor.totals();\n        for (uint256 i = 0; i < length; ++i) {\n            IAsset asset = assetRegistry.toAsset(erc20s[i]);\n\n            // {tok} = {BU} * {tok/BU}\n            uint192 req = needed.mul(basketHandler.quantity(erc20s[i]), CEIL);\n            uint192 bal = asset.bal(address(this));\n\n            if (bal.gt(req)) {\n                // delta: {qTok}, the excess quantity of this asset that we hold\n                uint256 delta = bal.minus(req).shiftl_toUint(int8(asset.erc20Decimals()));\n                uint256 tokensPerShare = delta / (totals.rTokenTotal + totals.rsrTotal);\n\n                // no div-by-0: Distributor guarantees (totals.rTokenTotal + totals.rsrTotal) > 0\n                // initial division is intentional here! We'd rather save the dust than be unfair\n\n                if (totals.rsrTotal > 0) {\n                    erc20s[i].safeTransfer(address(rsrTrader), tokensPerShare * totals.rsrTotal);\n                }\n                if (totals.rTokenTotal > 0) {\n                    erc20s[i].safeTransfer(\n                        address(rTokenTrader),\n                        tokensPerShare * totals.rTokenTotal\n                    );\n                }\n            }\n        }\n        // It's okay if there is leftover dust for RToken or a surplus asset (not RSR)\n    }\n\n    // === Private ===\n\n    /// Compromise on how many baskets are needed in order to recollateralize-by-accounting\n    /// @param basketsHeldBottom {BU} The number of full basket units held by the BackingManager\n    function compromiseBasketsNeeded(uint192 basketsHeldBottom) private {\n        // assert(tradesOpen == 0 && !basketHandler.fullyCollateralized());\n        assert(tradesOpen == 0);\n        rToken.setBasketsNeeded(basketsHeldBottom);\n    }\n\n    // === Governance Setters ===\n\n    /// @custom:governance\n    function setTradingDelay(uint48 val) public governance {\n        require(val <= MAX_TRADING_DELAY, \"invalid tradingDelay\");\n        emit TradingDelaySet(tradingDelay, val);\n        tradingDelay = val;\n    }\n\n    /// @custom:governance\n    function setBackingBuffer(uint192 val) public governance {\n        require(val <= MAX_BACKING_BUFFER, \"invalid backingBuffer\");\n        emit BackingBufferSet(backingBuffer, val);\n        backingBuffer = val;\n    }\n\n    /// Call after upgrade to >= 3.0.0\n    function cacheComponents() public {\n        assetRegistry = main.assetRegistry();\n        basketHandler = main.basketHandler();\n        distributor = main.distributor();\n        rToken = main.rToken();\n        rsr = main.rsr();\n        stRSR = main.stRSR();\n        rsrTrader = main.rsrTrader();\n        rTokenTrader = main.rTokenTrader();\n        furnace = main.furnace();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[39] private __gap;\n}"
    }
  ]
}