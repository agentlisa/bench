{
  "Title": "Tokens Trapped in the Vault Might Cause Redemptions to Revert in Low FORT Liquidity Scenarios",
  "Content": "The [`redeem` function](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L294) enables users to redeem their staked FORT tokens—or someone else's on their behalf. This function calculates the redeemer's share of the total vault assets and uses this proportion to [transfer active staking tokens](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L317-L326) and [distributor shares](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L349-L356) from the vault to the `redemptionReceiver`. This allows the user to later claim them through the [`claimRedeem` function](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L383) when available. Finally, it [transfers the corresponding proportion of available FORT tokens in the vault](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L372) that have not yet been delegated, utilizing the FORT token's `balanceOf` function for this purpose.\n\n\nHowever, during this final operation, if extra tokens are present in the vault—whether they were directly sent to the contract by mistake or otherwise—these tokens will be included in the calculation when deducting the assets transferred to the user from the [`_totalAssets`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L373) variable. Notably, the `_totalAssets` variable does not account for tokens directly transferred to the vault. Consequently, this discrepancy may lead to the `redeem` function reverting due to an underflow, especially when the last few users attempt to redeem tokens from the vault. A step-by-step proof-of-concept for this scenario can be found in [this secret gist](https://gist.github.com/jbcarpanelli/555279fc3e48614ee070db45d9e0820f).\n\n\nConsider accounting for all mistakenly sent FORT tokens in the vault in the `_totalAssets` state variable. Otherwise, consider implementing a `sweep` function that withdraws the token amount difference between `_totalAssets` and the actual balance reported by the FORT token contract's `balanceOf` function.\n\n\n***Update:** Resolved in [pull request #30](https://github.com/NethermindEth/forta-staking-vault/pull/30).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/FortaStakingVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ERC4626Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\nimport { ERC1155HolderUpgradeable } from\n    \"@openzeppelin-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { IFortaStaking, DELEGATOR_SCANNER_POOL_SUBJECT } from \"./interfaces/IFortaStaking.sol\";\nimport { IRewardsDistributor } from \"./interfaces/IRewardsDistributor.sol\";\nimport { FortaStakingUtils } from \"./utils/FortaStakingUtils.sol\";\nimport { OperatorFeeUtils, FEE_BASIS_POINTS_DENOMINATOR } from \"./utils/OperatorFeeUtils.sol\";\nimport { RedemptionReceiver } from \"./RedemptionReceiver.sol\";\nimport { InactiveSharesDistributor } from \"./InactiveSharesDistributor.sol\";\n\n/**\n * @title FORT Vault with a stategy to generate rewards by staking in the forta network\n * @author Nethermind\n * @notice Strategy is manually operated by the OPERATOR_ROLE\n */\ncontract FortaStakingVault is AccessControlUpgradeable, ERC4626Upgradeable, ERC1155HolderUpgradeable {\n    using Clones for address;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    mapping(uint256 => uint256) private _assetsPerSubject;\n\n    mapping(uint256 => uint256) private _subjectIndex;\n    uint256[] public subjects;\n\n    mapping(uint256 => uint256) private _subjectInactiveSharesDistributorIndex;\n    mapping(uint256 => uint256) private _subjectDeadline;\n    mapping(address => uint256) private _distributorSubject;\n    address[] private _inactiveSharesDistributors;\n\n    uint256 public feeInBasisPoints; // e.g. 300 = 3%\n    address public feeTreasury;\n\n    IERC20 private _token;\n    IFortaStaking private _staking;\n    IRewardsDistributor private _rewardsDistributor;\n    address private _receiverImplementation;\n    address private _distributorImplementation;\n    uint256 private _totalAssets;\n\n    error NotOperator();\n    error InvalidTreasury();\n    error InvalidFee();\n    error PendingUndelegation();\n    error InvalidUndelegation();\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the Vault\n     * @param asset_ Asset to stake (FORT Token address)\n     * @param fortaStaking FortaStaking contract address\n     * @param redemptionReceiverImplementation RedemptionReceiver implementation contract\n     * @param inactiveSharesDistributorImplementation InactiveSharesDistributor implementation contract\n     * @param operatorFeeInBasisPoints Fee applied on redemptions\n     * @param operatorFeeTreasury Treasury address to receive the fees\n     * @param rewardsDistributor RewardsDistributor contract address\n     */\n    function initialize(\n        address asset_,\n        address fortaStaking,\n        address redemptionReceiverImplementation,\n        address inactiveSharesDistributorImplementation,\n        uint256 operatorFeeInBasisPoints,\n        address operatorFeeTreasury,\n        address rewardsDistributor\n    )\n        public\n        initializer\n    {\n        __ERC20_init_unchained(\"FORT Staking Vault\", \"vFORT\");\n        __ERC4626_init_unchained(IERC20(asset_));\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(OPERATOR_ROLE, msg.sender);\n        _staking = IFortaStaking(fortaStaking);\n        _token = IERC20(asset_);\n        _receiverImplementation = redemptionReceiverImplementation;\n        _distributorImplementation = inactiveSharesDistributorImplementation;\n        _rewardsDistributor = IRewardsDistributor(rewardsDistributor);\n        feeInBasisPoints = operatorFeeInBasisPoints;\n        feeTreasury = operatorFeeTreasury;\n    }\n\n    /**\n     * @inheritdoc ERC1155HolderUpgradeable\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155HolderUpgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @notice Updates the known assets in the different subjects\n     * @dev Needed to ensure the _totalAssets are correct and shares\n     * distributed correctly\n     */\n    function _updatePoolsAssets() private {\n        for (uint256 i = 0; i < subjects.length; ++i) {\n            _updatePoolAssets(subjects[i]);\n        }\n    }\n\n    /**\n     * @notice Updates the amount of assets delegated to a subject\n     * @param subject Subject to update the amount of assets\n     */\n    function _updatePoolAssets(uint256 subject) private {\n        uint256 activeId = FortaStakingUtils.subjectToActive(DELEGATOR_SCANNER_POOL_SUBJECT, subject);\n        uint256 inactiveId = FortaStakingUtils.activeToInactive(activeId);\n\n        uint256 assets = _staking.activeSharesToStake(activeId, _staking.balanceOf(address(this), activeId));\n\n        if (_subjectDeadline[subject] != 0) {\n            assets += _staking.inactiveSharesToStake(\n                inactiveId,\n                IERC20(_inactiveSharesDistributors[_subjectInactiveSharesDistributorIndex[subject]]).balanceOf(\n                    address(this)\n                )\n            );\n        }\n\n        if (_assetsPerSubject[subject] != assets) {\n            _totalAssets = _totalAssets - _assetsPerSubject[subject] + assets;\n            _assetsPerSubject[subject] = assets;\n        }\n    }\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     * @dev Overrided because assets are moved out of the vault\n     */\n    function totalAssets() public view override returns (uint256) {\n        return _totalAssets;\n    }\n\n    /**\n     * @notice Claim rewards associated to a subject\n     * @param subjectId Subject to claim rewards from\n     * @param epochNumber Epoch where the rewards were generated\n     * @dev meant to be called by a relayer (i.e OZ Defender)\n     */\n    function claimRewards(uint256 subjectId, uint256 epochNumber) public {\n        uint256[] memory epochs = new uint256[](1);\n        epochs[0] = epochNumber;\n        _rewardsDistributor.claimRewards(DELEGATOR_SCANNER_POOL_SUBJECT, subjectId, epochs);\n    }\n\n    //// Operator functions ////\n\n    /**\n     * @notice Checks that the caller is the OPERATOR_ROLE\n     */\n    function _validateIsOperator() private view {\n        if (!hasRole(OPERATOR_ROLE, msg.sender)) {\n            revert NotOperator();\n        }\n    }\n\n    /**\n     * @notice Delegate FORT in the vault to a subject\n     * @param subject Subject to delegate assets to\n     * @param assets Amount of assets to delegate\n     */\n    function delegate(uint256 subject, uint256 assets) public {\n        _validateIsOperator();\n\n        if (_assetsPerSubject[subject] == 0) {\n            _subjectIndex[subject] = subjects.length;\n            subjects.push(subject);\n        }\n        _token.approve(address(_staking), assets);\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _staking.deposit(DELEGATOR_SCANNER_POOL_SUBJECT, subject, assets);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n        // get the exact amount delivered to the pool\n        _assetsPerSubject[subject] += (balanceBefore - balanceAfter);\n    }\n\n    /**\n     * @notice Initiate an undelegation from a subject\n     * @param subject Subject to undelegate assets from\n     * @param shares Amount of shares to undelegate\n     * @dev generated a new contract to simulate a pool given\n     * that inactiveShares are not transferrable\n     */\n    function initiateUndelegate(uint256 subject, uint256 shares) public returns (uint256, address) {\n        _validateIsOperator();\n\n        if (_subjectDeadline[subject] != 0) {\n            // can generate extra delays for users\n            revert PendingUndelegation();\n        }\n\n        InactiveSharesDistributor distributor = InactiveSharesDistributor(_distributorImplementation.clone());\n        _staking.safeTransferFrom(\n            address(this),\n            address(distributor),\n            FortaStakingUtils.subjectToActive(DELEGATOR_SCANNER_POOL_SUBJECT, subject),\n            shares,\n            \"\"\n        );\n        distributor.initialize(_staking, _token, subject, shares);\n\n        _subjectInactiveSharesDistributorIndex[subject] = _inactiveSharesDistributors.length;\n        _inactiveSharesDistributors.push(address(distributor));\n        _distributorSubject[address(distributor)] = subject;\n        uint256 deadline = distributor.initiateUndelegate();\n        _subjectDeadline[subject] = deadline;\n        return (deadline, address(distributor));\n    }\n\n    /**\n     * @notice Finish an undelegation from a subject\n     * @param subject Subject being undelegate\n     * @dev vault receives the portion of undelegated assets\n     * not redeemed by users\n     */\n    function undelegate(uint256 subject) public {\n        _updatePoolAssets(subject);\n\n        if (\n            (_subjectDeadline[subject] == 0) || (_subjectDeadline[subject] > block.timestamp)\n                || _staking.isFrozen(DELEGATOR_SCANNER_POOL_SUBJECT, subject)\n        ) {\n            revert InvalidUndelegation();\n        }\n\n        uint256 distributorIndex = _subjectInactiveSharesDistributorIndex[subject];\n        InactiveSharesDistributor distributor = InactiveSharesDistributor(_inactiveSharesDistributors[distributorIndex]);\n\n        uint256 beforeWithdrawBalance = _token.balanceOf(address(this));\n        distributor.undelegate();\n        uint256 afterWithdrawBalance = _token.balanceOf(address(this));\n\n        // remove _inactiveSharesDistributors\n        address lastDistributor = _inactiveSharesDistributors[_inactiveSharesDistributors.length - 1];\n        _inactiveSharesDistributors[distributorIndex] = lastDistributor;\n        _subjectInactiveSharesDistributorIndex[_distributorSubject[lastDistributor]] = distributorIndex;\n        _inactiveSharesDistributors.pop();\n        delete _subjectDeadline[subject];\n        delete _distributorSubject[address(distributor)];\n        delete _subjectInactiveSharesDistributorIndex[subject];\n\n        _assetsPerSubject[subject] -= (afterWithdrawBalance - beforeWithdrawBalance);\n\n        //slither-disable-next-line incorrect-equality\n        if (_assetsPerSubject[subject] == 0) {\n            uint256 index = _subjectIndex[subject];\n            subjects[index] = subjects[subjects.length - 1];\n            _subjectIndex[subjects[index]] = index;\n            subjects.pop();\n            delete _subjectIndex[subject];\n        }\n    }\n\n    //// User operations ////\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        _updatePoolsAssets();\n\n        uint256 beforeDepositBalance = _token.balanceOf(address(this));\n        uint256 shares = super.deposit(assets, receiver);\n        uint256 afterDepositBalance = _token.balanceOf(address(this));\n\n        _totalAssets += afterDepositBalance - beforeDepositBalance;\n\n        return shares;\n    }\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     * @dev Assets in the pool are redeemed inmediatly\n     * @dev New contract is crated per user so the redemptions\n     * don't share the same delay in the FortaStaking contract\n     */\n    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256) {\n        _updatePoolsAssets();\n\n        if (msg.sender != owner) {\n            // caller needs to be allowed\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        // user redemption contract\n        RedemptionReceiver redemptionReceiver = RedemptionReceiver(createAndGetRedemptionReceiver(owner));\n\n        {\n            // Active shares redemption\n            uint256 newUndelegations;\n            uint256[] memory tempSharesToUndelegate = new uint256[](subjects.length);\n            uint256[] memory tempSubjectsToUndelegateFrom = new uint256[](subjects.length);\n\n            for (uint256 i = 0; i < subjects.length; ++i) {\n                uint256 subject = subjects[i];\n                uint256 subjectShares = _staking.sharesOf(DELEGATOR_SCANNER_POOL_SUBJECT, subject, address(this));\n                uint256 sharesToUndelegateInSubject = Math.mulDiv(shares, subjectShares, totalSupply());\n                if (sharesToUndelegateInSubject != 0) {\n                    _staking.safeTransferFrom(\n                        address(this),\n                        address(redemptionReceiver),\n                        FortaStakingUtils.subjectToActive(DELEGATOR_SCANNER_POOL_SUBJECT, subject),\n                        sharesToUndelegateInSubject,\n                        \"\"\n                    );\n                    _updatePoolAssets(subject);\n                    tempSharesToUndelegate[newUndelegations] = sharesToUndelegateInSubject;\n                    tempSubjectsToUndelegateFrom[newUndelegations] = subject;\n                    ++newUndelegations;\n                }\n            }\n            uint256[] memory sharesToUndelegate = new uint256[](newUndelegations);\n            uint256[] memory subjectsToUndelegateFrom = new uint256[](newUndelegations);\n            for (uint256 i = 0; i < newUndelegations; ++i) {\n                sharesToUndelegate[i] = tempSharesToUndelegate[i];\n                subjectsToUndelegateFrom[i] = tempSubjectsToUndelegateFrom[i];\n            }\n            redemptionReceiver.addUndelegations(subjectsToUndelegateFrom, sharesToUndelegate);\n        }\n\n        {\n            // Inactive shares redemption\n            uint256 newUndelegations;\n            address[] memory tempDistributors = new address[](_inactiveSharesDistributors.length);\n\n            for (uint256 i = 0; i < _inactiveSharesDistributors.length; ++i) {\n                InactiveSharesDistributor distributor = InactiveSharesDistributor(_inactiveSharesDistributors[i]);\n                uint256 vaultShares = distributor.balanceOf(address(this));\n                uint256 sharesToUndelegateInDistributor = Math.mulDiv(shares, vaultShares, totalSupply());\n                if (sharesToUndelegateInDistributor != 0) {\n                    IERC20(distributor).safeTransfer(address(redemptionReceiver), sharesToUndelegateInDistributor);\n                    _updatePoolAssets(_distributorSubject[address(distributor)]);\n                    tempDistributors[newUndelegations] = address(distributor);\n                    ++newUndelegations;\n                }\n            }\n            address[] memory distributorsToUndelegateFrom = new address[](newUndelegations);\n            for (uint256 i = 0; i < newUndelegations; ++i) {\n                distributorsToUndelegateFrom[i] = tempDistributors[i];\n            }\n            redemptionReceiver.addDistributors(distributorsToUndelegateFrom);\n        }\n\n        // send portion of assets in the pool\n        uint256 vaultBalance = _token.balanceOf(address(this));\n        uint256 vaultBalanceToRedeem = Math.mulDiv(shares, vaultBalance, totalSupply());\n\n        uint256 userAmountToRedeem =\n            OperatorFeeUtils.deductAndTransferFee(vaultBalanceToRedeem, feeInBasisPoints, feeTreasury, _token);\n\n        _token.safeTransfer(receiver, userAmountToRedeem);\n        _totalAssets -= vaultBalanceToRedeem;\n        _burn(owner, shares);\n\n        return vaultBalanceToRedeem;\n    }\n\n    /**\n     * @notice Claim user redeemed assets\n     * @param receiver Address to receive the redeemed assets\n     */\n    function claimRedeem(address receiver) public returns (uint256) {\n        RedemptionReceiver redemptionReceiver = RedemptionReceiver(getRedemptionReceiver(msg.sender));\n        return redemptionReceiver.claim(receiver, feeInBasisPoints, feeTreasury);\n    }\n\n    /**\n     * @notice Generates the salt to be used by create2 given an user\n     * @param user Address of the user the salt is associated to\n     */\n    function getSalt(address user) private pure returns (bytes32) {\n        return keccak256(abi.encode(user));\n    }\n\n    /**\n     * @notice Return the redemption receiver contract of a user\n     * @param user Address of the user the receiver is associated to\n     */\n    function getRedemptionReceiver(address user) public view returns (address) {\n        return _receiverImplementation.predictDeterministicAddress(getSalt(user), address(this));\n    }\n\n    /**\n     * @notice Deploys a new Redemption Receiver for a user\n     * @param user Address of the user the receiver is associated to\n     * @dev If the address if already deployed it is simply returned\n     */\n    function createAndGetRedemptionReceiver(address user) private returns (address) {\n        address receiver = getRedemptionReceiver(user);\n        if (receiver.code.length == 0) {\n            // create and initialize a new contract\n            _receiverImplementation.cloneDeterministic(getSalt(user));\n            RedemptionReceiver(receiver).initialize(_staking, _token);\n        }\n        return receiver;\n    }\n\n    /**\n     * @notice Updates the treasury address\n     * @param treasury New treasury address\n     */\n    function updateFeeTreasury(address treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (treasury == address(0)) {\n            revert InvalidTreasury();\n        }\n        feeTreasury = treasury;\n    }\n\n    /**\n     * @notice Updates the redemption fee\n     * @param feeBasisPoints New fee\n     */\n    function updateFeeBasisPoints(uint256 feeBasisPoints) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (feeBasisPoints >= FEE_BASIS_POINTS_DENOMINATOR) {\n            revert InvalidFee();\n        }\n        feeInBasisPoints = feeBasisPoints;\n    }\n}"
    },
    {
      "filename": "src/FortaStakingVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ERC4626Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\nimport { ERC1155HolderUpgradeable } from\n    \"@openzeppelin-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { IFortaStaking, DELEGATOR_SCANNER_POOL_SUBJECT } from \"./interfaces/IFortaStaking.sol\";\nimport { IRewardsDistributor } from \"./interfaces/IRewardsDistributor.sol\";\nimport { FortaStakingUtils } from \"./utils/FortaStakingUtils.sol\";\nimport { OperatorFeeUtils, FEE_BASIS_POINTS_DENOMINATOR } from \"./utils/OperatorFeeUtils.sol\";\nimport { RedemptionReceiver } from \"./RedemptionReceiver.sol\";\nimport { InactiveSharesDistributor } from \"./InactiveSharesDistributor.sol\";\n\n/**\n * @title FORT Vault with a stategy to generate rewards by staking in the forta network\n * @author Nethermind\n * @notice Strategy is manually operated by the OPERATOR_ROLE\n */\ncontract FortaStakingVault is AccessControlUpgradeable, ERC4626Upgradeable, ERC1155HolderUpgradeable {\n    using Clones for address;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    mapping(uint256 => uint256) private _assetsPerSubject;\n\n    mapping(uint256 => uint256) private _subjectIndex;\n    uint256[] public subjects;\n\n    mapping(uint256 => uint256) private _subjectInactiveSharesDistributorIndex;\n    mapping(uint256 => uint256) private _subjectDeadline;\n    mapping(address => uint256) private _distributorSubject;\n    address[] private _inactiveSharesDistributors;\n\n    uint256 public feeInBasisPoints; // e.g. 300 = 3%\n    address public feeTreasury;\n\n    IERC20 private _token;\n    IFortaStaking private _staking;\n    IRewardsDistributor private _rewardsDistributor;\n    address private _receiverImplementation;\n    address private _distributorImplementation;\n    uint256 private _totalAssets;\n\n    error NotOperator();\n    error InvalidTreasury();\n    error InvalidFee();\n    error PendingUndelegation();\n    error InvalidUndelegation();\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the Vault\n     * @param asset_ Asset to stake (FORT Token address)\n     * @param fortaStaking FortaStaking contract address\n     * @param redemptionReceiverImplementation RedemptionReceiver implementation contract\n     * @param inactiveSharesDistributorImplementation InactiveSharesDistributor implementation contract\n     * @param operatorFeeInBasisPoints Fee applied on redemptions\n     * @param operatorFeeTreasury Treasury address to receive the fees\n     * @param rewardsDistributor RewardsDistributor contract address\n     */\n    function initialize(\n        address asset_,\n        address fortaStaking,\n        address redemptionReceiverImplementation,\n        address inactiveSharesDistributorImplementation,\n        uint256 operatorFeeInBasisPoints,\n        address operatorFeeTreasury,\n        address rewardsDistributor\n    )\n        public\n        initializer\n    {\n        __ERC20_init_unchained(\"FORT Staking Vault\", \"vFORT\");\n        __ERC4626_init_unchained(IERC20(asset_));\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(OPERATOR_ROLE, msg.sender);\n        _staking = IFortaStaking(fortaStaking);\n        _token = IERC20(asset_);\n        _receiverImplementation = redemptionReceiverImplementation;\n        _distributorImplementation = inactiveSharesDistributorImplementation;\n        _rewardsDistributor = IRewardsDistributor(rewardsDistributor);\n        feeInBasisPoints = operatorFeeInBasisPoints;\n        feeTreasury = operatorFeeTreasury;\n    }\n\n    /**\n     * @inheritdoc ERC1155HolderUpgradeable\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155HolderUpgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @notice Updates the known assets in the different subjects\n     * @dev Needed to ensure the _totalAssets are correct and shares\n     * distributed correctly\n     */\n    function _updatePoolsAssets() private {\n        for (uint256 i = 0; i < subjects.length; ++i) {\n            _updatePoolAssets(subjects[i]);\n        }\n    }\n\n    /**\n     * @notice Updates the amount of assets delegated to a subject\n     * @param subject Subject to update the amount of assets\n     */\n    function _updatePoolAssets(uint256 subject) private {\n        uint256 activeId = FortaStakingUtils.subjectToActive(DELEGATOR_SCANNER_POOL_SUBJECT, subject);\n        uint256 inactiveId = FortaStakingUtils.activeToInactive(activeId);\n\n        uint256 assets = _staking.activeSharesToStake(activeId, _staking.balanceOf(address(this), activeId));\n\n        if (_subjectDeadline[subject] != 0) {\n            assets += _staking.inactiveSharesToStake(\n                inactiveId,\n                IERC20(_inactiveSharesDistributors[_subjectInactiveSharesDistributorIndex[subject]]).balanceOf(\n                    address(this)\n                )\n            );\n        }\n\n        if (_assetsPerSubject[subject] != assets) {\n            _totalAssets = _totalAssets - _assetsPerSubject[subject] + assets;\n            _assetsPerSubject[subject] = assets;\n        }\n    }\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     * @dev Overrided because assets are moved out of the vault\n     */\n    function totalAssets() public view override returns (uint256) {\n        return _totalAssets;\n    }\n\n    /**\n     * @notice Claim rewards associated to a subject\n     * @param subjectId Subject to claim rewards from\n     * @param epochNumber Epoch where the rewards were generated\n     * @dev meant to be called by a relayer (i.e OZ Defender)\n     */\n    function claimRewards(uint256 subjectId, uint256 epochNumber) public {\n        uint256[] memory epochs = new uint256[](1);\n        epochs[0] = epochNumber;\n        _rewardsDistributor.claimRewards(DELEGATOR_SCANNER_POOL_SUBJECT, subjectId, epochs);\n    }\n\n    //// Operator functions ////\n\n    /**\n     * @notice Checks that the caller is the OPERATOR_ROLE\n     */\n    function _validateIsOperator() private view {\n        if (!hasRole(OPERATOR_ROLE, msg.sender)) {\n            revert NotOperator();\n        }\n    }\n\n    /**\n     * @notice Delegate FORT in the vault to a subject\n     * @param subject Subject to delegate assets to\n     * @param assets Amount of assets to delegate\n     */\n    function delegate(uint256 subject, uint256 assets) public {\n        _validateIsOperator();\n\n        if (_assetsPerSubject[subject] == 0) {\n            _subjectIndex[subject] = subjects.length;\n            subjects.push(subject);\n        }\n        _token.approve(address(_staking), assets);\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _staking.deposit(DELEGATOR_SCANNER_POOL_SUBJECT, subject, assets);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n        // get the exact amount delivered to the pool\n        _assetsPerSubject[subject] += (balanceBefore - balanceAfter);\n    }\n\n    /**\n     * @notice Initiate an undelegation from a subject\n     * @param subject Subject to undelegate assets from\n     * @param shares Amount of shares to undelegate\n     * @dev generated a new contract to simulate a pool given\n     * that inactiveShares are not transferrable\n     */\n    function initiateUndelegate(uint256 subject, uint256 shares) public returns (uint256, address) {\n        _validateIsOperator();\n\n        if (_subjectDeadline[subject] != 0) {\n            // can generate extra delays for users\n            revert PendingUndelegation();\n        }\n\n        InactiveSharesDistributor distributor = InactiveSharesDistributor(_distributorImplementation.clone());\n        _staking.safeTransferFrom(\n            address(this),\n            address(distributor),\n            FortaStakingUtils.subjectToActive(DELEGATOR_SCANNER_POOL_SUBJECT, subject),\n            shares,\n            \"\"\n        );\n        distributor.initialize(_staking, _token, subject, shares);\n\n        _subjectInactiveSharesDistributorIndex[subject] = _inactiveSharesDistributors.length;\n        _inactiveSharesDistributors.push(address(distributor));\n        _distributorSubject[address(distributor)] = subject;\n        uint256 deadline = distributor.initiateUndelegate();\n        _subjectDeadline[subject] = deadline;\n        return (deadline, address(distributor));\n    }\n\n    /**\n     * @notice Finish an undelegation from a subject\n     * @param subject Subject being undelegate\n     * @dev vault receives the portion of undelegated assets\n     * not redeemed by users\n     */\n    function undelegate(uint256 subject) public {\n        _updatePoolAssets(subject);\n\n        if (\n            (_subjectDeadline[subject] == 0) || (_subjectDeadline[subject] > block.timestamp)\n                || _staking.isFrozen(DELEGATOR_SCANNER_POOL_SUBJECT, subject)\n        ) {\n            revert InvalidUndelegation();\n        }\n\n        uint256 distributorIndex = _subjectInactiveSharesDistributorIndex[subject];\n        InactiveSharesDistributor distributor = InactiveSharesDistributor(_inactiveSharesDistributors[distributorIndex]);\n\n        uint256 beforeWithdrawBalance = _token.balanceOf(address(this));\n        distributor.undelegate();\n        uint256 afterWithdrawBalance = _token.balanceOf(address(this));\n\n        // remove _inactiveSharesDistributors\n        address lastDistributor = _inactiveSharesDistributors[_inactiveSharesDistributors.length - 1];\n        _inactiveSharesDistributors[distributorIndex] = lastDistributor;\n        _subjectInactiveSharesDistributorIndex[_distributorSubject[lastDistributor]] = distributorIndex;\n        _inactiveSharesDistributors.pop();\n        delete _subjectDeadline[subject];\n        delete _distributorSubject[address(distributor)];\n        delete _subjectInactiveSharesDistributorIndex[subject];\n\n        _assetsPerSubject[subject] -= (afterWithdrawBalance - beforeWithdrawBalance);\n\n        //slither-disable-next-line incorrect-equality\n        if (_assetsPerSubject[subject] == 0) {\n            uint256 index = _subjectIndex[subject];\n            subjects[index] = subjects[subjects.length - 1];\n            _subjectIndex[subjects[index]] = index;\n            subjects.pop();\n            delete _subjectIndex[subject];\n        }\n    }\n\n    //// User operations ////\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        _updatePoolsAssets();\n\n        uint256 beforeDepositBalance = _token.balanceOf(address(this));\n        uint256 shares = super.deposit(assets, receiver);\n        uint256 afterDepositBalance = _token.balanceOf(address(this));\n\n        _totalAssets += afterDepositBalance - beforeDepositBalance;\n\n        return shares;\n    }\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     * @dev Assets in the pool are redeemed inmediatly\n     * @dev New contract is crated per user so the redemptions\n     * don't share the same delay in the FortaStaking contract\n     */\n    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256) {\n        _updatePoolsAssets();\n\n        if (msg.sender != owner) {\n            // caller needs to be allowed\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        // user redemption contract\n        RedemptionReceiver redemptionReceiver = RedemptionReceiver(createAndGetRedemptionReceiver(owner));\n\n        {\n            // Active shares redemption\n            uint256 newUndelegations;\n            uint256[] memory tempSharesToUndelegate = new uint256[](subjects.length);\n            uint256[] memory tempSubjectsToUndelegateFrom = new uint256[](subjects.length);\n\n            for (uint256 i = 0; i < subjects.length; ++i) {\n                uint256 subject = subjects[i];\n                uint256 subjectShares = _staking.sharesOf(DELEGATOR_SCANNER_POOL_SUBJECT, subject, address(this));\n                uint256 sharesToUndelegateInSubject = Math.mulDiv(shares, subjectShares, totalSupply());\n                if (sharesToUndelegateInSubject != 0) {\n                    _staking.safeTransferFrom(\n                        address(this),\n                        address(redemptionReceiver),\n                        FortaStakingUtils.subjectToActive(DELEGATOR_SCANNER_POOL_SUBJECT, subject),\n                        sharesToUndelegateInSubject,\n                        \"\"\n                    );\n                    _updatePoolAssets(subject);\n                    tempSharesToUndelegate[newUndelegations] = sharesToUndelegateInSubject;\n                    tempSubjectsToUndelegateFrom[newUndelegations] = subject;\n                    ++newUndelegations;\n                }\n            }\n            uint256[] memory sharesToUndelegate = new uint256[](newUndelegations);\n            uint256[] memory subjectsToUndelegateFrom = new uint256[](newUndelegations);\n            for (uint256 i = 0; i < newUndelegations; ++i) {\n                sharesToUndelegate[i] = tempSharesToUndelegate[i];\n                subjectsToUndelegateFrom[i] = tempSubjectsToUndelegateFrom[i];\n            }\n            redemptionReceiver.addUndelegations(subjectsToUndelegateFrom, sharesToUndelegate);\n        }\n\n        {\n            // Inactive shares redemption\n            uint256 newUndelegations;\n            address[] memory tempDistributors = new address[](_inactiveSharesDistributors.length);\n\n            for (uint256 i = 0; i < _inactiveSharesDistributors.length; ++i) {\n                InactiveSharesDistributor distributor = InactiveSharesDistributor(_inactiveSharesDistributors[i]);\n                uint256 vaultShares = distributor.balanceOf(address(this));\n                uint256 sharesToUndelegateInDistributor = Math.mulDiv(shares, vaultShares, totalSupply());\n                if (sharesToUndelegateInDistributor != 0) {\n                    IERC20(distributor).safeTransfer(address(redemptionReceiver), sharesToUndelegateInDistributor);\n                    _updatePoolAssets(_distributorSubject[address(distributor)]);\n                    tempDistributors[newUndelegations] = address"
    }
  ]
}