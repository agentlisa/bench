{
  "Title": "[H-05] LOSS OF PRECISION RESULTING IN WRONG VALUE FOR PRICE RATIO",
  "Content": "\nThe project implements a price oracle in order to get the relative price between the pegged asset and the price of the original asset (example: stETH to ETH). If the ratio (the pegged asset divided by the original asset) is 1 the Token is pegged, otherwise is depegged.\n\nBelow is a code snippet from the [PegOracle.sol](https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/oracles/PegOracle.sol) function.\n\n     if (price1 > price2) {\n                nowPrice = (price2 * 10000) / price1;\n            } else {\n                nowPrice = (price1 * 10000) / price2;\n            }\n\n            int256 decimals10 = int256(10**(18 - priceFeed1.decimals()));\n            nowPrice = nowPrice * decimals10;\n\n            return (\n                roundID1,\n                nowPrice / 1000000,\n                startedAt1,\n                timeStamp1,\n                answeredInRound1\n            );\n        }\n\nTo fetch the ratio at any time, the `PegOracle.sol` performs some calculations; first the relative price is multiplied by 1e4 and then it returns the above calculation divided by 1e6.\n\nThe [Controller.sol](https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol) file makes an external call to the [PegOracle.sol](https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/oracles/PegOracle.sol) oracle to get the relative price. After, the value returned, it is multiplied by `10**(18-(priceFeed.decimals())` and the result represents the relative price between the two assets.\n\nThe result is converted to 18 decimal points in order to be compared with the Strike Price passed by the admin on `VaultFactory.sol`.\n\nDue to the fact that the first multiplication is first divided by `1e6` ([PegOracle.sol#L78)](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/oracles/PegOracle.sol#L78)( and then re-multiplied by `uint256 decimals = 10**(18-(priceFeed.decimals()));` ([Controller.sol#L299-L300](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L299-L300))  it leads to loss of precision. This behavior will make the relative price between the assets incorrect.\n\n### Proof of Concept\n\nBelow is a test that illustrates the above issue for various oracle pairs. The calculated ratio is compared against a modified version of an example of different price denominator, provided by [Chainlink](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination).\n\n    // SPDX-License-Identifier: MIT\n    pragma solidity 0.8.15;\n\n    import \"forge-std/Test.sol\";\n    import \"../lib/AggregatorV3Interface.sol\";\n\n    //run with: forge test --fork-url https://arb1.arbitrum.io/rpc -vv \n\n    contract PegOracle {\n\n        /***\n        @dev  for example: oracle1 would be stETH / USD, while oracle2 would be ETH / USD oracle\n        ***/\n        address public oracle1;\n        address public oracle2;\n\n        uint8 public decimals;\n\n        AggregatorV3Interface internal priceFeed1;\n        AggregatorV3Interface internal priceFeed2;\n\n        /** @notice Contract constructor\n          * @param _oracle1 First oracle address\n          * @param _oracle2 Second oracle address\n          */\n        constructor(address _oracle1, address _oracle2) {\n            require(_oracle1 != address(0), \"oracle1 cannot be the zero address\");\n            require(_oracle2 != address(0), \"oracle2 cannot be the zero address\");\n            require(_oracle1 != _oracle2, \"Cannot be same Oracle\");\n            priceFeed1 = AggregatorV3Interface(_oracle1);\n            priceFeed2 = AggregatorV3Interface(_oracle2);\n            require(\n                (priceFeed1.decimals() == priceFeed2.decimals()),\n                \"Decimals must be the same\"\n            );\n\n            oracle1 = _oracle1;\n            oracle2 = _oracle2;\n\n            decimals = priceFeed1.decimals();\n        }\n\n        /** @notice Returns oracle-fed data from the latest round\n          * @return roundID Current round id \n          * @return nowPrice Current price\n          * @return startedAt Starting timestamp\n          * @return timeStamp Current timestamp\n          * @return answeredInRound Round id for which answer was computed \n          */ \n        function latestRoundData()\n            public\n            view\n            returns (\n                uint80 roundID,\n                int256 nowPrice,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            )\n        {\n            (\n                uint80 roundID1,\n                int256 price1,\n                uint256 startedAt1,\n                uint256 timeStamp1,\n                uint80 answeredInRound1\n            ) = priceFeed1.latestRoundData();\n\n            int256 price2 = getOracle2_Price();\n\n            if (price1 > price2) {\n                nowPrice = (price2 * 10000) / price1;\n            } else {\n                nowPrice = (price1 * 10000) / price2;\n            }\n\n            int256 decimals10 = int256(10**(18 - priceFeed1.decimals()));\n            nowPrice = nowPrice * decimals10;\n\n            return (\n                roundID1,\n                nowPrice / 1000000, //1000000,\n                startedAt1,\n                timeStamp1,\n                answeredInRound1\n            );\n        }\n\n        /* solhint-disbable-next-line func-name-mixedcase */\n        /** @notice Lookup first oracle price\n          * @return price Current first oracle price\n          */ \n        function getOracle1_Price() public view returns (int256 price) {\n            (\n                uint80 roundID1,\n                int256 price1,\n                ,\n                uint256 timeStamp1,\n                uint80 answeredInRound1\n            ) = priceFeed1.latestRoundData();\n\n            require(price1 > 0, \"Chainlink price <= 0\");\n            require(\n                answeredInRound1 >= roundID1,\n                \"RoundID from Oracle is outdated!\"\n            );\n            require(timeStamp1 != 0, \"Timestamp == 0 !\");\n\n            return price1;\n        }\n\n        /* solhint-disbable-next-line func-name-mixedcase */\n        /** @notice Lookup second oracle price\n          * @return price Current second oracle price\n          */ \n        function getOracle2_Price() public view returns (int256 price) {\n            (\n                uint80 roundID2,\n                int256 price2,\n                ,\n                uint256 timeStamp2,\n                uint80 answeredInRound2\n            ) = priceFeed2.latestRoundData();\n\n            require(price2 > 0, \"Chainlink price <= 0\");\n            require(\n                answeredInRound2 >= roundID2,\n                \"RoundID from Oracle is outdated!\"\n            );\n            require(timeStamp2 != 0, \"Timestamp == 0 !\");\n\n            return price2;\n        }\n        \n        function latestRoundData2()\n            public\n            view\n            returns (\n                uint80 roundID,\n                int256 nowPrice,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            )\n        {\n            (\n                uint80 roundID1,\n                int256 price1,\n                uint256 startedAt1,\n                uint256 timeStamp1,\n                uint80 answeredInRound1\n            ) = priceFeed1.latestRoundData();\n\n            price1 = scalePriceTo18(price1, priceFeed1.decimals());\n\n            int256 price2 = scalePriceTo18(getOracle2_Price(), priceFeed1.decimals());\n\n\n            return (\n                roundID1,\n                price1  * 1e18 / price2, \n                startedAt1,\n                timeStamp1,\n                answeredInRound1\n            );\n        }\n\n\n    function scalePriceTo18(int256 _price, uint8 _priceDecimals)\n            internal\n            pure\n            returns (int256)\n        {\n            if (_priceDecimals < 18) {\n                return _price * int256(10 ** uint256(18 - _priceDecimals));\n            } else if (_priceDecimals > 18) {\n                return _price * int256(10 ** uint256(_priceDecimals - 18));\n            }\n            return _price;\n        }\n    } \n\n\n\n\n    contract TestOracles is Test {\n        address WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n\n        address tokenFRAX = 0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F;\n        address tokenMIM = 0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A;\n        address tokenFEI = 0x4A717522566C7A09FD2774cceDC5A8c43C5F9FD2;\n        address tokenUSDC = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;\n        address tokenDAI = 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1;\n        address tokenSTETH = 0xEfa0dB536d2c8089685630fafe88CF7805966FC3;\n\n        address oracleFRAX = 0x0809E3d38d1B4214958faf06D8b1B1a2b73f2ab8;\n        address oracleMIM = 0x87121F6c9A9F6E90E59591E4Cf4804873f54A95b;\n        address oracleFEI = 0x7c4720086E6feb755dab542c46DE4f728E88304d;\n        address oracleUSDC = 0x50834F3163758fcC1Df9973b6e91f0F0F0434aD3;\n        address oracleDAI = 0xc5C8E77B397E531B8EC06BFb0048328B30E9eCfB;\n        address oracleSTETH = 0x07C5b924399cc23c24a95c8743DE4006a32b7f2a;\n        address oracleETH = 0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612;\n        address btcEthOracle = 0xc5a90A6d7e4Af242dA238FFe279e9f2BA0c64B2e;\n\n        PegOracle pegOracle = new PegOracle(oracleSTETH, oracleETH);\n        PegOracle pegOracle2 = new PegOracle(oracleFRAX, oracleFEI);\n        PegOracle pegOracle3 = new PegOracle(oracleDAI, oracleFEI);\n\n        function setUp() public {}\n\n        function convertBasedOnContractsLogic(int256 price, uint8 oracleDecimals) public returns(int256 newPrice){\n            uint256 decimals = 10**(18- oracleDecimals );\n            int256 newPrice = price * int256(decimals);\n            return newPrice;\n        }\n\n        function testOraclePrices() public {\n            (, int256 var1 ,,,) = pegOracle.latestRoundData();\n            emit log_int(convertBasedOnContractsLogic(var1, pegOracle.decimals()));\n\n            (, int256 var2 ,,,) = pegOracle.latestRoundData2();\n            emit log_int(var2);\n\n            (, int256 var3 ,,,) = pegOracle2.latestRoundData();\n            emit log_int(convertBasedOnContractsLogic(var3, pegOracle2.decimals()));\n\n            (, int256 var4 ,,,) = pegOracle2.latestRoundData2();\n            emit log_int(var4);\n\n\n            (, int256 var5 ,,,) = pegOracle3.latestRoundData();\n            emit log_int(convertBasedOnContractsLogic(var5, pegOracle3.decimals()));\n\n            (, int256 var6 ,,,) = pegOracle3.latestRoundData2();\n            emit log_int(var6);\n        }\n\n    }\n\nHere is the output after running the with: ` forge test --fork-url https://arb1.arbitrum.io/rpc -vv  `:\n990500000000000000\n990544616614592905\n\n996300000000000000\n1003669952945847834\n\n996000000000000000\n1003940775578783463\n\n### Recommended Mitigation Steps\n\nSince the 2 assets are required to having the same amount of decimals a formula that transforms the relative price to 1e18 could be:\n`x * 1e18 / y` .\n\nAn example that Chainlink implements, that includes a `scalePrice` function, in order to find a different price denominator could be found [here](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination).\n\n**[MiguelBits (Y2K Finance) acknowledged](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/323)** \n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/323#issuecomment-1280944745):**\n > Agree with the issue; the precision loss may be the decisive factor between whether a depeg is ruled to have happened. Since the core functionality and user funds are at stake, the high severity is appropriate here.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-y2k-finance-contest",
  "Code": [
    {
      "filename": "src/oracles/PegOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\n\ncontract PegOracle {\n    /***\n    @dev  for example: oracle1 would be stETH / USD, while oracle2 would be ETH / USD oracle\n    ***/\n    address public oracle1;\n    address public oracle2;\n\n    uint8 public decimals;\n\n    AggregatorV3Interface internal priceFeed1;\n    AggregatorV3Interface internal priceFeed2;\n\n    /** @notice Contract constructor\n      * @param _oracle1 First oracle address\n      * @param _oracle2 Second oracle address\n      */\n    constructor(address _oracle1, address _oracle2) {\n        require(_oracle1 != address(0), \"oracle1 cannot be the zero address\");\n        require(_oracle2 != address(0), \"oracle2 cannot be the zero address\");\n        require(_oracle1 != _oracle2, \"Cannot be same Oracle\");\n        priceFeed1 = AggregatorV3Interface(_oracle1);\n        priceFeed2 = AggregatorV3Interface(_oracle2);\n        require(\n            (priceFeed1.decimals() == priceFeed2.decimals()),\n            \"Decimals must be the same\"\n        );\n\n        oracle1 = _oracle1;\n        oracle2 = _oracle2;\n\n        decimals = priceFeed1.decimals();\n    }\n\n    /** @notice Returns oracle-fed data from the latest round\n      * @return roundID Current round id \n      * @return nowPrice Current price\n      * @return startedAt Starting timestamp\n      * @return timeStamp Current timestamp\n      * @return answeredInRound Round id for which answer was computed \n      */ \n    function latestRoundData()\n        public\n        view\n        returns (\n            uint80 roundID,\n            int256 nowPrice,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        )\n    {\n        (\n            uint80 roundID1,\n            int256 price1,\n            uint256 startedAt1,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        int256 price2 = getOracle2_Price();\n\n        if (price1 > price2) {\n            nowPrice = (price2 * 10000) / price1;\n        } else {\n            nowPrice = (price1 * 10000) / price2;\n        }\n\n        int256 decimals10 = int256(10**(18 - priceFeed1.decimals()));\n        nowPrice = nowPrice * decimals10;\n\n        return (\n            roundID1,\n            nowPrice / 1000000,\n            startedAt1,\n            timeStamp1,\n            answeredInRound1\n        );\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup first oracle price\n      * @return price Current first oracle price\n      */ \n    function getOracle1_Price() public view returns (int256 price) {\n        (\n            uint80 roundID1,\n            int256 price1,\n            ,\n            uint256 timeStamp1,\n            uint80 answeredInRound1\n        ) = priceFeed1.latestRoundData();\n\n        require(price1 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound1 >= roundID1,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp1 != 0, \"Timestamp == 0 !\");\n\n        return price1;\n    }\n\n    /* solhint-disbable-next-line func-name-mixedcase */\n    /** @notice Lookup second oracle price\n      * @return price Current second oracle price\n      */ \n    function getOracle2_Price() public view returns (int256 price) {\n        (\n            uint80 roundID2,\n            int256 price2,\n            ,\n            uint256 timeStamp2,\n            uint80 answeredInRound2\n        ) = priceFeed2.latestRoundData();\n\n        require(price2 > 0, \"Chainlink price <= 0\");\n        require(\n            answeredInRound2 >= roundID2,\n            \"RoundID from Oracle is outdated!\"\n        );\n        require(timeStamp2 != 0, \"Timestamp == 0 !\");\n\n        return price2;\n    }\n}"
    }
  ]
}