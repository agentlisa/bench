{
  "Title": "Protocol's invariants can be broken",
  "Content": "**Description:** The protocol intends to provide a generalized framework for constant-function AMM liquidity pools.\nWe have identified some invariants that should hold at any given time. One of these invariants is `totalSupply() == calcLpTokenSupply(reserves)`, and we can interpret this as the pool's total LP supply should match the calculation of LP from the current `reserves` state values.\n\nThis invariant can be broken with valid transactions in the current implementation, leading to several problems. For example, valid liquidity removal might revert, as shown in the PoC test below.\n\n**Impact:** The impact is HIGH because this discrepancy will lead to protocol insolvency (revert on valid transactions).\n\n**Proof of Concept:**\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IERC20} from \"test/TestHelper.sol\";\nimport {IWellFunction} from \"src/functions/ConstantProduct2.sol\";\nimport {LiquidityHelper} from \"test/LiquidityHelper.sol\";\nimport \"forge-std/Test.sol\";\nimport {MockToken} from \"mocks/tokens/MockToken.sol\";\n\ncontract GetRemoveLiquidityOneTokenOutArithmeticFail is LiquidityHelper {\n    function setUp() public {\n        setupWell(2);\n    }\n\n    address internal constant ADDRESS_0 = 0x0000000000000000000000000000000000001908;\n    address internal constant ADDRESS_1 = 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE;\n    address internal constant ADDRESS_2 = 0x0000000000000000000000000000000000000001;\n    address internal constant ADDRESS_3 = 0x00000011EF7b76c418fC426B8707dC60c8404f4a;\n\n    // Failing unit tests from invariant results\n    function test_getRemoveLiquidityOneTokenOutArithmeticFail() public {\n        showStatus();\n\n        address msgSender = ADDRESS_0;\n        _addLiquidity(msgSender, 77_470_052_844_788_801_811_950_156_551, 17_435);\n        _removeLiquidityOneTokenOut(msgSender, 5267, 0);\n        showStatus();\n\n        msgSender = ADDRESS_1;\n        _addLiquidity(msgSender, 79_228_162_514_264_337_593_543_950_335, 0);\n        _removeLiquidity(msgSender, 2_025_932_259_663_320_959_193_637_370_794);\n        showStatus();\n\n        msgSender = ADDRESS_2;\n        _addLiquidity(msgSender, 69_069_904_726_099_247_337_000_262_288, 3);\n        showStatus();\n\n        msgSender = ADDRESS_1;\n        _transferLp(msgSender, ADDRESS_3, 1_690_276_116_468_540_706_301_324_542_928);\n        emit log_named_uint(\"LP Balance (1)\", well.balanceOf(ADDRESS_1));\n        emit log_named_uint(\"LP Balance (3)\", well.balanceOf(ADDRESS_3));\n        showStatus();\n\n        msgSender = ADDRESS_0;\n        emit log_string(\"removeLiquidity\");\n        _removeLiquidity(msgSender, 122_797_404_990_851_137_316_041_024_188);\n        showStatus();\n\n        msgSender = ADDRESS_3;\n        emit log_string(\"removeLiquidityOneToken\");\n        _removeLiquidityOneTokenOut(msgSender, 1_690_276_116_468_540_706_301_000_000_000, 1);\n        emit log_named_uint(\"LP Balance (3)\", well.balanceOf(ADDRESS_3));\n        showStatus();\n        // The next line fails with an under/overflow error\n        //\n        // CONTEXT: In the previous operation, ADDRESS_3 removes the vast majority of his LP position\n        // for token[1]. At this point the token balances of the well are as follows:\n        //  * token[0].balanceOf(well) = 198508852592404865716451834587\n        //  * token[1].balanceOf(well) =          625986797429655048967\n        // The next operation ADDRESS_3 calls is removeLiquidityOneTokenOut() for token[0] using his\n        // remaining LP position. The amount of LP tokens he has left is 3. Line 526 reverts with underflow,\n        // despite all operations being completely valid. How severe is this?\n        _removeLiquidityOneTokenOut(msgSender, 324_542_928, 0);\n        showStatus();\n    }\n\n    function test_audit() public {\n        address msgSender = address(this);\n        _removeLiquidityOneTokenOut(msgSender, 1e16, 0);\n        _removeLiquidity(msgSender, well.balanceOf(msgSender) - 1);\n        _removeLiquidity(msgSender, 1);\n    }\n\n    function test_totalSupplyInvariantSwapFail() public {\n        address msgSender = 0x576024f76bd1640d7399a5B5F61530f997Ae06f2;\n        changePrank(msgSender);\n        IERC20[] memory mockTokens = well.tokens();\n        uint tokenInIndex = 0;\n        uint tokenOutIndex = 1;\n        uint tokenInAmount = 52_900_000_000_000_000_000;\n        MockToken(address(mockTokens[tokenInIndex])).mint(msgSender, tokenInAmount);\n        mockTokens[tokenInIndex].approve(address(well), tokenInAmount);\n        uint minAmountOut = well.getSwapOut(mockTokens[tokenInIndex], mockTokens[tokenOutIndex], tokenInAmount);\n        well.swapFrom(\n            mockTokens[tokenInIndex], mockTokens[tokenOutIndex], tokenInAmount, minAmountOut, msgSender, block.timestamp\n        );\n        // check the total supply\n        uint functionCalc =\n            IWellFunction(well.wellFunction().target).calcLpTokenSupply(well.getReserves(), well.wellFunction().data);\n        // assertEq(well.totalSupply(), functionCalc);\n        showStatus();\n    }\n\n    function _transferLp(address msgSender, address to, uint amount) private {\n        changePrank(msgSender);\n        well.transfer(to, amount);\n    }\n\n    function _removeLiquidityOneTokenOut(\n        address msgSender,\n        uint lpAmountIn,\n        uint tokenIndex\n    ) private returns (uint tokenAmountOut) {\n        changePrank(msgSender);\n        IERC20[] memory mockTokens = well.tokens();\n        uint minTokenAmountOut = well.getRemoveLiquidityOneTokenOut(lpAmountIn, mockTokens[tokenIndex]);\n        tokenAmountOut = well.removeLiquidityOneToken(\n            lpAmountIn, mockTokens[tokenIndex], minTokenAmountOut, msgSender, block.timestamp\n        );\n    }\n\n    function _removeLiquidity(address msgSender, uint lpAmountIn) private returns (uint[] memory tokenAmountsOut) {\n        changePrank(msgSender);\n        uint[] memory minTokenAmountsOut = well.getRemoveLiquidityOut(lpAmountIn);\n        tokenAmountsOut = well.removeLiquidity(lpAmountIn, minTokenAmountsOut, msgSender, block.timestamp);\n    }\n\n    function _addLiquidity(\n        address msgSender,\n        uint token0Amount,\n        uint token1Amount\n    ) private returns (uint lpAmountOut) {\n        changePrank(msgSender);\n        uint[] memory tokenAmountsIn = _mintToSender(msgSender, token0Amount, token1Amount);\n        uint minLpAmountOut = well.getAddLiquidityOut(tokenAmountsIn);\n\n        lpAmountOut = well.addLiquidity(tokenAmountsIn, minLpAmountOut, msgSender, block.timestamp);\n    }\n\n    function _mintToSender(\n        address msgSender,\n        uint token0Amount,\n        uint token1Amount\n    ) private returns (uint[] memory tokenAmountsIn) {\n        changePrank(msgSender);\n        IERC20[] memory mockTokens = well.tokens();\n        MockToken(address(mockTokens[0])).mint(msgSender, token0Amount);\n        MockToken(address(mockTokens[1])).mint(msgSender, token1Amount);\n\n        tokenAmountsIn = new uint[](2);\n        tokenAmountsIn[0] = token0Amount;\n        tokenAmountsIn[1] = token1Amount;\n\n        mockTokens[0].approve(address(well), token0Amount);\n        mockTokens[1].approve(address(well), token1Amount);\n    }\n\n    function showStatus() public {\n        IERC20[] memory mockTokens = well.tokens();\n        uint[] memory reserves = well.getReserves();\n\n        uint calcedSupply = IWellFunction(well.wellFunction().target).calcLpTokenSupply(well.getReserves(), well.wellFunction().data);\n        emit log_named_uint(\"Total  LP Supply\", well.totalSupply());\n        emit log_named_uint(\"Calced LP Supply\", calcedSupply);\n    }\n}\n```\n\nThe test results are shown below.\n\n```\nRunning 1 test for test/invariant/RemoveOneLiquidity.t.sol:GetRemoveLiquidityOneTokenOutArithmeticFail\n[FAIL. Reason: Arithmetic over/underflow] test_getRemoveLiquidityOneTokenOutArithmeticFail() (gas: 1029158)\nLogs:\n  Total  LP Supply: 1000000000000000000000000000\n  Calced LP Supply: 1000000000000000000000000000\n  Total  LP Supply: 8801707439172742871919189288925\n  Calced LP Supply: 8801707439172742871919189288909\n  Total  LP Supply: 10491983555641283578220513831854\n  Calced LP Supply: 10491983555641283578222260432821\n  Total  LP Supply: 12960446346289240477619201802843\n  Calced LP Supply: 12960446346289240477619201802843\n  LP Balance (1): 1\n  LP Balance (3): 1690276116468540706301324542928\n  Total  LP Supply: 12960446346289240477619201802843\n  Calced LP Supply: 12960446346289240477619201802843\n  removeLiquidity\n  Total  LP Supply: 12837648941298389340303160778655\n  Calced LP Supply: 12837648941298389340310429464350\n  removeLiquidityOneToken\n  LP Balance (3): 324542928\n  Total  LP Supply: 11147372824829848634002160778655\n  Calced LP Supply: 11147372824829848633998681214926\n\nTest result: FAILED. 0 passed; 1 failed; finished in 3.70ms\n\nFailing tests:\nEncountered 1 failing test in test/invariant/RemoveOneLiquidity.t.sol:GetRemoveLiquidityOneTokenOutArithmeticFail\n[FAIL. Reason: Arithmetic over/underflow] test_getRemoveLiquidityOneTokenOutArithmeticFail() (gas: 1029158)\n\nEncountered a total of 1 failing tests, 0 tests succeeded\n```\n\nLooking into this, the `ConstantProduct2`, we see three problems:\n\n1. No rounding direction is specified in the functions `calcReserve` and `calcLpTokenSupply`. These Well functions are used in critical places where the Well's state (reserve, LP) will change. Mathematical discrepancies should be rounded in favor of the protocol; however, no rounding direction is specified in the current implementation, which allows unfavorable transactions.\n\n   For example, in [Well::getSwapOut](https://github.com/BeanstalkFarms/Wells/blob/e5441fc78f0fd4b77a898812d0fd22cb43a0af55/src/Well.sol#L231) and [Well::\\_getRemoveLiquidityOneTokenOut](https://github.com/BeanstalkFarms/Wells/blob/e5441fc78f0fd4b77a898812d0fd22cb43a0af55/src/Well.sol#L519), the calculation of the output token amount is rounded up (downside rounded value is subtracted) while it should be rounded down. These unfavorable transactions will compound, affecting the health of the protocol.\n\n2. This invariant is not guaranteed after `Well::removeLiquidity`. The current implementation calculates the token output amount from the ratio of the `lpAmountIn` to the `totalSupply`, assuming that `calcLpTokenSupply([r0 * delta, r1 * delta]) = totalSupply() * delta` where `delta` denotes the ratio `1 - lpAmountIn/lpTokenSupply`. This is also mentioned separately in another issue, but we want to note again that ensuring the invariant holds after any transaction is essential. Handling the last token separately is recommended, similar to `Well::removeLiquidityOneToken`.\n\n3. It is practically almost impossible to make the invariant `totalSupply() == calcLpTokenSupply(reserves)` hold strictly. For this example, we will focus on the `Well::removeLiquidityOneToken` function because it is the simplest and most reasonable way to withdraw liquidity, and we will assume `ConstantProduct2` is the Well function. The mechanism is intuitive - the protocol burns the requested `lpAmountIn` and calculates the new reserve value for the requested `tokenOut` (`tokens[0]`) using the decreased LP token supply.\n\nLet us assume `totalSupply() == calcLpTokenSupply(reserves) == T0` before the transaction. After the transaction, the total supply will be `T0 - lpAmountIn`. The output token amount is calculated as `getRemoveLiquidityOneTokenOut(lpAmountIn, 0, reserves) = reserves[0] - calcReserve(reserves, 0, T0 - lpAmountIn)`. After the transaction, the calculated total supply will be `calcLpTokenSupply([calcReserve(reserves, 0, T0 - lpAmountIn), reserves[1]])`. For the invariant to hold after the transaction, the functions `ConstantProduct2::calcLpTokenSupply` and `ConstantProduct2::calcReserve` should exhibit an accurate inverse relationship (`calcLpTokenSupply(calcReserves(reserves, LP)) == LP`). In practice, all calculations come with rounding to some extent, and this relationship is not possible so long as the two functions are implemented separately.\n\n**Recommended Mitigation:**\n1. Add a rounding direction flag parameter to the `IWellFunction::calcReserve` and `IWellFunction::calcLpTokenSupply` functions. At all invocations of these functions, apply the correct rounding direction such that the transaction is processed favorably to the protocol.\n\n2. Handle the last token separately in `Well::removeLiquidity`. In `Well::getRemoveLiquidityOut`, calculate the output token amount for the first `n-1` tokens as usual but use an approach similar to `Well::getRemoveLiquidityOneTokenOut` for the last token. This will help to have the invariant hold. We understand that another finding suggested adding a dedicated function to calculate the output token amount at the `IWellFunction` level. If the issue is mitigated that way, consider adding another check to ensure the invariant holds.\n\n3. As we explained above, it is practically almost impossible to make the invariant `totalSupply() == calcLpTokenSupply(reserves)` hold strictly. We recommend a slightly looser invariant `totalSupply() >= calcLpTokenSupply(reserves)`, which can be interpreted as \"the Well function underestimates the LP supply\". Otherwise, we suggest adding another variable, `totalCalcSupply`, which will always reflect the calculated LP supply from the current `reserves`. This new variable can be used with `totalSupply()` together while deciding the output token amount. For example, in `Well::_getRemoveLiquidityOneTokenOut`, we can calculate `lpAmountInCalc = lpAmountIn * totalCalcSupply / totalSupply()` and use that in the function `_calcReserve`. This will be helpful because the discrepancy is reflected in the calculation.\n\nPlease note that `well.getReserves()[i] == wellFunction.calcReserve(i)` is also supposed to hold.\nBecause of the rounding in the calculation, we understand this invariant might be too strict and similar mitigation is recommended.\nBelow is a test to show that the above _invariant_ can be broken.\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IERC20} from \"test/TestHelper.sol\";\nimport {IWellFunction} from \"src/functions/ConstantProduct2.sol\";\nimport {LiquidityHelper} from \"test/LiquidityHelper.sol\";\nimport \"forge-std/Test.sol\";\nimport {MockToken} from \"mocks/tokens/MockToken.sol\";\n\ncontract ReservesMathFunctionCalcReservesFail is LiquidityHelper {\n    function setUp() public {\n        setupWell(2);\n    }\n\n    function testReservesMismatchFail() public {\n        // perform initial check\n        uint[] memory reserves = well.getReserves();\n\n        uint reserve0 =\n            IWellFunction(wellFunction.target).calcReserve(reserves, 0, well.totalSupply(), wellFunction.data);\n        uint reserve1 =\n            IWellFunction(wellFunction.target).calcReserve(reserves, 1, well.totalSupply(), wellFunction.data);\n\n        assertEq(reserves[0], reserve0);\n        assertEq(reserves[1], reserve1);\n\n        // swap\n        address msgSender = address(2);\n        changePrank(msgSender);\n        uint tokenInIndex = 0;\n        uint tokenOutIndex = 1;\n        uint amountIn = 59_534_739_918_926_377_591_512_171_513;\n\n        IERC20[] memory mockTokens = well.tokens();\n        MockToken(address(mockTokens[tokenInIndex])).mint(msgSender, amountIn);\n        // approve the well\n        mockTokens[tokenInIndex].approve(address(well), amountIn);\n        uint minAmountOut = well.getSwapOut(mockTokens[tokenInIndex], mockTokens[tokenOutIndex], amountIn);\n        well.swapFrom(\n            mockTokens[tokenInIndex], mockTokens[tokenOutIndex], amountIn, minAmountOut, msgSender, block.timestamp\n        );\n\n        // perform check again\n        reserves = well.getReserves();\n\n        reserve0 = IWellFunction(wellFunction.target).calcReserve(reserves, 0, well.totalSupply(), wellFunction.data);\n        reserve1 = IWellFunction(wellFunction.target).calcReserve(reserves, 1, well.totalSupply(), wellFunction.data);\n\n        assertEq(reserves[0], reserve0);\n        assertEq(reserves[1], reserve1);\n    }\n}\n\n```\n\n**Beanstalk:**\n1. `ConstantProduct2::_calcReserve` now rounds up instead of to the nearest number. `ConstantProduct2::_calcLpTokenSupply` still rounds down. The rationale is below. Fixed in commit [876da9a](https://github.com/BeanstalkFarms/Basin/pull/84/commits/876da9a8f0df4118a701299397b36065c8a92530).\n\n    No rounding mode is necessary because `calcReserve` and `calcLpTokenSupply` should round the same direction in all cases:\n\n    1. All instances of `calcReserve` should round up:\n        * All output `amountIn` values are calculated by subtracting `_calcReserve(...) - reserveBefore`. The Well wants to overestimate `amountIn` to guarantee more tokens on the margin are sent to the Well. Thus, `_calcReserve` should round up. (See `swapTo`)\n        * All output `amountOut` values are calculated by subtracting `reserveBefore - _calcReserve(...)`. The Well wants to underestimate `amountOut` so that less tokens are removed from the Well on the margin. Thus, `_calcReserve` should round up again. (See `swapFrom`, `shift`, `removeLiquidityOneToken`)\n    2. All instances of `calcLpTokenSupply` should round down:\n        * All `lpAmountIn` values are calculated by subtracting `totalSupply() - _calcLpTokenSupply(...)`. `lpAmountIn` should be overestimated and thus `_calcLpTokenSupply` should round down. (See `removeLiquidityImbalanced`)\n        * All `lpAmountOut` values are calculated by subtracting `_calcLpTokenSupply(...) - totalSupply()`.  `lpAmountOut` values should be underestimated and thus `_calcLpTokenSupply` should round down.\n\n    Given no rounding mode is necessary–It is in fact up to the corresponding Well Function to decide how to round. The above rounding methods are only a suggestion and each Well Function is free to round however it wants.\n\n2. The remediation for [H-03] added a `calcLPTokenUnderlying` function to `IWellFunction` to determine how much of each amount to remove when removing LP tokens. As a consequence, the Well Function itself now determines how many tokens to remove when LP is removed instead of the Well. Thus, the Well Function is free to define how to handle the `removeLiquidity` calculation and can ensure that it doesn't break its own defined invariant.\n\n    Documentation has been added [here](https://github.com/BeanstalkFarms/Basin/commit/39ea396b0e78762cbeeee4e3fe8e343c2e114259) to indicate that a valid implementation of `calcLPTokenUnderlying` should never break a Well's invariant.\n\n    Also, updated the `test_removeLiquidity_fuzz` test to include a check to test that the invariant holds after the `removeLiquidity` call [here](https://github.com/BeanstalkFarms/Basin/commit/f5d14eba5c9c7a02ed15eba675ed869916ea469d).\n\n    Given that users should verify that a Well has a valid Well Function before interacting with a Well and protocols using Wells should keep a list of verified Well Functions, adding a check would just serve as an extra precaution in the case that an invalid Well Function is verified.,\n\n    Adding the following check to `removeLiquidity`:\n\n    ```solidity\n    require(lpTokenSupply - lpAmountIn <= _calcLpTokenSupply(wellFunction(), reserves), \"Well Function Invalid\");\n    ```\n\n    increases the gas cost by 3,940. Given that the check only serves as an extra precaution, it doesn't seem like it is worth the extra gas cost to add. Therefore, the check has not been added.\n\n3. The invariant that the Well is maintaining is `_calcLpTokenSupply(...) >= totalSupply()`. In order words, the Well issues fewer Well LP Tokens at the margin. This is to ensure that Well LP Tokens at least maintain their underlying value and don’t get diluted.\n\n    In order to help verify this, a `checkInvariant` function has been added to `TestHelper` which reverts if the above invariant does not hold. The `checkInvariant` function has been added to the majority of tests including `swapFrom`, `swapTo`, `removeLiquidity`, `removeLiquidityImbalanced`, `removeLiquidityOneToken`, and `addLiquidity`. Added in commit [876da9a](https://github.com/BeanstalkFarms/Basin/pull/84/commits/876da9a8f0df4118a701299397b36065c8a92530).\n\n**Cyfrin:** Acknowledged and validated changes mitigate the original issue.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/Well.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {ReentrancyGuardUpgradeable} from \"ozu/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC20Upgradeable, ERC20PermitUpgradeable} from \"ozu/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {IERC20, SafeERC20} from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\nimport {IWell, Call} from \"src/interfaces/IWell.sol\";\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\nimport {LibBytes} from \"src/libraries/LibBytes.sol\";\nimport {ClonePlus} from \"src/utils/ClonePlus.sol\";\n\n/**\n * @title Well\n * @author Publius, Silo Chad, Brean\n * @dev A Well is a constant function AMM allowing the provisioning of liquidity\n * into a single pooled on-chain liquidity position.\n */\ncontract Well is ERC20PermitUpgradeable, IWell, ReentrancyGuardUpgradeable, ClonePlus {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint;\n\n    bytes32 constant RESERVES_STORAGE_SLOT = keccak256(\"reserves.storage.slot\");\n\n    function init(string memory name, string memory symbol) public initializer {\n        __ERC20Permit_init(name);\n        __ERC20_init(name, symbol);\n    }\n\n    //////////////////// WELL DEFINITION ////////////////////\n\n    /// This Well uses a dynamic immutable storage layout. Immutable storage is\n    /// used for gas-efficient reads during Well operation. The Well must be\n    /// created by cloning with a pre-encoded byte string containing immutable\n    /// data.\n    ///\n    /// Let n = number of tokens\n    ///     m = length of well function data (bytes)\n    ///\n    /// TYPE        NAME                       LOCATION (CONSTANT)\n    /// ==============================================================\n    /// address     aquifer()                  0        (LOC_AQUIFER_ADDR)\n    /// uint256     numberOfTokens()           20       (LOC_TOKENS_COUNT)\n    /// address     wellFunctionAddress()      52       (LOC_WELL_FUNCTION_ADDR)\n    /// uint256     wellFunctionDataLength()   72       (LOC_WELL_FUNCTION_DATA_LENGTH)\n    /// uint256     numberOfPumps()            104      (LOC_PUMPS_COUNT)\n    /// --------------------------------------------------------------\n    /// address     token0                     136      (LOC_VARIABLE)\n    /// ...\n    /// address     tokenN                     136 + (n-1) * 32\n    /// --------------------------------------------------------------\n    /// byte        wellFunctionData0          136 + n * 32\n    /// ...\n    /// byte        wellFunctionDataM          136 + n * 32 + m\n    /// --------------------------------------------------------------\n    /// address     pump1Address               136 + n * 32 + m\n    /// uint256     pump1DataLength            136 + n * 32 + m + 20\n    /// byte        pump1Data                  136 + n * 32 + m + 52\n    /// ...\n    /// ==============================================================\n\n    uint constant LOC_AQUIFER_ADDR = 0;\n    uint constant LOC_TOKENS_COUNT = LOC_AQUIFER_ADDR + 20;\n    uint constant LOC_WELL_FUNCTION_ADDR = LOC_TOKENS_COUNT + 32;\n    uint constant LOC_WELL_FUNCTION_DATA_LENGTH = LOC_WELL_FUNCTION_ADDR + 20;\n    uint constant LOC_PUMPS_COUNT = LOC_WELL_FUNCTION_DATA_LENGTH + 32;\n    uint constant LOC_VARIABLE = LOC_PUMPS_COUNT + 32;\n\n    function tokens() public pure returns (IERC20[] memory ts) {\n        ts = _getArgIERC20Array(LOC_VARIABLE, numberOfTokens());\n    }\n\n    function wellFunction() public pure returns (Call memory _wellFunction) {\n        _wellFunction.target = wellFunctionAddress();\n        uint dataLoc = LOC_VARIABLE + numberOfTokens() * 32;\n        _wellFunction.data = _getArgBytes(dataLoc, wellFunctionDataLength());\n    }\n\n    function pumps() public pure returns (Call[] memory _pumps) {\n        if (numberOfPumps() == 0) return _pumps;\n\n        _pumps = new Call[](numberOfPumps());\n        uint dataLoc = LOC_VARIABLE + numberOfTokens() * 32 + wellFunctionDataLength();\n\n        uint pumpDataLength;\n        for (uint i = 0; i < _pumps.length; i++) {\n            _pumps[i].target = _getArgAddress(dataLoc);\n            dataLoc += 20;\n            pumpDataLength = _getArgUint256(dataLoc);\n            dataLoc += 32;\n            _pumps[i].data = _getArgBytes(dataLoc, pumpDataLength);\n            dataLoc += pumpDataLength;\n        }\n    }\n\n    /**\n     * @dev {wellData} is unused in this implementation.\n     */\n    function wellData() public pure returns (bytes memory) {}\n\n    function aquifer() public pure override returns (address) {\n        return _getArgAddress(LOC_AQUIFER_ADDR);\n    }\n\n    function well()\n        external\n        pure\n        returns (\n            IERC20[] memory _tokens,\n            Call memory _wellFunction,\n            Call[] memory _pumps,\n            bytes memory _wellData,\n            address _aquifer\n        )\n    {\n        _tokens = tokens();\n        _wellFunction = wellFunction();\n        _pumps = pumps();\n        _aquifer = aquifer();\n    }\n\n    //////////////////// WELL DEFINITION: HELPERS ////////////////////\n\n    /**\n     * @notice Returns the number of tokens that are tradable in this Well.\n     * @dev Length of the `tokens()` array.\n     */\n    function numberOfTokens() public pure returns (uint) {\n        return _getArgUint256(LOC_TOKENS_COUNT);\n    }\n\n    /**\n     * @notice Returns the address of the Well Function.\n     */\n    function wellFunctionAddress() public pure returns (address) {\n        return _getArgAddress(LOC_WELL_FUNCTION_ADDR);\n    }\n\n    /**\n     * @notice Returns the length of the configurable `data` parameter passed during calls to the Well Function.\n     */\n    function wellFunctionDataLength() public pure returns (uint) {\n        return _getArgUint256(LOC_WELL_FUNCTION_DATA_LENGTH);\n    }\n\n    /**\n     * @notice Returns the number of Pumps which this Well was initialized with.\n     */\n    function numberOfPumps() public pure returns (uint) {\n        return _getArgUint256(LOC_PUMPS_COUNT);\n    }\n\n    /**\n     * @notice Returns address & data used to call the first Pump.\n     * @dev Provided as an optimization in the case where {numberOfPumps} returns 1.\n     */\n    function firstPump() public pure returns (Call memory _pump) {\n        uint dataLoc = LOC_VARIABLE + numberOfTokens() * 32 + wellFunctionDataLength();\n        _pump.target = _getArgAddress(dataLoc);\n        uint pumpDataLength = _getArgUint256(dataLoc + 20);\n        _pump.data = _getArgBytes(dataLoc + 52, pumpDataLength);\n    }\n\n    //////////////////// SWAP: FROM ////////////////////\n\n    /**\n     * @dev MUST revert if a fee on transfer token is used. The requisite check\n     * is performed in {_setReserves}.\n     */\n    function swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint amountOut) {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    /**\n     * @dev Note that `amountOut` is the amount *transferred* by the Well; if a fee\n     * is charged on transfers of `toToken`, the amount received by `recipient`\n     * will be less than `amountOut`.\n     */\n    function swapFromFeeOnTransfer(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint amountOut) {\n        amountIn = _safeTransferFromFeeOnTransfer(fromToken, msg.sender, amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    function _swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient\n    ) internal returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[i] += amountIn;\n        uint reserveJBefore = reserves[j];\n        reserves[j] = _calcReserve(wellFunction(), reserves, j, totalSupply());\n\n        // Note: The rounding approach of the Well function determines whether\n        // slippage from imprecision goes to the Well or to the User.\n        amountOut = reserveJBefore - reserves[j];\n        if (amountOut < minAmountOut) {\n            revert SlippageOut(amountOut, minAmountOut);\n        }\n\n        toToken.safeTransfer(recipient, amountOut);\n        emit Swap(fromToken, toToken, amountIn, amountOut, recipient);\n        _setReserves(_tokens, reserves);\n    }\n\n    /**\n     * @dev Assumes both tokens incur no fee on transfer.\n     */\n    function getSwapOut(IERC20 fromToken, IERC20 toToken, uint amountIn) external view returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[i] += amountIn;\n\n        // underflow is desired; Well Function SHOULD NOT increase reserves of both `i` and `j`\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n    }\n\n    //////////////////// SWAP: TO ////////////////////\n\n    /**\n     * @dev {swapTo} does not support fee on transfer tokens, and no corresponding\n     * \"swapToFeeOnTransfer\" function is provided as this would require either:\n     * (a) inclusion of the fee as a parameter with verification; or\n     * (b) iterative transfers which attempts to back-calculate the fee.\n     */\n    function swapTo(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint maxAmountIn,\n        uint amountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint amountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[j] -= amountOut;\n        uint reserveIBefore = reserves[i];\n        reserves[i] = _calcReserve(wellFunction(), reserves, i, totalSupply());\n\n        // Note: The rounding approach of the Well function determines whether\n        // slippage from imprecision goes to the Well or to the User.\n        amountIn = reserves[i] - reserveIBefore;\n\n        if (amountIn > maxAmountIn) {\n            revert SlippageIn(amountIn, maxAmountIn);\n        }\n\n        _swapTo(fromToken, toToken, amountIn, amountOut, recipient);\n        _setReserves(_tokens, reserves);\n    }\n\n    /**\n     * @dev Executes token transfers and emits Swap event. Used by {swapTo} to\n     * avoid stack too deep errors.\n     */\n    function _swapTo(IERC20 fromToken, IERC20 toToken, uint amountIn, uint amountOut, address recipient) internal {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        toToken.safeTransfer(recipient, amountOut);\n        emit Swap(fromToken, toToken, amountIn, amountOut, recipient);\n    }\n\n    /**\n     * @dev Assumes both tokens incur no fee on transfer.\n     */\n    function getSwapIn(IERC20 fromToken, IERC20 toToken, uint amountOut) external view returns (uint amountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[j] -= amountOut;\n\n        amountIn = _calcReserve(wellFunction(), reserves, i, totalSupply()) - reserves[i];\n    }\n\n    //////////////////// SHIFT ////////////////////\n\n    /**\n     * @dev When using Wells for a multi-step swap, gas costs can be reduced by\n     * \"shifting\" tokens from one Well to another rather than returning them to\n     * a router (like Pipeline).\n     *\n     * Example multi-hop swap: WETH -> DAI -> USDC\n     *\n     * 1. Using a router without {shift}:\n     *  WETH.transfer(sender=0xUSER, recipient=0xROUTER)                     [1]\n     *  Call the router, which performs:\n     *      Well1.swapFrom(fromToken=WETH, toToken=DAI, recipient=0xROUTER)\n     *          WETH.transfer(sender=0xROUTER, recipient=Well1)              [2]\n     *          DAI.transfer(sender=Well1, recipient=0xROUTER)               [3]\n     *      Well2.swapFrom(fromToken=DAI, toToken=USDC, recipient=0xROUTER)\n     *          DAI.transfer(sender=0xROUTER, recipient=Well2)               [4]\n     *          USDC.transfer(sender=Well2, recipient=0xROUTER)              [5]\n     *  USDC.transfer(sender=0xROUTER, recipient=0xUSER)                     [6]\n     *\n     *  Note: this could be optimized by configuring the router to deliver\n     *  tokens from the last swap directly to the user.\n     *\n     * 2. Using a router with {shift}:\n     *  WETH.transfer(sender=0xUSER, recipient=Well1)                        [1]\n     *  Call the router, which performs:\n     *      Well1.shift(tokenOut=DAI, recipient=Well2)\n     *          DAI.transfer(sender=Well1, recipient=Well2)                  [2]\n     *      Well2.shift(tokenOut=USDC, recipient=0xUSER)\n     *          USDC.transfer(sender=Well2, recipient=0xUSER)                [3]\n     */\n    function shift(\n        IERC20 tokenOut,\n        uint minAmountOut,\n        address recipient\n    ) external nonReentrant returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = new uint[](_tokens.length);\n\n        // Use the balances of the pool instead of the stored reserves.\n        // If there is a change in token balances relative to the currently\n        // stored reserves, the extra tokens can be shifted into `tokenOut`.\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n        uint j = _getJ(_tokens, tokenOut);\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n\n        if (amountOut >= minAmountOut) {\n            tokenOut.safeTransfer(recipient, amountOut);\n            reserves[j] -= amountOut;\n            _setReserves(_tokens, reserves);\n            emit Shift(reserves, tokenOut, amountOut, recipient);\n        } else {\n            revert SlippageOut(amountOut, minAmountOut);\n        }\n    }\n\n    function getShiftOut(IERC20 tokenOut) external view returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n\n        uint j = _getJ(_tokens, tokenOut);\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n    }\n\n    //////////////////// ADD LIQUIDITY ////////////////////\n\n    function addLiquidity(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint lpAmountOut) {\n        lpAmountOut = _addLiquidity(tokenAmountsIn, minLpAmountOut, recipient, false);\n    }\n\n    function addLiquidityFeeOnTransfer(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint lpAmountOut) {\n        lpAmountOut = _addLiquidity(tokenAmountsIn, minLpAmountOut, recipient, true);\n    }\n\n    /**\n     * @dev Gas optimization: {IWell.AddLiquidity} is emitted even if `lpAmountOut` is 0.\n     */\n    function _addLiquidity(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        bool feeOnTransfer\n    ) internal returns (uint lpAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n\n        if (feeOnTransfer) {\n            for (uint i; i < _tokens.length; ++i) {\n                if (tokenAmountsIn[i] == 0) continue;\n                tokenAmountsIn[i] = _safeTransferFromFeeOnTransfer(_tokens[i], msg.sender, tokenAmountsIn[i]);\n                reserves[i] = reserves[i] + tokenAmountsIn[i];\n            }\n        } else {\n            for (uint i; i < _tokens.length; ++i) {\n                if (tokenAmountsIn[i] == 0) continue;\n                _tokens[i].safeTransferFrom(msg.sender, address(this), tokenAmountsIn[i]);\n                reserves[i] = reserves[i] + tokenAmountsIn[i];\n            }\n        }\n\n        lpAmountOut = _calcLpTokenSupply(wellFunction(), reserves) - totalSupply();\n        if (lpAmountOut < minLpAmountOut) {\n            revert SlippageOut(lpAmountOut, minLpAmountOut);\n        }\n\n        _mint(recipient, lpAmountOut);\n        _setReserves(_tokens, reserves);\n        emit AddLiquidity(tokenAmountsIn, lpAmountOut, recipient);\n    }\n\n    /**\n     * @dev Assumes that no tokens involved incur a fee on transfer.\n     */\n    function getAddLiquidityOut(uint[] memory tokenAmountsIn) external view returns (uint lpAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = reserves[i] + tokenAmountsIn[i];\n        }\n        lpAmountOut = _calcLpTokenSupply(wellFunction(), reserves) - totalSupply();\n    }\n\n    //////////////////// REMOVE LIQUIDITY: BALANCED ////////////////////\n\n    function removeLiquidity(\n        uint lpAmountIn,\n        uint[] calldata minTokenAmountsOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint[] memory tokenAmountsOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        uint lpTokenSupply = totalSupply();\n\n        tokenAmountsOut = new uint[](_tokens.length);\n        _burn(msg.sender, lpAmountIn);\n        for (uint i; i < _tokens.length; ++i) {\n            tokenAmountsOut[i] = (lpAmountIn * reserves[i]) / lpTokenSupply;\n            if (tokenAmountsOut[i] < minTokenAmountsOut[i]) {\n                revert SlippageOut(tokenAmountsOut[i], minTokenAmountsOut[i]);\n            }\n            _tokens[i].safeTransfer(recipient, tokenAmountsOut[i]);\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidity(lpAmountIn, tokenAmountsOut, recipient);\n    }\n\n    function getRemoveLiquidityOut(uint lpAmountIn) external view returns (uint[] memory tokenAmountsOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        uint lpTokenSupply = totalSupply();\n\n        tokenAmountsOut = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            tokenAmountsOut[i] = (lpAmountIn * reserves[i]) / lpTokenSupply;\n        }\n    }\n\n    //////////////////// REMOVE LIQUIDITY: ONE TOKEN ////////////////////\n\n    function removeLiquidityOneToken(\n        uint lpAmountIn,\n        IERC20 tokenOut,\n        uint minTokenAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint tokenAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        uint j = _getJ(_tokens, tokenOut);\n\n        tokenAmountOut = _getRemoveLiquidityOneTokenOut(lpAmountIn, j, reserves);\n        if (tokenAmountOut < minTokenAmountOut) {\n            revert SlippageOut(tokenAmountOut, minTokenAmountOut);\n        }\n\n        _burn(msg.sender, lpAmountIn);\n        tokenOut.safeTransfer(recipient, tokenAmountOut);\n\n        reserves[j] = reserves[j] - tokenAmountOut;\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidityOneToken(lpAmountIn, tokenOut, tokenAmountOut, recipient);\n    }\n\n    function getRemoveLiquidityOneTokenOut(\n        uint lpAmountIn,\n        IERC20 tokenOut\n    ) external view returns (uint tokenAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        uint j = _getJ(_tokens, tokenOut);\n        tokenAmountOut = _getRemoveLiquidityOneTokenOut(lpAmountIn, j, reserves);\n    }\n\n    /**\n     * @dev Shared logic for removing a single token from liquidity.\n     * Calculates change in reserve `j` given a change in LP token supply.\n     *\n     * Note: `lpAmountIn` is the amount of LP the user is burning in exchange\n     * for some amount of token `j`.\n     */\n    function _getRemoveLiquidityOneTokenOut(\n        uint lpAmountIn,\n        uint j,\n        uint[] memory reserves\n    ) private view returns (uint tokenAmountOut) {\n        uint newLpTokenSupply = totalSupply() - lpAmountIn;\n        uint newReserveJ = _calcReserve(wellFunction(), reserves, j, newLpTokenSupply);\n        tokenAmountOut = reserves[j] - newReserveJ;\n    }\n\n    //////////// REMOVE LIQUIDITY: IMBALANCED ////////////\n\n    function removeLiquidityImbalanced(\n        uint maxLpAmountIn,\n        uint[] calldata tokenAmountsOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint lpAmountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n\n        for (uint i; i < _tokens.length; ++i) {\n            _tokens[i].safeTransfer(recipient, tokenAmountsOut[i]);\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n\n        lpAmountIn = totalSupply() - _calcLpTokenSupply(wellFunction(), reserves);\n        if (lpAmountIn > maxLpAmountIn) {\n            revert SlippageIn(lpAmountIn, maxLpAmountIn);\n        }\n        _burn(msg.sender, lpAmountIn);\n\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidity(lpAmountIn, tokenAmountsOut, recipient);\n    }\n\n    function getRemoveLiquidityImbalancedIn(uint[] calldata tokenAmountsOut) external view returns (uint lpAmountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n        lpAmountIn = totalSupply() - _calcLpTokenSupply(wellFunction(), reserves);\n    }\n\n    //////////////////// RESERVES ////////////////////\n\n    /**\n     * @dev Sync the reserves of the Well with its current balance of underlying tokens.\n     */\n    function sync() external nonReentrant {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n        _setReserves(_tokens, reserves);\n        emit Sync(reserves);\n    }\n\n    /**\n     * @dev Transfer excess tokens held by the Well to `recipient`.\n     */\n    function skim(address recipient) external nonReentrant returns (uint[] memory skimAmounts) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        skimAmounts = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            skimAmounts[i] = _tokens[i].balanceOf(address(this)) - reserves[i];\n            if (skimAmounts[i] > 0) {\n                _tokens[i].safeTransfer(recipient, skimAmounts[i]);\n            }\n        }\n    }\n\n    function getReserves() external view returns (uint[] memory reserves) {\n        reserves = _getReserves(numberOfTokens());\n    }\n\n    /**\n     * @dev Gets the Well's token reserves by reading from byte storage.\n     */\n    function _getReserves(uint _numberOfTokens) internal view returns (uint[] memory reserves) {\n        reserves = LibBytes.readUint128(RESERVES_STORAGE_SLOT, _numberOfTokens);\n    }\n\n    /**\n     * @dev Checks that the balance of each ERC-20 token is >= the reserves and\n     * sets the Well's reserves of each token by writing to byte storage.\n     */\n    function _setReserves(IERC20[] memory _tokens, uint[] memory reserves) internal {\n        for (uint i; i < reserves.length; ++i) {\n            if (reserves[i] > _tokens[i].balanceOf(address(this))) revert InvalidReserves();\n        }\n        LibBytes.storeUint128(RESERVES_STORAGE_SLOT, reserves);\n    }\n\n    //////////////////// INTERNAL: UPDATE PUMPS ////////////////////\n\n    /**\n     * @dev Fetches the current token reserves of the Well and updates the Pumps.\n     * Typically called before an operation that modifies the Well's reserves.\n     */\n    function _updatePumps(uint _numberOfTokens) internal returns (uint[] memory reserves) {\n        reserves = _getReserves(_numberOfTokens);\n\n        if (numberOfPumps() == 0) {\n            return reserves;\n        }\n\n        // gas optimization: avoid looping if there is only one pump\n        if (numberOfPumps() == 1) {\n            Call memory _pump = firstPump();\n            IPump(_pump.target).update(reserves, _pump.data);\n        } else {\n            Call[] memory _pumps = pumps();\n            for (uint i; i < _pumps.length; ++i) {\n                IPump(_pumps[i].target).update(reserves, _pumps[i].data);\n            }\n        }\n    }\n\n    //////////////////// INTERNAL: WELL FUNCTION INTERACTION ////////////////////\n\n    /**\n     * @dev Calculates the LP token supply given a list of `reserves` using the\n     * provided `_wellFunction`. Wraps {IWellFunction.calcLpTokenSupply}.\n     *\n     * The Well function is passed as a parameter to minimize gas in instances\n     * where it is called multiple times in one transaction.\n     */\n    function _calcLpTokenSupply(\n        Call memory _wellFunction,\n        uint[] memory reserves\n    ) internal view returns (uint lpTokenSupply) {\n        lpTokenSupply = IWellFunction(_wellFunction.target).calcLpTokenSupply(reserves, _wellFunction.data);\n    }\n\n    /**\n     * @dev Calculates the `j`th reserve given a list of `reserves` and `lpTokenSupply`\n     * using the provided `_wellFunction`. Wraps {IWellFunction.calcReserve}.\n     *\n     * The Well function is passed as a parameter to minimize gas in instances\n     * where it is called multiple times in one transaction.\n     */\n    function _calcReserve(\n        Call memory _wellFunction,\n        uint[] memory reserves,\n        uint j,\n        uint lpTokenSupply\n    ) internal view returns (uint reserve) {\n        reserve = IWellFunction(_wellFunction.target).calcReserve(reserves, j, lpTokenSupply, _wellFunction.data);\n    }\n\n    //////////////////// INTERNAL: WELL TOKEN INDEXING ////////////////////\n\n    /**\n     * @dev Returns the indices of `iToken` and `jToken` in `_tokens`.\n     * Reverts if either token is not in `_tokens`.\n     */\n    function _getIJ(IERC20[] memory _tokens, IERC20 iToken, IERC20 jToken) internal pure returns (uint i, uint j) {\n        bool foundI = false;\n        bool foundJ = false;\n\n        for (uint k; k < _tokens.length; ++k) {\n            if (iToken == _tokens[k]) {\n                i = k;\n                foundI = true;\n            } else if (jToken == _tokens[k]) {\n                j = k;\n                foundJ = true;\n            }\n        }\n\n        if (!foundI) revert InvalidTokens();\n        if (!foundJ) revert InvalidTokens();\n    }\n\n    /**\n     * @dev Returns the index of `jToken` in `_tokens`. Reverts if `jToken` is\n     * not in `_tokens`.\n     *\n     * If `_tokens` contains multiple instances of `jToken`, this will return\n     * the first one. A {Well} with duplicate tokens has been misconfigured.\n     */\n    function _getJ(IERC20[] memory _tokens, IERC20 jToken) internal pure returns (uint j) {\n        for (j; j < _tokens.length; ++j) {\n            if (jToken == _tokens[j]) {\n                return j;\n            }\n        }\n        revert InvalidTokens();\n    }\n\n    //////////////////// INTERNAL: TRANSFER HELPERS ////////////////////\n\n    /**\n     * @dev Calculates the change in token balance of the Well across a transfer.\n     * Used when a fee might be incurred during safeTransferFrom.\n     */\n    function _safeTransferFromFeeOnTransfer(\n        IERC20 token,\n        address from,\n        uint amount\n    ) internal returns (uint amountTransferred) {\n        uint balanceBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        amountTransferred = token.balanceOf(address(this)) - balanceBefore;\n    }\n\n    //////////////////// INTERNAL: EXPIRY ////////////////////\n\n    /**\n     * @dev Reverts if the deadline has passed.\n     */\n    modifier expire(uint deadline) {\n        if (block.timestamp > deadline) {\n            revert Expired();\n        }\n        _;\n    }\n}"
    }
  ]
}