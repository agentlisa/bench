{
  "Title": "[M-02] `MerkleMinter` created through `TokenFactory` cannot be upgraded",
  "Content": "\nDuring the token creation process in the `TokenFactory` contract, the function creates a `MerkleMinter` contract to setup and handle token initial token distribution.\n\n<https://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/framework/utils/TokenFactory.sol#L119-L125>\n\n```solidity\n...\n\n// Clone and initialize a `MerkleMinter`\naddress merkleMinter = merkleMinterBase.clone();\nMerkleMinter(merkleMinter).initialize(\n    _managingDao,\n    IERC20MintableUpgradeable(token),\n    distributorBase\n);\n\n...\n```\n\nThe `MerkleMinter` contract is an upgradeable contract, as it inherits from `PluginUUPSUpgradeable`:\n\n<https://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/plugins/token/MerkleMinter.sol#L20>\n\n```solidity\ncontract MerkleMinter is IMerkleMinter, PluginUUPSUpgradeable {\n```\n\nHowever, as we can see in the first code snippet, the `MerkleMinter` instance created in `createToken` is a **cloned** instance (using OpenZeppelin `Clones` library). This is incompatible with upgradeable contracts, which require the use of a proxy.\n\nThis issue will cause the `MerkleMinter` instance created through `TokenFactory` to fail to be upgraded. The `MerkleMinter` contract will contain all the required logic to be upgraded, but the action will fail as there is no proxy to change to a new potential implementation.\n\n### Proof of Concept\n\nThe following test illustrates the issue. We call `createToken` to get an instance of `MerkleMinter`. We then simulate a new version of the contract to upgrade to (`merkleMinterV2Impl`) and try to upgrade the `MerkleMinter` instance to this new implementation. The call fails with a \"Function must be called through active proxy\" error (error is defined in OpenZeppelin base `UUPSUpgradeable` contract).\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/c3662b7324fd561991bf2ad174052680).\n\n```solidity\nfunction test_TokenFactory_createToken_MerkleMinterNotUpgradeable() public {\n    DAO dao = createDao();\n    TokenFactory tokenFactory = new TokenFactory();\n    grantRootPermission(dao, address(tokenFactory));\n\n    TokenFactory.TokenConfig memory tokenConfig = TokenFactory.TokenConfig({\n        addr: address(0),\n        name: \"DAO Token\",\n        symbol: \"DAOT\"\n    });\n\n    address[] memory receivers = new address[](0);\n    uint256[] memory amounts = new uint256[](0);\n    GovernanceERC20.MintSettings memory mintSettings = GovernanceERC20.MintSettings({\n        receivers: receivers,\n        amounts: amounts\n    });\n\n    (, MerkleMinter merkleMinter) = tokenFactory.createToken(dao, tokenConfig, mintSettings);\n\n    // Assume we have a new V2 implementation...\n    MerkleMinter merkleMinterV2Impl = new MerkleMinter();\n\n    // The following will fail when the UUPS checks if the upgrade came from the proxy (since there's no proxy)\n    vm.expectRevert(\"Function must be called through active proxy\");\n    PluginUUPSUpgradeable(merkleMinter).upgradeTo(address(merkleMinterV2Impl));\n}\n```\n\n### Recommendation\n\nThe `MerkleMinter` instance should be created using a proxy over the base implementation (`createERC1967Proxy`) instead of cloning the implementation:\n\n```diff\ndiff --git a/src/framework/utils/TokenFactory.sol b/src/framework/utils/TokenFactory.sol\nindex 381e745..91441e5 100644\n--- a/src/framework/utils/TokenFactory.sol\n+++ b/src/framework/utils/TokenFactory.sol\n@@ -15,6 +15,7 @@ import {GovernanceWrappedERC20} from \"../../token/ERC20/governance/GovernanceWra\n import {IERC20MintableUpgradeable} from \"../../token/ERC20/IERC20MintableUpgradeable.sol\";\n import {DAO} from \"../../core/dao/DAO.sol\";\n import {IDAO} from \"../../core/dao/IDAO.sol\";\n+import {createERC1967Proxy} from \"../../utils/Proxy.sol\";\n \n /// @title TokenFactory\n /// @author Aragon Association - 2022-2023\n@@ -116,12 +117,15 @@ contract TokenFactory {\n             _mintSettings\n         );\n \n-        // Clone and initialize a `MerkleMinter`\n-        address merkleMinter = merkleMinterBase.clone();\n-        MerkleMinter(merkleMinter).initialize(\n-            _managingDao,\n-            IERC20MintableUpgradeable(token),\n-            distributorBase\n+        // Create proxy and initialize a `MerkleMinter`\n+        address merkleMinter = createERC1967Proxy(\n+            merkleMinterBase,\n+            abi.encodeWithSelector(\n+                MerkleMinter.initialize.selector,\n+                _managingDao,\n+                token,\n+                distributorBase\n+            )\n         );\n \n         // Emit the event\n```\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-03-aragon-findings/issues/176#issuecomment-1465221334):**\n > I don't believe a MerkleMinter instance is intended to be upgradeable. \n> \n> > \"The [Clones](https://docs.openzeppelin.com/contracts/3.x/api/proxy#Clones) library provides a way to deploy minimal non-upgradeable proxies for cheap. This can be useful for applications that require deploying many instances of the same contract (for example one per user, or one per task). These instances are designed to be both cheap to deploy, and cheap to call. The drawback being that they are not upgradeable.\"\n> \n> Will leave open for sponsor confirmation. But most likely this is invalid. \n\n**[novaknole20 (Aragon) confirmed](https://github.com/code-423n4/2023-03-aragon-findings/issues/176#issuecomment-1468298815)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-03-aragon-findings/issues/176#issuecomment-1475023665):**\n > It appears the sponsor does intend for this to be upgradeable since they confirmed the issue. Awarding as Medium.\n\n***Please note: the following additional discussion took place after judging and awarding were finalized.***\n\n**[novaknole20 (Aragon) commented](https://github.com/code-423n4/2023-03-aragon-findings/issues/176#issuecomment-1506514510):**\n > Sorry we don't know why this got confirmed from our side.... As seen in the code the MerkleMinter is only used by the `TokenFactory` and there we use clones (minimal non-upgradable proxies).<br>\n> Therefore we need to extend from `PluginUUPSUpgradeable` to disable the initializer in the base during construction.<br>\n> We'd like to note our mistake in accepting it and that we never intend to use it in an upgradeable pattern.\n\n**[novaknole20 (Aragon) commented](https://github.com/code-423n4/2023-03-aragon-findings/issues/176#issuecomment-1591074985):**\n > `MerkleMinter` is `UUPSUpgradeable` and the upgradeability is part of its feature set. However, in the context of the `TokenFactory` we opted to deploy it via the minimal proxy pattern to save gas. This is because its upgradeability feature is not needed here and the cloning can be done as well. We are fully aware that the `MerkleMinter` proxies created through the `TokenFactory` are not upgradeable.\n> \n> Although we accidentally accepted this medium risk finding initially, we don't think that intentional absent of upgradeability qualifies as medium risk/finding. Accordingly, we would suggest to not rate this as a medium risk finding in the final audit report.\n> \n> To make our intentions more clear, we made the following change to the documentation: https://github.com/aragon/osx/pull/362/files\n> \n> It is also worth noting that we are currently using neither `TokenFactory` nor `MerkleMinter`/`MerkleDistributor` in our framework and that we will move the code out of the aragon/osx repository in the future.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-03-aragon",
  "Code": [
    {
      "filename": "packages/contracts/src/framework/utils/TokenFactory.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC20VotesUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\n\nimport {MerkleMinter} from \"../../plugins/token/MerkleMinter.sol\";\nimport {MerkleDistributor} from \"../../plugins/token/MerkleDistributor.sol\";\nimport {IMerkleDistributor} from \"../../plugins/token/IMerkleDistributor.sol\";\nimport {GovernanceERC20} from \"../../token/ERC20/governance/GovernanceERC20.sol\";\nimport {GovernanceWrappedERC20} from \"../../token/ERC20/governance/GovernanceWrappedERC20.sol\";\nimport {IERC20MintableUpgradeable} from \"../../token/ERC20/IERC20MintableUpgradeable.sol\";\nimport {DAO} from \"../../core/dao/DAO.sol\";\nimport {IDAO} from \"../../core/dao/IDAO.sol\";\n\n/// @title TokenFactory\n/// @author Aragon Association - 2022-2023\n/// @notice This contract creates [ERC-20](https://eips.ethereum.org/EIPS/eip-20) governance tokens.\ncontract TokenFactory {\n    using Address for address;\n    using Clones for address;\n\n    /// @notice The address of the `GovernanceERC20` base contract to clone from.\n    address public governanceERC20Base;\n\n    /// @notice The address of the `GovernanceWrappedERC20` base contract to clone from.\n    address public governanceWrappedERC20Base;\n\n    /// @notice The address of the `MerkleMinter` base contract to clone from.\n    address public merkleMinterBase;\n\n    /// @notice The `MerkleDistributor` base contract used to initialize the `MerkleMinter` clones.\n    MerkleDistributor public distributorBase;\n\n    /// @notice Emitted when a new token is created.\n    /// @param token [ERC-20](https://eips.ethereum.org/EIPS/eip-20) token address.\n    /// @param minter The `MerkleMinter` contract minting the new token.\n    /// @param distributor The `MerkleDistibutor` contract distributing the new token.\n    event TokenCreated(\n        IERC20Upgradeable token,\n        MerkleMinter minter,\n        IMerkleDistributor distributor\n    );\n\n    /// @notice Emitted when an existing token is passed and wrapped one is created.\n    /// @param token GovernanceWrappedERC20 token address\n    event WrappedToken(GovernanceWrappedERC20 token);\n\n    /// @notice Thrown if token address is not ERC20.\n    /// @param token The token address\n    error TokenNotERC20(address token, bytes data);\n\n    struct TokenConfig {\n        address addr;\n        string name;\n        string symbol;\n    }\n\n    struct MintConfig {\n        address[] receivers;\n        uint256[] amounts;\n    }\n\n    /// @notice Initializes the different base contracts for the factory to clone from.\n    constructor() {\n        setupBases();\n    }\n\n    /// @notice Creates a new `GovernanceERC20` token or a `GovernanceWrappedERC20` from an existing [ERC-20](https://eips.ethereum.org/EIPS/eip-20) token depending on the address used in the `TokenConfig` provided.\n    /// @param _managingDao The address of the DAO managing the token.\n    /// @param _tokenConfig The token configuration struct containing the name, and symbol of the token to be create, but also an address. For `address(0)`, a new governance token is created. For any other address pointing to an [ERC-20](https://eips.ethereum.org/EIPS/eip-20)-compatible contract, a wrapped governance token is created.\n    /// @param _mintSettings The token mint settings struct containing the `receivers` and `amounts`.\n    /// @return The created `ERC20VotesUpgradeable` compatible token contract.\n    /// @return The created `MerkleMinter` contract used to mint the `ERC20VotesUpgradeable` tokens or `address(0)` if an existing token was provided.\n    function createToken(\n        DAO _managingDao,\n        TokenConfig calldata _tokenConfig,\n        GovernanceERC20.MintSettings calldata _mintSettings\n    ) external returns (ERC20VotesUpgradeable, MerkleMinter) {\n        address token = _tokenConfig.addr;\n\n        // deploy token\n        if (token != address(0)) {\n            // Validate if token is ERC20\n            bytes memory data = token.functionStaticCall(\n                abi.encodeWithSelector(IERC20Upgradeable.balanceOf.selector, address(this))\n            );\n\n            if (data.length != 0x20) {\n                revert TokenNotERC20(token, data);\n            }\n\n            token = governanceWrappedERC20Base.clone();\n            // user already has a token. we need to wrap it in\n            // GovernanceWrappedERC20 in order to make the token\n            // include governance functionality.\n            GovernanceWrappedERC20(token).initialize(\n                IERC20Upgradeable(_tokenConfig.addr),\n                _tokenConfig.name,\n                _tokenConfig.symbol\n            );\n\n            emit WrappedToken(GovernanceWrappedERC20(token));\n\n            return (ERC20VotesUpgradeable(token), MerkleMinter(address(0)));\n        }\n\n        token = governanceERC20Base.clone();\n        GovernanceERC20(token).initialize(\n            _managingDao,\n            _tokenConfig.name,\n            _tokenConfig.symbol,\n            _mintSettings\n        );\n\n        // Clone and initialize a `MerkleMinter`\n        address merkleMinter = merkleMinterBase.clone();\n        MerkleMinter(merkleMinter).initialize(\n            _managingDao,\n            IERC20MintableUpgradeable(token),\n            distributorBase\n        );\n\n        // Emit the event\n        emit TokenCreated(IERC20Upgradeable(token), MerkleMinter(merkleMinter), distributorBase);\n\n        bytes32 tokenMintPermission = GovernanceERC20(token).MINT_PERMISSION_ID();\n        bytes32 merkleMintPermission = MerkleMinter(merkleMinter).MERKLE_MINT_PERMISSION_ID();\n\n        // Grant the managing DAO permission to directly mint tokens to an receiving address.\n        _managingDao.grant(token, address(_managingDao), tokenMintPermission);\n\n        // Grant the managing DAO permission to mint tokens via the `MerkleMinter` that are claimable on a merkle tree.\n        _managingDao.grant(token, merkleMinter, tokenMintPermission);\n        _managingDao.grant(merkleMinter, address(_managingDao), merkleMintPermission);\n\n        return (ERC20VotesUpgradeable(token), MerkleMinter(merkleMinter));\n    }\n\n    /// @notice Private helper method to set up the required base contracts on TokenFactory deployment.\n    function setupBases() private {\n        distributorBase = new MerkleDistributor();\n        governanceERC20Base = address(\n            new GovernanceERC20(\n                IDAO(address(0)),\n                \"baseName\",\n                \"baseSymbol\",\n                GovernanceERC20.MintSettings(new address[](0), new uint256[](0))\n            )\n        );\n        governanceWrappedERC20Base = address(\n            new GovernanceWrappedERC20(IERC20Upgradeable(address(0)), \"baseName\", \"baseSymbol\")\n        );\n        merkleMinterBase = address(new MerkleMinter());\n    }\n}"
    },
    {
      "filename": "packages/contracts/src/plugins/token/MerkleMinter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {IDAO} from \"../../core/dao/IDAO.sol\";\nimport {PluginUUPSUpgradeable} from \"../../core/plugin/PluginUUPSUpgradeable.sol\";\nimport {IERC20MintableUpgradeable} from \"../../token/ERC20/IERC20MintableUpgradeable.sol\";\nimport {createERC1967Proxy} from \"../../utils/Proxy.sol\";\nimport {IMerkleDistributor} from \"./IMerkleDistributor.sol\";\nimport {MerkleDistributor} from \"./MerkleDistributor.sol\";\nimport {IMerkleMinter} from \"./IMerkleMinter.sol\";\n\n/// @title MerkleMinter\n/// @author Aragon Association\n/// @notice A component minting [ERC-20](https://eips.ethereum.org/EIPS/eip-20) tokens and distributing them on merkle trees using `MerkleDistributor` clones.\ncontract MerkleMinter is IMerkleMinter, PluginUUPSUpgradeable {\n    using Clones for address;\n\n    /// @notice The ID of the permission required to call the `merkleMint` function.\n    bytes32 public constant MERKLE_MINT_PERMISSION_ID = keccak256(\"MERKLE_MINT_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `changeDistributor` function.\n    bytes32 public constant CHANGE_DISTRIBUTOR_PERMISSION_ID =\n        keccak256(\"CHANGE_DISTRIBUTOR_PERMISSION\");\n\n    /// @inheritdoc IMerkleMinter\n    IERC20MintableUpgradeable public override token;\n\n    /// @inheritdoc IMerkleMinter\n    IMerkleDistributor public override distributorBase;\n\n    /// @notice Initializes the MerkleMinter.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _token A mintable [ERC-20](https://eips.ethereum.org/EIPS/eip-20) token.\n    /// @param _distributorBase A `MerkleDistributor` to be cloned.\n    function initialize(\n        IDAO _dao,\n        IERC20MintableUpgradeable _token,\n        IMerkleDistributor _distributorBase\n    ) external initializer {\n        __PluginUUPSUpgradeable_init(_dao);\n\n        token = _token;\n        distributorBase = _distributorBase;\n    }\n\n    /// @inheritdoc IMerkleMinter\n    function changeDistributorBase(\n        IMerkleDistributor _distributorBase\n    ) external override auth(CHANGE_DISTRIBUTOR_PERMISSION_ID) {\n        distributorBase = _distributorBase;\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IMerkleMinter).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Mints [ERC-20](https://eips.ethereum.org/EIPS/eip-20) tokens and distributes them using a `MerkleDistributor`.\n    /// @param _merkleRoot The root of the merkle balance tree.\n    /// @param _totalAmount The total amount of tokens to be minted.\n    /// @param _tree The link to the stored merkle tree.\n    /// @param _context Additional info related to the minting process.\n    /// @return distributor The `MerkleDistributor` via which the tokens can be claimed.\n    function merkleMint(\n        bytes32 _merkleRoot,\n        uint256 _totalAmount,\n        bytes calldata _tree,\n        bytes calldata _context\n    ) external override auth(MERKLE_MINT_PERMISSION_ID) returns (IMerkleDistributor distributor) {\n        address distributorAddr = createERC1967Proxy(\n            address(distributorBase),\n            abi.encodeWithSelector(\n                MerkleDistributor.initialize.selector,\n                dao(),\n                IERC20Upgradeable(address(token)),\n                _merkleRoot\n            )\n        );\n\n        token.mint(distributorAddr, _totalAmount);\n\n        emit MerkleMinted(distributorAddr, _merkleRoot, _totalAmount, _tree, _context);\n\n        return IMerkleDistributor(distributorAddr);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[48] private __gap;\n}"
    }
  ]
}