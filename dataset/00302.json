{
  "Title": "A given CCTP domain can be registered for multiple foreign chains due to insufficient validation in `Governance::registerEmitterAndDomain`",
  "Content": "**Description:** [`Governance::registerEmitterAndDomain`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/CircleIntegration/Governance.sol#L48-L84) is a Governance action that is used to register the emitter address and corresponding CCTP domain for a given foreign chain. Validation is currently performed to ensure that the registered CCTP domain of the foreign chain is not equal to that of the local chain; however, there is no such check to ensure that the given CCTP domain has not already been registered for a different foreign chain. In this case, where the CCTP domain of an existing foreign chain is mistakenly used in the registration of a new foreign chain, the [`getDomainToChain`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/CircleIntegration/Governance.sol#L83) mapping of an existing CCTP domain will be overwritten to the most recently registered foreign chain. Given the validation that prevents foreign chains from being registered again, without a method for updating an already registered emitter, it will not be possible to correct this corruption of state.\n\n```solidity\nfunction registerEmitterAndDomain(bytes memory encodedVaa) public {\n    /* snip: parsing of Governance VAA payload */\n\n    // For now, ensure that we cannot register the same foreign chain again.\n    require(registeredEmitters[foreignChain] == 0, \"chain already registered\");\n\n    /* snip: additional parsing of Governance VAA payload */\n\n    // Set the registeredEmitters state variable.\n    registeredEmitters[foreignChain] = foreignAddress;\n\n    // update the chainId to domain (and domain to chainId) mappings\n    getChainToDomain()[foreignChain] = cctpDomain;\n    getDomainToChain()[cctpDomain] = foreignChain;\n}\n```\n\n**Impact:** The impact of this issue in the current scope is limited since the corrupted state is only ever queried in a public view function; however, if it is important for third-party integrators, then this has the potential to cause downstream issues.\n\n**Proof of Concept:**\n1. CCTP Domain A is registered for foreign chain identifier X.\n2. CCTP Domain A is again registered, this time for foreign chain identifier Y.\n3. The `getDomainToChain` mapping for CCTP Domain A now points to foreign chain identifier Y, while the `getChainToDomain` mapping for both X and Y now points to CCTP domain A.\n\n**Recommended Mitigation:** Consider adding the following validation when registering a CCTP domain for a foreign chain:\n\n```diff\n+ require (getDomainToChain()[cctpDomain] == 0, \"CCTP domain already registered for a different foreign chain\");\n```\n\n**Wormhole Foundation:** We are comfortable that governance messages are sufficiently validated before being signed by the guardians and submitted on-chain.\n\n**Cyfrin:** Acknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/contracts/CircleIntegration/Governance.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nimport {ERC1967Upgrade} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\n\nimport {BytesParsing} from \"src/libraries/BytesParsing.sol\";\nimport {IWormhole} from \"src/interfaces/IWormhole.sol\";\nimport {IGovernance} from \"src/interfaces/IGovernance.sol\";\n\nimport {State} from \"./State.sol\";\nimport {\n    getRegisteredEmitters,\n    getChainToDomain,\n    getConsumedVaas,\n    getDomainToChain\n} from \"./Storage.sol\";\n\nabstract contract Governance is IGovernance, State, ERC1967Upgrade {\n    using BytesParsing for bytes;\n\n    /**\n     * @dev Governance emitter chain ID.\n     */\n    uint16 constant _GOVERNANCE_CHAIN = 1;\n\n    /**\n     * @dev Governance emitter address.\n     */\n    bytes32 constant _GOVERNANCE_EMITTER =\n        0x0000000000000000000000000000000000000000000000000000000000000004;\n\n    /**\n     * @dev \"CircleIntegration\" (left-padded with zeros).\n     */\n    bytes32 constant GOVERNANCE_MODULE =\n        0x000000000000000000000000000000436972636c65496e746567726174696f6e;\n\n    /**\n     * @dev Governance action ID indicating decree to register new emitter and CCTP domain.\n     */\n    uint8 constant _ACTION_REGISTER_EMITTER_AND_DOMAIN = 2;\n\n    /**\n     * @dev Governance action ID indicating decree to upgrade contract.\n     */\n    uint8 constant _ACTION_CONTRACT_UPGRADE = 3;\n\n    /// @inheritdoc IGovernance\n    function registerEmitterAndDomain(bytes memory encodedVaa) public {\n        (IWormhole.VM memory vaa, uint256 offset) =\n            _verifyAndConsumeGovernanceMessage(encodedVaa, _ACTION_REGISTER_EMITTER_AND_DOMAIN);\n\n        // Registering emitters should only be relevant for this contract's chain ID,\n        // unless the target chain is 0 (which means all chains).\n        uint16 targetChain;\n        (targetChain, offset) = vaa.payload.asUint16Unchecked(offset);\n        require(targetChain == 0 || targetChain == _chainId, \"invalid target chain\");\n\n        uint16 foreignChain;\n        (foreignChain, offset) = vaa.payload.asUint16Unchecked(offset);\n        require(foreignChain != 0 && foreignChain != _chainId, \"invalid chain\");\n\n        mapping(uint16 => bytes32) storage registeredEmitters = getRegisteredEmitters();\n\n        // For now, ensure that we cannot register the same foreign chain again.\n        require(registeredEmitters[foreignChain] == 0, \"chain already registered\");\n\n        bytes32 foreignAddress;\n        (foreignAddress, offset) = vaa.payload.asBytes32Unchecked(offset);\n        require(foreignAddress != 0, \"emitter cannot be zero address\");\n\n        uint32 cctpDomain;\n        (cctpDomain, offset) = vaa.payload.asUint32Unchecked(offset);\n        require(cctpDomain != _localCctpDomain, \"domain == localDomain()\");\n\n        _checkLength(vaa.payload, offset);\n\n        // Set the registeredEmitters state variable.\n        registeredEmitters[foreignChain] = foreignAddress;\n\n        // update the chainId to domain (and domain to chainId) mappings\n        getChainToDomain()[foreignChain] = cctpDomain;\n        getDomainToChain()[cctpDomain] = foreignChain;\n    }\n\n    /// @inheritdoc IGovernance\n    function upgradeContract(bytes memory encodedVaa) public {\n        (IWormhole.VM memory vaa, uint256 offset) =\n            _verifyAndConsumeGovernanceMessage(encodedVaa, _ACTION_CONTRACT_UPGRADE);\n\n        // contract upgrades should only be relevant for this contract's chain ID\n        uint16 targetChain;\n        (targetChain, offset) = vaa.payload.asUint16Unchecked(offset);\n        require(targetChain == _chainId, \"invalid target chain\");\n\n        bytes32 encodedImplementation;\n        (encodedImplementation, offset) = vaa.payload.asBytes32Unchecked(offset);\n        require(bytes12(encodedImplementation) == 0, \"invalid address\");\n\n        _checkLength(vaa.payload, offset);\n\n        address newImplementation;\n        assembly (\"memory-safe\") {\n            newImplementation := encodedImplementation\n        }\n\n        // Verify new implementation is CircleIntegration.\n        {\n            (, bytes memory queried) = newImplementation.staticcall(\n                abi.encodeWithSignature(\"circleIntegrationImplementation()\")\n            );\n\n            require(queried.length == 32, \"invalid implementation\");\n            require(\n                abi.decode(queried, (bytes32)) == keccak256(\"circleIntegrationImplementation()\"),\n                \"invalid implementation\"\n            );\n        }\n\n        // Save the current implementation address for event.\n        address currentImplementation = _getImplementation();\n\n        _upgradeTo(newImplementation);\n\n        // call initialize function of the new implementation\n        (bool success, bytes memory reason) =\n            newImplementation.delegatecall(abi.encodeWithSignature(\"initialize()\"));\n        require(success, string(reason));\n\n        emit ContractUpgraded(currentImplementation, newImplementation);\n    }\n\n    /// @inheritdoc IGovernance\n    function verifyGovernanceMessage(bytes memory encodedVaa, uint8 action)\n        public\n        view\n        returns (bytes32, bytes memory)\n    {\n        (IWormhole.VM memory vaa,) = _verifyGovernanceMessage(getConsumedVaas(), encodedVaa, action);\n        return (vaa.hash, vaa.payload);\n    }\n\n    function _verifyAndConsumeGovernanceMessage(bytes memory encodedVaa, uint8 action)\n        private\n        returns (IWormhole.VM memory, uint256)\n    {\n        mapping(bytes32 => bool) storage consumedVaas = getConsumedVaas();\n\n        // verify the governance message\n        (IWormhole.VM memory vaa, uint256 offset) =\n            _verifyGovernanceMessage(consumedVaas, encodedVaa, action);\n\n        // store the hash for replay protection\n        consumedVaas[vaa.hash] = true;\n\n        return (vaa, offset);\n    }\n\n    function _verifyGovernanceMessage(\n        mapping(bytes32 => bool) storage consumedVaas,\n        bytes memory encodedVaa,\n        uint8 action\n    ) private view returns (IWormhole.VM memory vaa, uint256 offset) {\n        // Make sure the blockchain has not forked.\n        require(block.chainid == _evmChain, \"invalid evm chain\");\n\n        // verify the governance message\n        bool valid;\n        string memory reason;\n        (vaa, valid, reason) = _wormhole.parseAndVerifyVM(encodedVaa);\n        require(valid, reason);\n\n        // Confirm that the governance message was sent from the governance contract.\n        require(vaa.emitterChainId == _GOVERNANCE_CHAIN, \"invalid governance chain\");\n        require(vaa.emitterAddress == _GOVERNANCE_EMITTER, \"invalid governance contract\");\n\n        // Confirm that this governance action has not been consumed already.\n        require(!consumedVaas[vaa.hash], \"governance action already consumed\");\n\n        bytes32 govModule;\n        (govModule, offset) = vaa.payload.asBytes32Unchecked(offset);\n\n        require(govModule == GOVERNANCE_MODULE, \"invalid governance module\");\n\n        uint8 govAction;\n        (govAction, offset) = vaa.payload.asUint8Unchecked(offset);\n\n        require(govAction == action, \"invalid governance action\");\n    }\n\n    function _checkLength(bytes memory encoded, uint256 expected) private pure {\n        require(encoded.length == expected, \"invalid governance payload length\");\n    }\n\n    // getters\n\n    /// @inheritdoc IGovernance\n    function governanceChainId() public pure returns (uint16) {\n        return _GOVERNANCE_CHAIN;\n    }\n\n    /// @inheritdoc IGovernance\n    function governanceContract() public pure returns (bytes32) {\n        return _GOVERNANCE_EMITTER;\n    }\n}"
    }
  ]
}