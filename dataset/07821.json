{
  "Title": "[M-17] Chainlink oracle data feed is not sufficiently validated and can return stale price",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363\n\n\n# Vulnerability details\n\n## Impact\nCalling the `Oracle` contract's `viewPrice` or `getPrice` function executes `uint price = feeds[token].feed.latestAnswer()` and `require(price > 0, \"Invalid feed price\")`. Besides that Chainlink's `latestAnswer` function is deprecated, only verifying that `price > 0` is true is also not enough to guarantee that the returned `price` is not stale. Using a stale `price` can cause the calculations for the credit and withdrawal limits to be inaccurate, which, for example, can mistakenly consider a user's debt to be under water and unexpectedly allow the user's debt to be liquidated.\n\nTo avoid using a stale answer returned by the Chainlink oracle data feed, according to [Chainlink's documentation](https://docs.chain.link/docs/historical-price-data):\n1. The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function.\n2. `roundId` and `answeredInRound` are also returned. \"You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh.\"\n3. \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"\n\n\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105\n```solidity\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n```\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144\n```solidity\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n```\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347\n```solidity\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n```\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327\n```solidity\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n```\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363\n```solidity\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n```\n\n## Proof of Concept\nThe following steps can occur for the described scenario.\n1. Alice calls the `depositAndBorrow` function to deposit some WETH as the collateral and borrows some DOLA against the collateral.\n2. Bob calls the `liquidate` function for trying to liquidate Alice's debt. Because the Chainlink oracle data feed returns an up-to-date price at this moment, the `getCreditLimitInternal` function calculates Alice's credit limit accurately, which does not cause Alice's debt to be under water. Hence, Bob's `liquidate` transaction reverts.\n3. After some time, Bob calls the `liquidate` function again for trying to liquidate Alice's debt. This time, because the Chainlink oracle data feed returns a positive but stale price, the `getCreditLimitInternal` function calculates Alice's credit limit inaccurately, which mistakenly causes Alice's debt to be under water.\n4. Bob's `liquidate` transaction is executed successfully so he gains some of Alice's WETH collateral. Alice loses such WETH collateral amount unexpectedly because her debt should not be considered as under water if the stale price was not used.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L82-L83 and https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L116-L117 can be updated to the following code.\n```solidity\n            (uint80 roundId, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = feeds[token].feed.latestRoundData();\n            require(answeredInRound >= roundId, \"answer is stale\");\n            require(updatedAt > 0, \"round is incomplete\");\n            require(answer > 0, \"Invalid feed answer\");\n\n            uint256 price = uint256(answer);\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
  "Code": [
    {
      "filename": "src/Oracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}"
    },
    {
      "filename": "src/Oracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IChainlinkFeed {\n    function decimals() external view returns (uint8);\n    function latestAnswer() external view returns (uint);\n}\n\n/**\n@title Oracle\n@notice Oracle used by markets. Can use both fixed price feeds and Chainlink-style feeds for prices.\nThe Pessimistic Oracle introduces collateral factor into the pricing formula. It ensures that any given oracle price is dampened to prevent borrowers from borrowing more than the lowest recorded value of their collateral over the past 2 days.\nThis has the advantage of making price manipulation attacks more difficult, as an attacker needs to log artificially high lows.\nIt has the disadvantage of reducing borrow power of borrowers to a 2-day minimum value of their collateral, where the value must have been seen by the oracle.\n*/\ncontract Oracle {\n\n    struct FeedData {\n        IChainlinkFeed feed;\n        uint8 tokenDecimals;\n    }\n\n    address public operator;\n    address public pendingOperator;\n    mapping (address => FeedData) public feeds;\n    mapping (address => uint) public fixedPrices;\n    mapping (address => mapping(uint => uint)) public dailyLows; // token => day => price\n\n    constructor(\n        address _operator\n    ) {\n        operator = _operator;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n    \n    /**\n    @notice Sets the pending operator of the oracle. Only callable by operator.\n    @param newOperator_ The address of the pending operator.\n    */\n    function setPendingOperator(address newOperator_) public onlyOperator { pendingOperator = newOperator_; }\n\n    /**\n    @notice Sets the price feed of a specific token address.\n    @dev Even though the price feeds implement the chainlink interface, it's possible to use other price oracle.\n    @param token Address of the ERC20 token to set a feed for\n    @param feed The chainlink feed of the ERC20 token.\n    @param tokenDecimals uint8 representing the decimal precision of the token\n    */\n    function setFeed(address token, IChainlinkFeed feed, uint8 tokenDecimals) public onlyOperator { feeds[token] = FeedData(feed, tokenDecimals); }\n\n    /**\n    @notice Sets a fixed price for a token\n    @dev Be careful when setting this. Assuming a fixed price where one doesn't exist can have disastrous consequences.\n    @param token The address of the fixed price token\n    @param price The fixed price of the token. Remember to account for decimal precision when setting this.\n    */\n    function setFixedPrice(address token, uint price) public onlyOperator { fixedPrices[token] = price; }\n\n    /**\n    @notice Claims the operator role. Only successfully callable by the pending operator.\n    */\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            uint day = block.timestamp / 1 days;\n            // get today's low\n            uint todaysLow = dailyLows[token][day];\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    /**\n    @notice Gets the price of a specific token in DOLA while also saving the price if it is the day's lowest.\n    @param token The address of the token to get price of\n    @return The price of the token in DOLA, adjusted for token and feed decimals\n    */\n    function getPrice(address token, uint collateralFactorBps) external returns (uint) {\n        if(fixedPrices[token] > 0) return fixedPrices[token];\n        if(feeds[token].feed != IChainlinkFeed(address(0))) {\n            // get price from feed\n            uint price = feeds[token].feed.latestAnswer();\n            require(price > 0, \"Invalid feed price\");\n            // normalize price\n            uint8 feedDecimals = feeds[token].feed.decimals();\n            uint8 tokenDecimals = feeds[token].tokenDecimals;\n            uint8 decimals = 36 - feedDecimals - tokenDecimals;\n            uint normalizedPrice = price * (10 ** decimals);\n            // potentially store price as today's low\n            uint day = block.timestamp / 1 days;\n            uint todaysLow = dailyLows[token][day];\n            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n                dailyLows[token][day] = normalizedPrice;\n                todaysLow = normalizedPrice;\n                emit RecordDailyLow(token, normalizedPrice);\n            }\n            // get yesterday's low\n            uint yesterdaysLow = dailyLows[token][day - 1];\n            // calculate new borrowing power based on collateral factor\n            uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;\n            uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;\n            if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {\n                uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;\n                return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;\n            }\n            return normalizedPrice;\n\n        }\n        revert(\"Price not found\");\n    }\n\n    event ChangeOperator(address indexed newOperator);\n    event RecordDailyLow(address indexed token, uint price);\n\n}"
    },
    {
      "filename": "src/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256("
    }
  ]
}