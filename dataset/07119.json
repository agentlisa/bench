{
  "Title": "[M-05] Borrower can lose partial fund during minting of Power Token as excess ETH are not refunded automatically",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L142\nhttps://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L87-L124\nhttps://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L119-L123\nhttps://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/Payment.sol#L44-L46\n\n\n# Vulnerability details\n\n## Impact\nWhen the collateral/speculative token (Token1) is WETH, a borrower could mint Power Tokens and deposit the collateral tokens by sending ETH while calling the payable mint() function in LendgineRouter.sol. \n\nThe exact collateral amount required to be deposited by the borrower is only calculated during minting (due to external swap), which could be lesser than what the borrower has sent for the mint. This means that there will be excess ETH left in LengineRouter contract and they are not automatically refunded to the borrower. \n\nAnyone that see this opportunity can call refundETH() to retrieve the excess ETH. \n\nThe borrower could retrieve the remaining ETH with a separate call to refundETH(). However, as the calls are not atomic, it is possible for a MEV bot to frontrun the borrower and steal the ETH too. \n\nFurthermore, there are no documentation and test cases that advise or handle this issue.\n\n## Proof of Concept\n\nFirst, call payable mint() in LendgineRouter contract with the required ETH amount for collateral. \n\n\tfunction mint(MintParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 shares) {\n\nhttps://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L142\n\nLendgineRouter.mintCallback() will be triggered, which will perform the external swap of the borrowed token0 to token1 on uniswap. The collateralSwap value (token1) is only calculated and known after the successful swap. Both swapped token1 and borrowed token1 are then sent to Lendgine contract (msg.sender).\n\n    // swap all token0 to token1\n    uint256 collateralSwap = swap(\n      decoded.swapType,\n      SwapParams({\n        tokenIn: decoded.token0,\n        tokenOut: decoded.token1,\n        amount: SafeCast.toInt256(amount0),\n        recipient: msg.sender\n      }),\n      decoded.swapExtraData\n    );\n\n    // send token1 back\n    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);\n\nhttps://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L87-L124\n\nAfter that, mintCallback() will continue to calculate the remaining token1 required to be paid by the borrower (collateralIn value).  \n\nDepending on the external swap, the collateralSwap (token1) value could be higher than expected, resulting in a lower collateralIn value. A small collateralIn value means that less ETH is required to be paid by the borrower (via the pay function), resulting in excess ETH left in the LengineRouter contract. However, the excess ETH is not automatically refunded by the mint() call.\n\nNote: For WETH, the pay() uses the ETH balance deposited and wrap it before transferring to Lendgine contract.\n\n    // pull the rest of tokens from the user\n    uint256 collateralIn = collateralTotal - amount1 - collateralSwap;\n    if (collateralIn > decoded.collateralMax) revert AmountError();\n\n    pay(decoded.token1, decoded.payer, msg.sender, collateralIn);\n\nhttps://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/LendgineRouter.sol#L119-L123\n\nA MEV bot or anyone that see this opportunity can call refundETH() to retrieve the excess ETH.\n\n\tfunction refundETH() external payable {\n\t\tif (address(this).balance > 0) SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\n\t}\n\nhttps://github.com/code-423n4/2023-01-numoen/blob/main/src/periphery/Payment.sol#L44-L46\n\n## Recommended Mitigation Steps\nAutomatically refund any excess ETH to the borrower.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-numoen-contest",
  "Code": [
    {
      "filename": "src/periphery/LendgineRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { Multicall } from \"./Multicall.sol\";\nimport { Payment } from \"./Payment.sol\";\nimport { SelfPermit } from \"./SelfPermit.sol\";\nimport { SwapHelper } from \"./SwapHelper.sol\";\n\nimport { ILendgine } from \"../core/interfaces/ILendgine.sol\";\nimport { IMintCallback } from \"../core/interfaces/callback/IMintCallback.sol\";\nimport { IPairMintCallback } from \"../core/interfaces/callback/IPairMintCallback.sol\";\n\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { LendgineAddress } from \"./libraries/LendgineAddress.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\n/// @notice Contract for automatically entering and exiting option positions\n/// @author Kyle Scott (kyle@numoen.com)\ncontract LendgineRouter is Multicall, Payment, SelfPermit, SwapHelper, IMintCallback, IPairMintCallback {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(address indexed from, address indexed lendgine, uint256 collateral, uint256 shares, address indexed to);\n\n  event Burn(address indexed from, address indexed lendgine, uint256 collateral, uint256 shares, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error LivelinessError();\n\n  error ValidationError();\n\n  error AmountError();\n\n  /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  address public immutable factory;\n\n  /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n  constructor(\n    address _factory,\n    address _uniswapV2Factory,\n    address _uniswapV3Factory,\n    address _weth\n  )\n    SwapHelper(_uniswapV2Factory, _uniswapV3Factory)\n    Payment(_weth)\n  {\n    factory = _factory;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           LIVELINESS MODIFIER\n    //////////////////////////////////////////////////////////////*/\n\n  modifier checkDeadline(uint256 deadline) {\n    if (deadline < block.timestamp) revert LivelinessError();\n    _;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                               MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  struct MintCallbackData {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 collateralMax;\n    SwapType swapType;\n    bytes swapExtraData;\n    address payer;\n  }\n\n  /// @notice Transfer the necessary amount of token1 to mint an option position\n  function mintCallback(\n    uint256 collateralTotal,\n    uint256 amount0,\n    uint256 amount1,\n    uint256,\n    bytes calldata data\n  )\n    external\n    override\n  {\n    MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n\n    address lendgine = LendgineAddress.computeAddress(\n      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound\n    );\n    if (lendgine != msg.sender) revert ValidationError();\n\n    // swap all token0 to token1\n    uint256 collateralSwap = swap(\n      decoded.swapType,\n      SwapParams({\n        tokenIn: decoded.token0,\n        tokenOut: decoded.token1,\n        amount: SafeCast.toInt256(amount0),\n        recipient: msg.sender\n      }),\n      decoded.swapExtraData\n    );\n\n    // send token1 back\n    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);\n\n    // pull the rest of tokens from the user\n    uint256 collateralIn = collateralTotal - amount1 - collateralSwap;\n    if (collateralIn > decoded.collateralMax) revert AmountError();\n\n    pay(decoded.token1, decoded.payer, msg.sender, collateralIn);\n  }\n\n  struct MintParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 amountIn;\n    uint256 amountBorrow;\n    uint256 sharesMin;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Use token1 to completely mint an option position\n  function mint(MintParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 shares) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    shares = ILendgine(lendgine).mint(\n      address(this),\n      params.amountIn + params.amountBorrow,\n      abi.encode(\n        MintCallbackData({\n          token0: params.token0,\n          token1: params.token1,\n          token0Exp: params.token0Exp,\n          token1Exp: params.token1Exp,\n          upperBound: params.upperBound,\n          collateralMax: params.amountIn,\n          swapType: params.swapType,\n          swapExtraData: params.swapExtraData,\n          payer: msg.sender\n        })\n      )\n    );\n    if (shares < params.sharesMin) revert AmountError();\n\n    SafeTransferLib.safeTransfer(lendgine, params.recipient, shares);\n\n    emit Mint(msg.sender, lendgine, params.amountIn, shares, params.recipient);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                               BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  struct PairMintCallbackData {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 collateralMin;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n  }\n\n  /// @notice Provide the tokens for the liquidity that is owed\n  function pairMintCallback(uint256 liquidity, bytes calldata data) external override {\n    PairMintCallbackData memory decoded = abi.decode(data, (PairMintCallbackData));\n\n    address lendgine = LendgineAddress.computeAddress(\n      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound\n    );\n    if (lendgine != msg.sender) revert ValidationError();\n\n    uint256 r0 = ILendgine(msg.sender).reserve0();\n    uint256 r1 = ILendgine(msg.sender).reserve1();\n    uint256 totalLiquidity = ILendgine(msg.sender).totalLiquidity();\n\n    uint256 amount0;\n    uint256 amount1;\n\n    if (totalLiquidity == 0) {\n      amount0 = decoded.amount0Min;\n      amount1 = decoded.amount1Min;\n    } else {\n      amount0 = FullMath.mulDivRoundingUp(liquidity, r0, totalLiquidity);\n      amount1 = FullMath.mulDivRoundingUp(liquidity, r1, totalLiquidity);\n    }\n\n    if (amount0 < decoded.amount0Min || amount1 < decoded.amount1Min) revert AmountError();\n\n    // swap for required token0\n    uint256 collateralSwapped = swap(\n      decoded.swapType,\n      SwapParams({\n        tokenIn: decoded.token1,\n        tokenOut: decoded.token0,\n        amount: -SafeCast.toInt256(amount0),\n        recipient: msg.sender\n      }),\n      decoded.swapExtraData\n    );\n\n    // pay token1\n    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);\n\n    // determine remaining and send to recipient\n    uint256 collateralTotal = ILendgine(msg.sender).convertLiquidityToCollateral(liquidity);\n    uint256 collateralOut = collateralTotal - amount1 - collateralSwapped;\n    if (collateralOut < decoded.collateralMin) revert AmountError();\n\n    if (decoded.recipient != address(this)) {\n      SafeTransferLib.safeTransfer(decoded.token1, decoded.recipient, collateralOut);\n    }\n  }\n\n  struct BurnParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 shares;\n    uint256 collateralMin;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Take an option position and withdraw it fully into token1\n  function burn(BurnParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 amount) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n    SafeTransferLib.safeTransferFrom(lendgine, msg.sender, lendgine, params.shares);\n\n    amount = ILendgine(lendgine).burn(\n      address(this),\n      abi.encode(\n        PairMintCallbackData({\n          token0: params.token0,\n          token1: params.token1,\n          token0Exp: params.token0Exp,\n          token1Exp: params.token1Exp,\n          upperBound: params.upperBound,\n          collateralMin: params.collateralMin,\n          amount0Min: params.amount0Min,\n          amount1Min: params.amount1Min,\n          swapType: params.swapType,\n          swapExtraData: params.swapExtraData,\n          recipient: recipient\n        })\n      )\n    );\n\n    emit Burn(msg.sender, lendgine, amount, params.shares, recipient);\n  }\n}"
    },
    {
      "filename": "src/periphery/LendgineRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { Multicall } from \"./Multicall.sol\";\nimport { Payment } from \"./Payment.sol\";\nimport { SelfPermit } from \"./SelfPermit.sol\";\nimport { SwapHelper } from \"./SwapHelper.sol\";\n\nimport { ILendgine } from \"../core/interfaces/ILendgine.sol\";\nimport { IMintCallback } from \"../core/interfaces/callback/IMintCallback.sol\";\nimport { IPairMintCallback } from \"../core/interfaces/callback/IPairMintCallback.sol\";\n\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { LendgineAddress } from \"./libraries/LendgineAddress.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\n/// @notice Contract for automatically entering and exiting option positions\n/// @author Kyle Scott (kyle@numoen.com)\ncontract LendgineRouter is Multicall, Payment, SelfPermit, SwapHelper, IMintCallback, IPairMintCallback {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(address indexed from, address indexed lendgine, uint256 collateral, uint256 shares, address indexed to);\n\n  event Burn(address indexed from, address indexed lendgine, uint256 collateral, uint256 shares, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error LivelinessError();\n\n  error ValidationError();\n\n  error AmountError();\n\n  /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  address public immutable factory;\n\n  /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n  constructor(\n    address _factory,\n    address _uniswapV2Factory,\n    address _uniswapV3Factory,\n    address _weth\n  )\n    SwapHelper(_uniswapV2Factory, _uniswapV3Factory)\n    Payment(_weth)\n  {\n    factory = _factory;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           LIVELINESS MODIFIER\n    //////////////////////////////////////////////////////////////*/\n\n  modifier checkDeadline(uint256 deadline) {\n    if (deadline < block.timestamp) revert LivelinessError();\n    _;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                               MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  struct MintCallbackData {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 collateralMax;\n    SwapType swapType;\n    bytes swapExtraData;\n    address payer;\n  }\n\n  /// @notice Transfer the necessary amount of token1 to mint an option position\n  function mintCallback(\n    uint256 collateralTotal,\n    uint256 amount0,\n    uint256 amount1,\n    uint256,\n    bytes calldata data\n  )\n    external\n    override\n  {\n    MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n\n    address lendgine = LendgineAddress.computeAddress(\n      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound\n    );\n    if (lendgine != msg.sender) revert ValidationError();\n\n    // swap all token0 to token1\n    uint256 collateralSwap = swap(\n      decoded.swapType,\n      SwapParams({\n        tokenIn: decoded.token0,\n        tokenOut: decoded.token1,\n        amount: SafeCast.toInt256(amount0),\n        recipient: msg.sender\n      }),\n      decoded.swapExtraData\n    );\n\n    // send token1 back\n    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);\n\n    // pull the rest of tokens from the user\n    uint256 collateralIn = collateralTotal - amount1 - collateralSwap;\n    if (collateralIn > decoded.collateralMax) revert AmountError();\n\n    pay(decoded.token1, decoded.payer, msg.sender, collateralIn);\n  }\n\n  struct MintParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 amountIn;\n    uint256 amountBorrow;\n    uint256 sharesMin;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Use token1 to completely mint an option position\n  function mint(MintParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 shares) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    shares = ILendgine(lendgine).mint(\n      address(this),\n      params.amountIn + params.amountBorrow,\n      abi.encode(\n        MintCallbackData({\n          token0: params.token0,\n          token1: params.token1,\n          token0Exp: params.token0Exp,\n          token1Exp: params.token1Exp,\n          upperBound: params.upperBound,\n          collateralMax: params.amountIn,\n          swapType: params.swapType,\n          swapExtraData: params.swapExtraData,\n          payer: msg.sender\n        })\n      )\n    );\n    if (shares < params.sharesMin) revert AmountError();\n\n    SafeTransferLib.safeTransfer(lendgine, params.recipient, shares);\n\n    emit Mint(msg.sender, lendgine, params.amountIn, shares, params.recipient);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                               BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  struct PairMintCallbackData {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 collateralMin;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n  }\n\n  /// @notice Provide the tokens for the liquidity that is owed\n  function pairMintCallback(uint256 liquidity, bytes calldata data) external override {\n    PairMintCallbackData memory decoded = abi.decode(data, (PairMintCallbackData));\n\n    address lendgine = LendgineAddress.computeAddress(\n      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound\n    );\n    if (lendgine != msg.sender) revert ValidationError();\n\n    uint256 r0 = ILendgine(msg.sender).reserve0();\n    uint256 r1 = ILendgine(msg.sender).reserve1();\n    uint256 totalLiquidity = ILendgine(msg.sender).totalLiquidity();\n\n    uint256 amount0;\n    uint256 amount1;\n\n    if (totalLiquidity == 0) {\n      amount0 = decoded.amount0Min;\n      amount1 = decoded.amount1Min;\n    } else {\n      amount0 = FullMath.mulDivRoundingUp(liquidity, r0, totalLiquidity);\n      amount1 = FullMath.mulDivRoundingUp(liquidity, r1, totalLiquidity);\n    }\n\n    if (amount0 < decoded.amount0Min || amount1 < decoded.amount1Min) revert AmountError();\n\n    // swap for required token0\n    uint256 collateralSwapped = swap(\n      decoded.swapType,\n      SwapParams({\n        tokenIn: decoded.token1,\n        tokenOut: decoded.token0,\n        amount: -SafeCast.toInt256(amount0),\n        recipient: msg.sender\n      }),\n      decoded.swapExtraData\n    );\n\n    // pay token1\n    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);\n\n    // determine remaining and send to recipient\n    uint256 collateralTotal = ILendgine(msg.sender).convertLiquidityToCollateral(liquidity);\n    uint256 collateralOut = collateralTotal - amount1 - collateralSwapped;\n    if (collateralOut < decoded.collateralMin) revert AmountError();\n\n    if (decoded.recipient != address(this)) {\n      SafeTransferLib.safeTransfer(decoded.token1, decoded.recipient, collateralOut);\n    }\n  }\n\n  struct BurnParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 shares;\n    uint256 collateralMin;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Take an option position and withdraw it fully into token1\n  function burn(BurnParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 amount) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n    SafeTransferLib.safeTransferFrom(lendgine, msg.sender, lendgine, params.shares);\n\n    amount = ILendgine(lendgine).burn(\n      address(this),\n      abi.encode(\n        PairMintCallbackData({\n          token0: params.token0,\n          token1: params.token1,\n          token0Exp: params.token0Exp,\n          token1Exp: params.token1Exp,\n          upperBound: params.upperBound,\n          collateralMin: params.collateralMin,\n          amount0Min: params.amount0Min,\n          amount1Min: params.amount1Min,\n          swapType: params.swapType,\n          swapExtraData: params.swapExtraData,\n          recipient: recipient\n        })\n      )\n    );\n\n    emit Burn(msg.sender, lendgine, amount, params.shares, recipient);\n  }\n}"
    },
    {
      "filename": "src/periphery/LendgineRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { Multicall } from \"./Multicall.sol\";\nimport { Payment } from \"./Payment.sol\";\nimport { SelfPermit } from \"./SelfPermit.sol\";\nimport { SwapHelper } from \"./SwapHelper.sol\";\n\nimport { ILendgine } from \"../core/interfaces/ILendgine.sol\";\nimport { IMintCallback } from \"../core/interfaces/callback/IMintCallback.sol\";\nimport { IPairMintCallback } from \"../core/interfaces/callback/IPairMintCallback.sol\";\n\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { LendgineAddress } from \"./libraries/LendgineAddress.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\n/// @notice Contract for automatically entering and exiting option positions\n/// @author Kyle Scott (kyle@numoen.com)\ncontract LendgineRouter is Multicall, Payment, SelfPermit, SwapHelper, IMintCallback, IPairMintCallback {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(address indexed from, address indexed lendgine, uint256 collateral, uint256 shares, address indexed to);\n\n  event Burn(address indexed from, address indexed lendgine, uint256 collateral, uint256 shares, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error LivelinessError();\n\n  error ValidationError();\n\n  error AmountError();\n\n  /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  address public immutable factory;\n\n  /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n  constructor(\n    address _factory,\n    address _uniswapV2Factory,\n    address _uniswapV3Factory,\n    address _weth\n  )\n    SwapHelper(_uniswapV2Factory, _uniswapV3Factory)\n    Payment(_weth)\n  {\n    factory = _factory;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           LIVELINESS MODIFIER\n    //////////////////////////////////////////////////////////////*/\n\n  modifier checkDeadline(uint256 deadline) {\n    if (deadline < block.timestamp) revert LivelinessError();\n    _;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                               MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  struct MintCallbackData {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 collateralMax;\n    SwapType swapType;\n    bytes swapExtraData;\n    address payer;\n  }\n\n  /// @notice Transfer the necessary amount of token1 to mint an option position\n  function mintCallback(\n    uint256 collateralTotal,\n    uint256 amount0,\n    uint256 amount1,\n    uint256,\n    bytes calldata data\n  )\n    external\n    override\n  {\n    MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n\n    address lendgine = LendgineAddress.computeAddress(\n      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound\n    );\n    if (lendgine != msg.sender) revert ValidationError();\n\n    // swap all token0 to token1\n    uint256 collateralSwap = swap(\n      decoded.swapType,\n      SwapParams({\n        tokenIn: decoded.token0,\n        tokenOut: decoded.token1,\n        amount: SafeCast.toInt256(amount0),\n        recipient: msg.sender\n      }),\n      decoded.swapExtraData\n    );\n\n    // send token1 back\n    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);\n\n    // pull the rest of tokens from the user\n    uint256 collateralIn = collateralTotal - amount1 - collateralSwap;\n    if (collateralIn > decoded.collateralMax) revert AmountError();\n\n    pay(decoded.token1, decoded.payer, msg.sender, collateralIn);\n  }\n\n  struct MintParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 amountIn;\n    uint256 amountBorrow;\n    uint256 sharesMin;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Use token1 to completely mint an option position\n  function mint(MintParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 shares) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    shares = ILendgine(lendgine).mint(\n      address(this),\n      params.amountIn + params.amountBorrow,\n      abi.encode(\n        MintCallbackData({\n          token0: params.token0,\n          token1: params.token1,\n          token0Exp: params.token0Exp,\n          token1Exp: params.token1Exp,\n          upperBound: params.upperBound,\n          collateralMax: params.amountIn,\n          swapType: params.swapType,\n          swapExtraData: params.swapExtraData,\n          payer: msg.sender\n        })\n      )\n    );\n    if (shares < params.sharesMin) revert AmountError();\n\n    SafeTransferLib.safeTransfer(lendgine, params.recipient, shares);\n\n    emit Mint(msg.sender, lendgine, params.amountIn, shares, params.recipient);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                               BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  struct PairMintCallbackData {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 collateralMin;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n  }\n\n  /// @notice Provide the tokens for the liquidity that is owed\n  function pairMintCallback(uint256 liquidity, bytes calldata data) external override {\n    PairMintCallbackData memory decoded = abi.decode(data, (PairMintCallbackData));\n\n    address lendgine = LendgineAddress.computeAddress(\n      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound\n    );\n    if (lendgine != msg.sender) revert ValidationError();\n\n    uint256 r0 = ILendgine(msg.sender).reserve0();\n    uint256 r1 = ILendgine(msg.sender).reserve1();\n    uint256 totalLiquidity = ILendgine(msg.sender).totalLiquidity();\n\n    uint256 amount0;\n    uint256 amount1;\n\n    if (totalLiquidity == 0) {\n      amount0 = decoded.amount0Min;\n      amount1 = decoded.amount1Min;\n    } else {\n      amount0 = FullMath.mulDivRoundingUp(liquidity, r0, totalLiquidity);\n      amount1 = FullMath.mulDivRoundingUp(liquidity, r1, totalLiquidity);\n    }\n\n    if (amount0 < decoded.amount0Min || amount1 < decoded.amount1Min) revert AmountError();\n\n    // swap for required token0\n    uint256 collateralSwapped = swap(\n      decoded.swapType,\n      SwapParams({\n        tokenIn: decoded.token1,\n        tokenOut: decoded.token0,\n        amount: -SafeCast.toInt256(amount0),\n        recipient: msg.sender\n      }),\n      decoded.swapExtraData\n    );\n\n    // pay token1\n    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);\n\n    // determine remaining and send to recipient\n    uint256 collateralTotal = ILendgine(msg.sender).convertLiquidityToCollateral(liquidity);\n    uint256 collateralOut = collateralTotal - amount1 - collateralSwapped;\n    if (collateralOut < decoded.collateralMin) revert AmountError();\n\n    if (decoded.recipient != address(this)) {\n      SafeTransferLib.safeTransfer(decoded.token1, decoded.recipient, collateralOut);\n    }\n  }\n\n  struct BurnParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 shares;\n    uint256 collateralMin;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Take an option position and withdraw it fully into token1\n  function burn(BurnParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 amount) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n    SafeTransferLib.safeTransferFrom(lendgine, msg.sender, lendgine, params.shares);\n\n    amount = ILendgine(lendgine).burn(\n      address(this),\n      abi.encode(\n        PairMintCallbackData({\n          token0: params.token0,\n          token1: params.token1,\n          token0Exp: params.token0Exp,\n          token1Exp: params.token1Exp,\n          upperBound: params.upperBound,\n          collateralMin: params.collateralMin,\n          amount0Min: params.amount0Min,\n          amount1Min: params.amount1Min,\n          swapType: params.swapType,\n          swapExtraData: params.swapExtraData,\n          recipient: recipient\n        })\n      )\n    );\n\n    emit Burn(msg.sender, lendgine, amount, params.shares, recipient);\n  }\n}"
    },
    {
      "filename": "src/periphery/Payment.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\nimport { IWETH9 } from \"./interfaces/external/IWETH9.sol\";\n\nimport { Balance } from \"./../libraries/Balance.sol\";\nimport { SafeTransferLib } from \"./../libraries/SafeTransferLib.sol\";\n\n/// @title   Payment contract\n/// @author  https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/PeripheryPayments.sol\n/// @notice  Functions to ease deposits and withdrawals of ETH\nabstract contract Payment {\n  address public immutable weth;\n\n  error InsufficientOutputError();\n\n  constructor(address _weth) {\n    weth = _weth;\n  }\n\n  receive() external payable {\n    require(msg.sender == weth, \"Not WETH9\");\n  }\n\n  function unwrapWETH(uint256 amountMinimum, address recipient) public payable {\n    uint256 balanceWETH = Balance.balance(weth);\n    if (balanceWETH < amountMinimum) revert InsufficientOutputError();\n\n    if (balanceWETH > 0) {\n      IWETH9(weth).withdraw(balanceWETH);\n      SafeTransferLib.safeTransferETH(recipient, balanceWETH);\n    }\n  }\n\n  function sweepToken(address token, uint256 amountMinimum, address recipient) public payable {\n    uint256 balanceToken = Balance.balance(token);\n    if (balanceToken < amountMinimum) revert InsufficientOutputError();\n\n    if (balanceToken > 0) {\n      SafeTransferLib.safeTransfer(token, recipient, balanceToken);\n    }\n  }\n\n  function refundETH() external payable {\n    if (address(this).balance > 0) SafeTransferLib.safeTransferETH(msg.sender, address(this).balance);\n  }\n\n  /// @param token The token to pay\n  /// @param payer The entity that must pay\n  /// @param recipient The entity that will receive payment\n  /// @param value The amount to pay\n  function pay(address token, address payer, address recipient, uint256 value) internal {\n    if (token == weth && address(this).balance >= value) {\n      // pay with WETH\n      IWETH9(weth).deposit{value: value}(); // wrap only what is needed to pay\n      SafeTransferLib.safeTransfer(weth, recipient, value);\n    } else if (payer == address(this)) {\n      // pay with tokens already in the contract (for the exact input multihop case)\n      SafeTransferLib.safeTransfer(token, recipient, value);\n    } else {\n      // pull payment\n      SafeTransferLib.safeTransferFrom(token, payer, recipient, value);\n    }\n  }\n}"
    }
  ]
}