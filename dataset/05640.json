{
  "Title": "[G-03] Add unchecked blocks for subtractions where the operands cannot underflow",
  "Content": "\nThe solidity compiler introduces some checks to avoid an underflow, but in some scenarios where it is impossible for underflow to occur we can use unchecked blocks to have some gas savings.\n\n*There is 1 instance of this issue.*\n\nhttps://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/PolicyValidator.sol#L162-#L166\n\n```solidity\nfile: contracts/src/core/PolicyValidator.sol\n\n156:    function _decompileSignatures(bytes calldata _signatures)\n157:        internal\n158:        pure\n159:        returns (uint32 expiryEpoch, bytes memory validatorSignature)\n160:    {\n161:        uint256 length = _signatures.length;\n162:        if (length < 8) revert InvalidSignatures();\n163:\n164:        uint32 sigLength = uint32(bytes4(_signatures[length - 8:length - 4]));  //@audit calculations can be unchecked\n165:        expiryEpoch = uint32(bytes4(_signatures[length - 4:length]));  //@audit calculations can be unchecked\n166:        validatorSignature = _signatures[length - 8 - sigLength:length - 8];  //@audit calculations can be unchecked\n167:    }\n```\n\nIn the `_decompileSignatures()` function above, the following calculations were made `uint32 sigLength = uint32(bytes4(_signatures[length - 8:length - 4]))`, `expiryEpoch = uint32(bytes4(_signatures[length - 4:length]))`, `validatorSignature = _signatures[length - 8 - sigLength:length - 8]`. However, prior to these calculations, the check `if (length < 8) revert InvalidSignatures()` was made which ensures that the value of the `length` variable should be greater or equal to 8. The code could be refactored as shown in the diff below: \n\n```diff\ndiff --git a/contracts/src/core/PolicyValidator.sol b/contracts/src/core/PolicyValidator.sol\nindex 70d672f..04eb07a 100644\n--- a/contracts/src/core/PolicyValidator.sol\n+++ b/contracts/src/core/PolicyValidator.sol\n@@ -161,9 +161,13 @@ contract PolicyValidator is AddressProviderService, EIP712 {\n         uint256 length = _signatures.length;\n         if (length < 8) revert InvalidSignatures();\n\n-        uint32 sigLength = uint32(bytes4(_signatures[length - 8:length - 4]));\n-        expiryEpoch = uint32(bytes4(_signatures[length - 4:length]));\n-        validatorSignature = _signatures[length - 8 - sigLength:length - 8];\n+        unchecked {\n+         uint32 sigLength = uint32(bytes4(_signatures[length - 8:length - 4]));\n+         expiryEpoch = uint32(bytes4(_signatures[length - 4:length]));\n+         validatorSignature = _signatures[length - 8 - sigLength:length - 8];\n+        }\n+\n+\n     }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-brahma",
  "Code": [
    {
      "filename": "contracts/src/core/PolicyValidator.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {EIP712} from \"solady/utils/EIP712.sol\";\nimport {AddressProviderService} from \"src/core/AddressProviderService.sol\";\nimport {PolicyRegistry} from \"src/core/registries/PolicyRegistry.sol\";\nimport {TypeHashHelper} from \"src/libraries/TypeHashHelper.sol\";\nimport {IGnosisSafe, Enum} from \"interfaces/external/IGnosisSafe.sol\";\n\n/**\n * @title PolicyValidator\n * @author Brahma.fi\n * @notice Responsible for validating policy signatures for safe transactions\n */\ncontract PolicyValidator is AddressProviderService, EIP712 {\n    error InvalidSignature();\n    error NoPolicyCommit();\n    error TxnExpired(uint32 expiryEpoch);\n    error InvalidSignatures();\n\n    /// @notice EIP712 domain name\n    string private constant _NAME = \"PolicyValidator\";\n    /// @notice EIP712 domain version\n    string private constant _VERSION = \"1.0\";\n\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\n\n    /**\n     * @notice generates digest and validates signature against policies for safe transaction\n     * @dev The TRUSTED_VALIDATOR is expected to sign EIP712 digest generated from the following struct:\n     * TypeHashHelper.Validation, where -\n     *  txnDigest = EIP712 digest generated from struct: TypeHashHelper.Transaction\n     *  policyHash = policy commit hash of the safe account\n     *  expiryEpoch = expiry timestamp\n     *\n     * @dev signatures = abi.encodePacked(safeSignature, validatorSignature, validatorSignatureLength, expiryEpoch)\n     *  safeSignature = safe owners signatures (arbitrary bytes length)\n     *  validatorSignature = EIP 712 digest signature (arbitrary bytes length)\n     *  validatorSignatureLength = length of `validatorSignature` (4 bytes)\n     *  expiryEpoch = expiry timestamp (4 bytes)\n     *\n     * @param account address of account to validate txn for\n     * @param to target address\n     * @param value txn value\n     * @param data txn callData\n     * @param operation type of operation\n     * @param signatures user signatures appended with validation signature\n     * @return isSignatureValid boolean\n     */\n    function isPolicySignatureValid(\n        address account,\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        bytes calldata signatures\n    ) external view returns (bool) {\n        // Get nonce from safe\n        uint256 nonce = IGnosisSafe(account).nonce();\n\n        // Build transaction struct hash\n        bytes32 transactionStructHash = TypeHashHelper._buildTransactionStructHash(\n            TypeHashHelper.Transaction({\n                to: to,\n                value: value,\n                data: data,\n                operation: uint8(operation),\n                account: account,\n                executor: address(0),\n                nonce: nonce\n            })\n        );\n\n        // Validate signature\n        return isPolicySignatureValid(account, transactionStructHash, signatures);\n    }\n\n    /**\n     * @notice generates digest and validates signature against policies for module execution\n     * @dev signatures = abi.encodePacked(validatorSignature, validatorSignatureLength, expiryEpoch)\n     *      validatorSignature = EIP 712 digest signed by `TRUSTED_VALIDATOR`(arbitrary bytes length)\n     *      validatorSignatureLength = length of `validatorSignature` (4 bytes)\n     *      expiryEpoch = expiry timestamp (4 bytes)\n     *  Here,\n     *  The `TRUSTED_VALIDATOR` is expected to sign the EIP 712 digest generated from following struct:\n     *  TypeHashHelper.Validation -\n     *      txnDigest = EIP712 digest generated from struct: TypeHashHelper.Transaction, with valid executor\n     *      policyHash = policy commit hash of the safe account\n     *      expiryEpoch = expiry timestamp\n     *\n     * @param account address of account to validate txn for\n     * @param transactionStructHash execution digest from ExecutorPlugin\n     * @param signatures user signatures appended with validation signature\n     * @return isSignatureValid boolean\n     */\n    function isPolicySignatureValid(address account, bytes32 transactionStructHash, bytes calldata signatures)\n        public\n        view\n        returns (bool)\n    {\n        // Get policy hash from registry\n        bytes32 policyHash =\n            PolicyRegistry(AddressProviderService._getRegistry(_POLICY_REGISTRY_HASH)).commitments(account);\n        if (policyHash == bytes32(0)) {\n            revert NoPolicyCommit();\n        }\n\n        // Get expiry epoch and validator signature from signatures\n        (uint32 expiryEpoch, bytes memory validatorSignature) = _decompileSignatures(signatures);\n\n        // Ensure transaction has not expired\n        if (expiryEpoch < uint32(block.timestamp)) {\n            revert TxnExpired(expiryEpoch);\n        }\n\n        // Build validation struct hash\n        bytes32 validationStructHash = TypeHashHelper._buildValidationStructHash(\n            TypeHashHelper.Validation({\n                transactionStructHash: transactionStructHash,\n                policyHash: policyHash,\n                expiryEpoch: expiryEpoch\n            })\n        );\n\n        // Build EIP712 digest with validation struct hash\n        bytes32 txnValidityDigest = _hashTypedData(validationStructHash);\n\n        address trustedValidator = AddressProviderService._getAuthorizedAddress(_TRUSTED_VALIDATOR_HASH);\n\n        // Empty Signature check for EOA signer\n        if (trustedValidator.code.length == 0 && validatorSignature.length == 0) {\n            // TrustedValidator is an EOA and no trustedValidator signature is provided\n            revert InvalidSignature();\n        }\n\n        // Validate signature\n        return SignatureCheckerLib.isValidSignatureNow(trustedValidator, txnValidityDigest, validatorSignature);\n    }\n\n    /**\n     * @notice Internal helper to extract validity signature from overall safe transaction signature\n     * @dev _signatures = abi.encodePacked(safeSignature, validatorSignature, validatorSignatureLength, expiryEpoch)\n     *  safeSignature = safe owners signatures (arbitrary bytes length)\n     *  validatorSignature = EIP 712 digest signed (arbitrary bytes length)\n     *  validatorSignatureLength = length of `validatorSignature` (4 bytes)\n     *  expiryEpoch = expiry timestamp (4 bytes)\n     *\n     * @param _signatures packed transaction signature\n     * @return expiryEpoch extracted expiry epoch signed by brahma backend\n     * @return validatorSignature extracted validity signature\n     */\n    function _decompileSignatures(bytes calldata _signatures)\n        internal\n        pure\n        returns (uint32 expiryEpoch, bytes memory validatorSignature)\n    {\n        uint256 length = _signatures.length;\n        if (length < 8) revert InvalidSignatures();\n\n        uint32 sigLength = uint32(bytes4(_signatures[length - 8:length - 4]));\n        expiryEpoch = uint32(bytes4(_signatures[length - 4:length]));\n        validatorSignature = _signatures[length - 8 - sigLength:length - 8];\n    }\n\n    /**\n     * @notice Internal helper to get EIP712 domain name and version\n     * @return name domainName\n     * @return version domainVersion\n     */\n    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {\n        return (_NAME, _VERSION);\n    }\n}"
    }
  ]
}