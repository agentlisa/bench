{
  "Title": "M-14: `Reserves` should not be considered part of the available liquidity while calculating the interest rate",
  "Content": "# Issue M-14: `Reserves` should not be considered part of the available liquidity while calculating the interest rate \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/266-M \n## Found by \nWATCHPUG\n\n## Summary\n\nThe implementation is different from the documentation regarding the interest rate formula.\n\n## Vulnerability Detail\n\nThe formula given in the [docs](https://docs.sentiment.xyz/protocol/core/rateModel):\n\n> Calculates Borrow rate per second:\n\n> $$\nBorrow Rate Per Second = c3 \\cdot (util \\cdot c1 + util^{32} \\cdot c1 + util^{64} \\cdot c2) \\div secsPerYear\n$$\n\n> where, $util = borrows \\div (liquidity - reserves + borrows)$\n\n> $$\nutil=borrows \\div (liquidityâˆ’reserves+borrows)\n$$\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/tokens/LToken.sol#L217-L227\n\n```solidity\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n```\n\nHowever, the current implementation is taking all the balance as the liquidity:\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/DefaultRateModel.sol#L51-L68\n\n```solidity\n    function getBorrowRatePerSecond(\n        uint liquidity,\n        uint borrows\n    )\n        external\n        view\n        returns (uint)\n    {\n        uint util = _utilization(liquidity, borrows);\n        return c3.mulDivDown(\n            (\n                util.mulWadDown(c1)\n                + util.rpow(32, SCALE).mulWadDown(c1)\n                + util.rpow(64, SCALE).mulWadDown(c2)\n            ),\n            secsPerYear\n        );\n    }\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/DefaultRateModel.sol#L70-L77\n\n```solidity\n    function _utilization(uint liquidity, uint borrows)\n        internal\n        pure\n        returns (uint)\n    {\n        uint totalAssets = liquidity + borrows;\n        return (totalAssets == 0) ? 0 : borrows.divWadDown(totalAssets);\n    }\n```\n\n## Impact\n\nPer the docs, when calculating the interest rate, `util` is the ratio of available liquidity to the `borrows`, available liquidity should not include reserves.\n\nThe current implementation is using all the balance as the `liquidity`, this will make the interest rate lower than expectation.\n\n### PoC\n\nGiven:\n\n- `asset.address(this) + borrows = 10000`\n- `reserves = 1500, borrows = 7000`\n\nExpected result:\n\nWhen calculating `getRateFactor()`, available liquidity should be `asset.balanceOf(address(this)) - reserves = 1500, util = 7000 / 8500 = 0.82`, `getBorrowRatePerSecond() = 9114134329`\n\nActual result:\n\nWhen calculating `getRateFactor()`, `asset.balanceOf(address(this)) = 3000, util = 0.7e18`, `getBorrowRatePerSecond() = 7763863430`\n\nThe actual interest rate is only `7763863430 / 9114134329 = 85%` of the expected rate.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe implementation of `getRateFactor()` can be updated to:\n\n```solidity\nfunction getRateFactor() internal view returns (uint) {\n    return (block.timestamp == lastUpdated) ?\n        0 :\n        ((block.timestamp - lastUpdated)*1e18)\n        .mulWadUp(\n            rateModel.getBorrowRatePerSecond(\n                asset.balanceOf(address(this)) - reserves,\n                borrows\n            )\n        );\n}\n```\n\n## Sentiment Team\nRemoved reserves from LToken and added an alternate mechanism to collect direct fees.\n\n## Lead Senior Watson\noriginationFee may result in the borrower account becoming liquidatable immediately (aka WP-M2).\n\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/protocol/pull/236). \n\n## Lead Senior Watson\nriskEngine.isBorrowAllowed should be removed as it's no longer needed.\n\n## Sentiment Team\nPushed a commit to remove the redundant call to riskEngine. PR [here](https://github.com/sentimentxyz/protocol/pull/236/commits/bfc445b02784f8130181641ce0054382b4cc3ec5\n). \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "src/tokens/LToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"./utils/ERC4626.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\n\n/**\n    @title Lending Token\n    @notice Lending token with ERC4626 implementation\n*/\ncontract LToken is Pausable, ERC4626, ILToken {\n    using FixedPointMathLib for uint;\n    using SafeTransferLib for ERC20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Rate Model\n    IRateModel public rateModel;\n\n    /// @notice Account Manager\n    address public accountManager;\n\n    /// @notice Protocol treasury\n    address public treasury;\n\n    /// @notice Total amount of borrows\n    uint public borrows;\n\n    /// @notice Timestamp of when the state of the LToken was last updated\n    uint public lastUpdated;\n\n    /// @notice Protocol reserves\n    uint public reserves;\n\n    /// @notice Reserve factor\n    uint public reserveFactor;\n\n    /// @notice Total borrow shares minted\n    uint public totalBorrowShares;\n\n    /// @notice Mapping of account to borrow in terms of shares\n    mapping (address => uint) public borrowsOf;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event ReservesRedeemed(address indexed treasury, uint amt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract initialization function\n        @dev Can only be invoked once\n        @param _asset Underlying ERC20 token\n        @param _name Name of LToken\n        @param _symbol Symbol of LToken\n        @param _registry Address of Registry\n        @param _reserveFactor Borrow Fee\n        @param _treasury Protocol treasury\n    */\n    function init(\n        ERC20 _asset,\n        string calldata _name,\n        string calldata _symbol,\n        IRegistry _registry,\n        uint _reserveFactor,\n        address _treasury\n    ) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n\n        if (\n            address(_asset) == address(0) ||\n            address(_registry) == address(0) ||\n            _treasury == address(0)\n        ) revert Errors.ZeroAddress();\n\n        initialized = true;\n        initPausable(msg.sender);\n        initERC4626(_asset, _name, _symbol);\n        registry = _registry;\n        reserveFactor = _reserveFactor;\n        treasury = _treasury;\n    }\n\n    /**\n        @notice Initializes external dependencies\n        @param _rateModel Name of rate model contract\n    */\n    function initDep(string calldata _rateModel) external adminOnly {\n        rateModel = IRateModel(registry.getAddress(_rateModel));\n        accountManager = registry.getAddress('ACCOUNT_MANAGER');\n    }\n\n    /**\n        @notice Lends a specified amount of underlying asset to an account\n        @param account Address of account\n        @param amt Amount of token to lend\n        @return isFirstBorrow Returns if the account is borrowing the asset for\n            the first time\n    */\n    function lendTo(address account, uint amt)\n        external\n        whenNotPaused\n        accountManagerOnly\n        returns (bool isFirstBorrow)\n    {\n        updateState();\n        isFirstBorrow = (borrowsOf[account] == 0);\n\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        totalBorrowShares += borrowShares;\n        borrowsOf[account] += borrowShares;\n\n        borrows += amt;\n        asset.safeTransfer(account, amt);\n        return isFirstBorrow;\n    }\n\n    /**\n        @notice Collects a specified amount of underlying asset from an account\n        @param account Address of account\n        @param amt Amount of token to collect\n        @return bool Returns true if account has no debt\n    */\n    function collectFrom(address account, uint amt)\n        external\n        accountManagerOnly\n        returns (bool)\n    {\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        borrowsOf[account] -= borrowShares;\n        totalBorrowShares -= borrowShares;\n\n        borrows -= amt;\n        return (borrowsOf[account] == 0);\n    }\n\n    /**\n        @notice Returns Borrow balance of given account\n        @param account Address of account\n        @return borrowBalance Amount of underlying tokens borrowed\n    */\n    function getBorrowBalance(address account) external view returns (uint) {\n        return convertBorrowSharesToAsset(borrowsOf[account]);\n    }\n\n    function getReserves() public view returns (uint) {\n        return reserves + borrows.mulWadUp(getRateFactor())\n        .mulWadUp(reserveFactor);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Returns total amount of underlying assets\n            totalAssets = underlying balance + totalBorrows + delta\n            delta = totalBorrows * RateFactor\n        @return totalAssets Total amount of underlying assets\n    */\n    function totalAssets() public view override returns (uint) {\n        return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n    }\n\n    function getBorrows() public view returns (uint) {\n        return borrows + borrows.mulWadUp(getRateFactor());\n    }\n\n    /// @notice Updates state of the lending pool\n    function updateState() public {\n        if (lastUpdated == block.timestamp) return;\n        uint rateFactor = getRateFactor();\n        uint interestAccrued = borrows.mulWadUp(rateFactor);\n        borrows += interestAccrued;\n        reserves += interestAccrued.mulWadUp(reserveFactor);\n        lastUpdated = block.timestamp;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Rate Factor = Timestamp Delta * 1e18 (Scales timestamp delta to 18 decimals) * Interest Rate Per Block\n            Timestamp Delta = Number of seconds since last update\n    */\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n\n    function convertAssetToBorrowShares(uint amt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? amt : amt.mulDivUp(supply, getBorrows());\n    }\n\n    function convertBorrowSharesToAsset(uint debt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? debt : debt.mulDivDown(getBorrows(), supply);\n    }\n\n    function beforeDeposit(uint, uint) internal override { updateState(); }\n    function beforeWithdraw(uint, uint) internal override { updateState(); }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    function redeemReserves(uint amt) external adminOnly {\n        updateState();\n        reserves -= amt;\n        emit ReservesRedeemed(treasury, amt);\n        asset.safeTransfer(treasury, amt);\n    }\n}"
    },
    {
      "filename": "src/core/DefaultRateModel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n    @title Default Rate Model\n    @notice Rate model contract used by Lending pools to calculate borrow rate\n    per block\n*/\ncontract DefaultRateModel is IRateModel {\n    using FixedPointMathLib for uint;\n\n    /// @notice Constant coefficients with 18 decimals\n    uint immutable c1;\n    uint immutable c2;\n    uint immutable c3;\n\n    /// @notice Number of seconds per year\n    uint immutable secsPerYear;\n\n    uint constant SCALE = 1e18;\n\n    /**\n        @notice Contract constructor\n        @param _c1 constant coefficient, default value = 1 * 1e17\n        @param _c2 constant coefficient, default value = 3 * 1e17\n        @param _c3 constant coefficient, default value = 35 * 1e17\n        @param _secsPerYear secs in a year, default value = 31556952 * 1e18\n    */\n    constructor(uint _c1, uint _c2, uint _c3, uint _secsPerYear) {\n        if (_c1 == 0 || _c2 == 0 || _c3 == 0 || _secsPerYear == 0)\n            revert Errors.IncorrectConstructorArgs();\n        c1 = _c1;\n        c2 = _c2;\n        c3 = _c3;\n        secsPerYear = _secsPerYear;\n    }\n\n    /**\n        @notice Calculates Borrow rate per second\n        Borrow Rate Per Second =\n        c3 * (util * c1 + util^32 * c1 + util^64 * c2) / secsPerYear\n        where util = borrows / (liquidity + borrows)\n        @param liquidity total balance of the underlying asset in the pool\n        @param borrows balance of underlying assets borrowed from the pool\n        @return uint borrow rate per sec\n    */\n    function getBorrowRatePerSecond(\n        uint liquidity,\n        uint borrows\n    )\n        external\n        view\n        returns (uint)\n    {\n        uint util = _utilization(liquidity, borrows);\n        return c3.mulDivDown(\n            (\n                util.mulWadDown(c1)\n                + util.rpow(32, SCALE).mulWadDown(c1)\n                + util.rpow(64, SCALE).mulWadDown(c2)\n            ),\n            secsPerYear\n        );\n    }\n\n    function _utilization(uint liquidity, uint borrows)\n        internal\n        pure\n        returns (uint)\n    {\n        uint totalAssets = liquidity + borrows;\n        return (totalAssets == 0) ? 0 : borrows.divWadDown(totalAssets);\n    }\n}"
    },
    {
      "filename": "src/core/DefaultRateModel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n    @title Default Rate Model\n    @notice Rate model contract used by Lending pools to calculate borrow rate\n    per block\n*/\ncontract DefaultRateModel is IRateModel {\n    using FixedPointMathLib for uint;\n\n    /// @notice Constant coefficients with 18 decimals\n    uint immutable c1;\n    uint immutable c2;\n    uint immutable c3;\n\n    /// @notice Number of seconds per year\n    uint immutable secsPerYear;\n\n    uint constant SCALE = 1e18;\n\n    /**\n        @notice Contract constructor\n        @param _c1 constant coefficient, default value = 1 * 1e17\n        @param _c2 constant coefficient, default value = 3 * 1e17\n        @param _c3 constant coefficient, default value = 35 * 1e17\n        @param _secsPerYear secs in a year, default value = 31556952 * 1e18\n    */\n    constructor(uint _c1, uint _c2, uint _c3, uint _secsPerYear) {\n        if (_c1 == 0 || _c2 == 0 || _c3 == 0 || _secsPerYear == 0)\n            revert Errors.IncorrectConstructorArgs();\n        c1 = _c1;\n        c2 = _c2;\n        c3 = _c3;\n        secsPerYear = _secsPerYear;\n    }\n\n    /**\n        @notice Calculates Borrow rate per second\n        Borrow Rate Per Second =\n        c3 * (util * c1 + util^32 * c1 + util^64 * c2) / secsPerYear\n        where util = borrows / (liquidity + borrows)\n        @param liquidity total balance of the underlying asset in the pool\n        @param borrows balance of underlying assets borrowed from the pool\n        @return uint borrow rate per sec\n    */\n    function getBorrowRatePerSecond(\n        uint liquidity,\n        uint borrows\n    )\n        external\n        view\n        returns (uint)\n    {\n        uint util = _utilization(liquidity, borrows);\n        return c3.mulDivDown(\n            (\n                util.mulWadDown(c1)\n                + util.rpow(32, SCALE).mulWadDown(c1)\n                + util.rpow(64, SCALE).mulWadDown(c2)\n            ),\n            secsPerYear\n        );\n    }\n\n    function _utilization(uint liquidity, uint borrows)\n        internal\n        pure\n        returns (uint)\n    {\n        uint totalAssets = liquidity + borrows;\n        return (totalAssets == 0) ? 0 : borrows.divWadDown(totalAssets);\n    }\n}"
    }
  ]
}