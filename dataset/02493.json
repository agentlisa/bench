{
  "Title": "M-18: user can drawDebt that is below dust amount",
  "Content": "# Issue M-18: user can drawDebt that is below dust amount \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/70 \n\n## Found by \nkoxuan\n\n## Summary\nAccording to the protocol, drawDebt prevents user from drawing below the `quoteDust_` amount. However, a logical error in the code can allow user to draw below dust amount.\n\n## Vulnerability Detail\n`_revertOnMinDebt` is used in `drawDebt` to prevent dust loans. As you can see, the protocol wants to take the average of debt in the pool and make it the minimum if there are 10 or more loans. If it is lower than 10 loans, a `quoteDust` is used as the minimum. There is an edge case, whereby there are 10 loans in the pool, and the borrowers repay the loans till there is only 1 unit owed for each loan.(Might revert due to rounding error but it is describing a situation whereby repaying till a low amount of poolDebt can enable this). A new borrower can then `drawDebt` and because `_revertOnMindebt` only goes through the average loan amount check and not the `quoteDust_` amount check, he/she is able to draw loan that is well below the `quoteDust_` amount.\n\n```solidity\n    function _revertOnMinDebt(\n        LoansState storage loans_,\n        uint256 poolDebt_,\n        uint256 borrowerDebt_,\n        uint256 quoteDust_\n    ) view {\n        if (borrowerDebt_ != 0) {\n            uint256 loansCount = Loans.noOfLoans(loans_);\n            if (loansCount >= 10) {\n                if (borrowerDebt_ < _minDebtAmount(poolDebt_, loansCount)) revert AmountLTMinDebt();\n            } else {\n                if (borrowerDebt_ < quoteDust_)                            revert DustAmountNotExceeded();\n            }\n        }\n    }\n\n```\n\n```solidity\n    function _minDebtAmount(\n        uint256 debt_,\n        uint256 loansCount_\n    ) pure returns (uint256 minDebtAmount_) {\n        if (loansCount_ != 0) {\n            minDebtAmount_ = Maths.wdiv(Maths.wdiv(debt_, Maths.wad(loansCount_)), 10**19);\n        }\n    }\n\n```\n## Impact\nA minimum loan amount is used to deter dust loans, which can diminish user experience.\n\n## Code Snippet\n[BorrowerActions.sol#173](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/BorrowerActions.sol#L173)\n[RevertsHelper.sol#L61-L75](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/helpers/RevertsHelper.sol#L61-L75)\n[PoolHelper.sol#L100-L107](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/helpers/PoolHelper.sol#L100-L107)\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRecommend checking that loan amount is more than `quoteDust_` regardless of the loan count.\n\n```solidity\n    function _revertOnMinDebt(\n        LoansState storage loans_,\n        uint256 poolDebt_,\n        uint256 borrowerDebt_,\n        uint256 quoteDust_\n    ) view {\n        if (borrowerDebt_ != 0) {\n            uint256 loansCount = Loans.noOfLoans(loans_);\n            if (loansCount >= 10) {\n                if (borrowerDebt_ < _minDebtAmount(poolDebt_, loansCount)) revert AmountLTMinDebt();\n            } \n            if (borrowerDebt_ < quoteDust_) revert DustAmountNotExceeded();\n            \n        }\n    }\n\n```\n\n\n\n## Discussion\n\n**EdNoepel**\n\nEdge case discussed in the fourth sentence is invalid.  Repayment performs a check to ensure remaining debt is also above the minimum debt amount (or 0).  ~~As such, there is no way for `_minDebtAmount` to return a number smaller than the dust amount.~~\n\nHowever, since `_minDebtAmount` is 10% of the average, one could game the system.  Upon pool creation, the attacker creates 10 EOAs, and draws debt at the dust limit from each of them.  Now the pool is in a state where the minimum debt is 10% of the dust limit.\n\nI do not see how this would give the attacker a material advantage, but agree it should be remedied regardless.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/libraries/external/BorrowerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    LoansState,\n    PoolState\n}                   from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    DrawDebtResult,\n    RepayDebtResult\n}                   from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _feeRate,\n    _priceAt,\n    _isCollateralized\n}                           from '../helpers/PoolHelper.sol';\nimport { _revertOnMinDebt } from '../helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\nimport { Auctions } from './Auctions.sol';\n\n/**\n    @title  BorrowerActions library\n    @notice External library containing logic for for pool actors:\n            - Borrowers: pledge collateral and draw debt; repay debt and pull collateral\n */\nlibrary BorrowerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    struct DrawDebtLocalVars {\n        uint256 borrowerDebt; // [WAD] borrower's accrued debt\n        uint256 debtChange;   // [WAD] additional debt resulted from draw debt action\n        bool    inAuction;    // true if loan is auctioned\n        uint256 lupId;        // id of new LUP\n        bool    stampT0Np;    // true if loan's t0 neutral price should be restamped (when drawing debt or pledge settles auction)\n    }\n    struct RepayDebtLocalVars {\n        uint256 borrowerDebt;          // [WAD] borrower's accrued debt\n        bool    inAuction;             // true if loan still in auction after repay, false otherwise\n        uint256 newLup;                // [WAD] LUP after repay debt action\n        bool    pull;                  // true if pull action\n        bool    repay;                 // true if repay action\n        bool    stampT0Np;             // true if loan's t0 neutral price should be restamped (when repay settles auction or pull collateral)\n        uint256 t0DebtInAuctionChange; // [WAD] t0 change amount of debt after repayment\n        uint256 t0RepaidDebt;          // [WAD] t0 debt repaid\n    }\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error BorrowerNotSender();\n    error BorrowerUnderCollateralized();\n    error InsufficientCollateral();\n    error LimitIndexReached();\n    error NoDebt();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IERC20PoolBorrowerActions` and `IERC721PoolBorrowerActions` for descriptions\n     *  @dev    write state:\n     *              - Auctions._settleAuction:\n     *                  - _removeAuction:\n     *                      - decrement kicker locked accumulator, increment kicker claimable accumumlator\n     *                      - decrement auctions count accumulator\n     *                      - decrement auctions.totalBondEscrowed accumulator\n     *                      - update auction queue state\n     *              - Loans.update:\n     *                  - _upsert:\n     *                      - insert or update loan in loans array\n     *                  - remove:\n     *                      - remove loan from loans array\n     *                  - update borrower in address => borrower mapping\n     *  @dev    reverts on:\n     *              - borrower not sender BorrowerNotSender()\n     *              - borrower debt less than pool min debt AmountLTMinDebt()\n     *              - limit price reached LimitIndexReached()\n     *              - borrower cannot draw more debt BorrowerUnderCollateralized()\n     *  @dev    emit events:\n     *              - Auctions._settleAuction:\n     *                  - AuctionNFTSettle or AuctionSettle\n     */\n    function drawDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external returns (\n        DrawDebtResult memory result_\n    ) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        result_.poolDebt       = poolState_.debt;\n        result_.newLup         = _lup(deposits_, result_.poolDebt);\n        result_.poolCollateral = poolState_.collateral;\n\n        DrawDebtLocalVars memory vars;\n\n        vars.borrowerDebt = Maths.wmul(borrower.t0Debt, poolState_.inflator);\n\n        // pledge collateral to pool\n        if (collateralToPledge_ != 0) {\n            // add new amount of collateral to pledge to borrower balance\n            borrower.collateral  += collateralToPledge_;\n\n            // load loan's auction state\n            vars.inAuction = _inAuction(auctions_, borrowerAddress_);\n            // if loan is auctioned and becomes collateralized by newly pledged collateral then settle auction\n            if (\n                vars.inAuction &&\n                _isCollateralized(vars.borrowerDebt, borrower.collateral, result_.newLup, poolState_.poolType)\n            ) {\n                // borrower becomes collateralized\n                vars.inAuction = false;\n                vars.stampT0Np = true;  // stamp borrower t0Np when exiting from auction\n\n                result_.settledAuction = true;\n\n                // remove debt from pool accumulator and settle auction\n                result_.t0DebtInAuctionChange = borrower.t0Debt;\n\n                // settle auction and update borrower's collateral with value after settlement\n                result_.remainingCollateral = Auctions._settleAuction(\n                    auctions_,\n                    buckets_,\n                    deposits_,\n                    borrowerAddress_,\n                    borrower.collateral,\n                    poolState_.poolType\n                );\n\n                borrower.collateral = result_.remainingCollateral;\n            }\n\n            // add new amount of collateral to pledge to pool balance\n            result_.poolCollateral += collateralToPledge_;\n        }\n\n        // borrow against pledged collateral\n        // check both values to enable an intentional 0 borrow loan call to update borrower's loan state\n        if (amountToBorrow_ != 0 || limitIndex_ != 0) {\n            // only intended recipient can borrow quote\n            if (borrowerAddress_ != msg.sender) revert BorrowerNotSender();\n\n            // add origination fee to the amount to borrow and add to borrower's debt\n            vars.debtChange = Maths.wmul(amountToBorrow_, _feeRate(poolState_.rate) + Maths.WAD);\n\n            vars.borrowerDebt += vars.debtChange;\n\n            // check that drawing debt doesn't leave borrower debt under min debt amount\n            _revertOnMinDebt(loans_, result_.poolDebt, vars.borrowerDebt, poolState_.quoteDustLimit);\n\n            // add debt change to pool's debt\n            result_.poolDebt += vars.debtChange;\n\n            // determine new lup index and revert if borrow happens at a price higher than the specified limit (lower index than lup index)\n            vars.lupId = _lupIndex(deposits_, result_.poolDebt);\n            if (vars.lupId > limitIndex_) revert LimitIndexReached();\n\n            // calculate new lup and check borrow action won't push borrower into a state of under-collateralization\n            // this check also covers the scenario when loan is already auctioned\n            result_.newLup = _priceAt(vars.lupId);\n\n            if (!_isCollateralized(vars.borrowerDebt, borrower.collateral, result_.newLup, poolState_.poolType)) {\n                revert BorrowerUnderCollateralized();\n            }\n\n            // stamp borrower t0Np when draw debt\n            vars.stampT0Np = true;\n\n            result_.t0DebtChange = Maths.wdiv(vars.debtChange, poolState_.inflator);\n\n            borrower.t0Debt += result_.t0DebtChange;\n        }\n\n        // update loan state\n        Loans.update(\n            loans_,\n            auctions_,\n            deposits_,\n            borrower,\n            borrowerAddress_,\n            vars.borrowerDebt,\n            poolState_.rate,\n            result_.newLup,\n            vars.inAuction,\n            vars.stampT0Np\n        );\n    }\n\n    /**\n     *  @notice See `IERC20PoolBorrowerActions` and `IERC721PoolBorrowerActions` for descriptions\n     *  @dev    write state:\n     *              - Auctions._settleAuction:\n     *                  - _removeAuction:\n     *                      - decrement kicker locked accumulator, increment kicker claimable accumumlator\n     *                      - decrement auctions count accumulator\n     *                      - decrement auctions.totalBondEscrowed accumulator\n     *                      - update auction queue state\n     *              - Loans.update:\n     *                  - _upsert:\n     *                      - insert or update loan in loans array\n     *                  - remove:\n     *                      - remove loan from loans array\n     *                  - update borrower in address => borrower mapping\n     *  @dev    reverts on:\n     *              - no debt to repay NoDebt()\n     *              - borrower debt less than pool min debt AmountLTMinDebt()\n     *              - borrower not sender BorrowerNotSender()\n     *              - not enough collateral to pull InsufficientCollateral()\n     *  @dev    emit events:\n     *              - Auctions._settleAuction:\n     *                  - AuctionNFTSettle or AuctionSettle\n     */\n    function repayDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_\n    ) external returns (\n        RepayDebtResult memory result_\n    ) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        RepayDebtLocalVars memory vars;\n\n        vars.repay        = maxQuoteTokenAmountToRepay_ != 0;\n        vars.pull         = collateralAmountToPull_ != 0;\n        vars.borrowerDebt = Maths.wmul(borrower.t0Debt, poolState_.inflator);\n\n        result_.poolDebt       = poolState_.debt;\n        result_.poolCollateral = poolState_.collateral;\n\n        if (vars.repay) {\n            if (borrower.t0Debt == 0) revert NoDebt();\n\n            if (maxQuoteTokenAmountToRepay_ == type(uint256).max) {\n                result_.t0RepaidDebt = borrower.t0Debt;\n            } else {\n                result_.t0RepaidDebt = Maths.min(\n                    borrower.t0Debt,\n                    Maths.wdiv(maxQuoteTokenAmountToRepay_, poolState_.inflator)\n                );\n            }\n\n            result_.quoteTokenToRepay = Maths.wmul(result_.t0RepaidDebt, poolState_.inflator);\n\n            result_.poolDebt -= result_.quoteTokenToRepay;\n            vars.borrowerDebt -= result_.quoteTokenToRepay;\n\n            // check that paying the loan doesn't leave borrower debt under min debt amount\n            _revertOnMinDebt(loans_, result_.poolDebt, vars.borrowerDebt, poolState_.quoteDustLimit);\n\n            result_.newLup = _lup(deposits_, result_.poolDebt);\n            vars.inAuction = _inAuction(auctions_, borrowerAddress_);\n\n            if (vars.inAuction) {\n                if (_isCollateralized(vars.borrowerDebt, borrower.collateral, result_.newLup, poolState_.poolType)) {\n                    // borrower becomes re-collateralized\n                    vars.inAuction = false;\n                    vars.stampT0Np = true;  // stamp borrower t0Np when exiting from auction\n\n                    result_.settledAuction = true;\n\n                    // remove entire borrower debt from pool auctions debt accumulator\n                    result_.t0DebtInAuctionChange = borrower.t0Debt;\n\n                    // settle auction and update borrower's collateral with value after settlement\n                    result_.remainingCollateral = Auctions._settleAuction(\n                        auctions_,\n                        buckets_,\n                        deposits_,\n                        borrowerAddress_,\n                        borrower.collateral,\n                        poolState_.poolType\n                    );\n\n                    borrower.collateral = result_.remainingCollateral;\n                } else {\n                    // partial repay, remove only the paid debt from pool auctions debt accumulator\n                    result_.t0DebtInAuctionChange = result_.t0RepaidDebt;\n                }\n            }\n\n            borrower.t0Debt -= result_.t0RepaidDebt;\n        }\n\n        if (vars.pull) {\n            // only intended recipient can pull collateral\n            if (borrowerAddress_ != msg.sender) revert BorrowerNotSender();\n\n            // calculate LUP only if it wasn't calculated by repay action\n            if (!vars.repay) result_.newLup = _lup(deposits_, result_.poolDebt);\n\n            uint256 encumberedCollateral = borrower.t0Debt != 0 ? Maths.wdiv(vars.borrowerDebt, result_.newLup) : 0;\n\n            if (borrower.collateral - encumberedCollateral < collateralAmountToPull_) revert InsufficientCollateral();\n\n            // stamp borrower t0Np when pull collateral action\n            vars.stampT0Np = true;\n\n            borrower.collateral    -= collateralAmountToPull_;\n            result_.poolCollateral -= collateralAmountToPull_;\n        }\n\n        // calculate LUP if repay is called with 0 amount\n        if (!vars.repay && !vars.pull) {\n            result_.newLup = _lup(deposits_, result_.poolDebt);\n        }\n\n        // update loan state\n        Loans.update(\n            loans_,\n            auctions_,\n            deposits_,\n            borrower,\n            borrowerAddress_,\n            vars.borrowerDebt,\n            poolState_.rate,\n            result_.newLup,\n            vars.inAuction,\n            vars.stampT0Np\n        );\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /**\n     *  @notice Returns true if borrower is in auction.\n     *  @dev    Used to accuratley increment and decrement t0DebtInAuction.\n     *  @param  borrower_ Borrower address to check auction status for.\n     *  @return  active_ Boolean, based on if borrower is in auction.\n     */\n    function _inAuction(\n        AuctionsState storage auctions_,\n        address borrower_\n    ) internal view returns (bool) {\n        return auctions_.liquidations[borrower_].kickTime != 0;\n    }\n\n    function _lupIndex(\n        DepositsState storage deposits_,\n        uint256 debt_\n    ) internal view returns (uint256) {\n        return Deposits.findIndexOfSum(deposits_, debt_);\n    }\n\n    function _lup(\n        DepositsState storage deposits_,\n        uint256 debt_\n    ) internal view returns (uint256) {\n        return _priceAt(_lupIndex(deposits_, debt_));\n    }\n\n}"
    },
    {
      "filename": "contracts/src/libraries/helpers/RevertsHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport {\n    AuctionsState,\n    Borrower,\n    DepositsState,\n    LoansState,\n    PoolBalancesState\n} from '../../interfaces/pool/commons/IPoolState.sol';\n\nimport { _minDebtAmount } from './PoolHelper.sol';\n\nimport { Loans }    from '../internal/Loans.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n    // See `IPoolErrors` for descriptions\n    error AuctionNotCleared();\n    error AmountLTMinDebt();\n    error DustAmountNotExceeded();\n    error RemoveDepositLockedByAuctionDebt();\n\n    /**\n     *  @notice Called by LPB removal functions assess whether or not LPB is locked.\n     *  @param  index_    The deposit index from which LPB is attempting to be removed.\n     *  @param  inflator_ The pool inflator used to properly assess t0 debt in auctions.\n     */\n    function _revertIfAuctionDebtLocked(\n        DepositsState storage deposits_,\n        PoolBalancesState storage poolBalances_,\n        uint256 index_,\n        uint256 inflator_\n    ) view {\n        uint256 t0AuctionDebt = poolBalances_.t0DebtInAuction;\n        if (t0AuctionDebt != 0 ) {\n            // deposit in buckets within liquidation debt from the top-of-book down are frozen.\n            if (index_ <= Deposits.findIndexOfSum(deposits_, Maths.wmul(t0AuctionDebt, inflator_))) revert RemoveDepositLockedByAuctionDebt();\n        } \n    }\n\n    /**\n     *  @notice Check if head auction is clearable (auction is kicked and 72 hours passed since kick time or auction still has debt but no remaining collateral).\n     *  @notice Revert if auction is clearable\n     */\n    function _revertIfAuctionClearable(\n        AuctionsState storage auctions_,\n        LoansState    storage loans_\n    ) view {\n        address head     = auctions_.head;\n        uint256 kickTime = auctions_.liquidations[head].kickTime;\n        if (kickTime != 0) {\n            if (block.timestamp - kickTime > 72 hours) revert AuctionNotCleared();\n\n            Borrower storage borrower = loans_.borrowers[head];\n            if (borrower.t0Debt != 0 && borrower.collateral == 0) revert AuctionNotCleared();\n        }\n    }\n\n    function _revertOnMinDebt(\n        LoansState storage loans_,\n        uint256 poolDebt_,\n        uint256 borrowerDebt_,\n        uint256 quoteDust_\n    ) view {\n        if (borrowerDebt_ != 0) {\n            uint256 loansCount = Loans.noOfLoans(loans_);\n            if (loansCount >= 10) {\n                if (borrowerDebt_ < _minDebtAmount(poolDebt_, loansCount)) revert AmountLTMinDebt();\n            } else {\n                if (borrowerDebt_ < quoteDust_)                            revert DustAmountNotExceeded();\n            }\n        }\n    }"
    },
    {
      "filename": "contracts/src/libraries/helpers/PoolHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport { Buckets } from '../internal/Buckets.sol';\nimport { Maths }   from '../internal/Maths.sol';\n\n    error BucketIndexOutOfBounds();\n    error BucketPriceOutOfBounds();\n\n    /*************************/\n    /*** Price Conversions ***/\n    /*************************/\n\n    /**\n        @dev constant price indices defining the min and max of the potential price range\n     */\n    int256  constant MAX_BUCKET_INDEX  =  4_156;\n    int256  constant MIN_BUCKET_INDEX  = -3_232;\n    uint256 constant MAX_FENWICK_INDEX =  7_388;\n\n    uint256 constant MIN_PRICE = 99_836_282_890;\n    uint256 constant MAX_PRICE = 1_004_968_987.606512354182109771 * 1e18;\n    /**\n        @dev step amounts in basis points. This is a constant across pools at .005, achieved by dividing WAD by 10,000\n     */\n    int256 constant FLOAT_STEP_INT = 1.005 * 1e18;\n\n    /**\n     *  @notice Calculates the price for a given Fenwick index\n     *  @dev    Throws if index exceeds maximum constant\n     *  @dev    Uses fixed-point math to get around lack of floating point numbers in EVM\n     *  @dev    Price expected to be inputted as a 18 decimal WAD\n     *  @dev    Fenwick index is converted to bucket index\n     *  @dev    Fenwick index to bucket index conversion\n     *          1.00      : bucket index 0,     fenwick index 4146: 7388-4156-3232=0\n     *          MAX_PRICE : bucket index 4156,  fenwick index 0:    7388-0-3232=4156.\n     *          MIN_PRICE : bucket index -3232, fenwick index 7388: 7388-7388-3232=-3232.\n     *  @dev    V1: price = MIN_PRICE + (FLOAT_STEP * index)\n     *          V2: price = MAX_PRICE * (FLOAT_STEP ** (abs(int256(index - MAX_PRICE_INDEX))));\n     *          V3 (final): x^y = 2^(y*log_2(x))\n     */\n    function _priceAt(\n        uint256 index_\n    ) pure returns (uint256) {\n        // Lowest Fenwick index is highest price, so invert the index and offset by highest bucket index.\n        int256 bucketIndex = MAX_BUCKET_INDEX - int256(index_);\n        if (bucketIndex < MIN_BUCKET_INDEX || bucketIndex > MAX_BUCKET_INDEX) revert BucketIndexOutOfBounds();\n\n        return uint256(\n            PRBMathSD59x18.exp2(\n                PRBMathSD59x18.mul(\n                    PRBMathSD59x18.fromInt(bucketIndex),\n                    PRBMathSD59x18.log2(FLOAT_STEP_INT)\n                )\n            )\n        );\n    }\n\n    /**\n     *  @notice Calculates the Fenwick index for a given price\n     *  @dev    Throws if price exceeds maximum constant\n     *  @dev    Price expected to be inputted as a 18 decimal WAD\n     *  @dev    V1: bucket index = (price - MIN_PRICE) / FLOAT_STEP\n     *          V2: bucket index = (log(FLOAT_STEP) * price) /  MAX_PRICE\n     *          V3 (final): bucket index =  log_2(price) / log_2(FLOAT_STEP)\n     *  @dev    Fenwick index = 7388 - bucket index + 3232\n     */\n    function _indexOf(\n        uint256 price_\n    ) pure returns (uint256) {\n        if (price_ < MIN_PRICE || price_ > MAX_PRICE) revert BucketPriceOutOfBounds();\n\n        int256 index = PRBMathSD59x18.div(\n            PRBMathSD59x18.log2(int256(price_)),\n            PRBMathSD59x18.log2(FLOAT_STEP_INT)\n        );\n\n        int256 ceilIndex = PRBMathSD59x18.ceil(index);\n        if (index < 0 && ceilIndex - index > 0.5 * 1e18) {\n            return uint256(4157 - PRBMathSD59x18.toInt(ceilIndex));\n        }\n        return uint256(4156 - PRBMathSD59x18.toInt(ceilIndex));\n    }\n\n    /**********************/\n    /*** Pool Utilities ***/\n    /**********************/\n\n    /**\n     *  @notice Calculates the minimum debt amount that can be borrowed or can remain in a loan in pool.\n     *  @param  debt_          The debt amount to calculate minimum debt amount for.\n     *  @param  loansCount_    The number of loans in pool.\n     *  @return minDebtAmount_ Minimum debt amount value of the pool.\n     */\n    function _minDebtAmount(\n        uint256 debt_,\n        uint256 loansCount_\n    ) pure returns (uint256 minDebtAmount_) {\n        if (loansCount_ != 0) {\n            minDebtAmount_ = Maths.wdiv(Maths.wdiv(debt_, Maths.wad(loansCount_)), 10**19);\n        }\n    }\n\n    /**\n     *  @notice Calculates fee rate for a given interest rate.\n     *  @notice Calculated as greater of the current annualized interest rate divided by 52 (one week of interest) or 5 bps.\n     *  @param  interestRate_ The current interest rate.\n     *  @return Fee rate applied to the given interest rate.\n     */\n    function _feeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // greater of the current annualized interest rate divided by 52 (one week of interest) or 5 bps\n        return Maths.max(Maths.wdiv(interestRate_, 52 * 1e18), 0.0005 * 1e18);\n    }\n\n    /**\n     *  @notice Calculates Pool Threshold Price (PTP) for a given debt and collateral amount.\n     *  @param  debt_       The debt amount to calculate PTP for.\n     *  @param  collateral_ The amount of collateral to calculate PTP for.\n     *  @return ptp_        Pool Threshold Price value.\n     */\n    function _ptp(\n        uint256 debt_,\n        uint256 collateral_\n    ) pure returns (uint256 ptp_) {\n        if (collateral_ != 0) ptp_ = Maths.wdiv(debt_, collateral_);\n    }\n\n    /**\n     *  @notice Collateralization calculation.\n     *  @param debt_       Debt to calculate collateralization for.\n     *  @param collateral_ Collateral to calculate collateralization for.\n     *  @param price_      Price to calculate collateralization for.\n     *  @param type_       Type of the pool.\n     *  @return True if collateralization calculated is equal or greater than 1.\n     */\n    function _isCollateralized(\n        uint256 debt_,\n        uint256 collateral_,\n        uint256 price_,\n        uint8 type_\n    ) pure returns (bool) {\n        if (type_ == uint8(PoolType.ERC20)) return Maths.wmul(collateral_, price_) >= debt_;\n        else {\n            //slither-disable-next-line divide-before-multiply\n            collateral_ = (collateral_ / Maths.WAD) * Maths.WAD; // use collateral floor\n            return Maths.wmul(collateral_, price_) >= debt_;\n        }\n    }\n\n    /**\n     *  @notice Price precision adjustment used in calculating collateral dust for a bucket.\n     *          To ensure the accuracy of the exchange rate calculation, buckets with smaller prices require\n     *          larger minimum amounts of collateral.  This formula imposes a lower bound independent of token scale.\n     *  @param  bucketIndex_              Index of the bucket, or 0 for encumbered collateral with no bucket affinity.\n     *  @return pricePrecisionAdjustment_ Unscaled integer of the minimum number of decimal places the dust limit requires.\n     */\n    function _getCollateralDustPricePrecisionAdjustment(\n        uint256 bucketIndex_\n    ) pure returns (uint256 pricePrecisionAdjustment_) {\n        // conditional is a gas optimization\n        if (bucketIndex_ > 3900) {\n            int256 bucketOffset = int256(bucketIndex_ - 3900);\n            int256 result = PRBMathSD59x18.sqrt(PRBMathSD59x18.div(bucketOffset * 1e18, int256(36 * 1e18)));\n            pricePrecisionAdjustment_ = uint256(result / 1e18);\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of collateral calculated for the given amount of LPs.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  bucketLPs_        Amount of LPs in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / LPs.\n     *  @param  lenderLPsBalance_ The amount of LPs to calculate collateral for.\n     *  @param  bucketPrice_      Bucket price.\n     *  @return collateralAmount_ Amount of collateral calculated for the given LPs amount.\n     */\n    function _lpsToCollateral(\n        uint256 bucketCollateral_,\n        uint256 bucketLPs_,\n        uint256 deposit_,\n        uint256 lenderLPsBalance_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 collateralAmount_) {\n        // max collateral to lps\n        uint256 rate = Buckets.getExchangeRate(bucketCollateral_, bucketLPs_, deposit_, bucketPrice_);\n\n        collateralAmount_ = Maths.rwdivw(Maths.rmul(lenderLPsBalance_, rate), bucketPrice_);\n\n        if (collateralAmount_ > bucketCollateral_) {\n            // user is owed more collateral than is available in the bucket\n            collateralAmount_ = bucketCollateral_;\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of quote tokens calculated for the given amount of LPs.\n     *  @param  bucketLPs_        Amount of LPs in bucket.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / LPs.\n     *  @param  lenderLPsBalance_ The amount of LPs to calculate quote token amount for.\n     *  @param  maxQuoteToken_    The max quote token amount to calculate LPs for.\n     *  @param  bucketPrice_      Bucket price.\n     *  @return quoteTokenAmount_ Amount of quote tokens calculated for the given LPs amount.\n     */\n    function _lpsToQuoteToken(\n        uint256 bucketLPs_,\n        uint256 bucketCollateral_,\n        uint256 deposit_,\n        uint256 lenderLPsBalance_,\n        uint256 maxQuoteToken_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 quoteTokenAmount_) {\n        uint256 rate = Buckets.getExchangeRate(bucketCollateral_, bucketLPs_, deposit_, bucketPrice_);\n\n        quoteTokenAmount_ = Maths.rayToWad(Maths.rmul(lenderLPsBalance_, rate));\n\n        if (quoteTokenAmount_ > deposit_)       quoteTokenAmount_ = deposit_;\n        if (quoteTokenAmount_ > maxQuoteToken_) quoteTokenAmount_ = maxQuoteToken_;\n    }\n\n    /**\n     *  @notice Rounds a token amount down to the minimum amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of 10.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        scaledAmount_ = (amount_ / tokenScale_) * tokenScale_;\n    }\n\n    /**\n     *  @notice Rounds a token amount up to the next amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of 10.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundUpToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        if (amount_ % tokenScale_ == 0)\n            scaledAmount_ = amount_;\n        else\n            scaledAmount_ = _roundToScale(amount_, tokenScale_) + tokenScale_;\n    }\n\n    /*********************************/\n    /*** Reserve Auction Utilities ***/\n    /*********************************/\n\n    uint256 constant MINUTE_HALF_LIFE    = 0.988514020352896135_356867505 * 1e27;  // 0.5^(1/60)\n\n    function _claimableReserves(\n        uint256 debt_,\n        uint256 poolSize_,\n        uint256 totalBondEscrowed_,\n        uint256 reserveAuctionUnclaimed_,\n        uint256 quoteTokenBalance_\n    ) pure returns (uint256 claimable_) {\n        claimable_ = Maths.wmul(0.995 * 1e18, debt_) + quoteTokenBalance_;\n\n        claimable_ -= Maths.min(claimable_, poolSize_ + totalBondEscrowed_ + reserveAuctionUnclaimed_);\n    }\n\n    function _reserveAuctionPrice(\n        uint256 reserveAuctionKicked_\n    ) view returns (uint256 _price) {\n        if (reserveAuctionKicked_ != 0) {\n            uint256 secondsElapsed   = block.timestamp - reserveAuctionKicked_;\n            uint256 hoursComponent   = 1e27 >> secondsElapsed / 3600;\n            uint256 minutesComponent = Maths.rpow(MINUTE_HALF_LIFE, secondsElapsed % 3600 / 60);\n\n            _price = Maths.rayToWad(1_000_000_000 * Maths.rmul(hoursComponent, minutesComponent));\n        }\n    }"
    }
  ]
}