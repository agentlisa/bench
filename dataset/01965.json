{
  "Title": "H-6: ShortLongSpell#_withdraw checks slippage limit but never applies it making it useless",
  "Content": "# Issue H-6: ShortLongSpell#_withdraw checks slippage limit but never applies it making it useless \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/126 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nSlippage limits protect the protocol in the event that a malicious user wants to extract value via swaps, this is an important protection in the event that a user finds a way to trick collateral requirements. Currently the sell slippage is checked but never applied so it is useless.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nSlippage limit protections are ineffective for ShortLongSpell\n\n## Code Snippet\n\n[ShortLongSpell.sol#L160-L20](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApply sell slippage after it is checked\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is not a valid M/H. The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is not a valid M/H. The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI still think this is a valid issue\n\nsellSlippage checked but not applied\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202\n\n```solidity\n   function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n```\n\nit is true that the slippage is checked but not applied\n\n> The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\nthis is true, but the code should still check the slippage based on the received amount instead of off-chain parameter\n\n\n\n**hrishibhat**\n\nEscalation rejected\n\nValid high\nAgree with the Lead judge comment. \nSlippage must be checked on code whenever possible instead of an off-chain parameter. \n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid high\n> Agree with the Lead judge comment. \n> Slippage must be checked on code whenever possible instead of an off-chain parameter. \n> \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/ShortLongSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BasicSpell.sol\";\n\nimport \"../interfaces/ISoftVault.sol\";\nimport \"../interfaces/IWERC20.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/**\n * @title Short/Long Spell\n * @author BlueberryProtocol\n * @notice Short/Long Spell is the factory contract that\n * defines how Blueberry Protocol interacts for leveraging\n * an asset either long or short\n */\ncontract ShortLongSpell is BasicSpell {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev WERC20\n    IWERC20 public wrapper;\n\n    /// @dev paraswap AugustusSwapper address\n    address public augustusSwapper;\n\n    /// @dev paraswap TokenTransferProxy address\n    address public tokenTransferProxy;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        if (augustusSwapper_ == address(0)) revert Errors.ZERO_ADDRESS();\n        if (tokenTransferProxy_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n        wrapper = IWERC20(werc20_);\n\n        __BasicSpell_init(bank_, werc20_, weth_);\n    }\n\n    /**\n     * @notice Internal function to swap token using paraswap assets\n     * @dev Deposit isolated underlying to Blueberry Money Market,\n     *      Borrow tokens from Blueberry Money Market,\n     *      Swap borrowed token to another token\n     *      Then deposit swapped token to softvault,\n     *\n     */\n    function _deposit(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt;\n        if (strTokenAmt < swapData.expectedAmount)\n            revert Errors.SWAP_FAILED(address(swapToken));\n\n        // 4. Deposit to SoftVault directly\n        _ensureApprove(\n            address(swapToken),\n            address(strategy.vault),\n            strTokenAmt\n        );\n        ISoftVault(strategy.vault).deposit(strTokenAmt);\n\n        // 5. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets\n     */\n    function openPosition(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        if (\n            address(ISoftVault(strategy.vault).uToken()) != param.borrowToken ||\n            swapData.fromToken != param.borrowToken\n        ) revert Errors.INCORRECT_LP(param.borrowToken);\n\n        // 1-3 Swap to strategy underlying token, deposit to softvault\n        _deposit(param, swapData);\n\n        // 4. Put collateral -\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collSize = pos.collateralSize;\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n        }\n\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Internal function to withdraw assets from SoftVault\n     * @dev Withdraw assets from Soft Vault,\n     *      Swap withdrawn assets to debt token,\n     *      Withdraw isolated collaterals from Blueberry Money Market,\n     *      Repay Debt and refund rest to user\n     */\n    function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n\n        Strategy memory strategy = strategies[param.strategyId];\n        ISoftVault vault = ISoftVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Calculate actual amount to remove\n        uint256 amountPosRemove = param.amountPosRemove;\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = vault.balanceOf(address(this));\n        }\n\n        // 2. Withdraw from softvault\n        vault.withdraw(amountPosRemove);\n\n        // 3. Swap strategy token to isolated collateral token\n        {\n            PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        }\n\n        // 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 5. Repay\n        {\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(positionId);\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets\n     */\n    function closePosition(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        if (address(ISoftVault(strategy.vault).uToken()) != swapData.fromToken)\n            revert Errors.INCORRECT_LP(swapData.fromToken);\n\n        address vault = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address posCollToken = pos.collToken;\n        uint256 collId = pos.collId;\n        if (IWERC20(posCollToken).getUnderlyingToken(collId) != vault)\n            revert Errors.INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(werc20))\n            revert Errors.INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n\n        // 2-7. Remove liquidity\n        _withdraw(param, swapData);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param swapToken Address of token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(\n        address swapToken,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(swapToken, maxPosSize);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/libraries/Paraswap/Utils.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nlibrary Utils {\n    /**\n   * @param fromToken Address of the source token\n   * @param fromAmount Amount of source tokens to be swapped\n   * @param toAmount Minimum destination token amount expected out of this swap\n   * @param expectedAmount Expected amount of destination tokens without slippage\n   * @param beneficiary Beneficiary address\n   * 0 then 100% will be transferred to beneficiary. Pass 10000 for 100%\n   * @param path Route to be taken for this swap to take place\n\n   */\n    struct SellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        Utils.Path[] path;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct MegaSwapSellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        Utils.MegaSwapPath[] path;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct SimpleData {\n        address fromToken;\n        address toToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address[] callees;\n        bytes exchangeData;\n        uint256[] startIndexes;\n        uint256[] values;\n        address payable beneficiary;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct Adapter {\n        address payable adapter;\n        uint256 percent;\n        uint256 networkFee;\n        Route[] route;\n    }\n\n    struct Route {\n        uint256 index; //Adapter at which index needs to be used\n        address targetExchange;\n        uint percent;\n        bytes payload;\n        uint256 networkFee; //Network fee is associated with 0xv3 trades\n    }\n\n    struct MegaSwapPath {\n        uint256 fromAmountPercent;\n        Path[] path;\n    }\n\n    struct Path {\n        address to;\n        uint256 totalNetworkFee; //Network fee is associated with 0xv3 trades\n        Adapter[] adapters;\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/libraries/Paraswap/Utils.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nlibrary Utils {\n    /**\n   * @param fromToken Address of the source token\n   * @param fromAmount Amount of source tokens to be swapped\n   * @param toAmount Minimum destination token amount expected out of this swap\n   * @param expectedAmount Expected amount of destination tokens without slippage\n   * @param beneficiary Beneficiary address\n   * 0 then 100% will be transferred to beneficiary. Pass 10000 for 100%\n   * @param path Route to be taken for this swap to take place\n\n   */\n    struct SellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        Utils.Path[] path;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct MegaSwapSellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        Utils.MegaSwapPath[] path;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct SimpleData {\n        address fromToken;\n        address toToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address[] callees;\n        bytes exchangeData;\n        uint256[] startIndexes;\n        uint256[] values;\n        address payable beneficiary;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct Adapter {\n        address payable adapter;\n        uint256 percent;\n        uint256 networkFee;\n        Route[] route;\n    }\n\n    struct Route {\n        uint256 index; //Adapter at which index needs to be used\n        address targetExchange;\n        uint percent;\n        bytes payload;\n        uint256 networkFee; //Network fee is associated with 0xv3 trades\n    }\n\n    struct MegaSwapPath {\n        uint256 fromAmountPercent;\n        Path[] path;\n    }\n\n    struct Path {\n        address to;\n        uint256 totalNetworkFee; //Network fee is associated with 0xv3 trades\n        Adapter[] adapters;\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/ShortLongSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BasicSpell.sol\";\n\nimport \"../interfaces/ISoftVault.sol\";\nimport \"../interfaces/IWERC20.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/**\n * @title Short/Long Spell\n * @author BlueberryProtocol\n * @notice Short/Long Spell is the factory contract that\n * defines how Blueberry Protocol interacts for leveraging\n * an asset either long or short\n */\ncontract ShortLongSpell is BasicSpell {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev WERC20\n    IWERC20 public wrapper;\n\n    /// @dev paraswap AugustusSwapper address\n    address public augustusSwapper;\n\n    /// @dev paraswap TokenTransferProxy address\n    address public tokenTransferProxy;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        if (augustusSwapper_ == address(0)) revert Errors.ZERO_ADDRESS();\n        if (tokenTransferProxy_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n        wrapper = IWERC20(werc20_);\n\n        __BasicSpell_init(bank_, werc20_, weth_);\n    }\n\n    /**\n     * @notice Internal function to swap token using paraswap assets\n     * @dev Deposit isolated underlying to Blueberry Money Market,\n     *      Borrow tokens from Blueberry Money Market,\n     *      Swap borrowed token to another token\n     *      Then deposit swapped token to softvault,\n     *\n     */\n    function _deposit(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt;\n        if (strTokenAmt < swapData.expectedAmount)\n            revert Errors.SWAP_FAILED(address(swapToken));\n\n        // 4. Deposit to SoftVault directly\n        _ensureApprove(\n            address(swapToken),\n            address(strategy.vault),\n            strTokenAmt\n        );\n        ISoftVault(strategy.vault).deposit(strTokenAmt);\n\n        // 5. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets\n     */\n    function openPosition(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        if (\n            address(ISoftVault(strategy.vault).uToken()) != param.borrowToken ||\n            swapData.fromToken != param.borrowToken\n        ) revert Errors.INCORRECT_LP(param.borrowToken);\n\n        // 1-3 Swap to strategy underlying token, deposit to softvault\n        _deposit(param, swapData);\n\n        // 4. Put collateral -\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collSize = pos.collateralSize;\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n        }\n\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Internal function to withdraw assets from SoftVault\n     * @dev Withdraw assets from Soft Vault,\n     *      Swap withdrawn assets to debt token,\n     *      Withdraw isolated collaterals from Blueberry Money Market,\n     *      Repay Debt and refund rest to user\n     */\n    function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n\n        Strategy memory strategy = strategies[param.strategyId];\n        ISoftVault vault = ISoftVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Calculate actual amount to remove\n        uint256 amountPosRemove = param.amountPosRemove;\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = vault.balanceOf(address(this));\n        }\n\n        // 2. Withdraw from softvault\n        vault.withdraw(amountPosRemove);\n\n        // 3. Swap strategy token to isolated collateral token\n        {\n            PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        }\n\n        // 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 5. Repay\n        {\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(positionId);\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets\n     */\n    function closePosition(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        if (address(ISoftVault(strategy.vault).uToken()) != swapData.fromToken)\n            revert Errors.INCORRECT_LP(swapData.fromToken);\n\n        address vault = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address posCollToken = pos.collToken;\n        uint256 collId = pos.collId;\n        if (IWERC20(posCollToken).getUnderlyingToken(collId) != vault)\n            revert Errors.INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(werc20))\n            revert Errors.INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n\n        // 2-7. Remove liquidity\n        _withdraw(param, swapData);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param swapToken Address of token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(\n        address swapToken,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(swapToken, maxPosSize);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/libraries/Paraswap/Utils.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nlibrary Utils {\n    /**\n   * @param fromToken Address of the source token\n   * @param fromAmount Amount of source tokens to be swapped\n   * @param toAmount Minimum destination token amount expected out of this swap\n   * @param expectedAmount Expected amount of destination tokens without slippage\n   * @param beneficiary Beneficiary address\n   * 0 then 100% will be transferred to beneficiary. Pass 10000 for 100%\n   * @param path Route to be taken for this swap to take place\n\n   */\n    struct SellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        Utils.Path[] path;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct MegaSwapSellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        Utils.MegaSwapPath[] path;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct SimpleData {\n        address fromToken;\n        address toToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address[] callees;\n        bytes exchangeData;\n        uint256[] startIndexes;\n        uint256[] values;\n        address payable beneficiary;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct Adapter {\n        address payable adapter;\n        uint256 percent;\n        uint256 networkFee;\n        Route[] route;\n    }\n\n    struct Route {\n        uint256 index; //Adapter at which index needs to be used\n        address targetExchange;\n        uint percent;\n        bytes payload;\n        uint256 networkFee; //Network fee is associated with 0xv3 trades\n    }\n\n    struct MegaSwapPath {\n        uint256 fromAmountPercent;\n        Path[] path;\n    }\n\n    struct Path {\n        address to;\n        uint256 totalNetworkFee; //Network fee is associated with 0xv3 trades\n        Adapter[] adapters;\n    }\n}"
    }
  ]
}