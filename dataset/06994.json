{
  "Title": "[M-10] P can be updated to zero which can cause a DOS when liquidating troves",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/StabilityPool.sol#L575-L595\n\n\n# Vulnerability details\n\n## Impact\nP is asserted to never be zero in `_updateRewardSumAndProduct` which is called for every liquidation. However, there is an edge case that can cause P to be zero, causing DOS to certain liquidations.\n\n## Proof of Concept\n\nIn `_updateRewardSumAndProduct` notice `assert(newP > 0);`. However, the SCALE_FACTOR check is insufficient in ensuring P is always more than zero. Three cycles of very small P can cause P to drop to zero and hence causing revert for that particular liquidation of troves. POC steps are as follows,\n\n1. First liquidation newProductFactor is 1e2, 1e18*1e2/1e18 = 1e2,  since its less than scale factor. 1e9 is multiplied before dividing with 1e18. P = 1e11 after 1st liquidation cycle.\n2. Second liquidation newProductFactor is 1e3, 1e11*1e3/1e18 = 0, since its less than scale factor. 1e9 is multipled. P = 1e5\n3. Third liquidation newProductFactor is 1e3, 1e5*1e3/1e8 = 0, since its less than scale factor, 1e9 is multipled. However, even after 1e9 is multiplied it will result in 1e17, which is less than DECIMAL_PRECISION of 1e18. P = 0. \n\n4. Revert due to `assert(newP > 0);`.\n\n\n```solidity\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n\n        // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION); \n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n\n        assert(newP > 0);\n        P = newP;\n\n\n        emit P_Updated(newP);\n    }\n```\n\nReasons for putting high is because\n\n1. It breaks the invariant of P being > 0 which according to the docs would break deposit tracking when Pool is not empty.\n\n2. Even though in some lucky cases, smaller liquidation can be made if batch liquidation is done, in the event that P is at a precarious place whereby all permutations of liquidations done will result in P being 0, liquidation will be DOSed which can be detrimental to protocol as they cannot liquidate bad debt and hence might lead it to insolvency.  \n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nRecommend setting SCALE_FACTOR to 1e18, even though the docs did explain that 1e9 is used instead of 1e18 to ensure negligible precision loss, the alternative option is redesigning the mitigation mechanism of rounding error for P.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Core/contracts/StabilityPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IBorrowerOperations.sol';\nimport \"./Interfaces/ICollateralConfig.sol\";\nimport './Interfaces/IStabilityPool.sol';\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/ILUSDToken.sol';\nimport './Interfaces/ISortedTroves.sol';\nimport \"./Interfaces/ICommunityIssuance.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/LiquitySafeMath128.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\n\n/*\n * The Stability Pool holds LUSD tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its LUSD debt gets offset with\n * LUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of LUSD tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a LUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive a collateral gain, as the collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total LUSD in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and collateral gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and collateral gain, we simply update two state variables:\n * a product P, and a sum S.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated collateral gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated collateral gain is derived here:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated collateral gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding collateral gain\n * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated collateral gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the \n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the \n * order of 1e-9. \n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion LUSD has depleted to < 1 LUSD).\n *\n *\n *  --- TRACKING DEPOSITOR'S COLLATERAL GAIN OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated collateral gain, during the epoch in which the deposit was non-zero and earned collateral.\n *\n * We calculate the depositor's accumulated collateral gain for the scale at which they made the deposit, using the collateral gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated collateral gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n *\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / collateral gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n *\n * --- LQTY ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An LQTY issuance event occurs at every deposit operation, and every liquidation. All deposits earn a share of the issued LQTY\n * in proportion to the deposit as a share of total deposits.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\n *\n * We use the same mathematical product-sum approach to track LQTY gains for depositors, where 'G' is the sum corresponding to LQTY gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\n *\n */\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n    using SafeERC20 for IERC20;\n\n    string constant public NAME = \"StabilityPool\";\n\n    IBorrowerOperations public borrowerOperations;\n\n    ICollateralConfig public collateralConfig;\n\n    ITroveManager public troveManager;\n\n    ILUSDToken public lusdToken;\n\n    address public lqtyTokenAddress;\n\n    // Needed to check if there are pending liquidations\n    ISortedTroves public sortedTroves;\n\n    ICommunityIssuance public communityIssuance;\n\n    mapping (address => uint256) internal collAmounts;  // deposited collateral tracker\n\n    // Tracker for LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalLUSDDeposits;\n\n   // --- Data structures ---\n\n    struct Deposit {\n        uint initialValue;\n    }\n\n    struct Snapshots {\n        mapping (address => uint) S;\n        uint P;\n        uint G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping (address => Deposit) public deposits;  // depositor address -> Deposit struct\n    mapping (address => Snapshots) public depositSnapshots;  // depositor address -> snapshots struct\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n    * after a series of liquidations have occurred, each of which cancel some LUSD debt with the deposit.\n    *\n    * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n    */\n    uint public P = DECIMAL_PRECISION;\n\n    uint public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    /* Collateral Gain sum 'S': During its lifetime, each deposit d_t earns a collateral gain of ( d_t * [S - S_t] )/P_t, where S_t\n    * is the depositor's snapshot of S taken at the time t when the deposit was made.\n    *\n    * The 'S' sums are stored in a nested mapping (epoch => scale => collateral => sum):\n    *\n    * - The inner mapping records the sum S for each collateral\n    * - The middle mapping records the (collateral => sum) mappings, at different scales.\n    * - The outer mapping records the (scale => collateral => sum) mappings, for different epochs.\n    */\n    mapping (uint128 => mapping(uint128 => mapping (address => uint))) public epochToScaleToSum;\n\n    /*\n    * Similarly, the sum 'G' is used to calculate LQTY gains. During it's lifetime, each deposit d_t earns a LQTY gain of\n    *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n    *\n    *  LQTY reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n    *  In each case, the LQTY reward is issued (i.e. G is updated), before other state changes are made.\n    */\n    mapping (uint128 => mapping(uint128 => uint)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the LQTY issuance calculation\n    uint public lastLQTYError;\n    // Error trackers for the error correction in the offset calculation\n    mapping (address => uint) public lastCollateralError_Offset;\n    uint public lastLUSDLossError_Offset;\n\n    // --- Events ---\n\n    event StabilityPoolCollateralBalanceUpdated(address _collateral, uint _newBalance);\n    event StabilityPoolLUSDBalanceUpdated(uint _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event CollateralConfigAddressChanged(address _newCollateralConfigAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint _P);\n    event S_Updated(address _collateral, uint _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, address[] _assets, uint[] _amounts, uint _G);\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\n\n    event CollateralGainWithdrawn(address indexed _depositor, address _collateral, uint _collAmount);\n    event LQTYPaidToDepositor(address indexed _depositor, uint _LQTY);\n    event CollateralSent(address _collateral, address _to, uint _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _collateralConfigAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_collateralConfigAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_lusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_communityIssuanceAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        collateralConfig = ICollateralConfig(_collateralConfigAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit CollateralConfigAddressChanged(_collateralConfigAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getCollateral(address _collateral) external view override returns (uint) {\n        return collAmounts[_collateral];\n    }\n\n    function getTotalLUSDDeposits() external view override returns (uint) {\n        return totalLUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n    *\n    * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors\n    * - Sends depositor's accumulated gains to depositor\n    * - Increases depositor's deposit, and takes new snapshot.\n    */\n    function provideToSP(uint _amount) external override {\n        _requireNonZeroAmount(_amount);\n\n        uint initialDeposit = deposits[msg.sender].initialValue;\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerLQTYIssuance(communityIssuanceCached);\n\n        (address[] memory assets, uint[] memory amounts) = getDepositorCollateralGain(msg.sender);\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n\n        /* TODO tess3rac7 unused var, but previously included in ETHGainWithdrawn event log.\n         * Doesn't make a lot of sense to include in multiple CollateralGainWithdrawn logs.\n         * If needed could create a separate event just to report this.\n         */\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        _payOutLQTYGains(communityIssuanceCached, msg.sender);\n\n        _sendLUSDtoStabilityPool(msg.sender, _amount);\n\n        uint newDeposit = compoundedLUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        uint numCollaterals = assets.length;\n        for (uint i = 0; i < numCollaterals; i++) {\n            address collateral = assets[i];\n            uint amount = amounts[i];\n            emit CollateralGainWithdrawn(msg.sender, collateral, amount);\n            _sendCollateralGainToDepositor(collateral, amount);\n        }\n     }\n\n    /*  withdrawFromSP():\n    *\n    * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors\n    * - Sends all depositor's accumulated gains to depositor\n    * - Decreases depositor's deposit, and takes new snapshot.\n    *\n    * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n    */\n    function withdrawFromSP(uint _amount) external override {\n        if (_amount !=0) {_requireNoUnderCollateralizedTroves();}\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerLQTYIssuance(communityIssuanceCached);\n\n        (address[] memory assets, uint[] memory amounts) = getDepositorCollateralGain(msg.sender);\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDtoWithdraw = LiquityMath._min(_amount, compoundedLUSDDeposit);\n\n        /* TODO tess3rac7 unused var, but previously included in ETHGainWithdrawn event log.\n         * Doesn't make a lot of sense to include in multiple CollateralGainWithdrawn logs.\n         * If needed could create a separate event just to report this.\n         */\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        _payOutLQTYGains(communityIssuanceCached, msg.sender);\n        \n        _sendLUSDToDepositor(msg.sender, LUSDtoWithdraw);\n\n        // Update deposit\n        uint newDeposit = compoundedLUSDDeposit.sub(LUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        uint numCollaterals = assets.length;\n        for (uint i = 0; i < numCollaterals; i++) {\n            address collateral = assets[i];\n            uint amount = amounts[i];\n            emit CollateralGainWithdrawn(msg.sender, collateral, amount);\n            _sendCollateralGainToDepositor(collateral, amount);\n        }\n    }\n\n    /*\n     * A depositor's snapshot struct now contains a mapping for the running sum (S) for each collateral.\n     * Mappings within a struct are not accessible via the auto-generated getters in the ABI, so we provide\n     * this separate function that will return the specified depositor's \"S\" snapshot for the given collateral.\n     */\n    function depositSnapshots_S(address _depositor, address _collateral) external override view returns (uint) {\n        return depositSnapshots[_depositor].S[_collateral];\n    }\n\n    // --- LQTY issuance functions ---\n\n    function _triggerLQTYIssuance(ICommunityIssuance _communityIssuance) internal {\n        uint LQTYIssuance = _communityIssuance.issueOath();\n       _updateG(LQTYIssuance);\n    }\n\n    function _updateG(uint _LQTYIssuance) internal {\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n        /*\n        * When total deposits is 0, G is not updated. In this case, the LQTY issued can not be obtained by later\n        * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n        *\n        */\n        if (totalLUSD == 0 || _LQTYIssuance == 0) {return;}\n\n        uint LQTYPerUnitStaked;\n        LQTYPerUnitStaked =_computeLQTYPerUnitStaked(_LQTYIssuance, totalLUSD);\n\n        uint marginalLQTYGain = LQTYPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale].add(marginalLQTYGain);\n\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeLQTYPerUnitStaked(uint _LQTYIssuance, uint _totalLUSDDeposits) internal returns (uint) {\n        /*  \n        * Calculate the LQTY-per-unit staked.  Division uses a \"feedback\" error correction, to keep the \n        * cumulative error low in the running total G:\n        *\n        * 1) Form a numerator which compensates for the floor division error that occurred the last time this \n        * function was called.  \n        * 2) Calculate \"per-unit-staked\" ratio.\n        * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store this error for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint LQTYNumerator = _LQTYIssuance.mul(DECIMAL_PRECISION).add(lastLQTYError);\n\n        uint LQTYPerUnitStaked = LQTYNumerator.div(_totalLUSDDeposits);\n        lastLQTYError = LQTYNumerator.sub(LQTYPerUnitStaked.mul(_totalLUSDDeposits));\n\n        return LQTYPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n    * Cancels out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\n    * and transfers the Trove's collateral from ActivePool to StabilityPool.\n    * Only called by liquidation functions in the TroveManager.\n    */\n    function offset(address _collateral, uint _debtToOffset, uint _collToAdd) external override {\n        _requireCallerIsTroveManager();\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n        if (totalLUSD == 0 || _debtToOffset == 0) { return; }\n\n        _triggerLQTYIssuance(communityIssuance);\n\n        (uint collGainPerUnitStaked,\n            uint LUSDLossPerUnitStaked) = _computeRewardsPerUnitStaked(_collateral, _collToAdd, _debtToOffset, totalLUSD);\n\n        _updateRewardSumAndProduct(_collateral, collGainPerUnitStaked, LUSDLossPerUnitStaked);  // updates S and P\n\n        _moveOffsetCollAndDebt(_collateral, _collToAdd, _debtToOffset);\n    }\n\n    /*\n    * Updates the reward sum for the specified collateral. A trimmed down version of \"offset()\" that doesn't\n    * concern itself with any debt to offset or LUSD loss. Only called by ActivePool when distributing\n    * yield farming rewards.\n    */\n    function updateRewardSum(address _collateral, uint _collToAdd) external override {\n        _requireCallerIsActivePool();\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n        if (totalLUSD == 0) { return; }\n\n        _triggerLQTYIssuance(communityIssuance);\n\n        (uint collGainPerUnitStaked, ) = _computeRewardsPerUnitStaked(_collateral, _collToAdd, 0, totalLUSD);\n\n        _updateRewardSumAndProduct(_collateral, collGainPerUnitStaked, 0);  // updates S\n\n        uint sum = collAmounts[_collateral].add(_collToAdd);\n        collAmounts[_collateral] = sum;\n        emit StabilityPoolCollateralBalanceUpdated(_collateral, sum);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeRewardsPerUnitStaked(\n        address _collateral,\n        uint _collToAdd,\n        uint _debtToOffset,\n        uint _totalLUSDDeposits\n    )\n        internal\n        returns (uint collGainPerUnitStaked, uint LUSDLossPerUnitStaked)\n    {\n        /*\n        * Compute the LUSD and collateral rewards. Uses a \"feedback\" error correction, to keep\n        * the cumulative error in the P and S state variables low:\n        *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this \n        * function was called.  \n        * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n        */\n        uint collNumerator = _collToAdd.mul(DECIMAL_PRECISION).add(lastCollateralError_Offset[_collateral]);\n\n        assert(_debtToOffset <= _totalLUSDDeposits);\n        if (_debtToOffset == _totalLUSDDeposits) {\n            LUSDLossPerUnitStaked = DECIMAL_PRECISION;  // When the Pool depletes to 0, so does each deposit \n            lastLUSDLossError_Offset = 0;\n        } else {\n            uint LUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(lastLUSDLossError_Offset);\n            /*\n            * Add 1 to make error in quotient positive. We want \"slightly too much\" LUSD loss,\n            * which ensures the error in any given compoundedLUSDDeposit favors the Stability Pool.\n            */\n            LUSDLossPerUnitStaked = (LUSDLossNumerator.div(_totalLUSDDeposits)).add(1);\n            lastLUSDLossError_Offset = (LUSDLossPerUnitStaked.mul(_totalLUSDDeposits)).sub(LUSDLossNumerator);\n        }\n\n        collGainPerUnitStaked = collNumerator.div(_totalLUSDDeposits);\n        lastCollateralError_Offset[_collateral] = collNumerator.sub(collGainPerUnitStaked.mul(_totalLUSDDeposits));\n\n        return (collGainPerUnitStaked, LUSDLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(address _collateral, uint _collGainPerUnitStaked, uint _LUSDLossPerUnitStaked) internal {\n        uint currentP = P;\n        uint newP;\n\n        assert(_LUSDLossPerUnitStaked <= DECIMAL_PRECISION);\n        /*\n        * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool LUSD in the liquidation.\n        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - LUSDLossPerUnitStaked)\n        */\n        uint newProductFactor = uint(DECIMAL_PRECISION).sub(_LUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached][_collateral];\n\n        /*\n        * Calculate the new S first, before we update P.\n        * The collateral gain for any given depositor from a liquidation depends on the value of their deposit\n        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n        *\n        * Since S corresponds to collateral gain, and P to deposit loss, we update S first.\n        */\n        uint marginalCollGain = _collGainPerUnitStaked.mul(currentP);\n        uint newS = currentS.add(marginalCollGain);\n        epochToScaleToSum[currentEpochCached][currentScaleCached][_collateral] = newS;\n        emit S_Updated(_collateral, newS, currentEpochCached, currentScaleCached);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n        // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION); \n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        assert(newP > 0);\n        P = newP;\n\n        emit P_Updated(newP);\n    }\n\n    function _moveOffsetCollAndDebt(address _collateral, uint _collToAdd, uint _debtToOffset) internal {\n        IActivePool activePoolCached = activePool;\n\n        // Cancel the liquidated LUSD debt with the LUSD in the stability pool\n        activePoolCached.decreaseLUSDDebt(_collateral, _debtToOffset);\n        _decreaseLUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        lusdToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendCollateral(_collateral, address(this), _collToAdd);\n        uint sum = collAmounts[_collateral].add(_collToAdd);\n        collAmounts[_collateral] = sum;\n        emit StabilityPoolCollateralBalanceUpdated(_collateral, sum);\n    }\n\n    function _decreaseLUSD(uint _amount) internal {\n        uint newTotalLUSDDeposits = totalLUSDDeposits.sub(_amount);\n        totalLUSDDeposits = newTotalLUSDDeposits;\n        emit StabilityPoolLUSDBalanceUpdated(newTotalLUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor ---\n\n    /* Calculates the collateral gain earned by the deposit since its last snapshots were taken.\n    * Given by the formula:  E = d0 * (S - S(0))/P(0)\n    * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorCollateralGain(address _depositor) public view override returns (address[] memory assets, uint[] memory amounts) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit != 0) { \n            Snapshots storage snapshots = depositSnapshots[_depositor];\n\n            return _getCollateralGainFromSnapshots(initialDeposit, snapshots);\n        }\n\n    }\n\n    function _getCollateralGainFromSnapshots(uint initialDeposit, Snapshots storage snapshots) internal view returns (address[] memory assets, uint[] memory amounts) {\n        assets = collateralConfig.getAllowedCollaterals();\n        amounts = new uint[](assets.length);\n        for (uint i = 0; i < assets.length; i++) {\n            amounts[i] = _getSingularCollateralGain(initialDeposit, assets[i], snapshots);\n        }\n    }\n\n    // Due to \"stack too deep\" error\n    struct LocalVariables_getSingularCollateralGain {\n        uint256 collDecimals;\n        uint128 epochSnapshot;\n        uint128 scaleSnapshot;\n        uint P_Snapshot;\n        uint S_Snapshot;\n        uint firstPortion;\n        uint secondPortion;\n        uint gain;\n    }\n\n    function _getSingularCollateralGain(uint _initialDeposit, address _collateral, Snapshots storage _snapshots) internal view returns (uint) {\n        /*\n        * Grab the sum 'S' from the epoch at which the stake was made. The collateral gain may span up to one scale change.\n        * If it does, the second portion of the collateral gain is scaled by 1e9.\n        * If the gain spans no scale change, the second portion will be 0.\n        */\n        LocalVariables_getSingularCollateralGain memory vars;\n        vars.collDecimals = collateralConfig.getCollateralDecimals(_collateral);\n        vars.epochSnapshot = _snapshots.epoch;\n        vars.scaleSnapshot = _snapshots.scale;\n        vars.P_Snapshot = _snapshots.P;\n        vars.S_Snapshot = _snapshots.S[_collateral];\n\n        vars.firstPortion = epochToScaleToSum[vars.epochSnapshot][vars.scaleSnapshot][_collateral].sub(vars.S_Snapshot);\n        vars.secondPortion = epochToScaleToSum[vars.epochSnapshot][vars.scaleSnapshot.add(1)][_collateral].div(SCALE_FACTOR);\n\n        vars.gain = _initialDeposit.mul(vars.firstPortion.add(vars.secondPortion)).div(vars.P_Snapshot).div(DECIMAL_PRECISION);\n        return vars.gain;\n    }\n\n    /*\n    * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\n    * Given by the formula:  LQTY = d0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    * d0 is the last recorded deposit value.\n    */\n    function getDepositorLQTYGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {return 0;}\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n        ui"
    }
  ]
}