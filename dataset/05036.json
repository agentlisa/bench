{
  "Title": "[07] No code size limit check in function `put_sidevm_code`",
  "Content": "\nhttps://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/runtime/pallet_pink.rs#L134-L146\n\n**[__ 141345 __ (lookout) commented](https://github.com/code-423n4/2024-03-phala-network-findings/issues/11#issuecomment-2017519242):**\n> [01] - Non-Critical<br>\n> [02] - Non-Critical<br>\n> [03] - Non-Critical<br>\n> [04] - Non-Critical<br>\n> [05] - Low<br>\n> [06] - Non-Critical<br>\n> [07] - Non-Critical<br>\n\n**[kvinwang (Phala) confirmed and commented](https://github.com/code-423n4/2024-03-phala-network-findings/issues/11#issuecomment-2019249514):**\n> [01] - Disagree, `len = 1` is a valid batch.<br>\n> [02] - Confirmed.<br>\n> [03] - Confirmed.<br>\n> [04] - Judgable. It did actually revert in the past, but the reverting can not be catched by the contract which leads bad dev experience.<br>\n> [05] If `deposit_per_byte is = 664613997892457936451903530140172289`, the cluster wouldn't be able to do anything as it is two expensive.<br>\n> [06] - Confirmed. This is actually on the plan.<br>\n> [07] - Confirmed. Might be good to have; however, there is already a on-chain limit check for that.\n\n**[Lambda (judge) commented](https://github.com/code-423n4/2024-03-phala-network-findings/issues/11#issuecomment-2024700219):**\n > Agree with the Lookout's assessment of L/NC and the sponsors assessment of the validity with the following differences:<br>\n >\n> [01] - Valid design suggestion (not necessarily better than the current one, but just an alternative one).<br>\n> [04] - Also a design suggestion.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-phala-network",
  "Code": [
    {
      "filename": "phala-blockchain/crates/pink/runtime/src/runtime/pallet_pink.rs",
      "content": "pub use pallet::*;\n\n#[allow(unused_imports)]\n#[frame_support::pallet]\npub mod pallet {\n    use frame_support::pallet_prelude::{ValueQuery, *};\n    use frame_support::traits::{\n        Currency,\n        ExistenceRequirement::{AllowDeath, KeepAlive},\n    };\n    use pallet_contracts::AddressGenerator;\n    use phala_crypto::sr25519::Sr25519SecretKey;\n    use scale::{Decode, Encode};\n    use scale_info::TypeInfo;\n    use sp_core::crypto::UncheckedFrom;\n    use sp_runtime::{\n        traits::{Convert, Hash as _},\n        SaturatedConversion, Saturating,\n    };\n\n    use crate::types::Hash;\n\n    type BalanceOf<T> =\n        <<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\n    type AccountIdOf<T> = <T as frame_system::Config>::AccountId;\n    type HashOf<T> = <T as frame_system::Config>::Hash;\n\n    #[pallet::error]\n    pub enum Error<T> {\n        /// Calling chain extension with an invalid extension id.\n        UnknownChainExtensionId,\n        /// Calling chain extension with an invalid function id.\n        UnknownChainExtensionFunction,\n        /// Failed to write chain extension return value to the contract buffer.\n        ContractIoBufferOverflow,\n        /// No key seed found in the cluster when deriving a key. Should never happen.\n        KeySeedMissing,\n        /// Crypto error occurred while deriving a key. Unlikely to happen.\n        DeriveKeyFailed,\n        /// The system contract is missing. Should never happen.\n        SystemContractMissing,\n    }\n\n    #[derive(Clone, Eq, PartialEq, Encode, Decode, TypeInfo)]\n    pub struct WasmCode<AccountId> {\n        pub owner: AccountId,\n        pub code: Vec<u8>,\n    }\n\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n        type Currency: Currency<Self::AccountId>;\n    }\n\n    #[pallet::storage]\n    #[pallet::getter(fn cluster_id)]\n    pub(crate) type ClusterId<T: Config> = StorageValue<_, Hash, ValueQuery>;\n\n    #[pallet::storage]\n    #[pallet::getter(fn gas_price)]\n    pub(crate) type GasPrice<T: Config> = StorageValue<_, BalanceOf<T>, ValueQuery>;\n\n    #[pallet::storage]\n    #[pallet::getter(fn deposit_per_byte)]\n    pub(crate) type DepositPerByte<T: Config> = StorageValue<_, BalanceOf<T>, ValueQuery>;\n\n    #[pallet::storage]\n    #[pallet::getter(fn deposit_per_item)]\n    pub(crate) type DepositPerItem<T: Config> = StorageValue<_, BalanceOf<T>, ValueQuery>;\n\n    #[pallet::storage]\n    pub(crate) type TreasuryAccount<T: Config> = StorageValue<_, T::AccountId>;\n\n    /// The priviate key of the cluster\n    #[pallet::storage]\n    #[pallet::getter(fn key)]\n    pub(crate) type Key<T: Config> = StorageValue<_, Sr25519SecretKey>;\n\n    /// Uploaded sidevm codes\n    #[pallet::storage]\n    #[pallet::getter(fn sidevm_codes)]\n    pub(crate) type SidevmCodes<T: Config> =\n        StorageMap<_, Twox64Concat, T::Hash, WasmCode<T::AccountId>>;\n\n    /// The system contract address\n    #[pallet::storage]\n    #[pallet::getter(fn system_contract)]\n    pub(crate) type SystemContract<T: Config> = StorageValue<_, T::AccountId, OptionQuery>;\n\n    /// The next event chain sequence number\n    #[pallet::storage]\n    #[pallet::getter(fn next_event_block_number)]\n    pub(crate) type NextEventBlockNumber<T: Config> = StorageValue<_, u64, ValueQuery>;\n\n    /// The last emited event block hash\n    #[pallet::storage]\n    #[pallet::getter(fn last_event_block_hash)]\n    pub(crate) type LastEventBlockHash<T: Config> = StorageValue<_, T::Hash, ValueQuery>;\n\n    #[pallet::pallet]\n    #[pallet::without_storage_info]\n    pub struct Pallet<T>(_);\n\n    impl<T: Config + pallet_contracts::Config> AddressGenerator<T> for Pallet<T>\n    where\n        AccountIdOf<T>: UncheckedFrom<HashOf<T>> + AsRef<[u8]>,\n    {\n        fn contract_address(\n            deploying_address: &AccountIdOf<T>,\n            code_hash: &HashOf<T>,\n            _input_data: &[u8],\n            salt: &[u8],\n        ) -> AccountIdOf<T> {\n            let cluster_id = <ClusterId<T>>::get();\n            let buf = phala_types::contract::contract_id_preimage(\n                deploying_address.as_ref(),\n                code_hash.as_ref(),\n                cluster_id.as_ref(),\n                salt,\n            );\n            UncheckedFrom::unchecked_from(<T as frame_system::Config>::Hashing::hash(&buf))\n        }\n    }\n\n    impl<T: Config> Pallet<T> {\n        pub fn set_cluster_id(cluster_id: Hash) {\n            <ClusterId<T>>::put(cluster_id);\n        }\n\n        pub fn set_key(key: Sr25519SecretKey) {\n            <Key<T>>::put(key);\n        }\n\n        pub fn put_sidevm_code(\n            owner: T::AccountId,\n            code: Vec<u8>,\n        ) -> Result<T::Hash, DispatchError> {\n            let hash = T::Hashing::hash(&code);\n            let bytes = code.len() + hash.as_ref().len();\n            let fee = Self::deposit_per_byte()\n                .saturating_mul(BalanceOf::<T>::saturated_from(bytes))\n                .saturating_add(Self::deposit_per_item());\n            Self::pay(&owner, fee)?;\n            <SidevmCodes<T>>::insert(hash, WasmCode { owner, code });\n            Ok(hash)\n        }\n\n        pub fn sidevm_code_exists(code_hash: &T::Hash) -> bool {\n            <SidevmCodes<T>>::contains_key(code_hash)\n        }\n\n        pub fn set_system_contract(address: &T::AccountId) {\n            <SystemContract<T>>::put(address);\n        }\n\n        pub fn pay_for_gas(user: &T::AccountId, gas: Weight) -> DispatchResult {\n            Self::pay(user, Self::convert(gas))\n        }\n\n        pub fn refund_gas(user: &T::AccountId, gas: Weight) -> DispatchResult {\n            Self::refund(user, Self::convert(gas))\n        }\n\n        fn pay(user: &T::AccountId, amount: BalanceOf<T>) -> DispatchResult {\n            let Some(treasury) = TreasuryAccount::<T>::get() else {\n                return Ok(());\n            };\n            <T as Config>::Currency::transfer(user, &treasury, amount, KeepAlive)\n        }\n\n        fn refund(user: &T::AccountId, amount: BalanceOf<T>) -> DispatchResult {\n            let Some(treasury) = TreasuryAccount::<T>::get() else {\n                return Ok(());\n            };\n            <T as Config>::Currency::transfer(&treasury, user, amount, AllowDeath)\n        }\n\n        pub fn set_gas_price(price: BalanceOf<T>) {\n            <GasPrice<T>>::put(price);\n        }\n\n        pub fn set_deposit_per_item(value: BalanceOf<T>) {\n            <DepositPerItem<T>>::put(value);\n        }\n\n        pub fn set_deposit_per_byte(value: BalanceOf<T>) {\n            <DepositPerByte<T>>::put(value);\n        }\n\n        pub fn set_treasury_account(account: &T::AccountId) {\n            <TreasuryAccount<T>>::put(account);\n        }\n\n        pub fn take_next_event_block_number() -> u64 {\n            <NextEventBlockNumber<T>>::mutate(|n| {\n                let next = *n;\n                *n += 1;\n                next\n            })\n        }\n\n        pub fn set_last_event_block_hash(hash: T::Hash) {\n            <LastEventBlockHash<T>>::put(hash);\n        }\n    }\n\n    impl<T: Config> Convert<Weight, BalanceOf<T>> for Pallet<T> {\n        fn convert(w: Weight) -> BalanceOf<T> {\n            let weight = BalanceOf::<T>::saturated_from(w.ref_time());\n            weight.saturating_mul(GasPrice::<T>::get())\n        }\n    }\n}"
    }
  ]
}