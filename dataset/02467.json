{
  "Title": "M-2: Users can lose their staking rewards.",
  "Content": "# Issue M-2: Users can lose their staking rewards. \n\nSource: https://github.com/sherlock-audit/2023-02-union-judging/issues/29 \n\n## Found by \nCodingNameKiki\n\n## Summary\nBy following the steps described in `Vulnerability Detail`, user is able to lose all of his staking rewards.\n\n## Vulnerability Detail\nThe issue occurs in the following steps described below:\n1. Kiki calls the function `unstake` and unstakes all of his funds, as a result the internal function `_updateStakedCoinAge` is called to update his staked coin age till the current block.\n\n```solidity\ncontracts/user/UserManager.sol\n\n711:  function unstake(uint96 amount) external whenNotPaused nonReentrant {\n712:        Staker storage staker = stakers[msg.sender];\n713:\n714:        // Stakers can only unstaked stake balance that is unlocked. Stake balance\n715:        // becomes locked when it is used to underwrite a borrow.\n716:        if (staker.stakedAmount - staker.locked < amount) revert InsufficientBalance();\n717:\n718:        comptroller.withdrawRewards(msg.sender, stakingToken);\n719:\n720:        uint256 remaining = IAssetManager(assetManager).withdraw(stakingToken, msg.sender, amount);\n721:        if (uint96(remaining) > amount) {\n722:            revert AssetManagerWithdrawFailed();\n723:        }\n724:        uint96 actualAmount = amount - uint96(remaining);\n725:\n726:        _updateStakedCoinAge(msg.sender, staker);\n727:        staker.stakedAmount -= actualAmount;\n728:        totalStaked -= actualAmount;\n729:\n730:        emit LogUnstake(msg.sender, actualAmount);\n731:    }\n```\n```solidity\ncontracts/user/UserManager.sol\n\n1064:  function _updateStakedCoinAge(address stakerAddress, Staker storage staker) private {\n1065:        uint64 currentBlock = uint64(block.number);\n1066:        uint256 lastWithdrawRewards = getLastWithdrawRewards[stakerAddress];\n1067:        uint256 blocksPast = (uint256(currentBlock) - _max(lastWithdrawRewards, uint256(staker.lastUpdated)));\n1068:        staker.stakedCoinAge += blocksPast * uint256(staker.stakedAmount);\n1069:        staker.lastUpdated = currentBlock;\n1070:    }\n```\n2. After that Kiki calls the function `withdrawRewards` in order to withdraw his staking rewards. \nEverything executes fine, but the contract lacks union tokens and can't transfer the tokens to Kiki, so the else statement is triggered and the amount of tokens is added to his accrued balance, so he can still be able to withdraw them after.\n\n```solidity\ncontracts/token/Comptroller.sol\n\n224:  function withdrawRewards(address account, address token) external override whenNotPaused returns (uint256) {\n225:        IUserManager userManager = _getUserManager(token);\n226:\n227:        // Lookup account state from UserManager\n228:        (UserManagerAccountState memory user, Info memory userInfo, uint256 pastBlocks) = _getUserInfo(\n229:            userManager,\n230:            account,\n231:            token,\n232:            0\n233:        );\n234:\n235:        // Lookup global state from UserManager\n236:        uint256 globalTotalStaked = userManager.globalTotalStaked();\n237:\n238:        uint256 amount = _calculateRewardsByBlocks(account, token, pastBlocks, userInfo, globalTotalStaked, user);\n239:\n240:        // update the global states\n241:        gInflationIndex = _getInflationIndexNew(globalTotalStaked, block.number - gLastUpdatedBlock);\n242:        gLastUpdatedBlock = block.number;\n243:        users[account][token].updatedBlock = block.number;\n244:        users[account][token].inflationIndex = gInflationIndex;\n245:        if (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n246:            unionToken.safeTransfer(account, amount);\n247:            users[account][token].accrued = 0;\n248:            emit LogWithdrawRewards(account, amount);\n249:\n250:            return amount;\n251:        } else {\n252:            users[account][token].accrued = amount;\n253:            emit LogWithdrawRewards(account, 0);\n254:\n255:            return 0;\n256:        }\n257:    }\n```\n3. This is where the issue occurs, next time Kiki calls the function `withdrawRewards`, he is going to lose all of his rewards.\n\nExplanation of how this happens:\n- First the internal function _getUserInfo will return the struct `UserManagerAccountState memory user`, which contains zero amount for effectiveStaked, because Kiki unstaked all of his funds and already called the function withdrawRewards once.\nThis happens because Kiki has `stakedAmount = 0, stakedCoinAge = 0, lockedCoinAge = 0, frozenCoinAge = 0`.\n\n```solidity\n(UserManagerAccountState memory user, Info memory userInfo, uint256 pastBlocks) = _getUserInfo(\n            userManager,\n            account,\n            token,\n            0\n        );\n```\n- The cache `uint256 amount` will have a zero value because of the if statement applied in the internal function `_calculateRewardsByBlocks`, the if statement will be triggered as Kiki's effectiveStaked == 0, and as a result the function will return zero.\n```solidity\nuint256 amount = _calculateRewardsByBlocks(account, token, pastBlocks, userInfo, globalTotalStaked, user);\n```\n```solidity\nif (user.effectiveStaked == 0 || totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0) {\n            return 0;\n        }\n```\n- Since the cache `uint256 amount` have a zero value, the if statement in the function `withdrawRewards` will actually be ignored because of `&& amount > 0`. And the else statement will be triggered, which will override Kiki's accrued balance with \"amount\", which is actually zero. As a result Kiki will lose his rewards.\n```solidity\nif (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n            unionToken.safeTransfer(account, amount);\n            users[account][token].accrued = 0;\n            emit LogWithdrawRewards(account, amount);\n\n            return amount;\n        } else {\n            users[account][token].accrued = amount;\n            emit LogWithdrawRewards(account, 0);\n\n            return 0;\n        }\n```\n\n\n## Impact\nThe impact here is that users can lose their staking rewards. \n\nTo understand the scenario which is described in `Vulnerability Detail`, you'll need to know how the codebase works.\nHere in the impact section, l will describe in little more details and trace the functions.\n\nThe issue occurs in 3 steps like described in `Vulnerability Detail`:\n1. User unstakes all of his funds.\n2. Then he calls the function `withdrawRewards` in order to withdraw his rewards, everything executes fine but the contract lacks union tokens, so instead of transferring the tokens to the user, they are added to his accrued balance so he can still withdraw them after.\n3. The next time the user calls the function `withdrawRewards` in order to withdraw his accrued balance of tokens, he will lose all of his rewards.\n\nExplanation in details:\n\n1. User unstakes all of his funds by calling the function `unstake`.\n\n- His stakedAmount will be reduced to zero in the struct `Staker`.\n- His stakedCoinAge will be updated to the current block with the internal function `_updateStakedCoinAge`.\n\n2. Then he calls the function withdrawRewards in order to withdraw his rewards, everything executes fine but the contract lacks union tokens, so instead of transferring the tokens to the user, they are added to his accrued balance so he can still withdraw them after.\n\n- User's stakedCoinAge, lockedCoinAge and frozenCoinAge are reduced to zero in the function `onWithdrawRewards`. \n\n3. The next time the user calls the function `withdrawRewards` in order to withdraw his accrued balance of tokens, he will lose all of his rewards.\n\n- In order to withdraw his accrued rewards stored in his struct balance `Info`. He calls the function `withdrawRewards` again and this is where the issue occurs, as the user has `stakedAmount = 0, stakedCoinAge = 0, lockedCoinAge = 0, frozenCoinAge = 0 `.\n- Duo to that the outcome of the function _getCoinAge, which returns a memory struct of CoinAge to the function `_getEffectiveAmounts` will look like this:\n```Note\nCoinAge memory coinAge = CoinAge({\n            lastWithdrawRewards: lastWithdrawRewards,\n            diff: diff,\n            stakedCoinAge: staker.stakedCoinAge + diff * uint256(staker.stakedAmount),\n            lockedCoinAge: staker.lockedCoinAge,\n            frozenCoinAge: frozenCoinAge[stakerAddress]\n        });\n\n// The function will return:\nCoinAge memory coinAge = CoinAge({\n            lastWithdrawRewards: random number,\n            diff: random number,\n            stakedCoinAge: 0 + random number * 0,\n            lockedCoinAge: 0, \n            frozenCoinAge: 0\n        });\n\n```\n- As a result the function `_getEffectiveAmounts` will return zero values for effectiveStaked and effectiveLocked to the function `onWithdrawRewards`.\n```Note\nreturn (\n            // staker's total effective staked = (staked coinage - frozen coinage) / (# of blocks since last reward claiming)\n            coinAge.diff == 0 ? 0 : (coinAge.stakedCoinAge - coinAge.frozenCoinAge) / coinAge.diff,\n            // effective locked amount = (locked coinage - frozen coinage) / (# of blocks since last reward claiming)\n            coinAge.diff == 0 ? 0 : (coinAge.lockedCoinAge - coinAge.frozenCoinAge) / coinAge.diff,\n            memberTotalFrozen\n        );\n\nreturn (\n            // staker's total effective staked = (staked coinage - frozen coinage) / (# of blocks since last reward claiming)\n            coinAge.diff == 0 ? 0 : (0 - 0) / random number,\n             // effective locked amount = (locked coinage - frozen coinage) / (# of blocks since last reward claiming)\n            coinAge.diff == 0 ? 0 : (0 - 0) / random number,\n            0\n        );\n```\n\n- After that the function `withdrawRewards` caches the returning value from the internal function `_calculateRewardsByBlocks`.\nWhat happens is that in the function `_calculateRewardsByBlocks` the if statement is triggered because the user's effectiveStaked == 0. As a result the internal function will return 0 and the cache `uint256 amount` will equal zero.\n\n```Note\nuint256 amount = _calculateRewardsByBlocks(account, token, pastBlocks, userInfo, globalTotalStaked, user);\n```\n```Note\nif (user.effectiveStaked == 0 || totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0) {\n            return 0;\n        }\n```\n\n- Since the cache `uint256 amount` have a zero value, the if statement in the function `withdrawRewards` will actually be ignored because of `&& amount > 0`. And the else statement will be triggered, which will override Kiki's accrued balance with \"amount\", which is actually zero. \n\n```Note\nif (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n            unionToken.safeTransfer(account, amount);\n            users[account][token].accrued = 0;\n            emit LogWithdrawRewards(account, amount);\n\n            return amount;\n        } else {\n            users[account][token].accrued = amount;\n            emit LogWithdrawRewards(account, 0);\n\n            return 0;\n        }\n```\n\nBelow you can see the functions which are invoked starting from the function `_getUserInfo`:\n\n```solidity\n(UserManagerAccountState memory user, Info memory userInfo, uint256 pastBlocks) = _getUserInfo(\n            userManager,\n            account,\n            token,\n            0\n        );\n```\n```solidity\nfunction _getUserInfo(\n        IUserManager userManager,\n        address account,\n        address token,\n        uint256 futureBlocks\n    ) internal returns (UserManagerAccountState memory user, Info memory userInfo, uint256 pastBlocks) {\n        userInfo = users[account][token];\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n\n        (user.effectiveStaked, user.effectiveLocked, user.isMember) = userManager.onWithdrawRewards(\n            account,\n            pastBlocks\n        );\n    }\n```\n```solidity\nfunction onWithdrawRewards(address staker, uint256 pastBlocks)\n        external\n        returns (\n            uint256 effectiveStaked,\n            uint256 effectiveLocked,\n            bool isMember\n        )\n    {\n        if (address(comptroller) != msg.sender) revert AuthFailed();\n        uint256 memberTotalFrozen = 0;\n        (effectiveStaked, effectiveLocked, memberTotalFrozen) = _getEffectiveAmounts(staker, pastBlocks);\n        stakers[staker].stakedCoinAge = 0;\n        stakers[staker].lastUpdated = uint64(block.number);\n        stakers[staker].lockedCoinAge = 0;\n        frozenCoinAge[staker] = 0;\n        getLastWithdrawRewards[staker] = block.number;\n\n        uint256 memberFrozenBefore = memberFrozen[staker];\n        if (memberFrozenBefore != memberTotalFrozen) {\n            memberFrozen[staker] = memberTotalFrozen;\n            totalFrozen = totalFrozen - memberFrozenBefore + memberTotalFrozen;\n        }\n\n        isMember = stakers[staker].isMember;\n    }\n```\n```solidity\nfunction _getEffectiveAmounts(address stakerAddress, uint256 pastBlocks)\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 memberTotalFrozen = 0;\n        CoinAge memory coinAge = _getCoinAge(stakerAddress);\n\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 voucheesLength = vouchees[stakerAddress].length;\n        // Loop through all of the stakers vouchees sum their total\n        // locked balance and sum their total currDefaultFrozenCoinAge\n        for (uint256 i = 0; i < voucheesLength; i++) {\n            // Get the vouchee record and look up the borrowers voucher record\n            // to get the locked amount and lastUpdated block number\n            Vouchee memory vouchee = vouchees[stakerAddress][i];\n            Vouch memory vouch = vouchers[vouchee.borrower][vouchee.voucherIndex];\n\n            uint256 lastRepay = uToken.getLastRepay(vouchee.borrower);\n            uint256 repayDiff = block.number - _max(lastRepay, coinAge.lastWithdrawRewards);\n            uint256 locked = uint256(vouch.locked);\n\n            if (overdueBlocks < repayDiff && (coinAge.lastWithdrawRewards != 0 || lastRepay != 0)) {\n                memberTotalFrozen += locked;\n                if (pastBlocks >= repayDiff) {\n                    coinAge.frozenCoinAge += (locked * repayDiff);\n                } else {\n                    coinAge.frozenCoinAge += (locked * pastBlocks);\n                }\n            }\n\n            uint256 lastUpdateBlock = _max(coinAge.lastWithdrawRewards, uint256(vouch.lastUpdated));\n            coinAge.lockedCoinAge += (block.number - lastUpdateBlock) * locked;\n        }\n\n        return (\n            // staker's total effective staked = (staked coinage - frozen coinage) / (# of blocks since last reward claiming)\n            coinAge.diff == 0 ? 0 : (coinAge.stakedCoinAge - coinAge.frozenCoinAge) / coinAge.diff,\n            // effective locked amount = (locked coinage - frozen coinage) / (# of blocks since last reward claiming)\n            coinAge.diff == 0 ? 0 : (coinAge.lockedCoinAge - coinAge.frozenCoinAge) / coinAge.diff,\n            memberTotalFrozen\n        );\n    }\n```\n```solidity\nfunction _getCoinAge(address stakerAddress) private view returns (CoinAge memory) {\n        Staker memory staker = stakers[stakerAddress];\n\n        uint256 lastWithdrawRewards = getLastWithdrawRewards[stakerAddress];\n        uint256 diff = block.number - _max(lastWithdrawRewards, uint256(staker.lastUpdated));\n\n        CoinAge memory coinAge = CoinAge({\n            lastWithdrawRewards: lastWithdrawRewards,\n            diff: diff,\n            stakedCoinAge: staker.stakedCoinAge + diff * uint256(staker.stakedAmount),\n            lockedCoinAge: staker.lockedCoinAge,\n            frozenCoinAge: frozenCoinAge[stakerAddress]\n        });\n\n        return coinAge;\n    }\n```\n\nBelow you can see the function _calculateRewardsByBlocks:\n\n```solidity\nfunction _calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 pastBlocks,\n        Info memory userInfo,\n        uint256 totalStaked,\n        UserManagerAccountState memory user\n    ) internal view returns (uint256) {\n        uint256 startInflationIndex = users[account][token].inflationIndex;\n\n        if (user.effectiveStaked == 0 || totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0) {\n            return 0;\n        }\n\n        uint256 rewardMultiplier = _getRewardsMultiplier(user);\n\n        uint256 curInflationIndex = _getInflationIndexNew(totalStaked, pastBlocks);\n\n        if (curInflationIndex < startInflationIndex) revert InflationIndexTooSmall();\n\n        return\n            userInfo.accrued +\n            (curInflationIndex - startInflationIndex).wadMul(user.effectiveStaked).wadMul(rewardMultiplier);\n    }\n```\n\n## Code Snippet\nFunction `unstake` - https://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L711-L731\n\nFunction `_updateStakedCoinAge` - https://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L1064-L1070\n\nFunction `withdrawRewards` - https://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/token/Comptroller.sol#L224-L257\n\nFunction `_getUserInfo` - https://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/token/Comptroller.sol#L311-L329\n\nFunction `onWithdrawRewards` - https://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L969-L993\n\nFunction `_getEffectiveAmounts` - https://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L892-L938\n\nFunction `_getCoinAge` - https://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L1072-L1087\n\nFunction `_calculateRewardsByBlocks` - https://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/token/Comptroller.sol#L341-L364\n\n## Tool used\n\nManual Review\n\n## Recommendation\nOne way of fixing this problem, that l can think of is to refactor the function _calculateRewardsByBlocks.\nFirst the function _calculateRewardsByBlocks will revert if `(totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0)`.\nSecond new if statement is created, which is triggered if `user.effectiveStaked == 0`.\n- if `userInfo.accrued == 0`, it will return 0.\n- if `userInfo.accrued != 0`, it will return the accrued balance.\n\n```solidity\nfunction _calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 pastBlocks,\n        Info memory userInfo,\n        uint256 totalStaked,\n        UserManagerAccountState memory user\n    ) internal view returns (uint256) {\n        uint256 startInflationIndex = users[account][token].inflationIndex;\n\n        if (totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0) {\n            revert ZeroNotAllowed();\n        }\n        \n        if (user.effectiveStaked == 0) {\n           if (userInfo.accrued == 0) return 0;\n           else return userInfo.accrued\n        }\n\n        uint256 rewardMultiplier = _getRewardsMultiplier(user);\n\n        uint256 curInflationIndex = _getInflationIndexNew(totalStaked, pastBlocks);\n\n        if (curInflationIndex < startInflationIndex) revert InflationIndexTooSmall();\n\n        return\n            userInfo.accrued +\n            (curInflationIndex - startInflationIndex).wadMul(user.effectiveStaked).wadMul(rewardMultiplier);\n    }\n```\n\n## Discussion\n\n**kingjacob**\n\nThis is valid but medium severity as its inaccurate rewards not a loss of funds.\n\n**hrishibhat**\n\nConsidering this issue a valid medium as there is a precondition of an underfunded contract for this to occur which is highly unlikely. \n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/44",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/user/UserManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IUnionToken} from \"../interfaces/IUnionToken.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\n/**\n * @title UserManager Contract\n * @dev Manages the Union members stake and vouches.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeCastUpgradeable for uint256;\n    using SafeCastUpgradeable for uint128;\n\n    /* -------------------------------------------------------------------\n      Storage Types \n    ------------------------------------------------------------------- */\n\n    struct Vouch {\n        // staker recieveing the vouch\n        address staker;\n        // trust amount\n        uint96 trust;\n        // amount of stake locked by this vouch\n        uint96 locked;\n        // block number of last update\n        uint64 lastUpdated;\n    }\n\n    struct Staker {\n        bool isMember;\n        uint96 stakedAmount;\n        uint96 locked;\n        // block number of last stakedAmount update\n        uint64 lastUpdated;\n        uint256 stakedCoinAge;\n        uint256 lockedCoinAge;\n    }\n\n    struct Index {\n        bool isSet;\n        uint128 idx;\n    }\n\n    struct Vouchee {\n        address borrower;\n        uint96 voucherIndex;\n    }\n\n    /* -------------------------------------------------------------------\n      Memory Types \n    ------------------------------------------------------------------- */\n\n    struct CoinAge {\n        uint256 stakedCoinAge;\n        uint256 lockedCoinAge;\n        uint256 frozenCoinAge;\n        uint256 lastWithdrawRewards;\n        uint256 diff;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Max amount that can be staked of the staking token\n     */\n    uint96 public maxStakeAmount;\n\n    /**\n     *  @dev The staking token that is staked in the comptroller\n     */\n    address public stakingToken;\n\n    /**\n     *  @dev Address of the UNION token contract\n     */\n    address public unionToken;\n\n    /**\n     *  @dev Address of the asset manager contract\n     */\n    address public assetManager;\n\n    /**\n     *  @dev uToken contract\n     */\n    IUToken public uToken;\n\n    /**\n     *  @dev Comptroller contract\n     */\n    IComptroller public comptroller;\n\n    /**\n     * @dev Number of vouches needed to become a member\n     */\n    uint256 public effectiveCount;\n\n    /**\n     *  @dev New member fee\n     */\n    uint256 public newMemberFee;\n\n    /**\n     *  @dev Total amount of staked staked token\n     */\n    uint256 public totalStaked;\n\n    /**\n     *  @dev Total amount of stake frozen\n     */\n    uint256 public totalFrozen;\n\n    /**\n     *  @dev Max blocks can be overdue for\n     */\n    uint256 public maxOverdueBlocks;\n\n    /**\n     * @dev Max voucher limit\n     */\n    uint256 public maxVouchers;\n\n    /**\n     * @dev Max vouchees limit\n     */\n    uint256 public maxVouchees;\n\n    /**\n     *  @dev Union Stakers\n     */\n    mapping(address => Staker) public stakers;\n\n    /**\n     *  @dev Borrower (borrower) mapped to received vouches (staker)\n     */\n    mapping(address => Vouch[]) public vouchers;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vouchers array\n     */\n    mapping(address => mapping(address => Index)) public voucherIndexes;\n\n    /**\n     *  @dev Staker (staker) mapped to vouches given (borrower)\n     */\n    mapping(address => Vouchee[]) public vouchees;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vochee array\n     */\n    mapping(address => mapping(address => Index)) public voucheeIndexes;\n\n    /**\n     * @dev Stakers frozen amounts\n     */\n    mapping(address => uint256) public memberFrozen;\n\n    /**\n     * @dev Stakers mapped to frozen coin age\n     */\n    mapping(address => uint256) public frozenCoinAge;\n\n    /**\n     * @dev Staker mapped to last time they withdrew rewards\n     */\n    mapping(address => uint256) public getLastWithdrawRewards;\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error AuthFailed();\n    error ErrorSelfVouching();\n    error TrustAmountLtLocked();\n    error NoExistingMember();\n    error NotEnoughStakers();\n    error StakeLimitReached();\n    error AssetManagerDepositFailed();\n    error AssetManagerWithdrawFailed();\n    error InsufficientBalance();\n    error LockedStakeNonZero();\n    error NotOverdue();\n    error ExceedsLocked();\n    error AmountZero();\n    error LockedRemaining();\n    error VoucherNotFound();\n    error VouchWhenOverdue();\n    error MaxVouchers();\n    error MaxVouchees();\n    error InvalidParams();\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Add new member event\n     *  @param member New member address\n     */\n    event LogAddMember(address member);\n\n    /**\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /**\n     *  @dev New member application event\n     *  @param account New member's voucher address\n     *  @param borrower New member address\n     */\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Cancel vouching for other member event\n     *  @param account New member's voucher address\n     *  @param borrower The address gets vouched for\n     */\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Stake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev Unstake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to unstake\n     */\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev DebtWriteOff event\n     *  @param staker The staker's address\n     *  @param borrower The borrower's address\n     *  @param amount The amount of write off\n     */\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    /**\n     *  @dev set utoken address\n     *  @param uToken new uToken address\n     */\n    event LogSetUToken(address uToken);\n\n    /**\n     *  @dev set new member fee\n     *  @param oldMemberFee old member fee\n     *  @param newMemberFee new member fee\n     */\n    event LogSetNewMemberFee(uint256 oldMemberFee, uint256 newMemberFee);\n\n    /**\n     *  @dev set max stake amount\n     *  @param oldMaxStakeAmount Old amount\n     *  @param newMaxStakeAmount New amount\n     */\n    event LogSetMaxStakeAmount(uint256 oldMaxStakeAmount, uint256 newMaxStakeAmount);\n\n    /**\n     *  @dev set max overdue blocks\n     *  @param oldMaxOverdueBlocks Old value\n     *  @param newMaxOverdueBlocks New value\n     */\n    event LogSetMaxOverdueBlocks(uint256 oldMaxOverdueBlocks, uint256 newMaxOverdueBlocks);\n\n    /**\n     *  @dev set effective count\n     *  @param oldEffectiveCount Old value\n     *  @param newEffectiveCount New value\n     */\n    event LogSetEffectiveCount(uint256 oldEffectiveCount, uint256 newEffectiveCount);\n\n    /**\n     * @dev Set max voucher\n     * @param maxVouchers new max voucher limit\n     */\n    event LogSetMaxVouchers(uint256 maxVouchers);\n\n    /**\n     * @dev Set max vouchees\n     * @param maxVouchees new max voucher limit\n     */\n    event LogSetMaxVouchees(uint256 maxVouchees);\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address comptroller_,\n        address admin_,\n        uint256 maxOverdueBlocks_,\n        uint256 effectiveCount_,\n        uint256 maxVouchers_,\n        uint256 maxVouchees_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1 ether;\n        maxStakeAmount = 10_000e18;\n        maxOverdueBlocks = maxOverdueBlocks_;\n        effectiveCount = effectiveCount_;\n        maxVouchers = maxVouchers_;\n        maxVouchees = maxVouchees_;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier onlyMember(address account) {\n        if (!checkIsMember(account)) revert AuthFailed();\n        _;\n    }\n\n    modifier onlyMarket() {\n        if (address(uToken) != msg.sender) revert AuthFailed();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Set the max amount that a user can stake\n     * Emits {LogSetMaxStakeAmount} event\n     * @param maxStakeAmount_ The max stake amount\n     */\n    function setMaxStakeAmount(uint96 maxStakeAmount_) external onlyAdmin {\n        uint96 oldMaxStakeAmount = maxStakeAmount;\n        maxStakeAmount = maxStakeAmount_;\n        emit LogSetMaxStakeAmount(uint256(oldMaxStakeAmount), uint256(maxStakeAmount));\n    }\n\n    /**\n     * @dev set the UToken contract address\n     * Emits {LogSetUToken} event\n     * @param uToken_ UToken contract address\n     */\n    function setUToken(address uToken_) external onlyAdmin {\n        uToken = IUToken(uToken_);\n        emit LogSetUToken(uToken_);\n    }\n\n    /**\n     * @dev set New Member fee\n     * @dev The amount of UNION an account must burn to become a member\n     * Emits {LogSetNewMemberFee} event\n     * @param amount New member fee amount\n     */\n    function setNewMemberFee(uint256 amount) external onlyAdmin {\n        uint256 oldMemberFee = newMemberFee;\n        newMemberFee = amount;\n        emit LogSetNewMemberFee(oldMemberFee, amount);\n    }\n\n    /**\n     * @dev set New max overdue blocks\n     * Emits {LogSetMaxOverdueBlocks} event\n     * @param _maxOverdueBlocks New maxOverdueBlocks value\n     */\n    function setMaxOverdueBlocks(uint256 _maxOverdueBlocks) external onlyAdmin {\n        uint256 oldMaxOverdueBlocks = maxOverdueBlocks;\n        maxOverdueBlocks = _maxOverdueBlocks;\n        emit LogSetMaxOverdueBlocks(oldMaxOverdueBlocks, _maxOverdueBlocks);\n    }\n\n    /**\n     * @dev set New effective count\n     * @dev this is the number of vouches an account needs in order\n     *      to register as a member\n     * Emits {LogSetEffectiveCount} event\n     * @param _effectiveCount New effectiveCount value\n     */\n    function setEffectiveCount(uint256 _effectiveCount) external onlyAdmin {\n        uint256 oldEffectiveCount = effectiveCount;\n        effectiveCount = _effectiveCount;\n        emit LogSetEffectiveCount(oldEffectiveCount, _effectiveCount);\n    }\n\n    function setMaxVouchers(uint256 _maxVouchers) external onlyAdmin {\n        maxVouchers = _maxVouchers;\n        emit LogSetMaxVouchers(_maxVouchers);\n    }\n\n    function setMaxVouchees(uint256 _maxVouchees) external onlyAdmin {\n        maxVouchees = _maxVouchees;\n        emit LogSetMaxVouchees(_maxVouchees);\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     */\n    function checkIsMember(address account) public view returns (bool) {\n        return stakers[account].isMember;\n    }\n\n    /**\n     *  @dev  Get the member's available credit limit\n     *  @dev  IMPORTANT: This function can take up a tonne of gas as the vouchers[address] array\n     *        grows in size. the maxVoucher limit will ensure this function can always run within a\n     *        single block but it is intended only to be used as a view function called from a UI\n     *  @param borrower Member address\n     *  @return total Credit line amount\n     */\n    function getCreditLimit(address borrower) external view returns (uint256 total) {\n        for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n            Vouch memory vouch = vouchers[borrower][i];\n            Staker memory staker = stakers[vouch.staker];\n            total += _min(staker.stakedAmount - staker.locked, vouch.trust - vouch.locked);\n        }\n    }\n\n    /**\n     *  @dev  Get the count of vouchers\n     *        Vouchers are addresses that this borrower is receiving a vouch from.\n     *  @param borrower Address of borrower\n     */\n    function getVoucherCount(address borrower) external view returns (uint256) {\n        return vouchers[borrower].length;\n    }\n\n    /**\n     *  @dev  Get the count of vouchees\n     *        Vouchers are addresses that this staker is vouching for\n     *  @param staker Address of staker\n     */\n    function getVoucheeCount(address staker) external view returns (uint256) {\n        return vouchees[staker].length;\n    }\n\n    /**\n     *  @dev Get the user's deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) external view returns (uint256) {\n        return stakers[account].stakedAmount;\n    }\n\n    /**\n     *  @dev Get Total locked stake\n     *  @param staker Staker address\n     */\n    function getTotalLockedStake(address staker) external view returns (uint256) {\n        return stakers[staker].locked;\n    }\n\n    /**\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     */\n    function getLockedStake(address staker, address borrower) external view returns (uint256) {\n        Index memory index = voucherIndexes[borrower][staker];\n        if (!index.isSet) return 0;\n        return vouchers[borrower][index.idx].locked;\n    }\n\n    /**\n     *  @dev Get vouching amount\n     *  @param _staker Staker address\n     *  @param borrower Borrower address\n     */\n    function getVouchingAmount(address _staker, address borrower) external view returns (uint256) {\n        Index memory index = voucherIndexes[borrower][_staker];\n        Staker memory staker = stakers[_staker];\n        if (!index.isSet) return 0;\n        uint96 trustAmount = vouchers[borrower][index.idx].trust;\n        return trustAmount < staker.stakedAmount ? trustAmount : staker.stakedAmount;\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Manually add union members and bypass all the requirements of `registerMember`\n     *  Only accepts calls from the admin\n     *  Emit {LogAddMember} event\n     *  @param account Member address\n     */\n    function addMember(address account) external onlyAdmin {\n        stakers[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /**\n     *  @dev  Update the trust amount for existing members.\n     *  @dev  Trust is the amount of the underlying token you would in theory be\n     *        happy to lend to another member. Vouch is derived from trust and stake.\n     *        Vouch is the minimum of trust and staked amount.\n     *  Emits {LogUpdateTrust} event\n     *  @param borrower Account address\n     *  @param trustAmount Trust amount\n     */\n    function updateTrust(address borrower, uint96 trustAmount) external onlyMember(msg.sender) whenNotPaused {\n        address staker = msg.sender;\n        if (borrower == staker) revert ErrorSelfVouching();\n\n        // Check if this staker is already vouching for this borrower\n        // If they are already vouching then update the existing vouch record\n        // If this is a new vouch then insert a new Vouch record\n        Index memory index = voucherIndexes[borrower][staker];\n        if (index.isSet) {\n            // Update existing record checking that the new trust amount is\n            // not less than the amount of stake currently locked by the borrower\n            Vouch storage vouch = vouchers[borrower][index.idx];\n            if (trustAmount < vouch.locked) revert TrustAmountLtLocked();\n            vouch.trust = trustAmount;\n        } else {\n            // If the member is overdue they cannot create new vouches they can\n            // only update existing vouches\n            if (uToken.checkIsOverdue(staker)) revert VouchWhenOverdue();\n\n            // This is a new vouch so we need to check that the\n            // member has not reached the max voucher limit\n            uint256 voucheeIndex = vouchees[staker].length;\n            if (voucheeIndex >= maxVouchees) revert MaxVouchees();\n\n            // Get the new index that this vouch is going to be inserted at\n            // Then update the voucher indexes for this borrower as well as\n            // Adding the Vouch the the vouchers array for this staker\n            uint256 voucherIndex = vouchers[borrower].length;\n            if (voucherIndex >= maxVouchers) revert MaxVouchers();\n            voucherIndexes[borrower][staker] = Index(true, voucherIndex.toUint128());\n            vouchers[borrower].push(Vouch(staker, trustAmount, 0, 0));\n\n            // Add the voucherIndex of this new vouch to the vouchees array for this\n            // staker then update the voucheeIndexes with the voucheeIndex\n            vouchees[staker].push(Vouchee(borrower, voucherIndex.toUint96()));\n            voucheeIndexes[borrower][staker] = Index(true, voucheeIndex.toUint128());\n        }\n\n        emit LogUpdateTrust(staker, borrower, trustAmount);\n    }\n\n    /**\n     *  @dev Remove voucher for member\n     *  Can be called by either the borrower or the staker. It will remove the voucher from\n     *  the voucher array by replacing it with the last item of the array and resting the array\n     *  size to -1 by popping off the last item\n     *  Only callable by a member when the contract is not paused\n     *  Emit {LogCancelVouch} event\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function _cancelVouchInternal(address staker, address borrower) internal {\n        Index memory removeVoucherIndex = voucherIndexes[borrower][staker];\n        if (!removeVoucherIndex.isSet) revert VoucherNotFound();\n\n        // Check that the locked amount for this vouch is 0\n        Vouch memory vouch = vouchers[borrower][removeVoucherIndex.idx];\n        if (vouch.locked > 0) revert LockedStakeNonZero();\n\n        // Remove borrower from vouchers array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        {\n            // Cache the last voucher\n            Vouch memory lastVoucher = vouchers[borrower][vouchers[borrower].length - 1];\n            // Move the lastVoucher to the index of the voucher we are removing\n            vouchers[borrower][removeVoucherIndex.idx] = lastVoucher;\n            // Pop the last vouch off the end of the vouchers array\n            vouchers[borrower].pop();\n            // Delete the voucher index for this borrower => staker pair\n            delete voucherIndexes[borrower][staker];\n            // Update the last vouchers coresponsing Vouchee item\n            uint128 voucheeIdx = voucherIndexes[borrower][lastVoucher.staker].idx;\n            vouchees[staker][voucheeIdx].voucherIndex = removeVoucherIndex.idx.toUint96();\n        }\n\n        // Update the vouchee entry for this borrower => staker pair\n        {\n            Index memory removeVoucheeIndex = voucheeIndexes[borrower][staker];\n            // Cache the last vouchee\n            Vouchee memory lastVouchee = vouchees[staker][vouchees[staker].length - 1];\n            // Move the last vouchee to the index of the removed vouchee\n            vouchees[staker][removeVoucheeIndex.idx] = lastVouchee;\n            // Pop the last vouchee off the end of the vouchees array\n            vouchees[staker].pop();\n            // Delete the vouchee index for this borrower => staker pair\n            delete voucheeIndexes[borrower][staker];\n            // Update the vouchee indexes to the new vouchee index\n            voucheeIndexes[lastVouchee.borrower][staker].idx = removeVoucheeIndex.idx;\n        }\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    /**\n     *  Cancels a vouch between a staker and a borrower.\n     *  @dev The function can only be called by a member of the stakers list.\n     *  @param staker The address of the staker who made the vouch.\n     *  @param borrower The address of the borrower who received the vouch.\n     */\n    function cancelVouch(address staker, address borrower) public onlyMember(msg.sender) whenNotPaused {\n        if (staker != msg.sender && borrower != msg.sender) revert AuthFailed();\n        _cancelVouchInternal(staker, borrower);\n    }\n\n    /**\n     *  @notice Register a a member using a signed permit\n     *  @dev See registerMember\n     *  @param newMember New member address\n     *  @param value Amount approved by permit\n     *  @param deadline Timestamp for when the permit expires\n     *  @param v secp256k1 signature part\n     *  @param r secp256k1 signature part\n     *  @param s secp256k1 signature part\n     */\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused {\n        IUnionToken(unionToken).permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /**\n     *  @notice Register a a member, and burn the application fee\n     *  @dev    In order to register as a member an address must be receiving x amount\n     *          of vouches greater than 0 from stakers. x is defined by `effectiveCount`\n     *          Emits {LogRegisterMember} event\n     *  @param newMember New member address\n     */\n    function registerMember(address newMember) public virtual whenNotPaused {\n        _validateNewMember(newMember);\n\n        IUnionToken(unionToken).burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    /**\n     *  @notice Stake staking tokens\n     *  @dev    Stake is used to underwrite loans and becomes locked if a\n     *          member a staker has vouched for borrows against it.\n     *          Stake also earns rewards from the comptroller\n     *  Emits a {LogStake} event.\n     *  @param amount Amount to stake\n     */\n    function stake(uint96 amount) public whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        Staker storage staker = stakers[msg.sender];\n\n        if (staker.stakedAmount + amount > maxStakeAmount) revert StakeLimitReached();\n\n        _updateStakedCoinAge(msg.sender, staker);\n        staker.stakedAmount += amount;\n        totalStaked += amount;\n\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 currentAllowance = erc20Token.allowance(address(this), assetManager);\n        if (currentAllowance < amount) {\n            erc20Token.safeIncreaseAllowance(assetManager, amount - currentAllowance);\n        }\n\n        if (!IAssetManager(assetManager).deposit(stakingToken, amount)) revert AssetManagerDepositFailed();\n        emit LogStake(msg.sender, amount);\n    }\n\n    /**\n     *  @notice Unstake staking token\n     *  @dev    Tokens can only be unstaked if they are not locked. ie a\n     *          vouchee is not borrowing against them.\n     *  Emits {LogUnstake} event\n     *  @param amount Amount to unstake\n     */\n    function unstake(uint96 amount) external whenNotPaused nonReentrant {\n        Staker storage staker = stakers[msg.sender];\n\n        // Stakers can only unstaked stake balance that is unlocked. Stake balance\n        // becomes locked when it is used to underwrite a borrow.\n        if (staker.stakedAmount - staker.locked < amount) revert InsufficientBalance();\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 remaining = IAssetManager(assetManager).withdraw(stakingToken, msg.sender, amount);\n        if (uint96(remaining) > amount) {\n            revert AssetManagerWithdrawFailed();\n        }\n        uint96 actualAmount = amount - uint96(remaining);\n\n        _updateStakedCoinAge(msg.sender, staker);\n        staker.stakedAmount -= actualAmount;\n        totalStaked -= actualAmount;\n\n        emit LogUnstake(msg.sender, actualAmount);\n    }\n\n    /**\n     *  @dev collect staker rewards from the comptroller\n     */\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n    }\n\n    /**\n     *  @notice Write off a borrowers debt\n     *  @dev    Used the stakers locked stake to write off the loan, transferring the\n     *          Stake to the AssetManager and adjusting balances in the AssetManager\n     *          and the UToken to repay the principal\n     *  @dev    Emits {LogDebtWriteOff} event\n     *  @param stakerAddress address of staker\n     *  @param borrowerAddress address of borrower\n     *  @param amount amount to writeoff\n     */\n    function debtWriteOff(\n        address stakerAddress,\n        address borrowerAddress,\n        uint96 amount\n    ) external {\n        if (amount == 0) revert AmountZero();\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 lastRepay = uToken.getLastRepay(borrowerAddress);\n\n        // This function is only callable by the public if the loan is overdue by\n        // overdue blocks + maxOverdueBlocks. This stops the system being left with\n        // debt that is overdue indefinitely and no ability to do anything about it.\n        if (block.number <= lastRepay + overdueBlocks + maxOverdueBlocks) {\n            if (stakerAddress != msg.sender) revert AuthFailed();\n        }\n\n        Index memory index = voucherIndexes[borrowerAddress][stakerAddress];\n        if (!index.isSet) revert VoucherNotFound();\n        Vouch storage vouch = vouchers[borrowerAddress][index.idx];\n\n        if (amount > vouch.locked) revert ExceedsLocked();\n\n        // update staker staked amount\n        Staker storage staker = stakers[stakerAddress];\n        _updateStakedCoinAge(stakerAddress, staker);\n        staker.stakedAmount -= amount;\n        staker.locked -= amount;\n        totalStaked -= amount;\n\n        // update vouch trust amount\n        vouch.trust -= amount;\n        vouch.locked -= amount;\n\n        // Update total frozen and member frozen. We don't want to move th\n        // burden of calling updateFrozenInfo into this function as it is quite\n        // gas intensive. Instead we just want to remove the amount that was\n        // frozen which is now being written off. However, it is possible that\n        // member frozen has not been updated prior to calling debtWriteOff and\n        // the amount being written off could be greater than the amount frozen.\n        // To avoid an underflow here we need to check this condition\n        uint256 stakerFrozen = memberFrozen[stakerAddress];\n        if (amount > stakerFrozen) {\n            // The amount being written off is more than the amount that has\n            // been previously frozen for this staker. Reset their frozen stake\n            // to zero and adjust totalFrozen\n            memberFrozen[stakerAddress] = 0;\n            totalFrozen -= stakerFrozen;\n        } else {\n            totalFrozen -= amount;\n            memberFrozen[stakerAddress] -= amount;\n        }\n\n        if (vouch.trust == 0) {\n            _cancelVouchInternal(stakerAddress, borrowerAddress);\n        }\n\n        // Notify the AssetManager and the UToken market of the debt write off\n        // so they can adjust their balances accordingly\n        IAssetManager(assetManager).debtWriteOff(stakingToken, uint256(amount));\n        uToken.debtWriteOff(borrowerAddress, uint256(amount));\n\n        comptroller.updateTotalStaked(stakingToken, totalStaked - totalFrozen);\n\n        emit LogDebtWriteOff(msg.sender, borrowerAddress, uint256(amount));\n    }\n\n    /**\n     *  @notice Borrowing from the market\n     *  @dev    Locks/Unlocks the borrowers stakers staked amounts in a first in\n     *          First out order. Meaning the members that vouched for this borrower\n     *          first will be the first members to get their stake locked or unlocked\n     *          following a borrow or repayment.\n     *  @param borrower The address of the borrower\n     *  @param amount Lock/Unlock amount\n     *  @param lock If the amount is being locked or unlocked\n     */\n    function updateLocked(\n        address borrower,\n        uint96 amount,\n        bool lock\n    ) external onlyMarket {\n        uint96 remaining = amount;\n\n        uint256 vouchersLength = vouchers[borrower].length;\n        for (uint256 i = 0; i < vouchersLength; i++) {\n            Vouch storage vouch = vouchers[borrower][i];\n            uint96 innerAmount;\n\n            uint256 lastWithdrawRewards = getLastWithdrawRewards[vouch.staker];\n            stakers[vouch.staker].lockedCoinAge +=\n                (block.number - _max(lastWithdrawRewards, uint256(vouch.lastUpdated))) *\n                uint256(vouch.locked);\n            if (lock) {\n                // Look up the staker and determine how much unlock stake they\n                // have available for the borrower to borrow. If there is 0\n                // then continue to the next voucher in the array\n                uint96 stakerLocked = stakers[vouch.staker].locked;\n                uint96 stakerStakedAmount = stakers[vouch.staker].stakedAmount;\n                uint96 availableStake = stakerStakedAmount - stakerLocked;\n                uint96 lockAmount = _min(availableStake, vouch.trust - vouch.locked);\n                if (lockAmount == 0) continue;\n                // Calculate the amount to add to the lock then\n                // add the extra amount to lock to the stakers locked amount\n                // and also update the vouches locked amount and lastUpdated block\n                innerAmount = _min(remaining, lockAmount);\n                stakers[vouch.staker].locked = stakerLocked + innerAmount;\n                vouch.locked += innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            } else {\n                // Look up how much this vouch has locked. If it is 0 then\n                // continue to the next voucher. Then calculate the amount to\n                // unlock which is the min of the vouches lock and what is\n                // remaining to unlock\n                uint96 locked = vouch.locked;\n                if (locked == 0) continue;\n                innerAmount = _min(locked, remaining);\n                // Update the stored locked values and last updated block\n                stakers[vouch.staker].locked -= innerAmount;\n                vouch.locked -= innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            }\n\n            remaining -= innerAmount;\n            // If there is no remaining amount to lock/unlock\n            // we can stop looping through vouchers\n            if (remaining <= 0) break;\n        }\n\n        // If we have looped through all the avai"
    }
  ]
}