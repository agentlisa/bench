{
  "Title": "M-9: Vault Factory ownership can be changed immediately and bypass timelock delay",
  "Content": "# Issue M-9: Vault Factory ownership can be changed immediately and bypass timelock delay \n\nSource: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/337 \n\n## Found by \nast3ros\n\n## Summary\n\nThe VaultFactoryV2 contract is supposed to use a timelock contract with a delay period when changing its owner. However, there is a loophole that allows the owner to change the owner address instantly, without waiting for the delay period to expire. This defeats the purpose of the timelock contract and exposes the VaultFactoryV2 contract to potential abuse.\n\n## Vulnerability Detail\n\nIn project description, timelock is required when making critical changes. Admin can only configure new markets and epochs on those markets.\n\n        2) Admin can configure new markets and epochs on those markets, Timelock can make cirital changes like changing the oracle or whitelisitng controllers.\n\nThe VaultFactoryV2 contract has a `changeOwner` function that is supposed to be called only by the timelock contract with a delay period.\n\n```javascript\nfunction changeOwner(address _owner) public onlyTimeLocker {\n        if (_owner == address(0)) revert AddressZero();\n        _transferOwnership(_owner);\n    }\n```\n\nThe VaultFactoryV2 contract inherits from the Openzeppelin Ownable contract, which has a transferOwnership function that allows the owner to change the owner address immediately. However, the `transferOwnership` function is not overridden by the `changeOwner` function, which creates a conflict and a vulnerability. The owner can bypass the timelock delay and use the transferOwnership function to change the owner address instantly.\n\n```javascript\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/VaultFactoryV2.sol#L325-L328\n\n## Impact\n\nThe transferOwnership is not worked as design (using timelock), the timelock delay become useless. This means that if the owner address is hacked or corrupted, the attacker can take over the contract immediately, leaving no time for the protocol and the users to respond or intervene.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/VaultFactoryV2.sol#L325-L328\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOverride the `transferOwnership` function and add modifier `onlyTimeLocker`.\n\n\n\n\n\n## Discussion\n\n**thangtranth**\n\nEscalate for 10 USDC.\n\nThis issue is different from #501 and cannot be ignored. It is not related to using two steps to change ownership. The problem here is that the transferOwnership function in the Ownable contract is not overridden as it should be. This allows the owner to change the ownership without going through the timelock. This creates a severe security risk and undermines the trust and transparency of the protocol as stated in spec.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> This issue is different from #501 and cannot be ignored. It is not related to using two steps to change ownership. The problem here is that the transferOwnership function in the Ownable contract is not overridden as it should be. This allows the owner to change the ownership without going through the timelock. This creates a severe security risk and undermines the trust and transparency of the protocol as stated in spec.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nNot a duplicate of #501 \nand can be considered a valid medium since this identifies the issue that `transferOwnership` is not overridden and needs to have `onlyTimeLocker' modifier, \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Not a duplicate of #501 \n> and can be considered a valid medium since this identifies the issue that `transferOwnership` is not overridden and needs to have `onlyTimeLocker' modifier, \n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**hrishibhat**\n\nLead Judge comment:\n> looks valid, maybe med, if they intend to do it without a delay is one thing and to be documented, but if a function just left not overriden it's a bug\n\nSponsor comment:\n> Actually thats valid issue, .... fixing this will make this action more complicated. My thinking is to add a direct function on timelocker which lets timelocker execute the owner (deployer) change without 7day queue.\n\n\n**3xHarry**\n\nFIX RP: https://github.com/Y2K-Finance/Earthquake/pull/147 - last two commits\n\n**IAm0x52**\n\nFix looks good. changeOwner has been removed and transferOwnership has been overridden to allow only timelocker\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/57",
  "Code": [
    {
      "filename": "Earthquake/src/v2/VaultFactoryV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IVaultV2} from \"./interfaces/IVaultV2.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {VaultV2Creator} from \"./libraries/VaultV2Creator.sol\";\n\n/// @author Y2K Finance Team\n\ncontract VaultFactoryV2 is Ownable {\n    address public immutable WETH;\n    bytes internal constant COLLAT = \"COLLATERAL\";\n    bytes internal constant PREMIUM = \"PREMIUM\";\n    bytes internal constant CSYMBOL = \"cY2K\";\n    bytes internal constant PSYMBOL = \"pY2K\";\n    /*//////////////////////////////////////////////////////////////\n                                Storage\n    //////////////////////////////////////////////////////////////*/\n    address public treasury;\n    bool internal adminSetController;\n    address public timelocker;\n\n    mapping(uint256 => address[2]) public marketIdToVaults; //[0] premium and [1] collateral vault\n    mapping(uint256 => uint256[]) public marketIdToEpochs; //all epochs in the market\n    mapping(uint256 => uint16) public epochFee; // epochId to fee\n    mapping(address => address) public tokenToOracle; //token address to respective oracle smart contract address\n    mapping(address => bool) public controllers;\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Contract constructor\n     * @param _weth WETH address\n     * @param _treasury Treasury address\n     * @param _timelocker Timelocker address\n     */\n    constructor(\n        address _weth,\n        address _treasury,\n        address _timelocker\n    ) {\n        if (_weth == address(0)) revert AddressZero();\n        WETH = _weth;\n        timelocker = _timelocker;\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n    @notice Function to create two new vaults, premium and collateral, with the respective params, and storing the oracle for the token provided\n    @param  _marketCalldata MarketConfigurationCalldata struct with the market params\n    @return premium address of the premium vault\n    @return collateral address of the collateral vault\n    @return marketId uint256 of the marketId\n     */\n    function createNewMarket(MarketConfigurationCalldata memory _marketCalldata)\n        external\n        onlyOwner\n        returns (\n            address premium,\n            address collateral,\n            uint256 marketId\n        )\n    {\n        if (!controllers[_marketCalldata.controller]) revert ControllerNotSet();\n        if (_marketCalldata.token == address(0)) revert AddressZero();\n        if (_marketCalldata.oracle == address(0)) revert AddressZero();\n        if (_marketCalldata.underlyingAsset == address(0)) revert AddressZero();\n\n        if (tokenToOracle[_marketCalldata.token] == address(0)) {\n            tokenToOracle[_marketCalldata.token] = _marketCalldata.oracle;\n        }\n\n        marketId = getMarketId(_marketCalldata.token, _marketCalldata.strike);\n        if (marketIdToVaults[marketId][0] != address(0))\n            revert MarketAlreadyExists();\n\n        //y2kUSDC_99*PREMIUM\n        premium = VaultV2Creator.createVaultV2(\n            VaultV2Creator.MarketConfiguration(\n                _marketCalldata.underlyingAsset == WETH,\n                _marketCalldata.underlyingAsset,\n                string(abi.encodePacked(_marketCalldata.name, PREMIUM)),\n                string(PSYMBOL),\n                _marketCalldata.tokenURI,\n                _marketCalldata.token,\n                _marketCalldata.strike,\n                _marketCalldata.controller,\n                treasury\n            )\n        );\n\n        // y2kUSDC_99*COLLATERAL\n        collateral = VaultV2Creator.createVaultV2(\n            VaultV2Creator.MarketConfiguration(\n                _marketCalldata.underlyingAsset == WETH,\n                _marketCalldata.underlyingAsset,\n                string(abi.encodePacked(_marketCalldata.name, COLLAT)),\n                string(CSYMBOL),\n                _marketCalldata.tokenURI,\n                _marketCalldata.token,\n                _marketCalldata.strike,\n                _marketCalldata.controller,\n                treasury\n            )\n        );\n\n        //set counterparty vault\n        IVaultV2(premium).setCounterPartyVault(collateral);\n        IVaultV2(collateral).setCounterPartyVault(premium);\n\n        marketIdToVaults[marketId] = [premium, collateral];\n\n        emit MarketCreated(\n            marketId,\n            premium,\n            collateral,\n            _marketCalldata.underlyingAsset,\n            _marketCalldata.token,\n            _marketCalldata.name,\n            _marketCalldata.strike,\n            _marketCalldata.controller\n        );\n\n        return (premium, collateral, marketId);\n    }\n\n    /**    \n    @notice Function set epoch for market,\n    @param  _marketId uint256 of the market index to create more assets in\n    @param  _epochBegin uint40 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  _epochEnd uint40 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint16 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function createEpoch(\n        uint256 _marketId,\n        uint40 _epochBegin,\n        uint40 _epochEnd,\n        uint16 _withdrawalFee\n    ) public onlyOwner returns (uint256 epochId, address[2] memory vaults) {\n        vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        if (_withdrawalFee == 0) revert FeeCannotBe0();\n\n        if (!controllers[IVaultV2(vaults[0]).controller()])\n            revert ControllerNotSet();\n        if (!controllers[IVaultV2(vaults[1]).controller()])\n            revert ControllerNotSet();\n\n        epochId = getEpochId(_marketId, _epochBegin, _epochEnd);\n\n        _setEpoch(\n            EpochConfiguration(\n                _epochBegin,\n                _epochEnd,\n                _withdrawalFee,\n                _marketId,\n                epochId,\n                IVaultV2(vaults[0]),\n                IVaultV2(vaults[1])\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function _setEpoch(EpochConfiguration memory _epochConfig) internal {\n        _epochConfig.premium.setEpoch(\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            _epochConfig.epochId\n        );\n        _epochConfig.collateral.setEpoch(\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            _epochConfig.epochId\n        );\n\n        epochFee[_epochConfig.epochId] = _epochConfig.withdrawalFee;\n        marketIdToEpochs[_epochConfig.marketId].push(_epochConfig.epochId);\n\n        emit EpochCreated(\n            _epochConfig.epochId,\n            _epochConfig.marketId,\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            address(_epochConfig.premium),\n            address(_epochConfig.collateral),\n            _epochConfig.premium.token(),\n            _epochConfig.premium.strike(),\n            _epochConfig.withdrawalFee\n        );\n    }\n\n    /**\n    @notice Function to whitelist controller smart contract, only owner or timelocker can add more controllers. \n    owner can set controller once, all future controllers must be set by timelocker.\n    @param  _controller Address of the controller smart contract\n     */\n    function whitelistController(address _controller) public {\n        if (_controller == address(0)) revert AddressZero();\n        if (msg.sender == owner() && !adminSetController) {\n            controllers[_controller] = true;\n            adminSetController = true;\n            emit ControllerWhitelisted(_controller);\n        } else if (msg.sender == timelocker) {\n            controllers[_controller] = !controllers[_controller];\n            if (!adminSetController) adminSetController = true;\n            emit ControllerWhitelisted(_controller);\n        } else {\n            revert NotAuthorized();\n        }\n    }\n\n    /**\n    @notice Admin function, whitelists an address on vault for sendTokens function\n    @param _treasury Treasury address\n    @param  _marketId Target market index\n     */\n    function changeTreasury(uint256 _marketId, address _treasury)\n        public\n        onlyTimeLocker\n    {\n        if (_treasury == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).whiteListAddress(_treasury);\n        IVaultV2(vaults[1]).whiteListAddress(_treasury);\n        IVaultV2(vaults[0]).setTreasury(treasury);\n        IVaultV2(vaults[1]).setTreasury(treasury);\n\n        emit AddressWhitelisted(_treasury, _marketId);\n    }\n\n    /**\n    @notice Admin function, whitelists an address on vault for sendTokens function\n    @param  _marketId Target market index\n    @param _wAddress Treasury address\n     */\n    function whitelistAddressOnMarket(uint256 _marketId, address _wAddress)\n        public\n        onlyTimeLocker\n    {\n        if (_wAddress == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).whiteListAddress(_wAddress);\n        IVaultV2(vaults[1]).whiteListAddress(_wAddress);\n\n        emit AddressWhitelisted(_wAddress, _marketId);\n    }\n\n    /**\n    @notice Admin function, sets treasury address\n    @param _treasury Treasury address\n     */\n    function setTreasury(address _treasury) public onlyTimeLocker {\n        if (_treasury == address(0)) revert AddressZero();\n        treasury = _treasury;\n        emit TreasurySet(_treasury);\n    }\n\n    /**\n    @notice Timelocker function, changes controller address on vaults\n    @param _marketId Target marketId\n    @param  _controller Address of the controller smart contract\n     */\n    function changeController(uint256 _marketId, address _controller)\n        public\n        onlyTimeLocker\n        controllerIsWhitelisted(_controller)\n    {\n        if (_controller == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).changeController(_controller);\n        IVaultV2(vaults[1]).changeController(_controller);\n\n        emit ControllerChanged(_marketId, _controller, vaults[0], vaults[1]);\n    }\n\n    /**\n    @notice Timelocker function, changes oracle address for a given token\n    @param _token Target token address\n    @param  _oracle Oracle address\n     */\n    function changeOracle(address _token, address _oracle)\n        public\n        onlyTimeLocker\n    {\n        if (_oracle == address(0)) revert AddressZero();\n        if (_token == address(0)) revert AddressZero();\n\n        tokenToOracle[_token] = _oracle;\n        emit OracleChanged(_token, _oracle);\n    }\n\n    /**\n    @notice Timelocker function, changes owner address\n    @param _owner Address of the new _owner\n     */\n    function changeOwner(address _owner) public onlyTimeLocker {\n        if (_owner == address(0)) revert AddressZero();\n        _transferOwnership(_owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function the retrieve the addresses of the premium and collateral vaults, in an array, in the respective order\n    @param index uint256 of the market index which to the vaults are associated to\n    @return vaults Address array of two vaults addresses, [0] being the premium vault, [1] being the collateral vault\n     */\n    function getVaults(uint256 index)\n        public\n        view\n        returns (address[2] memory vaults)\n    {\n        return marketIdToVaults[index];\n    }\n\n    /**\n    @notice Function to retrieve the epochId for a given marketId\n    @param marketId marketId\n    @return epochIds uint256 array of epochIds\n     */\n    function getEpochsByMarketId(uint256 marketId)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return marketIdToEpochs[marketId];\n    }\n\n    /**\n    @notice Function to retrieve the fee for a given epoch\n    @param epochId uint256 of the epoch\n    @return fee uint16 of the fee\n     */\n    function getEpochFee(uint256 epochId) public view returns (uint16 fee) {\n        return epochFee[epochId];\n    }\n\n    /**\n    @notice Function to compute the marketId from a token and a strike price\n    @param token Address of the token\n    @param strikePrice uint256 of the strike price\n    @return marketId uint256 of the marketId\n     */\n    function getMarketId(address token, uint256 strikePrice)\n        public\n        pure\n        returns (uint256 marketId)\n    {\n        return uint256(keccak256(abi.encodePacked(token, strikePrice)));\n    }\n\n    /**\n    @notice Function to compute the epochId from a marketId, epochBegin and epochEnd\n    @param marketId uint256 of the marketId\n    @param epochBegin uint40 of the epoch begin\n    @param epochEnd uint40 of the epoch end\n    @return epochId uint256 of the epochId\n     */\n    function getEpochId(\n        uint256 marketId,\n        uint40 epochBegin,\n        uint40 epochEnd\n    ) public pure returns (uint256 epochId) {\n        return\n            uint256(\n                keccak256(abi.encodePacked(marketId, epochBegin, epochEnd))\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n    struct MarketConfigurationCalldata {\n        address token;\n        uint256 strike;\n        address oracle;\n        address underlyingAsset;\n        string name;\n        string tokenURI;\n        address controller;\n    }\n\n    struct EpochConfiguration {\n        uint40 epochBegin;\n        uint40 epochEnd;\n        uint16 withdrawalFee;\n        uint256 marketId;\n        uint256 epochId;\n        IVaultV2 premium;\n        IVaultV2 collateral;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Modifier to check if the caller is the timelocker\n     */\n    modifier onlyTimeLocker() {\n        if (msg.sender != timelocker) revert NotTimeLocker();\n        _;\n    }\n\n    /** @notice Modifier to check if the controller is whitelisted on the factory\n     */\n    modifier controllerIsWhitelisted(address _controller) {\n        if (!controllers[_controller]) revert ControllerNotSet();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error MarketDoesNotExist(uint256 marketId);\n    error MarketAlreadyExists();\n    error AddressZero();\n    error ControllerNotSet();\n    error NotTimeLocker();\n    error NotAuthorized();\n    error FeeCannotBe0();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Market is created when event is emitted\n     * @param marketId market id\n     * @param premium premium vault address\n     * @param collateral collateral vault address\n     * @param underlyingAsset underlying asset address\n     * @param token Token address to monitor strike price\n     * @param name Market name\n     * @param strike Strike price\n     * @param controller Controller address\n     */\n    event MarketCreated(\n        uint256 indexed marketId,\n        address premium,\n        address collateral,\n        address underlyingAsset,\n        address token,\n        string name,\n        uint256 strike,\n        address controller\n    );\n\n    /** @notice event is emitted when epoch is created\n     * @param epochId epoch id derrived out of market id, start and end epoch\n     * @param marketId Current market index\n     * @param startEpoch Epoch start time\n     * @param endEpoch Epoch end time\n     * @param premium premium vault address\n     * @param collateral collateral vault address\n     * @param token Token address\n     * @param strike Strike price\n     * @param withdrawalFee Withdrawal fee\n     */\n    event EpochCreated(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        uint40 startEpoch,\n        uint40 endEpoch,\n        address premium,\n        address collateral,\n        address token,\n        uint256 strike,\n        uint16 withdrawalFee\n    );\n\n    /** @notice Controller is changed when event is emitted\n     * @param marketId Target market index\n     * @param controller Target controller address\n     * @param premium Target premium vault address\n     * @param collateral Target collateral vault address\n     */\n    event ControllerChanged(\n        uint256 indexed marketId,\n        address indexed controller,\n        address premium,\n        address collateral\n    );\n\n    /** @notice Oracle is changed when event is emitted\n     * @param _token Target token address\n     * @param _oracle Target oracle address\n     */\n    event OracleChanged(address indexed _token, address _oracle);\n\n    /** @notice Address whitelisted is changed when event is emitted\n     * @param _wAddress whitelisted address\n     * @param _marketId Target market index\n     */\n    event AddressWhitelisted(address _wAddress, uint256 indexed _marketId);\n\n    /** @notice Treasury is changed when event is emitted\n     * @param _treasury Treasury address\n     */\n    event TreasurySet(address _treasury);\n\n    /** @notice New Controller is whitelisted when event is emitted\n     * @param _controller Controller address\n     */\n    event ControllerWhitelisted(address _controller);\n}"
    },
    {
      "filename": "Earthquake/src/v2/VaultFactoryV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IVaultV2} from \"./interfaces/IVaultV2.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {VaultV2Creator} from \"./libraries/VaultV2Creator.sol\";\n\n/// @author Y2K Finance Team\n\ncontract VaultFactoryV2 is Ownable {\n    address public immutable WETH;\n    bytes internal constant COLLAT = \"COLLATERAL\";\n    bytes internal constant PREMIUM = \"PREMIUM\";\n    bytes internal constant CSYMBOL = \"cY2K\";\n    bytes internal constant PSYMBOL = \"pY2K\";\n    /*//////////////////////////////////////////////////////////////\n                                Storage\n    //////////////////////////////////////////////////////////////*/\n    address public treasury;\n    bool internal adminSetController;\n    address public timelocker;\n\n    mapping(uint256 => address[2]) public marketIdToVaults; //[0] premium and [1] collateral vault\n    mapping(uint256 => uint256[]) public marketIdToEpochs; //all epochs in the market\n    mapping(uint256 => uint16) public epochFee; // epochId to fee\n    mapping(address => address) public tokenToOracle; //token address to respective oracle smart contract address\n    mapping(address => bool) public controllers;\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Contract constructor\n     * @param _weth WETH address\n     * @param _treasury Treasury address\n     * @param _timelocker Timelocker address\n     */\n    constructor(\n        address _weth,\n        address _treasury,\n        address _timelocker\n    ) {\n        if (_weth == address(0)) revert AddressZero();\n        WETH = _weth;\n        timelocker = _timelocker;\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n    @notice Function to create two new vaults, premium and collateral, with the respective params, and storing the oracle for the token provided\n    @param  _marketCalldata MarketConfigurationCalldata struct with the market params\n    @return premium address of the premium vault\n    @return collateral address of the collateral vault\n    @return marketId uint256 of the marketId\n     */\n    function createNewMarket(MarketConfigurationCalldata memory _marketCalldata)\n        external\n        onlyOwner\n        returns (\n            address premium,\n            address collateral,\n            uint256 marketId\n        )\n    {\n        if (!controllers[_marketCalldata.controller]) revert ControllerNotSet();\n        if (_marketCalldata.token == address(0)) revert AddressZero();\n        if (_marketCalldata.oracle == address(0)) revert AddressZero();\n        if (_marketCalldata.underlyingAsset == address(0)) revert AddressZero();\n\n        if (tokenToOracle[_marketCalldata.token] == address(0)) {\n            tokenToOracle[_marketCalldata.token] = _marketCalldata.oracle;\n        }\n\n        marketId = getMarketId(_marketCalldata.token, _marketCalldata.strike);\n        if (marketIdToVaults[marketId][0] != address(0))\n            revert MarketAlreadyExists();\n\n        //y2kUSDC_99*PREMIUM\n        premium = VaultV2Creator.createVaultV2(\n            VaultV2Creator.MarketConfiguration(\n                _marketCalldata.underlyingAsset == WETH,\n                _marketCalldata.underlyingAsset,\n                string(abi.encodePacked(_marketCalldata.name, PREMIUM)),\n                string(PSYMBOL),\n                _marketCalldata.tokenURI,\n                _marketCalldata.token,\n                _marketCalldata.strike,\n                _marketCalldata.controller,\n                treasury\n            )\n        );\n\n        // y2kUSDC_99*COLLATERAL\n        collateral = VaultV2Creator.createVaultV2(\n            VaultV2Creator.MarketConfiguration(\n                _marketCalldata.underlyingAsset == WETH,\n                _marketCalldata.underlyingAsset,\n                string(abi.encodePacked(_marketCalldata.name, COLLAT)),\n                string(CSYMBOL),\n                _marketCalldata.tokenURI,\n                _marketCalldata.token,\n                _marketCalldata.strike,\n                _marketCalldata.controller,\n                treasury\n            )\n        );\n\n        //set counterparty vault\n        IVaultV2(premium).setCounterPartyVault(collateral);\n        IVaultV2(collateral).setCounterPartyVault(premium);\n\n        marketIdToVaults[marketId] = [premium, collateral];\n\n        emit MarketCreated(\n            marketId,\n            premium,\n            collateral,\n            _marketCalldata.underlyingAsset,\n            _marketCalldata.token,\n            _marketCalldata.name,\n            _marketCalldata.strike,\n            _marketCalldata.controller\n        );\n\n        return (premium, collateral, marketId);\n    }\n\n    /**    \n    @notice Function set epoch for market,\n    @param  _marketId uint256 of the market index to create more assets in\n    @param  _epochBegin uint40 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  _epochEnd uint40 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint16 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function createEpoch(\n        uint256 _marketId,\n        uint40 _epochBegin,\n        uint40 _epochEnd,\n        uint16 _withdrawalFee\n    ) public onlyOwner returns (uint256 epochId, address[2] memory vaults) {\n        vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        if (_withdrawalFee == 0) revert FeeCannotBe0();\n\n        if (!controllers[IVaultV2(vaults[0]).controller()])\n            revert ControllerNotSet();\n        if (!controllers[IVaultV2(vaults[1]).controller()])\n            revert ControllerNotSet();\n\n        epochId = getEpochId(_marketId, _epochBegin, _epochEnd);\n\n        _setEpoch(\n            EpochConfiguration(\n                _epochBegin,\n                _epochEnd,\n                _withdrawalFee,\n                _marketId,\n                epochId,\n                IVaultV2(vaults[0]),\n                IVaultV2(vaults[1])\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function _setEpoch(EpochConfiguration memory _epochConfig) internal {\n        _epochConfig.premium.setEpoch(\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            _epochConfig.epochId\n        );\n        _epochConfig.collateral.setEpoch(\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            _epochConfig.epochId\n        );\n\n        epochFee[_epochConfig.epochId] = _epochConfig.withdrawalFee;\n        marketIdToEpochs[_epochConfig.marketId].push(_epochConfig.epochId);\n\n        emit EpochCreated(\n            _epochConfig.epochId,\n            _epochConfig.marketId,\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            address(_epochConfig.premium),\n            address(_epochConfig.collateral),\n            _epochConfig.premium.token(),\n            _epochConfig.premium.strike(),\n            _epochConfig.withdrawalFee\n        );\n    }\n\n    /**\n    @notice Function to whitelist controller smart contract, only owner or timelocker can add more controllers. \n    owner can set controller once, all future controllers must be set by timelocker.\n    @param  _controller Address of the controller smart contract\n     */\n    function whitelistController(address _controller) public {\n        if (_controller == address(0)) revert AddressZero();\n        if (msg.sender == owner() && !adminSetController) {\n            controllers[_controller] = true;\n            adminSetController = true;\n            emit ControllerWhitelisted(_controller);\n        } else if (msg.sender == timelocker) {\n            controllers[_controller] = !controllers[_controller];\n            if (!adminSetController) adminSetController = true;\n            emit ControllerWhitelisted(_controller);\n        } else {\n            revert NotAuthorized();\n        }\n    }\n\n    /**\n    @notice Admin function, whitelists an address on vault for sendTokens function\n    @param _treasury Treasury address\n    @param  _marketId Target market index\n     */\n    function changeTreasury(uint256 _marketId, address _treasury)\n        public\n        onlyTimeLocker\n    {\n        if (_treasury == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).whiteListAddress(_treasury);\n        IVaultV2(vaults[1]).whiteListAddress(_treasury);\n        IVaultV2(vaults[0]).setTreasury(treasury);\n        IVaultV2(vaults[1]).setTreasury(treasury);\n\n        emit AddressWhitelisted(_treasury, _marketId);\n    }\n\n    /**\n    @notice Admin function, whitelists an address on vault for sendTokens function\n    @param  _marketId Target market index\n    @param _wAddress Treasury address\n     */\n    function whitelistAddressOnMarket(uint256 _marketId, address _wAddress)\n        public\n        onlyTimeLocker\n    {\n        if (_wAddress == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).whiteListAddress(_wAddress);\n        IVaultV2(vaults[1]).whiteListAddress(_wAddress);\n\n        emit AddressWhitelisted(_wAddress, _marketId);\n    }\n\n    /**\n    @notice Admin function, sets treasury address\n    @param _treasury Treasury address\n     */\n    function setTreasury(address _treasury) public onlyTimeLocker {\n        if (_treasury == address(0)) revert AddressZero();\n        treasury = _treasury;\n        emit TreasurySet(_treasury);\n    }\n\n    /**\n    @notice Timelocker function, changes controller address on vaults\n    @param _marketId Target marketId\n    @param  _controller Address of the controller smart contract\n     */\n    function changeController(uint256 _marketId, address _controller)\n        public\n        onlyTimeLocker\n        controllerIsWhitelisted(_controller)\n    {\n        if (_controller == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).changeController(_controller);\n        IVaultV2(vaults[1]).changeController(_controller);\n\n        emit ControllerChanged(_marketId, _controller, vaults[0], vaults[1]);\n    }\n\n    /**\n    @notice Timelocker function, changes oracle address for a given token\n    @param _token Target token address\n    @param  _oracle Oracle address\n     */\n    function changeOracle(address _token, address _oracle)\n        public\n        onlyTimeLocker\n    {\n        if (_oracle == address(0)) revert AddressZero();\n        if (_token == address(0)) revert AddressZero();\n\n        tokenToOracle[_token] = _oracle;\n        emit OracleChanged(_token, _oracle);\n    }\n\n    /**\n    @notice Timelocker function, changes owner address\n    @param _owner Address of the new _owner\n     */\n    function changeOwner(address _owner) public onlyTimeLocker {\n        if (_owner == address(0)) revert AddressZero();\n        _transferOwnership(_owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function the retrieve the addresses of the premium and collateral vaults, in an array, in the respective order\n    @param index uint256 of the market index which to the vaults are associated to\n    @return vaults Address array of two vaults addresses, [0] being the premium vault, [1] being the collateral vault\n     */\n    function getVaults(uint256 index)\n        public\n        view\n        returns (address[2] memory vaults)\n    {\n        return marketIdToVaults[index];\n    }\n\n    /**\n    @notice Function to retrieve the epochId for a given marketId\n    @param marketId marketId\n    @return epochIds uint256 array of epochIds\n     */\n    function getEpochsByMarketId(uint256 marketId)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return marketIdToEpochs[marketId];\n    }\n\n    /**\n    @notice Function to retrieve the fee for a given epoch\n    @param epochId uint256 of the epoch\n    @return fee uint16 of the fee\n     */\n    function getEpochFee(uint256 epochId) public view returns (uint16 fee) {\n        return epochFee[epochId];\n    }\n\n    /**\n    @notice Function to compute the marketId from a token and a strike price\n    @param token Address of the token\n    @param strikePrice uint256 of the strike price\n    @return marketId uint256 of the marketId\n     */\n    function getMarketId(address token, uint256 strikePrice)\n        public\n        pure\n        returns (uint256 marketId)\n    {\n        return uint256(keccak256(abi.encodePacked(token, strikePrice)));\n    }\n\n    /**\n    @notice Function to compute the epochId from a marketId, epochBegin and epochEnd\n    @param marketId uint256 of the marketId\n    @param epochBegin uint40 of the epoch begin\n    @param epochEnd uint40 o"
    }
  ]
}