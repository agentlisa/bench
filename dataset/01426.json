{
  "Title": "M-15: LMPVault: DoS when `feeSink` balance hits `perWalletLimit`",
  "Content": "# Issue M-15: LMPVault: DoS when `feeSink` balance hits `perWalletLimit` \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/679 \n\n## Found by \nCh\\_301, n33k, warRoom, xiaoming90\n\nThe LMPVault token share has a per-wallet limit. LMPVault collects fees as share tokens to the `feeSink` address. `_collectFees` will revert if it mints shares that make the `feeSink` balance hit the `perWalletLimit`.\n\n## Vulnerability Detail\n\n`_collectFees` mints shares to `feeSink`.\n\n```solidity\nfunction _collectFees(uint256 idle, uint256 debt, uint256 totalSupply) internal {\n    address sink = feeSink;\n    ....\n    if (fees > 0 && sink != address(0)) {\n        // Calculated separate from other mints as normal share mint is round down\n        shares = _convertToShares(fees, Math.Rounding.Up);\n        _mint(sink, shares);\n        emit Deposit(address(this), sink, fees, shares);\n    }\n    ....\n}\n```\n\n`_mint` calls `_beforeTokenTransfer` internally to check if the target wallet exceeds `perWalletLimit`.\n\n```solidity\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override whenNotPaused {\n    ....\n    if (balanceOf(to) + amount > perWalletLimit) {\n        revert OverWalletLimit(to);\n    }\n}\n```\n\n`_collectFees` function will revert if `balanceOf(feeSink) + fee shares > perWalletLimit`. `updateDebtReporting`, `rebalance` and `flashRebalance` call `_collectFees` internally so they will be unfunctional.\n\n## Impact\n\n`updateDebtReporting`, `rebalance` and `flashRebalance` won't be working if `feeSink` balance hits `perWalletLimit`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L823\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L849-L851\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L797\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L703\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L727\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow `feeSink` to exceeds `perWalletLimit`.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\n// solhint-disable max-states-count\n\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { LMPDebt } from \"src/vault/libs/LMPDebt.sol\";\nimport { Pausable } from \"src/security/Pausable.sol\";\nimport { VaultTypes } from \"src/vault/VaultTypes.sol\";\nimport { NonReentrant } from \"src/utils/NonReentrant.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { LMPStrategy } from \"src/strategy/LMPStrategy.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { ILMPVault } from \"src/interfaces/vault/ILMPVault.sol\";\nimport { IStrategy } from \"src/interfaces/strategy/IStrategy.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { LMPDestinations } from \"src/vault/libs/LMPDestinations.sol\";\nimport { ERC20 } from \"openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport { IERC4626 } from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport { IMainRewarder } from \"src/interfaces/rewarders/IMainRewarder.sol\";\nimport { IDestinationVault } from \"src/interfaces/vault/IDestinationVault.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"openzeppelin-contracts/proxy/utils/Initializable.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { ISystemRegistry, IDestinationVaultRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ERC20Permit } from \"openzeppelin-contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { IERC3156FlashBorrower } from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport { IERC20Metadata as IERC20 } from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// Cross functional reentrancy was identified between updateDebtReporting and the\n// destinationInfo. Have nonReentrant and read-only nonReentrant modifier on them both\n// but slither was still complaining\n//slither-disable-start reentrancy-no-eth,reentrancy-benign\n\ncontract LMPVault is\n    SystemComponent,\n    Initializable,\n    ILMPVault,\n    IStrategy,\n    ERC20Permit,\n    SecurityBase,\n    Pausable,\n    NonReentrant\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Math for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IERC20;\n\n    /// @dev In memory struct only for managing vars in _withdraw\n    struct WithdrawInfo {\n        uint256 currentIdle;\n        uint256 assetsFromIdle;\n        uint256 totalAssetsToPull;\n        uint256 totalAssetsPulled;\n        uint256 idleIncrease;\n        uint256 debtDecrease;\n    }\n\n    /// @notice Max fee. 100% == 10000\n    uint256 public constant MAX_FEE_BPS = 10_000;\n\n    uint256 public constant NAV_CHANGE_ROUNDING_BUFFER = 100;\n\n    /// @notice Factory contract that created this vault\n    address public factory;\n\n    /// @notice Overarching baseAsset type\n    bytes32 public immutable vaultType = VaultTypes.LST;\n\n    /// @dev The asset that is deposited into the vault\n    IERC20 internal immutable _baseAsset;\n\n    /// @notice Decimals of the base asset. Used as the decimals for the vault itself\n    uint8 internal immutable _baseAssetDecimals;\n\n    /// @dev Full list of possible destinations that could be deployed to\n    EnumerableSet.AddressSet internal destinations;\n\n    /// @dev Destinations that queued for removal\n    EnumerableSet.AddressSet internal removalQueue;\n\n    /// @dev destinationVaultAddress -> Info .. Debt reporting snapshot info\n    mapping(address => LMPDebt.DestinationInfo) internal destinationInfo;\n\n    /// @dev whether or not the vault has been shutdown\n    bool internal _shutdown;\n\n    /// @notice The amount of baseAsset deposited into the contract pending deployment\n    uint256 public totalIdle = 0;\n\n    /// @notice The current (though cached) value of assets we've deployed\n    uint256 public totalDebt = 0;\n\n    /// @notice The destinations, in order, in which withdrawals will be attempted from\n    IDestinationVault[] public withdrawalQueue;\n\n    /// @notice Main rewarder for this contract\n    IMainRewarder public rewarder;\n\n    /// @notice Current performance fee taken on profit. 100% == 10000\n    uint256 public performanceFeeBps;\n\n    /// @notice Where claimed fees are sent\n    address public feeSink;\n\n    /// @notice The last nav/share height we took fees at\n    uint256 public navPerShareHighMark = MAX_FEE_BPS;\n\n    /// @notice The last timestamp we took fees at\n    uint256 public navPerShareHighMarkTimestamp;\n\n    /// @notice The max total supply of shares we'll allow to be minted\n    uint256 public totalSupplyLimit;\n\n    /// @notice The max shares a single wallet is allowed to hold\n    uint256 public perWalletLimit;\n\n    string private _desc;\n    string private _symbol;\n\n    error TooFewAssets(uint256 requested, uint256 actual);\n    error WithdrawShareCalcInvalid(uint256 currentShares, uint256 cachedShares);\n    error InvalidFee(uint256 newFee);\n    error RewarderAlreadySet();\n    error RebalanceDestinationsMatch(address destinationVault);\n    error InvalidDestination(address destination);\n    error NavChanged(uint256 oldNav, uint256 newNav);\n    error NavOpsInProgress();\n    error OverWalletLimit(address to);\n    error VaultShutdown();\n\n    event PerformanceFeeSet(uint256 newFee);\n    event FeeSinkSet(address newFeeSink);\n    event NewNavHighWatermark(uint256 navPerShare, uint256 timestamp);\n    event TotalSupplyLimitSet(uint256 limit);\n    event PerWalletLimitSet(uint256 limit);\n\n    modifier noNavChange() {\n        (uint256 oldNav, uint256 startingTotalSupply) = _snapStartNav();\n        _;\n        _ensureNoNavChange(oldNav, startingTotalSupply);\n    }\n\n    modifier noNavDecrease() {\n        (uint256 oldNav, uint256 startingTotalSupply) = _snapStartNav();\n        _;\n        _ensureNoNavDecrease(oldNav, startingTotalSupply);\n    }\n\n    modifier ensureNoNavOps() {\n        if (systemRegistry.systemSecurity().navOpsInProgress() > 0) {\n            revert NavOpsInProgress();\n        }\n        _;\n    }\n\n    modifier trackNavOps() {\n        systemRegistry.systemSecurity().enterNavOperation();\n        _;\n        systemRegistry.systemSecurity().exitNavOperation();\n    }\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _vaultAsset\n    )\n        SystemComponent(_systemRegistry)\n        ERC20(\n            string(abi.encodePacked(ERC20(_vaultAsset).name(), \" Pool Token\")),\n            string(abi.encodePacked(\"lmp\", ERC20(_vaultAsset).symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"lmp\", ERC20(_vaultAsset).symbol())))\n        SecurityBase(address(_systemRegistry.accessController()))\n        Pausable(_systemRegistry)\n    {\n        _baseAsset = IERC20(_vaultAsset);\n        _baseAssetDecimals = IERC20(_vaultAsset).decimals();\n\n        _symbol = ERC20(_vaultAsset).symbol();\n        _desc = ERC20(_vaultAsset).name();\n\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 supplyLimit,\n        uint256 walletLimit,\n        string memory symbolSuffix,\n        string memory descPrefix,\n        bytes memory\n    ) public virtual initializer {\n        Errors.verifyNotEmpty(symbolSuffix, \"symbolSuffix\");\n        Errors.verifyNotEmpty(descPrefix, \"descPrefix\");\n\n        // init withdrawal queue to empty (slither issue)\n        withdrawalQueue = new IDestinationVault[](0);\n\n        navPerShareHighMarkTimestamp = block.timestamp;\n\n        _setTotalSupplyLimit(supplyLimit);\n        _setPerWalletLimit(walletLimit);\n\n        factory = msg.sender;\n\n        _symbol = symbolSuffix;\n        _desc = descPrefix;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(_desc, \" Pool Token\"));\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(\"lmp\", _symbol));\n    }\n\n    /// @inheritdoc IERC20\n    function decimals() public view virtual override(ERC20, IERC20) returns (uint8) {\n        return _baseAssetDecimals;\n    }\n\n    /// @notice Set the global share limit\n    /// @dev Zero is allowed here and used as a way to stop deposits but allow withdrawals\n    /// @param newSupplyLimit new total amount of shares allowed to be minted\n    function setTotalSupplyLimit(uint256 newSupplyLimit) external onlyOwner {\n        _setTotalSupplyLimit(newSupplyLimit);\n    }\n\n    /// @notice Set the per-wallet share limit\n    /// @param newWalletLimit new total shares a wallet is allowed to hold\n    function setPerWalletLimit(uint256 newWalletLimit) external onlyOwner {\n        _setPerWalletLimit(newWalletLimit);\n    }\n\n    /// @notice Set the fee that will be taken when profit is realized\n    /// @dev Resets the high water to current value\n    /// @param fee Percent. 100% == 10000\n    function setPerformanceFeeBps(uint256 fee) external nonReentrant hasRole(Roles.LMP_FEE_SETTER_ROLE) {\n        if (fee >= MAX_FEE_BPS) {\n            revert InvalidFee(fee);\n        }\n\n        performanceFeeBps = fee;\n\n        // Set the high mark when we change the fee so we aren't able to go farther back in\n        // time than one debt reporting and claim fee's against past profits\n        uint256 supply = totalSupply();\n        if (supply > 0) {\n            navPerShareHighMark = (totalAssets() * MAX_FEE_BPS) / supply;\n        } else {\n            // The default high mark is 1:1. We don't want to be able to take\n            // fee's before the first debt reporting\n            // Before a rebalance, everything will be in idle and we don't want to take\n            // fee's on pure idle\n            navPerShareHighMark = MAX_FEE_BPS;\n        }\n\n        emit PerformanceFeeSet(fee);\n    }\n\n    /// @notice Set the address that will receive fees\n    /// @param newFeeSink Address that will receive fees\n    function setFeeSink(address newFeeSink) external onlyOwner {\n        emit FeeSinkSet(newFeeSink);\n\n        // Zero is valid. One way to disable taking fees\n        // slither-disable-next-line missing-zero-check\n        feeSink = newFeeSink;\n    }\n\n    /// @notice Set the rewarder contract used by the vault\n    /// @dev Must be set immediately on initialization/creation and only once\n    function setRewarder(address _rewarder) external {\n        if (msg.sender != factory) {\n            revert Errors.AccessDenied();\n        }\n\n        Errors.verifyNotZero(_rewarder, \"rewarder\");\n\n        if (address(rewarder) != address(0)) {\n            revert RewarderAlreadySet();\n        }\n\n        rewarder = IMainRewarder(_rewarder);\n\n        emit RewarderSet(_rewarder);\n    }\n\n    /// @dev See {IERC4626-asset}.\n    function asset() public view virtual override returns (address) {\n        return address(_baseAsset);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return totalIdle + totalDebt;\n    }\n\n    /// @dev See {IERC4626-convertToShares}.\n    function convertToShares(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /// @dev See {IERC4626-convertToAssets}.\n    function convertToAssets(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t\tDeposit\t\t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////\n\n    /// @dev See {IERC4626-maxDeposit}.\n    function maxDeposit(address wallet) public view virtual override returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(_maxMint(wallet));\n    }\n\n    /// @dev See {IERC4626-previewDeposit}.\n    function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) public virtual override nonReentrant noNavChange ensureNoNavOps returns (uint256 shares) {\n        Errors.verifyNotZero(assets, \"assets\");\n        if (assets > maxDeposit(receiver)) {\n            revert ERC4626DepositExceedsMax(assets, maxDeposit(receiver));\n        }\n\n        shares = previewDeposit(assets);\n\n        _transferAndMint(assets, shares, receiver);\n    }\n\n    /// @dev See {IERC4626-maxMint}.\n    function maxMint(address wallet) public view virtual override returns (uint256 maxShares) {\n        maxShares = _maxMint(wallet);\n    }\n\n    /// @dev See {IERC4626-maxWithdraw}.\n    function maxWithdraw(address owner) public view virtual returns (uint256 maxAssets) {\n        maxAssets = paused() ? 0 : previewRedeem(balanceOf(owner));\n    }\n\n    /// @dev See {IERC4626-maxRedeem}.\n    function maxRedeem(address owner) public view virtual returns (uint256 maxShares) {\n        maxShares = _maxRedeem(owner);\n    }\n\n    /// @dev See {IERC4626-previewMint}.\n    function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /// @dev See {IERC4626-previewWithdraw}.\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /// @dev See {IERC4626-previewRedeem}.\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /**\n     * @dev See {IERC4626-mint}.\n     *\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\n     * In this case, the shares will be minted without requiring any assets to be deposited.\n     */\n    function mint(\n        uint256 shares,\n        address receiver\n    ) public virtual override nonReentrant noNavChange ensureNoNavOps returns (uint256 assets) {\n        if (shares > maxMint(receiver)) {\n            revert ERC4626MintExceedsMax(shares, maxMint(receiver));\n        }\n\n        assets = previewMint(shares);\n\n        _transferAndMint(assets, shares, receiver);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t\tWithdraw\t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////\n\n    /// @dev See {IERC4626-withdraw}.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 shares) {\n        Errors.verifyNotZero(assets, \"assets\");\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        // query number of shares these assets match\n        shares = previewWithdraw(assets);\n\n        uint256 actualAssets = _withdraw(assets, shares, receiver, owner);\n\n        if (actualAssets < assets) {\n            revert TooFewAssets(assets, actualAssets);\n        }\n    }\n\n    /// @dev See {IERC4626-redeem}.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 assets) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n        uint256 possibleAssets = previewRedeem(shares);\n\n        assets = _withdraw(possibleAssets, shares, receiver, owner);\n    }\n\n    function _calcUserWithdrawSharesToBurn(\n        IDestinationVault destVault,\n        uint256 userShares,\n        uint256 maxAssetsToPull,\n        uint256 totalVaultShares\n    ) internal returns (uint256 sharesToBurn, uint256 totalDebtBurn) {\n        (sharesToBurn, totalDebtBurn) = LMPDebt._calcUserWithdrawSharesToBurn(\n            destinationInfo[address(destVault)], destVault, userShares, maxAssetsToPull, totalVaultShares\n        );\n    }\n\n    // slither-disable-next-line cyclomatic-complexity\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual returns (uint256) {\n        uint256 idle = totalIdle;\n        WithdrawInfo memory info = WithdrawInfo({\n            currentIdle: idle,\n            assetsFromIdle: assets >= idle ? idle : assets,\n            totalAssetsToPull: assets - (assets >= idle ? idle : assets),\n            totalAssetsPulled: 0,\n            idleIncrease: 0,\n            debtDecrease: 0\n        });\n\n        // If not enough funds in idle, then pull what we need from destinations\n        if (info.totalAssetsToPull > 0) {\n            uint256 totalVaultShares = totalSupply();\n\n            // Using pre-set withdrawalQueue for withdrawal order to help minimize user gas\n            uint256 withdrawalQueueLength = withdrawalQueue.length;\n            for (uint256 i = 0; i < withdrawalQueueLength; ++i) {\n                IDestinationVault destVault = IDestinationVault(withdrawalQueue[i]);\n                (uint256 sharesToBurn, uint256 totalDebtBurn) = _calcUserWithdrawSharesToBurn(\n                    destVault,\n                    shares,\n                    info.totalAssetsToPull - Math.max(info.debtDecrease, info.totalAssetsPulled),\n                    totalVaultShares\n                );\n                if (sharesToBurn == 0) {\n                    continue;\n                }\n\n                uint256 assetPreBal = _baseAsset.balanceOf(address(this));\n                uint256 assetPulled = destVault.withdrawBaseAsset(sharesToBurn, address(this));\n\n                // Destination Vault rewards will be transferred to us as part of burning out shares\n                // Back into what that amount is and make sure it gets into idle\n                info.idleIncrease += _baseAsset.balanceOf(address(this)) - assetPreBal - assetPulled;\n                info.totalAssetsPulled += assetPulled;\n                info.debtDecrease += totalDebtBurn;\n\n                // It's possible we'll get back more assets than we anticipate from a swap\n                // so if we do, throw it in idle and stop processing. You don't get more than we've calculated\n                if (info.totalAssetsPulled > info.totalAssetsToPull) {\n                    info.idleIncrease = info.totalAssetsPulled - info.totalAssetsToPull;\n                    info.totalAssetsPulled = info.totalAssetsToPull;\n                    break;\n                }\n\n                // No need to keep going if we have the amount we're looking for\n                // Any overage is accounted for above. Anything lower and we need to keep going\n                // slither-disable-next-line incorrect-equality\n                if (info.totalAssetsPulled == info.totalAssetsToPull) {\n                    break;\n                }\n            }\n        }\n\n        // At this point should have all the funds we need sitting in in the vault\n        uint256 returnedAssets = info.assetsFromIdle + info.totalAssetsPulled;\n\n        // subtract what's taken out of idle from totalIdle\n        // slither-disable-next-line events-maths\n        totalIdle = info.currentIdle + info.idleIncrease - info.assetsFromIdle;\n\n        if (info.debtDecrease > totalDebt) {\n            totalDebt = 0;\n        } else {\n            totalDebt -= info.debtDecrease;\n        }\n\n        // do the actual withdrawal (going off of total # requested)\n        uint256 allowed = allowance(owner, msg.sender);\n        if (msg.sender != owner && allowed != type(uint256).max) {\n            if (shares > allowed) revert AmountExceedsAllowance(shares, allowed);\n\n            unchecked {\n                _approve(owner, msg.sender, allowed - shares);\n            }\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, returnedAssets, shares);\n\n        _baseAsset.safeTransfer(receiver, returnedAssets);\n\n        return returnedAssets;\n    }\n\n    function claimRewards() public whenNotPaused {\n        rewarder.getReward(msg.sender, true);\n    }\n\n    /// @notice Transfer out non-tracked tokens\n    function recover(\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        address[] calldata _destinations\n    ) external virtual override hasRole(Roles.TOKEN_RECOVERY_ROLE) {\n        // Makes sure our params are valid\n        uint256 len = tokens.length;\n        if (len == 0) {\n            revert Errors.InvalidParams();\n        }\n        Errors.verifyArrayLengths(len, amounts.length, \"tokens+amounts\");\n        Errors.verifyArrayLengths(len, _destinations.length, \"tokens+_destinations\");\n\n        emit TokensRecovered(tokens, amounts, _destinations);\n\n        for (uint256 i = 0; i < len; ++i) {\n            (address tokenAddress, uint256 amount, address destination) = (tokens[i], amounts[i], _destinations[i]);\n\n            // Ensure this isn't an asset we care about\n            if (_isTrackedAsset(tokenAddress)) {\n                revert Errors.AssetNotAllowed(tokenAddress);\n            }\n\n            IERC20(tokenAddress).safeTransfer(destination, amount);\n        }\n    }\n\n    /// @inheritdoc ILMPVault\n    function shutdown() external onlyOwner {\n        _shutdown = true;\n\n        emit Shutdown();\n    }\n\n    /// @inheritdoc ILMPVault\n    function isShutdown() external view returns (bool) {\n        return _shutdown;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n\n        // slither-disable-next-line incorrect-equality\n        shares = (assets == 0 || supply == 0) ? assets : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /// @dev Internal conversion function (from shares to assets) with support for rounding direction.\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        assets = (supply == 0) ? shares : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    function _maxRedeem(address owner) internal view virtual returns (uint256 maxShares) {\n        maxShares = paused() ? 0 : balanceOf(owner);\n    }\n\n    function _transferAndMint(uint256 assets, uint256 shares, address receiver) internal virtual {\n        // From OZ documentation:\n        // ----------------------\n        // If _asset is ERC777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        _baseAsset.safeTransferFrom(msg.sender, address(this), assets);\n\n        totalIdle += assets;\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    ///@dev Checks if vault is \"healthy\" in the sense of having assets backing the circulating shares.\n    function _isVaultCollateralized() internal view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n\n    function updateDebtReporting(address[] calldata _destinations) external nonReentrant trackNavOps {\n        _updateDebtReporting(_destinations);\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t  Destinations     \t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////////\n\n    function getDestinations() public view override returns (address[] memory) {\n        return destinations.values();\n    }\n\n    function isDestinationRegistered(address destination) external view returns (bool) {\n        return destinations.contains(destination);\n    }\n\n    function addDestinations(address[] calldata _destinations) public hasRole(Roles.DESTINATION_VAULTS_UPDATER) {\n        LMPDestinations.addDestinations(removalQueue, destinations, _destinations, systemRegistry);\n    }\n\n    function removeDestinations(address[] calldata _destinations) public hasRole(Roles.DESTINATION_VAULTS_UPDATER) {\n        LMPDestinations.removeDestinations(removalQueue, destinations, _destinations);\n    }\n\n    function getRemovalQueue() public view override returns (address[] memory) {\n        return removalQueue.values();\n    }\n\n    function removeFromRemovalQueue(address vaultToRemove) public override hasRole(Roles.REBALANCER_ROLE) {\n        LMPDestinations.removeFromRemovalQueue(removalQueue, vaultToRemove);\n    }\n\n    /// @dev Order is set as list of interfaces to minimize gas for our users\n    function setWithdrawalQueue(address[] calldata _destinations)\n        public\n        override\n        hasRole(Roles.SET_WITHDRAWAL_QUEUE_ROLE)\n    {\n        LMPDestinations.setWithdrawalQueue(withdrawalQueue, _destinations, systemRegistry);\n    }\n\n    /// @notice Get the current withdrawal queue\n    function getWithdrawalQueue() public view override returns (IDestinationVault[] memory withdrawalDestinations) {\n        return withdrawalQueue;\n    }\n\n    /// @notice Get the current snapshot debt info for a destination\n    function getDestinationInfo(address destVault)\n        external\n        view\n        nonReentrantReadOnly\n        returns (LMPDebt.DestinationInfo memory)\n    {\n        return destinationInfo[destVault];\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //\t\t\t\t\t\t\tStrategy Related   \t\t\t\t\t\t\t//\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IStrategy\n    function rebalance(RebalanceParams memory params) public nonReentrant hasRole(Roles.SOLVER_ROLE) trackNavOps {\n        (uint256 idle, uint256 debt) = LMPDebt.rebalance(\n            destinationInfo[params.destinationOut],\n            destinationInfo[params.destinationIn],\n            params,\n            _baseAsset,\n            _shutdown,\n            totalIdle,\n            totalDebt\n        );\n        totalIdle = idle;\n        totalDebt = debt;\n        _collectFees(idle, debt, totalSupply());\n    }\n\n    /// @inheritdoc IStrategy\n    function flashRebalance(\n        IERC3156FlashBorrower receiver,\n        RebalanceParams memory rebalanceParams,\n        bytes calldata data\n    ) public nonReentrant hasRole(Roles.SOLVER_ROLE) trackNavOps {\n        (uint256 idle, uint256 debt) = LMPDebt.flashRebalance(\n            destinationInfo[rebalanceParams.destinationOut],\n            destinationInfo[rebalanceParams.destinationIn],\n            receiver,\n            rebalanceParams,\n            LMPDebt.FlashRebalanceParams({\n                totalIdle: totalIdle,\n                totalDebt: totalDebt,\n                baseAsset: _baseAsset,\n                shutdown: _shutdown\n            }),\n            data\n        );\n        totalIdle = idle;\n        totalDebt = debt;\n        _collectFees(idle, debt, totalSupply());\n    }\n\n    /// @inheritdoc IStrategy\n    function verifyRebalance(\n        address destinationIn,\n        address tokenIn,\n        uint256 amountIn,\n        address destinationOut,\n        address tokenOut,\n        uint256 amountOut\n    ) public view virtual returns (bool success, string memory message) {\n        (success, message) = LMPStrategy.verifyRebalance(\n            IStrategy.RebalanceParams({\n                destinationIn: destinationIn,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                destinationOut: destinationOut,\n                tokenOut: tokenOut,\n                amountOut: amountOut\n            })\n        );\n    }\n\n    /// @notice Process the destinations calculating current value and snapshotting for safe deposit/mint'ing\n    function _updateDebtReporting(address[] memory _destinations) private {\n        uint256 nDest = _destinations.length;\n\n        uint256 idleIncrease = 0;\n        uint256 prevNTotalDebt = 0;\n        uint256 afterNTotalDebt = 0;\n\n        for (uint256 i = 0; i < nDest; ++i) {\n            IDestinationVault destVault = IDestinationVault(_destinations[i]);\n\n            if (!destinations.contains(address(destVault))) {\n                revert InvalidDestination(address(destVault));\n            }\n\n            // Get the reward value we've earned. DV rewards are always in terms of base asset\n            // We track the gas used purely for off-chain stats purposes\n            // Main rewarder on DV's store the earned and liquidated rewards\n            // Extra rewarders are disabled at the DV level\n            uint256 claimGasUsed = gasleft();\n            uint256 beforeBaseAsset = _baseAsset.balanceOf(address(this));\n            // We don't want any extras, those would likely not be baseAsset\n            IMainRewarder(destVault.rewarder()).getReward(address(this), false);\n            uint256 claimedRewardValue = _baseAsset.balanceOf(address(this)) - beforeBaseAsset;\n            claimGasUsed -= gasleft();\n            idleIncrease += claimedRewardValue;\n\n            // Recalculate the debt info figuring out the change in\n            // total debt value we can roll up later\n            uint256 currentShareBalance = destVault.balanceOf(address(this));\n            (uint256 totalDebtDecrease, uint256 totalDebtIncrease) = LMPDebt.recalculateDestInfo(\n                destinationInfo[address(destVault)], destVault, currentShareBalance, currentShareBalance, false\n            );\n            prevNTotalDebt += totalDebtDecrease;\n            afterNTotalDebt += totalDebtIncrease;\n\n            emit DestinationDebtReporting(address(destVault), totalDebtIncrease, claimedRewardValue, claimGasUsed);\n        }\n\n        // Persist our change in idle and debt\n        uint256 idle = totalIdle + idleIncrease;\n        uint256 debt = totalDebt - prevNTotalDebt + afterNTotalDebt;\n\n        totalIdle = idle;\n        totalDebt = debt;\n\n        _collectFees(idle, debt, totalSupply());\n    }\n\n    function _collectFees(uint256 idle, uint256 debt, uint256 totalSupply) internal {\n        address sink = feeSink;\n        uint256 fees = 0;\n        uint256 shares = 0;\n        uint256 profit = 0;\n\n        // If there's no supply then there should be no assets and so nothing\n        // to actually take fees on\n        if (totalSupply == 0) {\n            return;\n        }\n\n        uint256 currentNavPerShare = ((idle + debt) * MAX_FEE_BPS) / totalSupply;\n        uint256 effectiveNavPerShareHighMark = navPerShareHighMark;\n\n        if (currentNavPerShare > effectiveNavPerShareHighMark) {\n            // Even if we aren't going to take the fee (haven't set a sink)\n            // We still want to calculate so we can emit for off-chain analysis\n            profit = (currentNavPerShare - effectiveNavPerShareHighMark) * totalSupply;\n            fees = profit.mulDiv(performanceFeeBps, (MAX_FEE_BPS ** 2), Math.Rounding.Up);\n            if (fees > 0 && sink != address(0)) {\n                // Calculated separate from other mints as normal share mint is round down\n                shares = _convertToShares(fees, Math.Rounding.Up);\n                _mint(sink, shares);\n                emit Deposit(address(this), sink, fees, shares);\n            }\n            // Set our new high water mark, the last nav/share height we took fees\n            navPerShareHighMark = currentNavPerShare;\n            navPerShareHighMarkTimestamp = block.timestamp;\n            emit NewNavHighWatermark(currentNavPerShare, block.timestamp);\n        }\n        emit FeeCollected(fees, sink, shares, profit, idle, debt);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override whenNotPaused {\n        // Nothing to do really do here\n        if (from == to) {\n            return;\n        }\n\n        // If this isn't a mint of new tokens, then they are being transferred\n        // from someone who is \"staked\" in the rewarder. Make sure the"
    }
  ]
}