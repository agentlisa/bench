{
  "Title": "The yETH contract has one step for management role transferring and allows zero address as management",
  "Content": "##### Description\n\nThe function does not use a two-step process for management role transferring.\n- https://github.com/yearn/yETH-bootstrap/blob/2dd219d3af49952275934638e8c9d50d0fef0d8f/contracts/Token.vy#L125-L131\n\nBut other contracts use a two-step process with the pending_management role.\n- https://github.com/yearn/yETH-bootstrap/blob/2dd219d3af49952275934638e8c9d50d0fef0d8f/contracts/POL.vy#L125-L147\n\n##### Recommendation\n\nWe recommend using the same process of management role transferring as on other contracts (with the pending_management).\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Token.vy",
      "content": "# @version 0.3.7\n\"\"\"\n@title yETH token\n@author 0xkorin, Yearn Finance\n@license Copyright (c) Yearn Finance, 2023 - all rights reserved\n\"\"\"\n\nfrom vyper.interfaces import ERC20\nimplements: ERC20\n\ntotalSupply: public(uint256)\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\n\nname: public(constant(String[11])) = \"Yearn Ether\"\nsymbol: public(constant(String[4])) = \"yETH\"\ndecimals: public(constant(uint8)) = 18\n\nminters: public(HashMap[address, bool])\nmanagement: public(address)\n\nevent Transfer:\n    sender: indexed(address)\n    receiver: indexed(address)\n    value: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    value: uint256\n\nevent SetManagement:\n    account: indexed(address)\n\nevent SetMinter:\n    account: indexed(address)\n    minter: bool\n\n@external\ndef __init__():\n    self.management = msg.sender\n    log Transfer(empty(address), msg.sender, 0)\n\n@external\ndef transfer(_to: address, _value: uint256) -> bool:\n    \"\"\"\n    @notice Transfers `_value` tokens from the caller's address to `_to`\n    @param _to The address shares are being transferred to. Must not be this contract's\n        address, must not be 0x0\n    @param _value The quantity of tokens to transfer\n    @return True\n    \"\"\"\n    assert _to != empty(address) and _to != self\n    self.balanceOf[msg.sender] -= _value\n    self.balanceOf[_to] += _value\n    log Transfer(msg.sender, _to, _value)\n    return True\n\n@external\ndef transferFrom(_from: address, _to: address, _value: uint256) -> bool:\n    \"\"\"\n    @notice Transfers `_value` tokens from `_from` to `_to`.\n        Transfering tokens will decrement the caller's `allowance` by `_value`\n    @param _from The address tokens are being transferred from\n    @param _to The address tokens are being transferred to. Must not be this contract's\n        address, must not be 0x0\n    @param _value The quantity of tokens to transfer\n    @return True\n    \"\"\"\n    assert _to != empty(address) and _to != self\n    self.allowance[_from][msg.sender] -= _value\n    self.balanceOf[_from] -= _value\n    self.balanceOf[_to] += _value\n    log Transfer(_from, _to, _value)\n    return True\n\n@external\ndef approve(_spender: address, _value: uint256) -> bool:\n    \"\"\"\n    @notice Approve the passed address to spend the specified amount of tokens on behalf of\n        `msg.sender`. Beware that changing an allowance with this method brings the risk\n        that someone may use both the old and the new allowance by unfortunate transaction\n        ordering. See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param _spender The address which will spend the funds\n    @param _value The amount of tokens to be spent\n    @return True\n    \"\"\"\n    self.allowance[msg.sender][_spender] = _value\n    log Approval(msg.sender, _spender, _value)\n    return True\n\n@external\ndef increaseAllowance(_spender: address, _value: uint256) -> bool:\n    \"\"\"\n    @notice Increase the allowance of the passed address to spend the total amount of tokens\n        on behalf of `msg.sender`. This method mitigates the risk that someone may use both\n        the old and the new allowance by unfortunate transaction ordering.\n        See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param _spender The address which will spend the funds\n    @param _value The amount of tokens to increase the allowance by\n    @return True\n    \"\"\"\n    allowance: uint256 = self.allowance[msg.sender][_spender] + _value\n    self.allowance[msg.sender][_spender] = allowance\n    log Approval(msg.sender, _spender, allowance)\n    return True\n\n@external\ndef decreaseAllowance(_spender: address, _value: uint256) -> bool:\n    \"\"\"\n    @notice Decrease the allowance of the passed address to spend the total amount of tokens\n        on behalf of `msg.sender`. This method mitigates the risk that someone may use both\n        the old and the new allowance by unfortunate transaction ordering.\n        See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param _spender The address which will spend the funds\n    @param _value The amount of tokens to decrease the allowance by\n    @return True\n    \"\"\"\n    allowance: uint256 = self.allowance[msg.sender][_spender] - _value\n    self.allowance[msg.sender][_spender] = allowance\n    log Approval(msg.sender, _spender, allowance)\n    return True\n\n@external\ndef set_management(_management: address):\n    \"\"\"\n    @notice Set new management address\n    \"\"\"\n    assert msg.sender == self.management\n    self.management = _management\n    log SetManagement(_management)\n\n@external\ndef set_minter(_account: address, _minter: bool = True):\n    \"\"\"\n    @notice Grant or revoke mint and burn powers to an account\n    @param _account The account to change mint/burn powers of\n    @param _minter Flag whether or not to allow minting/burning\n    \"\"\"\n    assert msg.sender == self.management\n    self.minters[_account] = _minter\n    log SetMinter(_account, _minter)\n\n@external\ndef mint(_account: address, _value: uint256):\n    \"\"\"\n    @notice Mint `_value` tokens to `_account`\n    @param _account The account to mint tokens to\n    @param _value Amount of tokens to mint\n    \"\"\"\n    assert self.minters[msg.sender]\n    self.totalSupply += _value\n    self.balanceOf[_account] += _value\n    log Transfer(empty(address), _account, _value)\n\n@external\ndef burn(_account: address, _value: uint256):\n    \"\"\"\n    @notice Burn `_value` tokens from `_account`\n    @param _account The account to burn tokens from\n    @param _value Amount of tokens to burn\n    \"\"\"\n    assert self.minters[msg.sender]\n    self.totalSupply -= _value\n    self.balanceOf[_account] -= _value\n    log Transfer(_account, empty(address), _value)"
    },
    {
      "filename": "contracts/POL.vy",
      "content": "# @version 0.3.7\n\"\"\"\n@title Protocol Owned Liquidity\n@author 0xkorin, Yearn Finance\n@license Copyright (c) Yearn Finance, 2023 - all rights reserved\n@notice\n    Contract to manage the protocol owned liquidity.\n    Actual operations are implemented in individual modules, this contract only serves to \n    manage its permissions. Modules can be approved to mint or burn yETH, receive ETH and receive tokens.\n    yETH can only be minted up to the debt ceiling, which is determined by the amount of ETH deposited\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface Token:\n    def mint(_account: address, _amount: uint256): nonpayable\n    def burn(_account: address, _amount: uint256): nonpayable\n\ntoken: public(immutable(address))\nmanagement: public(address)\npending_management: public(address)\navailable: public(uint256)\ndebt: public(uint256)\nnative_allowance: public(HashMap[address, uint256])\nmint_allowance: public(HashMap[address, uint256])\nburn_allowance: public(HashMap[address, uint256])\nkilled: public(bool)\n\nNATIVE: constant(address) = 0x0000000000000000000000000000000000000000\nMINT: constant(address)   = 0x0000000000000000000000000000000000000001\nBURN: constant(address)   = 0x0000000000000000000000000000000000000002\n\nevent Mint:\n    account: indexed(address)\n    amount: uint256\n\nevent Burn:\n    account: indexed(address)\n    amount: uint256\n\nevent Approve:\n    token: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\nevent PendingManagement:\n    management: indexed(address)\n\nevent SetManagement:\n    management: indexed(address)\n\nevent Kill: pass\n\n@external\ndef __init__(_token: address):\n    \"\"\"\n    @notice Constructor\n    @param _token yETH token address\n    \"\"\"\n    token = _token\n    self.management = msg.sender\n\n@external\n@payable\ndef __default__():\n    \"\"\"\n    @notice Receive ETH and raise debt ceiling\n    \"\"\"\n    self.available += msg.value\n    pass\n\n@external\n@payable\ndef receive_native():\n    \"\"\"\n    @notice Receive ETH without raising the debt ceiling\n    @dev Modules should use this when sending back previously received ETH\n    \"\"\"\n    pass\n\n@external\ndef send_native(_receiver: address, _amount: uint256):\n    \"\"\"\n    @notice Send ETH\n    @param _receiver Account to send the ETH to\n    @param _amount Amount of ETH to send\n    @dev Requires prior permission by management\n    \"\"\"\n    assert _amount > 0\n    self.native_allowance[msg.sender] -= _amount\n    raw_call(_receiver, b\"\", value=_amount)\n\n@external\ndef mint(_amount: uint256):\n    \"\"\"\n    @notice Mint yETH\n    @param _amount Amount of ETH to mint\n    @dev Cannot mint more than the debt ceiling\n    @dev Requires prior permission by management\n    \"\"\"\n    assert _amount > 0\n    assert not self.killed\n    self.mint_allowance[msg.sender] -= _amount\n    debt: uint256 = self.debt + _amount\n    assert debt <= self.available\n    self.debt = debt\n    Token(token).mint(self, _amount)\n    log Mint(msg.sender, _amount)\n\n@external\ndef burn(_amount: uint256):\n    \"\"\"\n    @notice Burn yETH\n    @param _amount Amount of yETH to burn\n    @dev Requires prior permission by management\n    \"\"\"\n    assert _amount > 0\n    self.burn_allowance[msg.sender] -= _amount\n    self.debt -= _amount\n    Token(token).burn(self, _amount)\n    log Burn(msg.sender, _amount)\n\n# MANAGEMENT FUNCTIONS\n\n@external\ndef set_management(_management: address):\n    \"\"\"\n    @notice \n        Set the pending management address.\n        Needs to be accepted by that account separately to transfer management over\n    @param _management New pending management address\n    \"\"\"\n    assert msg.sender == self.management\n    self.pending_management = _management\n    log PendingManagement(_management)\n\n@external\ndef accept_management():\n    \"\"\"\n    @notice \n        Accept management role.\n        Can only be called by account previously marked as pending management by current management\n    \"\"\"\n    assert msg.sender == self.pending_management\n    self.pending_management = empty(address)\n    self.management = msg.sender\n    log SetManagement(msg.sender)\n\n@external\ndef approve(_token: address, _spender: address, _amount: uint256):\n    \"\"\"\n    @notice Approve `_spender` to spend `_amount` of `_token` from the POL\n    @param _token\n        Token to give approval for.\n        Use special designated values to set minting/burning/native allowances\n    @param _spender Account to give approvel to\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    self._approve(_token, _spender, _amount)\n\n@external\ndef increase_allowance(_token: address, _spender: address, _amount: uint256):\n    \"\"\"\n    @notice Increase `_spender`s allowance to spend `_token` by `_amount`\n    @param _token \n        Token to give increase in allowance for.\n        Use special designated values to set minting/burning/native allowances\n    @param _spender Account to increase in allowance of\n    @param _amount Amount to increase allowance by\n    \"\"\"\n    allowance: uint256 = 0\n    if _token == NATIVE:\n        allowance = self.native_allowance[_spender]\n    elif _token == MINT:\n        allowance = self.mint_allowance[_spender]\n    elif _token == BURN:\n        allowance = self.burn_allowance[_spender]\n    else:\n        allowance = ERC20(_token).allowance(self, _spender)\n\n    self._approve(_token, _spender, allowance + _amount)\n\n@external\ndef decrease_allowance(_token: address, _spender: address, _amount: uint256):\n    \"\"\"\n    @notice Decrease `_spender`s allowance to spend `_token` by `_amount`\n    @param _token\n        Token to decrease allowance for.\n        Use special designated values to set minting/burning/native allowances\n    @param _spender Account to decrease allowance of\n    @param _amount Amount to decrease allowance by\n    @dev If decrease is larger than current allowance, it will be set to zero\n    \"\"\"\n    allowance: uint256 = 0\n    if _token == NATIVE:\n        allowance = self.native_allowance[_spender]\n    elif _token == MINT:\n        allowance = self.mint_allowance[_spender]\n    elif _token == BURN:\n        allowance = self.burn_allowance[_spender]\n    else:\n        allowance = ERC20(_token).allowance(self, _spender)\n\n    if _amount > allowance:\n        allowance = 0\n    else:\n        allowance -= _amount\n    self._approve(_token, _spender, allowance)\n\n@internal\ndef _approve(_token: address, _spender: address, _amount: uint256):\n    \"\"\"\n    @notice Approve `_spender` to spend `_amount` of `_token` from the POL\n    @param _token\n        Token to give approval for.\n        Use special designated values to set minting/burning/native allowances\n    @param _spender Account to give approvel to\n    @param _amount Amount of tokens to approve\n    \"\"\"\n    assert msg.sender == self.management\n    if _token == NATIVE:\n        self.native_allowance[_spender] = _amount\n    elif _token == MINT:\n        self.mint_allowance[_spender] = _amount\n    elif _token == BURN:\n        self.burn_allowance[_spender] = _amount\n    else:\n        ERC20(_token).approve(_spender, _amount)\n    log Approve(_token, _spender, _amount)\n\n@external\ndef kill():\n    \"\"\"\n    @notice Kill the POL, permanently disabling yETH minting\n    \"\"\"\n    assert msg.sender == self.management\n    self.killed = True\n    log Kill()"
    }
  ]
}