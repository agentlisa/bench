{
  "Title": "[M-20] Nonce Behavior Discrepancy Between zkSync Era and EIP-161",
  "Content": "\nThe discrepancy in deployment nonce behavior between zkSync Era and EVM can cause problems for contract factories and developers. zkSync Era starts the deployment nonce at zero, unlike the EVM, where it starts at one. This difference may lead to incorrect predictions of child contract addresses.\n\n### Proof of Concept\n\nAs per EIP-161, it's specified that account creation transactions and the CREATE operation should increase the nonce beyond its initial value by **one**.\n\n<https://github.com/ethereum/EIPs/blob/master/EIPS/eip-161.md#specification>\n\n> Account creation transactions and the CREATE operation SHALL, prior to the execution of the initialisation code, increment the nonce over and above its normal starting value by one (for normal networks, this will be simply 1, however test-nets with non-zero default starting nonces will be different).\n\nIn other words, when an EOA (for example with nonce 100) deploys a contract (named as \"contract X\"), the nonces will be (please note that the nonce of the newly-deployed contract X is also incremented by one):\n\n    nonce(EOA): 100 -> 101 \n    nonce(contract X): 0 -> 1\n\nAnd when in another transaction, this contract X deploys another contract (named as \"contract Y\"), the nonces will be (again please note that the nonce of the newly-deployed contract Y is also incremented by one):\n\n    nonce(EOA): 101 -> 102 \n    nonce(contract X): 1 -> 2\n    nonce(contract Y): 0 -> 1\n\nHowever, during the zkSync Era, there is a divergence from the Ethereum standard. In this context, the deployment nonce for a newly created contract initiates at zero. This deviation from the EVM standard can impact factories that anticipate the addresses of child contracts and make decisions based on these assumptions. Such factories might mistakenly assume that their nonce starts at 1, mirroring the EVM, leading to discrepancies between anticipated and actual addresses of the deployed child contracts.\n\n### Recommended Mitigation Steps\n\nIt is advisable to increment the deployment nonce of a contract by one before invoking its constructor. Moreover, this contrast should be documented to provide clarity for developers.\n\n    function _constructContract(\n            address _sender,\n            address _newAddress,\n            bytes32 _bytecodeHash,\n            bytes calldata _input,\n            bool _isSystem,\n            bool _callConstructor\n        ) internal {\n            NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(_newAddress);\n            //...\n        }\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/ContractDeployer.sol#L322>\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) acknowledged and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1803654621):**\n > Medium/Low. The impact can be high (depending on the context), and probality is medium to high (any factory can be affected).\n> I am thinking that if a factory creates a child, and child also creates second contract, and factory already transfers ETH to the second contract address (assuming that nonce of child is one, leading to predict the second contract address wrongly). Fund is lost. \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1812462720):**\n > We have an historical record of awarding non-evm equivalence that can cause damage as med, so I'm inclined to maintain the severity. Will double check.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1826878015):**\n > The Warden has shown a discrepancy in the CREATE opcode for Contracts deployed on the zkEVM. While impact should be low in many scenarios, this highlights a discrepancy between zkEVM and EVM, which is notable, for this reason Medium Severity seems most appropriate.\n\n**[anon (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1836074188):**\n > The identified issue could potentially affect numerous widely-used projects and libraries. As an illustration:\n> \n> The create3 library facilitates EVM contract creation, resembling `CREATE2` but differing in that it excludes the contract `initCode` from the address derivation formula. The process involves employing the `CREATE2` method to deploy a new proxy contract, which subsequently deploys the child contract using `CREATE`. This keyless deployment approach removes reliance on the account owner who deployed the factory contract.\n> \n> Examining the `CREATE3` library in [solmate](https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol#L9) or [solady](https://github.com/Vectorized/solady/blob/main/src/utils/CREATE3.sol#L8), the child contract's address is computed based on the [address](https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol#L77-L85) of the proxy contract and its nonce. Notably, the [nonce](https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol#L83) of the proxy contract is hardcoded as `hex\"01\"`. This choice aligns with EIP-161, specifying that account creation transactions and the `CREATE` operation should increment the nonce beyond its initial value by one. However, in the zkSync Era, the nonce does not increase by one, so unexpectedly this mechanism does not work on zkSync Era as on EVM.\n> \n> Given that this library or a similar mechanism is widely used (as seen in [AxelarNetwork](https://github.com/axelarnetwork/axelar-gmp-sdk-solidity/blob/main/contracts/deploy/Create3.sol#L15) and [MeanFinance](https://github.com/Mean-Finance/deterministic-factory/blob/main/solidity/contracts/DeterministicFactory.sol#L8)), any deviation from the expected behavior could impact numerous contracts dependent on the correct address of the child contract. \n> \n> Consequently, I assert that the significance of this bug should be classified as high.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1845202289):**\n > After reviewing the issue and consulting with another Judge.\n> \n> While the issue is notable, I believe that the finding is limited in its impact in the sense that it shows a discrepancy against the EVM. Integrators would be subject to an incorrect functionality which would be found rationally through the first usage or an integration test.\n> \n> In the case in which said factory was in scope, then a High Severity would have been appropriate. But in lack of it, the finding impacts the compatibility of zkSync with the EVM, meaning Medium Severity is most appropriate.\n\n**[vladbochok (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1855335245):**\n > 1. Nonce is not visible inside the VM execution, the only resulted address will be derived from the nonce `1`, not `0`.\n> 2. The rule of address derivation on Era is different. Not only by a specific different formula but also by using two separate nonces - deployment nonce and min nonce. One is used for deployment and another for the contract address derivation. That is different from Ethereum itself, and has much bigger impact on the address prediction than just nonce that nonce value been used in the derivation. \n> \n> I do think that the maximum impact is low, due to the reason that only infra is affected, I would like to see the real contract deployed on Ethereum that would affected rather than very hypothetical assumptions about developers and users. The likelihood is also very low. All in all, I don't think this issue has proven to have some severity. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "EIPS/eip-161.md",
      "content": "---\neip: 161\ntitle: State trie clearing (invariant-preserving alternative)\nauthor: Gavin Wood (@gavofyork)\ntype: Standards Track\ncategory: Core\nstatus: Final\ncreated: 2016-10-24\n---\n\n### Hard fork\n[Spurious Dragon](./eip-607.md)\n\n### Parameters\n- `FORK_BLKNUM`: 2,675,000\n- `CHAIN_ID`: 1 (Mainnet)\n\n### Specification\n\na. Account creation transactions and the `CREATE` operation SHALL, prior to the execution of the initialisation code, **increment** the **nonce** over and above its normal starting value by **one** (for normal networks, this will be simply 1, however test-nets with non-zero default starting nonces will be different).\n\nb. Whereas `CALL` and `SUICIDE` would charge 25,000 gas when the destination is non-existent, now the charge SHALL **only** be levied if the operation transfers **more than zero value** and the destination account is _dead_.\n\nc. No account may _change state_ from non-existent to existent-but-_empty_. If an operation would do this, the account SHALL instead remain non-existent.\n\nd. _At the end of the transaction_, any account _touched_ by the execution of that transaction which is now _empty_ SHALL instead become non-existent (i.e. **deleted**).\n\nWhere:\n\nAn account is considered to be _touched_ when it is involved in any potentially _state-changing_ operation. This includes, but is not limited to, being the recipient of a **transfer of zero value**.\n\nAn account is considered _empty_ when it has **no code** and **zero nonce** and **zero balance**.\n\nAn account is considered _dead_ when either it is non-existent or it is _empty_.\n\n_At the end of the transaction_ is immediately following the execution of the suicide list, prior to the determination of the state trie root for receipt population.\n\nAn account _changes state_ when:\n- it is the target or refund of a `SUICIDE` operation for **zero or more** value;\n- it is the source or destination of a `CALL` operation or message-call transaction transferring **zero or more** value;\n- it is the source or creation of a `CREATE` operation or contract-creation transaction endowing **zero or more** value;\n- as the block author (\"miner\") it is the recipient of block-rewards or transaction-fees of **zero or more** value.\n\n#### Notes\n\nIn the present Ethereum protocol, it should be noted that very few state changes can ultimately result in accounts that are empty following the execution of the transaction. In fact there are only four contexts that current implementations need track:\n- an empty account has zero value transferred to it through `CALL`;\n- an empty account has zero value transferred to it through `SUICIDE`;\n- an empty account has zero value transferred to it through a message-call transaction;\n- an empty account has zero value transferred to it through a zero-gas-price fees transfer.\n\n### Rationale\n\nSame as #158 except that several edge cases are avoided since we do not break invariants:\n- ~~that an account can go from having code and storage to not having code or storage mid-way through the execution of a transaction;~~ [corrected]\n- that a newly created account cannot be deleted prior to being deployed.\n\n`CREATE` avoids zero in the nonce to avoid any suggestion of the oddity of `CREATE`d accounts being reaped half-way through their creation.\n\n### Addendum (2017-08-15)\n\nOn 2016-11-24, a consensus bug occurred due to two implementations having different behavior in the case of state reverts.[3] The specification was amended to clarify that empty account deletions are reverted when the state is reverted.\n\n### References\n\n1. EIP-158 issue and discussion: https://github.com/ethereum/EIPs/issues/158\n2. EIP-161 issue and discussion: https://github.com/ethereum/EIPs/issues/161\n3. https://blog.ethereum.org/2016/11/25/security-alert-11242016-consensus-bug-geth-v1-4-19-v1-5-2/\n> Details: Geth was failing to revert empty account deletions when the transaction causing the deletions of empty accounts ended with an out-of-gas exception. An additional issue was found in Parity, where the Parity client incorrectly failed to revert empty account deletions in a more limited set of contexts involving out-of-gas calls to precompiled contracts; the new Geth behavior matches Parityâ€™s, and empty accounts will cease to be a source of concern in general in about one week once the state clearing process finishes."
    },
    {
      "filename": "code/system-contracts/contracts/ContractDeployer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ImmutableData} from \"./interfaces/IImmutableSimulator.sol\";\nimport {IContractDeployer} from \"./interfaces/IContractDeployer.sol\";\nimport {CREATE2_PREFIX, CREATE_PREFIX, NONCE_HOLDER_SYSTEM_CONTRACT, ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT, FORCE_DEPLOYER, MAX_SYSTEM_CONTRACT_ADDRESS, KNOWN_CODE_STORAGE_CONTRACT, ETH_TOKEN_SYSTEM_CONTRACT, IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT, COMPLEX_UPGRADER_CONTRACT} from \"./Constants.sol\";\n\nimport {Utils} from \"./libraries/Utils.sol\";\nimport {EfficientCall} from \"./libraries/EfficientCall.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice System smart contract that is responsible for deploying other smart contracts on zkSync.\n * @dev The contract is responsible for generating the address of the deployed smart contract,\n * incrementing the deployment nonce and making sure that the constructor is never called twice in a contract.\n * Note, contracts with bytecode that have already been published to L1 once\n * do not need to be published anymore.\n */\ncontract ContractDeployer is IContractDeployer, ISystemContract {\n    /// @notice Information about an account contract.\n    /// @dev For EOA and simple contracts (i.e. not accounts) this value is 0.\n    mapping(address => AccountInfo) internal accountInfo;\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Callable only by self\");\n        _;\n    }\n\n    /// @notice Returns information about a certain account.\n    function getAccountInfo(address _address) external view returns (AccountInfo memory info) {\n        return accountInfo[_address];\n    }\n\n    /// @notice Returns the account abstraction version if `_address` is a deployed contract.\n    /// Returns the latest supported account abstraction version if `_address` is an EOA.\n    function extendedAccountVersion(address _address) public view returns (AccountAbstractionVersion) {\n        AccountInfo memory info = accountInfo[_address];\n        if (info.supportedAAVersion != AccountAbstractionVersion.None) {\n            return info.supportedAAVersion;\n        }\n\n        // It is an EOA, it is still an account.\n        if (ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getRawCodeHash(_address) == 0) {\n            return AccountAbstractionVersion.Version1;\n        }\n\n        return AccountAbstractionVersion.None;\n    }\n\n    /// @notice Stores the new account information\n    function _storeAccountInfo(address _address, AccountInfo memory _newInfo) internal {\n        accountInfo[_address] = _newInfo;\n    }\n\n    /// @notice Update the used version of the account.\n    /// @param _version The new version of the AA protocol to use.\n    /// @dev Note that it allows changes from account to non-account and vice versa.\n    function updateAccountVersion(AccountAbstractionVersion _version) external onlySystemCall {\n        accountInfo[msg.sender].supportedAAVersion = _version;\n\n        emit AccountVersionUpdated(msg.sender, _version);\n    }\n\n    /// @notice Updates the nonce ordering of the account. Currently,\n    /// it only allows changes from sequential to arbitrary ordering.\n    /// @param _nonceOrdering The new nonce ordering to use.\n    function updateNonceOrdering(AccountNonceOrdering _nonceOrdering) external onlySystemCall {\n        AccountInfo memory currentInfo = accountInfo[msg.sender];\n\n        require(\n            _nonceOrdering == AccountNonceOrdering.Arbitrary &&\n                currentInfo.nonceOrdering == AccountNonceOrdering.Sequential,\n            \"It is only possible to change from sequential to arbitrary ordering\"\n        );\n\n        currentInfo.nonceOrdering = _nonceOrdering;\n        _storeAccountInfo(msg.sender, currentInfo);\n\n        emit AccountNonceOrderingUpdated(msg.sender, _nonceOrdering);\n    }\n\n    /// @notice Calculates the address of a deployed contract via create2\n    /// @param _sender The account that deploys the contract.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _salt The create2 salt.\n    /// @param _input The constructor data.\n    /// @return newAddress The derived address of the account.\n    function getNewAddressCreate2(\n        address _sender,\n        bytes32 _bytecodeHash,\n        bytes32 _salt,\n        bytes calldata _input\n    ) public view override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE2, since\n        // the prefix begins with 0x20....\n        bytes32 constructorInputHash = EfficientCall.keccak(_input);\n\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE2_PREFIX, bytes32(uint256(uint160(_sender))), _salt, _bytecodeHash, constructorInputHash)\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Calculates the address of a deployed contract via create\n    /// @param _sender The account that deploys the contract.\n    /// @param _senderNonce The deploy nonce of the sender's account.\n    function getNewAddressCreate(\n        address _sender,\n        uint256 _senderNonce\n    ) public pure override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE, since\n        // the prefix begins with 0x63....\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev In case of a revert, the zero address should be returned.\n    function create2(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return create2Account(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev This method also accepts nonce as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// @dev In case of a revert, the zero address should be returned.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return createAccount(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev In case of a revert, the zero address should be returned.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create2Account(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate2(msg.sender, _bytecodeHash, _salt, _input);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev This method also accepts salt as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// @dev In case of a revert, the zero address should be returned.\n    function createAccount(\n        bytes32, // salt\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        uint256 senderNonce = NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate(msg.sender, senderNonce);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice A struct that describes a forced deployment on an address\n    struct ForceDeployment {\n        // The bytecode hash to put on an address\n        bytes32 bytecodeHash;\n        // The address on which to deploy the bytecodehash to\n        address newAddress;\n        // Whether to run the constructor on the force deployment\n        bool callConstructor;\n        // The value with which to initialize a contract\n        uint256 value;\n        // The constructor calldata\n        bytes input;\n    }\n\n    /// @notice The method that can be used to forcefully deploy a contract.\n    /// @param _deployment Information about the forced deployment.\n    /// @param _sender The `msg.sender` inside the constructor call.\n    function forceDeployOnAddress(ForceDeployment calldata _deployment, address _sender) external payable onlySelf {\n        _ensureBytecodeIsKnown(_deployment.bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = AccountAbstractionVersion.None;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_deployment.newAddress, newAccountInfo);\n\n        _constructContract(\n            _sender,\n            _deployment.newAddress,\n            _deployment.bytecodeHash,\n            _deployment.input,\n            false,\n            _deployment.callConstructor\n        );\n\n        emit ContractDeployed(_sender, _deployment.bytecodeHash, _deployment.newAddress);\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    /// @dev We do not require `onlySystemCall` here, since the method is accessible only\n    /// by `FORCE_DEPLOYER`.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments) external payable {\n        require(\n            msg.sender == FORCE_DEPLOYER || msg.sender == address(COMPLEX_UPGRADER_CONTRACT),\n            \"Can only be called by FORCE_DEPLOYER or COMPLEX_UPGRADER_CONTRACT\"\n        );\n\n        uint256 deploymentsLength = _deployments.length;\n        // We need to ensure that the `value` provided by the call is enough to provide `value`\n        // for all of the deployments\n        uint256 sumOfValues = 0;\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            sumOfValues += _deployments[i].value;\n        }\n        require(msg.value == sumOfValues, \"`value` provided is not equal to the combined `value`s of deployments\");\n\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            this.forceDeployOnAddress{value: _deployments[i].value}(_deployments[i], msg.sender);\n        }\n    }\n\n    function _nonSystemDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        require(_bytecodeHash != bytes32(0x0), \"BytecodeHash cannot be zero\");\n        require(uint160(_newAddress) > MAX_SYSTEM_CONTRACT_ADDRESS, \"Can not deploy contracts in kernel space\");\n\n        // We do not allow deploying twice on the same address.\n        require(\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getCodeHash(uint256(uint160(_newAddress))) == 0x0,\n            \"Code hash is non-zero\"\n        );\n        // Do not allow deploying contracts to default accounts that have already executed transactions.\n        require(NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(_newAddress) == 0x00, \"Account is occupied\");\n\n        _performDeployOnAddress(_bytecodeHash, _newAddress, _aaVersion, _input);\n    }\n\n    /// @notice Deploy a certain bytecode on the address.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _newAddress The address of the contract to be deployed.\n    /// @param _aaVersion The version of the account abstraction protocol to use.\n    /// @param _input The constructor calldata.\n    function _performDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        _ensureBytecodeIsKnown(_bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = _aaVersion;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_newAddress, newAccountInfo);\n\n        _constructContract(msg.sender, _newAddress, _bytecodeHash, _input, false, true);\n        emit ContractDeployed(msg.sender, _bytecodeHash, _newAddress);\n    }\n\n    /// @notice Check that bytecode hash is marked as known on the `KnownCodeStorage` system contracts\n    function _ensureBytecodeIsKnown(bytes32 _bytecodeHash) internal view {\n        uint256 knownCodeMarker = KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash);\n        require(knownCodeMarker > 0, \"The code hash is not known\");\n    }\n\n    /// @notice Ensures that the _newAddress and assigns a new contract hash to it\n    /// @param _newAddress The address of the deployed contract\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    function _storeConstructingByteCodeHashOnAddress(address _newAddress, bytes32 _bytecodeHash) internal {\n        // Set the \"isConstructor\" flag to the bytecode hash\n        bytes32 constructingBytecodeHash = Utils.constructingBytecodeHash(_bytecodeHash);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructingCodeHash(_newAddress, constructingBytecodeHash);\n    }\n\n    /// @notice Transfers the `msg.value` ETH to the deployed account & invokes its constructor.\n    /// This function must revert in case the deployment fails.\n    /// @param _sender The msg.sender to be used in the constructor\n    /// @param _newAddress The address of the deployed contract\n    /// @param _input The constructor calldata\n    /// @param _isSystem Whether the call should be a system call (could be possibly required in the future).\n    function _constructContract(\n        address _sender,\n        address _newAddress,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        bool _isSystem,\n        bool _callConstructor\n    ) internal {\n        uint256 value = msg.value;\n        if (_callConstructor) {\n            // 1. Transfer the balance to the new address on the constructor call.\n            if (value > 0) {\n                ETH_TOKEN_SYSTEM_CONTRACT.transferFromTo(address(this), _newAddress, value);\n            }\n            // 2. Set the constructed code hash on the account\n            _storeConstructingByteCodeHashOnAddress(_newAddress, _bytecodeHash);\n\n            // 3. Call the constructor on behalf of the account\n            if (value > 0) {\n                // Safe to cast value, because `msg.value` <= `uint128.max` due to `MessageValueSimulator` invariant\n                SystemContractHelper.setValueForNextFarCall(uint128(value));\n            }\n            bytes memory returnData = EfficientCall.mimicCall(gasleft(), _newAddress, _input, _sender, true, _isSystem);\n            // 4. Mark bytecode hash as constructed\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.markAccountCodeHashAsConstructed(_newAddress);\n            // 5. Set the contract immutables\n            ImmutableData[] memory immutables = abi.decode(returnData, (ImmutableData[]));\n            IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT.setImmutables(_newAddress, immutables);\n        } else {\n            require(value == 0, \"The value must be zero if we do not call the constructor\");\n            // If we do not call the constructor, we need to set the constructed code hash.\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructedCodeHash(_newAddress, _bytecodeHash);\n        }\n    }\n}"
    },
    {
      "filename": "src/utils/CREATE3.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        return getDeployed(salt, address(this));\n    }\n\n    function getDeployed(bytes32 salt, address creator) internal pure returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                creator,\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}"
    },
    {
      "filename": "contracts/deploy/Create3.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IDeploy } from '../interfaces/IDeploy.sol';\nimport { ContractAddress } from '../libs/ContractAddress.sol';\nimport { CreateDeploy } from './CreateDeploy.sol';\nimport { Create3Address } from './Create3Address.sol';\n\n/**\n * @title Create3 contract\n * @notice This contract can be used to deploy a contract with a deterministic address that depends only on\n * the deployer address and deployment salt, not the contract bytecode and constructor parameters.\n */\ncontract Create3 is Create3Address, IDeploy {\n    using ContractAddress for address;\n\n    /**\n     * @notice Deploys a new contract using the `CREATE3` method.\n     * @dev This function first deploys the CreateDeploy contract using\n     * the `CREATE2` opcode and then utilizes the CreateDeploy to deploy the\n     * new contract with the `CREATE` opcode.\n     * @param bytecode The bytecode of the contract to be deployed\n     * @param deploySalt A salt to influence the contract address\n     * @return deployed The address of the deployed contract\n     */\n    function _create3(bytes memory bytecode, bytes32 deploySalt) internal returns (address deployed) {\n        deployed = _create3Address(deploySalt);\n\n        if (bytecode.length == 0) revert EmptyBytecode();\n        if (deployed.isContract()) revert AlreadyDeployed();\n\n        // Deploy using create2\n        CreateDeploy create = new CreateDeploy{ salt: deploySalt }();\n\n        if (address(create) == address(0)) revert DeployFailed();\n\n        // Deploy using create\n        create.deploy(bytecode);\n    }\n}"
    }
  ]
}