{
  "Title": "M-5: Refunding logic with multiple deposits is first mover take all",
  "Content": "# Issue M-5: Refunding logic with multiple deposits is first mover take all \n\nSource: https://github.com/sherlock-audit/2023-02-openq-judging/issues/257 \n\n## Found by \njoestakey, HollaDieWaldfee, Jeiwan, 0x52, HonorLt, MyFDsYours, TrungOre, unforgiven, ctf\\_sec, Ruhum, chaduke, yixxas, ltyu, libratus\n\n## Summary\n\nThere is no accounting to keep track of which deposits are being used to pay bounties. This means that after all deposits have expired, the first user to refund their deposit will get more funds.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/DepositManager/Implementations/DepositManagerV1.sol#L171-L179\n\nAvailable funds are simply calculated by taking the current balance of the bounty contract and subtracting the locked balance. This works well for single deposits but doesn't when there are multiple deposits from multiple funders. When this occurs it will cause a first mover take all situation.\n\nExample:\nUser A and User B both makes 10,000 USDC deposits to an Ongoing bounty, bringing the total funds of the bounty to 20,000 USDC. After some time the bounty is closed. By the time it's closed, it has paid out 10,000 USDC in awards leaving it with 10,000 USDC. User A and B both wait until their deposits are expired. Now User A requests a refund from his deposit. This refunds all 10,000 USDC to User A leaving none for User B. As a result, User A has effectively forced User B to pay all the awards.\n\n## Impact\n\nReward logic is first mover take all\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/DepositManager/Implementations/DepositManagerV1.sol#L152-L195\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBounties should track how much has been paid and how much has been funded. When an ongoing bounty is refunded it should even split remaining funds over depositors.\n\n## Discussion\n\n**FlacoJones**\n\nWill fix by requiring funder == issuer\n\n**FlacoJones**\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/117\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/116\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/39",
  "Code": [
    {
      "filename": "contracts/DepositManager/Implementations/DepositManagerV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/DepositManagerStorage.sol';\n\n/// @title DepositManagerV1\n/// @author FlacoJones\n/// @notice Manager contract for depositing protocol, ERC-20, and ERC-721 on bounty contracts\n/// @notice Emitter of all deposit-related events\ncontract DepositManagerV1 is DepositManagerStorageV1 {\n    constructor() {}\n\n    /// @notice Initializes the DepositManager implementation\n    /// @notice Can only be called once thanks to initializer (https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)\n    function initialize() external initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice Sets openQTokenWhitelist address\n    /// @param _openQTokenWhitelist The OpenQTokenWhitelist address\n    function setTokenWhitelist(address _openQTokenWhitelist)\n        external\n        onlyOwner\n        onlyProxy\n    {\n        openQTokenWhitelist = OpenQTokenWhitelist(_openQTokenWhitelist);\n    }\n\n    /// @notice Transfers protocol token or ERC20 from msg.sender to bounty address\n    /// @param _bountyAddress A bounty address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token transferred\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @param funderUuid The external user id of the funder\n    function fundBountyToken(\n        address _bountyAddress,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration,\n        string memory funderUuid\n    ) external payable onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        if (!isWhitelisted(_tokenAddress)) {\n            require(\n                !tokenAddressLimitReached(_bountyAddress),\n                Errors.TOO_MANY_TOKEN_ADDRESSES\n            );\n        }\n\n        require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);\n\n        (bytes32 depositId, uint256 volumeReceived) = bounty.receiveFunds{\n            value: msg.value\n        }(msg.sender, _tokenAddress, _volume, _expiration);\n\n        bytes memory funderUuidBytes = abi.encode(funderUuid);\n\n        emit TokenDepositReceived(\n            depositId,\n            _bountyAddress,\n            bounty.bountyId(),\n            bounty.organization(),\n            _tokenAddress,\n            block.timestamp,\n            msg.sender,\n            _expiration,\n            volumeReceived,\n            0,\n            funderUuidBytes,\n            VERSION_1\n        );\n    }\n\n    /// @notice Extends the expiration for a deposit\n    /// @param _bountyAddress Bounty address\n    /// @param _depositId The deposit to extend\n    /// @param _seconds The duration to add until the deposit becomes refundable\n    function extendDeposit(\n        address _bountyAddress,\n        bytes32 _depositId,\n        uint256 _seconds\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(\n            bounty.funder(_depositId) == msg.sender,\n            Errors.CALLER_NOT_FUNDER\n        );\n\n        uint256 newExpiration = bounty.extendDeposit(\n            _depositId,\n            _seconds,\n            msg.sender\n        );\n\n        emit DepositExtended(\n            _depositId,\n            newExpiration,\n            0,\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    /// @notice Transfers NFT from msg.sender to bounty address\n    /// @param _bountyAddress The address of the bounty to fund\n    /// @param _tokenAddress The ERC721 token address of the NFT\n    /// @param _tokenId The tokenId of the NFT to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @param _data The tier of the NFT (not relevant for non-tiered bounties)\n    function fundBountyNFT(\n        address _bountyAddress,\n        address _tokenAddress,\n        uint256 _tokenId,\n        uint256 _expiration,\n        bytes calldata _data\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(isWhitelisted(_tokenAddress), Errors.TOKEN_NOT_ACCEPTED);\n        require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);\n\n        bytes32 depositId = bounty.receiveNft(\n            msg.sender,\n            _tokenAddress,\n            _tokenId,\n            _expiration,\n            _data\n        );\n\n        emit NFTDepositReceived(\n            depositId,\n            _bountyAddress,\n            bounty.bountyId(),\n            bounty.organization(),\n            _tokenAddress,\n            block.timestamp,\n            msg.sender,\n            _expiration,\n            _tokenId,\n            0,\n            _data,\n            VERSION_1\n        );\n    }\n\n    /// @notice Refunds an individual deposit from bountyAddress to sender if expiration time has passed\n    /// @param _bountyAddress The address of the bounty that has the deposit to refund\n    /// @param _depositId The depositId associated with the deposit being refunded\n    function refundDeposit(address _bountyAddress, bytes32 _depositId)\n        external\n        onlyProxy\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(\n            bounty.funder(_depositId) == msg.sender,\n            Errors.CALLER_NOT_FUNDER\n        );\n\n        require(\n            block.timestamp >=\n                bounty.depositTime(_depositId) + bounty.expiration(_depositId),\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        address depToken = bounty.tokenAddress(_depositId);\n\n        uint256 availableFunds = bounty.getTokenBalance(depToken) -\n            bounty.getLockedFunds(depToken);\n\n        uint256 volume;\n        if (bounty.volume(_depositId) <= availableFunds) {\n            volume = bounty.volume(_depositId);\n        } else {\n            volume = availableFunds;\n        }\n\n        bounty.refundDeposit(_depositId, msg.sender, volume);\n\n        emit DepositRefunded(\n            _depositId,\n            bounty.bountyId(),\n            _bountyAddress,\n            bounty.organization(),\n            block.timestamp,\n            bounty.tokenAddress(_depositId),\n            volume,\n            0,\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    /// @notice Checks if _tokenAddress is whitelisted\n    /// @param _tokenAddress The token address in question\n    /// @return True if _tokenAddress is whitelisted, false otherwise\n    function isWhitelisted(address _tokenAddress) public view returns (bool) {\n        return openQTokenWhitelist.isWhitelisted(_tokenAddress);\n    }\n\n    /// @notice Returns true if the total number of unique tokens deposited on then bounty is greater than the OpenQWhitelist TOKEN_ADDRESS_LIMIT\n    /// @param _bountyAddress Address of bounty\n    /// @return True if the token address limit has been reached\n    function tokenAddressLimitReached(address _bountyAddress)\n        public\n        view\n        returns (bool)\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        return\n            bounty.getTokenAddressesCount() >=\n            openQTokenWhitelist.TOKEN_ADDRESS_LIMIT();\n    }\n\n    /// @notice Checks if bounty associated with _bountyId is open\n    /// @param _bountyAddress Address of bounty\n    /// @return bool True if _bountyId is associated with an open bounty\n    function bountyIsOpen(address _bountyAddress) public view returns (bool) {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n        bool isOpen = bounty.status() == OpenQDefinitions.OPEN;\n        return isOpen;\n    }\n\n    /// @notice Override for UUPSUpgradeable._authorizeUpgrade(address newImplementation) to enforce onlyOwner upgrades\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}"
    },
    {
      "filename": "contracts/DepositManager/Implementations/DepositManagerV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/DepositManagerStorage.sol';\n\n/// @title DepositManagerV1\n/// @author FlacoJones\n/// @notice Manager contract for depositing protocol, ERC-20, and ERC-721 on bounty contracts\n/// @notice Emitter of all deposit-related events\ncontract DepositManagerV1 is DepositManagerStorageV1 {\n    constructor() {}\n\n    /// @notice Initializes the DepositManager implementation\n    /// @notice Can only be called once thanks to initializer (https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)\n    function initialize() external initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice Sets openQTokenWhitelist address\n    /// @param _openQTokenWhitelist The OpenQTokenWhitelist address\n    function setTokenWhitelist(address _openQTokenWhitelist)\n        external\n        onlyOwner\n        onlyProxy\n    {\n        openQTokenWhitelist = OpenQTokenWhitelist(_openQTokenWhitelist);\n    }\n\n    /// @notice Transfers protocol token or ERC20 from msg.sender to bounty address\n    /// @param _bountyAddress A bounty address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token transferred\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @param funderUuid The external user id of the funder\n    function fundBountyToken(\n        address _bountyAddress,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration,\n        string memory funderUuid\n    ) external payable onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        if (!isWhitelisted(_tokenAddress)) {\n            require(\n                !tokenAddressLimitReached(_bountyAddress),\n                Errors.TOO_MANY_TOKEN_ADDRESSES\n            );\n        }\n\n        require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);\n\n        (bytes32 depositId, uint256 volumeReceived) = bounty.receiveFunds{\n            value: msg.value\n        }(msg.sender, _tokenAddress, _volume, _expiration);\n\n        bytes memory funderUuidBytes = abi.encode(funderUuid);\n\n        emit TokenDepositReceived(\n            depositId,\n            _bountyAddress,\n            bounty.bountyId(),\n            bounty.organization(),\n            _tokenAddress,\n            block.timestamp,\n            msg.sender,\n            _expiration,\n            volumeReceived,\n            0,\n            funderUuidBytes,\n            VERSION_1\n        );\n    }\n\n    /// @notice Extends the expiration for a deposit\n    /// @param _bountyAddress Bounty address\n    /// @param _depositId The deposit to extend\n    /// @param _seconds The duration to add until the deposit becomes refundable\n    function extendDeposit(\n        address _bountyAddress,\n        bytes32 _depositId,\n        uint256 _seconds\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(\n            bounty.funder(_depositId) == msg.sender,\n            Errors.CALLER_NOT_FUNDER\n        );\n\n        uint256 newExpiration = bounty.extendDeposit(\n            _depositId,\n            _seconds,\n            msg.sender\n        );\n\n        emit DepositExtended(\n            _depositId,\n            newExpiration,\n            0,\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    /// @notice Transfers NFT from msg.sender to bounty address\n    /// @param _bountyAddress The address of the bounty to fund\n    /// @param _tokenAddress The ERC721 token address of the NFT\n    /// @param _tokenId The tokenId of the NFT to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @param _data The tier of the NFT (not relevant for non-tiered bounties)\n    function fundBountyNFT(\n        address _bountyAddress,\n        address _tokenAddress,\n        uint256 _tokenId,\n        uint256 _expiration,\n        bytes calldata _data\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(isWhitelisted(_tokenAddress), Errors.TOKEN_NOT_ACCEPTED);\n        require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);\n\n        bytes32 depositId = bounty.receiveNft(\n            msg.sender,\n            _tokenAddress,\n            _tokenId,\n            _expiration,\n            _data\n        );\n\n        emit NFTDepositReceived(\n            depositId,\n            _bountyAddress,\n            bounty.bountyId(),\n            bounty.organization(),\n            _tokenAddress,\n            block.timestamp,\n            msg.sender,\n            _expiration,\n            _tokenId,\n            0,\n            _data,\n            VERSION_1\n        );\n    }\n\n    /// @notice Refunds an individual deposit from bountyAddress to sender if expiration time has passed\n    /// @param _bountyAddress The address of the bounty that has the deposit to refund\n    /// @param _depositId The depositId associated with the deposit being refunded\n    function refundDeposit(address _bountyAddress, bytes32 _depositId)\n        external\n        onlyProxy\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(\n            bounty.funder(_depositId) == msg.sender,\n            Errors.CALLER_NOT_FUNDER\n        );\n\n        require(\n            block.timestamp >=\n                bounty.depositTime(_depositId) + bounty.expiration(_depositId),\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        address depToken = bounty.tokenAddress(_depositId);\n\n        uint256 availableFunds = bounty.getTokenBalance(depToken) -\n            bounty.getLockedFunds(depToken);\n\n        uint256 volume;\n        if (bounty.volume(_depositId) <= availableFunds) {\n            volume = bounty.volume(_depositId);\n        } else {\n            volume = availableFunds;\n        }\n\n        bounty.refundDeposit(_depositId, msg.sender, volume);\n\n        emit DepositRefunded(\n            _depositId,\n            bounty.bountyId(),\n            _bountyAddress,\n            bounty.organization(),\n            block.timestamp,\n            bounty.tokenAddress(_depositId),\n            volume,\n            0,\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    /// @notice Checks if _tokenAddress is whitelisted\n    /// @param _tokenAddress The token address in question\n    /// @return True if _tokenAddress is whitelisted, false otherwise\n    function isWhitelisted(address _tokenAddress) public view returns (bool) {\n        return openQTokenWhitelist.isWhitelisted(_tokenAddress);\n    }\n\n    /// @notice Returns true if the total number of unique tokens deposited on then bounty is greater than the OpenQWhitelist TOKEN_ADDRESS_LIMIT\n    /// @param _bountyAddress Address of bounty\n    /// @return True if the token address limit has been reached\n    function tokenAddressLimitReached(address _bountyAddress)\n        public\n        view\n        returns (bool)\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        return\n            bounty.getTokenAddressesCount() >=\n            openQTokenWhitelist.TOKEN_ADDRESS_LIMIT();\n    }\n\n    /// @notice Checks if bounty associated with _bountyId is open\n    /// @param _bountyAddress Address of bounty\n    /// @return bool True if _bountyId is associated with an open bounty\n    function bountyIsOpen(address _bountyAddress) public view returns (bool) {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n        bool isOpen = bounty.status() == OpenQDefinitions.OPEN;\n        return isOpen;\n    }\n\n    /// @notice Override for UUPSUpgradeable._authorizeUpgrade(address newImplementation) to enforce onlyOwner upgrades\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}"
    }
  ]
}