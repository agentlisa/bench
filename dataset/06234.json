{
  "Title": "[H-25] Overflow risk in Market contract",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L415-L421> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L390-L396>\n\nActions of users (borrow, repay, removeCollateral, ...) in Martket contract might be reverted by overflow, resulting in their funds might be frozen.\n\n### Proof of concept\n\nFunction `_isSolvent` in `Market` contract use conversion from share to amount of yieldBox.\n\n```solidity\nyieldBox.toAmount(\n    collateralId,\n    collateralShare *\n        (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n        collateralizationRate,\n    false\n)\n```\n\nIt will trigger `_toAmount` function in `YieldBoxRebase` contract\n\n```solidity\nfunction _toAmount(\n    uint256 share,\n    uint256 totalShares_,\n    uint256 totalAmount,\n    bool roundUp\n) internal pure returns (uint256 amount) {\n    totalAmount++;\n    totalShares_ += 1e8;\n\n    amount = (share * totalAmount) / totalShares_;\n\n    if (roundUp && (amount * totalShares_) / totalAmount < share) {\n        amount++;\n    }\n}\n```\n\nThe calculation `amount = (share * totalAmount) / totalShares_` might be overflow because\n`share * totalAmount` = `collateralShare * (EXCHANGE_RATE_PRECISION / FEE_PRECISION) * collateralizationRate * totalAmount`\n\nIn the default condition,<br>\n`EXCHANGE_RATE_PRECISION` = 1e18,<br>\n`FEE_PRECISION` = 1e5,<br>\n`collateralizationRate` = 0.75e18\n\nThe `collateralShare` is equal to around `1e8 * collateralAmount` by default (because `totalAmount++; totalShares_ += 1e8;` is present in the `_toAmount` function).\n\n\\=> **`share * totalAmount` \\~= (collateralAmount &ast; 1e8) &ast; (1e18 / 1e5) &ast; 0.75e18 &ast; totalAmount = collateralAmount &ast; totalAmount &ast; 0.75e39**\n\nThis formula will overflow when `collateralAmount * totalAmount` > 1.5e38. This situation can occur easily with 18-decimal collateral. As a consequence, user transactions will revert due to overflow, resulting in the freezing of market functionalities.\n\nThe same issue applies to the calculation of `_computeMaxBorrowableAmount` in the Market contract.\n\n### Recommended Mitigation Steps\n\nReduce some variables used to trigger yieldBox.toAmount(), such as `EXCHANGE_RATE_PRECISION` and `collateralizationRate`, and use these variables to calculate with the obtained amount.\nExample, the expected amount can be calculated as:\n\n```solidity\nyieldBox.toAmount(\n    collateralId,\n    collateralShare\n    false\n) * (EXCHANGE_RATE_PRECISION / FEE_PRECISION) * collateralizationRate\n```\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1109#issuecomment-1701992223)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol\";\nimport \"tapioca-periph/contracts/interfaces/IOracle.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPenrose.sol\";\nimport \"./MarketERC20.sol\";\n\n/// @title Market contract\n/// @notice Market contract implemented by Singularity & BigBang\nabstract contract Market is MarketERC20, BoringOwnable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns YieldBox address\n    YieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n\n    /// @notice contract's pause state\n    bool public paused;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice oracle address\n    IOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice liquidation caller rewards\n    uint256 public callerFee; // 90%\n    /// @notice liquidation protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 1e3; //1%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 1e4; //10%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice borrowing opening fee\n    uint256 public borrowOpeningFee = 50; //0.05%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(bool oldState, bool newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated();\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address liquidator,\n        address[] users,\n        uint256 liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when borrow opening fee is updated\n    event LogBorrowingFee(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 oldVal, uint256 newVal);\n\n    modifier notPaused() {\n        require(!paused, \"Market: paused\");\n        _;\n    }\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice sets the borrowing opening fee\n    /// @dev can only be called by the owner\n    /// @param _val the new value\n    function setBorrowOpeningFee(uint256 _val) external onlyOwner {\n        require(_val <= FEE_PRECISION, \"Market: not valid\");\n        emit LogBorrowingFee(borrowOpeningFee, _val);\n        borrowOpeningFee = _val;\n    }\n\n    /// @notice sets max borrowable amount\n    /// @dev can only be called by the owner\n    /// @param _cap the new value\n    function setBorrowCap(uint256 _cap) external notPaused onlyOwner {\n        emit LogBorrowCapUpdated(totalBorrowCap, _cap);\n        totalBorrowCap = _cap;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setMarketConfig(\n        uint256 _borrowOpeningFee,\n        IOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _callerFee,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate\n    ) external onlyOwner {\n        if (_borrowOpeningFee > 0) {\n            require(_borrowOpeningFee <= FEE_PRECISION, \"Market: not valid\");\n            emit LogBorrowingFee(borrowOpeningFee, _borrowOpeningFee);\n            borrowOpeningFee = _borrowOpeningFee;\n        }\n\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated();\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_callerFee > 0) {\n            require(_callerFee <= FEE_PRECISION, \"Market: not valid\");\n            callerFee = _callerFee;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(\n                _liquidationBonusAmount < FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            liquidationBonusAmount = _liquidationBonusAmount;\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _minLiquidatorReward < maxLiquidatorReward,\n                \"Market: not valid\"\n            );\n            minLiquidatorReward = _minLiquidatorReward;\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            require(_maxLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _maxLiquidatorReward > minLiquidatorReward,\n                \"Market: not valid\"\n            );\n            maxLiquidatorReward = _maxLiquidatorReward;\n        }\n\n        if (_totalBorrowCap > 0) {\n            emit LogBorrowCapUpdated(totalBorrowCap, _totalBorrowCap);\n            totalBorrowCap = _totalBorrowCap;\n        }\n\n        if (_collateralizationRate > 0) {\n            require(\n                _collateralizationRate <= FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            collateralizationRate = _collateralizationRate;\n        }\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n        require(val != paused, \"Market: same state\");\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the maximum liquidatable amount for user\n    function computeClosingFactor(\n        uint256 borrowPart,\n        uint256 collateralPartInAsset,\n        uint256 borrowPartDecimals,\n        uint256 collateralPartDecimals,\n        uint256 ratesPrecision\n    ) public view returns (uint256) {\n        uint256 borrowPartScaled = borrowPart;\n        if (borrowPartDecimals > 18) {\n            borrowPartScaled = borrowPart / (10 ** (borrowPartDecimals - 18));\n        }\n        if (borrowPartDecimals < 18) {\n            borrowPartScaled = borrowPart * (10 ** (18 - borrowPartDecimals));\n        }\n\n        uint256 collateralPartInAssetScaled = collateralPartInAsset;\n        if (collateralPartDecimals > 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset /\n                (10 ** (collateralPartDecimals - 18));\n        }\n        if (collateralPartDecimals < 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset *\n                (10 ** (18 - collateralPartDecimals));\n        }\n\n        uint256 liquidationStartsAt = (collateralPartInAssetScaled *\n            collateralizationRate) / (10 ** ratesPrecision);\n        if (borrowPartScaled < liquidationStartsAt) return 0;\n\n        uint256 numerator = borrowPartScaled -\n            ((collateralizationRate * collateralPartInAssetScaled) /\n                (10 ** ratesPrecision));\n        uint256 denominator = ((10 ** ratesPrecision) -\n            (collateralizationRate *\n                ((10 ** ratesPrecision) + liquidationMultiplier)) /\n            (10 ** ratesPrecision)) * (10 ** (18 - ratesPrecision));\n\n        uint256 x = (numerator * 1e18) / denominator;\n        return x;\n    }\n\n    /// @notice return the amount of collateral for a `user` to be solvent, min TVL and max TVL. Returns 0 if user already solvent.\n    /// @dev we use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      to prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate the exchange rate asset/collateral.\n    /// @return amountToSolvency the amount of collateral to be solvent.\n    function computeTVLInfo(\n        address user,\n        uint256 _exchangeRate\n    )\n        public\n        view\n        returns (uint256 amountToSolvency, uint256 minTVL, uint256 maxTVL)\n    {\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return (0, 0, 0);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmountInAsset = _computeMaxBorrowableAmount(\n            user,\n            _exchangeRate\n        );\n\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        amountToSolvency = borrowPart >= collateralAmountInAsset\n            ? borrowPart - collateralAmountInAsset\n            : 0;\n\n        (minTVL, maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n    }\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// @dev This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    ///      Oracle should consider USDO at 1$\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(\"\");\n\n        if (updated) {\n            require(rate > 0, \"Market: invalid rate\");\n            exchangeRate = rate;\n            emit LogExchangeRate(rate);\n        } else {\n            // Return the old rate if fetching wasn't successful\n            rate = exchangeRate;\n        }\n    }\n\n    /// @notice computes the possible liquidator reward\n    /// @notice user the user for which a liquidation operation should be performed\n    /// @param _exchangeRate the exchange rate asset/collateral to use for internal computations\n    function computeLiquidatorReward(\n        address user,\n        uint256 _exchangeRate\n    ) public view returns (uint256) {\n        (uint256 minTVL, uint256 maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n        return _getCallerReward(userBorrowPart[user], minTVL, maxTVL);\n    }\n\n    // ************************** //\n    // *** INTERNAL FUNCTIONS *** //\n    // ************************** //\n    function _accrue() internal virtual;\n\n    function _getRevertMsg(\n        bytes memory _returnData\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Market: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _computeMaxBorrowableAmount(\n        address user,\n        uint256 _exchangeRate\n    ) internal view returns (uint256 collateralAmountInAsset) {\n        collateralAmountInAsset =\n            yieldBox.toAmount(\n                collateralId,\n                (userCollateralShare[user] *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate),\n                false\n            ) /\n            _exchangeRate;\n    }\n\n    /// @notice Concrete implementation of `isSolvent`. Includes a parameter to allow caching `exchangeRate`.\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\n    function _isSolvent(\n        address user,\n        uint256 _exchangeRate\n    ) internal view returns (bool) {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return true;\n        uint256 collateralShare = userCollateralShare[user];\n        if (collateralShare == 0) return false;\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        return\n            yieldBox.toAmount(\n                collateralId,\n                collateralShare *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate,\n                false\n            ) >=\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\n            (borrowPart * _totalBorrow.elastic * _exchangeRate) /\n                _totalBorrow.base;\n    }\n\n    /// @notice Returns the min and max LTV for user in asset price\n    function _computeMaxAndMinLTVInAsset(\n        uint256 collateralShare,\n        uint256 _exchangeRate\n    ) internal view returns (uint256 min, uint256 max) {\n        uint256 collateralAmount = yieldBox.toAmount(\n            collateralId,\n            collateralShare,\n            false\n        );\n\n        max = (collateralAmount * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n        min = (max * collateralizationRate) / FEE_PRECISION;\n    }\n\n    function _getCallerReward(\n        uint256 borrowed,\n        uint256 startTVLInAsset,\n        uint256 maxTVLInAsset\n    ) internal view returns (uint256) {\n        if (borrowed == 0) return 0;\n        if (startTVLInAsset == 0) return 0;\n\n        if (borrowed < startTVLInAsset) return 0;\n        if (borrowed >= maxTVLInAsset) return minLiquidatorReward;\n\n        uint256 rewardPercentage = ((borrowed - startTVLInAsset) *\n            FEE_PRECISION) / (maxTVLInAsset - startTVLInAsset);\n\n        int256 diff = int256(minLiquidatorReward) - int256(maxLiquidatorReward);\n        int256 reward = (diff * int256(rewardPercentage)) /\n            int256(FEE_PRECISION) +\n            int256(maxLiquidatorReward);\n\n        return uint256(reward);\n    }\n\n    function _computeAllowanceAmountInAsset(\n        address user,\n        uint256 _exchangeRate,\n        uint256 borrowAmount,\n        uint256 assetDecimals\n    ) internal view returns (uint256) {\n        uint256 maxBorrowabe = _computeMaxBorrowableAmount(user, _exchangeRate);\n\n        uint256 shareRatio = _getRatio(\n            borrowAmount,\n            maxBorrowabe,\n            assetDecimals\n        );\n        return (shareRatio * userCollateralShare[user]) / (10 ** assetDecimals);\n    }\n\n    function _getRatio(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 precision\n    ) private pure returns (uint256) {\n        if (numerator == 0 || denominator == 0) {\n            return 0;\n        }\n        uint256 _numerator = numerator * 10 ** (precision + 1);\n        uint256 _quotient = ((_numerator / denominator) + 5) / 10;\n        return (_quotient);\n    }\n}"
    },
    {
      "filename": "contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol\";\nimport \"tapioca-periph/contracts/interfaces/IOracle.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPenrose.sol\";\nimport \"./MarketERC20.sol\";\n\n/// @title Market contract\n/// @notice Market contract implemented by Singularity & BigBang\nabstract contract Market is MarketERC20, BoringOwnable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns YieldBox address\n    YieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n\n    /// @notice contract's pause state\n    bool public paused;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice oracle address\n    IOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice liquidation caller rewards\n    uint256 public callerFee; // 90%\n    /// @notice liquidation protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 1e3; //1%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 1e4; //10%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice borrowing opening fee\n    uint256 public borrowOpeningFee = 50; //0.05%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(bool oldState, bool newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated();\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address liquidator,\n        address[] users,\n        uint256 liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when borrow opening fee is updated\n    event LogBorrowingFee(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 oldVal, uint256 newVal);\n\n    modifier notPaused() {\n        require(!paused, \"Market: paused\");\n        _;\n    }\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice sets the borrowing opening fee\n    /// @dev can only be called by the owner\n    /// @param _val the new value\n    function setBorrowOpeningFee(uint256 _val) external onlyOwner {\n        require(_val <= FEE_PRECISION, \"Market: not valid\");\n        emit LogBorrowingFee(borrowOpeningFee, _val);\n        borrowOpeningFee = _val;\n    }\n\n    /// @notice sets max borrowable amount\n    /// @dev can only be called by the owner\n    /// @param _cap the new value\n    function setBorrowCap(uint256 _cap) external notPaused onlyOwner {\n        emit LogBorrowCapUpdated(totalBorrowCap, _cap);\n        totalBorrowCap = _cap;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setMarketConfig(\n        uint256 _borrowOpeningFee,\n        IOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _callerFee,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate\n    ) external onlyOwner {\n        if (_borrowOpeningFee > 0) {\n            require(_borrowOpeningFee <= FEE_PRECISION, \"Market: not valid\");\n            emit LogBorrowingFee(borrowOpeningFee, _borrowOpeningFee);\n            borrowOpeningFee = _borrowOpeningFee;\n        }\n\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated();\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_callerFee > 0) {\n            require(_callerFee <= FEE_PRECISION, \"Market: not valid\");\n            callerFee = _callerFee;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(\n                _liquidationBonusAmount < FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            liquidationBonusAmount = _liquidationBonusAmount;\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _minLiquidatorReward < maxLiquidatorReward,\n                \"Market: not valid\"\n            );\n            minLiquidatorReward = _minLiquidatorReward;\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            require(_maxLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _maxLiquidatorReward > minLiquidatorReward,\n                \"Market: not valid\"\n            );\n            maxLiquidatorReward = _maxLiquidatorReward;\n        }\n\n        if (_totalBorrowCap > 0) {\n            emit LogBorrowCapUpdated(totalBorrowCap, _totalBorrowCap);\n            totalBorrowCap = _totalBorrowCap;\n        }\n\n        if (_collateralizationRate > 0) {\n            require(\n                _collateralizationRate <= FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            collateralizationRate = _collateralizationRate;\n        }\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n        require(val != paused, \"Market: same state\");\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the maximum liquidatable amount for user\n    function computeClosingFactor(\n        uint256 borrowPart,\n        uint256 collateralPartInAsset,\n        uint256 borrowPartDecimals,\n        uint256 collateralPartDecimals,\n        uint256 ratesPrecision\n    ) public view returns (uint256) {\n        uint256 borrowPartScaled = borrowPart;\n        if (borrowPartDecimals > 18) {\n            borrowPartScaled = borrowPart / (10 ** (borrowPartDecimals - 18));\n        }\n        if (borrowPartDecimals < 18) {\n            borrowPartScaled = borrowPart * (10 ** (18 - borrowPartDecimals));\n        }\n\n        uint256 collateralPartInAssetScaled = collateralPartInAsset;\n        if (collateralPartDecimals > 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset /\n                (10 ** (collateralPartDecimals - 18));\n        }\n        if (collateralPartDecimals < 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset *\n                (10 ** (18 - collateralPartDecimals));\n        }\n\n        uint256 liquidationStartsAt = (collateralPartInAssetScaled *\n            collateralizationRate) / (10 ** ratesPrecision);\n        if (borrowPartScaled < liquidationStartsAt) return 0;\n\n        uint256 numerator = borrowPartScaled -\n            ((collateralizationRate * collateralPartInAssetScaled) /\n                (10 ** ratesPrecision));\n        uint256 denominator = ((10 ** ratesPrecision) -\n            (collateralizationRate *\n                ((10 ** ratesPrecision) + liquidationMultiplier)) /\n            (10 ** ratesPrecision)) * (10 ** (18 - ratesPrecision));\n\n        uint256 x = (numerator * 1e18) / denominator;\n        return x;\n    }\n\n    /// @notice return the amount of collateral for a `user` to be solvent, min TVL and max TVL. Returns 0 if user already solvent.\n    /// @dev we use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      to prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate the exchange rate asset/collateral.\n    /// @return amountToSolvency the amount of collateral to be solvent.\n    function computeTVLInfo(\n        address user,\n        uint256 _exchangeRate\n    )\n        public\n        view\n        returns (uint256 amountToSolvency, uint256 minTVL, uint256 maxTVL)\n    {\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return (0, 0, 0);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmountInAsset = _computeMaxBorrowableAmount(\n            user,\n            _exchangeRate\n        );\n\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        amountToSolvency = borrowPart >= collateralAmountInAsset\n            ? borrowPart - collateralAmountInAsset\n            : 0;\n\n        (minTVL, maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n    }\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// @dev This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    ///      Oracle should consider USDO at 1$\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(\"\");\n\n        if (updated) {\n            require(rate > 0, \"Market: invalid rate\");\n            exchangeRate = rate;\n            emit LogExchangeRate(rate);\n        } else {\n            // Return the old rate if fetching wasn't successful\n            rate = exchangeRate;\n        }\n    }\n\n    /// @notice computes the possible liquidator reward\n    /// @notice user the user for which a liquidation operation should be performed\n    /// @param _exchangeRate the exchange rate asset/collateral to use for internal computations\n    function computeLiquidatorReward(\n        address user,\n        uint256 _exchangeRate\n    ) public view returns (uint256) {\n        (uint256 minTVL, uint256 maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n        return _getCallerReward(userBorrowPart[user], minTVL, maxTVL);\n    }\n\n    // ************************** //\n    // *** INTERNAL FUNCTIONS *** //\n    // ************************** //\n    function _accrue() internal virtual;\n\n    function _getRevertMsg(\n        bytes memory _returnData\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Market: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _computeMaxBorrowableAmount(\n        address user,\n        uint256 _exchangeRate\n    ) internal view returns (uint256 collateralAmountInAsset) {\n        collateralAmountInAsset =\n            yieldBox.toAmount(\n                collateralId,\n                (userCollateralShare[user] *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate),\n                false\n            ) /\n            _"
    }
  ]
}