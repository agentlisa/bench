{
  "Title": "[L13] Fraction reduction is not applied in all methods",
  "Content": "The [`FractionUtil` library](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol) adds the functionality to use [`Fractions`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L10-L13) in contracts.\n\n\nWhen operations with fractions are done, the result `Fraction` *might* have a greatest common divisor (GCD) greater than one. In this scenario, that `Fraction` can be reduced. This is called after finishing operations such as in the [`add`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L57), [`sub`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L73), and [`mul`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L83) methods.\n\n\nHowever, [the `div` method](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L112) does not reduce the `Fraction` once the operation ends, creating the possibility of having denominators and numerators that have a greater than one GCD.\n\n\nConsider reducing the result of the `div` method after the operation is completed.\n\n\n***Update**: Fixed in [pull request #2890](https://github.com/celo-org/celo-monorepo/pull/2890). The [`FractionUtil` contract was removed](https://github.com/celo-org/celo-monorepo/pull/2890/files#diff-a6ab9ebb5bec0a336a6b4614bd82063c). Now the [only function that used it returns a tuple of (numerator, denominator)](https://github.com/celo-org/celo-monorepo/pull/2890/files#diff-b3cbc9c000b2a3d8f2f8360587d70368L342).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/FractionUtil.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n// TODO(asa): Move to uint128 if gas savings are significant enough.\nlibrary FractionUtil {\n  using SafeMath for uint256;\n  using FractionUtil for Fraction;\n\n  struct Fraction {\n    uint256 numerator;\n    uint256 denominator;\n  }\n\n  function reduce(Fraction memory x) internal pure returns (Fraction memory) {\n    uint256 gcd = x.denominator;\n    uint256 y = x.numerator;\n    while (y != 0) {\n      uint256 y_ = gcd % y;\n      gcd = y;\n      y = y_;\n    }\n    Fraction memory fraction = Fraction(x.numerator.div(gcd), x.denominator.div(gcd));\n    return fraction;\n  }\n\n  /**\n   * @dev Returns whether or not at least one of numerator and denominator are non-zero.\n   * @return Whether or not at least one of numerator and denominator are non-zero.\n   */\n  function exists(Fraction memory x) internal pure returns (bool) {\n    return x.numerator > 0 || x.denominator > 0;\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x == y\n   */\n  function equals(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) == y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns a new fraction that is the sum of two rates.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x + y\n   */\n  function add(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    return\n      Fraction(\n        x.numerator.mul(y.denominator).add(y.numerator.mul(x.denominator)),\n        x.denominator.mul(y.denominator)\n      )\n        .reduce();\n  }\n\n  /**\n   * @dev Returns a new fraction that is the two rates subtracted from each other.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x - y\n   */\n  function sub(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    require(isGreaterThanOrEqualTo(x, y));\n    return\n      Fraction(\n        x.numerator.mul(y.denominator).sub(y.numerator.mul(x.denominator)),\n        x.denominator.mul(y.denominator)\n      )\n        .reduce();\n  }\n\n  /**\n   * @dev Returns a fraction that is the fraction times a fraction.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x * y\n   */\n  function mul(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    return Fraction(x.numerator.mul(y.numerator), x.denominator.mul(y.denominator)).reduce();\n  }\n\n  /**\n   * @dev Returns an integer that is the fraction time an integer.\n   * @param x A Fraction struct.\n   * @param y An integer.\n   * @return x * y\n   */\n  function mul(Fraction memory x, uint256 y) internal pure returns (uint256) {\n    return x.numerator.mul(y).div(x.denominator);\n  }\n\n  /**\n   * @dev Returns the inverse of the fraction.\n   * @param x A Fraction struct.\n   * @return 1 / x\n   */\n  function inverse(Fraction memory x) internal pure returns (Fraction memory) {\n    require(x.numerator != 0);\n    return Fraction(x.denominator, x.numerator);\n  }\n\n  /**\n   * @dev Returns a fraction that is the fraction divided by a fraction.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x / y\n   */\n  function div(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    require(y.numerator != 0);\n    return Fraction(x.numerator.mul(y.denominator), x.denominator.mul(y.numerator));\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is greater than fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x > y\n   */\n  function isGreaterThan(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) > y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is greater than or equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x >= y\n   */\n  function isGreaterThanOrEqualTo(Fraction memory x, Fraction memory y)\n    internal\n    pure\n    returns (bool)\n  {\n    return x.numerator.mul(y.denominator) >= y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is less than fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x < y\n   */\n  function isLessThan(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) < y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is less than or equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x <= y\n   */\n  function isLessThanOrEqualTo(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) <= y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"z\" is between fractions \"x\" and \"y\".\n   * @param z A Fraction struct.\n   * @param x A Fraction struct representing a rate lower than \"y\".\n   * @param y A Fraction struct representing a rate higher than \"x\".\n   * @return x <= z <= y\n   */\n  function isBetween(Fraction memory z, Fraction memory x, Fraction memory y)\n    internal\n    pure\n    returns (bool)\n  {\n    return isLessThanOrEqualTo(x, z) && isLessThanOrEqualTo(z, y);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/FractionUtil.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n// TODO(asa): Move to uint128 if gas savings are significant enough.\nlibrary FractionUtil {\n  using SafeMath for uint256;\n  using FractionUtil for Fraction;\n\n  struct Fraction {\n    uint256 numerator;\n    uint256 denominator;\n  }\n\n  function reduce(Fraction memory x) internal pure returns (Fraction memory) {\n    uint256 gcd = x.denominator;\n    uint256 y = x.numerator;\n    while (y != 0) {\n      uint256 y_ = gcd % y;\n      gcd = y;\n      y = y_;\n    }\n    Fraction memory fraction = Fraction(x.numerator.div(gcd), x.denominator.div(gcd));\n    return fraction;\n  }\n\n  /**\n   * @dev Returns whether or not at least one of numerator and denominator are non-zero.\n   * @return Whether or not at least one of numerator and denominator are non-zero.\n   */\n  function exists(Fraction memory x) internal pure returns (bool) {\n    return x.numerator > 0 || x.denominator > 0;\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x == y\n   */\n  function equals(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) == y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns a new fraction that is the sum of two rates.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x + y\n   */\n  function add(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    return\n      Fraction(\n        x.numerator.mul(y.denominator).add(y.numerator.mul(x.denominator)),\n        x.denominator.mul(y.denominator)\n      )\n        .reduce();\n  }\n\n  /**\n   * @dev Returns a new fraction that is the two rates subtracted from each other.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x - y\n   */\n  function sub(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    require(isGreaterThanOrEqualTo(x, y));\n    return\n      Fraction(\n        x.numerator.mul(y.denominator).sub(y.numerator.mul(x.denominator)),\n        x.denominator.mul(y.denominator)\n      )\n        .reduce();\n  }\n\n  /**\n   * @dev Returns a fraction that is the fraction times a fraction.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x * y\n   */\n  function mul(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    return Fraction(x.numerator.mul(y.numerator), x.denominator.mul(y.denominator)).reduce();\n  }\n\n  /**\n   * @dev Returns an integer that is the fraction time an integer.\n   * @param x A Fraction struct.\n   * @param y An integer.\n   * @return x * y\n   */\n  function mul(Fraction memory x, uint256 y) internal pure returns (uint256) {\n    return x.numerator.mul(y).div(x.denominator);\n  }\n\n  /**\n   * @dev Returns the inverse of the fraction.\n   * @param x A Fraction struct.\n   * @return 1 / x\n   */\n  function inverse(Fraction memory x) internal pure returns (Fraction memory) {\n    require(x.numerator != 0);\n    return Fraction(x.denominator, x.numerator);\n  }\n\n  /**\n   * @dev Returns a fraction that is the fraction divided by a fraction.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x / y\n   */\n  function div(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    require(y.numerator != 0);\n    return Fraction(x.numerator.mul(y.denominator), x.denominator.mul(y.numerator));\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is greater than fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x > y\n   */\n  function isGreaterThan(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) > y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is greater than or equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x >= y\n   */\n  function isGreaterThanOrEqualTo(Fraction memory x, Fraction memory y)\n    internal\n    pure\n    returns (bool)\n  {\n    return x.numerator.mul(y.denominator) >= y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is less than fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x < y\n   */\n  function isLessThan(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) < y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is less than or equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x <= y\n   */\n  function isLessThanOrEqualTo(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) <= y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"z\" is between fractions \"x\" and \"y\".\n   * @param z A Fraction struct.\n   * @param x A Fraction struct representing a rate lower than \"y\".\n   * @param y A Fraction struct representing a rate higher than \"x\".\n   * @return x <= z <= y\n   */\n  function isBetween(Fraction memory z, Fraction memory x, Fraction memory y)\n    internal\n    pure\n    returns (bool)\n  {\n    return isLessThanOrEqualTo(x, z) && isLessThanOrEqualTo(z, y);\n  }\n}"
    }
  ]
}