{
  "Title": "[M-03] Offchain name resolution would fail despite the located DNS resolver being fully functional",
  "Content": "\nIn OffchainDNSResolver, `resolveCallback` parses resource  records received off-chain and extracts the DNS resolver address:\n\n    \t\t// Look for a valid ENS-DNS TXT record\n    \t\t(address dnsresolver, bytes memory context) = parseRR(\n    \t\t\titer.data,\n    \t\t\titer.rdataOffset,\n    \t\t\titer.nextOffset\n    \t\t);\n\nThe contract supports three methods of resolution through the resolver:\n\n1.  IExtendedDNSResolver.resolve\n2.  IExtendedResolver.resolve\n3.  Arbitrary call with the `query` parameter originating in `resolve()`\n\nCode is below:\n\n                // If we found a valid record, try to resolve it\n                if (dnsresolver != address(0)) {\n                    if (\n                        IERC165(dnsresolver).supportsInterface(\n                            IExtendedDNSResolver.resolve.selector\n                        )\n                    ) {\n                        return\n                            IExtendedDNSResolver(dnsresolver).resolve(\n                                name,\n                                query,\n                                context\n                            );\n                    } else if (\n                        IERC165(dnsresolver).supportsInterface(\n                            IExtendedResolver.resolve.selector\n                        )\n                    ) {\n                        return IExtendedResolver(dnsresolver).resolve(name, query);\n                    } else {\n                        (bool ok, bytes memory ret) = address(dnsresolver)\n                            .staticcall(query);\n                        if (ok) {\n                            return ret;\n                        } else {\n                            revert CouldNotResolve(name);\n                        }\n                    }\n                }\n\nThe issue is that a resolver could support option (3), but execution would revert prior to the `query` call. The function uses `supportsInterface` in an unsafe way. It should first check that the contract implements ERC165, which will guarantee the call won't revert. Dynamic resolvers are not likely in practice to implement ERC165 as there's no specific signature to support ahead of time.\n\n### Impact\n\nResolution with custom DNS resolvers are likely to fail.\n\n### Recommended Mitigation Steps\n\nUse the OZ `ERC165Checker.sol` library, which [addresses](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f959d7e4e6ee0b022b41e5b644c79369869d8411/contracts/utils/introspection/ERC165Checker.sol#L36) the issue:\n\n        function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n            // query support of both ERC165 as per the spec and support of _interfaceId\n            return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n        }\n\n**[Arachnid (ENS) disputed and commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1536257482):**\n > ERC165 support is required in order to be a valid resolver. Any resolver that doesn't support it is incorrectly implemented.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1539812287):**\n > This is easy to protect against. Issue stands.\n\n**[Arachnid (ENS) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1540226929):**\n > There's no point building a protection for this; either way the result is a failed resolution.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1545645183):**\n > The OZ implementation would guarantee that the else clause gets triggered and the error returned is understandable / sane. In this case, a very simple fix will significantly enhance the composability of the protocol and improve the experience of dev users.\n\n**[Arachnid (ENS) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1548256807):**\n > I continue to disagree this is an issue. ERC165 support is a baseline requirement for a resolver; checking it's supported is a pointless waste of gas.\n\n**[IllIllI (warden) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/256#issuecomment-1551319058):**\n > https://github.com/code-423n4/2023-04-ens/blob/83836eff1975fb47dae6b0982afd0b00294165cf/contracts/utils/UniversalResolver.sol#L498-L510 this code shows that at least in other areas, the possibility failure is acknowledged and handled.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/utils/introspection/ERC165Checker.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}"
    },
    {
      "filename": "contracts/utils/UniversalResolver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {LowLevelCallUtils} from \"./LowLevelCallUtils.sol\";\nimport {ENS} from \"../registry/ENS.sol\";\nimport {IExtendedResolver} from \"../resolvers/profiles/IExtendedResolver.sol\";\nimport {Resolver, INameResolver, IAddrResolver} from \"../resolvers/Resolver.sol\";\nimport {NameEncoder} from \"./NameEncoder.sol\";\nimport {BytesUtils} from \"../wrapper/BytesUtils.sol\";\nimport {HexUtils} from \"./HexUtils.sol\";\n\nerror OffchainLookup(\n    address sender,\n    string[] urls,\n    bytes callData,\n    bytes4 callbackFunction,\n    bytes extraData\n);\n\nstruct MulticallData {\n    bytes name;\n    bytes[] data;\n    string[] gateways;\n    bytes4 callbackFunction;\n    bool isWildcard;\n    address resolver;\n    bytes metaData;\n    bool[] failures;\n}\n\nstruct OffchainLookupCallData {\n    address sender;\n    string[] urls;\n    bytes callData;\n}\n\nstruct OffchainLookupExtraData {\n    bytes4 callbackFunction;\n    bytes data;\n}\n\ninterface BatchGateway {\n    function query(\n        OffchainLookupCallData[] memory data\n    ) external returns (bool[] memory failures, bytes[] memory responses);\n}\n\n/**\n * The Universal Resolver is a contract that handles the work of resolving a name entirely onchain,\n * making it possible to make a single smart contract call to resolve an ENS name.\n */\ncontract UniversalResolver is ERC165, Ownable {\n    using Address for address;\n    using NameEncoder for string;\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n\n    string[] public batchGatewayURLs;\n    ENS public immutable registry;\n\n    constructor(address _registry, string[] memory _urls) {\n        registry = ENS(_registry);\n        batchGatewayURLs = _urls;\n    }\n\n    function setGatewayURLs(string[] memory _urls) public onlyOwner {\n        batchGatewayURLs = _urls;\n    }\n\n    /**\n     * @dev Performs ENS name resolution for the supplied name and resolution data.\n     * @param name The name to resolve, in normalised and DNS-encoded form.\n     * @param data The resolution data, as specified in ENSIP-10.\n     * @return The result of resolving the name.\n     */\n    function resolve(\n        bytes calldata name,\n        bytes memory data\n    ) external view returns (bytes memory, address) {\n        return\n            _resolveSingle(\n                name,\n                data,\n                batchGatewayURLs,\n                this.resolveSingleCallback.selector,\n                \"\"\n            );\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes[] memory data\n    ) external view returns (bytes[] memory, address) {\n        return resolve(name, data, batchGatewayURLs);\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes memory data,\n        string[] memory gateways\n    ) external view returns (bytes memory, address) {\n        return\n            _resolveSingle(\n                name,\n                data,\n                gateways,\n                this.resolveSingleCallback.selector,\n                \"\"\n            );\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes[] memory data,\n        string[] memory gateways\n    ) public view returns (bytes[] memory, address) {\n        return\n            _resolve(name, data, gateways, this.resolveCallback.selector, \"\");\n    }\n\n    function _resolveSingle(\n        bytes calldata name,\n        bytes memory data,\n        string[] memory gateways,\n        bytes4 callbackFunction,\n        bytes memory metaData\n    ) public view returns (bytes memory, address) {\n        bytes[] memory dataArr = new bytes[](1);\n        dataArr[0] = data;\n        (bytes[] memory results, address resolver) = _resolve(\n            name,\n            dataArr,\n            gateways,\n            callbackFunction,\n            metaData\n        );\n        return (results[0], resolver);\n    }\n\n    function _resolve(\n        bytes calldata name,\n        bytes[] memory data,\n        string[] memory gateways,\n        bytes4 callbackFunction,\n        bytes memory metaData\n    ) internal view returns (bytes[] memory results, address resolverAddress) {\n        (Resolver resolver, , uint256 finalOffset) = findResolver(name);\n        resolverAddress = address(resolver);\n        if (resolverAddress == address(0)) {\n            return (results, address(0));\n        }\n\n        bool isWildcard = finalOffset != 0;\n\n        results = _multicall(\n            MulticallData(\n                name,\n                data,\n                gateways,\n                callbackFunction,\n                isWildcard,\n                resolverAddress,\n                metaData,\n                new bool[](data.length)\n            )\n        );\n    }\n\n    function reverse(\n        bytes calldata reverseName\n    ) external view returns (string memory, address, address, address) {\n        return reverse(reverseName, batchGatewayURLs);\n    }\n\n    /**\n     * @dev Performs ENS name reverse resolution for the supplied reverse name.\n     * @param reverseName The reverse name to resolve, in normalised and DNS-encoded form. e.g. b6E040C9ECAaE172a89bD561c5F73e1C48d28cd9.addr.reverse\n     * @return The resolved name, the resolved address, the reverse resolver address, and the resolver address.\n     */\n    function reverse(\n        bytes calldata reverseName,\n        string[] memory gateways\n    ) public view returns (string memory, address, address, address) {\n        bytes memory encodedCall = abi.encodeCall(\n            INameResolver.name,\n            reverseName.namehash(0)\n        );\n        (\n            bytes memory resolvedReverseData,\n            address reverseResolverAddress\n        ) = _resolveSingle(\n                reverseName,\n                encodedCall,\n                gateways,\n                this.reverseCallback.selector,\n                \"\"\n            );\n\n        return\n            getForwardDataFromReverse(\n                resolvedReverseData,\n                reverseResolverAddress,\n                gateways\n            );\n    }\n\n    function getForwardDataFromReverse(\n        bytes memory resolvedReverseData,\n        address reverseResolverAddress,\n        string[] memory gateways\n    ) internal view returns (string memory, address, address, address) {\n        string memory resolvedName = abi.decode(resolvedReverseData, (string));\n\n        (bytes memory encodedName, bytes32 namehash) = resolvedName\n            .dnsEncodeName();\n\n        bytes memory encodedCall = abi.encodeCall(IAddrResolver.addr, namehash);\n        bytes memory metaData = abi.encode(\n            resolvedName,\n            reverseResolverAddress\n        );\n        (bytes memory resolvedData, address resolverAddress) = this\n            ._resolveSingle(\n                encodedName,\n                encodedCall,\n                gateways,\n                this.reverseCallback.selector,\n                metaData\n            );\n\n        address resolvedAddress = abi.decode(resolvedData, (address));\n\n        return (\n            resolvedName,\n            resolvedAddress,\n            reverseResolverAddress,\n            resolverAddress\n        );\n    }\n\n    function resolveSingleCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (bytes memory, address) {\n        (bytes[] memory results, address resolver, , ) = _resolveCallback(\n            response,\n            extraData,\n            this.resolveSingleCallback.selector\n        );\n        return (results[0], resolver);\n    }\n\n    function resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (bytes[] memory, address) {\n        (bytes[] memory results, address resolver, , ) = _resolveCallback(\n            response,\n            extraData,\n            this.resolveCallback.selector\n        );\n        return (results, resolver);\n    }\n\n    function reverseCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (string memory, address, address, address) {\n        (\n            bytes[] memory resolvedData,\n            address resolverAddress,\n            string[] memory gateways,\n            bytes memory metaData\n        ) = _resolveCallback(\n                response,\n                extraData,\n                this.reverseCallback.selector\n            );\n\n        if (metaData.length > 0) {\n            (string memory resolvedName, address reverseResolverAddress) = abi\n                .decode(metaData, (string, address));\n            address resolvedAddress = abi.decode(resolvedData[0], (address));\n            return (\n                resolvedName,\n                resolvedAddress,\n                reverseResolverAddress,\n                resolverAddress\n            );\n        }\n\n        return\n            getForwardDataFromReverse(\n                resolvedData[0],\n                resolverAddress,\n                gateways\n            );\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IExtendedResolver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData,\n        bytes4 callbackFunction\n    )\n        internal\n        view\n        returns (bytes[] memory, address, string[] memory, bytes memory)\n    {\n        MulticallData memory multicallData;\n        multicallData.callbackFunction = callbackFunction;\n        (bool[] memory failures, bytes[] memory responses) = abi.decode(\n            response,\n            (bool[], bytes[])\n        );\n        OffchainLookupExtraData[] memory extraDatas;\n        (\n            multicallData.isWildcard,\n            multicallData.resolver,\n            multicallData.gateways,\n            multicallData.metaData,\n            extraDatas\n        ) = abi.decode(\n            extraData,\n            (bool, address, string[], bytes, OffchainLookupExtraData[])\n        );\n        require(responses.length <= extraDatas.length);\n        multicallData.data = new bytes[](extraDatas.length);\n        multicallData.failures = new bool[](extraDatas.length);\n        uint256 offchainCount = 0;\n        for (uint256 i = 0; i < extraDatas.length; i++) {\n            if (extraDatas[i].callbackFunction == bytes4(0)) {\n                // This call did not require an offchain lookup; use the previous input data.\n                multicallData.data[i] = extraDatas[i].data;\n            } else {\n                if (failures[offchainCount]) {\n                    multicallData.failures[i] = true;\n                    multicallData.data[i] = responses[offchainCount];\n                } else {\n                    multicallData.data[i] = abi.encodeWithSelector(\n                        extraDatas[i].callbackFunction,\n                        responses[offchainCount],\n                        extraDatas[i].data\n                    );\n                }\n                offchainCount = offchainCount + 1;\n            }\n        }\n\n        return (\n            _multicall(multicallData),\n            multicallData.resolver,\n            multicallData.gateways,\n            multicallData.metaData\n        );\n    }\n\n    /**\n     * @dev Makes a call to `target` with `data`. If the call reverts with an `OffchainLookup` error, wraps\n     *      the error with the data necessary to continue the request where it left off.\n     * @param target The address to call.\n     * @param data The data to call `target` with.\n     * @return offchain Whether the call reverted with an `OffchainLookup` error.\n     * @return returnData If `target` did not revert, contains the return data from the call to `target`. Otherwise, contains a `OffchainLookupCallData` struct.\n     * @return extraData If `target` did not revert, is empty. Otherwise, contains a `OffchainLookupExtraData` struct.\n     * @return result Whether the call succeeded.\n     */\n    function callWithOffchainLookupPropagation(\n        address target,\n        bytes memory data\n    )\n        internal\n        view\n        returns (\n            bool offchain,\n            bytes memory returnData,\n            OffchainLookupExtraData memory extraData,\n            bool result\n        )\n    {\n        result = LowLevelCallUtils.functionStaticCall(address(target), data);\n        uint256 size = LowLevelCallUtils.returnDataSize();\n\n        if (result) {\n            return (\n                false,\n                LowLevelCallUtils.readReturnData(0, size),\n                extraData,\n                true\n            );\n        }\n\n        // Failure\n        if (size >= 4) {\n            bytes memory errorId = LowLevelCallUtils.readReturnData(0, 4);\n            // Offchain lookup. Decode the revert message and create our own that nests it.\n            bytes memory revertData = LowLevelCallUtils.readReturnData(\n                4,\n                size - 4\n            );\n            if (bytes4(errorId) == OffchainLookup.selector) {\n                (\n                    address wrappedSender,\n                    string[] memory wrappedUrls,\n                    bytes memory wrappedCallData,\n                    bytes4 wrappedCallbackFunction,\n                    bytes memory wrappedExtraData\n                ) = abi.decode(\n                        revertData,\n                        (address, string[], bytes, bytes4, bytes)\n                    );\n                if (wrappedSender == target) {\n                    returnData = abi.encode(\n                        OffchainLookupCallData(\n                            wrappedSender,\n                            wrappedUrls,\n                            wrappedCallData\n                        )\n                    );\n                    extraData = OffchainLookupExtraData(\n                        wrappedCallbackFunction,\n                        wrappedExtraData\n                    );\n                    return (true, returnData, extraData, false);\n                }\n            } else {\n                returnData = revertData;\n                return (false, returnData, extraData, false);\n            }\n        }\n    }\n\n    /**\n     * @dev Finds a resolver by recursively querying the registry, starting at the longest name and progressively\n     *      removing labels until it finds a result.\n     * @param name The name to resolve, in DNS-encoded and normalised form.\n     * @return resolver The Resolver responsible for this name.\n     * @return namehash The namehash of the full name.\n     * @return finalOffset The offset of the first label with a resolver.\n     */\n    function findResolver(\n        bytes calldata name\n    ) public view returns (Resolver, bytes32, uint256) {\n        (\n            address resolver,\n            bytes32 namehash,\n            uint256 finalOffset\n        ) = findResolver(name, 0);\n        return (Resolver(resolver), namehash, finalOffset);\n    }\n\n    function findResolver(\n        bytes calldata name,\n        uint256 offset\n    ) internal view returns (address, bytes32, uint256) {\n        uint256 labelLength = uint256(uint8(name[offset]));\n        if (labelLength == 0) {\n            return (address(0), bytes32(0), offset);\n        }\n        uint256 nextLabel = offset + labelLength + 1;\n        bytes32 labelHash;\n        if (\n            labelLength == 66 &&\n            // 0x5b == '['\n            name[offset + 1] == 0x5b &&\n            // 0x5d == ']'\n            name[nextLabel - 1] == 0x5d\n        ) {\n            // Encrypted label\n            (labelHash, ) = bytes(name[offset + 2:nextLabel - 1])\n                .hexStringToBytes32(0, 64);\n        } else {\n            labelHash = keccak256(name[offset + 1:nextLabel]);\n        }\n        (\n            address parentresolver,\n            bytes32 parentnode,\n            uint256 parentoffset\n        ) = findResolver(name, nextLabel);\n        bytes32 node = keccak256(abi.encodePacked(parentnode, labelHash));\n        address resolver = registry.resolver(node);\n        if (resolver != address(0)) {\n            return (resolver, node, offset);\n        }\n        return (parentresolver, node, parentoffset);\n    }\n\n    function _hasExtendedResolver(\n        address resolver\n    ) internal view returns (bool) {\n        try\n            Resolver(resolver).supportsInterface{gas: 50000}(\n                type(IExtendedResolver).interfaceId\n            )\n        returns (bool supported) {\n            return supported;\n        } catch {\n            return false;\n        }\n    }\n\n    function _multicall(\n        MulticallData memory multicallData\n    ) internal view returns (bytes[] memory results) {\n        uint256 length = multicallData.data.length;\n        uint256 offchainCount = 0;\n        OffchainLookupCallData[]\n            memory callDatas = new OffchainLookupCallData[](length);\n        OffchainLookupExtraData[]\n            memory extraDatas = new OffchainLookupExtraData[](length);\n        results = new bytes[](length);\n        bool isCallback = multicallData.name.length == 0;\n        bool hasExtendedResolver = _hasExtendedResolver(multicallData.resolver);\n\n        require(\n            !multicallData.isWildcard || hasExtendedResolver,\n            \"UniversalResolver: Wildcard on non-extended resolvers is not supported\"\n        );\n\n        for (uint256 i = 0; i < length; i++) {\n            bytes memory item = multicallData.data[i];\n            bool failure = multicallData.failures[i];\n            if (failure) {\n                results[i] = item;\n                continue;\n            }\n            if (!isCallback && hasExtendedResolver) {\n                item = abi.encodeCall(\n                    IExtendedResolver.resolve,\n                    (multicallData.name, item)\n                );\n            }\n            (\n                bool offchain,\n                bytes memory returnData,\n                OffchainLookupExtraData memory extraData,\n                bool success\n            ) = callWithOffchainLookupPropagation(multicallData.resolver, item);\n\n            if (offchain) {\n                callDatas[offchainCount] = abi.decode(\n                    returnData,\n                    (OffchainLookupCallData)\n                );\n                extraDatas[i] = extraData;\n                offchainCount += 1;\n                continue;\n            }\n\n            if (success && hasExtendedResolver) {\n                // if this is a successful resolve() call, unwrap the result\n                returnData = abi.decode(returnData, (bytes));\n            }\n            results[i] = returnData;\n            extraDatas[i].data = multicallData.data[i];\n        }\n\n        if (offchainCount == 0) {\n            return results;\n        }\n\n        // Trim callDatas if offchain data exists\n        assembly {\n            mstore(callDatas, offchainCount)\n        }\n\n        revert OffchainLookup(\n            address(this),\n            multicallData.gateways,\n            abi.encodeWithSelector(BatchGateway.query.selector, callDatas),\n            multicallData.callbackFunction,\n            abi.encode(\n                multicallData.isWildcard,\n                multicallData.resolver,\n                multicallData.gateways,\n                multicallData.metaData,\n                extraDatas\n            )\n        );\n    }\n}"
    }
  ]
}