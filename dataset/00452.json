{
  "Title": "M-33: Operation residual is lost for the user of BBLeverage's and SGLLeverage's `sellCollateral()`",
  "Content": "# Issue M-33: Operation residual is lost for the user of BBLeverage's and SGLLeverage's `sellCollateral()` \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/144 \n\n## Found by \ncergyk, hyh\n## Summary\n\n`sellCollateral()` sells the specified amount of collateral, then repays the debt. The proceedings can cover the debt with some excess amount. Moreover, as the market swaps are involved and the actual proceedings amount isn't known in advance, while there is an over collaterization present in any healthy loan, the usual going concern situation is to sell slightly more when the goal is to pay off the debt.\n\nCurrently all the remainder of collateral sale will be left with the contract. It can be immediately stolen via `skim` option.\n\n## Vulnerability Detail\n\nCore issue is that all sale proceeding are now stay with the contract, but remainder handling logic isn't present, so the leftover amounts, which can be arbitrary big, are lost for user and left on the contract balance.\n\nThese funds are unaccounted and can be skimmed by a back-running attacker.\n\n## Impact\n\nThere is the only prerequisite of having a material amount of extra funds from collateral sale, which can happen frequently, so the probability is medium/high. Affected funds can be arbitrary big and are lost for the user, can be stolen by any attacker immediately via back-running. \n\nLikelihood: Medium/High + Impact: High = Severity: High.\n\n## Code Snippet\n\nAll collateral sale proceedings are left with the contract instead of going to `from`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L126-L150\n\n```solidity\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        ...\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n>>      yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n```\n\nLeverageExecutors return the whole proceedings to sender, i.e. SGL or BB contract:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/AssetTotsDaiLeverageExecutor.sol#L91-L92\n\n```solidity\n        assetAmountOut = _swapAndTransferToSender(true, daiAddress, assetAddress, obtainedDai, swapData.swapperData);\n    }\n```\n\nPreviously it remained with `from` (the code is from the old snapshot):\n\nhttps://github.com/Tapioca-DAO/Tapioca-bar/blob/f15aa5143f3435b6efbcc19419d1a3b1d1388bdb/contracts/markets/leverage/AssetToRethLeverageExecutor.sol#L108-L114\n\n```\n        yieldBox.depositAsset(\n            collateralId,\n            address(this),\n>>          from,\n            collateralAmountOut,\n            0\n        );\n```\n\nSo in the current implementation assets are left with the contract and `memoryData.shareOut - memoryData.shareOwed` residual will be removed from and not reimbursed to the `from`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L144-L161\n\n```solidity\n>>      amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n>>      yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n>>      if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n```\n\nThese funds will be frozen with the contract as the system accounting isn't updated either to reflect injection of `memoryData.shareOut - memoryData.shareOwed` amount of `asset`.\n\nThis way anyone can steal them via `skim` option:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBCommon.sol#L128-L138\n\n```solidity\n    function _addTokens(address from, uint256 _tokenId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n>>          require(share <= yieldBox.balanceOf(address(this), _tokenId) - total, \"BB: too much\");\n        } else {\n            // yieldBox.transfer(from, address(this), _tokenId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _tokenId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLCommon.sol#L165-L177\n\n```solidity\n    function _addTokens(address from, address, uint256 _assetId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n>>          if (share > yieldBox.balanceOf(address(this), _assetId) - total) {\n                revert TooMuch();\n            }\n        } else {\n            // yieldBox.transfer(from, address(this), _assetId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _assetId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider sending back (via `yieldBox.depositAsset`) the `memoryData.shareOut - memoryData.shareOwed` amount to the operating user.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**WangAudit** commented:\n> looks like design decision\n\n\n\n**nevillehuang**\n\n@cryptotechmaker This seems like medium. I think the excess wouldn't be material enough to consider high given it is also users responsibility to input a reasonable amount to repay shares\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/369.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLendingCommon} from \"./BBLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLeverage is BBLendingCommon {\n    using RebaseLibrary for Rebase;\n    using SafeApprove for address;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    struct _BuyCollateralMemoryData {\n        uint256 supplyShareToAmount;\n        uint256 borrowShareToAmount;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        _BuyCollateralMemoryData memory memoryData;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        {\n            uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n            if (supplyShare > 0) {\n                (memoryData.supplyShareToAmount,) =\n                    yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n            }\n        }\n\n        {\n            (, uint256 borrowShare) = _borrow(\n                calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralMemoryData {\n        uint256 obtainedShare;\n        uint256 leverageAmount;\n        uint256 shareOut;\n        uint256 partOwed;\n        uint256 amountOwed;\n        uint256 shareOwed;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/leverage/AssetTotsDaiLeverageExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//interfaces\nimport {ISavingsDai} from \"tapioca-periph/interfaces/external/makerdao/ISavingsDai.sol\";\nimport {BaseLeverageExecutor, SLeverageSwapData} from \"./BaseLeverageExecutor.sol\";\nimport {IZeroXSwapper} from \"tapioca-periph/interfaces/periph/IZeroXSwapper.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract AssetTotsDaiLeverageExecutor is BaseLeverageExecutor {\n    using SafeApprove for address;\n\n    constructor(IZeroXSwapper _swapper, ICluster _cluster) BaseLeverageExecutor(_swapper, _cluster) {}\n\n    // ********************* //\n    // *** PUBLIC METHODS *** //\n    // ********************* //\n\n    /**\n     * @dev USDO > DAI > sDAi > wrap to tsDai\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenInToft to be false. Does the unwrapping internally.\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenOutToft to be false. Does the wrapping internally.\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getCollateral(address assetAddress, address collateralAddress, uint256 assetAmountIn, bytes calldata data)\n        external\n        payable\n        override\n        returns (uint256 collateralAmountOut)\n    {\n        if (msg.value > 0) revert NativeNotSupported();\n\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n\n        //retrieve addresses\n        (address sDaiAddress, address daiAddress) = _getAddresses(collateralAddress);\n\n        //swap USDO (asset) with DAI\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n        uint256 daiAmount =\n            _swapAndTransferToSender(false, assetAddress, daiAddress, assetAmountIn, swapData.swapperData);\n\n        //obtain sDai\n        daiAddress.safeApprove(sDaiAddress, daiAmount);\n        collateralAmountOut = ISavingsDai(sDaiAddress).deposit(daiAmount, address(this));\n\n        // Wrap into tsDai to sender\n        sDaiAddress.safeApprove(collateralAddress, collateralAmountOut);\n        ITOFT(collateralAddress).wrap(address(this), msg.sender, collateralAmountOut);\n        sDaiAddress.safeApprove(collateralAddress, 0);\n    }\n\n    /**\n     * @dev unwrap tsDai > withdraw sDai > Dai > USDO\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenInToft to be false. Does the unwrapping internally.\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenOutToft to be false. Does the wrapping internally.\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getAsset(address collateralAddress, address assetAddress, uint256 collateralAmountIn, bytes calldata data)\n        external\n        override\n        returns (uint256 assetAmountOut)\n    {\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n\n        //retrieve addresses\n        (address sDaiAddress, address daiAddress) = _getAddresses(collateralAddress);\n        //unwrap tsDai\n        ITOFT(collateralAddress).unwrap(address(this), collateralAmountIn);\n        //redeem from sDai\n        uint256 obtainedDai = ISavingsDai(sDaiAddress).redeem(collateralAmountIn, address(this), address(this));\n        // swap DAI with USDO, and transfer to sender\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n        // If sendBack true and swapData.swapperData.toftInfo.isTokenOutToft false\n        // The asset will be transfer via IERC20 transfer.\n        assetAmountOut = _swapAndTransferToSender(true, daiAddress, assetAddress, obtainedDai, swapData.swapperData);\n    }\n\n    // ********************** //\n    // *** PRIVATE METHODS *** //\n    // ********************** //\n\n    /**\n     * @dev retrieve sDai and Dai addresses from tsDai\n     */\n    function _getAddresses(address collateralAddress) private view returns (address sDaiAddress, address daiAddress) {\n        //retrieve sDAI address from tsDai\n        sDaiAddress = ITOFT(collateralAddress).erc20();\n        if (sDaiAddress == address(0)) revert TokenNotValid();\n\n        //retrieve DAI address from sDAI\n        daiAddress = ISavingsDai(sDaiAddress).dai();\n    }\n}"
    },
    {
      "filename": "contracts/markets/leverage/AssetToRethLeverageExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//interfaces\nimport {ITapiocaOFTBase} from \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\nimport \"tapioca-periph/contracts/interfaces/IBalancerVault.sol\";\n\nimport \"./BaseLeverageExecutor.sol\";\n\n//Asset > WETH > trETH through BalancerV2\ncontract AssetToRethLeverageExecutor is BaseLeverageExecutor {\n    address public immutable weth;\n    IBalancerVault public vault;\n    bytes32 public poolId; //0xade4a71bb62bec25154cfc7e6ff49a513b491e81000000000000000000000497\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error SenderNotValid();\n    error TokenNotValid();\n    error NotEnough(address token);\n    error Failed();\n\n    constructor(\n        YieldBox _yb,\n        ISwapper _swapper,\n        ICluster _cluster,\n        address _weth,\n        address _balancerVault,\n        bytes32 _balancerPoolId\n    ) BaseLeverageExecutor(_yb, _swapper, _cluster) {\n        weth = _weth;\n        vault = IBalancerVault(_balancerVault);\n        poolId = _balancerPoolId;\n    }\n\n    // ********************* //\n    // *** PUBLIC MEHODS *** //\n    // ********************* //\n    /// @notice buys collateral with asset\n    /// @dev USDO > ETH > wrap to trETH\n    /// `data` params needs the following `(uint256, bytes, uint256)`\n    ///     - min WETH amount (for swapping Asset to Weth), dexWethData (for swapping Asset to Weth; it can be empty), minREthAmount for swapping WETH with rETH on Balancer V2\n    /// @param collateralId Collateral's YieldBox id\n    /// @param assetAddress usually USDO address\n    /// @param collateralAddress tETH address (TOFT ETH)\n    /// @param assetAmountIn amount to swap\n    /// @param from collateral receiver\n    /// @param data AssetToRethLeverageExecutor data\n    function getCollateral(\n        uint256 collateralId,\n        address assetAddress,\n        address collateralAddress,\n        uint256 assetAmountIn,\n        address from,\n        bytes calldata data\n    ) external payable override returns (uint256 collateralAmountOut) {\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n        _assureSwapperValidity();\n\n        //decode data\n        (\n            uint256 minWethAmount,\n            bytes memory dexWEthData,\n            uint256 minRethAmount\n        ) = abi.decode(data, (uint256, bytes, uint256));\n\n        //swap Asset with WETH\n        uint256 wethAmount = _swapTokens(\n            assetAddress,\n            weth,\n            assetAmountIn,\n            minWethAmount,\n            dexWEthData,\n            0\n        );\n        if (wethAmount < minWethAmount) revert NotEnough(weth);\n\n        //verify rETH\n        address rEth = ITapiocaOFTBase(collateralAddress).erc20();\n        if (rEth == address(0)) revert TokenNotValid();\n\n        //Swap WETH with rETH on BalancerV2\n        IERC20(weth).approve(address(vault), 0);\n        IERC20(weth).approve(address(vault), wethAmount);\n        collateralAmountOut = _swap(\n            weth,\n            rEth,\n            wethAmount,\n            minRethAmount,\n            block.timestamp + 10 minutes\n        );\n\n        //wrap and transfer to user\n        IERC20(rEth).approve(collateralAddress, 0);\n        IERC20(rEth).approve(collateralAddress, collateralAmountOut);\n        ITapiocaOFTBase(collateralAddress).wrap(\n            address(this),\n            address(this),\n            collateralAmountOut\n        );\n\n        IERC20(collateralAddress).approve(address(yieldBox), 0);\n        IERC20(collateralAddress).approve(\n            address(yieldBox),\n            collateralAmountOut\n        );\n        yieldBox.depositAsset(\n            collateralId,\n            address(this),\n            from,\n            collateralAmountOut,\n            0\n        );\n    }\n\n    /// @notice buys asset with collateral\n    /// @dev unwrap trETH > ETH > USDO\n    /// `data` params needs the following `(uint256, uint256, bytes)`\n    ///     - min WETH amount (for swapping rETH to Weth on Balancer V2), minAssetAmount (for swapping Weth with Asset), dexAssetData (for swapping Weth to Asset; it can be empty)\n    /// @param assetId Asset's YieldBox id; usually USDO asset id\n    /// @param collateralAddress trETH address (TOFT rETH)\n    /// @param assetAddress usually USDO address\n    /// @param collateralAmountIn amount to swap\n    /// @param from collateral receiver\n    /// @param data AssetToRethLeverageExecutor data\n    function getAsset(\n        uint256 assetId,\n        address collateralAddress,\n        address assetAddress,\n        uint256 collateralAmountIn,\n        address from,\n        bytes calldata data\n    ) external override returns (uint256 assetAmountOut) {\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n        _assureSwapperValidity();\n\n        //decode data\n        (\n            uint256 minWethAmount,\n            uint256 minAssetAmount,\n            bytes memory dexAssetData\n        ) = abi.decode(data, (uint256, uint256, bytes));\n\n        //unwrap trETH\n        ITapiocaOFTBase(collateralAddress).unwrap(\n            address(this),\n            collateralAmountIn\n        );\n\n        //verify rETH\n        address rEth = ITapiocaOFTBase(collateralAddress).erc20();\n        if (rEth == address(0)) revert TokenNotValid();\n\n        //swap rETH with WETH\n        uint256 wethAmount = _swap(\n            rEth,\n            weth,\n            collateralAmountIn,\n            minWethAmount,\n            block.timestamp + 10 minutes\n        );\n\n        //swap WETH with Asset\n        assetAmountOut = _swapTokens(\n            weth,\n            assetAddress,\n            wethAmount,\n            minAssetAmount,\n            dexAssetData,\n            0\n        );\n        if (assetAmountOut < minAssetAmount) revert NotEnough(assetAddress);\n\n        IERC20(assetAddress).approve(address(yieldBox), 0);\n        IERC20(assetAddress).approve(address(yieldBox), assetAmountOut);\n        yieldBox.depositAsset(assetId, address(this), from, assetAmountOut, 0);\n    }\n\n    receive() external payable {}\n\n    // ********************** //\n    // *** PRIVATE MEHODS *** //\n    // ********************** //\n    function _swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amount,\n        uint256 minAmountOut,\n        uint256 deadline\n    ) private returns (uint256 collateralAmountOut) {\n        IBalancerVault.FundManagement memory fundManagement = IBalancerVault\n            .FundManagement({\n                sender: address(this),\n                fromInternalBalance: false,\n                recipient: payable(this),\n                toInternalBalance: false\n            });\n        IBalancerVault.SingleSwap memory singleSwap = IBalancerVault\n            .SingleSwap({\n                poolId: poolId,\n                kind: IBalancerVault.SwapKind.GIVEN_IN,\n                assetIn: IAsset(tokenIn),\n                assetOut: IAsset(tokenOut),\n                amount: amount,\n                userData: \"0x\"\n            });\n\n        if (tokenIn != address(0)) {\n            IERC20(tokenIn).approve(address(vault), 0);\n            IERC20(tokenIn).approve(address(vault), amount);\n        }\n\n        collateralAmountOut = vault.swap(\n            singleSwap,\n            fundManagement,\n            minAmountOut,\n            deadline\n        );\n        if (collateralAmountOut < minAmountOut) revert Failed();\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLendingCommon} from \"./BBLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLeverage is BBLendingCommon {\n    using RebaseLibrary for Rebase;\n    using SafeApprove for address;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    struct _BuyCollateralMemoryData {\n        uint256 supplyShareToAmount;\n        uint256 borrowShareToAmount;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        _BuyCollateralMemoryData memory memoryData;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        {\n            uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n            if (supplyShare > 0) {\n                (memoryData.supplyShareToAmount,) =\n                    yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n            }\n        }\n\n        {\n            (, uint256 borrowShare) = _borrow(\n                calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralMemoryData {\n        uint256 obtainedShare;\n        uint256 leverageAmount;\n        uint256 shareOut;\n        uint256 partOwed;\n        uint256 amountOwed;\n        uint256 shareOwed;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IBigBang} from \"tapioca-periph/interfaces/bar/IBigBang.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBStorage} from \"./BBStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBCommon is BBStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NotEnough();\n    error TransferFailed();\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns total market debt\n    function getTotalDebt() external view returns (uint256) {\n        return totalBorrow.elastic;\n    }\n\n    /// @notice returns the current debt rate\n    function getDebtRate() public view returns (uint256) {\n        if (isMainMarket) return penrose.bigBangEthDebtRate(); // default 0.5%\n        if (totalBorrow.elastic == 0) return minDebtRate;\n\n        uint256 _ethMarketTotalDebt = IBigBang(penrose.bigBangEthMarket()).getTotalDebt();\n        uint256 _currentDebt = totalBorrow.elastic;\n        uint256 _maxDebtPoint = (_ethMarketTotalDebt * debtRateAgainstEthMarket) / 1e18;\n\n        if (_currentDebt >= _maxDebtPoint) return maxDebtRate;\n\n        uint256 debtPercentage = (_currentDebt * DEBT_PRECISION) / _maxDebtPoint;\n        uint256 debt = ((maxDebtRate - minDebtRate) * debtPercentage) / DEBT_PRECISION + minDebtRate;\n\n        if (debt > maxDebtRate) return maxDebtRate;\n\n        return debt;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function _accrueView() internal view override returns (Rebase memory _totalBorrow) {\n        uint256 elapsedTime = block.timestamp - accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return totalBorrow;\n        }\n\n        // Calculate fees\n        _totalBorrow = totalBorrow;\n        uint256 extraAmount = (uint256(_totalBorrow.elastic) * (getDebtRate() / 31536000) * elapsedTime) / 1e18;\n        uint256 max = type(uint128).max - totalBorrowCap;\n\n        if (extraAmount > max) {\n            extraAmount = max;\n        }\n        _totalBorrow.elastic += extraAmount.toUint128();\n    }\n\n    function _accrue() internal override {\n        IBigBang.AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        //update debt rate\n        uint256 annumDebtRate = getDebtRate();\n        _accrueInfo.debtRate = (annumDebtRate / 31557600).toUint64(); //per second; account for leap years\n        _accrueInfo.lastAccrued = block.timestamp.toUint64();\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        // Calculate fees\n        uint256 extraAmount = 0;\n        extraAmount = (uint256(_totalBorrow.elastic) * _accrueInfo.debtRate * elapsedTime) / 1e18;\n\n        // cap `extraAmount` to avoid overflow risk when converting it from uint256 to uint128\n        uint256 max = type(uint128).max - totalBorrowCap;\n\n        if (extraAmount > max) {\n            extraAmount = max;\n        }\n        _totalBorrow.elastic += extraAmount.toUint128();\n\n        totalBorrow = _totalBorrow;\n        accrueInfo = _accrueInfo;\n\n        emit LogAccrue(extraAmount, _accrueInfo.debtRate);\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _tokenId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(address from, uint256 _tokenId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            require(share <= yieldBox.balanceOf(address(this), _tokenId) - total, \"BB: too much\");\n        } else {\n            // yieldBox.transfer(from, address(this), _tokenId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _tokenId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n\n    /// @notice deposits an amount to YieldBox\n    /// @param token the IERC20 token to deposit\n    /// @param to the shares receiver\n    /// @param id the IERC20 YieldBox asset id\n    /// @param amount the amount to deposit\n    function _depositAmountToYb(IERC20 token, address to, uint256 id, uint256 amount)\n        internal\n        returns (uint256 share)\n    {\n        address(token).safeApprove(address(yieldBox), amount);\n        (, share) = yieldBox.depositAsset(id, address(this), to, amount, 0);\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {ISingularity, IMarket} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {SGLStorage} from \"./SGLStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLCommon is SGLStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error TooMuch();\n    error MinLimit();\n    error TransferFailed();\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function getInterestDetails()\n        external\n        view\n        returns (ISingularity.AccrueInfo memory _accrueInfo, uint256 utilization)\n    {\n        (_accrueInfo,,,,, utilization,) = _getInterestRate();\n    }\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getInterestRate()\n        internal\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256"
    }
  ]
}