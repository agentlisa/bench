{
  "Title": "Check user balance at beginning to save gas",
  "Content": "##### Description\nFunction `_withdraw` defined at line https://github.com/convex-eth/platform/blob/754d9e700693246275b613e895b4044b63ce9ed5/contracts/contracts/Booster.sol#L309 needs to burn wrapper tokens and back LP tokens to user, for now in case if user have to sufficient wrapped tokens ```ITokenMinter(token).burn(_from,_amount)``` at line https://github.com/convex-eth/platform/blob/754d9e700693246275b613e895b4044b63ce9ed5/contracts/contracts/Booster.sol#L329 will revert transaction. In that case user will pay gas for whole operations before, so we recommend to check user's balance at the very beginning of the functions to save gas on negative scenario.\n\n##### Recommendation\nWe recommend to check user's balance at beginning of the function\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/Booster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\n\ncontract Booster{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant escrow = address(0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2);\n    address public constant registry = address(0x0000000022D53366457F9d5E68Ec105046FC4383);\n\n\n    uint256 public lockIncentive = 1000; //incentive to crv stakers\n    uint256 public stakerIncentive = 450; //incentive to native token stakers\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    uint256 public platformFee = 0; //possible fee to build treasury\n    uint256 public constant MaxFees = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public owner;\n    address public feeManager;\n    address public staker;\n    address public minter;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards;\n    address public lockRewards;\n    address public lockFees;\n    address public feeDistro;\n    address public feeToken;\n    uint256 public mintStart;\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address crvRewards;\n        address stash;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n\n    constructor(address _staker) public {\n        isShutdown = false;\n        staker = _staker;\n        owner = msg.sender;\n        voteDelegate = msg.sender;\n        feeManager = msg.sender;\n        feeDistro = address(0); //address(0xA464e6DCda8AC41e03616F95f4BC98a13b8922Dc);\n        feeToken = address(0); //address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        treasury = address(0);\n        mintStart = block.timestamp + (86400*7);\n    }\n\n\n    /// SETTER SECTION ///\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n    }\n\n    function setFeeManager(address _feeM) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeM;\n    }\n\n    function setMinter(address _minter) external {\n        require(msg.sender == owner, \"!auth\");\n        minter = _minter;\n    }\n\n    function setMintStart(uint256 _mintStart) external{\n        require(msg.sender == owner, \"!auth\");\n        mintStart = _mintStart;\n    }\n\n    function setFactories(address _rfactory, address _sfactory, address _tfactory) external {\n        require(msg.sender == owner, \"!auth\");\n        rewardFactory = _rfactory;\n        stashFactory = _sfactory;\n        tokenFactory = _tfactory;\n    }\n\n    function setVoteDelegate(address _voteDelegate) external {\n        require(msg.sender==voteDelegate, \"!auth\");\n        voteDelegate = _voteDelegate;\n    }\n\n    function setRewardContracts(address _rewards, address _stakerRewards) external {\n        require(msg.sender == owner, \"!auth\");\n        lockRewards = _rewards;\n        stakerRewards = _stakerRewards;\n    }\n\n    // Set reward token and claim contract\n    // this could change via a curve dao vote thus needs an access role to change.\n    // however to stop malicious reward contracts from being deployed,\n    // the fee reward contract is always created via the factory, and not assigned directly.\n    function setFeeInfo(address _feeDistro, address _feeToken) external {\n        require(msg.sender==feeManager, \"!auth\");\n        //require(lockRewards != address(0),\"set locker rewards first\");\n        \n        if(feeToken != _feeToken){\n            //create a new reward contract for the new token\n           lockFees = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken,lockRewards,address(this));\n        }\n\n        feeToken = _feeToken;\n        feeDistro = _feeDistro;\n    }\n\n    function setFees(uint256 _lockFees, uint256 _stakerFees, uint256 _callerFees, uint256 _platform) external{\n        require(msg.sender==feeManager, \"!auth\");\n        require(_lockFees >= 1000 && _lockFees <= 1500, \"fee range\");\n        require(_stakerFees >= 300 && _stakerFees <= 600, \"fee range\");\n        require(_callerFees >= 25 && _callerFees <= 100, \"fee range\");\n        require(_platform <= 200, \"fee range\");\n\n        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform);\n        require(total <= MaxFees, \">MaxFees\");\n        \n        lockIncentive = _lockFees;\n        stakerIncentive = _stakerFees;\n        earmarkIncentive = _callerFees;\n        platformFee = _platform;\n    }\n\n    function setTreasury(address _treasury) external {\n        require(msg.sender==feeManager, \"!auth\");\n        treasury = _treasury;\n    }\n\n    /// END SETTER SECTION ///\n\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    //add a new curve pool to the system.\n    //gauge must be on curve's registry, thus anyone can call\n    function addPool(address _swap, address _gauge, uint256 _stashVersion) external {\n        \n        //get curve's registery\n        address mainReg = IRegistry(registry).get_registry();\n        \n        //get lp token and gauge list from swap address\n        address lptoken = IRegistry(mainReg).get_lp_token(_swap);\n\n        (address[10] memory gaugeList,) = IRegistry(mainReg).get_gauges(_swap);\n\n        //confirm the gauge passed in calldata is in the list\n        //  a passed gauge address is needed if there is ever multiple gauges\n        //  as the fact that an array is returned implies.\n        bool found = false;\n        for(uint256 i = 0; i < gaugeList.length; i++){\n            if(gaugeList[i] == _gauge){\n                found = true;\n                break;\n            }\n        }\n        require(found, \"!registry\");\n\n        //now make sure this pool/gauge hasnt been added before\n        found = false;\n        for(uint256 i = 0; i < poolInfo.length; i++){\n            if(poolInfo[i].gauge == _gauge){\n                found = true;\n                break;\n            }\n        }\n        require(!found, \"already registered\");\n        \n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        address token = ITokenFactory(tokenFactory).CreateDepositToken(lptoken);\n        //create a reward contract for crv rewards\n        address newRewardPool = IRewardFactory(rewardFactory).CreateCrvRewards(pid,token);\n        //create a stash to handle extra incentives\n        address stash = IStashFactory(stashFactory).CreateStash(pid,_gauge,staker,_stashVersion);\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: lptoken,\n                token: token,\n                gauge: _gauge,\n                crvRewards: newRewardPool,\n                stash: stash\n            })\n        );\n\n        //give stashes access to rewardfactory and voteproxy\n        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards\n        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge\n        if(stash != address(0)){\n            poolInfo[pid].stash = stash;\n            IStaker(staker).setStashAccess(stash,true);\n            IRewardFactory(rewardFactory).setAccess(stash,true);\n        }\n    }\n\n    //shutdown this contract.\n    //  unstake and pull all lp tokens to this address\n    //  only allow withdrawals\n    //  claim final rewards because stashes could have tokens on them\n    //  remove stash access after final claim\n    function shutdownSystem(bool _claimRewards) external{\n        require(msg.sender == owner, \"!auth\");\n        isShutdown = true;\n\n        for(uint i=0; i < poolInfo.length; i++){\n            address token = poolInfo[i].lptoken;\n            address gauge = poolInfo[i].gauge;\n            address stash = poolInfo[i].stash;\n\n            //withdraw from gauge\n            try IStaker(staker).withdrawAll(token,gauge){\n            }catch{}\n            \n            if(_claimRewards){\n                //earmark remaining rewards\n                _earmarkRewards(i);\n            }\n\n            //remove stash rights\n            if(stash != address(0)){\n                IStaker(staker).setStashAccess(stash,false);\n            }\n        }\n    }\n\n\n    //stake coins on curve's gauge contracts via the staker account\n    function sendTokensToGauge(uint256 _pid) private {\n        address token = poolInfo[_pid].lptoken;\n        uint256 bal = IERC20(token).balanceOf(address(this));\n\n        //send to proxy to stake\n        IERC20(token).safeTransfer(staker, bal);\n\n        //stake\n        address gauge = poolInfo[_pid].gauge;\n        require(gauge != address(0),\"!gauge setting\");\n        IStaker(staker).deposit(token,gauge);\n\n        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim\n        address stash = poolInfo[_pid].stash;\n        if(stash != address(0)){\n            IStash(stash).stashRewards();\n        }\n    }\n\n    //deposit lp tokens and stake\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){\n        require(!isShutdown,\"shutdown\");\n        address lptoken = poolInfo[_pid].lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //move to curve gauge\n        sendTokensToGauge(_pid);\n\n        address token = poolInfo[_pid].token;\n        if(_stake){\n            //mint here and send to rewards on user behalf\n            ITokenMinter(token).mint(address(this),_amount);\n            address rewardContract = poolInfo[_pid].crvRewards;\n            IERC20(token).approve(rewardContract,_amount);\n            IRewards(rewardContract).stakeFor(msg.sender,_amount);\n        }else{\n            //add user balance directly\n            ITokenMinter(token).mint(msg.sender,_amount);\n        }\n\n        \n        emit Deposited(msg.sender, _pid, _amount);\n        return true;\n    }\n\n    //deposit all lp tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns(bool){\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid,balance,_stake);\n        return true;\n    }\n\n    //withdraw lp tokens\n    function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {\n        address lptoken = poolInfo[_pid].lptoken;\n        address gauge = poolInfo[_pid].gauge;\n        uint256 before = IERC20(lptoken).balanceOf(address(this));\n\n        //pull whats needed from gauge\n        //  should always be full amount unless we withdrew everything to shutdown this contract\n        if (before < _amount) {\n            IStaker(staker).withdraw(lptoken,gauge, _amount.sub(before));\n        }\n\n        //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim\n        //do not call if shutdown since stashes wont have access\n        address stash = poolInfo[_pid].stash;\n        if(stash != address(0) && !isShutdown){\n            IStash(stash).stashRewards();\n        }\n        \n        //remove lp balance\n        address token = poolInfo[_pid].token;\n        ITokenMinter(token).burn(_from,_amount);\n\n        //return lp tokens\n        IERC20(lptoken).safeTransfer(_to, _amount);\n\n        emit Withdrawn(_to, _pid, _amount);\n    }\n\n    //withdraw lp tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns(bool){\n        _withdraw(_pid,_amount,msg.sender,msg.sender);\n        return true;\n    }\n\n    //withdraw all lp tokens\n    function withdrawAll(uint256 _pid) public returns(bool){\n       // uint256 userBal = userPoolInfo[_pid][msg.sender].amount;\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n\n    //allow reward contracts to send here and withdraw to user\n    function withdrawTo(uint256 _pid, uint256 _amount, address _to) external returns(bool){\n        address rewardContract = poolInfo[_pid].crvRewards;\n        require(msg.sender == rewardContract,\"!auth\");\n\n        _withdraw(_pid,_amount,address(this),_to);\n        return true;\n    }\n\n\n    //delegate address votes on dao\n    function vote(uint256 _voteId, address _votingAddress, bool _support) external returns(bool){\n        require(msg.sender == voteDelegate, \"!auth\");\n        IStaker(staker).vote(_voteId,_votingAddress,_support);\n        return true;\n    }\n\n    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight ) external returns(bool){\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        for(uint256 i = 0; i < _gauge.length; i++){\n            IStaker(staker).voteGaugeWeight(_gauge[i],_weight[i]);\n        }\n        return true;\n    }\n\n    //claim crv and extra rewards, convert extra to crv, disperse to reward contracts\n    function _earmarkRewards(uint256 _pid) internal {\n        address gauge = poolInfo[_pid].gauge;\n\n        //claim crv\n        IStaker(staker).claimCrv(gauge);\n\n        //check if there are extra rewards\n        address stash = poolInfo[_pid].stash;\n        if(stash != address(0) && IStash(stash).canClaimRewards()){\n            //claim extra rewards\n            IStaker(staker).claimRewards(gauge);\n            //move rewards from staker to stash\n            IStash(stash).stashRewards();\n            //process extra rewards\n            IStash(stash).processStash();\n        }\n\n        //crv balance\n        uint256 crvBal = IERC20(crv).balanceOf(address(this));\n\n        if (crvBal > 0) {\n            uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);\n            uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);\n            \n            //send treasury\n            if(treasury != address(0) && treasury != address(this)){\n                //only subtract after address condition check\n                uint256 _platform = crvBal.mul(platformFee).div(FEE_DENOMINATOR);\n                crvBal = crvBal.sub(_platform);\n                IERC20(crv).safeTransfer(treasury, _platform);\n            }\n\n            //remove incentives from balance\n            crvBal = crvBal.sub(_lockIncentive).sub(_callIncentive).sub(_stakerIncentive);\n\n            //send incentives for calling\n            IERC20(crv).safeTransfer(msg.sender, _callIncentive);          \n\n            //send crv to lp provider reward contract\n            address rewardContract = poolInfo[_pid].crvRewards;\n            IERC20(crv).safeTransfer(rewardContract, crvBal);\n            IRewards(rewardContract).queueNewRewards(crvBal);\n\n            //send lockers' share of crv to reward contract\n            IERC20(crv).safeTransfer(lockRewards, _lockIncentive);\n            IRewards(lockRewards).queueNewRewards(_lockIncentive);\n\n            //send stakers's share of crv to reward contract\n            IERC20(crv).safeTransfer(stakerRewards, _stakerIncentive);\n            IRewards(stakerRewards).queueNewRewards(_stakerIncentive);\n        }\n    }\n\n    function earmarkRewards(uint256 _pid) external returns(bool){\n        // require(!isShutdown,\"shutdown\");\n        _earmarkRewards(_pid);\n        return true;\n    }\n\n    //claim fees from curve distro contract, put in lockers' reward contract\n    function earmarkFees() external returns(bool){\n       // require(!isShutdown,\"shutdown\");\n        //claim fee rewards\n        IStaker(staker).claimFees(feeDistro, feeToken);\n        //send fee rewards to reward contract\n        uint256 _balance = IERC20(feeToken).balanceOf(address(this));\n        IERC20(feeToken).safeTransfer(lockFees, _balance);\n        IRewards(lockFees).queueNewRewards(_balance);\n        return true;\n    }\n\n    //callback from reward contract when crv is received.\n    function rewardClaimed(uint256 _pid, address _address, uint256 _amount) external returns(bool){\n        address rewardContract = poolInfo[_pid].crvRewards;\n        require(msg.sender == lockRewards||msg.sender == rewardContract,\"!auth\");\n\n        if(block.timestamp >= mintStart){\n            //mint reward tokens\n            ITokenMinter(minter).mint(_address,_amount);\n        }\n        return true;\n    }\n\n}"
    }
  ]
}