{
  "Title": "[M-07] `_validateOrder` Does Not Allow Anyone To Be A Taker Of An Off-Chain Order",
  "Content": "_Submitted by leastwood_\n\nThe `EIP1271Wallet` contract intends to allow the treasury manager account to sign off-chain orders in 0x on behalf of the `TreasuryManager` contract, which holds harvested assets/`COMP` from Notional. While the `EIP1271Wallet._validateOrder` function mostly prevents the treasury manager from exploiting these orders, it does not ensure that the `takerAddress` and `senderAddress` are set to the zero address. As a result, it is possible for the manager to have sole rights to an off-chain order and due to the flexibility in `makerPrice`, the manager is able to extract value from the treasury by maximising the allowed slippage.\n\nBy setting `takerAddress` to the zero address, any user can be the taker of an off-chain order. By setting `senderAddress` to the zero address, anyone is allowed to access the exchange methods that interact with the order, including filling the order itself. Hence, these two order addresses can be manipulated by the manager to effectively restrict order trades to themselves.\n\n#### Proof of Concept\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibOrder.sol#L66>\n```solidity\naddress takerAddress;   // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n```\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250>\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L354-L374>\n\n<https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188>\n```solidity\nfunction _validateOrder(bytes memory order) private view {\n    (\n        address makerToken,\n        address takerToken,\n        address feeRecipient,\n        uint256 makerAmount,\n        uint256 takerAmount\n    ) = _extractOrderInfo(order);\n\n    // No fee recipient allowed\n    require(feeRecipient == address(0), \"no fee recipient allowed\");\n\n    // MakerToken should never be WETH\n    require(makerToken != address(WETH), \"maker token must not be WETH\");\n\n    // TakerToken (proceeds) should always be WETH\n    require(takerToken == address(WETH), \"taker token must be WETH\");\n\n    address priceOracle = priceOracles[makerToken];\n\n    // Price oracle not defined\n    require(priceOracle != address(0), \"price oracle not defined\");\n\n    uint256 slippageLimit = slippageLimits[makerToken];\n\n    // Slippage limit not defined\n    require(slippageLimit != 0, \"slippage limit not defined\");\n\n    uint256 oraclePrice = _toUint(\n        AggregatorV2V3Interface(priceOracle).latestAnswer()\n    );\n\n    uint256 priceFloor = (oraclePrice * slippageLimit) /\n        SLIPPAGE_LIMIT_PRECISION;\n\n    uint256 makerDecimals = 10**ERC20(makerToken).decimals();\n\n    // makerPrice = takerAmount / makerAmount\n    uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;\n\n    require(makerPrice >= priceFloor, \"slippage is too high\");\n}\n```\n\n#### Tools Used\n\nManual code review.\nDiscussions with Notional team.\n\n#### Recommended Mitigation Steps\n\nConsider adding `require(takerAddress == address(0), \"manager cannot set taker\");` and `require(senderAddress == address(0), \"manager cannot set sender\");` statements to `_validateOrder`. This should allow any user to fill an order and prevent the manager from restricting exchange methods to themselves.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2022-01-notional-findings/issues/152)**\n\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/152#issuecomment-1041564430):**\n > Great find, I like when wardens understand and identify issues with integrated external protocols.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-notional",
  "Code": [
    {
      "filename": "contracts/exchange-libs/contracts/src/LibOrder.sol",
      "content": "/*\n\n  Copyright 2019 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.5.9;\n\nimport \"@0x/contracts-utils/contracts/src/LibEIP712.sol\";\n\n\nlibrary LibOrder {\n\n    using LibOrder for Order;\n\n    // Hash for the EIP712 Order Schema:\n    // keccak256(abi.encodePacked(\n    //     \"Order(\",\n    //     \"address makerAddress,\",\n    //     \"address takerAddress,\",\n    //     \"address feeRecipientAddress,\",\n    //     \"address senderAddress,\",\n    //     \"uint256 makerAssetAmount,\",\n    //     \"uint256 takerAssetAmount,\",\n    //     \"uint256 makerFee,\",\n    //     \"uint256 takerFee,\",\n    //     \"uint256 expirationTimeSeconds,\",\n    //     \"uint256 salt,\",\n    //     \"bytes makerAssetData,\",\n    //     \"bytes takerAssetData,\",\n    //     \"bytes makerFeeAssetData,\",\n    //     \"bytes takerFeeAssetData\",\n    //     \")\"\n    // ))\n    bytes32 constant internal _EIP712_ORDER_SCHEMA_HASH =\n        0xf80322eb8376aafb64eadf8f0d7623f22130fd9491a221e902b713cb984a7534;\n\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\n    // An order's status is unaffected by external factors, like account balances.\n    enum OrderStatus {\n        INVALID,                     // Default value\n        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\n        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\n        FILLABLE,                    // Order is fillable\n        EXPIRED,                     // Order has already expired\n        FULLY_FILLED,                // Order is fully filled\n        CANCELLED                    // Order has been cancelled\n    }\n\n    // solhint-disable max-line-length\n    /// @dev Canonical order structure.\n    struct Order {\n        address makerAddress;           // Address that created the order.\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\n        uint256 makerFee;               // Fee paid to feeRecipient by maker when order is filled.\n        uint256 takerFee;               // Fee paid to feeRecipient by taker when order is filled.\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The leading bytes4 references the id of the asset proxy.\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The leading bytes4 references the id of the asset proxy.\n        bytes makerFeeAssetData;        // Encoded data that can be decoded by a specified proxy contract when transferring makerFeeAsset. The leading bytes4 references the id of the asset proxy.\n        bytes takerFeeAssetData;        // Encoded data that can be decoded by a specified proxy contract when transferring takerFeeAsset. The leading bytes4 references the id of the asset proxy.\n    }\n    // solhint-enable max-line-length\n\n    /// @dev Order information returned by `getOrderInfo()`.\n    struct OrderInfo {\n        OrderStatus orderStatus;                    // Status that describes order's validity and fillability.\n        bytes32 orderHash;                    // EIP712 typed data hash of the order (see LibOrder.getTypedDataHash).\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n    }\n\n    /// @dev Calculates the EIP712 typed data hash of an order with a given domain separator.\n    /// @param order The order structure.\n    /// @return EIP712 typed data hash of the order.\n    function getTypedDataHash(Order memory order, bytes32 eip712ExchangeDomainHash)\n        internal\n        pure\n        returns (bytes32 orderHash)\n    {\n        orderHash = LibEIP712.hashEIP712Message(\n            eip712ExchangeDomainHash,\n            order.getStructHash()\n        );\n        return orderHash;\n    }\n\n    /// @dev Calculates EIP712 hash of the order struct.\n    /// @param order The order structure.\n    /// @return EIP712 hash of the order struct.\n    function getStructHash(Order memory order)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = _EIP712_ORDER_SCHEMA_HASH;\n        bytes memory makerAssetData = order.makerAssetData;\n        bytes memory takerAssetData = order.takerAssetData;\n        bytes memory makerFeeAssetData = order.makerFeeAssetData;\n        bytes memory takerFeeAssetData = order.takerFeeAssetData;\n\n        // Assembly for more efficiently computing:\n        // keccak256(abi.encodePacked(\n        //     EIP712_ORDER_SCHEMA_HASH,\n        //     uint256(order.makerAddress),\n        //     uint256(order.takerAddress),\n        //     uint256(order.feeRecipientAddress),\n        //     uint256(order.senderAddress),\n        //     order.makerAssetAmount,\n        //     order.takerAssetAmount,\n        //     order.makerFee,\n        //     order.takerFee,\n        //     order.expirationTimeSeconds,\n        //     order.salt,\n        //     keccak256(order.makerAssetData),\n        //     keccak256(order.takerAssetData),\n        //     keccak256(order.makerFeeAssetData),\n        //     keccak256(order.takerFeeAssetData)\n        // ));\n\n        assembly {\n            // Assert order offset (this is an internal error that should never be triggered)\n            if lt(order, 32) {\n                invalid()\n            }\n\n            // Calculate memory addresses that will be swapped out before hashing\n            let pos1 := sub(order, 32)\n            let pos2 := add(order, 320)\n            let pos3 := add(order, 352)\n            let pos4 := add(order, 384)\n            let pos5 := add(order, 416)\n\n            // Backup\n            let temp1 := mload(pos1)\n            let temp2 := mload(pos2)\n            let temp3 := mload(pos3)\n            let temp4 := mload(pos4)\n            let temp5 := mload(pos5)\n\n            // Hash in place\n            mstore(pos1, schemaHash)\n            mstore(pos2, keccak256(add(makerAssetData, 32), mload(makerAssetData)))        // store hash of makerAssetData\n            mstore(pos3, keccak256(add(takerAssetData, 32), mload(takerAssetData)))        // store hash of takerAssetData\n            mstore(pos4, keccak256(add(makerFeeAssetData, 32), mload(makerFeeAssetData)))  // store hash of makerFeeAssetData\n            mstore(pos5, keccak256(add(takerFeeAssetData, 32), mload(takerFeeAssetData)))  // store hash of takerFeeAssetData\n            result := keccak256(pos1, 480)\n\n            // Restore\n            mstore(pos1, temp1)\n            mstore(pos2, temp2)\n            mstore(pos3, temp3)\n            mstore(pos4, temp4)\n            mstore(pos5, temp5)\n        }\n        return result;\n    }\n}"
    },
    {
      "filename": "contracts/exchange/contracts/src/MixinExchangeCore.sol",
      "content": "/*\n\n  Copyright 2019 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\npragma solidity ^0.5.9;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-utils/contracts/src/LibBytes.sol\";\nimport \"@0x/contracts-utils/contracts/src/LibRichErrors.sol\";\nimport \"@0x/contracts-utils/contracts/src/LibSafeMath.sol\";\nimport \"@0x/contracts-utils/contracts/src/Refundable.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibFillResults.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibMath.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibOrder.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibEIP712ExchangeDomain.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibExchangeRichErrors.sol\";\nimport \"./interfaces/IExchangeCore.sol\";\nimport \"./MixinAssetProxyDispatcher.sol\";\nimport \"./MixinProtocolFees.sol\";\nimport \"./MixinSignatureValidator.sol\";\n\n\ncontract MixinExchangeCore is\n    IExchangeCore,\n    Refundable,\n    LibEIP712ExchangeDomain,\n    MixinAssetProxyDispatcher,\n    MixinProtocolFees,\n    MixinSignatureValidator\n{\n    using LibOrder for LibOrder.Order;\n    using LibSafeMath for uint256;\n    using LibBytes for bytes;\n\n    /// @dev Mapping of orderHash => amount of takerAsset already bought by maker\n    /// @param 0 Order hash.\n    /// @return 0 The amount of taker asset filled.\n    mapping (bytes32 => uint256) public filled;\n\n    /// @dev Mapping of orderHash => cancelled\n    /// @param 0 Order hash.\n    /// @return 0 Whether the order was cancelled.\n    mapping (bytes32 => bool) public cancelled;\n\n    /// @dev Mapping of makerAddress => senderAddress => lowest salt an order can have in order to be fillable\n    ///      Orders with specified senderAddress and with a salt less than their epoch are considered cancelled\n    /// @param 0 Address of the order's maker.\n    /// @param 1 Address of the order's sender.\n    /// @return 0 Minimum valid order epoch.\n    mapping (address => mapping (address => uint256)) public orderEpoch;\n\n    /// @dev Cancels all orders created by makerAddress with a salt less than or equal to the targetOrderEpoch\n    ///      and senderAddress equal to msg.sender (or null address if msg.sender == makerAddress).\n    /// @param targetOrderEpoch Orders created with a salt less or equal to this value will be cancelled.\n    function cancelOrdersUpTo(uint256 targetOrderEpoch)\n        external\n        payable\n        refundFinalBalanceNoReentry\n    {\n        address makerAddress = _getCurrentContextAddress();\n        // If this function is called via `executeTransaction`, we only update the orderEpoch for the makerAddress/msg.sender combination.\n        // This allows external filter contracts to add rules to how orders are cancelled via this function.\n        address orderSenderAddress = makerAddress == msg.sender ? address(0) : msg.sender;\n\n        // orderEpoch is initialized to 0, so to cancelUpTo we need salt + 1\n        uint256 newOrderEpoch = targetOrderEpoch + 1;\n        uint256 oldOrderEpoch = orderEpoch[makerAddress][orderSenderAddress];\n\n        // Ensure orderEpoch is monotonically increasing\n        if (newOrderEpoch <= oldOrderEpoch) {\n            LibRichErrors.rrevert(LibExchangeRichErrors.OrderEpochError(\n                makerAddress,\n                orderSenderAddress,\n                oldOrderEpoch\n            ));\n        }\n\n        // Update orderEpoch\n        orderEpoch[makerAddress][orderSenderAddress] = newOrderEpoch;\n        emit CancelUpTo(\n            makerAddress,\n            orderSenderAddress,\n            newOrderEpoch\n        );\n    }\n\n    /// @dev Fills the input order.\n    /// @param order Order struct containing order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signature Proof that order has been created by maker.\n    /// @return fillResults Amounts filled and fees paid by maker and taker.\n    function fillOrder(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        public\n        payable\n        refundFinalBalanceNoReentry\n        returns (LibFillResults.FillResults memory fillResults)\n    {\n        fillResults = _fillOrder(\n            order,\n            takerAssetFillAmount,\n            signature\n        );\n        return fillResults;\n    }\n\n    /// @dev After calling, the order can not be filled anymore.\n    /// @param order Order struct containing order specifications.\n    function cancelOrder(LibOrder.Order memory order)\n        public\n        payable\n        refundFinalBalanceNoReentry\n    {\n        _cancelOrder(order);\n    }\n\n    /// @dev Gets information about an order: status, hash, and amount filled.\n    /// @param order Order to gather information on.\n    /// @return orderInfo Information about the order and its state.\n    ///         See LibOrder.OrderInfo for a complete description.\n    function getOrderInfo(LibOrder.Order memory order)\n        public\n        view\n        returns (LibOrder.OrderInfo memory orderInfo)\n    {\n        // Compute the order hash and fetch the amount of takerAsset that has already been filled\n        (orderInfo.orderHash, orderInfo.orderTakerAssetFilledAmount) = _getOrderHashAndFilledAmount(order);\n\n        // If order.makerAssetAmount is zero, we also reject the order.\n        // While the Exchange contract handles them correctly, they create\n        // edge cases in the supporting infrastructure because they have\n        // an 'infinite' price when computed by a simple division.\n        if (order.makerAssetAmount == 0) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.INVALID_MAKER_ASSET_AMOUNT;\n            return orderInfo;\n        }\n\n        // If order.takerAssetAmount is zero, then the order will always\n        // be considered filled because 0 == takerAssetAmount == orderTakerAssetFilledAmount\n        // Instead of distinguishing between unfilled and filled zero taker\n        // amount orders, we choose not to support them.\n        if (order.takerAssetAmount == 0) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.INVALID_TAKER_ASSET_AMOUNT;\n            return orderInfo;\n        }\n\n        // Validate order availability\n        if (orderInfo.orderTakerAssetFilledAmount >= order.takerAssetAmount) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.FULLY_FILLED;\n            return orderInfo;\n        }\n\n        // Validate order expiration\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp >= order.expirationTimeSeconds) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.EXPIRED;\n            return orderInfo;\n        }\n\n        // Check if order has been cancelled\n        if (cancelled[orderInfo.orderHash]) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.CANCELLED;\n            return orderInfo;\n        }\n        if (orderEpoch[order.makerAddress][order.senderAddress] > order.salt) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.CANCELLED;\n            return orderInfo;\n        }\n\n        // All other statuses are ruled out: order is Fillable\n        orderInfo.orderStatus = LibOrder.OrderStatus.FILLABLE;\n        return orderInfo;\n    }\n\n    /// @dev Fills the input order.\n    /// @param order Order struct containing order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signature Proof that order has been created by maker.\n    /// @return fillResults Amounts filled and fees paid by maker and taker.\n    function _fillOrder(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        internal\n        returns (LibFillResults.FillResults memory fillResults)\n    {\n        // Fetch order info\n        LibOrder.OrderInfo memory orderInfo = getOrderInfo(order);\n\n        // Fetch taker address\n        address takerAddress = _getCurrentContextAddress();\n\n        // Assert that the order is fillable by taker\n        _assertFillableOrder(\n            order,\n            orderInfo,\n            takerAddress,\n            signature\n        );\n\n        // Get amount of takerAsset to fill\n        uint256 remainingTakerAssetAmount = order.takerAssetAmount.safeSub(orderInfo.orderTakerAssetFilledAmount);\n        uint256 takerAssetFilledAmount = LibSafeMath.min256(takerAssetFillAmount, remainingTakerAssetAmount);\n\n        // Compute proportional fill amounts\n        fillResults = LibFillResults.calculateFillResults(\n            order,\n            takerAssetFilledAmount,\n            protocolFeeMultiplier,\n            tx.gasprice\n        );\n\n        bytes32 orderHash = orderInfo.orderHash;\n\n        // Update exchange internal state\n        _updateFilledState(\n            order,\n            takerAddress,\n            orderHash,\n            orderInfo.orderTakerAssetFilledAmount,\n            fillResults\n        );\n\n        // Settle order\n        _settleOrder(\n            orderHash,\n            order,\n            takerAddress,\n            fillResults\n        );\n\n        return fillResults;\n    }\n\n    /// @dev After calling, the order can not be filled anymore.\n    ///      Throws if order is invalid or sender does not have permission to cancel.\n    /// @param order Order to cancel. Order must be OrderStatus.FILLABLE.\n    function _cancelOrder(LibOrder.Order memory order)\n        internal\n    {\n        // Fetch current order status\n        LibOrder.OrderInfo memory orderInfo = getOrderInfo(order);\n\n        // Validate context\n        _assertValidCancel(order, orderInfo);\n\n        // Noop if order is already unfillable\n        if (orderInfo.orderStatus != LibOrder.OrderStatus.FILLABLE) {\n            return;\n        }\n\n        // Perform cancel\n        _updateCancelledState(order, orderInfo.orderHash);\n    }\n\n    /// @dev Updates state with results of a fill order.\n    /// @param order that was filled.\n    /// @param takerAddress Address of taker who filled the order.\n    /// @param orderTakerAssetFilledAmount Amount of order already filled.\n    function _updateFilledState(\n        LibOrder.Order memory order,\n        address takerAddress,\n        bytes32 orderHash,\n        uint256 orderTakerAssetFilledAmount,\n        LibFillResults.FillResults memory fillResults\n    )\n        internal\n    {\n        // Update state\n        filled[orderHash] = orderTakerAssetFilledAmount.safeAdd(fillResults.takerAssetFilledAmount);\n\n        emit Fill(\n            order.makerAddress,\n            order.feeRecipientAddress,\n            order.makerAssetData,\n            order.takerAssetData,\n            order.makerFeeAssetData,\n            order.takerFeeAssetData,\n            orderHash,\n            takerAddress,\n            msg.sender,\n            fillResults.makerAssetFilledAmount,\n            fillResults.takerAssetFilledAmount,\n            fillResults.makerFeePaid,\n            fillResults.takerFeePaid,\n            fillResults.protocolFeePaid\n        );\n    }\n\n    /// @dev Updates state with results of cancelling an order.\n    ///      State is only updated if the order is currently fillable.\n    ///      Otherwise, updating state would have no effect.\n    /// @param order that was cancelled.\n    /// @param orderHash Hash of order that was cancelled.\n    function _updateCancelledState(\n        LibOrder.Order memory order,\n        bytes32 orderHash\n    )\n        internal\n    {\n        // Perform cancel\n        cancelled[orderHash] = true;\n\n        // Log cancel\n        emit Cancel(\n            order.makerAddress,\n            order.feeRecipientAddress,\n            order.makerAssetData,\n            order.takerAssetData,\n            msg.sender,\n            orderHash\n        );\n    }\n\n    /// @dev Validates context for fillOrder. Succeeds or throws.\n    /// @param order to be filled.\n    /// @param orderInfo OrderStatus, orderHash, and amount already filled of order.\n    /// @param takerAddress Address of order taker.\n    /// @param signature Proof that the orders was created by its maker.\n    function _assertFillableOrder(\n        LibOrder.Order memory order,\n        LibOrder.OrderInfo memory orderInfo,\n        address takerAddress,\n        bytes memory signature\n    )\n        internal\n        view\n    {\n        // An order can only be filled if its status is FILLABLE.\n        if (orderInfo.orderStatus != LibOrder.OrderStatus.FILLABLE) {\n            LibRichErrors.rrevert(LibExchangeRichErrors.OrderStatusError(\n                orderInfo.orderHash,\n                LibOrder.OrderStatus(orderInfo.orderStatus)\n            ));\n        }\n\n        // Validate sender is allowed to fill this order\n        if (order.senderAddress != address(0)) {\n            if (order.senderAddress != msg.sender) {\n                LibRichErrors.rrevert(LibExchangeRichErrors.ExchangeInvalidContextError(\n                    LibExchangeRichErrors.ExchangeContextErrorCodes.INVALID_SENDER,\n                    orderInfo.orderHash,\n                    msg.sender\n                ));\n            }\n        }\n\n        // Validate taker is allowed to fill this order\n        if (order.takerAddress != address(0)) {\n            if (order.takerAddress != takerAddress) {\n                LibRichErrors.rrevert(LibExchangeRichErrors.ExchangeInvalidContextError(\n                    LibExchangeRichErrors.ExchangeContextErrorCodes.INVALID_TAKER,\n                    orderInfo.orderHash,\n                    takerAddress\n                ));\n            }\n        }\n\n        // Validate signature\n        if (!_isValidOrderWithHashSignature(\n                order,\n                orderInfo.orderHash,\n                signature\n            )\n        ) {\n            LibRichErrors.rrevert(LibExchangeRichErrors.SignatureError(\n                LibExchangeRichErrors.SignatureErrorCodes.BAD_ORDER_SIGNATURE,\n                orderInfo.orderHash,\n                order.makerAddress,\n                signature\n            ));\n        }\n    }\n\n    /// @dev Validates context for cancelOrder. Succeeds or throws.\n    /// @param order to be cancelled.\n    /// @param orderInfo OrderStatus, orderHash, and amount already filled of order.\n    function _assertValidCancel(\n        LibOrder.Order memory order,\n        LibOrder.OrderInfo memory orderInfo\n    )\n        internal\n        view\n    {\n        // Validate sender is allowed to cancel this order\n        if (order.senderAddress != address(0)) {\n            if (order.senderAddress != msg.sender) {\n                LibRichErrors.rrevert(LibExchangeRichErrors.ExchangeInvalidContextError(\n                    LibExchangeRichErrors.ExchangeContextErrorCodes.INVALID_SENDER,\n                    orderInfo.orderHash,\n                    msg.sender\n                ));\n            }\n        }\n\n        // Validate transaction signed by maker\n        address makerAddress = _getCurrentContextAddress();\n        if (order.makerAddress != makerAddress) {\n            LibRichErrors.rrevert(LibExchangeRichErrors.ExchangeInvalidContextError(\n                LibExchangeRichErrors.ExchangeContextErrorCodes.INVALID_MAKER,\n                orderInfo.orderHash,\n                makerAddress\n            ));\n        }\n    }\n\n    /// @dev Settles an order by transferring assets between counterparties.\n    /// @param orderHash The order hash.\n    /// @param order Order struct containing order specifications.\n    /// @param takerAddress Address selling takerAsset and buying makerAsset.\n    /// @param fillResults Amounts to be filled and fees paid by maker and taker.\n    function _settleOrder(\n        bytes32 orderHash,\n        LibOrder.Order memory order,\n        address takerAddress,\n        LibFillResults.FillResults memory fillResults\n    )\n        internal\n    {\n        // Transfer taker -> maker\n        _dispatchTransferFrom(\n            orderHash,\n            order.takerAssetData,\n            takerAddress,\n            order.makerAddress,\n            fillResults.takerAssetFilledAmount\n        );\n\n        // Transfer maker -> taker\n        _dispatchTransferFrom(\n            orderHash,\n            order.makerAssetData,\n            order.makerAddress,\n            takerAddress,\n            fillResults.makerAssetFilledAmount\n        );\n\n        // Transfer taker fee -> feeRecipient\n        _dispatchTransferFrom(\n            orderHash,\n            order.takerFeeAssetData,\n            takerAddress,\n            order.feeRecipientAddress,\n            fillResults.takerFeePaid\n        );\n\n        // Transfer maker fee -> feeRecipient\n        _dispatchTransferFrom(\n            orderHash,\n            order.makerFeeAssetData,\n            order.makerAddress,\n            order.feeRecipientAddress,\n            fillResults.makerFeePaid\n        );\n\n        // Pay protocol fee\n        bool didPayProtocolFee = _paySingleProtocolFee(\n            orderHash,\n            fillResults.protocolFeePaid,\n            order.makerAddress,\n            takerAddress\n        );\n\n        // Protocol fees are not paid if the protocolFeeCollector contract is not set\n        if (!didPayProtocolFee) {\n            fillResults.protocolFeePaid = 0;\n        }\n    }\n\n    /// @dev Gets the order's hash and amount of takerAsset that has already been filled.\n    /// @param order Order struct containing order specifications.\n    /// @return The typed data hash and amount filled of the order.\n    function _getOrderHashAndFilledAmount(LibOrder.Order memory order)\n        internal\n        view\n        returns (bytes32 orderHash, uint256 orderTakerAssetFilledAmount)\n    {\n        orderHash = order.getTypedDataHash(EIP712_EXCHANGE_DOMAIN_HASH);\n        orderTakerAssetFilledAmount = filled[orderHash];\n        return (orderHash, orderTakerAssetFilledAmount);\n    }\n}"
    },
    {
      "filename": "contracts/exchange/contracts/src/MixinExchangeCore.sol",
      "content": "/*\n\n  Copyright 2019 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\npragma solidity ^0.5.9;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-utils/contracts/src/LibBytes.sol\";\nimport \"@0x/contracts-utils/contracts/src/LibRichErrors.sol\";\nimport \"@0x/contracts-utils/contracts/src/LibSafeMath.sol\";\nimport \"@0x/contracts-utils/contracts/src/Refundable.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibFillResults.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibMath.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibOrder.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibEIP712ExchangeDomain.sol\";\nimport \"@0x/contracts-exchange-libs/contracts/src/LibExchangeRichErrors.sol\";\nimport \"./interfaces/IExchangeCore.sol\";\nimport \"./MixinAssetProxyDispatcher.sol\";\nimport \"./MixinProtocolFees.sol\";\nimport \"./MixinSignatureValidator.sol\";\n\n\ncontract MixinExchangeCore is\n    IExchangeCore,\n    Refundable,\n    LibEIP712ExchangeDomain,\n    MixinAssetProxyDispatcher,\n    MixinProtocolFees,\n    MixinSignatureValidator\n{\n    using LibOrder for LibOrder.Order;\n    using LibSafeMath for uint256;\n    using LibBytes for bytes;\n\n    /// @dev Mapping of orderHash => amount of takerAsset already bought by maker\n    /// @param 0 Order hash.\n    /// @return 0 The amount of taker asset filled.\n    mapping (bytes32 => uint256) public filled;\n\n    /// @dev Mapping of orderHash => cancelled\n    /// @param 0 Order hash.\n    /// @return 0 Whether the order was cancelled.\n    mapping (bytes32 => bool) public cancelled;\n\n    /// @dev Mapping of makerAddress => senderAddress => lowest salt an order can have in order to be fillable\n    ///      Orders with specified senderAddress and with a salt less than their epoch are considered cancelled\n    /// @param 0 Address of the order's maker.\n    /// @param 1 Address of the order's sender.\n    /// @return 0 Minimum valid order epoch.\n    mapping (address => mapping (address => uint256)) public orderEpoch;\n\n    /// @dev Cancels all orders created by makerAddress with a salt less than or equal to the targetOrderEpoch\n    ///      and senderAddress equal to msg.sender (or null address if msg.sender == makerAddress).\n    /// @param targetOrderEpoch Orders created with a salt less or equal to this value will be cancelled.\n    function cancelOrdersUpTo(uint256 targetOrderEpoch)\n        external\n        payable\n        refundFinalBalanceNoReentry\n    {\n        address makerAddress = _getCurrentContextAddress();\n        // If this function is called via `executeTransaction`, we only update the orderEpoch for the makerAddress/msg.sender combination.\n        // This allows external filter contracts to add rules to how orders are cancelled via this function.\n        address orderSenderAddress = makerAddress == msg.sender ? address(0) : msg.sender;\n\n        // orderEpoch is initialized to 0, so to cancelUpTo we need salt + 1\n        uint256 newOrderEpoch = targetOrderEpoch + 1;\n        uint256 oldOrderEpoch = orderEpoch[makerAddress][orderSenderAddress];\n\n        // Ensure orderEpoch is monotonically increasing\n        if (newOrderEpoch <= oldOrderEpoch) {\n            LibRichErrors.rrevert(LibExchangeRichErrors.OrderEpochError(\n                makerAddress,\n                orderSenderAddress,\n                oldOrderEpoch\n            ));\n        }\n\n        // Update orderEpoch\n        orderEpoch[makerAddress][orderSenderAddress] = newOrderEpoch;\n        emit CancelUpTo(\n            makerAddress,\n            orderSenderAddress,\n            newOrderEpoch\n        );\n    }\n\n    /// @dev Fills the input order.\n    /// @param order Order struct containing order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signature Proof that order has been created by maker.\n    /// @return fillResults Amounts filled and fees paid by maker and taker.\n    function fillOrder(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        public\n        payable\n        refundFinalBalanceNoReentry\n        returns (LibFillResults.FillResults memory fillResults)\n    {\n        fillResults = _fillOrder(\n            order,\n            takerAssetFillAmount,\n            signature\n        );\n        return fillResults;\n    }\n\n    /// @dev After calling, the order can not be filled anymore.\n    /// @param order Order struct containing order specifications.\n    function cancelOrder(LibOrder.Order memory order)\n        public\n        payable\n        refundFinalBalanceNoReentry\n    {\n        _cancelOrder(order);\n    }\n\n    /// @dev Gets information about an order: status, hash, and amount filled.\n    /// @param order Order to gather information on.\n    /// @return orderInfo Information about the order and its state.\n    ///         See LibOrder.OrderInfo for a complete description.\n    function getOrderInfo(LibOrder.Order memory order)\n        public\n        view\n        returns (LibOrder.OrderInfo memory orderInfo)\n    {\n        // Compute the order hash and fetch the amount of takerAsset that has already been filled\n        (orderInfo.orderHash, orderInfo.orderTakerAssetFilledAmount) = _getOrderHashAndFilledAmount(order);\n\n        // If order.makerAssetAmount is zero, we also reject the order.\n        // While the Exchange contract handles them correctly, they create\n        // edge cases in the supporting infrastructure because they have\n        // an 'infinite' price when computed by a simple division.\n        if (order.makerAssetAmount == 0) {\n            orderInfo.orderStatus = LibOrder.OrderStatus.INVALID_MAKER_ASSET_AMOUNT;\n            return orderInfo;\n        }\n\n        // If order.takerAssetAmount is zero, then the order will always\n        // be considered filled because 0 == takerAssetAmount == orderTakerAssetFilledAmount\n        // Instead of distinguishing between unfilled and filled zero taker"
    }
  ]
}