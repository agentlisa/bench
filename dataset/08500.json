{
  "Title": "[Nâ€‘01] Name validation is not strictly valid",
  "Content": "\nWhile the documentation does in fact [say](https://docs.ens.domains/ens-improvement-proposals/ensip-1-ens#name-syntax) that there are other validations necessary to be compatible with the legacy DNS system, it would be better to have the following function signature instead `function valid(string calldata name, bool isEnforceLegacyRules) public pure returns (bool)`, so it's clear what the caller is validating\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/ethregistrar/ETHRegistrarController.sol\n\n77       function valid(string memory name) public pure returns (bool) {\n78           return name.strlen() >= 3;\n79:      }\n\n```\n\n<https://github.com/code-423n4/2022-07-ens/blob/4dfb0e32f586bff3db486349523a93480e3ddfba/contracts/ethregistrar/ETHRegistrarController.sol#L77-L79>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-ens",
  "Code": [
    {
      "filename": "contracts/ethregistrar/ETHRegistrarController.sol",
      "content": "pragma solidity >=0.8.4;\n\nimport \"./BaseRegistrarImplementation.sol\";\nimport \"./StringUtils.sol\";\nimport \"../resolvers/Resolver.sol\";\nimport \"../registry/ReverseRegistrar.sol\";\nimport \"./IETHRegistrarController.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../wrapper/INameWrapper.sol\";\n\n/**\n * @dev A registrar controller for registering and renewing names at fixed cost.\n */\ncontract ETHRegistrarController is Ownable, IETHRegistrarController {\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper\n    ) {\n        require(_maxCommitmentAge > _minCommitmentAge);\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(string memory name, uint256 duration)\n        public\n        view\n        override\n        returns (IPriceOracle.Price memory price)\n    {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0) {\n            require(\n                resolver != address(0),\n                \"ETHRegistrarController: resolver is required when data is supplied\"\n            );\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    resolver,\n                    data,\n                    secret,\n                    reverseRecord,\n                    fuses,\n                    wrapperExpiry\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= (price.base + price.premium),\n            \"ETHRegistrarController: Not enough ether provided\"\n        );\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                fuses,\n                wrapperExpiry\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            fuses,\n            wrapperExpiry\n        );\n\n        _setRecords(resolver, keccak256(bytes(name)), data);\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(string calldata name, uint256 duration)\n        external\n        payable\n        override\n    {\n        bytes32 label = keccak256(bytes(name));\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= price.base,\n            \"ETHController: Not enough Ether provided for renewal\"\n        );\n\n        uint256 expires = base.renew(uint256(label), duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, label, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        external\n        pure\n        returns (bool)\n    {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require a valid commitment (is old enough and is committed)\n        require(\n            commitments[commitment] + minCommitmentAge <= block.timestamp,\n            \"ETHRegistrarController: Commitment is not valid\"\n        );\n\n        // If the commitment is too old, or the name is registered, stop\n        require(\n            commitments[commitment] + maxCommitmentAge > block.timestamp,\n            \"ETHRegistrarController: Commitment has expired\"\n        );\n        require(available(name), \"ETHRegistrarController: Name is unavailable\");\n\n        delete (commitments[commitment]);\n\n        require(duration >= MIN_REGISTRATION_DURATION);\n    }\n\n    function _setRecords(\n        address resolver,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        for (uint256 i = 0; i < data.length; i++) {\n            // check first few bytes are namehash\n            bytes32 txNamehash = bytes32(data[i][4:36]);\n            require(\n                txNamehash == nodehash,\n                \"ETHRegistrarController: Namehash on record do not match the name being registered\"\n            );\n            resolver.functionCall(\n                data[i],\n                \"ETHRegistrarController: Failed to set Record\"\n            );\n        }\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, \".eth\")\n        );\n    }\n}"
    }
  ]
}