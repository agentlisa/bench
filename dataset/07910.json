{
  "Title": "[M-05] `exp()` function is not accurate when `x/g` is not small",
  "Content": "\n[AdaptiveFee.sol#L70-L108](https://github.com/code-423n4/2022-09-quickswap/blob/15ea643c85ed936a92d2676a7aabf739b210af39/src/core/contracts/libraries/AdaptiveFee.sol#L70-L108)<br>\n\nThe evaluation of `exp` function will be inaccurate, and further affect the accuracy of `sigmoid()` function, eventually affecting fee calculation.<br>\nAlso the calculation takes quite a lot of gas to calculate to 8th term.\n\n### Proof of Concept\n\n`x/g` takes value between 0 to 6, but taylor expansion maintains good approximation only near 0. When `x/g` is close to 5, the error is around 7% for `exp()` and 7% for`sigmoid()` respectively. When `x/g` is close to 6, the error could go up to 15% for `exp()` and 18% for `sigmoid()`.\n\n```solidity\n// src/core/contracts/libraries/AdaptiveFee.sol\n  function exp(\n    uint256 x,\n    uint16 g,\n    uint256 gHighestDegree\n  ) internal pure returns (uint256 res) {\n    // calculating:\n    // g**8 + x * g**7 + (x**2 * g**6) / 2 + (x**3 * g**5) / 6 + (x**4 * g**4) / 24 + (x**5 * g**3) / 120 + (x**6 * g^2) / 720 + x**7 * g / 5040 + x**8 / 40320\n\n    // x**8 < 152 bits (19*8) and g**8 < 128 bits (8*16)\n    // so each summand < 152 bits and res < 155 bits\n    uint256 xLowestDegree = x;\n    res = gHighestDegree; // g**8\n\n    gHighestDegree /= g; // g**7\n    res += xLowestDegree * gHighestDegree;\n\n    gHighestDegree /= g; // g**6\n    xLowestDegree *= x; // x**2\n    res += (xLowestDegree * gHighestDegree) / 2;\n\n    gHighestDegree /= g; // g**5\n    xLowestDegree *= x; // x**3\n    res += (xLowestDegree * gHighestDegree) / 6;\n\n    gHighestDegree /= g; // g**4\n    xLowestDegree *= x; // x**4\n    res += (xLowestDegree * gHighestDegree) / 24;\n\n    gHighestDegree /= g; // g**3\n    xLowestDegree *= x; // x**5\n    res += (xLowestDegree * gHighestDegree) / 120;\n\n    gHighestDegree /= g; // g**2\n    xLowestDegree *= x; // x**6\n    res += (xLowestDegree * gHighestDegree) / 720;\n\n    xLowestDegree *= x; // x**7\n    res += (xLowestDegree * g) / 5040 + (xLowestDegree * x) / (40320);\n  }\n```\n\n### Recommended Mitigation Steps\n\nThe value of `exp(1)`, `exp(2)`, `exp(3)`, `exp(4)`, `exp(5)`, `exp(6)` can be pre-calculated and saved to constants, then be used as denominator or multiplier.\n\nFor example, to calculate `exp(3.48)`, what we can do is calculate `exp(0.48)`, and then multiply by `exp(3)`.\n\nWhen the power is less than 0.5, taylor expansion up to `x^3` can give good accuracy. `exp(0.5)` and corresponding `sigmoid()` has maximum error in the order of 2e-4 to 1e-4.\n\n**[vladyan18 (QuickSwap & StellaSwap) acknowledged and commented](https://github.com/code-423n4/2022-09-quickswap-findings/issues/202#issuecomment-1267196099):**\n > Thank you!\n> \n> Indeed, the Taylor series converges fast enough only close to zero. Tests and practice show that the current degree of accuracy is satisfactory and retains the main property - monotonous growth from volatility. However, the recommendations for gas optimization and accuracy improvement are really good.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-quickswap-findings/issues/202#issuecomment-1267798965):**\n > I am going to award this one based on the quality of the report and level of detail. While the error tolerance may be acceptable to the sponsor, I think the warden does a great job of demonstrating their point.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-09-quickswap",
  "Code": [
    {
      "filename": "src/core/contracts/libraries/AdaptiveFee.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.7.6;\n\nimport './Constants.sol';\n\n/// @title AdaptiveFee\n/// @notice Calculates fee based on combination of sigmoids\nlibrary AdaptiveFee {\n  // alpha1 + alpha2 + baseFee must be <= type(uint16).max\n  struct Configuration {\n    uint16 alpha1; // max value of the first sigmoid\n    uint16 alpha2; // max value of the second sigmoid\n    uint32 beta1; // shift along the x-axis for the first sigmoid\n    uint32 beta2; // shift along the x-axis for the second sigmoid\n    uint16 gamma1; // horizontal stretch factor for the first sigmoid\n    uint16 gamma2; // horizontal stretch factor for the second sigmoid\n    uint32 volumeBeta; // shift along the x-axis for the outer volume-sigmoid\n    uint16 volumeGamma; // horizontal stretch factor the outer volume-sigmoid\n    uint16 baseFee; // minimum possible fee\n  }\n\n  /// @notice Calculates fee based on formula:\n  /// baseFee + sigmoidVolume(sigmoid1(volatility, volumePerLiquidity) + sigmoid2(volatility, volumePerLiquidity))\n  /// maximum value capped by baseFee + alpha1 + alpha2\n  function getFee(\n    uint88 volatility,\n    uint256 volumePerLiquidity,\n    Configuration memory config\n  ) internal pure returns (uint16 fee) {\n    uint256 sumOfSigmoids = sigmoid(volatility, config.gamma1, config.alpha1, config.beta1) +\n      sigmoid(volatility, config.gamma2, config.alpha2, config.beta2);\n\n    if (sumOfSigmoids > type(uint16).max) {\n      // should be impossible, just in case\n      sumOfSigmoids = type(uint16).max;\n    }\n\n    return uint16(config.baseFee + sigmoid(volumePerLiquidity, config.volumeGamma, uint16(sumOfSigmoids), config.volumeBeta)); // safe since alpha1 + alpha2 + baseFee _must_ be <= type(uint16).max\n  }\n\n  /// @notice calculates α / (1 + e^( (β-x) / γ))\n  /// that is a sigmoid with a maximum value of α, x-shifted by β, and stretched by γ\n  /// @dev returns uint256 for fuzzy testing. Guaranteed that the result is not greater than alpha\n  function sigmoid(\n    uint256 x,\n    uint16 g,\n    uint16 alpha,\n    uint256 beta\n  ) internal pure returns (uint256 res) {\n    if (x > beta) {\n      x = x - beta;\n      if (x >= 6 * uint256(g)) return alpha; // so x < 19 bits\n      uint256 g8 = uint256(g)**8; // < 128 bits (8*16)\n      uint256 ex = exp(x, g, g8); // < 155 bits\n      res = (alpha * ex) / (g8 + ex); // in worst case: (16 + 155 bits) / 155 bits\n      // so res <= alpha\n    } else {\n      x = beta - x;\n      if (x >= 6 * uint256(g)) return 0; // so x < 19 bits\n      uint256 g8 = uint256(g)**8; // < 128 bits (8*16)\n      uint256 ex = g8 + exp(x, g, g8); // < 156 bits\n      res = (alpha * g8) / ex; // in worst case: (16 + 128 bits) / 156 bits\n      // g8 <= ex, so res <= alpha\n    }\n  }\n\n  /// @notice calculates e^(x/g) * g^8 in a series, since (around zero):\n  /// e^x = 1 + x + x^2/2 + ... + x^n/n! + ...\n  /// e^(x/g) = 1 + x/g + x^2/(2*g^2) + ... + x^(n)/(g^n * n!) + ...\n  function exp(\n    uint256 x,\n    uint16 g,\n    uint256 gHighestDegree\n  ) internal pure returns (uint256 res) {\n    // calculating:\n    // g**8 + x * g**7 + (x**2 * g**6) / 2 + (x**3 * g**5) / 6 + (x**4 * g**4) / 24 + (x**5 * g**3) / 120 + (x**6 * g^2) / 720 + x**7 * g / 5040 + x**8 / 40320\n\n    // x**8 < 152 bits (19*8) and g**8 < 128 bits (8*16)\n    // so each summand < 152 bits and res < 155 bits\n    uint256 xLowestDegree = x;\n    res = gHighestDegree; // g**8\n\n    gHighestDegree /= g; // g**7\n    res += xLowestDegree * gHighestDegree;\n\n    gHighestDegree /= g; // g**6\n    xLowestDegree *= x; // x**2\n    res += (xLowestDegree * gHighestDegree) / 2;\n\n    gHighestDegree /= g; // g**5\n    xLowestDegree *= x; // x**3\n    res += (xLowestDegree * gHighestDegree) / 6;\n\n    gHighestDegree /= g; // g**4\n    xLowestDegree *= x; // x**4\n    res += (xLowestDegree * gHighestDegree) / 24;\n\n    gHighestDegree /= g; // g**3\n    xLowestDegree *= x; // x**5\n    res += (xLowestDegree * gHighestDegree) / 120;\n\n    gHighestDegree /= g; // g**2\n    xLowestDegree *= x; // x**6\n    res += (xLowestDegree * gHighestDegree) / 720;\n\n    xLowestDegree *= x; // x**7\n    res += (xLowestDegree * g) / 5040 + (xLowestDegree * x) / (40320);\n  }\n}"
    }
  ]
}