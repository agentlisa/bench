{
  "Title": "[M-16] division rounding error in `_handleExecuteLiquidity()` and `_reconcile()` make `routerBalances` and contract fund balance to get out of sync and cause fund lose",
  "Content": "_Submitted by unforgiven, also found by xiaoming90_\n\n[BridgeFacet.sol#L753-L803](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L753-L803)<br>\n[BridgeFacet.sol#L526-L616](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L526-L616)<br>\n\nVariable `routerBalances` suppose to keep track of routers balance in contract and `routers` can withdraw their balance from contract. but because of division rounding error in `_handleExecuteLiquidity()` and `_reconcile()` contract uses more of its tokens than it subtract from router's balance. this can lead to fund lose.\n\n### Proof of Concept\n\nThis is `_handleExecuteLiquidity()` code:\n\n      /**\n       * @notice Execute liquidity process used when calling `execute`\n       * @dev Need this to prevent stack too deep\n       */\n      function _handleExecuteLiquidity(\n        bytes32 _transferId,\n        bool _isFast,\n        ExecuteArgs calldata _args\n      ) private returns (uint256, address) {\n        uint256 toSwap = _args.amount;\n\n        // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n        // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n        // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n        // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n        if (_isFast) {\n          uint256 pathLen = _args.routers.length;\n\n          // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n          toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n          // Save the addressess of all routers providing liquidity for this transfer.\n          s.routedTransfers[_transferId] = _args.routers;\n\n          // If router does not have enough liquidity, try to use Aave Portals.\n          // only one router should be responsible for taking on this credit risk, and it should only\n          // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)\n          if (\n            !_args.params.receiveLocal &&\n            pathLen == 1 &&\n            s.routerBalances[_args.routers[0]][_args.local] < toSwap &&\n            s.aavePool != address(0)\n          ) {\n            if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])\n              revert BridgeFacet__execute_notApprovedForPortals();\n\n            // Portal provides the adopted asset so we early return here\n            return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);\n          } else {\n            // for each router, assert they are approved, and deduct liquidity\n            uint256 routerAmount = toSwap / pathLen;\n            for (uint256 i; i < pathLen; ) {\n              // decrement routers liquidity\n              s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;\n\n              unchecked {\n                i++;\n              }\n            }\n          }\n        }\n\nAs you can see in last part it uses `uint256 routerAmount = toSwap / pathLen`  to calculate amount to decrease from router's balance but because of division rounding error contract using `toSwap` amount of token buy total value it decrease from router's balances are lower than `toSwap`.\n\nOf course in `_reconcile()` contract add some amount to router's balances again with division rounding error, but because the amounts are different in this two functions (in `_handleExecuteLiquidity()` we subtract fee and in `_reconcile()` we don't subtract fee) so the division rounding error would be different for them and in the end sum of total balances of routers would not be equal to contract balance. this bug could be more serious for tokens with low precision and higher price.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nPerform better calculations.\n\n**[LayneHaber (Connext) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/213#issuecomment-1166339087):**\n > The maximum fund loss in this case is capped by the maximum number of routers allowed in a transfer (this will generally be below 10, meaning maximum loss from one of these errors is 18 wei units of the token -- assuming it hit max on both execute and reconcile).\n> \n> I understand the rounding error exists, but even with tokens at a precision of 6 with a high price the maximum rounding error is small (i.e. 100K coin, 6 decimals, this amounts to $1.8). At this level of impact, this should amount to a value leak.\n\n**[0xleastwood (judge) decreased severity to QA and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/213#issuecomment-1214491119):**\n > I'm gonna downgrade this to `QA` (low risk / non-critical) because the value leak is mostly negligible and extremely hard to avoid. You could sweep the remaining balance and delegate that to the last router, but this is unfair to other routers.\n>\n > I think a good solution would be to make the last router pay the swept balance and then be reconciled this amount once the bridge transfer is complete.\n\n**[0xleastwood (judge) increased severity to Medium and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/213#issuecomment-1214748995):**\n > Actually, upon thinking about this more, I think there is potential for the system to not work as intended under certain parts of the transfer flow.\n> \n> If the bridge transfer amount is `10 DAI` and the liquidity must be provided _three_ routers, each router provides `3 DAI` respectively. If the user opted to receive the local asset than `10 DAI` will be directly sent out to them. Therefore, until the transfer has been reconciled, the protocol will essentially take on temporary bad debt which won't be resolved until the bridge transfer has been reconciled. This may limit withdrawals for other routers during this period. For these reasons, I think `medium` severity makes more sense:) \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/facets/BridgeFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only"
    }
  ]
}