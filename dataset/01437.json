{
  "Title": "Precision loss/Rounding to Zero in `_distribute()`",
  "Content": "# Precision loss/Rounding to Zero in `_distribute()`\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/Distributor.sol#L144\">https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/Distributor.sol#L144</a>\n\n\n## Summary\n\nThe identified vulnerability is associated with the `_distribute` function in \n`Distributor.sol`. In scenarios where the total token amount is low or low values are used for percentages, the function may encounter a precision issue. \nThis arises due to the division of totalAmount by `BASIS_POINTS` to calculate the distribution amount for each winner. The precision error can lead to incorrect token distribution, affecting the fairness and accuracy of rewards to winners.\n\n## Vulnerability Details\n\nThe vulnerability stems from the calculation of `amount` within the distribution loop. The formula `amount = totalAmount * percentages[i] / BASIS_POINTS` involves a division operation that could result in loss of precision(Rounding to Zero) when dealing with small `totalAmount` values or low `percentages[i]`. This imprecision can lead to token amounts being rounded down to zero, resulting in unfair or incomplete rewards for winners.\n\n### Proof Of Concept:\n\nTo simulate the vulnerability we need to make changes in the modifier \n`setUpContestForJasonAndSentJpycv2Token`:\n\nCode:\n\n```solidity\n\n\tmodifier setUpContestForJasonAndSentJpycv2Token(address _organizer) {\n        vm.startPrank(factoryAdmin);\n        bytes32 randomId = keccak256(abi.encode(\"Jason\", \"001\"));\n        proxyFactory.setContest(_organizer, randomId, block.timestamp + 8 days, address(distributor));\n        vm.stopPrank();\n        bytes32 salt = keccak256(abi.encode(_organizer, randomId, address(distributor)));\n        address proxyAddress = proxyFactory.getProxyAddress(salt, address(distributor));\n        vm.startPrank(sponsor);\n        MockERC20(jpycv2Address).transfer(proxyAddress, 10);\n        vm.stopPrank();\n        // console.log(MockERC20(jpycv2Address).balanceOf(proxyAddress));\n        // assertEq(MockERC20(jpycv2Address).balanceOf(proxyAddress), 10000 ether);\n        _;\n    }\n\n```\n\nWe change the value transferred to the `proxyAddress` to `10` tokens.\n\nNote: We are not using `10 ether` here as ether has 18 decimals which misguides the intended attack.\n\nNow, we create a function called `testPrecisionLoss()` wherein we simulate end of a contest and call the `deployProxyAndDistribute()` function. This makes use of the modified `createData()` function to send in `95` winners, each being rewarded with percentage of `100 BASIS POINTS`, which is equal to `(10000 - COMMISSION_FEE)` i.e. `9500 BASIS POINTS` thus satisfying the conditions in the `_distribute()` function and allowing distribution of funds.\n\nCode:\n```\nfunction testPrecisionLoss() public setUpContestForJasonAndSentJpycv2Token(organizer) {\n        bytes32 randomId_ = keccak256(abi.encode(\"Jason\", \"001\"));\n\n        //create data from modified createData() function\n\t\t\t\tbytes memory data = createData();\n\n        vm.startPrank(organizer);\n        console.log(\"User1 Start Balance -\", MockERC20(jpycv2Address).balanceOf(user1));\n        console.log(\"Stadium Balance Before: \",MockERC20(jpycv2Address).balanceOf(stadiumAddress));\n\n        //warping to the time where contest ends and token distribution is allowed\n\t\t\t\tvm.warp(30 days);\n\n\t\t\t\t// distributing the rewards to all 95 winners \n        proxyFactory.deployProxyAndDistribute(randomId_, address(distributor), data);\n\n        console.log(\"Stadium End Balance: \",MockERC20(jpycv2Address).balanceOf(stadiumAddress));\n        console.log(\"User1 After Balance -\", MockERC20(jpycv2Address).balanceOf(user1));\n\n        vm.stopPrank();\n    }\n```\n\nThe logs prove the existence of precision loss:\n\n```\nRunning 1 test for test/integration/ProxyFactoryTest.t.sol:ProxyFactoryTest\n[PASS] testPrecisionLoss() (gas: 892788)\nLogs:\n  0x000000000000000000000000000000000000000E\n  User1 Start Balance - 0\n  Stadium Balance Before:  0\n  Stadium End Balance:  10\n  User1 After Balance - 0\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 6.16ms\n```\n\nAs we can see, all of the balance gets transferred to the `stadiumAddress` from the contract as the `_commissionTransfer()` function declares:\n\n```\nfunction _commissionTransfer(IERC20 token) internal {\n        token.safeTransfer(STADIUM_ADDRESS, token.balanceOf(address(this)));\n    }\n```\n\nDue to the precision loss(Rounding to Zero), none of the amount gets transferred to any winners and thus, all the \"remaining tokens\" get sent to the `stadiumAddress`, thus leaving our winners - in this case, user1 - rewarded with 0 balance.\n\n## Impact\n\nThe Rounding to Zero vulnerability has the potential to undermine the intended fairness and accuracy of the reward distribution process. In scenarios where the token balance is very small or percentages are low, the distribution algorithm could yield incorrect or negligible rewards to winners. This impacts the trust and credibility of the protocol, potentially leading to user dissatisfaction and decreased participation.\n\n## Tools Used\n\nManual Review\nFoundry\nVSCode\n\n## Recommendations\n\nConsider instituting a `predefined minimum threshold` for the `percentage` amount used in the token distribution calculation. This approach ensures that the calculated distribution amount maintains a reasonable and equitable value, even when dealing with low percentages. \n\nAdditionally, an alternative strategy involves adopting a `rounding up equation` that consistently rounds the `distribution amount upward` to the nearest integer value. \n\nBy incorporating either of these methodologies, the precision vulnerability associated with small values and percentages can be effectively mitigated, resulting in more accurate and reliable token distribution outcomes.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
  "Code": [
    {
      "filename": "src/Distributor.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {ProxyFactory} from \"./ProxyFactory.sol\";\n\n/**\n * @title Distributor contract\n * @notice General ERC20 stable coin tokens, e.g. JPYC, USDC, USDT, DAI, etc, are suppsoed to be used in SPARKN.\n * @notice This contract is used as the implementation of proxy contracts to distribute ERC20 token(e.g. JPYC) to winners\n * @dev The main logic of prize token distribution sits in this contract waiting to be called by factory contract\n * @dev Although the contract is immutable after deployment, If we want to upgrade the implementation contract\n * we can deploy a new one and change the implementation address of proxy contract.\n */\ncontract Distributor {\n    using SafeERC20 for IERC20;\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n\n    error Distributor__InvalidCommissionFee();\n    error Distributor__NoZeroAddress();\n    error Distributor__OnlyFactoryAddressIsAllowed();\n    error Distributor__InvalidTokenAddress();\n    error Distributor__MismatchedArrays();\n    error Distributor__MismatchedPercentages();\n    error Distributor__NoTokenToDistribute();\n\n    //////////////////////////////////////\n    /////// Immutable Variables //////////\n    //////////////////////////////////////\n    /* solhint-disable */\n    uint8 private constant VERSION = 1; // version is 1 for now\n    address private immutable FACTORY_ADDRESS;\n    address private immutable STADIUM_ADDRESS;\n    uint256 private constant COMMISSION_FEE = 500; // this can be changed in the future\n    // a constant value of 10,000 (basis points) = 100%\n    uint256 private constant BASIS_POINTS = 10000;\n\n    // prize distribution event. data is for logging purpose\n    event Distributed(address token, address[] winners, uint256[] percentages, bytes data);\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /// @dev initiate the contract with factory address and other key addresses, fee rate\n    constructor(\n        // uint256 version, // for future use\n        address factoryAddress,\n        address stadiumAddress\n    ) \n    /* solhint-enable */\n    {\n        if (factoryAddress == address(0) || stadiumAddress == address(0)) revert Distributor__NoZeroAddress();\n        FACTORY_ADDRESS = factoryAddress; // initialize with deployed factory address beforehand\n        STADIUM_ADDRESS = stadiumAddress; // official address to receive commission fee\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Distribute token to winners according to the percentages\n     * @dev Only factory contract can call this function\n     * @param token The token address to distribute\n     * @param winners The addresses array of winners\n     * @param percentages The percentages array of winners\n     */\n    function distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        external\n    {\n        if (msg.sender != FACTORY_ADDRESS) {\n            revert Distributor__OnlyFactoryAddressIsAllowed();\n        }\n        _distribute(token, winners, percentages, data);\n    }\n\n    ////////////////////////////////////////////\n    /////// Internal & Private functions ///////\n    ////////////////////////////////////////////\n    /**\n     * @notice An internal function to distribute JPYC to winners\n     * @dev Main logic of distribution is implemented here. The length of winners and percentages must be the same\n     * The token address must be one of the whitelisted tokens\n     * The winners and percentages array are supposed not to be so long, so the loop can stay unbounded\n     * The total percentage must be correct. It must be (100 - COMMITION_FEE).\n     * Finally send the remained token(fee) to STADIUM_ADDRESS with no dust in the contract\n     * @param token The token address\n     * @param winners The addresses of winners\n     * @param percentages The percentages of winners\n     * @param data The data to be logged. It is supposed to be used for showing the realation bbetween winners and proposals.\n     */\n    function _distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        internal\n    {\n        // token address input check\n        if (token == address(0)) revert Distributor__NoZeroAddress();\n        if (!_isWhiteListed(token)) {\n            revert Distributor__InvalidTokenAddress();\n        }\n        // winners and percentages input check\n        if (winners.length == 0 || winners.length != percentages.length) revert Distributor__MismatchedArrays();\n        uint256 percentagesLength = percentages.length;\n        uint256 totalPercentage;\n        for (uint256 i; i < percentagesLength;) {\n            totalPercentage += percentages[i];\n            unchecked {\n                ++i;\n            }\n        }\n        // check if totalPercentage is correct\n        if (totalPercentage != (10000 - COMMISSION_FEE)) {\n            revert Distributor__MismatchedPercentages();\n        }\n        IERC20 erc20 = IERC20(token);\n        uint256 totalAmount = erc20.balanceOf(address(this));\n\n        // if there is no token to distribute, then revert\n        if (totalAmount == 0) revert Distributor__NoTokenToDistribute();\n\n        uint256 winnersLength = winners.length; // cache length\n        for (uint256 i; i < winnersLength;) {\n            uint256 amount = totalAmount * percentages[i] / BASIS_POINTS;\n            erc20.safeTransfer(winners[i], amount);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // send commission fee as well as all the remaining tokens to STADIUM_ADDRESS to avoid dust remaining\n        _commissionTransfer(erc20);\n        emit Distributed(token, winners, percentages, data);\n    }\n\n    /**\n     * @notice Transfer commission fee to STADIUM_ADDRESS\n     * @dev This internal function is called after distribution in `_distribute` function\n     * @param token The token address\n     */\n    function _commissionTransfer(IERC20 token) internal {\n        token.safeTransfer(STADIUM_ADDRESS, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Check if the token is whitelisted. calling FACTORY_ADDRESS\n     * @param token The token address\n     * @return true if the token is whitelisted, vice versa\n     */\n    function _isWhiteListed(address token) internal view returns (bool) {\n        return ProxyFactory(FACTORY_ADDRESS).whitelistedTokens(token);\n    }\n\n    ///////////////////////////////////////////\n    /////// Getter pure/view functions ////////\n    ///////////////////////////////////////////\n    /**\n     * @notice returns all the immutable and constant addresses and values\n     * @dev This function is for convenience to check the addresses and values\n     */\n    function getConstants()\n        external\n        view\n        returns (address _FACTORY_ADDRESS, address _STADIUM_ADDRESS, uint256 _COMMISSION_FEE, uint8 _VERSION)\n    {\n        /* solhint-disable */\n        _FACTORY_ADDRESS = FACTORY_ADDRESS;\n        _STADIUM_ADDRESS = STADIUM_ADDRESS;\n        _COMMISSION_FEE = COMMISSION_FEE;\n        _VERSION = VERSION;\n        /* solhint-enable */\n    }\n}"
    }
  ]
}