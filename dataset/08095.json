{
  "Title": "[M-21] Truncation in casting can lead to a founder receiving all the base tokens",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L71-L126\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L88\n\n\n# Vulnerability details\n\n## Impact\nThe initialize function of the `Token` contract receives an array of `FounderParams`, which contains the ownership percent of each founder as a `uint256`. The initialize function checks that the sum of the percents is not more than 100, but the value that is added to the sum of the percent is truncated to fit in `uint8`. This leads to an error because the value that is used for assigning the base tokens is the original, not truncated, `uint256` value.\n\nThis can lead to wrong assignment of the base tokens, and can also lead to a situation where not all the users will get the correct share of base tokens (if any).\n\n## Proof of Concept\nTo verify this bug I created a foundry test. You can add it to the test folder and run it with `forge test --match-test testFounderGettingAllBaseTokensBug`.\n\nThis test deploys a token implementation and an `ERC1967` proxy that points to it, and initializes the proxy using an array of 2 founders, each having 256 ownership percent. The value which is added to the `totalOwnership` variable is a `uint8`, and when truncating 256 to fit in a `uint8` it will turn to 0, so this check will pass.\n\nAfter the call to initialize, the test asserts that all the base token ids belongs to the first founder, which means the second founder didn't get any base tokens at all.\n\nWhat actually happens here is that the first founder gets the first 256 token ids, and the second founder gets the next 256 token ids, but because the base token is calculated % 100, only the first 100 matters and they will be owned by the first owner.\n\nThis happens because `schedule`, which is equal to `100 / founderPct`, will be zero (`100 / 256 == 0` due to uint div operation), and the base token id won't be updated in `(baseTokenId += schedule) % 100` (this line contains another mistake, which will be reported in another finding). The place where it will be updated is in the `_getNextTokenId`, where it will be incremented by 1.\n\nThis exploit can work as long as the sum of the percents modulo 256 (truncation to `uint8`) is not more than 100.\n\n```sol\n// The relative path of this file is \"test/FounderGettingAllBaseTokensBug.t.sol\"\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { IManager } from \"../src/manager/Manager.sol\";\nimport { IToken, Token } from \"../src/token/Token.sol\";\n\nimport { TokenTypesV1 } from \"../src/token/types/TokenTypesV1.sol\";\n\nimport { ERC1967Proxy } from \"../src/lib/proxy/ERC1967Proxy.sol\";\n\ncontract FounderGettingAllBaseTokensBug is Test, TokenTypesV1 {\n\n    Token imp;\n    address proxy;\n    \n    function setUp() public virtual {\n        // Deploying the implementation and the proxy\n        imp = new Token(address(this));\n        proxy = address(new ERC1967Proxy(address(imp), \"\"));\n    }\n\n    function testFounderGettingAllBaseTokensBug() public {\n\n        IToken token = IToken(proxy);\n\n        address chadFounder = address(0xdeadbeef);\n        address betaFounder = address(0xBBBBBBBB); // beta\n\n        // Creating 2 founders with `ownershipPct = 256`\n        IManager.FounderParams[] memory founders = new IManager.FounderParams[](2);\n        founders[0] = IManager.FounderParams({\n            wallet: chadFounder,\n            ownershipPct: 256,\n            vestExpiry: 1 weeks\n        });\n        founders[1] = IManager.FounderParams({\n            wallet: betaFounder,\n            ownershipPct: 256,\n            vestExpiry: 1 weeks\n        });\n\n        // Initializing the proxy with the founders data\n        token.initialize(   \n            founders, \n            // we don't care about these\n            abi.encode(\"\", \"\", \"\", \"\", \"\"),\n            address(0),\n            address(0)\n        );\n\n        // Asserting that the chad founder got all the base token ids\n        // (`tokenId % 100` is calculated to get the base token, so it is enough to check only the first 100 token ids)\n        for (uint i; i < 100; ++i) {\n            assertEq(token.getScheduledRecipient(i).wallet == chadFounder, true);\n        }\n\n        // Run with `forge test --match-test testFounderGettingAllBaseTokensBug`\n        // Results:\n        //      [PASS] testFounderGettingAllBaseTokensBug() (gas: 13537465)\n        // Great success\n    }\n```\n\n## Tools Used\nManual audit & foundry for the PoC\n\n## Recommended Mitigation Steps\nDon't truncate the `founderPct` variable to a uint8 when adding it to the totalOwnership variable, or alternatively check that it is less than `type(uint8).max` (or less or equal to 100).\nAfter applying this fix and running the test again, the result is:\n```\n[FAIL. Reason: INVALID_FOUNDER_OWNERSHIP()] testFounderGettingAllBaseTokensBug() (gas: 58674)\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-nouns-builder-contest",
  "Code": [
    {
      "filename": "src/token/Token.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { ERC721Votes } from \"../lib/token/ERC721Votes.sol\";\nimport { ERC721 } from \"../lib/token/ERC721.sol\";\n\nimport { TokenStorageV1 } from \"./storage/TokenStorageV1.sol\";\nimport { IBaseMetadata } from \"./metadata/interfaces/IBaseMetadata.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IToken } from \"./IToken.sol\";\n\n/// @title Token\n/// @author Rohan Kulkarni\n/// @notice A DAO's ERC-721 governance token\ncontract Token is IToken, UUPS, ReentrancyGuard, ERC721Votes, TokenStorageV1 {\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token contract\n    /// @param _founders The DAO founders\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _metadataRenderer The token's metadata renderer\n    /// @param _auction The token's auction house\n    function initialize(\n        IManager.FounderParams[] calldata _founders,\n        bytes calldata _initStrings,\n        address _metadataRenderer,\n        address _auction\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Store the founders and compute their allocations\n        _addFounders(_founders);\n\n        // Decode the token name and symbol\n        (string memory _name, string memory _symbol, , , ) = abi.decode(_initStrings, (string, string, string, string, string));\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_name, _symbol);\n\n        // Store the metadata renderer and auction house\n        settings.metadataRenderer = IBaseMetadata(_metadataRenderer);\n        settings.auction = _auction;\n    }\n\n    /// @dev Called upon initialization to add founders and compute their vesting allocations\n    /// @param _founders The list of DAO founders\n    function _addFounders(IManager.FounderParams[] calldata _founders) internal {\n        // Cache the number of founders\n        uint256 numFounders = _founders.length;\n\n        // Used to store the total percent ownership among the founders\n        uint256 totalOwnership;\n\n        unchecked {\n            // For each founder:\n            for (uint256 i; i < numFounders; ++i) {\n                // Cache the percent ownership\n                uint256 founderPct = _founders[i].ownershipPct;\n\n                // Continue if no ownership is specified\n                if (founderPct == 0) continue;\n\n                // Update the total ownership and ensure it's valid\n                if ((totalOwnership += uint8(founderPct)) > 100) revert INVALID_FOUNDER_OWNERSHIP();\n\n                // Compute the founder's id\n                uint256 founderId = settings.numFounders++;\n\n                // Get the pointer to store the founder\n                Founder storage newFounder = founder[founderId];\n\n                // Store the founder's vesting details\n                newFounder.wallet = _founders[i].wallet;\n                newFounder.vestExpiry = uint32(_founders[i].vestExpiry);\n                newFounder.ownershipPct = uint8(founderPct);\n\n                // Compute the vesting schedule\n                uint256 schedule = 100 / founderPct;\n\n                // Used to store the base token id the founder will recieve\n                uint256 baseTokenId;\n\n                // For each token to vest:\n                for (uint256 j; j < founderPct; ++j) {\n                    // Get the available token id\n                    baseTokenId = _getNextTokenId(baseTokenId);\n\n                    // Store the founder as the recipient\n                    tokenRecipient[baseTokenId] = newFounder;\n\n                    emit MintScheduled(baseTokenId, founderId, newFounder);\n\n                    // Update the base token id\n                    (baseTokenId += schedule) % 100;\n                }\n            }\n\n            // Store the founders' details\n            settings.totalOwnership = uint8(totalOwnership);\n            settings.numFounders = uint8(numFounders);\n        }\n    }\n\n    /// @dev Finds the next available base token id for a founder\n    /// @param _tokenId The ERC-721 token id\n    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n        unchecked {\n            while (tokenRecipient[_tokenId].wallet != address(0)) ++_tokenId;\n\n            return _tokenId;\n        }\n    }\n\n    ///                                                          ///\n    ///                             MINT                         ///\n    ///                                                          ///\n\n    /// @notice Mints tokens to the auction house for bidding and handles founder vesting\n    function mint() external nonReentrant returns (uint256 tokenId) {\n        // Cache the auction address\n        address minter = settings.auction;\n\n        // Ensure the caller is the auction\n        if (msg.sender != minter) revert ONLY_AUCTION();\n\n        // Cannot realistically overflow\n        unchecked {\n            do {\n                // Get the next token to mint\n                tokenId = settings.totalSupply++;\n\n                // Lookup whether the token is for a founder, and mint accordingly if so\n            } while (_isForFounder(tokenId));\n        }\n\n        // Mint the next available token to the auction house for bidding\n        _mint(minter, tokenId);\n    }\n\n    /// @dev Overrides _mint to include attribute generation\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal override {\n        // Mint the token\n        super._mint(_to, _tokenId);\n\n        // Generate the token attributes\n        if (!settings.metadataRenderer.onMinted(_tokenId)) revert NO_METADATA_GENERATED();\n    }\n\n    /// @dev Checks if a given token is for a founder and mints accordingly\n    /// @param _tokenId The ERC-721 token id\n    function _isForFounder(uint256 _tokenId) private returns (bool) {\n        // Get the base token id\n        uint256 baseTokenId = _tokenId % 100;\n\n        // If there is no scheduled recipient:\n        if (tokenRecipient[baseTokenId].wallet == address(0)) {\n            return false;\n\n            // Else if the founder is still vesting:\n        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n            // Mint the token to the founder\n            _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n\n            return true;\n\n            // Else the founder has finished vesting:\n        } else {\n            // Remove them from future lookups\n            delete tokenRecipient[baseTokenId];\n\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             BURN                         ///\n    ///                                                          ///\n\n    /// @notice Burns a token that did not see any bids\n    /// @param _tokenId The ERC-721 token id\n    function burn(uint256 _tokenId) external {\n        // Ensure the caller is the auction house\n        if (msg.sender != settings.auction) revert ONLY_AUCTION();\n\n        // Burn the token\n        _burn(_tokenId);\n    }\n\n    ///                                                          ///\n    ///                           METADATA                       ///\n    ///                                                          ///\n\n    /// @notice The URI for a token\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.tokenURI(_tokenId);\n    }\n\n    /// @notice The URI for the contract\n    function contractURI() public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.contractURI();\n    }\n\n    ///                                                          ///\n    ///                           FOUNDERS                       ///\n    ///                                                          ///\n\n    /// @notice The number of founders\n    function totalFounders() external view returns (uint256) {\n        return settings.numFounders;\n    }\n\n    /// @notice The founders total percent ownership\n    function totalFounderOwnership() external view returns (uint256) {\n        return settings.totalOwnership;\n    }\n\n    /// @notice The vesting details of a founder\n    /// @param _founderId The founder id\n    function getFounder(uint256 _founderId) external view returns (Founder memory) {\n        return founder[_founderId];\n    }\n\n    /// @notice The vesting details of all founders\n    function getFounders() external view returns (Founder[] memory) {\n        // Cache the number of founders\n        uint256 numFounders = settings.numFounders;\n\n        // Get a temporary array to hold all founders\n        Founder[] memory founders = new Founder[](numFounders);\n\n        // Cannot realistically overflow\n        unchecked {\n            // Add each founder to the array\n            for (uint256 i; i < numFounders; ++i) founders[i] = founder[i];\n        }\n\n        return founders;\n    }\n\n    /// @notice The founder scheduled to receive the given token id\n    /// NOTE: If a founder is returned, there's no guarantee they'll receive the token as vesting expiration is not considered\n    /// @param _tokenId The ERC-721 token id\n    function getScheduledRecipient(uint256 _tokenId) external view returns (Founder memory) {\n        return tokenRecipient[_tokenId % 100];\n    }\n\n    ///                                                          ///\n    ///                           SETTINGS                       ///\n    ///                                                          ///\n\n    /// @notice The total supply of tokens\n    function totalSupply() external view returns (uint256) {\n        return settings.totalSupply;\n    }\n\n    /// @notice The address of the auction house\n    function auction() external view returns (address) {\n        return settings.auction;\n    }\n\n    /// @notice The address of the metadata renderer\n    function metadataRenderer() external view returns (address) {\n        return address(settings.metadataRenderer);\n    }\n\n    /// @notice The address of the owner\n    function owner() public view returns (address) {\n        return settings.metadataRenderer.owner();\n    }\n\n    ///                                                          ///\n    ///                         TOKEN UPGRADE                    ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override {\n        // Ensure the caller is the shared owner of the token and metadata renderer\n        if (msg.sender != owner()) revert ONLY_OWNER();\n\n        // Ensure the implementation is valid\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "src/token/Token.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { ERC721Votes } from \"../lib/token/ERC721Votes.sol\";\nimport { ERC721 } from \"../lib/token/ERC721.sol\";\n\nimport { TokenStorageV1 } from \"./storage/TokenStorageV1.sol\";\nimport { IBaseMetadata } from \"./metadata/interfaces/IBaseMetadata.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IToken } from \"./IToken.sol\";\n\n/// @title Token\n/// @author Rohan Kulkarni\n/// @notice A DAO's ERC-721 governance token\ncontract Token is IToken, UUPS, ReentrancyGuard, ERC721Votes, TokenStorageV1 {\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token contract\n    /// @param _founders The DAO founders\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _metadataRenderer The token's metadata renderer\n    /// @param _auction The token's auction house\n    function initialize(\n        IManager.FounderParams[] calldata _founders,\n        bytes calldata _initStrings,\n        address _metadataRenderer,\n        address _auction\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Store the founders and compute their allocations\n        _addFounders(_founders);\n\n        // Decode the token name and symbol\n        (string memory _name, string memory _symbol, , , ) = abi.decode(_initStrings, (string, string, string, string, string));\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_name, _symbol);\n\n        // Store the metadata renderer and auction house\n        settings.metadataRenderer = IBaseMetadata(_metadataRenderer);\n        settings.auction = _auction;\n    }\n\n    /// @dev Called upon initialization to add founders and compute their vesting allocations\n    /// @param _founders The list of DAO founders\n    function _addFounders(IManager.FounderParams[] calldata _founders) internal {\n        // Cache the number of founders\n        uint256 numFounders = _founders.length;\n\n        // Used to store the total percent ownership among the founders\n        uint256 totalOwnership;\n\n        unchecked {\n            // For each founder:\n            for (uint256 i; i < numFounders; ++i) {\n                // Cache the percent ownership\n                uint256 founderPct = _founders[i].ownershipPct;\n\n                // Continue if no ownership is specified\n                if (founderPct == 0) continue;\n\n                // Update the total ownership and ensure it's valid\n                if ((totalOwnership += uint8(founderPct)) > 100) revert INVALID_FOUNDER_OWNERSHIP();\n\n                // Compute the founder's id\n                uint256 founderId = settings.numFounders++;\n\n                // Get the pointer to store the founder\n                Founder storage newFounder = founder[founderId];\n\n                // Store the founder's vesting details\n                newFounder.wallet = _founders[i].wallet;\n                newFounder.vestExpiry = uint32(_founders[i].vestExpiry);\n                newFounder.ownershipPct = uint8(founderPct);\n\n                // Compute the vesting schedule\n                uint256 schedule = 100 / founderPct;\n\n                // Used to store the base token id the founder will recieve\n                uint256 baseTokenId;\n\n                // For each token to vest:\n                for (uint256 j; j < founderPct; ++j) {\n                    // Get the available token id\n                    baseTokenId = _getNextTokenId(baseTokenId);\n\n                    // Store the founder as the recipient\n                    tokenRecipient[baseTokenId] = newFounder;\n\n                    emit MintScheduled(baseTokenId, founderId, newFounder);\n\n                    // Update the base token id\n                    (baseTokenId += schedule) % 100;\n                }\n            }\n\n            // Store the founders' details\n            settings.totalOwnership = uint8(totalOwnership);\n            settings.numFounders = uint8(numFounders);\n        }\n    }\n\n    /// @dev Finds the next available base token id for a founder\n    /// @param _tokenId The ERC-721 token id\n    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n        unchecked {\n            while (tokenRecipient[_tokenId].wallet != address(0)) ++_tokenId;\n\n            return _tokenId;\n        }\n    }\n\n    ///                                                          ///\n    ///                             MINT                         ///\n    ///                                                          ///\n\n    /// @notice Mints tokens to the auction house for bidding and handles founder vesting\n    function mint() external nonReentrant returns (uint256 tokenId) {\n        // Cache the auction address\n        address minter = settings.auction;\n\n        // Ensure the caller is the auction\n        if (msg.sender != minter) revert ONLY_AUCTION();\n\n        // Cannot realistically overflow\n        unchecked {\n            do {\n                // Get the next token to mint\n                tokenId = settings.totalSupply++;\n\n                // Lookup whether the token is for a founder, and mint accordingly if so\n            } while (_isForFounder(tokenId));\n        }\n\n        // Mint the next available token to the auction house for bidding\n        _mint(minter, tokenId);\n    }\n\n    /// @dev Overrides _mint to include attribute generation\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal override {\n        // Mint the token\n        super._mint(_to, _tokenId);\n\n        // Generate the token attributes\n        if (!settings.metadataRenderer.onMinted(_tokenId)) revert NO_METADATA_GENERATED();\n    }\n\n    /// @dev Checks if a given token is for a founder and mints accordingly\n    /// @param _tokenId The ERC-721 token id\n    function _isForFounder(uint256 _tokenId) private returns (bool) {\n        // Get the base token id\n        uint256 baseTokenId = _tokenId % 100;\n\n        // If there is no scheduled recipient:\n        if (tokenRecipient[baseTokenId].wallet == address(0)) {\n            return false;\n\n            // Else if the founder is still vesting:\n        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n            // Mint the token to the founder\n            _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n\n            return true;\n\n            // Else the founder has finished vesting:\n        } else {\n            // Remove them from future lookups\n            delete tokenRecipient[baseTokenId];\n\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             BURN                         ///\n    ///                                                          ///\n\n    /// @notice Burns a token that did not see any bids\n    /// @param _tokenId The ERC-721 token id\n    function burn(uint256 _tokenId) external {\n        // Ensure the caller is the auction house\n        if (msg.sender != settings.auction) revert ONLY_AUCTION();\n\n        // Burn the token\n        _burn(_tokenId);\n    }\n\n    ///                                                          ///\n    ///                           METADATA                       ///\n    ///                                                          ///\n\n    /// @notice The URI for a token\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.tokenURI(_tokenId);\n    }\n\n    /// @notice The URI for the contract\n    function contractURI() public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.contractURI();\n    }\n\n    ///                                                          ///\n    ///                           FOUNDERS                       ///\n    ///                                                          ///\n\n    /// @notice The number of founders\n    function totalFounders() external view returns (uint256) {\n        return settings.numFounders;\n    }\n\n    /// @notice The founders total percent ownership\n    function totalFounderOwnership() external view returns (uint256) {\n        return settings.totalOwnership;\n    }\n\n    /// @notice The vesting details of a founder\n    /// @param _founderId The founder id\n    function getFounder(uint256 _founderId) external view returns (Founder memory) {\n        return founder[_founderId];\n    }\n\n    /// @notice The vesting details of all founders\n    function getFounders() external view returns (Founder[] memory) {\n        // Cache the number of founders\n        uint256 numFounders = settings.numFounders;\n\n        // Get a temporary array to hold all founders\n        Founder[] memory founders = new Founder[](numFounders);\n\n        // Cannot realistically overflow\n        unchecked {\n            // Add each founder to the array\n            for (uint256 i; i < numFounders; ++i) founders[i] = founder[i];\n        }\n\n        return founders;\n    }\n\n    /// @notice The founder scheduled to receive the given token id\n    /// NOTE: If a founder is returned, there's no guarantee they'll receive the token as vesting expiration is not considered\n    /// @param _tokenId The ERC-721 token id\n    function getScheduledRecipient(uint256 _tokenId) external view returns (Founder memory) {\n        return tokenRecipient[_tokenId % 100];\n    }\n\n    ///                                                          ///\n    ///                           SETTINGS                       ///\n    ///                                                          ///\n\n    /// @notice The total supply of tokens\n    function totalSupply() external view returns (uint256) {\n        return settings.totalSupply;\n    }\n\n    /// @notice The address of the auction house\n    function auction() external view returns (address) {\n        return settings.auction;\n    }\n\n    /// @notice The address of the metadata renderer\n    function metadataRenderer() external view returns (address) {\n        return address(settings.metadataRenderer);\n    }\n\n    /// @notice The address of the owner\n    function owner() public view returns (address) {\n        return settings.metadataRenderer.owner();\n    }\n\n    ///                                                          ///\n    ///                         TOKEN UPGRADE                    ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override {\n        // Ensure the caller is the shared owner of the token and metadata renderer\n        if (msg.sender != owner()) revert ONLY_OWNER();\n\n        // Ensure the implementation is valid\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    }
  ]
}