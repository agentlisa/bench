{
  "Title": "H-2: Adversary can reenter takeOverDebt() during liquidation to steal vault funds",
  "Content": "# Issue H-2: Adversary can reenter takeOverDebt() during liquidation to steal vault funds \n\nSource: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/76 \n\n## Found by \n0x52\n\nDue to the lack of nonReentrant modifier on takeOverDebt() a liquidatable position can be both liquidated and transferred simultaneously. This results in LPs being repaid from the vault while the position and loans continue to be held open, effectively duplicating the liquidated position. LPs therefore get to 'double dip' from the vault, stealing funds and causing a deficit. This can be abused by an attacker who borrows against their own LP to exploit the 'double dip' for profit.\n\n## Vulnerability Detail\n\nFirst we'll walk through a high level breakdown of the issue to have as context for the rest of the report:\n\n 1) Create a custom token that allows them to take control of the transaction and to prevent liquidation\n 2) Fund UniV3 LP with target token and custom token\n 3) Borrow against LP with target token as the hold token\n 4) After some time the position become liquidatable\n 5) Begin liquidating the position via repay()\n 6) Utilize the custom token during the swap in repay() to gain control of the transaction\n 7) Use control to reenter into takeOverDebt() since it lack nonReentrant modifier\n 8) Loan is now open on a secondary address and closed on the initial one\n 8) Transaction resumes (post swap) on repay() \n 9) Finish repayment and refund all initial LP\n10) Position is still exists on new address\n11) After some time the position become liquidatable\n12) Loan is liquidated and attacker is paid more LP\n13) Vault is at a deficit due to refunding LP twice\n14) Repeat until the vault is drained of target token\n\n[LiquidityManager.sol#L279-L287](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/abstract/LiquidityManager.sol#L279-L287)\n\n    _v3SwapExactInput(\n        v3SwapExactInputParams({\n            fee: params.fee,\n            tokenIn: cache.holdToken,\n            tokenOut: cache.saleToken,\n            amountIn: holdTokenAmountIn,\n            amountOutMinimum: (saleTokenAmountOut * params.slippageBP1000) /\n                Constants.BPS\n        })\n\nThe control transfer happens during the swap to UniV3. Here when the custom token is transferred, it gives control back to the attacker which can be used to call takeOverDebt().\n\n[LiquidityBorrowingManager.sol#L667-L672](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L667-L672)\n\n        _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n        // Pay a profit to a msg.sender\n        _pay(borrowing.holdToken, address(this), msg.sender, holdTokenBalance);\n        _pay(borrowing.saleToken, address(this), msg.sender, saleTokenBalance);\n\n        emit Repay(borrowing.borrower, msg.sender, params.borrowingKey);\n\nThe reason the reentrancy works is because the actual borrowing storage state isn't modified until AFTER the control transfer. This means that the position state is fully intact for the takeOverDebt() call, allowing it to seamlessly transfer to another address behaving completely normally. After the repay() call resumes, _removeKeysAndClearStorage is called with the now deleted borrowKey. \n\n[Keys.sol#L31-L42](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/libraries/Keys.sol#L31-L42)\n\n    function removeKey(bytes32[] storage self, bytes32 key) internal {\n        uint256 length = self.length;\n        for (uint256 i; i < length; ) {\n            if (self.unsafeAccess(i).value == key) {\n                self.unsafeAccess(i).value = self.unsafeAccess(length - 1).value;\n                self.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\nThe unique characteristic of deleteKey is that it doesn't revert if the key doesn't exist. This allows \"removing\" keys from an empty array without reverting. This allows the repay call to finish successfully.\n\n[LiquidityBorrowingManager.sol#L450-L452](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L450-L452)\n\n        //newBorrowing.accLoanRatePerSeconds = oldBorrowing.accLoanRatePerSeconds;\n        _pay(oldBorrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt + feesDebt);\n        emit TakeOverDebt(oldBorrowing.borrower, msg.sender, borrowingKey, newBorrowingKey);\n\nNow we can see how this creates a deficit in the vault. When taking over an existing debt, the user is only required to provide enough hold token to cover any fee debt and any additional collateral to pay fees for the newly transferred position. This means that the user isn't providing any hold token to back existing LP.\n\n[LiquidityBorrowingManager.sol#L632-L636](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L632-L636)\n\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                address(this),\n                borrowing.borrowedAmount + liquidationBonus\n            );\n\nOn the other hand repay transfers the LP backing funds from the vault. Since the same position is effectively liquidated twice, it will withdraw twice as much hold token as was originally deposited and no new LP funds are added when the position is taken over. This causes a deficit in the vault since other users funds are being withdrawn from the vault.\n\n## Impact\n\nVault can be drained\n\n## Code Snippet\n\n[LiquidityBorrowingManager.sol#L395-L453](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L395-L453)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd the `nonReentrant` modifier to `takeOverDebt()`\n\n\n\n## Discussion\n\n**fann95**\n\nUnfortunately, during development, we lost the nonReentrant-modifier just like checkDeadline. We will fix it.\n\n**fann95**\n\nFixed: https://github.com/RealWagmi/wagmi-leverage/commit/955d742c37736192f81a20c39a82324f3d711fb4\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/118",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/abstract/LiquidityManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\nimport \"../vendor0.8/uniswap/LiquidityAmounts.sol\";\nimport \"../vendor0.8/uniswap/TickMath.sol\";\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"../interfaces/IQuoterV2.sol\";\nimport \"./ApproveSwapAndPay.sol\";\nimport \"../Vault.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\nabstract contract LiquidityManager is ApproveSwapAndPay {\n    /**\n     * @notice Represents information about a loan.\n     * @dev This struct is used to store liquidity and tokenId for a loan.\n     * @param liquidity The amount of liquidity for the loan represented by a uint128 value.\n     * @param tokenId The token ID associated with the loan represented by a uint256 value.\n     */\n    struct LoanInfo {\n        uint128 liquidity;\n        uint256 tokenId;\n    }\n    /**\n     * @notice Contains parameters for restoring liquidity.\n     * @dev This struct is used to store various parameters required for restoring liquidity.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param fee The fee associated with the internal swap pool is represented by a uint24 value.\n     * @param slippageBP1000 The slippage in basis points (BP) represented by a uint256 value.\n     * @param totalfeesOwed The total fees owed represented by a uint256 value.\n     * @param totalBorrowedAmount The total borrowed amount represented by a uint256 value.\n     */\n    struct RestoreLiquidityParams {\n        bool zeroForSaleToken;\n        uint24 fee;\n        uint256 slippageBP1000;\n        uint256 totalfeesOwed;\n        uint256 totalBorrowedAmount;\n    }\n    /**\n     * @notice Contains cache data for restoring liquidity.\n     * @dev This struct is used to store cached values required for restoring liquidity.\n     * @param tickLower The lower tick boundary represented by an int24 value.\n     * @param tickUpper The upper tick boundary represented by an int24 value.\n     * @param fee The fee associated with the restoring liquidity pool.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @param sqrtPriceX96 The square root of the price represented by a uint160 value.\n     * @param holdTokenDebt The debt amount associated with the hold token represented by a uint256 value.\n     */\n    struct RestoreLiquidityCache {\n        int24 tickLower;\n        int24 tickUpper;\n        uint24 fee;\n        address saleToken;\n        address holdToken;\n        uint160 sqrtPriceX96;\n        uint256 holdTokenDebt;\n    }\n    /**\n     * @notice The address of the vault contract.\n     */\n    address public immutable VAULT_ADDRESS;\n    /**\n     * @notice The Nonfungible Position Manager contract.\n     */\n    INonfungiblePositionManager public immutable underlyingPositionManager;\n    /**\n     * @notice The QuoterV2 contract.\n     */\n    IQuoterV2 public immutable underlyingQuoterV2;\n\n    /**\n     * @dev Contract constructor.\n     * @param _underlyingPositionManagerAddress Address of the underlying position manager contract.\n     * @param _underlyingQuoterV2 Address of the underlying quoterV2 contract.\n     * @param _underlyingV3Factory Address of the underlying V3 factory contract.\n     * @param _underlyingV3PoolInitCodeHash The init code hash of the underlying V3 pool.\n     */\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _underlyingQuoterV2,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    ) ApproveSwapAndPay(_underlyingV3Factory, _underlyingV3PoolInitCodeHash) {\n        // Assign the underlying position manager contract address\n        underlyingPositionManager = INonfungiblePositionManager(_underlyingPositionManagerAddress);\n        // Assign the underlying quoterV2 contract address\n        underlyingQuoterV2 = IQuoterV2(_underlyingQuoterV2);\n        // Generate a unique salt for the new Vault contract\n        bytes32 salt = keccak256(abi.encode(block.timestamp, address(this)));\n        // Deploy a new Vault contract using the generated salt and assign its address to VAULT_ADDRESS\n        VAULT_ADDRESS = address(new Vault{ salt: salt }());\n    }\n\n    error InvalidBorrowedLiquidity(uint256 tokenId);\n    error TooLittleBorrowedLiquidity(uint128 liquidity);\n    error InvalidTokens(uint256 tokenId);\n    error NotApproved(uint256 tokenId);\n    error InvalidRestoredLiquidity(\n        uint256 tokenId,\n        uint128 borrowedLiquidity,\n        uint128 restoredLiquidity,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 holdTokentBalance,\n        uint256 saleTokenBalance\n    );\n\n    /**\n     * @dev Calculates the borrowed amount from a pool's single side position, rounding up if necessary.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param tickLower The lower tick value of the position range.\n     * @param tickUpper The upper tick value of the position range.\n     * @param liquidity The liquidity of the position.\n     * @return borrowedAmount The calculated borrowed amount.\n     */\n    function _getSingleSideRoundUpBorrowedAmount(\n        bool zeroForSaleToken,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) private pure returns (uint256 borrowedAmount) {\n        borrowedAmount = (\n            zeroForSaleToken\n                ? LiquidityAmounts.getAmount1ForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n                : LiquidityAmounts.getAmount0ForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n        );\n        if (borrowedAmount > Constants.MINIMUM_BORROWED_AMOUNT) {\n            ++borrowedAmount;\n        } else {\n            revert TooLittleBorrowedLiquidity(liquidity);\n        }\n    }\n\n    /**\n     * @dev Extracts liquidity from loans and returns the borrowed amount.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param token0 The address of one of the tokens in the pair.\n     * @param token1 The address of the other token in the pair.\n     * @param loans An array of LoanInfo struct instances containing loan information.\n     * @return borrowedAmount The total amount borrowed.\n     */\n    function _extractLiquidity(\n        bool zeroForSaleToken,\n        address token0,\n        address token1,\n        LoanInfo[] memory loans\n    ) internal returns (uint256 borrowedAmount) {\n        if (!zeroForSaleToken) {\n            (token0, token1) = (token1, token0);\n        }\n\n        for (uint256 i; i < loans.length; ) {\n            uint256 tokenId = loans[i].tokenId;\n            uint128 liquidity = loans[i].liquidity;\n            // Extract position-related details\n            {\n                int24 tickLower;\n                int24 tickUpper;\n                uint128 posLiquidity;\n                {\n                    address operator;\n                    address posToken0;\n                    address posToken1;\n\n                    (\n                        ,\n                        operator,\n                        posToken0,\n                        posToken1,\n                        ,\n                        tickLower,\n                        tickUpper,\n                        posLiquidity,\n                        ,\n                        ,\n                        ,\n\n                    ) = underlyingPositionManager.positions(tokenId);\n                    // Check operator approval\n                    if (operator != address(this)) {\n                        revert NotApproved(tokenId);\n                    }\n                    // Check token validity\n                    if (posToken0 != token0 || posToken1 != token1) {\n                        revert InvalidTokens(tokenId);\n                    }\n                }\n                // Check borrowed liquidity validity\n                if (!(liquidity > 0 && liquidity <= posLiquidity)) {\n                    revert InvalidBorrowedLiquidity(tokenId);\n                }\n                // Calculate borrowed amount\n                borrowedAmount += _getSingleSideRoundUpBorrowedAmount(\n                    zeroForSaleToken,\n                    tickLower,\n                    tickUpper,\n                    liquidity\n                );\n            }\n            // Decrease liquidity and move to the next loan\n            _decreaseLiquidity(tokenId, liquidity);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Restores liquidity from loans.\n     * @param params The RestoreLiquidityParams struct containing restoration parameters.\n     * @param externalSwap The SwapParams struct containing external swap details.\n     * @param loans An array of LoanInfo struct instances containing loan information.\n     */\n    function _restoreLiquidity(\n        // Create a cache struct to store temporary data\n        RestoreLiquidityParams memory params,\n        SwapParams calldata externalSwap,\n        LoanInfo[] memory loans\n    ) internal {\n        RestoreLiquidityCache memory cache;\n        for (uint256 i; i < loans.length; ) {\n            // Update the cache for the current loan\n            LoanInfo memory loan = loans[i];\n            _upRestoreLiquidityCache(params.zeroForSaleToken, loan, cache);\n            // Calculate the hold token amount to be used for swapping\n            (uint256 holdTokenAmountIn, uint256 amount0, uint256 amount1) = _getHoldTokenAmountIn(\n                params.zeroForSaleToken,\n                cache.tickLower,\n                cache.tickUpper,\n                cache.sqrtPriceX96,\n                loan.liquidity,\n                cache.holdTokenDebt\n            );\n\n            if (holdTokenAmountIn > 0) {\n                // Quote exact input single for swap\n                uint256 saleTokenAmountOut;\n                (saleTokenAmountOut, cache.sqrtPriceX96, , ) = underlyingQuoterV2\n                    .quoteExactInputSingle(\n                        IQuoterV2.QuoteExactInputSingleParams({\n                            tokenIn: cache.holdToken,\n                            tokenOut: cache.saleToken,\n                            amountIn: holdTokenAmountIn,\n                            fee: params.fee,\n                            sqrtPriceLimitX96: 0\n                        })\n                    );\n\n                // Perform external swap if external swap target is provided\n                if (externalSwap.swapTarget != address(0)) {\n                    _patchAmountsAndCallSwap(\n                        cache.holdToken,\n                        cache.saleToken,\n                        externalSwap,\n                        holdTokenAmountIn,\n                        (saleTokenAmountOut * params.slippageBP1000) / Constants.BPS\n                    );\n                } else {\n                    // Calculate hold token amount in again for new sqrtPriceX96\n                    (holdTokenAmountIn, , ) = _getHoldTokenAmountIn(\n                        params.zeroForSaleToken,\n                        cache.tickLower,\n                        cache.tickUpper,\n                        cache.sqrtPriceX96,\n                        loan.liquidity,\n                        cache.holdTokenDebt\n                    );\n\n                    // Perform v3 swap exact input and update sqrtPriceX96\n                    _v3SwapExactInput(\n                        v3SwapExactInputParams({\n                            fee: params.fee,\n                            tokenIn: cache.holdToken,\n                            tokenOut: cache.saleToken,\n                            amountIn: holdTokenAmountIn,\n                            amountOutMinimum: (saleTokenAmountOut * params.slippageBP1000) /\n                                Constants.BPS\n                        })\n                    );\n                    // Update the value of sqrtPriceX96 in the cache using the _getCurrentSqrtPriceX96 function\n                    cache.sqrtPriceX96 = _getCurrentSqrtPriceX96(\n                        params.zeroForSaleToken,\n                        cache.saleToken,\n                        cache.holdToken,\n                        cache.fee\n                    );\n                    // Calculate the amounts of token0 and token1 for a given liquidity\n                    (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n                        cache.sqrtPriceX96,\n                        TickMath.getSqrtRatioAtTick(cache.tickLower),\n                        TickMath.getSqrtRatioAtTick(cache.tickUpper),\n                        loan.liquidity\n                    );\n                }\n            }\n            // Get the owner of the Nonfungible Position Manager token by its tokenId\n            address creditor = underlyingPositionManager.ownerOf(loan.tokenId);\n            // Increase liquidity and transfer liquidity owner reward\n            _increaseLiquidity(cache.saleToken, cache.holdToken, loan, amount0, amount1);\n            uint256 liquidityOwnerReward = FullMath.mulDiv(\n                params.totalfeesOwed,\n                cache.holdTokenDebt,\n                params.totalBorrowedAmount\n            ) / Constants.COLLATERAL_BALANCE_PRECISION;\n\n            Vault(VAULT_ADDRESS).transferToken(cache.holdToken, creditor, liquidityOwnerReward);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Retrieves the current square root price in X96 representation.\n     * @param zeroForA Flag indicating whether to treat the tokenA as the 0th token or not.\n     * @param tokenA The address of token A.\n     * @param tokenB The address of token B.\n     * @param fee The fee associated with the Uniswap V3 pool.\n     * @return sqrtPriceX96 The current square root price in X96 representation.\n     */\n    function _getCurrentSqrtPriceX96(\n        bool zeroForA,\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) private view returns (uint160 sqrtPriceX96) {\n        if (!zeroForA) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n        address poolAddress = computePoolAddress(tokenA, tokenB, fee);\n        (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(poolAddress).slot0();\n    }\n\n    /**\n     * @dev Decreases the liquidity of a position by removing tokens.\n     * @param tokenId The ID of the position token.\n     * @param liquidity The amount of liquidity to be removed.\n     */\n    function _decreaseLiquidity(uint256 tokenId, uint128 liquidity) private {\n        // Call the decreaseLiquidity function of underlyingPositionManager contract\n        // with DecreaseLiquidityParams struct as argument\n        (uint256 amount0, uint256 amount1) = underlyingPositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        // Check if both amount0 and amount1 are zero after decreasing liquidity\n        // If true, revert with InvalidBorrowedLiquidity exception\n        if (amount0 == 0 && amount1 == 0) {\n            revert InvalidBorrowedLiquidity(tokenId);\n        }\n        // Call the collect function of underlyingPositionManager contract\n        // with CollectParams struct as argument\n        (amount0, amount1) = underlyingPositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: address(this),\n                amount0Max: uint128(amount0),\n                amount1Max: uint128(amount1)\n            })\n        );\n    }\n\n    /**\n     * @dev Increases the liquidity of a position by providing additional tokens.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param loan An instance of LoanInfo memory struct containing loan details.\n     * @param amount0 The amount of token0 to be added to the liquidity.\n     * @param amount1 The amount of token1 to be added to the liquidity.\n     */\n    function _increaseLiquidity(\n        address saleToken,\n        address holdToken,\n        LoanInfo memory loan,\n        uint256 amount0,\n        uint256 amount1\n    ) private {\n        // increase if not equal to zero to avoid rounding down the amount of restored liquidity.\n        if (amount0 > 0) ++amount0;\n        if (amount1 > 0) ++amount1;\n        // Call the increaseLiquidity function of underlyingPositionManager contract\n        // with IncreaseLiquidityParams struct as argument\n        (uint128 restoredLiquidity, , ) = underlyingPositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: loan.tokenId,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        // Check if the restored liquidity is less than the loan liquidity amount\n        // If true, revert with InvalidRestoredLiquidity exception\n        if (restoredLiquidity < loan.liquidity) {\n            // Get the balance of holdToken and saleToken\n            (uint256 holdTokentBalance, uint256 saleTokenBalance) = _getPairBalance(\n                holdToken,\n                saleToken\n            );\n\n            revert InvalidRestoredLiquidity(\n                loan.tokenId,\n                loan.liquidity,\n                restoredLiquidity,\n                amount0,\n                amount1,\n                holdTokentBalance,\n                saleTokenBalance\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of hold token required for a swap.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param tickLower The lower tick of the liquidity range.\n     * @param tickUpper The upper tick of the liquidity range.\n     * @param sqrtPriceX96 The square root of the price ratio of the sale token to the hold token.\n     * @param liquidity The amount of liquidity.\n     * @param holdTokenDebt The amount of hold token debt.\n     * @return holdTokenAmountIn The amount of hold token needed to provide the specified liquidity.\n     * @return amount0 The amount of token0 calculated based on the liquidity.\n     * @return amount1 The amount of token1 calculated based on the liquidity.\n     */\n    function _getHoldTokenAmountIn(\n        bool zeroForSaleToken,\n        int24 tickLower,\n        int24 tickUpper,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        uint256 holdTokenDebt\n    ) private pure returns (uint256 holdTokenAmountIn, uint256 amount0, uint256 amount1) {\n        // Call getAmountsForLiquidity function from LiquidityAmounts library\n        // to get the amounts of token0 and token1 for a given liquidity position\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            TickMath.getSqrtRatioAtTick(tickLower),\n            TickMath.getSqrtRatioAtTick(tickUpper),\n            liquidity\n        );\n        // Calculate the holdTokenAmountIn based on the zeroForSaleToken flag\n        if (zeroForSaleToken) {\n            // If zeroForSaleToken is true, check if amount0 is zero\n            // If true, holdTokenAmountIn will be zero. Otherwise, it will be holdTokenDebt - amount1\n            holdTokenAmountIn = amount0 == 0 ? 0 : holdTokenDebt - amount1;\n        } else {\n            // If zeroForSaleToken is false, check if amount1 is zero\n            // If true, holdTokenAmountIn will be zero. Otherwise, it will be holdTokenDebt - amount0\n            holdTokenAmountIn = amount1 == 0 ? 0 : holdTokenDebt - amount0;\n        }\n    }\n\n    /**\n     * @dev Updates the RestoreLiquidityCache struct with data from the underlyingPositionManager contract.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param loan The LoanInfo struct containing loan details.\n     * @param cache The RestoreLiquidityCache struct to be updated.\n     */\n    function _upRestoreLiquidityCache(\n        bool zeroForSaleToken,\n        LoanInfo memory loan,\n        RestoreLiquidityCache memory cache\n    ) internal view {\n        // Get the positions data from `PositionManager` and store it in the cache variables\n        (\n            ,\n            ,\n            cache.saleToken,\n            cache.holdToken,\n            cache.fee,\n            cache.tickLower,\n            cache.tickUpper,\n            ,\n            ,\n            ,\n            ,\n\n        ) = underlyingPositionManager.positions(loan.tokenId);\n        // Swap saleToken and holdToken if zeroForSaleToken is false\n        if (!zeroForSaleToken) {\n            (cache.saleToken, cache.holdToken) = (cache.holdToken, cache.saleToken);\n        }\n        // Calculate the holdTokenDebt using\n        cache.holdTokenDebt = _getSingleSideRoundUpBorrowedAmount(\n            zeroForSaleToken,\n            cache.tickLower,\n            cache.tickUpper,\n            loan.liquidity\n        );\n        // Calculate the square root price using `_getCurrentSqrtPriceX96` function\n        cache.sqrtPriceX96 = _getCurrentSqrtPriceX96(\n            zeroForSaleToken,\n            cache.saleToken,\n            cache.holdToken,\n            cache.fee\n        );\n    }\n}"
    },
    {
      "filename": "wagmi-leverage/contracts/LiquidityBorrowingManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./abstract/LiquidityManager.sol\";\nimport \"./abstract/OwnerSettings.sol\";\nimport \"./abstract/DailyRateAndCollateral.sol\";\nimport \"./libraries/ErrLib.sol\";\n\n/**\n * @title LiquidityBorrowingManager\n * @dev This contract manages the borrowing liquidity functionality for WAGMI Leverage protocol.\n * It inherits from LiquidityManager, OwnerSettings, DailyRateAndCollateral, and ReentrancyGuard contracts.\n */\ncontract LiquidityBorrowingManager is\n    LiquidityManager,\n    OwnerSettings,\n    DailyRateAndCollateral,\n    ReentrancyGuard\n{\n    using { Keys.removeKey, Keys.addKeyIfNotExists } for bytes32[];\n    using { ErrLib.revertError } for bool;\n\n    /// @title BorrowParams\n    /// @notice This struct represents the parameters required for borrowing.\n    struct BorrowParams {\n        /// @notice The pool fee level for the internal swap\n        uint24 internalSwapPoolfee;\n        /// @notice The address of the token that will be sold to obtain the loan currency\n        address saleToken;\n        /// @notice The address of the token that will be held\n        address holdToken;\n        /// @notice The minimum amount of holdToken that must be obtained\n        uint256 minHoldTokenOut;\n        /// @notice The maximum amount of collateral that can be provided for the loan\n        uint256 maxCollateral;\n        /// @notice The SwapParams struct representing the external swap parameters\n        SwapParams externalSwap;\n        /// @notice An array of LoanInfo structs representing multiple loans\n        LoanInfo[] loans;\n    }\n    /// @title BorrowingInfo\n    /// @notice This struct represents the borrowing information for a borrower.\n    struct BorrowingInfo {\n        address borrower;\n        address saleToken;\n        address holdToken;\n        /// @notice The amount of fees owed by the creditor\n        uint256 feesOwed;\n        /// @notice The amount borrowed by the borrower\n        uint256 borrowedAmount;\n        /// @notice The amount of liquidation bonus\n        uint256 liquidationBonus;\n        /// @notice The accumulated loan rate per share\n        uint256 accLoanRatePerSeconds;\n        /// @notice The daily rate collateral balance multiplied by COLLATERAL_BALANCE_PRECISION\n        uint256 dailyRateCollateralBalance;\n    }\n    /// @notice This struct used for caching variables inside a function 'borrow'\n    struct BorrowCache {\n        uint256 dailyRateCollateral;\n        uint256 accLoanRatePerSeconds;\n        uint256 borrowedAmount;\n        uint256 holdTokenBalance;\n    }\n    /// @notice Struct representing the extended borrowing information.\n    struct BorrowingInfoExt {\n        /// @notice The main borrowing information.\n        BorrowingInfo info;\n        /// @notice An array of LoanInfo structs representing multiple loans\n        LoanInfo[] loans;\n        /// @notice The balance of the collateral.\n        int256 collateralBalance;\n        /// @notice The estimated lifetime of the loan.\n        uint256 estimatedLifeTime;\n        /// borrowing Key\n        bytes32 key;\n    }\n\n    /// @title RepayParams\n    /// @notice This struct represents the parameters required for repaying a loan.\n    struct RepayParams {\n        /// @notice The activation of the emergency liquidity restoration mode (available only to the lender)\n        bool isEmergency;\n        /// @notice The pool fee level for the internal swap\n        uint24 internalSwapPoolfee;\n        /// @notice The external swap parameters for the repayment transaction\n        SwapParams externalSwap;\n        /// @notice The unique borrowing key associated with the loan\n        bytes32 borrowingKey;\n        /// @notice The slippage allowance for the swap in basis points (1/10th of a percent)\n        uint256 swapSlippageBP1000;\n    }\n    /// borrowingKey=>LoanInfo\n    mapping(bytes32 => LoanInfo[]) public loansInfo;\n    /// borrowingKey=>BorrowingInfo\n    mapping(bytes32 => BorrowingInfo) public borrowingsInfo;\n    /// borrower => BorrowingKeys[]\n    mapping(address => bytes32[]) public userBorrowingKeys;\n    /// NonfungiblePositionManager tokenId => BorrowingKeys[]\n    mapping(uint256 => bytes32[]) public tokenIdToBorrowingKeys;\n\n    ///  token => FeesAmt\n    mapping(address => uint256) private platformsFeesInfo;\n\n    /// Indicates that a borrower has made a new loan\n    event Borrow(\n        address borrower,\n        bytes32 borrowingKey,\n        uint256 borrowedAmount,\n        uint256 borrowingCollateral,\n        uint256 liquidationBonus,\n        uint256 dailyRatePrepayment\n    );\n    /// Indicates that a borrower has repaid their loan, optionally with the help of a liquidator\n    event Repay(address borrower, address liquidator, bytes32 borrowingKey);\n    /// Indicates that a loan has been closed due to an emergency situation\n    event EmergencyLoanClosure(address borrower, address lender, bytes32 borrowingKey);\n    /// Indicates that the protocol has collected fee tokens\n    event CollectProtocol(address recipient, address[] tokens, uint256[] amounts);\n    /// Indicates that the daily interest rate for holding token(for specific pair) has been updated\n    event UpdateHoldTokenDailyRate(address saleToken, address holdToken, uint256 value);\n    /// Indicates that a borrower has increased their collateral balance for a loan\n    event IncreaseCollateralBalance(address borrower, bytes32 borrowingKey, uint256 collateralAmt);\n    /// Indicates that a new borrower has taken over the debt from an old borrower\n    event TakeOverDebt(\n        address oldBorrower,\n        address newBorrower,\n        bytes32 oldBorrowingKey,\n        bytes32 newBorrowingKey\n    );\n\n    error TooLittleReceivedError(uint256 minOut, uint256 out);\n\n    /// @dev Modifier to check if the current block timestamp is before or equal to the deadline.\n    modifier checkDeadline(uint256 deadline) {\n        (_blockTimestamp() > deadline).revertError(ErrLib.ErrorCode.TOO_OLD_TRANSACTION);\n        _;\n    }\n\n    function _blockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _underlyingQuoterV2,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    )\n        LiquidityManager(\n            _underlyingPositionManagerAddress,\n            _underlyingQuoterV2,\n            _underlyingV3Factory,\n            _underlyingV3PoolInitCodeHash\n        )\n    {}\n\n    /**\n     * @dev Adds or removes a swap call params to the whitelist.\n     * @param swapTarget The address of the target contract for the swap call.\n     * @param funcSelector The function selector of the swap call.\n     * @param isAllowed A boolean indicating whether the swap call is allowed or not.\n     */\n    function setSwapCallToWhitelist(\n        address swapTarget,\n        bytes4 funcSelector,\n        bool isAllowed\n    ) external onlyOwner {\n        (swapTarget == VAULT_ADDRESS ||\n            swapTarget == address(this) ||\n            swapTarget == address(underlyingPositionManager) ||\n            funcSelector == IERC20.transferFrom.selector).revertError(ErrLib.ErrorCode.FORBIDDEN);\n        whitelistedCall[swapTarget][funcSelector] = isAllowed;\n    }\n\n    /**\n     * @notice This function allows the owner to collect protocol fees for multiple tokens\n     * and transfer them to a specified recipient.\n     * @dev Only the contract owner can call this function.\n     * @param recipient The address of the recipient who will receive the collected fees.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectProtocol(address recipient, address[] calldata tokens) external onlyOwner {\n        uint256[] memory amounts = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ) {\n            address token = tokens[i];\n            uint256 amount = platformsFeesInfo[token] / Constants.COLLATERAL_BALANCE_PRECISION;\n            if (amount > 0) {\n                platformsFeesInfo[token] = 0;\n                amounts[i] = amount;\n                Vault(VAULT_ADDRESS).transferToken(token, recipient, amount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit CollectProtocol(recipient, tokens, amounts);\n    }\n\n    /**\n     * @notice This function is used to update the daily rate for holding token for specific pair.\n     * @dev Only the daily rate operator can call this function.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param value The new value of the daily rate for the hold token will be calculated based\n     * on the volatility of the pair and the popularity of loans in it\n     * @dev The value must be within the range of MIN_DAILY_RATE and MAX_DAILY_RATE.\n     */\n    function updateHoldTokenDailyRate(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external {\n        (msg.sender != dailyRateOperator).revertError(ErrLib.ErrorCode.INVALID_CALLER);\n        if (value > Constants.MAX_DAILY_RATE || value < Constants.MIN_DAILY_RATE) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(saleToken, holdToken);\n        holdTokenRateInfo.currentDailyRate = value;\n        emit UpdateHoldTokenDailyRate(saleToken, holdToken, value);\n    }\n\n    /**\n     * @notice This function is used to check the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The key of the borrowing.\n     * @return balance The balance of the daily rate collateral.\n     * @return estimatedLifeTime The estimated lifetime of the collateral in seconds.\n     */\n    function checkDailyRateCollateral(\n        bytes32 borrowingKey\n    ) external view returns (int256 balance, uint256 estimatedLifeTime) {\n        (, balance, estimatedLifeTime) = _getDebtInfo(borrowingKey);\n        balance /= int256(Constants.COLLATERAL_BALANCE_PRECISION);\n    }\n\n    /**\n     * @notice Get information about loans associated with a borrowing key\n     * @dev This function retrieves an array of loan information for a given borrowing key.\n     * The loans are stored in the loansInfo mapping, which is a mapping of borrowing keys to LoanInfo arrays.\n     * @param borrowingKey The unique key associated with the borrowing\n     * @return loans An array containing LoanInfo structs representing the loans associated with the borrowing key\n     */\n    function getLoansInfo(bytes32 borrowingKey) external view returns (LoanIn"
    }
  ]
}