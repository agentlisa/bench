{
  "Title": "[C05] Unfillable orders can be placed to constrain or halt markets",
  "Content": "In the [`FillOrder`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L363) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L363), the `fillOrder` function calls `tradeMakerTokensForFillerTokens` in the [`Trade`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L18) [`library`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L18) located in the same file. The `tradeMakerTokensForFillerTokens` function makes a [transfer](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L197-L199) of `longShareToken` and `shortShareToken` to the `_longBuyer` and `_shortBuyer` respectively. Either the `_longBuyer` or the `_shortBuyer` will be the order `creator` depending on the direction of the trade. Both transfers will trigger the [`tokensReceived`](https://eips.ethereum.org/EIPS/eip-777#erc777tokensrecipient-and-the-tokensreceived-hook) [hook](https://eips.ethereum.org/EIPS/eip-777#erc777tokensrecipient-and-the-tokensreceived-hook) on the recipient if the recipient is an [ERC820-registered](https://eips.ethereum.org/EIPS/eip-820) contract. This means that if the order `creator` is a contract that reverts when `tokensReceived` is called, the order will be unfillable because it will cause `fillOrder` to revert.\n\n\nAccording to Augur v2 whitepaper, “Orders are never executed at a worse price than the limit price set by the trader, but may be executed at a better price.” An unfillable order may severely limit or completely disable a market because it must be filled before an order with a worse price can be filled. This applies to orders on both sides of the order book.\n\n\nAny malicious user can exploit this vulnerability by placing an unfillable order at a price they do not want the market to trade above or below (depending on the direction of the order), thus creating an artificial ceiling or floor on the market. Furthermore, just by placing two unfillable orders, one long, one short, with a very tight spread, the attacker can effectively halt all trading operations in any Augur market.\n\n\nConsider using the [`trustedFillOrderTransfer`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/ShareToken.sol#L59) function instead of `transfer`, both in [line 197](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L197) and [line 199](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L199) of `FillOrder.sol`, to ensure the [`ERC777`](https://eips.ethereum.org/EIPS/eip-777) [`hooks`](https://eips.ethereum.org/EIPS/eip-777) are not called, which should mitigate the described critical vulnerability.\n\n\n***Update:*** *fixed in* [*`98a3f36`*](https://github.com/AugurProject/augur/commit/98a3f369bbf00f8ee9fd392fbe1612fd3c5d66be) *by modifying transfers of Augur’s Share tokens to no longer call the ERC 777 hooks.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/trading/FillOrder.sol",
      "content": "pragma solidity 0.5.4;\n\n\nimport 'ROOT/trading/IFillOrder.sol';\nimport 'ROOT/libraries/ReentrancyGuard.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/trading/ICash.sol';\nimport 'ROOT/trading/ICompleteSets.sol';\nimport 'ROOT/trading/IOrders.sol';\nimport 'ROOT/trading/IShareToken.sol';\nimport 'ROOT/trading/IProfitLoss.sol';\nimport 'ROOT/trading/Order.sol';\nimport 'ROOT/libraries/Initializable.sol';\n\n\n// CONSIDER: At some point it would probably be a good idea to shift much of the logic from trading contracts into extensions. In particular this means sorting for making and WCL calculcations + order walking for taking.\nlibrary Trade {\n    using SafeMathUint256 for uint256;\n\n    enum Direction {\n        Long,\n        Short\n    }\n\n    struct Contracts {\n        IOrders orders;\n        IMarket market;\n        ICompleteSets completeSets;\n        ICash denominationToken;\n        IShareToken longShareToken;\n        IShareToken[] shortShareTokens;\n        IAugur augur;\n    }\n\n    struct FilledOrder {\n        bytes32 orderId;\n        uint256 outcome;\n        ERC20Token kycToken;\n        uint256 sharePriceRange;\n        uint256 sharePriceLong;\n        uint256 sharePriceShort;\n    }\n\n    struct Participant {\n        address participantAddress;\n        Direction direction;\n        uint256 startingSharesToSell;\n        uint256 startingSharesToBuy;\n        uint256 sharesToSell;\n        uint256 sharesToBuy;\n    }\n\n    struct Data {\n        Contracts contracts;\n        FilledOrder order;\n        Participant creator;\n        Participant filler;\n        address affiliateAddress;\n    }\n\n    //\n    // Constructor\n    //\n\n    function create(IAugur _augur, bytes32 _orderId, address _fillerAddress, uint256 _fillerSize, bool _ignoreShares, address _affiliateAddress) internal view returns (Data memory) {\n        Contracts memory _contracts = getContracts(_augur, _orderId);\n        FilledOrder memory _order = getOrder(_contracts, _orderId);\n        Order.Types _orderOrderType = _contracts.orders.getOrderType(_orderId);\n        Participant memory _creator = getMaker(_contracts, _order, _orderOrderType);\n        Participant memory _filler = getFiller(_contracts, _orderOrderType, _fillerAddress, _fillerSize, _ignoreShares);\n\n        return Data({\n            contracts: _contracts,\n            order: _order,\n            creator: _creator,\n            filler: _filler,\n            affiliateAddress: _affiliateAddress\n        });\n    }\n\n    //\n    // \"public\" functions\n    //\n\n    function tradeMakerSharesForFillerShares(Data memory _data) internal returns (uint256, uint256) {\n        uint256 _numberOfCompleteSets = _data.creator.sharesToSell.min(_data.filler.sharesToSell);\n        if (_numberOfCompleteSets == 0) {\n            return (0, 0);\n        }\n\n        // transfer shares to this contract from each participant\n        _data.contracts.longShareToken.trustedFillOrderTransfer(getLongShareSellerSource(_data), address(this), _numberOfCompleteSets);\n        for (uint256 _i = 0; _i < _data.contracts.shortShareTokens.length; ++_i) {\n            _data.contracts.shortShareTokens[_i].trustedFillOrderTransfer(getShortShareSellerSource(_data), address(this), _numberOfCompleteSets);\n        }\n\n        // sell complete sets\n        uint256 _marketCreatorFees;\n        uint256 _reporterFees;\n        (_marketCreatorFees, _reporterFees) = _data.contracts.completeSets.sellCompleteSets(address(this), _data.contracts.market, _numberOfCompleteSets, _data.affiliateAddress);\n\n        // distribute payout proportionately (fees will have been deducted)\n        uint256 _payout = _data.contracts.denominationToken.balanceOf(address(this));\n        uint256 _longShare = _payout.mul(_data.order.sharePriceLong) / _data.order.sharePriceRange;\n        uint256 _shortShare = _payout.sub(_longShare);\n        _data.contracts.denominationToken.transfer(getLongShareSellerDestination(_data), _longShare);\n        _data.contracts.denominationToken.transfer(getShortShareSellerDestination(_data), _shortShare);\n\n        // update available shares for creator and filler\n        _data.creator.sharesToSell -= _numberOfCompleteSets;\n        _data.filler.sharesToSell -= _numberOfCompleteSets;\n        return (_marketCreatorFees, _reporterFees);\n    }\n\n    function tradeMakerSharesForFillerTokens(Data memory _data) internal returns (bool) {\n        uint256 _numberOfSharesToTrade = _data.creator.sharesToSell.min(_data.filler.sharesToBuy);\n        if (_numberOfSharesToTrade == 0) {\n            return true;\n        }\n\n        // transfer shares from creator (escrowed in market) to filler\n        if (_data.creator.direction == Direction.Short) {\n            _data.contracts.longShareToken.trustedFillOrderTransfer(address(_data.contracts.market), _data.filler.participantAddress, _numberOfSharesToTrade);\n        } else {\n            for (uint256 _i = 0; _i < _data.contracts.shortShareTokens.length; ++_i) {\n                _data.contracts.shortShareTokens[_i].trustedFillOrderTransfer(address(_data.contracts.market), _data.filler.participantAddress, _numberOfSharesToTrade);\n            }\n        }\n\n        uint256 _tokensToCover = getTokensToCover(_data, _data.filler.direction, _numberOfSharesToTrade);\n        _data.contracts.augur.trustedTransfer(_data.contracts.denominationToken, _data.filler.participantAddress, _data.creator.participantAddress, _tokensToCover);\n\n        // update available assets for creator and filler\n        _data.creator.sharesToSell -= _numberOfSharesToTrade;\n        _data.filler.sharesToBuy -= _numberOfSharesToTrade;\n        return true;\n    }\n\n    function tradeMakerTokensForFillerShares(Data memory _data) internal returns (bool) {\n        uint256 _numberOfSharesToTrade = _data.filler.sharesToSell.min(_data.creator.sharesToBuy);\n        if (_numberOfSharesToTrade == 0) {\n            return true;\n        }\n\n        // transfer shares from filler to creator\n        if (_data.filler.direction == Direction.Short) {\n            _data.contracts.longShareToken.trustedFillOrderTransfer(_data.filler.participantAddress, _data.creator.participantAddress, _numberOfSharesToTrade);\n        } else {\n            for (uint256 _i = 0; _i < _data.contracts.shortShareTokens.length; ++_i) {\n                _data.contracts.shortShareTokens[_i].trustedFillOrderTransfer(_data.filler.participantAddress, _data.creator.participantAddress, _numberOfSharesToTrade);\n            }\n        }\n\n        // transfer tokens from creator (escrowed in market) to filler\n        uint256 _tokensToCover = getTokensToCover(_data, _data.creator.direction, _numberOfSharesToTrade);\n        _data.contracts.denominationToken.transferFrom(address(_data.contracts.market), _data.filler.participantAddress, _tokensToCover);\n\n        // update available assets for creator and filler\n        _data.creator.sharesToBuy -= _numberOfSharesToTrade;\n        _data.filler.sharesToSell -= _numberOfSharesToTrade;\n        return true;\n    }\n\n    function tradeMakerTokensForFillerTokens(Data memory _data) internal returns (bool) {\n        uint256 _numberOfCompleteSets = _data.creator.sharesToBuy.min(_data.filler.sharesToBuy);\n        if (_numberOfCompleteSets == 0) {\n            return true;\n        }\n\n        // transfer tokens to this contract\n        uint256 _creatorTokensToCover = getTokensToCover(_data, _data.creator.direction, _numberOfCompleteSets);\n        uint256 _fillerTokensToCover = getTokensToCover(_data, _data.filler.direction, _numberOfCompleteSets);\n\n        // If someone is filling their own order with CASH both ways we just return the CASH\n        if (_data.creator.participantAddress == _data.filler.participantAddress) {\n            require(_data.contracts.denominationToken.transferFrom(address(_data.contracts.market), _data.creator.participantAddress, _creatorTokensToCover));\n\n            _data.creator.sharesToBuy -= _numberOfCompleteSets;\n            _data.filler.sharesToBuy -= _numberOfCompleteSets;\n            return true;\n        }\n\n        require(_data.contracts.denominationToken.transferFrom(address(_data.contracts.market), address(this), _creatorTokensToCover));\n        _data.contracts.augur.trustedTransfer(_data.contracts.denominationToken, _data.filler.participantAddress, address(this), _fillerTokensToCover);\n\n        // buy complete sets\n        uint256 _cost = _numberOfCompleteSets.mul(_data.contracts.market.getNumTicks());\n        if (_data.contracts.denominationToken.allowance(address(this), address(_data.contracts.augur)) < _cost) {\n            require(_data.contracts.denominationToken.approve(address(_data.contracts.augur), _cost));\n        }\n        _data.contracts.completeSets.buyCompleteSets(address(this), _data.contracts.market, _numberOfCompleteSets);\n\n        // distribute shares to participants\n        address _longBuyer = getLongShareBuyerDestination(_data);\n        address _shortBuyer = getShortShareBuyerDestination(_data);\n        require(_data.contracts.longShareToken.transfer(_longBuyer, _numberOfCompleteSets));\n        for (uint256 _i = 0; _i < _data.contracts.shortShareTokens.length; ++_i) {\n            require(_data.contracts.shortShareTokens[_i].transfer(_shortBuyer, _numberOfCompleteSets));\n        }\n\n        _data.creator.sharesToBuy -= _numberOfCompleteSets;\n        _data.filler.sharesToBuy -= _numberOfCompleteSets;\n        return true;\n    }\n\n    //\n    // Helpers\n    //\n\n    function getLongShareBuyerDestination(Data memory _data) internal pure returns (address) {\n        return (_data.creator.direction == Direction.Long) ? _data.creator.participantAddress : _data.filler.participantAddress;\n    }\n\n    function getShortShareBuyerDestination(Data memory _data) internal pure returns (address) {\n        return (_data.creator.direction == Direction.Short) ? _data.creator.participantAddress : _data.filler.participantAddress;\n    }\n\n    function getLongShareSellerSource(Data memory _data) internal pure returns (address) {\n        return (_data.creator.direction == Direction.Short) ? address(_data.contracts.market) : _data.filler.participantAddress;\n    }\n\n    function getShortShareSellerSource(Data memory _data) internal pure returns (address) {\n        return (_data.creator.direction == Direction.Long) ? address(_data.contracts.market) : _data.filler.participantAddress;\n    }\n\n    function getLongShareSellerDestination(Data memory _data) internal pure returns (address) {\n        return (_data.creator.direction == Direction.Short) ? _data.creator.participantAddress : _data.filler.participantAddress;\n    }\n\n    function getShortShareSellerDestination(Data memory _data) internal pure returns (address) {\n        return (_data.creator.direction == Direction.Long) ? _data.creator.participantAddress : _data.filler.participantAddress;\n    }\n\n    function getMakerSharesDepleted(Data memory _data) internal pure returns (uint256) {\n        return _data.creator.startingSharesToSell.sub(_data.creator.sharesToSell);\n    }\n\n    function getFillerSharesDepleted(Data memory _data) internal pure returns (uint256) {\n        return _data.filler.startingSharesToSell.sub(_data.filler.sharesToSell);\n    }\n\n    function getMakerTokensDepleted(Data memory _data) internal pure returns (uint256) {\n        return getTokensDepleted(_data, _data.creator.direction, _data.creator.startingSharesToBuy, _data.creator.sharesToBuy);\n    }\n\n    function getFillerTokensDepleted(Data memory _data) internal pure returns (uint256) {\n        return getTokensDepleted(_data, _data.filler.direction, _data.filler.startingSharesToBuy, _data.filler.sharesToBuy);\n    }\n\n    function getTokensDepleted(Data memory _data, Direction _direction, uint256 _startingSharesToBuy, uint256 _endingSharesToBuy) internal pure returns (uint256) {\n        return _startingSharesToBuy\n            .sub(_endingSharesToBuy)\n            .mul((_direction == Direction.Long) ? _data.order.sharePriceLong : _data.order.sharePriceShort);\n    }\n\n    function getTokensToCover(Data memory _data, Direction _direction, uint256 _numShares) internal pure returns (uint256) {\n        return getTokensToCover(_direction, _data.order.sharePriceLong, _data.order.sharePriceShort, _numShares);\n    }\n\n    //\n    // Construction helpers\n    //\n\n    function getContracts(IAugur _augur, bytes32 _orderId) private view returns (Contracts memory) {\n        IOrders _orders = IOrders(_augur.lookup(\"Orders\"));\n        IMarket _market = _orders.getMarket(_orderId);\n        uint256 _outcome = _orders.getOutcome(_orderId);\n        return Contracts({\n            orders: _orders,\n            market: _market,\n            completeSets: ICompleteSets(_augur.lookup(\"CompleteSets\")),\n            denominationToken: ICash(_augur.lookup(\"Cash\")),\n            longShareToken: _market.getShareToken(_outcome),\n            shortShareTokens: getShortShareTokens(_market, _outcome),\n            augur: _augur\n        });\n    }\n\n    function getOrder(Contracts memory _contracts, bytes32 _orderId) private view returns (FilledOrder memory) {\n        uint256 _sharePriceRange;\n        uint256 _sharePriceLong;\n        uint256 _sharePriceShort;\n        (_sharePriceRange, _sharePriceLong, _sharePriceShort) = getSharePriceDetails(_contracts.market, _contracts.orders, _orderId);\n        return FilledOrder({\n            orderId: _orderId,\n            outcome: _contracts.orders.getOutcome(_orderId),\n            kycToken: _contracts.orders.getKYCToken(_orderId),\n            sharePriceRange: _sharePriceRange,\n            sharePriceLong: _sharePriceLong,\n            sharePriceShort: _sharePriceShort\n        });\n    }\n\n    function getMaker(Contracts memory _contracts, FilledOrder memory _order, Order.Types _orderOrderType) private view returns (Participant memory) {\n        Direction _direction = (_orderOrderType == Order.Types.Bid) ? Direction.Long : Direction.Short;\n        uint256 _sharesToSell = _contracts.orders.getOrderSharesEscrowed(_order.orderId);\n        uint256 _sharesToBuy = _contracts.orders.getAmount(_order.orderId).sub(_sharesToSell);\n        return Participant({\n            participantAddress: _contracts.orders.getOrderCreator(_order.orderId),\n            direction: _direction,\n            startingSharesToSell: _sharesToSell,\n            startingSharesToBuy: _sharesToBuy,\n            sharesToSell: _sharesToSell,\n            sharesToBuy: _sharesToBuy\n        });\n    }\n\n    function getFiller(Contracts memory _contracts, Order.Types _orderOrderType, address _address, uint256 _size, bool _ignoreShares) private view returns (Participant memory) {\n        Direction _direction = (_orderOrderType == Order.Types.Bid) ? Direction.Short : Direction.Long;\n        uint256 _sharesToSell = 0;\n        if (!_ignoreShares) {\n            _sharesToSell = getFillerSharesToSell(_contracts.longShareToken, _contracts.shortShareTokens, _address, _direction, _size);\n        }\n        uint256 _sharesToBuy = _size.sub(_sharesToSell);\n        return Participant({\n            participantAddress: _address,\n            direction: _direction,\n            startingSharesToSell: _sharesToSell,\n            startingSharesToBuy: _sharesToBuy,\n            sharesToSell: _sharesToSell,\n            sharesToBuy: _sharesToBuy\n        });\n    }\n\n    function getTokensToCover(Direction _direction, uint256 _sharePriceLong, uint256 _sharePriceShort, uint256 _numShares) internal pure returns (uint256) {\n        return _numShares.mul((_direction == Direction.Long) ? _sharePriceLong : _sharePriceShort);\n    }\n\n    function getShortShareTokens(IMarket _market, uint256 _longOutcome) private view returns (IShareToken[] memory) {\n        IShareToken[] memory _shortShareTokens = new IShareToken[](_market.getNumberOfOutcomes() - 1);\n        for (uint256 _outcome = 0; _outcome < _shortShareTokens.length + 1; ++_outcome) {\n            if (_outcome == _longOutcome) {\n                continue;\n            }\n            uint256 _index = (_outcome < _longOutcome) ? _outcome : _outcome - 1;\n            _shortShareTokens[_index] = _market.getShareToken(_outcome);\n        }\n        return _shortShareTokens;\n    }\n\n    function getSharePriceDetails(IMarket _market, IOrders _orders, bytes32 _orderId) private view returns (uint256 _sharePriceRange, uint256 _sharePriceLong, uint256 _sharePriceShort) {\n        uint256 _numTicks = _market.getNumTicks();\n        uint256 _orderPrice = _orders.getPrice(_orderId);\n        _sharePriceShort = uint256(_numTicks.sub(_orderPrice));\n        return (_numTicks, _orderPrice, _sharePriceShort);\n    }\n\n    function getFillerSharesToSell(IShareToken _longShareToken, IShareToken[] memory _shortShareTokens, address _filler, Direction _fillerDirection, uint256 _fillerSize) private view returns (uint256) {\n        uint256 _sharesAvailable = SafeMathUint256.getUint256Max();\n        if (_fillerDirection == Direction.Short) {\n            _sharesAvailable = _longShareToken.balanceOf(_filler);\n        } else {\n            for (uint256 _outcome = 0; _outcome < _shortShareTokens.length; ++_outcome) {\n                _sharesAvailable = _shortShareTokens[_outcome].balanceOf(_filler).min(_sharesAvailable);\n            }\n        }\n        return _sharesAvailable.min(_fillerSize);\n    }\n}\n\n\ncontract FillOrder is Initializable, ReentrancyGuard, IFillOrder {\n    using SafeMathUint256 for uint256;\n    using Trade for Trade.Data;\n\n    IAugur public augur;\n    IOrders public orders;\n    IProfitLoss public profitLoss;\n    address public trade;\n\n    mapping (address => uint256) public marketVolume;\n\n    function initialize(IAugur _augur) public beforeInitialized returns (bool) {\n        endInitialization();\n        augur = _augur;\n        orders = IOrders(augur.lookup(\"Orders\"));\n        trade = augur.lookup(\"Trade\");\n        profitLoss = IProfitLoss(augur.lookup(\"ProfitLoss\"));\n        return true;\n    }\n\n    function publicFillOrder(bytes32 _orderId, uint256 _amountFillerWants, bytes32 _tradeGroupId, bool _ignoreShares, address _affiliateAddress) external afterInitialized returns (uint256) {\n        uint256 _result = this.fillOrder(msg.sender, _orderId, _amountFillerWants, _tradeGroupId, _ignoreShares, _affiliateAddress);\n        IMarket _market = orders.getMarket(_orderId);\n        _market.assertBalances();\n        return _result;\n    }\n\n    function fillOrder(address _filler, bytes32 _orderId, uint256 _amountFillerWants, bytes32 _tradeGroupId, bool _ignoreShares, address _affiliateAddress) external afterInitialized nonReentrant returns (uint256) {\n        require(msg.sender == trade || msg.sender == address(this));\n        Trade.Data memory _tradeData = Trade.create(augur, _orderId, _filler, _amountFillerWants, _ignoreShares, _affiliateAddress);\n        require(_tradeData.order.kycToken == ERC20Token(0) || _tradeData.order.kycToken.balanceOf(_filler) > 0);\n        uint256 _marketCreatorFees;\n        uint256 _reporterFees;\n        if (!_ignoreShares) {\n            (_marketCreatorFees, _reporterFees) = _tradeData.tradeMakerSharesForFillerShares();\n            _tradeData.tradeMakerTokensForFillerShares();\n        }\n        _tradeData.tradeMakerSharesForFillerTokens();\n        _tradeData.tradeMakerTokensForFillerTokens();\n\n        // Sell any complete sets the maker or filler may have ended up holding\n        if (!_ignoreShares) {\n            sellCompleteSets(_tradeData);\n        }\n\n        uint256 _amountRemainingFillerWants = _tradeData.filler.sharesToSell.add(_tradeData.filler.sharesToBuy);\n        uint256 _amountFilled = _amountFillerWants.sub(_amountRemainingFillerWants);\n        logOrderFilled(_tradeData, _marketCreatorFees, _reporterFees, _amountFilled, _tradeGroupId);\n        logAndUpdateVolume(_tradeData);\n        updateProfitLoss(_tradeData, _amountFilled);\n        _tradeData.contracts.orders.recordFillOrder(_orderId, _tradeData.getMakerSharesDepleted(), _tradeData.getMakerTokensDepleted(), _amountFilled);\n        return _amountRemainingFillerWants;\n    }\n\n    function sellCompleteSets(Trade.Data memory _tradeData) internal returns (bool) {\n        address _filler = _tradeData.filler.participantAddress;\n        address _creator = _tradeData.creator.participantAddress;\n        IMarket _market = _tradeData.contracts.market;\n\n        uint256 _fillerCompleteSets = _market.getShareToken(0).balanceOf(_filler);\n        uint256 _creatorCompleteSets = _market.getShareToken(0).balanceOf(_creator);\n\n        for (uint256 _outcome = 1; _outcome < _market.getNumberOfOutcomes(); ++_outcome) {\n            IShareToken _shareToken = _market.getShareToken(_outcome);\n            _creatorCompleteSets = _creatorCompleteSets.min(_shareToken.balanceOf(_creator));\n            _fillerCompleteSets = _fillerCompleteSets.min(_shareToken.balanceOf(_filler));\n        }\n\n        if (_fillerCompleteSets > 0) {\n            _tradeData.contracts.completeSets.sellCompleteSets(_filler, _market, _fillerCompleteSets, _tradeData.affiliateAddress);\n        }\n\n        if (_creatorCompleteSets > 0) {\n            _tradeData.contracts.completeSets.sellCompleteSets(_creator, _market, _creatorCompleteSets, _tradeData.affiliateAddress);\n        }\n\n        return true;\n    }\n\n    function logOrderFilled(Trade.Data memory _tradeData, uint256 _marketCreatorFees, uint256 _reporterFees, uint256 _amountFilled, bytes32 _tradeGroupId) private returns (bool) {\n        augur.logOrderFilled(_tradeData.contracts.market.getUniverse(), address(_tradeData.contracts.longShareToken), _tradeData.filler.participantAddress, _tradeData.order.orderId, _tradeData.getMakerSharesDepleted(), _tradeData.getMakerTokensDepleted(), _tradeData.getFillerSharesDepleted(), _tradeData.getFillerTokensDepleted(), _marketCreatorFees, _reporterFees, _amountFilled, _tradeGroupId);\n        return true;\n    }\n\n    function logAndUpdateVolume(Trade.Data memory _tradeData) private returns (uint256) {\n        IMarket _market = _tradeData.contracts.market;\n        uint256 _volume = marketVolume[address(_market)];\n        uint256 _makerSharesDepleted = _tradeData.getMakerSharesDepleted();\n        uint256 _fillerSharesDepleted = _tradeData.getFillerSharesDepleted();\n        uint256 _makerTokensDepleted = _tradeData.getMakerTokensDepleted();\n        uint256 _fillerTokensDepleted = _tradeData.getFillerTokensDepleted();\n        uint256 _completeSetTokens = _makerSharesDepleted.min(_fillerSharesDepleted).mul(_market.getNumTicks());\n        _volume = _volume.add(_makerTokensDepleted).add(_fillerTokensDepleted).add(_completeSetTokens);\n        marketVolume[address(_market)] = _volume;\n        augur.logMarketVolumeChanged(_tradeData.contracts.market.getUniverse(), address(_market), _volume);\n        return _volume;\n    }\n\n    function updateProfitLoss(Trade.Data memory _tradeData, uint256 _amountFilled) private returns (bool) {\n        uint256 _numLongTokens = _tradeData.creator.direction == Trade.Direction.Long ? _tradeData.getMakerTokensDepleted() : _tradeData.getFillerTokensDepleted();\n        uint256 _numShortTokens = _tradeData.creator.direction == Trade.Direction.Short ? _tradeData.getMakerTokensDepleted() : _tradeData.getFillerTokensDepleted();\n        uint256 _numLongShares = _tradeData.creator.direction == Trade.Direction.Long ? _tradeData.getMakerSharesDepleted() : _tradeData.getFillerSharesDepleted();\n        uint256 _numShortShares = _tradeData.creator.direction == Trade.Direction.Short ? _tradeData.getMakerSharesDepleted() : _tradeData.getFillerSharesDepleted();\n        profitLoss.recordTrade(_tradeData.contracts.market, _tradeData.getLongShareBuyerDestination(), _tradeData.getShortShareBuyerDestination(), _tradeData.order.outcome, int256(_amountFilled), int256(_tradeData.order.sharePriceLong), _numLongTokens, _numShortTokens, _numLongShares, _numShortShares);\n        return true;\n    }\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/trading/ShareToken.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/IERC820Registry.sol';\nimport 'ROOT/trading/IShareToken.sol';\nimport 'ROOT/libraries/token/VariableSupplyToken.sol';\nimport 'ROOT/libraries/ITyped.sol';\nimport 'ROOT/libraries/Initializable.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/IAugur.sol';\n\n\ncontract ShareToken is ITyped, Initializable, VariableSupplyToken, IShareToken {\n\n    string constant public name = \"Shares\";\n    string constant public symbol = \"SHARE\";\n\n    IMarket private market;\n    uint256 private outcome;\n\n    IAugur public augur;\n    address public createOrder;\n    address public fillOrder;\n    address public cancelOrder;\n    address public completeSets;\n    address public claimTradingProceeds;\n\n    function initialize(IAugur _augur, IMarket _market, uint256 _outcome, address _erc820RegistryAddress) external beforeInitialized returns(bool) {\n        endInitialization();\n        market = _market;\n        outcome = _outcome;\n        augur = _augur;\n        createOrder = _augur.lookup(\"CreateOrder\");\n        fillOrder = _augur.lookup(\"FillOrder\");\n        cancelOrder = _augur.lookup(\"CancelOrder\");\n        completeSets = _augur.lookup(\"CompleteSets\");\n        claimTradingProceeds = _augur.lookup(\"ClaimTradingProceeds\");\n        erc820Registry = IERC820Registry(_erc820RegistryAddress);\n        initialize820InterfaceImplementations();\n        return true;\n    }\n\n    function createShares(address _owner, uint256 _fxpValue) external afterInitialized returns(bool) {\n        require(msg.sender == completeSets);\n        mint(_owner, _fxpValue);\n        return true;\n    }\n\n    function destroyShares(address _owner, uint256 _fxpValue) external afterInitialized returns(bool) {\n        require(msg.sender == completeSets || msg.sender == claimTradingProceeds);\n        burn(_owner, _fxpValue);\n        return true;\n    }\n\n    function trustedOrderTransfer(address _source, address _destination, uint256 _attotokens) public afterInitialized returns (bool) {\n        require(msg.sender == createOrder);\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedFillOrderTransfer(address _source, address _destination, uint256 _attotokens) public afterInitialized returns (bool) {\n        require(msg.sender == fillOrder);\n        // We do not call ERC777 hooks here as it would allow a malicious order creator to halt trading\n        return internalTransfer(_source, _destination, _attotokens, false);\n    }\n\n    function trustedCancelOrderTransfer(address _source, address _destination, uint256 _attotokens) public afterInitialized returns (bool) {\n        require(msg.sender == cancelOrder);\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function getTypeName() public view returns(bytes32) {\n        return \"ShareToken\";\n    }\n\n    function getMarket() external view returns(IMarket) {\n        return market;\n    }\n\n    function getOutcome() external view returns(uint256) {\n        return outcome;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        augur.logShareTokensTransferred(market.getUniverse(), _from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function onMint(address _target, uint256 _amount) internal returns (bool) {\n        augur.logShareTokensMinted(market.getUniverse(), _target, _amount, totalSupply());\n        return true;\n    }\n\n    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n        augur.logShareTokensBurned(market.getUniverse(), _target, _amount, totalSupply());\n        return true;\n    }\n}"
    }
  ]
}