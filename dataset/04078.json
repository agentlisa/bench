{
  "Title": "[M04] Token fees can lead to incorrect calculations",
  "Content": "Certain tokens, such as USDT, have the ability to [charge fees on transfers](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code). Although the fee rate is currently `0`, this may change in the future. The result of this is that if `x` tokens are transferred, an amount less than `x` will be received. For any functions which utilize `transferFrom`, the expectation that the amount received will match the amount transferred cannot be relied upon.\n\n\nWithin `SwapUtils` functions [`swap`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L637-L638) and [`addLiquidity`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L713-L714) the [`safeTransferFrom`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/837828967a9831e4333d5fb9edefb200a357d24d/contracts/token/ERC20/SafeERC20.sol#L24) function is called to `transferFrom` tokens into the Saddle pool contract. While `safeTransferFrom` does provide error handling for unsuccessful calls, it will provide no indication of whether a token charges internal fees on transfers.\n\n\nFor tokens which may charge fees on transfers, consider checking the recipientâ€™s balance before and after `safeTransferFrom` calls, and using the change in balance for any calculations which may follow. In both cases mentioned above, the transfer of fee-charging tokens should occur before any relevant calculations are made, to avoid calculations which assume more tokens were received than actually were. For reference, the [Curve 3pool Pool](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pools/3pool/StableSwap3Pool.vy) uses a variable called [`FEE_INDEX`](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pools/3pool/StableSwap3Pool.vy#L83) to identify USDT as a token which may charge fees, and incorporates `FEE_INDEX` into logic accordingly.\n\n\n***Update:** Fixed in [pull request 191](https://github.com/saddle-finance/saddle-contract/pull/191/files#diff-b10206d740152912f7a57cdfc48fd115bbd5ca6e4eb37a60ae867efb39d19d44R648).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/SwapUtils.sol",
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./LPToken.sol\";\nimport \"./MathUtils.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtils {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using MathUtils for uint256;\n\n    /*** EVENTS ***/\n\n    event TokenSwap(address indexed buyer, uint256 tokensSold,\n        uint256 tokensBought, uint128 soldId, uint128 boughtId\n    );\n    event AddLiquidity(address indexed provider, uint256[] tokenAmounts,\n        uint256[] fees, uint256 invariant, uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(address indexed provider, uint256 lpTokenAmount,\n        uint256 lpTokenSupply, uint256 boughtId, uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(address indexed provider,\n        uint256[] tokenAmounts, uint256[] fees, uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n    event StopRampA(uint256 A, uint256 time);\n\n    struct Swap {\n        // variables around the ramp management of A,\n        // the amplification coefficient * n * (n - 1)\n        // see https://www.curve.fi/stableswap-paper.pdf for details\n        uint256 initialA;\n        uint256 futureA;\n        uint256 initialATime;\n        uint256 futureATime;\n\n        // fee calculation\n        uint256 swapFee;\n        uint256 adminFee;\n        uint256 defaultWithdrawFee;\n\n        LPToken lpToken;\n\n        // contract references for all tokens being pooled\n        IERC20[] pooledTokens;\n\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n        uint256[] tokenPrecisionMultipliers;\n\n        // the pool balance of each token, in the token's precision\n        // the contract's actual token balance might differ\n        uint256[] balances;\n\n        mapping(address => uint256) depositTimestamp;\n        mapping(address => uint256) withdrawFeeMultiplier;\n    }\n\n    // Struct storing variables used in calculation in calculateWithdrawOneTokenDY function\n    // to avoid stack too deep error\n    struct CalculateWithdrawOneTokenDYInfo {\n        uint256 D0;\n        uint256 D1;\n        uint256 newY;\n        uint256 feePerToken;\n    }\n\n    // the precision all pools tokens will be converted to\n    uint8 private constant POOL_PRECISION_DECIMALS = 18;\n\n    // the denominator used to calculate admin and LP fees. For example, an\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n    uint256 private constant FEE_DENOMINATOR = 10 ** 10;\n\n    // Max swap fee is 1% or 100bps of each swap\n    uint256 private constant MAX_SWAP_FEE = 10 ** 8;\n\n    // Max adminFee is 100% of the swapFee\n    // adminFee does not add additional fee on top of swapFee\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n    // users but only on the earnings of LPs\n    uint256 private constant MAX_ADMIN_FEE = 10 ** 10;\n\n    // Max withdrawFee is 1% of the value withdrawn\n    // Fee will be redistributed to the LPs in the pool, rewarding\n    // long term providers.\n    uint256 private constant MAX_WITHDRAW_FEE = 10 ** 8;\n\n    // Constant value used as max loop limit\n    uint256 private constant MAX_LOOP_LIMIT = 256;\n\n    // Constant values used in ramping A calculations\n    uint256 private constant A_PRECISION = 100;\n    uint256 private constant MAX_A = 10 ** 6;\n    uint256 private constant MAX_A_CHANGE = 2;\n    uint256 private constant MIN_RAMP_TIME = 14 days;\n\n    /*** VIEW & PURE FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function getA(Swap storage self) external view returns (uint256) {\n        return _getA(self);\n    }\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function _getA(Swap storage self) internal view returns (uint256) {\n        return _getAPrecise(self).div(A_PRECISION);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise(Swap storage self) external view returns (uint256) {\n        return _getAPrecise(self);\n    }\n\n    /**\n     * @notice Calculates and returns A based on the ramp settings\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\n        uint256 t1 = self.futureATime;\n        uint256 A1 = self.futureA;\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialATime;\n            uint256 A0 = self.initialA;\n            if (A1 > A0) {\n                // A0 + (A1 - A0) * (block.timestamp - t0) / (t1 - t0)\n                return A0.add(A1.sub(A0).mul(block.timestamp.sub(t0)).div(t1.sub(t0)));\n            } else {\n                // A0 - (A0 - A1) * (block.timestamp - t0) / (t1 - t0)\n                return A0.sub(A0.sub(A1).mul(block.timestamp.sub(t0)).div(t1.sub(t0)));\n            }\n        } else {\n            return A1;\n        }\n    }\n\n    /**\n     * @notice Returns POOL_PRECISION_DECIMALS, the decimals of all underlying tokens to scaled to\n     * @return precision decimals of all pool tokens to be converted to\n     */\n    function getPoolPrecisionDecimals() external pure returns (uint8) {\n        return POOL_PRECISION_DECIMALS;\n    }\n\n    /**\n     * @notice Returns A_PRECISION, precision used for ramp calculations. This value should be constant.\n     * @return precision of A calculation\n     */\n    function getAPrecision() external pure returns (uint256) {\n        return A_PRECISION;\n    }\n\n    /**\n     * @notice Retrieves the timestamp of last deposit made by the given address\n     * @return timestamp of last deposit\n     */\n    function getDepositTimestamp(Swap storage self, address user) external view returns (uint256) {\n        return self.depositTimestamp[user];\n    }\n\n    /**\n     * @notice Calculate the dy and fee of withdrawing in one token\n     * @param tokenAmount the amount to withdraw in the pool's precision\n     * @param tokenIndex which token will be withdrawn\n     * @return the dy and the associated fee\n     */\n    function calculateWithdrawOneToken(\n        Swap storage self, uint256 tokenAmount, uint8 tokenIndex\n    ) public view returns(uint256, uint256) {\n\n        uint256 dy;\n        uint256 newY;\n\n        (dy, newY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount);\n\n        // dy_0 (without fees)\n        // dy, dy_0 - dy\n        return (dy, _xp(self)[tokenIndex].sub(newY).div(\n            self.tokenPrecisionMultipliers[tokenIndex]).sub(dy));\n    }\n\n    /**\n     * @notice Calculate the dy of withdrawing in one token\n     * @param tokenIndex which token will be withdrawn\n     * @param tokenAmount the amount to withdraw in the pools precision\n     * @return the d and the new y after withdrawing one token\n     */\n    function calculateWithdrawOneTokenDY(\n        Swap storage self, uint8 tokenIndex, uint256 tokenAmount\n    ) internal view returns(uint256, uint256) {\n        require(tokenIndex < self.pooledTokens.length, \"Token index out of range\");\n\n        // Get the current D, then solve the stableswap invariant\n        // y_i for D - tokenAmount\n        uint256[] memory xp = _xp(self);\n        CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0);\n        v.D0 = getD(xp, _getAPrecise(self));\n        v.D1 = v.D0.sub(tokenAmount.mul(v.D0).div(self.lpToken.totalSupply()));\n\n        require(tokenAmount <= xp[tokenIndex], \"Cannot withdraw more than available\");\n\n        v.newY = getYD(_getAPrecise(self), tokenIndex, xp, v.D1);\n\n        uint256[] memory xpReduced = new uint256[](xp.length);\n\n        v.feePerToken = feePerToken(self);\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 xpi = xp[i];\n            // if i == tokenIndex, dxExpected = xp[i] * D1 / D0 - newY\n            // else dxExpected = xp[i] - (xp[i] * D1 / D0)\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n            xpReduced[i] = xpi.sub(\n                ((i == tokenIndex) ?\n                    xpi.mul(v.D1).div(v.D0).sub(v.newY) :\n                    xpi.sub(xpi.mul(v.D1).div(v.D0))\n                ).mul(v.feePerToken).div(FEE_DENOMINATOR));\n        }\n\n        uint256 dy = xpReduced[tokenIndex].sub(\n            getYD(_getAPrecise(self), tokenIndex, xpReduced, v.D1));\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\n\n        return (dy, v.newY);\n    }\n\n    /**\n     * @notice Calculate the price of a token in the pool given\n     * precision-adjusted balances and a particular D and precision-adjusted\n     * array of balances.\n     *\n     * @dev This is accomplished via solving the quadratic equation iteratively.\n     * See the StableSwap paper and Curve.fi implementation for further details.\n     *\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n     * x_1**2 + b*x_1 = c\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\n     *\n     * @param _A the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n     * @param tokenIndex Index of token we are calculating for.\n     * @param xp a precision-adjusted set of pool balances. Array should be\n     * the same cardinality as the pool.\n     * @param D the stableswap invariant\n     * @return the price of the token, in the same precision as in xp\n     */\n    function getYD(uint256 _A, uint8 tokenIndex, uint256[] memory xp, uint256 D)\n        internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 c = D;\n        uint256 s;\n        uint256 nA = _A.mul(numTokens);\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i != tokenIndex) {\n                s = s.add(xp[i]);\n                c = c.mul(D).div(xp[i].mul(numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // c = c * D * D * D * ... overflow!\n            } else {\n                continue;\n            }\n        }\n        c = c.mul(D).div(nA.mul(numTokens).div(A_PRECISION));\n\n        uint256 b = s.add(D.mul(A_PRECISION).div(nA));\n        uint256 yPrev;\n        uint256 y = D;\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(D));\n            if(y.within1(yPrev)) {\n                break;\n            }\n        }\n        return y;\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n     * as the pool.\n     * @param _A the amplification coefficient * n * (n - 1) in A_PRECISION.\n     * See the StableSwap paper for details\n     * @return the invariant, at the precision of the pool\n     */\n    function getD(uint256[] memory xp, uint256 _A)\n        internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        uint256 s;\n        for (uint256 i = 0; i < numTokens; i++) {\n            s = s.add(xp[i]);\n        }\n        if (s == 0) {\n            return 0;\n        }\n\n        uint256 prevD;\n        uint256 D = s;\n        uint256 nA = _A.mul(numTokens);\n\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            uint256 dP = D;\n            for (uint256 j = 0; j < numTokens; j++) {\n                dP = dP.mul(D).div(xp[j].mul(numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // dP = dP * D * D * D * ... overflow!\n            }\n            prevD = D;\n            D = nA.mul(s).div(A_PRECISION).add(dP.mul(numTokens)).mul(D).div(\n                nA.div(A_PRECISION).sub(1).mul(D).add(numTokens.add(1).mul(dP)));\n            if (D.within1(prevD)) {\n                break;\n            }\n        }\n        return D;\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on self Swap struct\n     * @return The invariant, at the precision of the pool\n     */\n    function getD(Swap storage self)\n        internal view returns (uint256) {\n        return getD(_xp(self), _getAPrecise(self));\n    }\n\n    /**\n     * @notice Given a set of balances and precision multipliers, return the\n     * precision-adjusted balances.\n     *\n     * @param _balances an array of token balances, in their native precisions.\n     * These should generally correspond with pooled tokens.\n     *\n     * @param precisionMultipliers an array of multipliers, corresponding to\n     * the amounts in the _balances array. When multiplied together they\n     * should yield amounts at the pool's precision.\n     *\n     * @return an array of amounts \"scaled\" to the pool's precision\n     */\n    function _xp(\n        uint256[] memory _balances,\n        uint256[] memory precisionMultipliers\n    ) internal pure returns (uint256[] memory) {\n        uint256 numTokens = _balances.length;\n        require(\n            numTokens == precisionMultipliers.length,\n            \"Balances must map to token precision multipliers\"\n        );\n        uint256[] memory xp = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; i++) {\n            xp[i] = _balances[i].mul(precisionMultipliers[i]);\n        }\n        return xp;\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param _balances array of balances to scale\n     * @return _balances array \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(Swap storage self, uint256[] memory _balances)\n        internal view returns (uint256[] memory) {\n        return _xp(_balances, self.tokenPrecisionMultipliers);\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice(Swap storage self) external view returns (uint256) {\n        uint256 D = getD(_xp(self), _getAPrecise(self));\n        uint256 supply = self.lpToken.totalSupply();\n        return D.mul(10 ** uint256(ERC20Detailed(self.lpToken).decimals())).div(supply);\n    }\n\n    /**\n     * @notice Calculate the new balances of the tokens given the indexes of the token\n     * that is swapped from (FROM) and the token that is swapped to (TO).\n     * This function is used as a helper function to calculate how much TO token\n     * the user should receive on swap.\n     *\n     * @param tokenIndexFrom index of FROM token\n     * @param tokenIndexTo index of TO token\n     * @param x the new total amount of FROM token\n     * @param xp balances of the tokens in the pool\n     * @return the amount of TO token that should remain in the pool\n     */\n    function getY(\n        Swap storage self, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 x,\n        uint256[] memory xp\n    ) internal view returns (uint256) {\n        uint256 numTokens = self.pooledTokens.length;\n        require(tokenIndexFrom != tokenIndexTo, \"Can't compare token to itself\");\n        require(\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\n            \"Tokens must be in pool\"\n        );\n\n        uint256 _A = _getAPrecise(self);\n        uint256 D = getD(xp, _A);\n        uint256 c = D;\n        uint256 s;\n        uint256 nA = numTokens.mul(_A);\n\n        uint256 _x;\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i == tokenIndexFrom) {\n                _x = x;\n            } else if (i != tokenIndexTo) {\n                _x = xp[i];\n            }\n            else {\n                continue;\n            }\n            s = s.add(_x);\n            c = c.mul(D).div(_x.mul(numTokens));\n            // If we were to protect the division loss we would have to keep the denominator separate\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\n            // c = c * D * D * D * ... overflow!\n        }\n        c = c.mul(D).div(nA.mul(numTokens).div(A_PRECISION));\n        uint256 b = s.add(D.mul(A_PRECISION).div(nA));\n        uint256 yPrev;\n        uint256 y = D;\n\n        // iterative approximation\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(D));\n            if (y.within1(yPrev)) {\n                break;\n            }\n        }\n        return y;\n    }\n\n    /**\n     * @notice Externally calculates a swap between two tokens.\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell\n     * @return dy the number of tokens the user will get\n     */\n    function calculateSwap(\n        Swap storage self, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx\n    ) external view returns(uint256 dy) {\n        (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx);\n    }\n\n    /**\n     * @notice Internally calculates a swap between two tokens.\n     *\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\n     * using the token contracts.\n     *\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell\n     * @return dy the number of tokens the user will get\n     * @return dyFee the associated fee\n     */\n    function _calculateSwap(\n        Swap storage self, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx\n    ) internal view returns(uint256 dy, uint256 dyFee) {\n        uint256[] memory xp = _xp(self);\n        require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\");\n        uint256 x = dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]).add(\n            xp[tokenIndexFrom]);\n        uint256 y = getY(self, tokenIndexFrom, tokenIndexTo, x, xp);\n        dy = xp[tokenIndexTo].sub(y).sub(1);\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n        dy = dy.sub(dyFee).div(self.tokenPrecisionMultipliers[tokenIndexTo]);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of\n     * LP tokens\n     *\n     * @param amount the amount of LP tokens that would to be burned on\n     * withdrawal\n     */\n    function calculateRemoveLiquidity(Swap storage self, uint256 amount)\n    external view returns (uint256[] memory) {\n        return _calculateRemoveLiquidity(self, amount);\n    }\n\n    function _calculateRemoveLiquidity(Swap storage self, uint256 amount)\n    internal view returns (uint256[] memory) {\n        uint256 totalSupply = self.lpToken.totalSupply();\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\n        uint256[] memory amounts = new uint256[](self.pooledTokens.length);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            amounts[i] = self.balances[i].mul(amount).div(totalSupply);\n        }\n        return amounts;\n    }\n\n    /**\n     * @notice Calculate the fee that is applied when the given user withdraws.\n     * Withdraw fee decays linearly over 4 weeks.\n     * @param user address you want to calculate withdraw fee of\n     * @return current withdraw fee of the user\n     */\n    function calculateCurrentWithdrawFee(Swap storage self, address user) public view returns (uint256) {\n        uint256 endTime = self.depositTimestamp[user].add(4 weeks);\n        if (endTime > block.timestamp) {\n            uint256 timeLeftover = endTime.sub(block.timestamp);\n            return self.defaultWithdrawFee\n            .mul(self.withdrawFeeMultiplier[user])\n            .mul(timeLeftover)\n            .div(4 weeks)\n            .div(FEE_DENOMINATOR);\n        }\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision\n     * @param deposit whether this is a deposit or a withdrawal\n     */\n    function calculateTokenAmount(\n        Swap storage self, uint256[] calldata amounts, bool deposit\n    ) external view returns(uint256) {\n        uint256 numTokens = self.pooledTokens.length;\n        uint256 _A = _getAPrecise(self);\n        uint256 D0 = getD(_xp(self, self.balances), _A);\n        uint256[] memory balances1 = self.balances;\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (deposit) {\n                balances1[i] = balances1[i].add(amounts[i]);\n            } else {\n                require(amounts[i] <= balances1[i], \"Cannot withdraw more than available\");\n                balances1[i] = balances1[i].sub(amounts[i]);\n            }\n        }\n        uint256 D1 = getD(_xp(self, balances1), _A);\n        uint256 totalSupply = self.lpToken.totalSupply();\n        return (deposit ? D1.sub(D0) : D0.sub(D1)).mul(totalSupply).div(D0);\n    }\n\n    /**\n     * @notice return accumulated amount of admin fees of the token with given index\n     * @param index Index of the pooled token\n     * @return admin balance in the token's precision\n     */\n    function getAdminBalance(Swap storage self, uint256 index) external view returns (uint256) {\n        require(index < self.pooledTokens.length, \"Token index out of range\");\n        return self.pooledTokens[index].balanceOf(address(this)).sub(self.balances[index]);\n    }\n\n    /**\n     * @notice internal helper function to calculate fee per token multiplier used in\n     * swap fee calculations\n     */\n    function feePerToken(Swap storage self)\n    internal view returns(uint256) {\n        return self.swapFee.mul(self.pooledTokens.length).div(\n            self.pooledTokens.length.sub(1).mul(4));\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice swap two tokens in the pool\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @param minDy the min amount the user would like to receive, or revert.\n     */\n    function swap(\n        Swap storage self, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx,\n        uint256 minDy\n    ) external {\n        require(dx <= self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender), \"Cannot swap more than you own\");\n        (uint256 dy, uint256 dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx);\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n        uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(self.tokenPrecisionMultipliers[tokenIndexTo]);\n\n        self.balances[tokenIndexFrom] = self.balances[tokenIndexFrom].add(dx);\n        self.balances[tokenIndexTo] = self.balances[tokenIndexTo].sub(dy).sub(dyAdminFee);\n\n        self.pooledTokens[tokenIndexFrom].safeTransferFrom(\n            msg.sender, address(this), dx);\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n        emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     */\n    function addLiquidity(Swap storage self, uint256[] calldata amounts, uint256 minToMint)\n        external {\n        require(\n            amounts.length == self.pooledTokens.length,\n            \"Amounts must map to pooled tokens\"\n        );\n\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\n\n        // current state\n        uint256 D0;\n        if (self.lpToken.totalSupply() != 0) {\n            D0 = getD(self);\n        }\n        uint256[] memory newBalances = self.balances;\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            require(\n                self.lpToken.totalSupply() != 0 || amounts[i] > 0,\n                \"If token supply is zero, must supply all tokens in pool\"\n            );\n            newBalances[i] = self.balances[i].add(amounts[i]);\n        }\n\n        // invariant after change\n        uint256 D1 = getD(_xp(self, newBalances), _getAPrecise(self));\n        require(D1 > D0, \"D should increase after additional liquidity\");\n\n        // updated to reflect fees and calculate the user's LP tokens\n        uint256 D2 = D1;\n        if (self.lpToken.totalSupply() != 0) {\n            uint256 feePerToken_ = feePerToken(self);\n            for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n                uint256 idealBalance = D1.mul(self.balances[i]).div(D0);\n                fees[i] = feePerToken_.mul(\n                    idealBalance.difference(newBalances[i])).div(FEE_DENOMINATOR);\n                self.balances[i] = newBalances[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR));\n                newBalances[i] = newBalances[i].sub(fees[i]);\n            }\n            D2 = getD(_xp(self, newBalances), _getAPrecise(self));\n        } else {\n            // the initial depositor doesn't pay fees\n            self.balances = newBalances;\n        }\n\n        uint256 toMint;\n        if (self.lpToken.totalSupply() == 0) {\n            toMint = D1;\n        } else {\n            toMint = D2.sub(D0).mul(self.lpToken.totalSupply()).div(D0);\n        }\n\n        require(toMint >= minToMint, \"Couldn't mint min requested LP tokens\");\n\n        // Update msg.sender's withdraw fee\n        _updateUserWithdrawFee(self, msg.sender, toMint);\n\n        // mint the user's LP tokens\n        self.lpToken.mint(msg.sender, toMint);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            if (amounts[i] != 0) {\n                self.pooledTokens[i].safeTransferFrom(\n                    msg.sender, address(this), amounts[i]);\n            }\n        }\n\n        emit AddLiquidity(\n            msg.sender, amounts, fees, D1, self.lpToken.totalSupply()\n        );\n    }\n\n    /**\n     * @notice Update the withdraw fee for `user`. If the user is currently\n     * not providing liquidity in the pool, sets to default value. If not, recalculate\n     * the starting withdraw fee based on the last deposit's time & amount relative\n     * to the new deposit.\n     *\n     * @param user address of the user depositing tokens\n     * @param toMint amount of pool tokens to be minted\n     */\n    function updateUserWithdrawFee(Swap storage self, address user, uint256 toMint) external {\n        _updateUserWithdrawFee(self, user, toMint);\n    }\n\n    function _updateUserWithdrawFee(Swap storage self, address user, uint256 toMint) internal {\n        uint256 currentFee = calculateCurrentWithdrawFee(self, user);\n        uint256 currentBalance = self.lpToken.balanceOf(user);\n\n        // (currentBalance * currentFee + (toMint * (defaultWithdrawFee + 1))) * FEE_DENOMINATOR /\n        // ((toMint + currentBalance) * (defaultWithdrawFee + 1))\n        self.withdrawFeeMultiplier[user] = currentBalance.mul(currentFee)\n            .add(toMint.mul(self.defaultWithdrawFee.add(1))).mul(FEE_DENOMINATOR)\n            .div(toMint.add(currentBalance).mul(self.defaultWithdrawFee.add(1)));\n\n        self.depositTimestamp[user] = block.timestamp;\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     * acceptable for this burn. Useful as a front-running mitigation\n     */\n    function removeLiquidity(\n        Swap storage self, uint256 amount, uint256[] calldata minAmounts\n    ) external {\n        require(amount <= self.lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(\n            minAmounts.length == self.pooledTokens.length,\n            \"Min amounts should correspond to pooled tokens\"\n        );\n\n        uint256 adjustedAmount = amount\n            .mul(FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender)))\n            .div(FEE_DENOMINATOR);\n\n        uint256[] memory amounts = _calculateRemoveLiquidity(self, adjustedAmount);\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            require(\n                amounts[i] >= minAmounts[i],\n                \"Resulted in fewer tokens than expected\"\n            );\n            self.balances[i] = self.balances[i].sub(amounts[i]);\n        }\n\n        self.lpToken.burnFrom(msg.sender, amount);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidity(\n            msg.sender, amounts, self.lpToken.totalSupply()\n        );\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token.\n     * @param tokenAmount the amount of the token you want to receive\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     */\n    function removeLiquidityOneToken(\n        Swap storage self, uint256 tokenAmount, uint8 tokenIndex,\n        uint256 minAmount\n    ) external {\n        uint256 totalSupply = self.lpToken.totalSupply();\n        uint256 numTokens = self.pooledTokens.length;\n        require(tokenAmount <= self.lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 dyFee;\n        uint256 dy;\n\n        (dy, dyFee) = calculateWithdrawOneToken(self, tokenAmount, tokenIndex);\n        dy = dy\n        .mul(FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender)))\n        .div(FEE_DENOMINATOR);\n\n        require(dy >= minAmount, \"The min amount of tokens wasn't met\");\n\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(\n            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\n        );\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\n        self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\n\n        emit RemoveLiquidityOne(\n            msg.sender, tokenAmount, totalSupply, tokenIndex, dy\n        );\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances.\n     *\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     */\n    function removeLiquidityImbalance(\n        Swap storage self, uint256[] memory amounts,"
    }
  ]
}