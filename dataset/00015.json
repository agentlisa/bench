{
  "Title": "`TSender.huff` and `TSender_NoCheck.huff` contracts will transfer funds to wrong addresses when called with specific calldata.",
  "Content": "# `TSender.huff` and `TSender_NoCheck.huff` contracts will transfer funds to wrong addresses when called with specific calldata.\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-TSender/blob/c6da9ef0c28741c007a02dfa07b7e899c1c22e47/src/protocol/TSender.huff#L115-L135\">https://github.com/Cyfrin/2024-05-TSender/blob/c6da9ef0c28741c007a02dfa07b7e899c1c22e47/src/protocol/TSender.huff#L115-L135</a>\n\n\n## Summary\nDue to a mismatch of hardcoded and dynamic calldata offsets in the `TSender.huff` and `TSender_NoCheck.huff` contracts, both contracts transfer funds to incorrect addresses when called with specific calldata.\n\n## Vulnerability Details\nThe Huff code (`TSender.huff` and `TSender_NoCheck.huff`) hardcodes certain calldata offset values (e.g., `RECIPIENT_ONE_OFFSET = 0xa4`). However, the offset of dynamic types like arrays is not fixed in calldata, leading to incorrect code execution if the calldata is formatted differently than expected.\n\nThe current ABI encoding used by Solidity and Vyper does not enforce a fixed order for dynamic type offsets. As a result, both calldata examples below are valid and decoded equivalently by the reference and Yul contracts (see POC below). However, while calldata A works as expected in the Huff contract, calldata B results in transfers to incorrect addresses.\n\n```md\n// Calldata A\n//0x82947abe //selector \"airdropERC20(address,address[],uint256[],uint256)\"\n//000000000000000000000000e87162786bb97c37c6e0f3a7077a7f0236580ea5 //erc20 address\n//0000000000000000000000000000000000000000000000000000000000000080 //offset to the recipients array data\n//00000000000000000000000000000000000000000000000000000000000000c0 //offset to the amounts array data\n//0000000000000000000000000000000000000000000000000000000000000064 //totalAmount\n//0000000000000000000000000000000000000000000000000000000000000001 //recipients length\n//0000000000000000000000004dba461ca9342f4a6cf942abd7eacf8ae259108c //recipients data\n//0000000000000000000000000000000000000000000000000000000000000001 //amounts length\n//0000000000000000000000000000000000000000000000000000000000000064 //amount data\n```\n\n```md\n// Calldata B\n//0x82947abe //selector \"airdropERC20(address,address[],uint256[],uint256)\"\n//000000000000000000000000e87162786bb97c37c6e0f3a7077a7f0236580ea5 //erc20 address\n//00000000000000000000000000000000000000000000000000000000000000c0 //offset to the recipients array data\n//0000000000000000000000000000000000000000000000000000000000000080 //offset to the amounts array data\n//0000000000000000000000000000000000000000000000000000000000000064 //totalAmount\n//0000000000000000000000000000000000000000000000000000000000000001 //amounts length\n//0000000000000000000000000000000000000000000000000000000000000064 //amount data\n//0000000000000000000000000000000000000000000000000000000000000001 //recipients length\n//0000000000000000000000004dba461ca9342f4a6cf942abd7eacf8ae259108c //recipients data\n```\n\nAt a [specific point](https://github.com/Cyfrin/2024-05-TSender/blob/c6da9ef0c28741c007a02dfa07b7e899c1c22e47/src/protocol/TSender.huff#L115-L135) in the Huff code, the difference between the `recipients` and `amounts` array offsets is computed for further use. However, due to the inversion of the `recipients` and `amounts` array offsets and the use of the hardcoded `NUMBER_OF_RECIPIENTS_OFFSET`, this difference becomes zero when calldata B is fed to `TSender.huff` (Check this scenario in [EVM Playground](https://www.evm.codes/playground?fork=cancun&unit=Wei&callData=0x82947abe000000000000000000000000e87162786bb97c37c6e0f3a7077a7f0236580ea500000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000004dba461ca9342f4a6cf942abd7eacf8ae259108c&codeType=Bytecode&code=%2734yVx7h82947abepV7kh4d8m19ap0f4kqwwfdqwz0o4o0Zjxz8Yp048k6x0a3Vd6~ql23b872ddU33tn30R0nXoznwwXiwz0Yg7a5sla9059cbbUz8403z8o051bzaZza4q82mjxjwp0e6ktn03xjR0n85u9450wwRiw88gcxstummTy090kXY85_Sy0d9k00qllb625l~ql1647bca2~00qRYjjw_vz2o0Zx_Svwmmqp162ru5vmtVz2o2ZuxSvmWqj84pS6r2_vWy13956q5050Wmmy1T56qzuQxbwQ3%27~Uz0ifdX0y6Tx35w5fvy16bku01tz20s7lfaTea06~qrkjtVXZx8q5bp_yoYzn52m81l63k57j80i4z1chwxzeuclg5af1y0_14Z4uY4xXz6WzuuV02UwnT10S15Rz4QUtwf%01QRSTUVWXYZ_ghijklmnopqrstuvwxyz~_), the contract bytecode and calldata are already filled in). Consequently, when this difference is subtracted to obtain the correct offset of the current recipient element in the `recipients` array, the wrong offset is used. Thus, the current amount value at this offset is incorrectly used both as the amount and as the recipient of the ERC20 transactions (i.e instead of calling `transfer(0x4dba461ca9342f4a6cf942abd7eacf8ae259108c, 0x64)`, it calls `transfer(0x64, 0x64)`).\n\nSee the POC below. Note that the Huff contracts are not equivalent to the reference or Yul contracts. Although the same calldata is used to call all three contracts, `TSender.huff` and `TSender_NoCheck.huff` transfer tokens to the wrong recipient. Add the following code to the `/test` folder in the TSender repo and run it with `forge test`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {TSender} from \"src/protocol/TSender.sol\";\nimport {TSenderReference} from \"src/reference/TSenderReference.sol\";\nimport {MockERC20} from \"test/mocks/MockERC20.sol\";\nimport {HuffDeployer} from \"lib/foundry-huff/src/HuffDeployer.sol\";\n\ncontract POC is Test {\n    TSender public huffTSender;\n    TSender public yulTSender;\n    TSender public solidityTSender;\n    MockERC20 public mockERC20;\n    address sender;\n    address recipient;\n\n    function setUp() public {\n        solidityTSender = TSender(address(new TSenderReference()));\n        string memory tsenderHuffLocation = \"protocol/TSender\"; // Change to protocol/TSender_NoCheck to test the huff no check contract\n        huffTSender = TSender(HuffDeployer.config().deploy(tsenderHuffLocation));\n        yulTSender = new TSender();\n        \n        MockERC20 contractERC20 = new MockERC20();\n        address erc20 = makeAddr(\"ERC20\"); //0xE87162786Bb97C37c6e0F3a7077A7F0236580EA5\n        vm.etch(erc20, address(contractERC20).code);\n        mockERC20 = MockERC20(erc20);\n\n        sender = makeAddr(\"Alice\");\n        recipient = makeAddr(\"Bob\"); //0x4dBa461cA9342F4A6Cf942aBd7eacf8AE259108C\n\n        vm.startPrank(sender);\n        mockERC20.mint(1e18);\n        mockERC20.approve(address(huffTSender), type(uint256).max);\n        mockERC20.approve(address(yulTSender), type(uint256).max);\n        mockERC20.approve(address(solidityTSender), type(uint256).max);\n        vm.stopPrank();\n    }\n\n    function testCalldataA() public {\n        //0x82947abe\n        //000000000000000000000000e87162786bb97c37c6e0f3a7077a7f0236580ea5\n        //0000000000000000000000000000000000000000000000000000000000000080\n        //00000000000000000000000000000000000000000000000000000000000000c0\n        //0000000000000000000000000000000000000000000000000000000000000064\n        //0000000000000000000000000000000000000000000000000000000000000001\n        //0000000000000000000000004dba461ca9342f4a6cf942abd7eacf8ae259108c\n        //0000000000000000000000000000000000000000000000000000000000000001\n        //0000000000000000000000000000000000000000000000000000000000000064\n        bytes memory callDataA = hex\"82947abe000000000000000000000000e87162786bb97c37c6e0f3a7077a7f0236580ea5000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000004dba461ca9342f4a6cf942abd7eacf8ae259108c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000064\";\n\n        vm.startPrank(sender);\n        uint256 balanceBefore = mockERC20.balanceOf(recipient);\n        (bool successReference, ) = address(solidityTSender).call(callDataA);\n        assertEq(successReference, true);\n        uint256 balanceAfter = mockERC20.balanceOf(recipient);\n        assertEq(balanceAfter - balanceBefore, 100);\n\n        balanceBefore = mockERC20.balanceOf(recipient);\n        (bool successYul, ) = address(yulTSender).call(callDataA);\n        require(successYul);\n        assertEq(successYul, true);\n        balanceAfter = mockERC20.balanceOf(recipient);\n        assertEq(balanceAfter - balanceBefore, 100);\n\n        balanceBefore = mockERC20.balanceOf(recipient);\n        (bool successHuff, ) = address(huffTSender).call(callDataA);\n        assertEq(successHuff, true);\n        balanceAfter = mockERC20.balanceOf(recipient);\n        assertEq(balanceAfter - balanceBefore, 100);\n        vm.stopPrank();\n    }\n\n    function testCalldataB() public {\n        //0x82947abe\n        //000000000000000000000000e87162786bb97c37c6e0f3a7077a7f0236580ea5\n        //00000000000000000000000000000000000000000000000000000000000000c0\n        //0000000000000000000000000000000000000000000000000000000000000080\n        //0000000000000000000000000000000000000000000000000000000000000064\n        //0000000000000000000000000000000000000000000000000000000000000001\n        //0000000000000000000000000000000000000000000000000000000000000064\n        //0000000000000000000000000000000000000000000000000000000000000001\n        //0000000000000000000000004dba461ca9342f4a6cf942abd7eacf8ae259108c\n        bytes memory callDataB = hex\"82947abe000000000000000000000000e87162786bb97c37c6e0f3a7077a7f0236580ea500000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000004dba461ca9342f4a6cf942abd7eacf8ae259108c\";\n\n        vm.startPrank(sender);\n        uint256 balanceBefore = mockERC20.balanceOf(recipient);\n        (bool successReference, ) = address(solidityTSender).call(callDataB);\n        assertEq(successReference, true);\n        uint256 balanceAfter = mockERC20.balanceOf(recipient);\n        assertEq(balanceAfter - balanceBefore, 100);\n\n        balanceBefore = mockERC20.balanceOf(recipient);\n        (bool successYul, ) = address(yulTSender).call(callDataB);\n        require(successYul);\n        assertEq(successYul, true);\n        balanceAfter = mockERC20.balanceOf(recipient);\n        assertEq(balanceAfter - balanceBefore, 100);\n\n        balanceBefore = mockERC20.balanceOf(recipient);\n        (bool successHuff, ) = address(huffTSender).call(callDataB);\n        assertEq(successHuff, true);\n        balanceAfter = mockERC20.balanceOf(recipient);\n        // Assert that no fund was transferred to recipient address\n        assertEq(balanceAfter - balanceBefore, 0);\n        \n        // Assert that funds were transferred to address 0x64 instead\n        assertEq(mockERC20.balanceOf(address(0x64)), 100);\n        vm.stopPrank();\n    }\n}\n```\n\n## Impact\n`TSender.huff` and `TSender_NoCheck.huff` contracts will transfer funds to wrong addresses when called with specific calldata.\n\n## Tools Used \nManual Review.\n\n## Recommendations\nDo not use hardcoded offsets for any of the dynamic types (`address[] recipients` and `uint256[] amounts`).\n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clwgjlhig0015rbi5sssuk0qe",
  "Code": [
    {
      "filename": "src/protocol/TSender.huff",
      "content": "/* Interface */\n#define function airdropERC20(address,address[],uint256[],uint256) nonpayable returns()\n#define function areListsValid(address[],uint256[]) nonpayable returns (bool)\n\n/* Memory Locations */\n#define constant TO_ADDRESS_MEMORY_LOCATION = 0x20\n#define constant AMOUNT_MEMORY_LOCATION = 0x40\n\n/* Calldata Offsets */\n#define constant TOKEN_ADDRESS_OFFSET = 0x04\n#define constant NUMBER_OF_AMOUNTS_OFFSET_OFFSET = 0x44\n#define constant TOTAL_AMOUNT_OFFSET = 0x64\n#define constant NUMBER_OF_RECIPIENTS_OFFSET = 0x84\n#define constant RECIPIENT_ONE_OFFSET = 0xa4\n\n/* Constants for areListsValid */\n#define constant RECIPIENTS_LENGTH_OFFSET = 0x44\n#define constant AMOUNTS_OFFSET_OFFSET = 0x24\n#define constant ADDRESS_ONE_OFFSET = 0x64\n\n\n/* Constants */ \n#define constant TWENTY_EIGHT = 0x1c\n\n/* Methods */\n// cast sig \"airdropERC20(address,address[],uint256[],uint256)\"\n// 0x82947abe\n#define macro AIRDROP_ERC20() = takes (0) returns (0) {\n    // the calldata will be:\n    // <4 bytes - func select> <32 bytes - tokenAddress> <32 bytes - first dynamic type offset> <32 bytes - second dynamic type offset> <32 bytes - totalAmount><xx bytes recipients><xx bytes amounts>\n    // check for equal lengths\n    // Remember, jump will fire if it gets anything other than 0. 0 is false.\n\n    // cast calldata \"airdropERC20(address,address[],uint256[],uint256)\" 0x00000000000000000000000000000000075BCd15 [0x0000000000000000000000000000000000bC610A] [77] 77\n\n    // Example calldata:\n    // 0x82947abe \n    // 00000000000000000000000000000000000000000000000000000000075bcd15    // erc20 address\n    // 0000000000000000000000000000000000000000000000000000000000000080    // 128, the first dynamic type starts at 128 + 4 slot in this calldata. \n    // 00000000000000000000000000000000000000000000000000000000000000c0    // 192, the second dynamic type starts at 192 + 4 slot in this calldata.\n    // 000000000000000000000000000000000000000000000000000000000000004d    // uint256 totalAmount \n    // 0000000000000000000000000000000000000000000000000000000000000001    // number of recipients\n    // 0000000000000000000000000000000000000000000000000000000000bc610a    // recipient\n    // 0000000000000000000000000000000000000000000000000000000000000001    // number of amounts\n    // 000000000000000000000000000000000000000000000000000000000000004d    // amount\n\n    // cast calldata \"airdropERC20(address,address[],uint256[],uint256)\" 0x00000000000000000000000000000000075BCd15 [\"0x0000000000000000000000000000000000bC610A\",\"0x0000000000000000000000000000000000bC610A\"] [77] 78\n\n    // 0x82947abe\n    // 00000000000000000000000000000000000000000000000000000000075bcd15     // erc20 address\n    // 0000000000000000000000000000000000000000000000000000000000000080     // 128, the first dynamic type starts at 128 + 4 slot in this calldata.\n    // 00000000000000000000000000000000000000000000000000000000000000e0     // 224, the second dynamic type starts at 224 + 4 slot in this calldata.\n    // 000000000000000000000000000000000000000000000000000000000000004e     // 78, totalAmount\n    // 0000000000000000000000000000000000000000000000000000000000000002     // number of recipients\n    // 0000000000000000000000000000000000000000000000000000000000bc610a     // recipient 1\n    // 0000000000000000000000000000000000000000000000000000000000bc610a     // recipient 2\n    // 0000000000000000000000000000000000000000000000000000000000000001     // number of amounts\n    // 000000000000000000000000000000000000000000000000000000000000004d     // amounts 1 \n    // wrong number of amounts! Should revert!\n\n    // Function selector starts on the bottom of the stack, so pretend you see it there when looking at the stack comments\n    // Setup for later\n    0x00                                                        // [total_amount]\n    [TOKEN_ADDRESS_OFFSET] calldataload                         // [token_address, total_amount]                      \n    [NUMBER_OF_AMOUNTS_OFFSET_OFFSET] calldataload              // [amounts.offset, token_address, total_amount]\n    0x4 add                                                     // [true_amounts.offset, token_address, total_amount]\n    dup1                                                        // [amounts.offset, amounts.offset, token_address, total_amount]\n    calldataload                                                // [amounts.length, amounts.offset, token_address, total_amount]\n    [NUMBER_OF_RECIPIENTS_OFFSET] calldataload                  // [recipients.length, amounts.length, amounts.offset, token_address, total_amount]\n    eq                                                          // [amounts.length == recipients.length, amounts.offset, token_address, total_amount] // 1 is true \n    // Function selector is technically still on the bottom of the stack\n    lengths_match jumpi                          // [amounts.offset, token_address, total_amount]\n        // cast sig TSender__LengthsDontMatch()\n        0x50a302d6 0x00 mstore\n        0x04 [TWENTY_EIGHT] revert\n    \n    lengths_match:\n    // transferFrom(msg.sender, address(this), amount)\n    // This next line will result in memory looking like this:\n    // 0x0000000000000000000000000000000000000000000000000000000023b872dd\n    // It's different from yul. Yul does a shl (left shift)\n    0x23b872dd 0x00 mstore                       // [amounts.offset, token_address, total_amount] -> {0x00: 0x23b872dd}\n    // Since memory looks like the comment above, we could do a left shift, or we could just say calldata starts at byte offset 28\n    // We do the latter since it means we don't have to do a left shift\n    caller 0x20 mstore                           // [amounts.offset, token_address, total_amount] -> {0x00: 0x23b872dd, 0x20: msg.sender (bytes32)} \n    address 0x40 mstore                          // [amounts.offset, token_address, total_amount] -> {0x00: 0x23b872dd, 0x20: msg.sender (bytes32), 0x40: address(this) (bytes32)}\n    // amount should be at 0x64 in calldata, then store it at 0x60 in memory\n    0x64 calldataload 0x60 mstore                // [amounts.offset, token_address, total_amount] -> {0x00: 0x23b872dd, 0x20: msg.sender (bytes32), 0x40: address(this) (bytes32), 0x60: amount (bytes32)}\n\n    ///////////////////////////////////////////////////////////////\n    //              CALL TRANSFERFROM, JUMP IF REVERTED\n    ///////////////////////////////////////////////////////////////\n    // Setup return\n    0x00 0x00                                    // [0, 0, amounts.offset, token_address, total_amount]\n    // Setup memory (start at 0x1c aka 28) \n    // This is because we are not doing the left shift that the yul does when calling `mstore`\n    0x64 [TWENTY_EIGHT]                          // [28, 0x64, 0, 0, amounts.offset, token_address, total_amount]\n    // Setup value & address of ERC20\n    0x00 [TOKEN_ADDRESS_OFFSET] calldataload     // [token_address, 0, 28, 0x64, 0, 0, amounts.offset, token_address, total_amount]\n    gas call // program counter 4c               // [success, amounts.offset, token_address, total_amount]\n    transfer_from_didnt_fail jumpi               // \n        // cast sig TSender__TransferFailed()\n        0xfa10ea06 0x00 mstore\n        0x04 [TWENTY_EIGHT] revert\n\n    transfer_from_didnt_fail:\n    ///////////////////////////////////////////////////////////////\n    //                         TRANSFER SETUP\n    ///////////////////////////////////////////////////////////////\n    // transfer(address,amount)\n    // This next line setups up memory to look like this:\n    // 0x00000000000000000000000000000000000000000000000000000000a9059cbb \n    0xa9059cbb 0x00 mstore        \n\n    // let diff := sub(recipients.offset, amounts.offset)\n    [NUMBER_OF_RECIPIENTS_OFFSET] sub                                                     // [diff, token_address, total_amount]\n\n    // let end := add(recipients.offset, shl(5, recipients.length))\n    // recipients.length\n    [NUMBER_OF_RECIPIENTS_OFFSET] calldataload \n    // add(recipients.offset, shl(5\n    0x5 shl [RECIPIENT_ONE_OFFSET] add                                                     // [end, address_offset, diff, token_address, total_amount]\n    [RECIPIENT_ONE_OFFSET]                                                                 // [address_offset, end, diff, token_address, total_amount]\n    \n    loop_start:\n        dup3                                                                               // [diff, address_offset, end, diff, token_address, total_amount]   \n        // To address, and setting up to use addressOffset later\n        dup2 dup1                                                                                               // [address_offset, address_offset, diff, address_offset, end, diff, token_address, total_amount]  \n        calldataload                                                                                            // [to_address, address_offset, address_offset, diff, address_offset, end, diff, token_address, total_amount]  \n        // zero address check\n        dup1 0x00 eq zero_address_to jumpi                                                                      // [to_address, address_offset, address_offset, diff, address_offset, end, diff, token_address, total_amount]  \n        // Store to address in memory\n        [TO_ADDRESS_MEMORY_LOCATION] mstore                                                                     // [address_offset, diff, address_offset, end, diff, token_address, total_amount]     \n        // Store amount in memory\n        sub calldataload dup1 [AMOUNT_MEMORY_LOCATION] mstore                                                   // [amount, address_offset, end, diff, token_address, total_amount]                                                           \n        \n        // addedAmount := add(addedAmount, mload(0x24))\n        dup6                                                                                                    // [total_amount, amount, address_offset, end, diff, token_address, total_amount]     \n        add                                                                                                     // [total_amount + amount, address_offset, end, diff, token_address, total_amount]        \n        swap5                                                                                                   // [(old) total_amount + amount, address_offset, end, diff, token_address, (new) total_amount]  \n        pop                                                                                                     // [address_offset, end, diff, token_address, (new) total_amount] \n\n        // call(gas(), tokenAddress, 0, 0x00, 0x44, 0, 0)\n        0x00 0x00 0x44 [TWENTY_EIGHT] 0x00 dup9 gas call                                                       // [success, address_offset, end, diff, token_address, (new) total_amount] \n        transfer_didnt_fail jumpi                                                                              // [address_offset, end, diff, token_address, (new) total_amount] \n            // cast sig TSender__TransferFailed()\n            0xfa10ea06 0x00 mstore\n            0x04 [TWENTY_EIGHT] revert\n\n        // increment the address offset\n        transfer_didnt_fail:\n        0x20 add                                                                                                 // [(new) address_offset, end, diff, token_address, total_amount] \n        dup2 dup2                                                                                                // [address_offset, end, address_offset, end, diff, token_address, total_amount]                 \n       \n        // if addressOffset >= end, jump to end\n        // if iszero(lt(addressOffset, end)) { break }\n        // Target: // [address_offset, end, diff, token_address, total_amount]\n        lt loop_start jumpi                                                                                 // [address_offset, end, diff, token_address, total_amount]\n\n    // Check if the totals match                                                                            // [address_offset, end, diff, token_address, total_amount]\n    [TOTAL_AMOUNT_OFFSET] calldataload                                                                      // [expected_total, address_offset, end, diff, token_address, total_amount]\n    dup6 eq iszero total_doesnt_add_up jumpi\n    stop\n    \n    total_doesnt_add_up:\n        // cast sig \"TSender__TotalDoesntAddUp():\n        0x63b62563 0x00 mstore\n        0x04 [TWENTY_EIGHT] revert\n    \n    zero_address_to:\n        // cast sig \"TSender__ZeroAddress()\"\n        0x1647bca2 0x00 mstore \n        0x04 [TWENTY_EIGHT] revert\n    stop\n}\n\n// This function is not optimized for gas\n// cast sig \"areListsValid(address[],uint256[])\"\n// 0x4d88119a\n\n// Calldata example for:\n// address[] memory recipients = new address[](2);\n// uint256[] memory amounts = new uint256[](2);\n// cast calldata \"areListsValid(address[],uint256[])\" [\"0x00000000000000000000000000000000075BCd15\",\"0x0000000000000000000000000000000000bC610A\"] [0,15]\n// 0x4d88119a\n// 0000000000000000000000000000000000000000000000000000000000000040  // 64, theÂ first dynamic type starts at 64 + 4 slot in this calldata\n// 00000000000000000000000000000000000000000000000000000000000000a0  // 160, the location of the second dynamic type starts at 160 + 4 slot in this calldata\n// 0000000000000000000000000000000000000000000000000000000000000002  // first dynamic type (recipients) length\n// 00000000000000000000000000000000000000000000000000000000075bcd15  // recipient 1\n// 0000000000000000000000000000000000000000000000000000000000bc610a  // recipient 2\n// 0000000000000000000000000000000000000000000000000000000000000002  // second dynamic type (amounts) length\n// 0000000000000000000000000000000000000000000000000000000000000000  // amount 1\n// 000000000000000000000000000000000000000000000000000000000000000f  // amount 2\n\n// cast calldata \"areListsValid(address[],uint256[])\" [\"0x00000000000000000000000000000000075BCd15\"] [0,15]\n// 0x4d88119a\n// 0000000000000000000000000000000000000000000000000000000000000040  // the first dynamic type starts at 64 + 4 slot in this calldata\n// 0000000000000000000000000000000000000000000000000000000000000080  // the second dynamic type starts at 128 + 4 slot in this calldata\n// 0000000000000000000000000000000000000000000000000000000000000001  // recipients.length\n// 00000000000000000000000000000000000000000000000000000000075bcd15  // recipient 1\n// 0000000000000000000000000000000000000000000000000000000000000002  // amounts.length\n// 0000000000000000000000000000000000000000000000000000000000000000  // amount 1\n// 000000000000000000000000000000000000000000000000000000000000000f  // amount 2\n#define macro ARE_LISTS_VALID() = takes (0) returns (0) { \n    // The recipients starting location will always be 0x44\n    [RECIPIENTS_LENGTH_OFFSET] calldataload  // [recipients.length]\n    dup1                                     // [recipients.length, recipients.length]\n    dup1                                     // [recipients.length, recipients.length, recipients.length]   \n    // check if the number of recipients is 0\n    0x00 eq return_false jumpi               // [recipients.length, recipients.length]\n\n    // However, the amounts starting location may be different depending on the number of recipients\n    // Check if the number of recipients matches the number of amounts\n    [AMOUNTS_OFFSET_OFFSET] calldataload     // [location_of_amounts_offset (without function selector), recipients.length, recipients.length]\n    0x04 add                                 // [location_of_amounts_offset (with function selector), recipients.length, recipients.length]\n    calldataload                             // [amounts.length, recipients.length, recipients.length]\n    eq iszero return_false jumpi             // [recipients.length]\n\n    0x00                                     // [outer_loop_count, recipients.length]\n    dup2 dup2                                // [outer_loop_count, recipients.length, outer_loop_count, recipients.length]\n\n    outer_loop_start:                        // [inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n        // Break loop conditional\n        eq return_true jumpi               // [outer_loop_count, recipients.length]\n\n        // Check for zero address\n        dup1                               // [loop_count, loop_count, recipients.length]\n        0x20 mul                           // [outer_loop_count * 32, recipients.length]\n        [ADDRESS_ONE_OFFSET] add           // [current_address_offset, outer_loop_count, recipients.length]\n        calldataload                       // [outer_loop_address, outer_loop_count, recipients.length]\n        dup1                               // [outer_loop_address, outer_loop_address, outer_loop_count, recipients.length]\n        iszero return_false jumpi          // [outer_loop_address, outer_loop_count, recipients.length]\n\n        // Check for zero amount\n        // This is not gas efficient at all, whatever\n        dup2                                  // [outer_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n        0x20 mul                              // [outer_loop_count * 32, outer_loop_address, outer_loop_count, recipients.length]\n        [AMOUNTS_OFFSET_OFFSET] calldataload  // [location_of_amounts_offset (without function selector), outer_loop_count * 32, outer_loop_address, outer_loop_count, recipients.length]\n        // we do 0x24 here since we need to step over amounts.length + the function selector \n        0x24 add                              // [location_of_amounts_offset (with function selector), outer_loop_count * 32, outer_loop_address, outer_loop_count, recipients.length]\n        add calldataload                      // [amounts[i], outer_loop_count * 32, outer_loop_address, outer_loop_count, recipients.length]\n        iszero return_false jumpi             // [outer_loop_address, outer_loop_count, recipients.length]\n\n        // inner loop starts at index i + 1\n        dup2 0x01 add                      // [inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n\n        inner_loop_start:\n            // Break loop conditional\n            dup1 dup5                      // [recipients.length, inner_loop_count, inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n            eq inner_loop_end jumpi        // [inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n            // Compare addresses\n            dup1                           // [inner_loop_count, inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n            0x20 mul                       // [inner_loop_count * 32, inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]   \n            [ADDRESS_ONE_OFFSET] add       // [inner_loop_address_offset, inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]   \n            calldataload                   // [inner_loop_address, inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n            dup3                           // [outer_loop_address, inner_loop_address, inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n            // We could obviously combine these next two jumps into one for gas optimization\n            eq return_false jumpi          // [inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n\n            // Incremement inner loop count\n            0x01 add                       // [inner_loop_count + 1, outer_loop_address, outer_loop_count, recipients.length]\n            inner_loop_start jump\n\n            // This is a gross waste of gas having all these jumps... but whatever\n            inner_loop_end:                    // [inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n                // pop off inner loop vars\n                pop pop \n                // Increment outer loop count\n                0x01 add                       // [outer_loop_count + 1, recipients.length]\n                dup2 dup2                      // [outer_loop_count, recipients.length, outer_loop_count, recipients.length]\n                outer_loop_start jump\n            // inner_loop target end stack:// [inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n    // outer_loop target end stack: // [inner_loop_count, outer_loop_address, outer_loop_count, recipients.length]\n    return_true:\n        // 1 is true\n        0x01 0x00 mstore \n        0x20 0x00 return\n    \n    return_false:\n        // 0 is false\n        0x00 0x00 mstore \n        0x20 0x00 return\n}\n\n#define macro MAIN() = takes (0) returns (0) {\n    // check for msg.value and revert if so\n    callvalue endcall jumpi\n\n    0x00 calldataload 0xE0 shr\n\n    // We don't dup1 because we want to be as gas efficient \n    // with the airdrop as possible\n    __FUNC_SIG(airdropERC20) eq airdropERC20 jumpi\n\n    // This means, for areListsValid, we need to get the selector again\n    0x00 calldataload 0xE0 shr \n    __FUNC_SIG(areListsValid) eq areListsValid jumpi\n\n    endcall:\n        0x00 0x00 revert\n\n    airdropERC20:\n        AIRDROP_ERC20()\n    \n    areListsValid:\n        ARE_LISTS_VALID()\n}"
    },
    {
      "filename": "src/protocol/TSender.huff",
      "content": "/* Interface */\n#define function airdropERC20(address,address[],uint256[],uint256) nonpayable returns()\n#define function areListsValid(address[],uint256[]) nonpayable returns (bool)\n\n/* Memory Locations */\n#define constant TO_ADDRESS_MEMORY_LOCATION = 0x20\n#define constant AMOUNT_MEMORY_LOCATION = 0x40\n\n/* Calldata Offsets */\n#define constant TOKEN_ADDRESS_OFFSET = 0x04\n#define constant NUMBER_OF_AMOUNTS_OFFSET_OFFSET = 0x44\n#define constant TOTAL_AMOUNT_OFFSET = 0x64\n#define constant NUMBER_OF_RECIPIENTS_OFFSET = 0x84\n#define constant RECIPIENT_ONE_OFFSET = 0xa4\n\n/* Constants for areListsValid */\n#define constant RECIPIENTS_LENGTH_OFFSET = 0x44\n#define constant AMOUNTS_OFFSET_OFFSET = 0x24\n#define constant ADDRESS_ONE_OFFSET = 0x64\n\n\n/* Constants */ \n#define constant TWENTY_EIGHT = 0x1c\n\n/* Methods */\n// cast sig \"airdropERC20(address,address[],uint256[],uint256)\"\n// 0x82947abe\n#define macro AIRDROP_ERC20() = takes (0) returns (0) {\n    // the calldata will be:\n    // <4 bytes - func select> <32 bytes - tokenAddress> <32 bytes - first dynamic type offset> <32 bytes - second dynamic type offset> <32 bytes - totalAmount><xx bytes recipients><xx bytes amounts>\n    // check for equal lengths\n    // Remember, jump will fire if it gets anything other than 0. 0 is false.\n\n    // cast calldata \"airdropERC20(address,address[],uint256[],uint256)\" 0x00000000000000000000000000000000075BCd15 [0x0000000000000000000000000000000000bC610A] [77] 77\n\n    // Example calldata:\n    // 0x82947abe \n    // 00000000000000000000000000000000000000000000000000000000075bcd15    // erc20 address\n    // 0000000000000000000000000000000000000000000000000000000000000080    // 128, the first dynamic type starts at 128 + 4 slot in this calldata. \n    // 00000000000000000000000000000000000000000000000000000000000000c0    // 192, the second dynamic type starts at 192 + 4 slot in this calldata.\n    // 000000000000000000000000000000000000000000000000000000000000004d    // uint256 totalAmount \n    // 0000000000000000000000000000000000000000000000000000000000000001    // number of recipients\n    // 0000000000000000000000000000000000000000000000000000000000bc610a    // recipient\n    // 0000000000000000000000000000000000000000000000000000000000000001    // number of amounts\n    // 000000000000000000000000000000000000000000000000000000000000004d    // amount\n\n    // cast calldata \"airdropERC20(address,address[],uint256[],uint256)\" 0x00000000000000000000000000000000075BCd15 [\"0x0000000000000000000000000000000000bC610A\",\"0x0000000000000000000000000000000000bC610A\"] [77] 78\n\n    // 0x82947abe\n    // 00000000000000000000000000000000000000000000000000000000075bcd15     // erc20 address\n    // 0000000000000000000000000000000000000000000000000000000000000080     // 128, the first dynamic type starts at 128 + 4 slot in this calldata.\n    // 00000000000000000000000000000000000000000000000000000000000000e0     // 224, the second dynamic type starts at 224 + 4 slot in this calldata.\n    // 000000000000000000000000000000000000000000000000000000000000004e     // 78, totalAmount\n    // 0000000000000000000000000000000000000000000000000000000000000002     // number of recipients\n    // 0000000000000000000000000000000000000000000000000000000000bc610a     // recipient 1\n    // 0000000000000000000000000000000000000000000000000000000000bc610a     // recipient 2\n    // 0000000000000000000000000000000000000000000000000000000000000001     // number of amounts\n    // 000000000000000000000000000000000000000000000000000000000000004d     // amounts 1 \n    // wrong number of amounts! Should revert!\n\n    // Function selector starts on the bottom of the stack, so pretend you see it there when looking at the stack comments\n    // Setup for later\n    0x00                                                        // [total_amount]\n    [TOKEN_ADDRESS_OFFSET] calldataload                         // [token_address, total_amount]                      \n    [NUMBER_OF_AMOUNTS_OFFSET_OFFSET] calldataload              // [amounts.offset, token_address, total_amount]\n    0x4 add                                                     // [true_amounts.offset, token_address, total_amount]\n    dup1                                                        // [amounts.offset, amounts.offset, token_address, total_amount]\n    calldataload                                                // [amounts.length, amounts.offset, token_address, total_amount]\n    [NUMBER_OF_RECIPIENTS_OFFSET] calldataload                  // [recipients.length, amounts.length, amounts.offset, token_address, total_amount]\n    eq                                                          // [amounts.length == recipients.length, amounts.offset, token_address, total_amount] // 1 is true \n    // Function selector is technically still on the bottom of the stack\n    lengths_match jumpi                          // [amounts.offset, token_address, total_amount]\n        // cast sig TSender__LengthsDontMatch()\n        0x50a302d6 0x00 mstore\n        0x04 [TWENTY_EIGHT] revert\n    \n    lengths_match:\n    // transferFrom(msg.sender, address(this), amount)\n    // This next line will result in memory looking like this:\n    // 0x0000000000000000000000000000000000000000000000000000000023b872dd\n    // It's different from yul. Yul does a shl (left shift)\n    0x23b872dd 0x00 mstore                       // [amounts.offset, token_address, total_amount] -> {0x00: 0x23b872dd}\n    // Since memory looks like the comment above, we could do a left shift, or we could just say calldata starts at byte offset 28\n    // We do the latter since it means we don't have to do a left shift\n    caller 0x20 mstore                           // [amounts.offset, token_address, total_amount] -> {0x00: 0x23b872dd, 0x20: msg.sender (bytes32)} \n    address 0x40 mstore                          // [amounts.offset, token_address, total_amount] -> {0x00: 0x23b872dd, 0x20: msg.sender (bytes32), 0x40: address(this) (bytes32)}\n    // amount should be at 0x64 in calldata, then store it at 0x60 in memory\n    0x64 calldataload 0x60 mstore                // [amounts.offset, token_address, total_amount] -> {0x00: 0x23b872dd, 0x20: msg.sender (bytes32), 0x40: address(this) (bytes32), 0x60: amount (bytes32)}\n\n    ///////////////////////////////////////////////////////////////\n    //              CALL TRANSFERFROM, JUMP IF REVERTED\n    ///////////////////////////////////////////////////////////////\n    // Setup return\n    0x00 0x00                                    // [0, 0, amounts.offset, token_address, total_amount]\n    // Setup memory (start at 0x1c aka 28) \n    // This is because we are not doing the left shift that the yul does when calling `mstore`\n    0x64 [TWENTY_EIGHT]                          // [28, 0x64, 0, 0, amounts.offset, token_address, total_amount]\n    // Setup value & address of ERC20\n    0x00 [TOKEN_ADDRESS_OFFSET] calldataload     // [token_address, 0, 28, 0x64, 0, 0, amounts.offset, token_address, total_amount]\n    gas call // program counter 4c               // [success, amounts.offset, token_address, total_amount]\n    transfer_from_didnt_fail jumpi               // \n        // cast sig TSender__TransferFailed()\n        0xfa10ea06 0x00 mstore\n        0x04 [TWENTY_EIGHT] revert\n\n    transfer_from_didnt_fail:\n    ///////////////////////////////////////////////////////////////\n    //                         TRANSFER SETUP\n    ///////////////////////////////////////////////////////////////\n    // transfer(address,amount)\n    // This next line setups up memory to look like this:\n    // 0x00000000000000000000000000000000000000000000000000000000a9059cbb \n    0xa9059cbb 0x00 mstore        \n\n    // let diff := sub(recipients.offset, amounts.offset)\n    [NUMBER_OF_RECIPIENTS_OFFSET] sub                                                     // [diff, token_address, total_amount]\n\n    // let end := add(recipients.offset, shl(5, recipients.length))\n    // recipients.length\n    [NUMBER_OF_RECIPIENTS_OFFSET] calldataload \n    // add(recipients.offset, shl(5\n    0x5 shl [RECIPIENT_ONE_OFFSET] add                                                     // [end, address_offset, diff, token_address, total_amount]\n    [RECIPIENT_ONE_OFFSET]                                                                 // [address_offset, end, diff, token_address, total_amount]\n    \n    loop_start:\n        dup3                                                                               // [diff, address_offset, end, diff, token_address, total_amount]   \n        // To address, and setting up to use addressOffset later\n        dup2 dup1                                                                                               // [address_offset, address_offset, diff, address_offset, end, diff, token_address, total_amount]  \n        calldataload                                                                                            // [to_address, address_offset, address_offset, diff, address_offset, end, diff, token_address, total_amount]  \n        // zero address check\n        dup1 0x00 eq zero_address_to jumpi                                                                      // [to_address, address_offset, address_offset, diff, address_offset, end, diff, token_address, total_amount]  \n        // Store to address in memory\n        [TO_ADDRESS_MEMORY_LOCATION] mstore                                                                     // [address_offset, diff, address_offset, end, diff, token_address, total_amount]     \n        // Store amount in memory\n        sub calldataload dup1 [AMOUNT_MEMORY_LOCATION] mstore                                                   // [amount, address_offset, end, diff, token_address, total_amount]                                                           \n        \n        // addedAmount := add(addedAmount, mload(0x24))\n        dup6                                                                                                    // [total_amount, amount, address_offset, end, diff, token_address, total_amount]     \n        add                                                                                                     // [total_amount + amount, address_offset, end, diff, token_address, total_amount]        \n        swap5                                                                                                   // [(old) total_amount + amount, address_offset, end, diff, token_address, (new) total_amount]  \n        pop                                                                                                     // [address_offset, end, diff, token_address, (new) total_amount] \n\n        // call(gas(), tokenAddress, 0, 0x00, 0x44, 0, 0)\n        0x00 0x00 0x44 [TWENTY_EIGHT] 0x00 dup9 gas call                                                       // [success, address_offset, end, diff, token_address, (new) total_amount] \n        transfer_didnt_fail jumpi                                                                              // [address_offset, end, diff, token_address, (new) total_amount] \n            // cast sig TSender__TransferFailed()\n            0xfa10ea06 0x00 mstore\n            0x04 [TWENTY_EIGHT] revert\n\n        // increment the address offset\n        transfer_didnt_fail:\n        0x20 add"
    }
  ]
}