{
  "Title": "M-2: \"Equilibrium price\" is not used to compute the capacity (OSDA Only)",
  "Content": "# Issue M-2: \"Equilibrium price\" is not used to compute the capacity (OSDA Only) \n\nSource: https://github.com/sherlock-audit/2023-02-bond-judging/issues/18 \n\n## Found by \nxiaoming90, Bauer\n\n## Summary\n\n\"Equilibrium price\" is not used to compute the capacity leading to a smaller-than-expected max payout.\n\n## Vulnerability Detail\n\nIn OFDA, it was observed that if the capacity is denominated in the quote token, the capacity will be calculated with the discounted price. \n\n```solidity\nFile: BondBaseOFDA.sol\n118:     function _createMarket(MarketParams memory params_) internal returns (uint256) {\n..SNIP..\n178:         // Calculate the maximum payout amount for this market\n179:         uint256 capacity = params_.capacityInQuote\n180:             ? params_.capacity.mulDiv(\n181:                 scale,\n182:                 price.mulDivUp(\n183:                     uint256(ONE_HUNDRED_PERCENT - params_.fixedDiscount),\n184:                     uint256(ONE_HUNDRED_PERCENT)\n185:                 )\n186:             )\n187:             : params_.capacity;\n188:         market.maxPayout = capacity.mulDiv(uint256(params_.depositInterval), uint256(length));\n```\n\nHowever, in OSDA, if the capacity is denominated in the quote token, the capacity will be calculated with the oracle price instead of the discounted price.\n\n```solidity\nFile: BondBaseOSDA.sol\n122:     function _createMarket(MarketParams memory params_) internal returns (uint256) {\n..SNIP..\n182:         // Calculate the maximum payout amount for this market, determined by deposit interval\n183:         uint256 capacity = params_.capacityInQuote\n184:             ? params_.capacity.mulDiv(scale, price)\n185:             : params_.capacity;\n186:         market.maxPayout = capacity.mulDiv(uint256(params_.depositInterval), uint256(length));\n```\n\nIn OSDA, it was also observed that the base discount is applied to the oracle price while calculating the price decimals because this will be the initial equilibrium price of the market. However, this \"initial equilibrium price\" is not used earlier when computing the capacity.\n\n```solidity\nFile: BondBaseOSDA.sol\n210:     function _validateOracle(\n211:         uint256 id_,\n212:         IBondOracle oracle_,\n213:         ERC20 quoteToken_,\n214:         ERC20 payoutToken_,\n215:         uint48 baseDiscount_\n216:     )\n..SNIP..\n251:         // Get the price decimals for the current oracle price\n252:         // Oracle price is in quote tokens per payout token\n253:         // E.g. if quote token is $10 and payout token is $2000,\n254:         // then the oracle price is 200 quote tokens per payout token.\n255:         // If the oracle has 18 decimals, then it would return 200 * 10^18.\n256:         // In this case, the price decimals would be 2 since 200 = 2 * 10^2.\n257:         // We apply the base discount to the oracle price before calculating\n258:         // since this will be the initial equilibrium price of the market.\n259:         int8 priceDecimals = _getPriceDecimals(\n260:             currentPrice.mulDivUp(\n261:                 uint256(ONE_HUNDRED_PERCENT - baseDiscount_),\n262:                 uint256(ONE_HUNDRED_PERCENT)\n263:             ),\n264:             oracleDecimals\n265:         );\n```\n\n## Impact\n\nAs the discount is not applied to the price when computing the capacity, the price will be higher which leads to a smaller capacity.  A smaller capacity will in turn result in a smaller max payout. A smaller-than-expected max payout reduces the maximum number of payout tokens a user can purchase at any single point in time, which might reduce the efficiency of a Bond market.\n\nUsers who want to purchase a large number of bond tokens have to break their trade into smaller chunks to overcome the smaller-than-expected max payout, leading to unnecessary delay and additional gas fees.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-bond/blob/main/bonds/src/bases/BondBaseOSDA.sol#L122\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApplied the discount to obtain the \"equilibrium price\" before computing the capacity.\n\n```diff\n// Calculate the maximum payout amount for this market, determined by deposit interval\nuint256 capacity = params_.capacityInQuote\n-\t ? params_.capacity.mulDiv(scale, price)\n+    ? params_.capacity.mulDiv(scale, price.mulDivUp(\n+    \t\tuint256(ONE_HUNDRED_PERCENT - params_.baseDiscount),\n+    \t\tuint256(ONE_HUNDRED_PERCENT)\n+    \t)\n+    )\n    : params_.capacity;\nmarket.maxPayout = capacity.mulDiv(uint256(params_.depositInterval), uint256(length));\n```\n\n## Discussion\n\n**UsmannK**\n\nEscalate for 10 USDC.\n\nThis issue should be Medium, not High. The issue identified is that `BondBaseOFDA` Auctions, in only some cases (`if capacityInQuote=true`), do not take into account the `fixedDiscount` parameter when calculating the auction's `capacity`.\n\nThe capacity in these cases may be **under-calculated**. If there is a situation as:\n\nPayout token: DAI\nQuote token: UNI\nExchange rate: 5 UNI : 1 DAI\nFixed discount: 10%\n`capacityInQuote`: true\n`params_.capacity`: 10\n\nThen the final `capacity` will be calculated as 10/5=`2` instead of 10/(4.5)=`2.222`.\n\nAKA the auction will sell slightly **fewer** tokens than intended, and end early. This is equivalent to a very minor denial of service and is at best a medium issue by the following criteria, taken from the Sherlock docs:\n```\nMedium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost.\n\nHigh: This vulnerability would result in a material loss of funds, \n```\n\nIf the protocol made this mistake in reverse and actually took slightly extra tokens, it may be closer to a High. But that is not the case. Actually the protocol just sells slightly **fewer** of the owner's tokens than intended, **but sells all of those at the correct price**.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> This issue should be Medium, not High. The issue identified is that `BondBaseOFDA` Auctions, in only some cases (`if capacityInQuote=true`), do not take into account the `fixedDiscount` parameter when calculating the auction's `capacity`.\n> \n> The capacity in these cases may be **under-calculated**. If there is a situation as:\n> \n> Payout token: DAI\n> Quote token: UNI\n> Exchange rate: 5 UNI : 1 DAI\n> Fixed discount: 10%\n> `capacityInQuote`: true\n> `params_.capacity`: 10\n> \n> Then the final `capacity` will be calculated as 10/5=`2` instead of 10/(4.5)=`2.222`.\n> \n> AKA the auction will sell slightly **fewer** tokens than intended, and end early. This is equivalent to a very minor denial of service and is at best a medium issue by the following criteria, taken from the Sherlock docs:\n> ```\n> Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost.\n> \n> High: This vulnerability would result in a material loss of funds, \n> ```\n> \n> If the protocol made this mistake in reverse and actually took slightly extra tokens, it may be closer to a High. But that is not the case. Actually the protocol just sells slightly **fewer** of the owner's tokens than intended, **but sells all of those at the correct price**.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Oighty**\n\nIssue fixed here: https://github.com/Bond-Protocol/bonds/pull/47\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/pull/47\n\n**hrishibhat**\n\nEscalation accepted\n\nIssue is a valid medium\nGiven the preconditions and the impact of the incorrect calculation, considering this issue as a valid medium\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Issue is a valid medium\n> Given the preconditions and the impact of the incorrect calculation, considering this issue as a valid medium\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/53",
  "Code": [
    {
      "filename": "bonds/src/bases/BondBaseOSDA.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\n\nimport {IBondOSDA, IBondAuctioneer} from \"../interfaces/IBondOSDA.sol\";\nimport {IBondOracle} from \"../interfaces/IBondOracle.sol\";\nimport {IBondTeller} from \"../interfaces/IBondTeller.sol\";\nimport {IBondCallback} from \"../interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"../interfaces/IBondAggregator.sol\";\n\nimport {TransferHelper} from \"../lib/TransferHelper.sol\";\nimport {FullMath} from \"../lib/FullMath.sol\";\n\n/// @title Bond Oracle-based Sequential Dutch Auctioneer (OSDA)\n/// @notice Bond Oracle-based Sequential Dutch Auctioneer Base Contract\n/// @dev Bond Protocol is a system to create bond markets for any token pair.\n///      The markets do not require maintenance and will manage bond prices\n///      based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Oracle-based Sequential Dutch Auctioneer contract allows users to create\n///      and manage bond markets. All bond market data is stored in the Auctioneer.\n///      The market price is based on an outside Oracle and varies based on whether the\n///      market is under- or oversold with the goal of selling a target amount of\n///      payout tokens or buying a target amount of quote tokens over the duration of\n///      a market. An Auctioneer is dependent on a Teller to serve external users and\n///      an Aggregator to register new markets.\n///\n/// @author Oighty\nabstract contract BondBaseOSDA is IBondOSDA, Auth {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS ========== */\n\n    error Auctioneer_OnlyMarketOwner();\n    error Auctioneer_InitialPriceLessThanMin();\n    error Auctioneer_MarketConcluded(uint256 conclusion_);\n    error Auctioneer_MaxPayoutExceeded();\n    error Auctioneer_AmountLessThanMinimum();\n    error Auctioneer_NotEnoughCapacity();\n    error Auctioneer_InvalidCallback();\n    error Auctioneer_BadExpiry();\n    error Auctioneer_InvalidParams();\n    error Auctioneer_NotAuthorized();\n    error Auctioneer_NewMarketsNotAllowed();\n    error Auctioneer_OraclePriceZero();\n\n    /* ========== EVENTS ========== */\n\n    event MarketCreated(\n        uint256 indexed id,\n        address indexed payoutToken,\n        address indexed quoteToken,\n        uint48 vesting\n    );\n    event MarketClosed(uint256 indexed id);\n    event Tuned(uint256 indexed id, uint256 oldControlVariable, uint256 newControlVariable);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Main information pertaining to bond market\n    mapping(uint256 => BondMarket) public markets;\n\n    /// @notice Information used to control how a bond market changes\n    mapping(uint256 => BondTerms) public terms;\n\n    /// @notice New address to designate as market owner. They must accept ownership to transfer permissions.\n    mapping(uint256 => address) public newOwners;\n\n    /// @notice Whether or not the market creator is authorized to use a callback address\n    mapping(address => bool) public callbackAuthorized;\n\n    /// @notice Whether or not the auctioneer allows new markets to be created\n    /// @dev    Changing to false will sunset the auctioneer after all active markets end\n    bool public allowNewMarkets;\n\n    // Minimum time parameter values. Can be updated by admin.\n    /// @notice Minimum deposit interval for a market\n    uint48 public minDepositInterval;\n\n    /// @notice Minimum duration for a market\n    uint48 public minMarketDuration;\n\n    // A 'vesting' param longer than 50 years is considered a timestamp for fixed expiry.\n    uint48 internal constant MAX_FIXED_TERM = 52 weeks * 50;\n    uint48 internal constant ONE_HUNDRED_PERCENT = 100e3; // one percent equals 1000.\n\n    // BondAggregator contract with utility functions\n    IBondAggregator internal immutable _aggregator;\n\n    // BondTeller contract that handles interactions with users and issues tokens\n    IBondTeller internal immutable _teller;\n\n    constructor(\n        IBondTeller teller_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) Auth(guardian_, authority_) {\n        _aggregator = aggregator_;\n        _teller = teller_;\n\n        minDepositInterval = 1 hours;\n        minMarketDuration = 1 days;\n\n        allowNewMarkets = true;\n    }\n\n    /* ========== MARKET FUNCTIONS ========== */\n\n    /// @inheritdoc IBondAuctioneer\n    function createMarket(bytes calldata params_) external virtual returns (uint256);\n\n    /// @notice core market creation logic, see IBondOSDA.MarketParams documentation\n    function _createMarket(MarketParams memory params_) internal returns (uint256) {\n        // Upfront permission and timing checks\n        {\n            // Check that the auctioneer is allowing new markets to be created\n            if (!allowNewMarkets) revert Auctioneer_NewMarketsNotAllowed();\n            // Restrict the use of a callback address unless allowed\n            if (!callbackAuthorized[msg.sender] && params_.callbackAddr != address(0))\n                revert Auctioneer_NotAuthorized();\n            // Conclusion must be in the future\n            if (params_.conclusion < block.timestamp) revert Auctioneer_InvalidParams();\n        }\n        // Register new market on aggregator and get marketId\n        uint256 marketId = _aggregator.registerMarket(params_.payoutToken, params_.quoteToken);\n\n        // Set basic market data\n        BondMarket storage market = markets[marketId];\n        market.owner = msg.sender;\n        market.quoteToken = params_.quoteToken;\n        market.payoutToken = params_.payoutToken;\n        market.callbackAddr = params_.callbackAddr;\n        market.capacityInQuote = params_.capacityInQuote;\n        market.capacity = params_.capacity;\n\n        // Check that the base discount is in bounds (cannot be 100% or greater)\n        BondTerms storage term = terms[marketId];\n        if (\n            params_.baseDiscount >= ONE_HUNDRED_PERCENT ||\n            params_.baseDiscount > params_.maxDiscountFromCurrent\n        ) revert Auctioneer_InvalidParams();\n        term.baseDiscount = params_.baseDiscount;\n\n        // Validate oracle and get price variables\n        (uint256 price, uint256 oracleConversion, uint256 scale) = _validateOracle(\n            marketId,\n            params_.oracle,\n            params_.quoteToken,\n            params_.payoutToken,\n            params_.baseDiscount\n        );\n        term.oracle = params_.oracle;\n        term.oracleConversion = oracleConversion;\n        term.scale = scale;\n\n        // Check that the max discount from current price is in bounds (cannot be greater than 100%)\n        if (params_.maxDiscountFromCurrent > ONE_HUNDRED_PERCENT) revert Auctioneer_InvalidParams();\n\n        // Calculate the minimum price for the market\n        term.minPrice = price.mulDivUp(\n            uint256(ONE_HUNDRED_PERCENT - params_.maxDiscountFromCurrent),\n            uint256(ONE_HUNDRED_PERCENT)\n        );\n\n        // Calculate market length and check time bounds\n        uint48 length = uint48(params_.conclusion - block.timestamp);\n        if (\n            length < minMarketDuration ||\n            params_.depositInterval < minDepositInterval ||\n            params_.depositInterval > length\n        ) revert Auctioneer_InvalidParams();\n\n        // Calculate the maximum payout amount for this market, determined by deposit interval\n        uint256 capacity = params_.capacityInQuote\n            ? params_.capacity.mulDiv(scale, price)\n            : params_.capacity;\n        market.maxPayout = capacity.mulDiv(uint256(params_.depositInterval), uint256(length));\n\n        // Check target interval discount in bounds\n        if (params_.targetIntervalDiscount > ONE_HUNDRED_PERCENT) revert Auctioneer_InvalidParams();\n\n        // Calculate decay speed\n        term.decaySpeed = (length * params_.targetIntervalDiscount) / params_.depositInterval;\n\n        // Store bond time terms\n        term.vesting = params_.vesting;\n        term.conclusion = params_.conclusion;\n        term.length = length;\n\n        // Emit market created event\n        emit MarketCreated(\n            marketId,\n            address(params_.payoutToken),\n            address(params_.quoteToken),\n            params_.vesting\n        );\n\n        return marketId;\n    }\n\n    function _validateOracle(\n        uint256 id_,\n        IBondOracle oracle_,\n        ERC20 quoteToken_,\n        ERC20 payoutToken_,\n        uint48 baseDiscount_\n    )\n        internal\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Ensure token decimals are in bounds\n        uint8 payoutTokenDecimals = payoutToken_.decimals();\n        uint8 quoteTokenDecimals = quoteToken_.decimals();\n\n        if (payoutTokenDecimals < 6 || payoutTokenDecimals > 18) revert Auctioneer_InvalidParams();\n        if (quoteTokenDecimals < 6 || quoteTokenDecimals > 18) revert Auctioneer_InvalidParams();\n\n        // Check that oracle is valid. It should:\n        // 1. Be a contract\n        if (address(oracle_) == address(0) || address(oracle_).code.length == 0)\n            revert Auctioneer_InvalidParams();\n\n        // 2. Allow registering markets\n        oracle_.registerMarket(id_, quoteToken_, payoutToken_);\n\n        // 3. Return a valid price for the quote token : payout token pair\n        uint256 currentPrice = oracle_.currentPrice(id_);\n        if (currentPrice == 0) revert Auctioneer_OraclePriceZero();\n\n        // 4. Return a valid decimal value for the quote token : payout token pair price\n        uint8 oracleDecimals = oracle_.decimals(id_);\n        if (oracleDecimals < 6 || oracleDecimals > 18) revert Auctioneer_InvalidParams();\n\n        // Calculate scaling values for market:\n        // 1. We need a value to convert between the oracle decimals to the bond market decimals\n        // 2. We need the bond scaling value to convert between quote and payout tokens using the market price\n\n        // Get the price decimals for the current oracle price\n        // Oracle price is in quote tokens per payout token\n        // E.g. if quote token is $10 and payout token is $2000,\n        // then the oracle price is 200 quote tokens per payout token.\n        // If the oracle has 18 decimals, then it would return 200 * 10^18.\n        // In this case, the price decimals would be 2 since 200 = 2 * 10^2.\n        // We apply the base discount to the oracle price before calculating\n        // since this will be the initial equilibrium price of the market.\n        int8 priceDecimals = _getPriceDecimals(\n            currentPrice.mulDivUp(\n                uint256(ONE_HUNDRED_PERCENT - baseDiscount_),\n                uint256(ONE_HUNDRED_PERCENT)\n            ),\n            oracleDecimals\n        );\n        // Check price decimals in reasonable range\n        // These bounds are quite large and it is unlikely any combination of tokens\n        // will have a price difference larger than 10^24 in either direction.\n        if (priceDecimals < -23 || priceDecimals > 24) revert Auctioneer_InvalidParams();\n\n        // Check that oracle decimals are large enough to avoid precision loss from negative price decimals\n        if (int8(oracleDecimals) <= -priceDecimals) revert Auctioneer_InvalidParams();\n\n        // Calculate the oracle price conversion factor\n        // oraclePriceFactor = int8(oracleDecimals) + priceDecimals;\n        // bondPriceFactor = 36 - priceDecimals / 2 + priceDecimals;\n        // oracleConversion = 10^(bondPriceFactor - oraclePriceFactor);\n        uint256 oracleConversion = 10**uint8(36 - priceDecimals / 2 - int8(oracleDecimals));\n\n        // Unit to scale calculation for this market by to ensure reasonable values\n        // for price, debt, and control variable without under/overflows.\n        //\n        // scaleAdjustment should be equal to (payoutDecimals - quoteDecimals) - ((payoutPriceDecimals - quotePriceDecimals) / 2)\n        // scale = 10^(36 + scaleAdjustment);\n        uint256 scale = 10 **\n            uint8(36 + int8(payoutTokenDecimals) - int8(quoteTokenDecimals) - priceDecimals / 2);\n\n        return (currentPrice * oracleConversion, oracleConversion, scale);\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function pushOwnership(uint256 id_, address newOwner_) external override {\n        if (msg.sender != markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\n        newOwners[id_] = newOwner_;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function pullOwnership(uint256 id_) external override {\n        if (msg.sender != newOwners[id_]) revert Auctioneer_NotAuthorized();\n        markets[id_].owner = newOwners[id_];\n    }\n\n    /// @inheritdoc IBondOSDA\n    function setMinMarketDuration(uint48 duration_) external override requiresAuth {\n        // Restricted to authorized addresses\n\n        // Require duration to be greater than minimum deposit interval and at least 1 day\n        if (duration_ < minDepositInterval || duration_ < 1 days) revert Auctioneer_InvalidParams();\n\n        minMarketDuration = duration_;\n    }\n\n    /// @inheritdoc IBondOSDA\n    function setMinDepositInterval(uint48 depositInterval_) external override requiresAuth {\n        // Restricted to authorized addresses\n\n        // Require min deposit interval to be less than minimum market duration and at least 1 hour\n        if (depositInterval_ > minMarketDuration || depositInterval_ < 1 hours)\n            revert Auctioneer_InvalidParams();\n\n        minDepositInterval = depositInterval_;\n    }\n\n    // Unused, but required by interface\n    function setIntervals(uint256 id_, uint32[3] calldata intervals_) external override {}\n\n    // Unused, but required by interface\n    function setDefaults(uint32[6] memory defaults_) external override {}\n\n    /// @inheritdoc IBondAuctioneer\n    function setAllowNewMarkets(bool status_) external override requiresAuth {\n        /// Restricted to authorized addresses, initially restricted to guardian\n        allowNewMarkets = status_;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function setCallbackAuthStatus(address creator_, bool status_) external override requiresAuth {\n        /// Restricted to authorized addresses, initially restricted to guardian\n        callbackAuthorized[creator_] = status_;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function closeMarket(uint256 id_) external override {\n        if (msg.sender != markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\n        _close(id_);\n    }\n\n    /* ========== TELLER FUNCTIONS ========== */\n\n    /// @inheritdoc IBondAuctioneer\n    function purchaseBond(\n        uint256 id_,\n        uint256 amount_,\n        uint256 minAmountOut_\n    ) external override returns (uint256 payout) {\n        if (msg.sender != address(_teller)) revert Auctioneer_NotAuthorized();\n\n        BondMarket storage market = markets[id_];\n        BondTerms memory term = terms[id_];\n\n        // If market uses a callback, check that owner is still callback authorized\n        if (market.callbackAddr != address(0) && !callbackAuthorized[market.owner])\n            revert Auctioneer_NotAuthorized();\n\n        // Markets end at a defined timestamp, revert if market has concluded\n        if (uint48(block.timestamp) >= term.conclusion)\n            revert Auctioneer_MarketConcluded(term.conclusion);\n\n        // Retrieve price and calculate payout\n        uint256 price = marketPrice(id_);\n\n        // Payout for the deposit = amount / price\n        //\n        // where:\n        // payout = payout tokens out\n        // amount = quote tokens in\n        // price = quote tokens : payout token (i.e. 200 QUOTE : BASE), adjusted for scaling\n        payout = amount_.mulDiv(term.scale, price);\n\n        // Payout must be greater than user inputted minimum\n        if (payout < minAmountOut_) revert Auctioneer_AmountLessThanMinimum();\n\n        // Markets have a max payout amount, capping size because deposits\n        // do not experience slippage. max payout is recalculated upon tuning\n        if (payout > market.maxPayout) revert Auctioneer_MaxPayoutExceeded();\n\n        // Update Capacity\n\n        // Capacity is either the number of payout tokens that the market can sell\n        // (if capacity in quote is false),\n        //\n        // or the number of quote tokens that the market can buy\n        // (if capacity in quote is true)\n\n        // If amount/payout is greater than capacity remaining, revert\n        if (market.capacityInQuote ? amount_ > market.capacity : payout > market.capacity)\n            revert Auctioneer_NotEnoughCapacity();\n        unchecked {\n            // Capacity is decreased by the deposited or paid amount\n            market.capacity -= market.capacityInQuote ? amount_ : payout;\n\n            // Markets keep track of how many quote tokens have been\n            // purchased, and how many payout tokens have been sold\n            market.purchased += amount_;\n            market.sold += payout;\n        }\n    }\n\n    /* ========== INTERNAL DEPO FUNCTIONS ========== */\n\n    /// @notice          Close a market\n    /// @dev             Closing a market sets capacity to 0 and immediately stops bonding\n    function _close(uint256 id_) internal {\n        terms[id_].conclusion = uint48(block.timestamp);\n        markets[id_].capacity = 0;\n\n        emit MarketClosed(id_);\n    }\n\n    /* ========== INTERNAL VIEW FUNCTIONS ========== */\n\n    /// @notice             Calculate current market price of payout token in quote tokens\n    /// @dev                See marketPrice() in IBondOSDA for explanation of price computation\n    /// @param id_          Market ID\n    /// @return             Price for market as a ratio of quote tokens to payout tokens with 36 decimals\n    function _currentMarketPrice(uint256 id_) internal view returns (uint256) {\n        BondMarket memory market = markets[id_];\n        BondTerms memory term = terms[id_];\n\n        // Get price from oracle and apply target discount\n        uint256 price = term.oracle.currentPrice(id_).mulDivUp(\n            (ONE_HUNDRED_PERCENT - term.baseDiscount),\n            ONE_HUNDRED_PERCENT\n        );\n\n        // Revert if price is 0\n        if (price == 0) revert Auctioneer_OraclePriceZero();\n\n        // Scale with the oracle conversion factor\n        price = price * term.oracleConversion;\n\n        // Calculate initial capacity based on remaining capacity and amount sold/purchased up to this point\n        uint256 initialCapacity = market.capacity +\n            (market.capacityInQuote ? market.purchased : market.sold);\n\n        // Compute seconds remaining until market will conclude\n        uint256 timeRemaining = uint256(term.conclusion) - block.timestamp;\n\n        // Calculate expectedCapacity as the capacity expected to be bought or sold up to this point\n        // Higher than current capacity means the market is undersold, lower than current capacity means the market is oversold\n        uint256 expectedCapacity = initialCapacity.mulDiv(timeRemaining, uint256(term.length));\n\n        // Price is increased or decreased based on how far the market is ahead or behind\n        // Intuition:\n        // If the time neutral capacity is higher than the initial capacity, then the market is undersold and price should be discounted\n        // If the time neutral capacity is lower than the initial capacity, then the market is oversold and price should be increased\n        //\n        // This implementation uses a linear price decay\n        // P(t) = P(0) * (1 + k * (X(t) - C(t) / C(0)))\n        // P(t): price at time t\n        // P(0): initial/target price of the market provided by oracle + base discount (see IOSDA.MarketParams)\n        // k: decay speed of the market\n        // k = L / I * d, where L is the duration/length of the market, I is the deposit interval, and d is the target interval discount.\n        // X(t): expected capacity of the market at time t.\n        // X(t) = C(0) * t / L.\n        // C(t): actual capacity of the market at time t.\n        // C(0): initial capacity of the market provided by the user (see IOSDA.MarketParams).\n        uint256 adjustment;\n        if (expectedCapacity > market.capacity) {\n            adjustment =\n                ONE_HUNDRED_PERCENT +\n                (term.decaySpeed * (expectedCapacity - market.capacity)) /\n                initialCapacity;\n        } else {\n            // If actual capacity is greater than expected capacity, we need to check for underflows\n            // The adjustment has a minimum value of 0 since that will reduce the price to 0 as well.\n            uint256 factor = (term.decaySpeed * (market.capacity - expectedCapacity)) /\n                initialCapacity;\n            adjustment = ONE_HUNDRED_PERCENT > factor ? ONE_HUNDRED_PERCENT - factor : 0;\n        }\n\n        return price.mulDivUp(adjustment, ONE_HUNDRED_PERCENT);\n    }\n\n    /* ========== INTERNAL VIEW FUNCTIONS ========== */\n\n    /// @notice         Helper function to calculate number of price decimals based on the value returned from the price feed.\n    /// @param price_   The price to calculate the number of decimals for\n    /// @return         The number of decimals\n    function _getPriceDecimals(uint256 price_, uint8 feedDecimals_) internal pure returns (int8) {\n        int8 decimals;\n        while (price_ >= 10) {\n            price_ = price_ / 10;\n            decimals++;\n        }\n\n        // Subtract the stated decimals from the calculated decimals to get the relative price decimals.\n        // Required to do it this way vs. normalizing at the beginning since price decimals can be negative.\n        return decimals - int8(feedDecimals_);\n    }\n\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\n\n    /// @inheritdoc IBondAuctioneer\n    function getMarketInfoForPurchase(uint256 id_)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address callbackAddr,\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 vesting,\n            uint256 maxPayout_\n        )\n    {\n        BondMarket memory market = markets[id_];\n        return (\n            market.owner,\n            market.callbackAddr,\n            market.payoutToken,\n            market.quoteToken,\n            terms[id_].vesting,\n            maxPayout(id_)\n        );\n    }\n\n    /// @inheritdoc IBondOSDA\n    function marketPrice(uint256 id_) public view override returns (uint256) {\n        uint256 price = _currentMarketPrice(id_);\n\n        return (price > terms[id_].minPrice) ? price : terms[id_].minPrice;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function marketScale(uint256 id_) external view override returns (uint256) {\n        return terms[id_].scale;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function payoutFor(\n        uint256 amount_,\n        uint256 id_,\n        address referrer_\n    ) public view override returns (uint256) {\n        /// Calculate the payout for the given amount of tokens\n        uint256 fee = amount_.mulDiv(_teller.getFee(referrer_), 1e5);\n        uint256 payout = (amount_ - fee).mulDiv(terms[id_].scale, marketPrice(id_));\n\n        /// Check that the payout is less than or equal to the maximum payout,\n        /// Revert if not, otherwise return the payout\n        if (payout > markets[id_].maxPayout) {\n            revert Auctioneer_MaxPayoutExceeded();\n        } else {\n            return payout;\n        }\n    }\n\n    /// @inheritdoc IBondOSDA\n    function maxPayout(uint256 id_) public view override returns (uint256) {\n        // Get current price\n        uint256 price = marketPrice(id_);\n\n        BondMarket memory market = markets[id_];\n        BondTerms memory term = terms[id_];\n\n        // Convert capacity to payout token units for comparison with max payout\n        uint256 capacity = market.capacityInQuote\n            ? market.capacity.mulDiv(term.scale, price)\n            : market.capacity;\n\n        // Cap max payout at the remaining capacity\n        return market.maxPayout > capacity ? capacity : market.maxPayout;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256) {\n        // Calculate maximum amount of quote tokens that correspond to max bond size\n        // Maximum of the maxPayout and the remaining capacity converted to quote tokens\n        BondMarket memory market = markets[id_];\n        BondTerms memory term = terms[id_];\n        uint256 price = marketPrice(id_);\n        uint256 quoteCapacity = market.capacityInQuote\n            ? market.capacity\n            : market.capacity.mulDiv(price, term.scale);\n        uint256 maxQuote = market.maxPayout.mulDiv(price, term.scale);\n        uint256 amountAccepted = quoteCapacity < maxQuote ? quoteCapacity : maxQuote;\n\n        // Take into account teller fees and return\n        // Estimate fee based on amountAccepted. Fee taken will be slightly larger than\n        // this given it will be taken off the larger amount, but this avoids rounding\n        // errors with trying to calculate the exact amount.\n        // Therefore, the maxAmountAccepted is slightly conservative.\n        uint256 estimatedFee = amountAccepted.mulDiv(\n            _teller.getFee(referrer_),\n            ONE_HUNDRED_PERCENT\n        );\n\n        return amountAccepted + estimatedFee;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function isInstantSwap(uint256 id_) public view returns (bool) {\n        uint256 vesting = terms[id_].vesting;\n        return (vesting <= MAX_FIXED_TERM) ? vesting == 0 : vesting <= block.timestamp;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function isLive(uint256 id_) public view override returns (bool) {\n        return (markets[id_].capacity != 0 && terms[id_].conclusion > uint48(block.timestamp));\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function ownerOf(uint256 id_) external view override returns (address) {\n        return markets[id_].owner;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function getTeller() external view override returns (IBondTeller) {\n        return _teller;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function getAggregator() external view override returns (IBondAggregator) {\n        return _aggregator;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function currentCapacity(uint256 id_) external view override returns (uint256) {\n        return markets[id_].capacity;\n    }\n}"
    }
  ]
}