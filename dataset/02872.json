{
  "Title": "H-34: liquidationAccountant can be claimed at any time",
  "Content": "# Issue H-34: liquidationAccountant can be claimed at any time \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/46 \n\n## Found by \nobront\n\n## Summary\n\nNew liquidations are sent to the `liquidationAccountant` with a `finalAuctionTimestamp` value, but the actual value that is passed in is simply the duration of an auction. The `claim()` function uses this value in a require check, so this error will allow it to be called before the auction is complete.\n\n## Vulnerability Detail\n\nWhen a lien is liquidated, `AstariaRouter.sol:liquidate()` is called. If the lien is set to end in a future epoch, we call `handleNewLiquidation()` on the `liquidationAccountant`.\n\nOne of the values passed in this call is the `finalAuctionTimestamp`, which updates the `finalAuctionEnd` variable in the `liquidationAccountant`. This value is then used to protect the `claim()` function from being called too early.\n\nHowever, when the router calls `handleLiquidationAccountant()`, it passes the duration of an auction rather than the final timestamp:\n\n```solidity\nLiquidationAccountant(accountant).handleNewLiquidation(\n  lien.amount,\n  COLLATERAL_TOKEN.auctionWindow() + 1 days\n);\n```\nAs a result, `finalAuctionEnd` will be set to 259200 (3 days). \n\nWhen `claim()` is called, it requires the final auction to have ended for the function to be called:\n\n```solidity\nrequire(\n  block.timestamp > finalAuctionEnd || finalAuctionEnd == uint256(0),\n  \"final auction has not ended\"\n);\n```\nBecause of the error above, `block.timestamp` will always be greater than `finalAuctionEnd`, so this will always be permitted. \n\n## Impact\n\nAnyone can call `claim()` before an auction has ended. This can cause many problems, but the clearest is that it can ruin the protocol's accounting by decreasing the Y intercept of the vault. \n\nFor example, if `claim()` is called before the auction, the returned value will be 0, so the Y intercept will be decreased as if there was an auction that returned no funds. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L407-L410\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L113-L120\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L65-L69\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdjust the call from the router to use the ending timestamp as the argument, rather than the duration:\n\n```solidity\nLiquidationAccountant(accountant).handleNewLiquidation(\n  lien.amount,\n  block.timestamp + COLLATERAL_TOKEN.auctionWindow() + 1 days\n);\n```\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nTouched on the same idea as #135. Tough call on duplication. This issue + #47 combine represent the same vulnerability fixed in both #135 and #188. In this issue it addresses being called too early and in #47 it addresses being called multiple times. The fix proposed in #135 and #188 address both issues by permissioning the function. IMHO this and 47 should be duped with #135 and #188, but up to judges. \n\nALSO little bit of a conflict of interest that @zobront validated his own issue here.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Touched on the same idea as #135. Tough call on duplication. This issue + #47 combine represent the same vulnerability fixed in both #135 and #188. In this issue it addresses being called too early and in #47 it addresses being called multiple times. The fix proposed in #135 and #188 address both issues by permissioning the function. IMHO this and 47 should be duped with #135 and #188, but up to judges. \n> \n> ALSO little bit of a conflict of interest that @zobront validated his own issue here.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted.\n\n#135 and #188 are already duplicates. This issue and #47 touch on the same core issue that `claim()` is not safe to be publicly callable. \n\n**sherlock-admin**\n\n> Escalation accepted.\n> \n> #135 and #188 are already duplicates. This issue and #47 touch on the same core issue that `claim()` is not safe to be publicly callable. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**zobront**\n\nEscalate for 5 USDC\n\nThis isn’t a dup of #135 or #188. Those two issues are talking about access control for the function. This calls out that there is a specific time enforcement mechanism (`finalAuctionTimestamp`) that is calculated incorrectly, allowing it to be called early.\n\nYes, I agree that adding access controls (their solution) would reduce the harm from this issue, but they are unrelated issues that just happen to have overlapping solutions. The real solution to this one is to do the calculation properly.\n\nNOTE: The other issue of mine that was dup’d with these is #47, which focuses on that there aren’t restrictions to stop `claim()` being called multiple times. I probably wouldn’t consider that a dup of theirs either, but it’s on the fence so I’m ok with it — but this one is clearly different.\n\n**sherlock-admin**\n\n > Escalate for 5 USDC\n> \n> This isn’t a dup of #135 or #188. Those two issues are talking about access control for the function. This calls out that there is a specific time enforcement mechanism (`finalAuctionTimestamp`) that is calculated incorrectly, allowing it to be called early.\n> \n> Yes, I agree that adding access controls (their solution) would reduce the harm from this issue, but they are unrelated issues that just happen to have overlapping solutions. The real solution to this one is to do the calculation properly.\n> \n> NOTE: The other issue of mine that was dup’d with these is #47, which focuses on that there aren’t restrictions to stop `claim()` being called multiple times. I probably wouldn’t consider that a dup of theirs either, but it’s on the fence so I’m ok with it — but this one is clearly different.\n\nYou've created a valid escalation for 5 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted. at the initial escalation we misinterpreted the https://github.com/sherlock-audit/2022-10-astaria-judging/issues/135 / https://github.com/sherlock-audit/2022-10-astaria-judging/issues/188 as it was thought they described both issues. \n\n**sherlock-admin**\n\n> Escalation accepted. at the initial escalation we misinterpreted the https://github.com/sherlock-audit/2022-10-astaria-judging/issues/135 / https://github.com/sherlock-audit/2022-10-astaria-judging/issues/188 as it was thought they described both issues. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/AstariaRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IERC721} from \"gpl/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"gpl/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\nimport {IStrategyValidator} from \"./interfaces/IStrategyValidator.sol\";\n\nimport {IPublicVault, PublicVault} from \"./PublicVault.sol\";\nimport {IVault, VaultImplementation} from \"./VaultImplementation.sol\";\nimport {LiquidationAccountant} from \"./LiquidationAccountant.sol\";\n\nimport {MerkleProof} from \"./utils/MerkleProof.sol\";\nimport {Pausable} from \"./utils/Pausable.sol\";\n\n/**\n * @title AstariaRouter\n * @notice This contract manages the deployment of Vaults and universal Astaria actions.\n */\ncontract AstariaRouter is Auth, Pausable, IAstariaRouter {\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  ERC20 public immutable WETH;\n  ICollateralToken public immutable COLLATERAL_TOKEN;\n  ILienToken public immutable LIEN_TOKEN;\n  ITransferProxy public immutable TRANSFER_PROXY;\n\n  address public LIQUIDATION_IMPLEMENTATION;\n  address public SOLO_IMPLEMENTATION;\n  address public VAULT_IMPLEMENTATION;\n  address public WITHDRAW_IMPLEMENTATION;\n  address public feeTo;\n  uint256 public liquidationFeePercent;\n  uint256 public maxInterestRate;\n  uint256 public maxEpochLength;\n  uint256 public minEpochLength;\n  uint256 public minInterestBPS; // was uint64\n  uint256 public protocolFeeNumerator;\n  uint256 public protocolFeeDenominator;\n  uint256 public strategistFeeNumerator;\n  uint256 public strategistFeeDenominator;\n  uint256 public buyoutFeeNumerator;\n  uint256 public buyoutFeeDenominator;\n  uint32 public minDurationIncrease;\n  uint32 public buyoutInterestWindow;\n\n  //A strategist can have many deployed vaults\n  mapping(address => address) public vaults;\n  mapping(address => uint256) public strategistNonce;\n  mapping(uint16 => address) public strategyValidators;\n\n  /**\n   * @dev Setup transfer authority and set up addresses for deployed CollateralToken, LienToken, TransferProxy contracts, as well as PublicVault and SoloVault implementations to clone.\n   * @param _AUTHORITY The authority manager.\n   * @param _WETH The WETH address to use for transfers.\n   * @param _COLLATERAL_TOKEN The address of the deployed CollateralToken contract.\n   * @param _LIEN_TOKEN The address of the deployed LienToken contract.\n   * @param _TRANSFER_PROXY The address of the deployed TransferProxy contract.\n   * @param _VAULT_IMPL The address of a base implementation of VaultImplementation for cloning.\n   * @param _SOLO_IMPL The address of a base implementation of a PrivateVault for cloning.\n   */\n  constructor(\n    Authority _AUTHORITY,\n    address _WETH,\n    ICollateralToken _COLLATERAL_TOKEN,\n    ILienToken _LIEN_TOKEN,\n    ITransferProxy _TRANSFER_PROXY,\n    address _VAULT_IMPL,\n    address _SOLO_IMPL\n  ) Auth(address(msg.sender), _AUTHORITY) {\n    WETH = ERC20(_WETH);\n    COLLATERAL_TOKEN = _COLLATERAL_TOKEN;\n    LIEN_TOKEN = _LIEN_TOKEN;\n    TRANSFER_PROXY = _TRANSFER_PROXY;\n    VAULT_IMPLEMENTATION = _VAULT_IMPL;\n    SOLO_IMPLEMENTATION = _SOLO_IMPL;\n    liquidationFeePercent = 13;\n    minInterestBPS = uint256(0.0005 ether) / uint256(365 days); //5 bips / second\n    minEpochLength = 7 days;\n    maxEpochLength = 45 days;\n    maxInterestRate = 63419583966; // 200% apy / second\n    strategistFeeNumerator = 200;\n    strategistFeeDenominator = 1000;\n    minDurationIncrease = 14 days;\n    buyoutInterestWindow = 60 days;\n  }\n\n  /**\n   * @dev Enables _pause, freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyPause() external requiresAuth whenNotPaused {\n    _pause();\n  }\n\n  /**\n   * @dev Disables _pause, un-freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyUnpause() external requiresAuth whenPaused {\n    _unpause();\n  }\n\n  function incrementNonce() external {\n    strategistNonce[msg.sender]++;\n  }\n\n  /**\n   * @notice Sets universal protocol parameters or changes the addresses for deployed contracts.\n   * @param what The identifier for what is being filed.\n   * @param data The encoded address data to be decoded and filed.\n   */\n  function fileBatch(bytes32[] memory what, bytes[] calldata data)\n    external\n    requiresAuth\n  {\n    require(what.length == data.length, \"data length mismatch\");\n    for (uint256 i = 0; i < what.length; i++) {\n      file(what[i], data[i]);\n    }\n  }\n\n  function file(bytes32 what, bytes calldata data) public requiresAuth {\n    if (what == \"LIQUIDATION_FEE_PERCENT\") {\n      uint256 value = abi.decode(data, (uint256));\n      liquidationFeePercent = value;\n    } else if (what == \"MIN_INTEREST_BPS\") {\n      uint256 value = abi.decode(data, (uint256));\n      minInterestBPS = uint256(value);\n    } else if (what == \"APPRAISER_NUMERATOR\") {\n      uint256 value = abi.decode(data, (uint256));\n      strategistFeeNumerator = value;\n    } else if (what == \"APPRAISER_ORIGINATION_FEE_BASE\") {\n      uint256 value = abi.decode(data, (uint256));\n      strategistFeeDenominator = value;\n    } else if (what == \"MIN_DURATION_INCREASE\") {\n      uint256 value = abi.decode(data, (uint256));\n      minDurationIncrease = value.safeCastTo32();\n    } else if (what == \"WITHDRAW_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      WITHDRAW_IMPLEMENTATION = addr;\n    } else if (what == \"LIQUIDATION_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      LIQUIDATION_IMPLEMENTATION = addr;\n    } else if (what == \"VAULT_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      VAULT_IMPLEMENTATION = addr;\n    } else if (what == \"SOLO_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      SOLO_IMPLEMENTATION = addr;\n    } else if (what == \"MIN_EPOCH_LENGTH\") {\n      minEpochLength = abi.decode(data, (uint256));\n    } else if (what == \"MAX_EPOCH_LENGTH\") {\n      maxEpochLength = abi.decode(data, (uint256));\n    } else if (what == \"MAX_INTEREST_RATE\") {\n      maxInterestRate = abi.decode(data, (uint256));\n    } else if (what == \"feeTo\") {\n      address addr = abi.decode(data, (address));\n      feeTo = addr;\n    } else if (what == \"setBuyoutInterestWindow\") {\n      uint256 value = abi.decode(data, (uint256));\n      buyoutInterestWindow = value.safeCastTo32();\n    } else if (what == \"setStrategyValidator\") {\n      (uint8 TYPE, address addr) = abi.decode(data, (uint8, address));\n      strategyValidators[TYPE] = addr;\n    } else {\n      revert(\"unsupported/file\");\n    }\n  }\n\n  // MODIFIERS\n  modifier onlyVaults() {\n    require(\n      vaults[msg.sender] != address(0),\n      \"this vault has not been initialized\"\n    );\n    _;\n  }\n\n  //PUBLIC\n\n  function validateCommitment(IAstariaRouter.Commitment calldata commitment)\n    public\n    returns (bool valid, IAstariaRouter.LienDetails memory ld)\n  {\n    require(\n      commitment.lienRequest.strategy.deadline >= block.timestamp,\n      \"deadline passed\"\n    );\n\n    require(\n      strategyValidators[commitment.lienRequest.nlrType] != address(0),\n      \"invalid strategy type\"\n    );\n\n    bytes32 leaf;\n    (leaf, ld) = IStrategyValidator(\n      strategyValidators[commitment.lienRequest.nlrType]\n    ).validateAndParse(\n        commitment.lienRequest,\n        COLLATERAL_TOKEN.ownerOf(\n          commitment.tokenContract.computeId(commitment.tokenId)\n        ),\n        commitment.tokenContract,\n        commitment.tokenId\n      );\n\n    return (\n      MerkleProof.verifyCalldata(\n        commitment.lienRequest.merkle.proof,\n        commitment.lienRequest.merkle.root,\n        leaf\n      ),\n      ld\n    );\n  }\n\n  /**\n   * @notice Deposits collateral and requests loans for multiple NFTs at once.\n   * @param commitments The commitment proofs and requested loan data for each loan.\n   * @return totalBorrowed The total amount borrowed by the requested loans.\n   */\n  function commitToLiens(IAstariaRouter.Commitment[] calldata commitments)\n    external\n    whenNotPaused\n    returns (uint256 totalBorrowed)\n  {\n    totalBorrowed = 0;\n    for (uint256 i = 0; i < commitments.length; ++i) {\n      _transferAndDepositAsset(\n        commitments[i].tokenContract,\n        commitments[i].tokenId\n      );\n      totalBorrowed += _executeCommitment(commitments[i]);\n\n      uint256 collateralId = commitments[i].tokenContract.computeId(\n        commitments[i].tokenId\n      );\n      _returnCollateral(collateralId, address(msg.sender));\n    }\n    WETH.safeApprove(address(TRANSFER_PROXY), totalBorrowed);\n    TRANSFER_PROXY.tokenTransferFrom(\n      address(WETH),\n      address(this),\n      address(msg.sender),\n      totalBorrowed\n    );\n  }\n\n  /**\n   * @notice Deploys a new PrivateVault.\n   * @return The address of the new PrivateVault.\n   */\n  function newVault(address delegate) external whenNotPaused returns (address) {\n    return _newVault(uint256(0), delegate, uint256(0));\n  }\n\n  /**\n   * @notice Deploys a new PublicVault.\n   * @param epochLength The length of each epoch for the new PublicVault.\n   */\n  function newPublicVault(\n    uint256 epochLength,\n    address delegate,\n    uint256 vaultFee\n  ) external whenNotPaused returns (address) {\n    return _newVault(epochLength, delegate, vaultFee);\n  }\n\n  /**\n   * @notice Create a new lien against a CollateralToken.\n   * @param terms the decoded lien details from the commitment\n   * @param params The valid proof and lien details for the new loan.\n   * @return The ID of the created lien.\n   */\n  function requestLienPosition(\n    IAstariaRouter.LienDetails memory terms,\n    IAstariaRouter.Commitment calldata params\n  ) external whenNotPaused onlyVaults returns (uint256) {\n    return\n      LIEN_TOKEN.createLien(\n        ILienBase.LienActionEncumber({\n          tokenContract: params.tokenContract,\n          tokenId: params.tokenId,\n          terms: terms,\n          strategyRoot: params.lienRequest.merkle.root,\n          amount: params.lienRequest.amount,\n          vault: address(msg.sender)\n        })\n      );\n  }\n\n  /**\n   * @notice Lend to a PublicVault.\n   * @param vault The address of the PublicVault.\n   * @param amount The amount to lend.\n   */\n  function lendToVault(IVault vault, uint256 amount) external whenNotPaused {\n    TRANSFER_PROXY.tokenTransferFrom(\n      address(WETH),\n      address(msg.sender),\n      address(this),\n      amount\n    );\n\n    require(\n      vaults[address(vault)] != address(0),\n      \"lendToVault: vault doesn't exist\"\n    );\n    WETH.safeApprove(address(vault), amount);\n    vault.deposit(amount, address(msg.sender));\n  }\n\n  /**\n   * @notice Returns whether a specific lien can be liquidated.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The specified lien position.\n   * @return A boolean value indicating whether the specified lien can be liquidated.\n   */\n  function canLiquidate(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (bool)\n  {\n    ILienToken.Lien memory lien = LIEN_TOKEN.getLien(collateralId, position);\n\n    return (lien.start + lien.duration <= block.timestamp && lien.amount > 0);\n  }\n\n  /**\n   * @notice Liquidate a CollateralToken that has defaulted on one of its liens.\n   * @param collateralId The ID of the CollateralToken.\n   * @param position The position of the defaulted lien.\n   * @return reserve The amount owed on all liens for against the collateral being liquidated, including accrued interest.\n   */\n  function liquidate(uint256 collateralId, uint256 position)\n    external\n    returns (uint256 reserve)\n  {\n    require(\n      canLiquidate(collateralId, position),\n      \"liquidate: borrow is healthy\"\n    );\n\n    // if expiration will be past epoch boundary, then create a LiquidationAccountant\n\n    uint256[] memory liens = LIEN_TOKEN.getLiens(collateralId);\n    for (uint256 i = 0; i < liens.length; ++i) {\n      uint256 currentLien = liens[i];\n\n      ILienToken.Lien memory lien = LIEN_TOKEN.getLien(currentLien);\n\n      address owner = LIEN_TOKEN.ownerOf(currentLien);\n      if (\n        IPublicVault(owner).supportsInterface(type(IPublicVault).interfaceId)\n      ) {\n        // subtract slope from PublicVault\n\n        PublicVault(owner).updateVaultAfterLiquidation(\n          LIEN_TOKEN.calculateSlope(currentLien)\n        );\n        if (\n          PublicVault(owner).timeToEpochEnd() <=\n          COLLATERAL_TOKEN.auctionWindow()\n        ) {\n          uint64 currentEpoch = PublicVault(owner).getCurrentEpoch();\n          address accountant = PublicVault(owner).getLiquidationAccountant(\n            currentEpoch\n          );\n          uint256 lienEpoch = PublicVault(owner).getLienEpoch(\n            lien.start + lien.duration\n          );\n          PublicVault(owner).decreaseEpochLienCount(lienEpoch);\n\n          // only deploy a LiquidationAccountant for the next set of withdrawing LPs if the previous set of LPs have been repaid\n          if (PublicVault(owner).withdrawReserve() == 0) {\n            if (accountant == address(0)) {\n              accountant = PublicVault(owner).deployLiquidationAccountant();\n            }\n            LIEN_TOKEN.setPayee(currentLien, accountant);\n            LiquidationAccountant(accountant).handleNewLiquidation(\n              lien.amount,\n              COLLATERAL_TOKEN.auctionWindow() + 1 days\n            );\n            PublicVault(owner).increaseLiquidationsExpectedAtBoundary(\n              lien.amount\n            );\n          }\n        }\n      }\n    }\n\n    reserve = COLLATERAL_TOKEN.auctionVault(\n      collateralId,\n      address(msg.sender),\n      liquidationFeePercent\n    );\n\n    emit Liquidation(collateralId, position, reserve);\n  }\n\n  /**\n   * @notice Retrieves the fee PublicVault strategists earn on loan origination.\n   * @return The numerator and denominator used to compute the percentage fee strategists earn by receiving minted vault shares.\n   */\n  function getStrategistFee(uint256 amountIn) external view returns (uint256) {\n    return\n      amountIn.mulDivDown(strategistFeeNumerator, strategistFeeDenominator);\n  }\n\n  /**\n   * @notice Retrieves the fee the protocol earns on loan origination.\n   * @return The numerator and denominator used to compute the percentage fee taken by the protocol\n   */\n  function getProtocolFee(uint256 amountIn) external view returns (uint256) {\n    return amountIn.mulDivDown(protocolFeeNumerator, protocolFeeDenominator);\n  }\n\n  /**\n   * @notice Retrieves the fee the protocol earns on loan origination.\n   * @return The numerator and denominator used to compute the percentage fee taken by the protocol\n   */\n\n  function getBuyoutFee(uint256 remainingInterestIn)\n    external\n    view\n    returns (uint256)\n  {\n    return\n      remainingInterestIn.mulDivDown(buyoutFeeNumerator, buyoutFeeDenominator);\n  }\n\n  /**\n   * @notice Retrieves the time window for computing maxbuyout costs\n   * @return The numerator and denominator used to compute the percentage fee taken by the protocol\n   */\n  function getBuyoutInterestWindow() external view returns (uint32) {\n    return buyoutInterestWindow;\n  }\n\n  /**\n   * @notice Returns whether a given address is that of a Vault.\n   * @param vault The Vault address.\n   * @return A boolean representing whether the address exists as a Vault.\n   */\n  function isValidVault(address vault) external view returns (bool) {\n    return vaults[vault] != address(0);\n  }\n\n  /**\n   * @notice Determines whether a potential refinance meets the minimum requirements for replacing a lien.\n   * @param lien The Lien to be refinanced.\n   * @param newLien The new Lien to replace the existing one.\n   * @return A boolean representing whether the potential refinance is valid.\n   */\n  function isValidRefinance(\n    ILienToken.Lien memory lien,\n    LienDetails memory newLien\n  ) external view returns (bool) {\n    uint256 minNewRate = uint256(lien.rate) - minInterestBPS;\n\n    return (newLien.rate >= minNewRate &&\n      ((block.timestamp + newLien.duration - lien.start - lien.duration) >=\n        minDurationIncrease));\n  }\n\n  //INTERNAL FUNCS\n\n  /**\n   * @dev Deploys a new PublicVault.\n   * @param epochLength The length of each epoch for the new PublicVault.\n   * @return The address for the new PublicVault.\n   */\n  function _newVault(\n    uint256 epochLength,\n    address delegate,\n    uint256 vaultFee\n  ) internal returns (address) {\n    uint8 vaultType;\n\n    address implementation;\n    if (epochLength > uint256(0)) {\n      require(\n        epochLength >= minEpochLength && epochLength <= maxEpochLength,\n        \"epochLength must be greater than or equal to MIN_EPOCH_LENGTH and less than MAX_EPOCH_LENGTH\"\n      );\n      implementation = VAULT_IMPLEMENTATION;\n      vaultType = uint8(VaultType.PUBLIC);\n    } else {\n      implementation = SOLO_IMPLEMENTATION;\n      vaultType = uint8(VaultType.SOLO);\n    }\n\n    //immutable data\n    address vaultAddr = ClonesWithImmutableArgs.clone(\n      implementation,\n      abi.encodePacked(\n        address(msg.sender),\n        address(WETH),\n        address(COLLATERAL_TOKEN),\n        address(this),\n        address(COLLATERAL_TOKEN.AUCTION_HOUSE()),\n        block.timestamp,\n        epochLength,\n        vaultType,\n        vaultFee\n      )\n    );\n\n    //mutable data\n    VaultImplementation(vaultAddr).init(\n      VaultImplementation.InitParams(delegate)\n    );\n\n    vaults[vaultAddr] = msg.sender;\n\n    emit NewVault(msg.sender, vaultAddr);\n\n    return vaultAddr;\n  }\n\n  /**\n   * @dev validates msg sender is owner\n   * @param c The commitment Data\n   * @return the amount borrowed\n   */\n  function _executeCommitment(IAstariaRouter.Commitment memory c)\n    internal\n    returns (uint256)\n  {\n    uint256 collateralId = c.tokenContract.computeId(c.tokenId);\n    require(\n      msg.sender == COLLATERAL_TOKEN.ownerOf(collateralId),\n      \"invalid sender for collateralId\"\n    );\n    return _borrow(c, address(this));\n  }\n\n  function _borrow(IAstariaRouter.Commitment memory c, address receiver)\n    internal\n    returns (uint256)\n  {\n    //router must be approved for the collateral to take a loan,\n    VaultImplementation(c.lienRequest.strategy.vault).commitToLien(c, receiver);\n    if (receiver == address(this)) {\n      return c.lienRequest.amount;\n    } else {\n      return uint256(0);\n    }\n  }\n\n  function _transferAndDepositAsset(address tokenContract, uint256 tokenId)\n    internal\n  {\n    IERC721(tokenContract).safeTransferFrom(\n      address(msg.sender),\n      address(COLLATERAL_TOKEN),\n      tokenId,\n      \"\"\n    );\n  }\n\n  function _returnCollateral(uint256 collateralId, address receiver) internal {\n    COLLATERAL_TOKEN.transferFrom(address(this), receiver, collateralId);\n  }\n}"
    },
    {
      "filename": "src/LiquidationAccountant.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\n\nimport {ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {PublicVault} from \"./PublicVault.sol\";\nimport {WithdrawProxy} from \"./WithdrawProxy.sol\";\n\nabstract contract LiquidationBase is Clone {\n  function underlying() public pure returns (address) {\n    return _getArgAddress(0);\n  }\n\n  function ROUTER() public pure returns (address) {\n    return _getArgAddress(20);\n  }\n\n  function VAULT() public pure returns (address) {\n    return _getArgAddress(40);\n  }\n\n  function LIEN_TOKEN() public pure returns (address) {\n    return _getArgAddress(60);\n  }\n\n  function WITHDRAW_PROXY() public pure returns (address) {\n    return _getArgAddress(80);\n  }\n}\n\n/**\n * @title LiquidationAccountant\n * @author santiagogregory\n * @notice This contract collects funds from liquidations that overlap with an epoch boundary where liquidity providers are exiting.\n * When the final auction being tracked by a LiquidationAccountant for a given epoch is completed,\n * claim() proportionally pays out auction funds to withdrawing liquidity providers and the PublicVault.\n */\ncontract LiquidationAccountant is LiquidationBase {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  uint256 withdrawRatio;\n\n  uint256 expected; // Expected value of auctioned NFTs. yIntercept (virtual assets) of a PublicVault are not modified on liquidation, only once an auction is completed.\n  uint256 finalAuctionEnd; // when this is deleted, we know the final auction is over\n\n  /**\n   * @notice Proportionally sends funds collected from auctions to withdrawing liquidity providers and the PublicVault for this LiquidationAccountant.\n   */\n  function claim() public {\n    require(\n      block.timestamp > finalAuctionEnd || finalAuctionEnd == uint256(0),\n      \"final auction has not ended\"\n    );\n\n    uint256 balance = ERC20(underlying()).balanceOf(address(this));\n    // would happen if there was no WithdrawProxy for current epoch\n    if (withdrawRatio == uint256(0)) {\n      ERC20(underlying()).safeTransfer(VAULT(), balance);\n    } else {\n      //should be wad multiplication\n      // declining\n      uint256 transferAmount = withdrawRatio.mulDivDown(balance, 1e18);\n\n      if (transferAmount > uint256(0)) {\n        ERC20(underlying()).safeTransfer(WITHDRAW_PROXY(), transferAmount);\n      }\n\n      unchecked {\n        balance -= transferAmount;\n      }\n\n      ERC20(underlying()).safeTransfer(VAULT(), balance);\n    }\n\n    PublicVault(VAULT()).decreaseYIntercept(\n      (expected - ERC20(underlying()).balanceOf(address(this))).mulDivDown(\n        1e18 - withdrawRatio,\n        1e18\n      )\n    );\n  }\n\n  /**\n   * @notice Called at epoch boundary, computes the ratio between the funds of withdrawing liquidity providers and the balance of the underlying PublicVault so that claim() proportionally pays out to all parties.\n   */\n  function setWithdrawRatio(uint256 liquidationWithdrawRatio) public {\n    require(msg.sender == VAULT());\n\n    withdrawRatio = liquidationWithdrawRatio;\n  }\n\n  /**\n   * @notice Adds an auction scheduled to end in a new epoch to this LiquidationAccountant.\n   * @param newLienExpectedValue The expected auction value for the lien being auctioned.\n   * @param finalAuctionTimestamp The timestamp by which the auction being added is guaranteed to end. As new auctions are added to the LiquidationAccountant, this value will strictly increase as all auctions have the same maximum duration.\n   */\n  function handleNewLiquidation(\n    uint256 newLienExpectedValue,\n    uint256 finalAuctionTimestamp\n  ) public {\n    require(msg.sender == ROUTER());\n    expected += newLienExpectedValue;\n    finalAuctionEnd = finalAuctionTimestamp;\n  }\n\n  function getFinalAuctionEnd() external view returns (uint256) {\n    return finalAuctionEnd;\n  }\n}"
    },
    {
      "filename": "src/LiquidationAccountant.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\n\nimport {ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {PublicVault} from \"./PublicVault.sol\";\nimport {WithdrawProxy} from \"./WithdrawProxy.sol\";\n\nabstract contract LiquidationBase is Clone {\n  function underlying() public pure returns (address) {\n    return _getArgAddress(0);\n  }\n\n  function ROUTER() public pure returns (address) {\n    return _getArgAddress(20);\n  }\n\n  function VAULT() public pure returns (address) {\n    return _getArgAddress(40);\n  }\n\n  function LIEN_TOKEN() public pure returns (address) {\n    return _getArgAddress(60);\n  }\n\n  function WITHDRAW_PROXY() public pure returns (address) {\n    return _getArgAddress(80);\n  }\n}\n\n/**\n * @title LiquidationAccountant\n * @author santiagogregory\n * @notice This contract collects funds from liquidations that overlap with an epoch boundary where liquidity providers are exiting.\n * When the final auction being tracked by a LiquidationAccountant for a given epoch is completed,\n * claim() proportionally pays out auction funds to withdrawing liquidity providers and the PublicVault.\n */\ncontract LiquidationAccountant is LiquidationBase {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  uint256 withdrawRatio;\n\n  uint256 expected; // Expected value of auctioned NFTs. yIntercept (virtual assets) of a PublicVault are not modified on liquidation, only once an auction is completed.\n  uint256 finalAuctionEnd; // when this is deleted, we know the final auction is over\n\n  /**\n   * @notice Proportionally sends funds collected from auctions to withdrawing liquidity providers and the PublicVault for this LiquidationAccountant.\n   */\n  function claim() public {\n    require(\n      block.timestamp > finalAuctionEnd || finalAuctionEnd == uint256(0),\n      \"final auction has not ended\"\n    );\n\n    uint256 balance = ERC20(underlying()).balanceOf(address(this));\n    // would happen if there was no WithdrawProxy for current epoch\n    if (withdrawRatio == uint256(0)) {\n      ERC20(underlying()).safeTransfer(VAULT(), balance);\n    } else {\n      //should be wad multiplication\n      // declining\n      uint256 transferAmount = withdrawRatio.mulDivDown(balance, 1e18);\n\n      if (transferAmount > uint256(0)) {\n        ERC20(underlying()).safeTransfer(WITHDRAW_PROXY(), transferAmount);\n      }\n\n      unchecked {\n        balance -= transferAmount;\n      }\n\n      ERC20(underlying()).safeTransfer(VAULT(), balance);\n    }\n\n    PublicVault(VAULT()).decreaseYIntercept(\n      (expected - ERC20(underlying()).balanceOf(address(this))).mulDivDown(\n        1e18 - withdrawRatio,\n        1e18\n      )\n    );\n  }\n\n  /**\n   * @notice Called at epoch boundary, computes the ratio between the funds of withdrawing liquidity providers and the balance of the underlying PublicVault so that claim() proportionally pays out to all parties.\n   */\n  function setWithdrawRatio(uint256 liquidationWithdrawRatio) public {\n    require(msg.sender == VAULT());\n\n    withdrawRatio = liquidationWithdrawRatio;\n  }\n\n  /**\n   * @notice Adds an auction scheduled to end in a new epoch to this LiquidationAccountant.\n   * @param newLienExpectedValue The expected auction value for the lien being auctioned.\n   * @param finalAuctionTimestamp The timestamp by which the auction being added is guaranteed to end. As new auctions are added to the LiquidationAccountant, this value will strictly increase as all auctions have the same maximum duration.\n   */\n  function handleNewLiquidation(\n    uint256 newLienExpectedValue,\n    uint256 finalAuctionTimestamp\n  ) public {\n    require(msg.sender == ROUTER());\n    expected += newLienExpectedValue;\n    finalAuctionEnd = finalAuctionTimestamp;\n  }\n\n  function getFinalAuctionEnd() external view returns (uint256) {\n    return finalAuctionEnd;\n  }\n}"
    }
  ]
}