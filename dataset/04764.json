{
  "Title": "[M-09] Adjusting \"_I_\" will create a sandwich opportunity because of price changes",
  "Content": "\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/main/src/mimswap/MagicLP.sol#L470-#L510> \n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/main/src/mimswap/MagicLP.sol#L244-#L265>\n\nBecause `MagicLP` is forked from DODO, we will check DODO documentation to understand this contract. From [DODO documentation](https://docs.dodoex.io/en/developer/contracts/dodo-v1-v2/dodo-v1-v2-integration-guide), the \"*I*\" is the \"i\" value in here and it is directly related with the output amount a trader will receive when selling a quote/base token:\n\n![img](https://i.imgur.com/UpeLbGg.png)\n\nAdjusting the value of \"*I*\" directly by calling `setParameters()` function will influence the price. This can be exploited by a MEV bot, simply by trading just before the `setParameters()` function and exiting right after the price change. The profit gained from this operation essentially represents potential losses for the liquidity providers who supplied liquidity to the pool.\n\n### Impact\n\nSince the price will change, the MEV bot can simply sandwich the tx and get profit.\n\nAnother note on this is that even though the adjustPrice called by `onlyImplementationOwner` without getting frontrunned, it still creates a big price difference which requires immediate arbitrages. Usually these type of parameter changes that impacts the trades are setted by time via ramping to mitigate the unfair advantages that it can occur during the price update.\n\n### Recommended Mitigation Steps\n\nAcknowledge the issue and use private RPC's to eliminate front-running or slowly ramp up the \"*I*\" so that the arbitrage opportunity is fair\n\n**[0xCalibur (Abracadabra) acknowledged and commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/171#issuecomment-2002305625):**\n > Fixed in main:\n> https://github.com/Abracadabra-money/abracadabra-money-contracts/\n> \n> We now have protocol own pool and can disable trading for our own pools, changing the parameters and make sure the pool is in good state before enabling it back.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/mimswap/MagicLP.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solady/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solady/tokens/ERC20.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {Math} from \"/mimswap/libraries/Math.sol\";\nimport {PMMPricing} from \"/mimswap/libraries/PMMPricing.sol\";\nimport {ICallee} from \"/mimswap/interfaces/ICallee.sol\";\nimport {IFeeRateModel} from \"/mimswap/interfaces/IFeeRateModel.sol\";\nimport {IWETH} from \"interfaces/IWETH.sol\";\n\n/// @title MIMSwap MagicLP\n/// @author Adapted from DODOEX DSP https://github.com/DODOEX/contractV2/tree/main/contracts/DODOStablePool\ncontract MagicLP is ERC20, ReentrancyGuard, Owned {\n    using Math for uint256;\n    using SafeCastLib for uint256;\n    using SafeTransferLib for address;\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n    event Swap(address fromToken, address toToken, uint256 fromAmount, uint256 toAmount, address trader, address receiver);\n    event FlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\n    event RChange(PMMPricing.RState newRState);\n    event TokenRescue(address indexed token, address to, uint256 amount);\n    event ParametersChanged(uint256 newLpFeeRate, uint256 newI, uint256 newK, uint256 newBaseReserve, uint256 newQuoteReserve);\n\n    error ErrInitialized();\n    error ErrBaseQuoteSame();\n    error ErrInvalidI();\n    error ErrInvalidK();\n    error ErrExpired();\n    error ErrInvalidSignature();\n    error ErrFlashLoanFailed();\n    error ErrNoBaseInput();\n    error ErrZeroAddress();\n    error ErrZeroQuoteAmount();\n    error ErrZeroQuoteTarget();\n    error ErrMintAmountNotEnough();\n    error ErrNotEnough();\n    error ErrWithdrawNotEnough();\n    error ErrSellBackNotAllowed();\n    error ErrInvalidLPFeeRate();\n    error ErrNotImplementationOwner();\n    error ErrNotImplementation();\n    error ErrNotClone();\n    error ErrNotAllowed();\n    error ErrReserveAmountNotEnough();\n    error ErrOverflow();\n\n    MagicLP public immutable implementation;\n\n    uint256 public constant MAX_I = 10 ** 36;\n    uint256 public constant MAX_K = 10 ** 18;\n    uint256 public constant MIN_LP_FEE_RATE = 1e14; // 0.01%\n    uint256 public constant MAX_LP_FEE_RATE = 1e16; // 1%\n\n    bool internal _INITIALIZED_;\n\n    address public _BASE_TOKEN_;\n    address public _QUOTE_TOKEN_;\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    uint32 public _RState_;\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    uint256 public _LP_FEE_RATE_;\n    uint256 public _K_;\n    uint256 public _I_;\n\n    constructor(address owner_) Owned(owner_) {\n        implementation = this;\n\n        // prevents the implementation contract initialization\n        _INITIALIZED_ = true;\n    }\n\n    function init(\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k\n    ) external {\n        if (_INITIALIZED_) {\n            revert ErrInitialized();\n        }\n        if (mtFeeRateModel == address(0) || baseTokenAddress == address(0) || quoteTokenAddress == address(0)) {\n            revert ErrZeroAddress();\n        }\n        if (baseTokenAddress == quoteTokenAddress) {\n            revert ErrBaseQuoteSame();\n        }\n        if (i == 0 || i > MAX_I) {\n            revert ErrInvalidI();\n        }\n        if (k > MAX_K) {\n            revert ErrInvalidK();\n        }\n        if (lpFeeRate < MIN_LP_FEE_RATE || lpFeeRate > MAX_LP_FEE_RATE) {\n            revert ErrInvalidLPFeeRate();\n        }\n\n        _INITIALIZED_ = true;\n        _BASE_TOKEN_ = baseTokenAddress;\n        _QUOTE_TOKEN_ = quoteTokenAddress;\n        _I_ = i;\n        _K_ = k;\n        _LP_FEE_RATE_ = lpFeeRate;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2 ** 32);\n\n        _afterInitialized();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function sync() external nonReentrant {\n        _sync();\n    }\n\n    function correctRState() external {\n        if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) && _BASE_RESERVE_ < _BASE_TARGET_) {\n            _RState_ = uint32(PMMPricing.RState.ONE);\n            _BASE_TARGET_ = _BASE_RESERVE_;\n            _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n        if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) && _QUOTE_RESERVE_ < _QUOTE_TARGET_) {\n            _RState_ = uint32(PMMPricing.RState.ONE);\n            _BASE_TARGET_ = _BASE_RESERVE_;\n            _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(\"MagicLP \", IERC20Metadata(_BASE_TOKEN_).symbol(), \"/\", IERC20Metadata(_QUOTE_TOKEN_).symbol()));\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return \"MagicLP\";\n    }\n\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(_BASE_TOKEN_).decimals();\n    }\n\n    function querySellBase(\n        address trader,\n        uint256 payBaseAmount\n    ) public view returns (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount - DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate) - mtFee;\n        newBaseTarget = state.B0;\n    }\n\n    function querySellQuote(\n        address trader,\n        uint256 payQuoteAmount\n    ) public view returns (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount - DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate) - mtFee;\n        newQuoteTarget = state.Q0;\n    }\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall() external view returns (uint256 i, uint256 K, uint256 B, uint256 Q, uint256 B0, uint256 Q0, uint256 R) {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    function getMidPrice() public view returns (uint256 midPrice) {\n        return PMMPricing.getMidPrice(getPMMState());\n    }\n\n    function getReserves() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {\n        return _MT_FEE_RATE_MODEL_.getFeeRate(user, _LP_FEE_RATE_);\n    }\n\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)) - uint256(_BASE_RESERVE_);\n    }\n\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_QUOTE_RESERVE_);\n    }\n\n    function version() external pure virtual returns (string memory) {\n        return \"MagicLP 1.0.0\";\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// TRADE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function sellBase(address to) external nonReentrant returns (uint256 receiveQuoteAmount) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n\n        _transferQuoteOut(to, receiveQuoteAmount);\n        _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            _BASE_TARGET_ = newBaseTarget.toUint112();\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n\n        emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, to);\n    }\n\n    function sellQuote(address to) external nonReentrant returns (uint256 receiveBaseAmount) {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(tx.origin, quoteInput);\n\n        _transferBaseOut(to, receiveBaseAmount);\n        _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            _QUOTE_TARGET_ = newQuoteTarget.toUint112();\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n\n        emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, to);\n    }\n\n    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data) external nonReentrant {\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0) {\n            ICallee(assetTo).FlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n        }\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        // no input -> pure loss\n        if (baseBalance < _BASE_RESERVE_ && quoteBalance < _QUOTE_RESERVE_) {\n            revert ErrFlashLoanFailed();\n        }\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n            (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) = querySellQuote(\n                tx.origin,\n                quoteInput\n            );\n\n            if (uint256(_BASE_RESERVE_) - baseBalance > receiveBaseAmount) {\n                revert ErrFlashLoanFailed();\n            }\n\n            _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n            if (_RState_ != uint32(newRState)) {\n                _QUOTE_TARGET_ = newQuoteTarget.toUint112();\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, assetTo);\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n            (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) = querySellBase(\n                tx.origin,\n                baseInput\n            );\n\n            if (uint256(_QUOTE_RESERVE_) - quoteBalance > receiveQuoteAmount) {\n                revert ErrFlashLoanFailed();\n            }\n\n            _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n            if (_RState_ != uint32(newRState)) {\n                _BASE_TARGET_ = newBaseTarget.toUint112();\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, assetTo);\n        }\n\n        _sync();\n\n        emit FlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// BUY & SELL SHARES\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    // buy shares [round down]\n    function buyShares(address to) external nonReentrant returns (uint256 shares, uint256 baseInput, uint256 quoteInput) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 baseReserve = _BASE_RESERVE_;\n        uint256 quoteReserve = _QUOTE_RESERVE_;\n\n        baseInput = baseBalance - baseReserve;\n        quoteInput = quoteBalance - quoteReserve;\n\n        if (baseInput == 0) {\n            revert ErrNoBaseInput();\n        }\n\n        // Round down when withdrawing. Therefore, never be a situation occurring balance is 0 but totalsupply is not 0\n        // But May Happenï¼Œreserve >0 But totalSupply = 0\n        if (totalSupply() == 0) {\n            // case 1. initial supply\n            if (quoteBalance == 0) {\n                revert ErrZeroQuoteAmount();\n            }\n\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;\n            _BASE_TARGET_ = shares.toUint112();\n            _QUOTE_TARGET_ = DecimalMath.mulFloor(shares, _I_).toUint112();\n\n            if (_QUOTE_TARGET_ == 0) {\n                revert ErrZeroQuoteTarget();\n            }\n\n            if (shares <= 2001) {\n                revert ErrMintAmountNotEnough();\n            }\n\n            _mint(address(0), 1001);\n            shares -= 1001;\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 2. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            shares = DecimalMath.mulFloor(totalSupply(), mintRatio);\n\n            _BASE_TARGET_ = (uint256(_BASE_TARGET_) + DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)).toUint112();\n            _QUOTE_TARGET_ = (uint256(_QUOTE_TARGET_) + DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)).toUint112();\n        }\n\n        _mint(to, shares);\n        _setReserve(baseBalance, quoteBalance);\n\n        emit BuyShares(to, shares, balanceOf(to));\n    }\n\n    // sell shares [round down]\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external nonReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\n        if (deadline < block.timestamp) {\n            revert ErrExpired();\n        }\n        if (shareAmount > balanceOf(msg.sender)) {\n            revert ErrNotEnough();\n        }\n        if (to == address(this)) {\n            revert ErrSellBackNotAllowed();\n        }\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 totalShares = totalSupply();\n\n        baseAmount = (baseBalance * shareAmount) / totalShares;\n        quoteAmount = (quoteBalance * shareAmount) / totalShares;\n\n        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) - (uint256(_BASE_TARGET_) * shareAmount).divCeil(totalShares));\n        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) - (uint256(_QUOTE_TARGET_) * shareAmount).divCeil(totalShares));\n\n        if (baseAmount < baseMinAmount || quoteAmount < quoteMinAmount) {\n            revert ErrWithdrawNotEnough();\n        }\n\n        _burn(msg.sender, shareAmount);\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n        _sync();\n\n        if (data.length > 0) {\n            ICallee(to).SellShareCall(msg.sender, shareAmount, baseAmount, quoteAmount, data);\n        }\n\n        emit SellShares(msg.sender, to, shareAmount, balanceOf(msg.sender));\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function rescue(address token, address to, uint256 amount) external onlyImplementationOwner {\n        if (token == _BASE_TOKEN_ || token == _QUOTE_TOKEN_) {\n            revert ErrNotAllowed();\n        }\n\n        token.safeTransfer(to, amount);\n        emit TokenRescue(token, to, amount);\n    }\n\n    function setParameters(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public nonReentrant onlyImplementationOwner {\n        if (_BASE_RESERVE_ < minBaseReserve || _QUOTE_RESERVE_ < minQuoteReserve) {\n            revert ErrReserveAmountNotEnough();\n        }\n        if (newI == 0 || newI > MAX_I) {\n            revert ErrInvalidI();\n        }\n        if (newK > MAX_K) {\n            revert ErrInvalidK();\n        }\n        if (newLpFeeRate < MIN_LP_FEE_RATE || newLpFeeRate > MAX_LP_FEE_RATE) {\n            revert ErrInvalidLPFeeRate();\n        }\n\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n\n        _transferBaseOut(assetTo, baseOutAmount);\n        _transferQuoteOut(assetTo, quoteOutAmount);\n        (uint256 newBaseBalance, uint256 newQuoteBalance) = _resetTargetAndReserve();\n\n        emit ParametersChanged(newLpFeeRate, newI, newK, newBaseBalance, newQuoteBalance);\n    }\n\n    function ratioSync() external nonReentrant onlyImplementationOwner {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {\n            revert ErrOverflow();\n        }\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_TARGET_ = uint112((uint256(_BASE_TARGET_) * baseBalance) / uint256(_BASE_RESERVE_));\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_TARGET_ = uint112((uint256(_QUOTE_TARGET_) * quoteBalance) / uint256(_QUOTE_RESERVE_));\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        _twapUpdate();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _resetTargetAndReserve() internal returns (uint256 baseBalance, uint256 quoteBalance) {\n        baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {\n            revert ErrOverflow();\n        }\n\n        _BASE_RESERVE_ = uint112(baseBalance);\n        _QUOTE_RESERVE_ = uint112(quoteBalance);\n        _BASE_TARGET_ = uint112(baseBalance);\n        _QUOTE_TARGET_ = uint112(quoteBalance);\n        _RState_ = uint32(PMMPricing.RState.ONE);\n\n        _twapUpdate();\n    }\n\n    function _twapUpdate() internal {\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n            /// @dev It is desired and expected for this value to\n            /// overflow once it has hit the max of `type.uint256`.\n            unchecked {\n                _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n            }\n        }\n\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n    }\n\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        _BASE_RESERVE_ = baseReserve.toUint112();\n        _QUOTE_RESERVE_ = quoteReserve.toUint112();\n\n        _twapUpdate();\n    }\n\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = baseBalance.toUint112();\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = quoteBalance.toUint112();\n        }\n\n        _twapUpdate();\n    }\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _mint(address to, uint256 amount) internal override {\n        if (amount <= 1000) {\n            revert ErrMintAmountNotEnough();\n        }\n\n        super._mint(to, amount);\n    }\n\n    function _afterInitialized() internal virtual {}\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// MODIFIERS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    modifier onlyImplementationOwner() {\n        if (msg.sender != implementation.owner()) {\n            revert ErrNotImplementationOwner();\n        }\n        _;\n    }\n\n    modifier onlyClones() {\n        if (address(this) == address(implementation)) {\n            revert ErrNotClone();\n        }\n        _;\n    }\n\n    modifier onlyImplementation() {\n        if (address(this) != address(implementation)) {\n            revert ErrNotImplementation();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/mimswap/MagicLP.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solady/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solady/tokens/ERC20.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {Math} from \"/mimswap/libraries/Math.sol\";\nimport {PMMPricing} from \"/mimswap/libraries/PMMPricing.sol\";\nimport {ICallee} from \"/mimswap/interfaces/ICallee.sol\";\nimport {IFeeRateModel} from \"/mimswap/interfaces/IFeeRateModel.sol\";\nimport {IWETH} from \"interfaces/IWETH.sol\";\n\n/// @title MIMSwap MagicLP\n/// @author Adapted from DODOEX DSP https://github.com/DODOEX/contractV2/tree/main/contracts/DODOStablePool\ncontract MagicLP is ERC20, ReentrancyGuard, Owned {\n    using Math for uint256;\n    using SafeCastLib for uint256;\n    using SafeTransferLib for address;\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n    event Swap(address fromToken, address toToken, uint256 fromAmount, uint256 toAmount, address trader, address receiver);\n    event FlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\n    event RChange(PMMPricing.RState newRState);\n    event TokenRescue(address indexed token, address to, uint256 amount);\n    event ParametersChanged(uint256 newLpFeeRate, uint256 newI, uint256 newK, uint256 newBaseReserve, uint256 newQuoteReserve);\n\n    error ErrInitialized();\n    error ErrBaseQuoteSame();\n    error ErrInvalidI();\n    error ErrInvalidK();\n    error ErrExpired();\n    error ErrInvalidSignature();\n    error ErrFlashLoanFailed();\n    error ErrNoBaseInput();\n    error ErrZeroAddress();\n    error ErrZeroQuoteAmount();\n    error ErrZeroQuoteTarget();\n    error ErrMintAmountNotEnough();\n    error ErrNotEnough();\n    error ErrWithdrawNotEnough();\n    error ErrSellBackNotAllowed();\n    error ErrInvalidLPFeeRate();\n    error ErrNotImplementationOwner();\n    error ErrNotImplementation();\n    error ErrNotClone();\n    error ErrNotAllowed();\n    error ErrReserveAmountNotEnough();\n    error ErrOverflow();\n\n    MagicLP public immutable implementation;\n\n    uint256 public constant MAX_I = 10 ** 36;\n    uint256 public constant MAX_K = 10 ** 18;\n    uint256 public constant MIN_LP_FEE_RATE = 1e14; // 0.01%\n    uint256 public constant MAX_LP_FEE_RATE = 1e16; // 1%\n\n    bool internal _INITIALIZED_;\n\n    address public _BASE_TOKEN_;\n    address public _QUOTE_TOKEN_;\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    uint32 public _RState_;\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    uint256 public _LP_FEE_RATE_;\n    uint256 public _K_;\n    uint256 public _I_;\n\n    constructor(address owner_) Owned(owner_) {\n        implementation = this;\n\n        // prevents the implementation contract initialization\n        _INITIALIZED_ = true;\n    }\n\n    function init(\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k\n    ) external {\n        if (_INITIALIZED_) {\n            revert ErrInitialized();\n        }\n        if (mtFeeRateModel == address(0) || baseTokenAddress == address(0) || quoteTokenAddress == address(0)) {\n            revert ErrZeroAddress();\n        }\n        if (baseTokenAddress == quoteTokenAddress) {\n            revert ErrBaseQuoteSame();\n        }\n        if (i == 0 || i > MAX_I) {\n            revert ErrInvalidI();\n        }\n        if (k > MAX_K) {\n            revert ErrInvalidK();\n        }\n        if (lpFeeRate < MIN_LP_FEE_RATE || lpFeeRate > MAX_LP_FEE_RATE) {\n            revert ErrInvalidLPFeeRate();\n        }\n\n        _INITIALIZED_ = true;\n        _BASE_TOKEN_ = baseTokenAddress;\n        _QUOTE_TOKEN_ = quoteTokenAddress;\n        _I_ = i;\n        _K_ = k;\n        _LP_FEE_RATE_ = lpFeeRate;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2 ** 32);\n\n        _afterInitialized();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function sync() external nonReentrant {\n        _sync();\n    }\n\n    function correctRState() external {\n        if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) && _BASE_RESERVE_ < _BASE_TARGET_) {\n            _RState_ = uint32(PMMPricing.RState.ONE);\n            _BASE_TARGET_ = _BASE_RESERVE_;\n            _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n        if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) && _QUOTE_RESERVE_ < _QUOTE_TARGET_) {\n            _RState_ = uint32(PMMPricing.RState.ONE);\n            _BASE_TARGET_ = _BASE_RESERVE_;\n            _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(\"MagicLP \", IERC20Metadata(_BASE_TOKEN_).symbol(), \"/\", IERC20Metadata(_QUOTE_TOKEN_).symbol()));\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return \"MagicLP\";\n    }\n\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(_BASE_TOKEN_).decimals();\n    }\n\n    function querySellBase(\n        address trader,\n        uint256 payBaseAmount\n    ) public view returns (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount - DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate) - mtFee;\n        newBaseTarget = state.B0;\n    }\n\n    function querySellQuote(\n        address trader,\n        uint256 payQuoteAmount\n    ) public view returns (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount - DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate) - mtFee;\n        newQuoteTarget = state.Q0;\n    }\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall() external view returns (uint256 i, uint256 K, uint256 B, uint256 Q, uint256 B0, uint256 Q0, uint256 R) {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    function getMidPrice() public view returns (uint256 midPrice) {\n        return PMMPricing.getMidPrice(getPMMState());\n    }\n\n    function getReserves() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {\n        return _MT_FEE_RATE_MODEL_.getFeeRate(user, _LP_FEE_RATE_);\n    }\n\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)) - uint256(_BASE_RESERVE_);\n    }\n\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_QUOTE_RESERVE_);\n    }\n\n    function version() external pure virtual returns (string memory) {\n        return \"MagicLP 1.0.0\";\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// TRADE FUNCTIONS\n    /////////////////////////////////////////"
    }
  ]
}