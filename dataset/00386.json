{
  "Title": "H-1: Claim functions don't validate if the epoch is settled",
  "Content": "# Issue H-1: Claim functions don't validate if the epoch is settled \n\nSource: https://github.com/sherlock-audit/2024-03-amphor-judging/issues/72 \n\n## Found by \nCryptoSan, aslanbek, cawfree, eeshenggoh, fugazzi, jennifer37, kennedy1030, mahdikarimi, pynschon, sammy, turvec, whitehair0330, zzykxx\n## Summary\n\nBoth claim functions fail to validate if the epoch for the request has been already settled, leading to loss of funds when claiming requests for the current epoch. The issue is worsened as `claimAndRequestDeposit()` can be used to claim a deposit on behalf of any account, allowing an attacker to wipe other's requests.\n\n## Vulnerability Detail\n\nWhen the vault is closed, users can request a deposit, transfer assets and later claim shares, or request a redemption, transfer shares and later redeem assets. Both of these processes store the assets or shares, and later convert these when the epoch is settled. For deposits, the core of the implementation is given by `_claimDeposit()`:\n\n```solidity\nfunction _claimDeposit(\n    address owner,\n    address receiver\n)\n    internal\n    returns (uint256 shares)\n{\n    shares = previewClaimDeposit(owner);\n\n    uint256 lastRequestId = lastDepositRequestId[owner];\n    uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n    epochs[lastRequestId].depositRequestBalance[owner] = 0;\n    _update(address(claimableSilo), receiver, shares);\n    emit ClaimDeposit(lastRequestId, owner, receiver, assets, shares);\n}\n\nfunction previewClaimDeposit(address owner) public view returns (uint256) {\n    uint256 lastRequestId = lastDepositRequestId[owner];\n    uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n    return _convertToShares(assets, lastRequestId, Math.Rounding.Floor);\n}\n\nfunction _convertToShares(\n    uint256 assets,\n    uint256 requestId,\n    Math.Rounding rounding\n)\n    internal\n    view\n    returns (uint256)\n{\n    if (isCurrentEpoch(requestId)) {\n        return 0;\n    }\n    uint256 totalAssets =\n        epochs[requestId].totalAssetsSnapshotForDeposit + 1;\n    uint256 totalSupply =\n        epochs[requestId].totalSupplySnapshotForDeposit + 1;\n\n    return assets.mulDiv(totalSupply, totalAssets, rounding);\n}\n```\n\nAnd for redemptions in `_claimRedeem()`:\n\n```solidity\nfunction _claimRedeem(\n    address owner,\n    address receiver\n)\n    internal\n    whenNotPaused\n    returns (uint256 assets)\n{\n    assets = previewClaimRedeem(owner);\n    uint256 lastRequestId = lastRedeemRequestId[owner];\n    uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n    epochs[lastRequestId].redeemRequestBalance[owner] = 0;\n    _asset.safeTransferFrom(address(claimableSilo), address(this), assets);\n    _asset.transfer(receiver, assets);\n    emit ClaimRedeem(lastRequestId, owner, receiver, assets, shares);\n}\n\nfunction previewClaimRedeem(address owner) public view returns (uint256) {\n    uint256 lastRequestId = lastRedeemRequestId[owner];\n    uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n    return _convertToAssets(shares, lastRequestId, Math.Rounding.Floor);\n}\n\nfunction _convertToAssets(\n    uint256 shares,\n    uint256 requestId,\n    Math.Rounding rounding\n)\n    internal\n    view\n    returns (uint256)\n{\n    if (isCurrentEpoch(requestId)) {\n        return 0;\n    }\n    uint256 totalAssets = epochs[requestId].totalAssetsSnapshotForRedeem + 1;\n    uint256 totalSupply = epochs[requestId].totalSupplySnapshotForRedeem + 1;\n\n    return shares.mulDiv(totalAssets, totalSupply, rounding);\n}\n```\n\nNote that in both cases the \"preview\" functions are used to convert and calculate the amounts owed to the user: `_convertToShares()` and `_convertToAssets()` use the settled values stored in `epochs[requestId]` to convert between assets and shares.\n\nHowever, there is no validation to check if the claiming is done for the current unsettled epoch. If a user claims a deposit or redemption during the same epoch it has been requested, the values stored in `epochs[epochId]` will be uninitialized, which means that `_convertToShares()` and `_convertToAssets()` will use zero values leading to zero results too. The claiming process will succeed, but since the converted amounts are zero, the users will always get zero assets or shares.\n\nThis is even worsened by the fact that `claimAndRequestDeposit()` can be used to claim a deposit on behalf of any account. An attacker can wipe any requested deposit from an arbitrary `account` by simply calling `claimAndRequestDeposit(0, account, \"\")`. This will internally execute `_claimDeposit(account, account)`, which will trigger the described issue.\n\n## Proof of concept\n\nThe following proof of concept demonstrates the scenario in which a user claims their own deposit during the current epoch:\n\n```solidity\nfunction test_ClaimSameEpochLossOfFunds_Scenario_A() public {\n    asset.mint(alice, 1_000e18);\n\n    vm.prank(alice);\n    vault.deposit(500e18, alice);\n\n    // vault is closed\n    vm.prank(owner);\n    vault.close();\n\n    // alice requests a deposit\n    vm.prank(alice);\n    vault.requestDeposit(500e18, alice, alice, \"\");\n\n    // the request is successfully created\n    assertEq(vault.pendingDepositRequest(alice), 500e18);\n\n    // now alice claims the deposit while vault is still open\n    vm.prank(alice);\n    vault.claimDeposit(alice);\n\n    // request is gone\n    assertEq(vault.pendingDepositRequest(alice), 0);\n}\n```\n\nThis other proof of concept illustrates the scenario in which an attacker calls `claimAndRequestDeposit()` to wipe the deposit of another account.\n\n```solidity\nfunction test_ClaimSameEpochLossOfFunds_Scenario_B() public {\n    asset.mint(alice, 1_000e18);\n\n    vm.prank(alice);\n    vault.deposit(500e18, alice);\n\n    // vault is closed\n    vm.prank(owner);\n    vault.close();\n\n    // alice requests a deposit\n    vm.prank(alice);\n    vault.requestDeposit(500e18, alice, alice, \"\");\n\n    // the request is successfully created\n    assertEq(vault.pendingDepositRequest(alice), 500e18);\n\n    // bob can issue a claim for alice through claimAndRequestDeposit()\n    vm.prank(bob);\n    vault.claimAndRequestDeposit(0, alice, \"\");\n\n    // request is gone\n    assertEq(vault.pendingDepositRequest(alice), 0);\n}\n```\n\n## Impact\n\nCRITICAL. Requests can be wiped by executing the claim in an unsettled epoch, leading to loss of funds. The issue can also be triggered for any arbitrary account by using `claimAndRequestDeposit()`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L742-L756\n\nhttps://github.com/sherlock-audit/2024-03-amphor/blob/main/asynchronous-vault/src/AsyncSynthVault.sol#L758-L773\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck that the epoch associated with the request is not the current epoch.\n\n```diff\n    function _claimDeposit(\n        address owner,\n        address receiver\n    )\n        internal\n        returns (uint256 shares)\n    {\n+       uint256 lastRequestId = lastDepositRequestId[owner];\n+       if (isCurrentEpoch(lastRequestId)) revert();\n      \n        shares = previewClaimDeposit(owner);\n\n-       uint256 lastRequestId = lastDepositRequestId[owner];\n        uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n        epochs[lastRequestId].depositRequestBalance[owner] = 0;\n        _update(address(claimableSilo), receiver, shares);\n        emit ClaimDeposit(lastRequestId, owner, receiver, assets, shares);\n    }\n```\n\n```diff\n    function _claimRedeem(\n        address owner,\n        address receiver\n    )\n        internal\n        whenNotPaused\n        returns (uint256 assets)\n    {\n+       uint256 lastRequestId = lastRedeemRequestId[owner];\n+       if (isCurrentEpoch(lastRequestId)) revert();\n        \n        assets = previewClaimRedeem(owner);\n-       uint256 lastRequestId = lastRedeemRequestId[owner];\n        uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n        epochs[lastRequestId].redeemRequestBalance[owner] = 0;\n        _asset.safeTransferFrom(address(claimableSilo), address(this), assets);\n        _asset.transfer(receiver, assets);\n        emit ClaimRedeem(lastRequestId, owner, receiver, assets, shares);\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid; high(1)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/AmphorProtocol/asynchronous-vault/pull/103.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/244",
  "Code": [
    {
      "filename": "asynchronous-vault/src/AsyncSynthVault.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {\n    IERC7540,\n    IERC165,\n    IERC7540Redeem,\n    IERC7540Deposit\n} from \"./interfaces/IERC7540.sol\";\nimport { ERC7540Receiver } from \"./interfaces/ERC7540Receiver.sol\";\nimport { IERC20, SafeERC20, Math, PermitParams } from \"./SyncSynthVault.sol\";\n\nimport { SyncSynthVault } from \"./SyncSynthVault.sol\";\n\n/**\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%=::::::=%@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*=#=--=*=*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:*=    =#:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*-.    .-*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*        *@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@.         .@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*  Amphor  *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*==========#@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@+==========*@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@*   ASync   *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@%  Vault  %@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@=        +@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%       %@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@=      =@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@%     .@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@=    =@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@%----%@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%+:::::+%@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@########@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *\n *            d8888                        888\n *           d88888                        888\n *          d88P888                        888\n *         d88P 888 88888b.d88b.  88888b.  88888b.   .d88b.  888d888\n *        d88P  888 888 \"888 \"88b 888 \"88b 888 \"88b d88\"\"88b 888P\"\n *       d88P   888 888  888  888 888  888 888  888 888  888 888\n *      d8888888888 888  888  888 888 d88P 888  888 Y88..88P 888\n *     d88P     888 888  888  888 88888P\"  888  888  \"Y88P\"  888.io\n *                                888\n *                                888\n *                                888\n */\n\n/*\n * ########\n * # LIBS #\n * ########\n*/\nusing Math for uint256; // only used for `mulDiv` operations.\nusing SafeERC20 for IERC20; // `safeTransfer` and `safeTransferFrom`\n\n/*\n    This structure contains all the informations needed to let user claim their\n    request after we processed those. To avoid rounding errors we store the\ntotalSupply and totalAssets at the time of the deposit/redeem for the deposit\nand\n    the redeem. We also store the amount of assets and shares given by the user.*/\nstruct EpochData {\n    uint256 totalSupplySnapshotForRedeem;\n    uint256 totalAssetsSnapshotForRedeem;\n    uint256 totalSupplySnapshotForDeposit;\n    uint256 totalAssetsSnapshotForDeposit;\n    mapping(address => uint256) depositRequestBalance;\n    mapping(address => uint256) redeemRequestBalance;\n}\n\nstruct SettleValues {\n    uint256 lastSavedBalance;\n    uint256 fees;\n    uint256 pendingRedeem;\n    uint256 sharesToMint;\n    uint256 pendingDeposit;\n    uint256 assetsToWithdraw;\n    uint256 totalAssetsSnapshotForDeposit;\n    uint256 totalSupplySnapshotForDeposit;\n    uint256 totalAssetsSnapshotForRedeem;\n    uint256 totalSupplySnapshotForRedeem;\n}\n\nuint256 constant BPS_DIVIDER = 10_000;\nuint16 constant MAX_FEES = 3000; // 30%\n\ncontract Silo {\n    constructor(IERC20 underlying) {\n        underlying.forceApprove(msg.sender, type(uint256).max);\n    }\n}\n\ncontract AsyncSynthVault is IERC7540, SyncSynthVault {\n    /*\n     * ####################################\n     * # AMPHOR SYNTHETIC RELATED STORAGE #\n     * ####################################\n    */\n\n    // @return Amount of the perf fees applied on the positive yield.\n    uint256 public epochId;\n    Silo public pendingSilo; // to manage the pending deposits and redeems we\n        // store them in a contract whose function is to hold the assets/shares.\n    Silo public claimableSilo; // to manage the claimable deposits and redeems\n        // we\n        // store them in a contract whose function is to hold the assets/shares.\n    mapping(uint256 epochId => EpochData epoch) public epochs;\n    mapping(address user => uint256 epochId) public lastDepositRequestId;\n    mapping(address user => uint256 epochId) public lastRedeemRequestId;\n\n    /*\n     * ##########\n     * # EVENTS #\n     * ##########\n    */\n\n    event DecreaseDepositRequest(\n        uint256 indexed requestId,\n        address indexed owner,\n        uint256 indexed previousRequestedAssets,\n        uint256 newRequestedAssets\n    );\n\n    event DecreaseRedeemRequest(\n        uint256 indexed requestId,\n        address indexed owner,\n        uint256 indexed previousRequestedShares,\n        uint256 newRequestedShares\n    );\n\n    event ClaimDeposit(\n        uint256 indexed requestId,\n        address indexed owner,\n        address indexed receiver,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event ClaimRedeem(\n        uint256 indexed requestId,\n        address indexed owner,\n        address indexed receiver,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*\n     * ##########\n     * # ERRORS #\n     * ##########\n     */\n    error ExceededMaxRedeemRequest(\n        address receiver, uint256 shares, uint256 maxShares\n    );\n    error ExceededMaxDepositRequest(\n        address receiver, uint256 assets, uint256 maxDeposit\n    );\n    error MustClaimFirst(address owner);\n\n    error ReceiverFailed();\n    error NotOwner();\n    error NullRequest();\n    error ERC7540CantRequestDepositOnBehalfOf();\n    /*\n     * ##############################\n     * # AMPHOR SYNTHETIC FUNCTIONS #\n     * ##############################\n     */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() SyncSynthVault() {\n        //_disableInitializers();\n    }\n\n    function initialize(\n        uint16 fees,\n        address owner,\n        IERC20 underlying,\n        string memory name,\n        string memory symbol\n    )\n        public\n        virtual\n        override\n        initializer\n    {\n        super.initialize(fees, owner, underlying, name, symbol);\n        epochId = 1;\n        pendingSilo = new Silo(underlying);\n        claimableSilo = new Silo(underlying);\n    }\n\n    /*\n    Since we only allow one claimable request at a time, users must claim\n        their request before making a new one. This function let users claim\n        and request a deposit in one transaction.\n    */\n    function claimAndRequestDeposit(\n        uint256 assets,\n        address receiver,\n        bytes memory data\n    )\n        external\n    {\n        _claimDeposit(receiver, receiver);\n        requestDeposit(assets, receiver, _msgSender(), data);\n    }\n\n    /*\n        Same logic as `claimAndRequestDeposit` but for redeem requests.\n    */\n    function claimAndRequestRedeem(\n        uint256 shares,\n        bytes memory data\n    )\n        external\n    {\n        address owner = _msgSender();\n        _claimRedeem(owner, owner);\n        requestRedeem(shares, owner, owner, data);\n    }\n\n    /*\n    This function is used to decrease the amount of assets requested to deposit\n    by the\n        user. It can only be called by the user who made the request.\n    */\n    function decreaseDepositRequest(uint256 assets)\n        external\n        whenClosed\n        whenNotPaused\n    {\n        address owner = _msgSender();\n        uint256 oldBalance = epochs[epochId].depositRequestBalance[owner];\n        epochs[epochId].depositRequestBalance[owner] -= assets;\n        _asset.safeTransferFrom(address(pendingSilo), owner, assets);\n\n        emit DecreaseDepositRequest(\n            epochId,\n            owner,\n            oldBalance,\n            epochs[epochId].depositRequestBalance[owner]\n        );\n    }\n\n    /*\n    This function is used to decrease the amount of shares requested to redeem\n    by the\n        user. It can only be called by the user who made the request.\n    */\n    function decreaseRedeemRequest(uint256 shares)\n        external\n        whenClosed\n        whenNotPaused\n    {\n        address owner = _msgSender();\n        uint256 oldBalance = epochs[epochId].redeemRequestBalance[owner];\n        epochs[epochId].redeemRequestBalance[owner] -= shares;\n        _update(address(pendingSilo), owner, shares);\n\n        emit DecreaseRedeemRequest(\n            epochId,\n            owner,\n            oldBalance,\n            epochs[epochId].redeemRequestBalance[owner]\n        );\n    }\n\n    /*\n     * ######################################\n     * # AMPHOR SYNTHETIC RELATED FUNCTIONS #\n     * ######################################\n    */\n\n    /**\n     * @dev The `close` function is used to close the vault.\n     * It can only be called by the owner of the contract (`onlyOwner`\n     * modifier).\n     */\n    function close() external override onlyOwner {\n        if (!vaultIsOpen) revert VaultIsClosed();\n\n        if (totalAssets() == 0) revert VaultIsEmpty();\n\n        lastSavedBalance = totalAssets();\n        vaultIsOpen = false;\n        _asset.safeTransfer(owner(), lastSavedBalance);\n        emit EpochStart(block.timestamp, lastSavedBalance, totalSupply());\n    }\n\n    /**\n     * @dev The `open` function is used to open the vault.\n     * @notice The `open` function is used to end the lock period of the vault.\n     * It can only be called by the owner of the contract (`onlyOwner` modifier)\n     * and only when the vault is locked.\n     * If there are profits, the performance fees are taken and sent to the\n     * owner of the contract.\n     * @param assetReturned The underlying assets amount to be deposited into\n     * the vault.\n     */\n    function open(uint256 assetReturned)\n        external\n        override\n        onlyOwner\n        whenNotPaused\n        whenClosed\n    {\n        (uint256 newBalance,) = _settle(assetReturned);\n        vaultIsOpen = true;\n        _asset.safeTransferFrom(owner(), address(this), newBalance);\n    }\n\n    /*\n     * #################################\n     * #   Permit RELATED FUNCTIONS    #\n     * #################################\n    */\n\n    /* This function is used to claim the pending deposit and request a new one\n    in one transaction using permit signatures */\n    function claimAndRequestDepositWithPermit(\n        uint256 assets,\n        bytes memory data,\n        PermitParams calldata permitParams\n    )\n        external\n    {\n        address msgSender = _msgSender();\n        _claimDeposit(msgSender, msgSender);\n        requestDepositWithPermit(assets, msgSender, data, permitParams);\n    }\n\n    /*\n    Since amphor strategies can be time sensitive, we must be able to switch\n    epoch without needing\n    to put all the funds back. Using _settle we can virtually put back the\n    funds, check how much we owe\n    to users that want to redeem and maybe take the extra funds from the deposit\n    requests.\n    \n    */\n    function settle(uint256 newSavedBalance) external {\n        (uint256 lastSavedBalance, uint256 totalSupply) =\n            _settle(newSavedBalance);\n        lastSavedBalance = 0;\n        emit EpochStart(block.timestamp, lastSavedBalance, totalSupply);\n    }\n\n    /**\n     * @dev How many shares a users currently has waiting to be redeem.\n     *\n     */\n    function pendingRedeemRequest(address owner)\n        external\n        view\n        returns (uint256)\n    {\n        return epochs[epochId].redeemRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many shares are  virtually waiting for the user to be redeemed\n     * via\n     * the `claimRedeem` function.\n     */\n    function claimableRedeemRequest(address owner)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        return isCurrentEpoch(lastRequestId)\n            ? 0\n            : epochs[lastRequestId].redeemRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are currently waiting to be deposited for the user.\n     */\n    function pendingDepositRequest(address owner)\n        external\n        view\n        returns (uint256 assets)\n    {\n        return epochs[epochId].depositRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are virtually waiting for the user to be deposit\n     * via the `claimDeposit` function.\n     */\n    function claimableDepositRequest(address owner)\n        external\n        view\n        returns (uint256 assets)\n    {\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        return isCurrentEpoch(lastRequestId)\n            ? 0\n            : epochs[lastRequestId].depositRequestBalance[owner];\n    }\n\n    /**\n     * @dev How many assets are currently waiting to be deposited for all users.\n     */\n    function totalPendingDeposits() external view returns (uint256) {\n        return vaultIsOpen ? 0 : _asset.balanceOf(address(pendingSilo));\n    }\n\n    /**\n     * @dev How many shares are  waiting to be redeemed for all users.\n     */\n    function totalPendingRedeems() external view returns (uint256) {\n        return vaultIsOpen ? 0 : balanceOf(address(pendingSilo));\n    }\n\n    function totalClaimableShares() external view returns (uint256) {\n        return balanceOf(address(claimableSilo));\n    }\n\n    function totalClaimableAssets() external view returns (uint256) {\n        return _asset.balanceOf(address(claimableSilo));\n    }\n\n    /**\n     * @dev when the vault is closed, users can only request to deposit.\n     * By doing this funds will be sent and wait in the pendingSilo.\n     * When the owner will call the `open` or `settle` function, the funds will\n     * be\n     * deposited and the minted shares will be sent to the claimableSilo. Waiting\n     * for the users to claim them.\n     */\n    function requestDeposit(\n        uint256 assets,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        public\n        whenNotPaused\n        whenClosed\n    {\n        // vault\n        if (_msgSender() != owner) {\n            revert ERC7540CantRequestDepositOnBehalfOf();\n        }\n        if (previewClaimDeposit(receiver) > 0) {\n            revert MustClaimFirst(receiver);\n        }\n\n        if (assets > maxDepositRequest(owner)) {\n            revert ExceededMaxDepositRequest(\n                receiver, assets, maxDepositRequest(owner)\n            );\n        }\n\n        _asset.safeTransferFrom(owner, address(pendingSilo), assets);\n\n        _createDepositRequest(assets, receiver, owner, data);\n    }\n\n    /**\n     * @dev when the vault is closed, users can only request to redeem.\n     * By doing this shares will be sent and wait in the pendingSilo.\n     * When the owner will call the `open` or `settle` function, the shares will\n     * be\n     * redeemed and the assets will be sent to the claimableSilo. Waiting for\n     * the\n     * users to claim them.\n     */\n    function requestRedeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        public\n        whenNotPaused\n        whenClosed\n    {\n        if (_msgSender() != owner) {\n            _spendAllowance(owner, _msgSender(), shares);\n        }\n        if (previewClaimRedeem(receiver) > 0) {\n            revert MustClaimFirst(receiver);\n        }\n        if (shares > maxRedeemRequest(owner)) {\n            revert ExceededMaxRedeemRequest(\n                receiver, shares, maxRedeemRequest(owner)\n            );\n        }\n\n        _update(owner, address(pendingSilo), shares);\n        // Create a new request\n        _createRedeemRequest(shares, receiver, owner, data);\n    }\n\n    /**\n     * @dev This function let users claim the shares we owe them after we\n     * processed their deposit request, in the _settle function.\n     */\n    function claimDeposit(address receiver)\n        public\n        whenNotPaused\n        returns (uint256 shares)\n    {\n        return _claimDeposit(_msgSender(), receiver);\n    }\n\n    /**\n     *\n     * @dev This function let users claim the assets we owe them after we\n     * processed their redeem request, in the _settle function.\n     */\n    function claimRedeem(address receiver)\n        public\n        whenNotPaused\n        returns (uint256 assets)\n    {\n        return _claimRedeem(_msgSender(), receiver);\n    }\n\n    /**\n     * @dev This funciton let user request a deposit using permit signatures.\n     */\n    function requestDepositWithPermit(\n        uint256 assets,\n        address receiver,\n        bytes memory data,\n        PermitParams calldata permitParams\n    )\n        public\n    {\n        address msgSender = _msgSender();\n        if (_asset.allowance(msgSender, address(this)) < assets) {\n            execPermit(msgSender, address(this), permitParams);\n        }\n        return requestDeposit(assets, receiver, msgSender, data);\n    }\n\n    /**\n     * @dev users can request deposit only when the vault is closed and not\n     * paused.\n     */\n    function maxDepositRequest(address) public view returns (uint256) {\n        return vaultIsOpen || paused() ? 0 : type(uint256).max;\n    }\n\n    /**\n     * @dev users can request redeem only when the vault is closed and not\n     * paused.\n     */\n    function maxRedeemRequest(address owner) public view returns (uint256) {\n        return vaultIsOpen || paused() ? 0 : balanceOf(owner);\n    }\n\n    /**\n     * @dev This function let users preview how many shares they will get if\n     * they claim their deposit request.\n     */\n    function previewClaimDeposit(address owner) public view returns (uint256) {\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n        return _convertToShares(assets, lastRequestId, Math.Rounding.Floor);\n    }\n\n    /**\n     * @dev This function let users preview how many assets they will get if\n     * they claim their redeem request.\n     */\n    function previewClaimRedeem(address owner) public view returns (uint256) {\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n        return _convertToAssets(shares, lastRequestId, Math.Rounding.Floor);\n    }\n\n    /**\n     */\n    function convertToShares(\n        uint256 assets,\n        uint256 _epochId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _convertToShares(assets, _epochId, Math.Rounding.Floor);\n    }\n\n    function convertToAssets(\n        uint256 shares,\n        uint256 _epochId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _convertToAssets(shares, _epochId, Math.Rounding.Floor);\n    }\n\n    /**\n     *\n     * Utils function to convert the shares claimable into assets. It can\n     * be used in the front end to save an rpc call.\n     */\n    function claimableDepositBalanceInAsset(address owner)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 shares = previewClaimDeposit(owner);\n        return convertToAssets(shares);\n    }\n\n    /**\n     * Using this the owner can know if he will have to send money to the\n     * claimableSilo (for users who want to leave the vault) or if he will\n     * receive money from it.\n     */\n    function previewSettle(uint256 newSavedBalance)\n        public\n        view\n        returns (\n            uint256 assetsToOwner,\n            uint256 assetsToVault,\n            SettleValues memory settleValues\n        )\n    {\n        uint256 _lastSavedBalance = lastSavedBalance;\n        _checkMaxDrawdown(_lastSavedBalance, newSavedBalance);\n\n        // calculate the fees between lastSavedBalance and newSavedBalance\n        uint256 fees = _computeFees(_lastSavedBalance, newSavedBalance);\n        uint256 totalSupply = totalSupply();\n\n        // taking fees if positive yield\n        _lastSavedBalance = newSavedBalance - fees;\n\n        address pendingSiloAddr = address(pendingSilo);\n        uint256 pendingRedeem = balanceOf(pendingSiloAddr);\n        uint256 pendingDeposit = _asset.balanceOf(pendingSiloAddr);\n\n        uint256 sharesToMint = pendingDeposit.mulDiv(\n            totalSupply + 1, _lastSavedBalance + 1, Math.Rounding.Floor\n        );\n\n        uint256 totalAssetsSnapshotForDeposit = _lastSavedBalance + 1;\n        uint256 totalSupplySnapshotForDeposit = totalSupply + 1;\n\n        uint256 assetsToWithdraw = pendingRedeem.mulDiv(\n            _lastSavedBalance + pendingDeposit + 1,\n            totalSupply + sharesToMint + 1,\n            Math.Rounding.Floor\n        );\n\n        uint256 totalAssetsSnapshotForRedeem =\n            _lastSavedBalance + pendingDeposit + 1;\n        uint256 totalSupplySnapshotForRedeem = totalSupply + sharesToMint + 1;\n\n        settleValues = SettleValues({\n            lastSavedBalance: _lastSavedBalance + fees,\n            fees: fees,\n            pendingRedeem: pendingRedeem,\n            sharesToMint: sharesToMint,\n            pendingDeposit: pendingDeposit,\n            assetsToWithdraw: assetsToWithdraw,\n            totalAssetsSnapshotForDeposit: totalAssetsSnapshotForDeposit,\n            totalSupplySnapshotForDeposit: totalSupplySnapshotForDeposit,\n            totalAssetsSnapshotForRedeem: totalAssetsSnapshotForRedeem,\n            totalSupplySnapshotForRedeem: totalSupplySnapshotForRedeem\n        });\n\n        if (pendingDeposit > assetsToWithdraw) {\n            assetsToOwner = pendingDeposit - assetsToWithdraw;\n        } else if (pendingDeposit < assetsToWithdraw) {\n            assetsToVault = assetsToWithdraw - pendingDeposit;\n        }\n    }\n\n    /**\n     * @dev see EIP\n     * @param interfaceId The interface id to check for.\n     * @return True if the contract implements the interface.\n     */\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return interfaceId == type(IERC165).interfaceId\n            || interfaceId == type(IERC7540Redeem).interfaceId\n            || interfaceId == type(IERC7540Deposit).interfaceId;\n    }\n\n    // transfer must happen before this function is called\n    function _createDepositRequest(\n        uint256 assets,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        internal\n    {\n        epochs[epochId].depositRequestBalance[receiver] += assets;\n        if (lastDepositRequestId[receiver] != epochId) {\n            lastDepositRequestId[receiver] = epochId;\n        }\n\n        if (\n            data.length > 0\n                && ERC7540Receiver(receiver).onERC7540DepositReceived(\n                    _msgSender(), owner, epochId, data\n                ) != ERC7540Receiver.onERC7540DepositReceived.selector\n        ) revert ReceiverFailed();\n\n        emit DepositRequest(receiver, owner, epochId, _msgSender(), assets);\n    }\n\n    function _createRedeemRequest(\n        uint256 shares,\n        address receiver,\n        address owner,\n        bytes memory data\n    )\n        internal\n    {\n        epochs[epochId].redeemRequestBalance[receiver] += shares;\n        lastRedeemRequestId[owner] = epochId;\n\n        if (\n            data.length > 0\n                && ERC7540Receiver(receiver).onERC7540RedeemReceived(\n                    _msgSender(), owner, epochId, data\n                ) != ERC7540Receiver.onERC7540RedeemReceived.selector\n        ) revert ReceiverFailed();\n\n        emit RedeemRequest(receiver, owner, epochId, _msgSender(), shares);\n    }\n\n    function _claimDeposit(\n        address owner,\n        address receiver\n    )\n        internal\n        returns (uint256 shares)\n    {\n        shares = previewClaimDeposit(owner);\n\n        uint256 lastRequestId = lastDepositRequestId[owner];\n        uint256 assets = epochs[lastRequestId].depositRequestBalance[owner];\n        epochs[lastRequestId].depositRequestBalance[owner] = 0;\n        _update(address(claimableSilo), receiver, shares);\n        emit ClaimDeposit(lastRequestId, owner, receiver, assets, shares);\n    }\n\n    function _claimRedeem(\n        address owner,\n        address receiver\n    )\n        internal\n        whenNotPaused\n        returns (uint256 assets)\n    {\n        assets = previewClaimRedeem(owner);\n        uint256 lastRequestId = lastRedeemRequestId[owner];\n        uint256 shares = epochs[lastRequestId].redeemRequestBalance[owner];\n        epochs[lastRequestId].redeemRequestBalance[owner] = 0;\n        _asset.safeTransferFrom(address(claimableSilo), address(this), assets);\n        _asset.transfer(receiver, assets);\n        emit ClaimRedeem(lastRequestId, owner, receiver, assets, shares);\n    }\n\n    function _settle(uint256 newSavedBalance)\n        internal\n        onlyOwner\n        whenNotPaused\n        whenClosed\n        returns (uint256, uint256)\n    {\n        (\n            uint256 assetsToOwner,\n            uint256 assetsToVault,\n            SettleValues memory settleValues\n        ) = previewSettle(newSavedBalance);\n\n        emit EpochEnd(\n            block.timestamp,\n            lastSavedBalance,\n            newSavedBalance,\n            settleValues.fees,\n            totalSupply()\n        );\n\n        // Settle the shares balance\n        _burn(address(pendingSilo), settleValues.pendingRedeem);\n        _mint(address(claimableSilo), settleValues.sharesToMint);\n\n        ///////////////////////////\n        // Settle assets balance //\n        ///////////////////////////\n        // either there are more deposits than withdrawals\n        if (settleValues.pendingDeposit > settleValues.assetsToWithdraw) {\n            _asset.safeTransferFrom(\n                address(pendingSilo), owner(), assetsToOwner\n            );\n            if (settleValues.assetsToWithdraw > 0) {\n                _asset.safeTransferFrom(\n                    address(pendingSilo),\n                    address(claimableSilo),\n                    settleValues.assetsToWithdraw\n                );\n            }\n        } else if (settleValues.pendingDeposit < settleValues.assetsToWithdraw)\n        {\n            _asset.safeTransferFrom(\n                owner(), address(claimableSilo), assetsToVault\n            );\n            if (settleValues.pendingDeposit > 0) {\n                _asset.safeTransferFrom(\n                    address(pendingSilo),\n                    address(claimableSilo),\n                    settleValues.pendingDeposit\n                );\n            }\n        } else if (settleValues.pendingDeposit > 0) {\n            // if _pendingDeposit == assetsToWithdraw AND _pendingDeposit > 0\n            // (and assetsToWithdraw > 0)\n            _asset.safeTransferFrom(\n                address(pendingSilo),\n                address(claimableSilo),\n                settleValues.assetsToWithdraw\n            );\n        }\n\n        emit Deposit(\n            address(pendingSilo),\n            address(claimableSilo),\n            settleValues.pendingDeposit,\n            settleValues.sharesToMint\n        );\n\n        emit Withdraw(\n            address(pendingSilo),\n            address(claimableSilo),\n            address(pendingSilo),\n            settleValues.assetsToWithdraw,\n            settleValues.pendingRedeem\n        );\n\n        settleValues.lastSavedBalance = settleValues.lastSavedBalance\n            - settleValues.fees + settleValues.pendingDeposit\n            - settleValues.assetsToWithdraw;\n        lastSavedBalance = settleValues.lastSavedBalance;\n\n        epochs[epochId].totalSupplySnapshotForDeposit =\n            settleValues.totalSupplySnapshotForDeposit;\n        epochs[epochId].totalAssetsSnapshotForDeposit =\n            settleValues.totalAssetsSnapshotForDeposit;\n        epochs[epochId].totalSupplySnapshotForRedeem =\n            settleValues.totalSupplySnapshotForRedeem;\n        epochs[epochId].totalAssetsSnapshotForRedeem =\n            settleValues.totalAssetsSnapshotForRedeem;\n\n        epochId++;\n\n        return (settleValues.lastSavedBalance, totalSupply());\n    }\n\n    function isCurrentEpoch(uint256 requestId) internal view returns (bool) {\n        return requestId == epochId;\n    }\n\n    function _convertToShares(\n        uint256 assets,\n        uint256 requestId,\n        Math.Rounding rounding\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        if (isCurrentEpoch(requestId)) {\n            return 0;\n        }\n        uint256 totalAssets =\n            epochs[requestId].totalAssetsSnapshotForDeposit + 1;\n        uint256 totalSupply =\n            epochs[requestId].totalSupplySnapshotForDeposit + 1;\n\n        return assets.mulDiv(totalSupply, totalAssets, rounding);\n    }\n\n    function _convertToAssets(\n        uint256 shares,\n        uint256 requestId,\n        Math.Rounding rounding\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        if (isCurrentEpoch(requestId)) {\n            return 0;\n        }\n        uint256 totalAssets = epochs[requestId].totalAssetsSnapshotForRedeem + 1;\n        uint256 totalSupply = epochs[requestId].totalSupplySnapshotForRedeem + 1;\n\n        return shares.mulDiv(totalAssets, totalSupply, rounding);\n    }\n\n    function _checkMaxDrawdown(\n        uint256 _lastSavedBalance,\n        uint256 newSavedBalance\n    )\n        internal\n        view\n    {\n        if (\n            newSavedBalance\n                < _lastSavedBalance.mulDiv(\n                    BPS_DIVIDER - _maxDrawdown, BPS_DIVIDER, Math.Rounding.Ceil\n                )\n        ) revert MaxDrawdownReached();\n    }\n\n    function _computeFees(\n        uint256 _lastSavedBalance,\n        uint256 newSavedBalance\n    )\n        internal\n        view\n        returns (uint256 fees)\n    {\n        if (newSavedBalance > _lastSavedBalance && feesInBps > 0) {\n            uint256 profits;\n            unchecked {\n                profits = newSavedBalance - _lastSavedBalance;\n            }\n            fees = (profits).mulDiv(feesInBps, BPS_DIVIDER, Math.Rounding.Floor);\n        }\n    }\n}"
    },
    {
      "filename": "asynchronous-vault/src/AsyncSynthVault.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {\n    IERC7540,\n    IERC165,\n    IERC7540Redeem,\n    IERC7540Deposit\n} from \"./interfaces/IERC7540.sol\";\nimport { ERC7540Receiver } from \"./interfaces/ERC7540Receiver.sol\";\nimport { IERC20, SafeERC20, Math, PermitParams } from \"./SyncSynthVault.sol\";\n\nimport { SyncSynthVault } from \"./SyncSynthVault.sol\";\n\n/**\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%=::::::=%@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*=#=--=*=*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:*=    =#:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@:@@    @@:@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*-.    .-*@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@*        *@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@.         .@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*  Amphor  *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@*==========#@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@+==========*@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@*   ASync   *@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@%  Vault  %@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@=        +@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%       %@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@=      =@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@%     .@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@=    =@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@%----%@@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@%+:::::+%@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@########@@@@@@@@@@@@@@@@@@@@@\n *         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *\n *            d8888                        888\n *           d88888                        888\n *          d88P888                        888\n *         d88P 888 88888b.d88b.  88888b.  88888b.   .d88b.  888d888\n *        d88P  888 888 \"888 \"88b 888 \"88b 888 \"88b d88\"\"88b 888P\"\n *       d88P   888 888  888  888 888  888 888  888 888  888 888\n *      d8888888888 888  888  888 888 d88P 888  888 Y88..88P 888\n *     d88P     888 888  888  888 88888P\"  888  888  \"Y88P\"  888.io\n *                                888\n *                                888\n *                                888\n */\n\n/*\n * ########\n * # LIBS #\n * ########\n*/\nusing Math for uint256; // only used for `mulDiv` operations.\nusing SafeERC20 for IERC20; // `safeTransfer` and `safeTransferFrom`\n\n/*\n    This structur"
    }
  ]
}