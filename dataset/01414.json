{
  "Title": "M-2: Lost rewards when the supply is `0`, which always happens if the rewards are queued before anyone has `StakeTracker` tokens",
  "Content": "# Issue M-2: Lost rewards when the supply is `0`, which always happens if the rewards are queued before anyone has `StakeTracker` tokens \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/387 \n\n## Found by \n0x73696d616f, chaduke, hassan-truscova, lucifero, p0wd3r\nIf the supply of `StakeTracker` tokens is `0`, the `rewardPerTokenStored` won't increase, but the `lastUpdateBlock` will, leading to lost rewards. \n\n## Vulnerability Detail\nThe rewards are destributed in a [`MasterChef`](https://medium.com/coinmonks/analysis-of-the-billion-dollar-algorithm-sushiswaps-masterchef-smart-contract-81bb4e479eb6) style, which takes snapshots of the total accrued rewards over time and whenever someone wants to get the rewards, it subtracts the snapshot of the user from the most updated, global snapshot. \n\nThe [`rewardsPerToken()`](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol#L180) calculation factors the blocks passed times the reward rate by the `totalSupply()`, to get the reward per token in a specific interval (and then accrues to the previous intervals, as stated in the last paragraph). When the `totalSupply()` is `0`, there is 0 `rewardPerToken()` increment as there is no supply to factor the rewards by.\n\nThe current solution is to [maintain](https://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol#L176-L178) the same `rewardsPerToken()` if the `totalSupply()` is `0`, but the `lastUpdateBlock` is still updated. This means that, during the interval in which the `totalSupply()` is `0`, no rewards are destributed but the block numbers still move forward, leaving the tokens stuck in the `MainRewarder` and `ExtraRewarder` smart contracts.\n\nThis will always happen if the rewards are quewed before the `totalSupply()` is bigger than `0` (before an initial deposit to either `DestinationVault` or `LMPVault`). It might also happen if users withdraw all their tokens from the vaults, leading to a `totalSupply()` of `0`, but this is very unlikely.\n\n## Impact\nLost reward tokens. The amount depends on the time during which the `totalSupply()` is `0`, but could be significant.\n\n## Code Snippet\nThe `rewardPerToken()` calculation:\n```solidity\nfunction rewardPerToken() public view returns (uint256) {\n    uint256 total = totalSupply();\n    if (total == 0) {\n        return rewardPerTokenStored;\n    }\n\n    return rewardPerTokenStored + ((lastBlockRewardApplicable() - lastUpdateBlock) * rewardRate * 1e18 / total);\n}\n```\nThe `rewardPerTokenStored` does not increment when the `totalSupply()` is `0`.\n\n## Tool used\nVscode\nFoundry\nManual Review\n\n## Recommendation\nThe `totalSupply()` should not realistically be `0` after the initial setup period (unless for some reason everyone decides to withdraw from the vaults, but this should be handled separately). It should be enough to only allow queueing rewards if the `totalSupply()` is bigger than `0`. For this, only a new check needs to be added:\n```solidity\nfunction queueNewRewards(uint256 newRewards) external onlyWhitelisted {\n    if (totalSupply() == 0) revert ZeroTotalSupply();\n    ...\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\n\nimport { IStakeTracking } from \"src/interfaces/rewarders/IStakeTracking.sol\";\nimport { IBaseRewarder } from \"src/interfaces/rewarders/IBaseRewarder.sol\";\n\nimport { IGPToke } from \"src/interfaces/staking/IGPToke.sol\";\n\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\n/**\n * @dev An abstract contract that serves as the base for rewarder contracts.\n * It implements common functionalities for reward distribution, including calculating rewards per token,\n * tracking user rewards, and handling stake-related operations.\n * Inherited by rewarder contracts, such as MainRewarder and ExtraRewarder.\n * The contract is inspired by the Convex contract but uses block-based duration instead of timestamp-based duration.\n * Unlike Convex, it does not own the LP token but it interacts with an external LP token contract.\n */\n\nabstract contract AbstractRewarder is IBaseRewarder, SecurityBase {\n    using SafeERC20 for IERC20;\n\n    /// @notice The duration of the reward period in blocks.\n    uint256 public durationInBlock;\n\n    ///  @notice It is used to determine if the new rewards should be distributed immediately or queued for later. If\n    /// the ratio of current rewards to the sum of new and queued rewards is less than newRewardRatio, the new rewards\n    /// are distributed immediately; otherwise, they are added to the queue.\n    uint256 public newRewardRatio;\n\n    /// @notice An instance of the system registry contract.\n    ISystemRegistry internal immutable systemRegistry;\n\n    /// @notice The address of the token to be distributed as rewards.\n    address public immutable rewardToken;\n\n    /// @notice An instance of the stake tracking contract, for managing staked tokens.\n    IStakeTracking public immutable stakeTracker;\n\n    /// @notice The block number when the current reward period ends.\n    uint256 public periodInBlockFinish;\n\n    /// @notice The rate of reward distribution per block.\n    uint256 public rewardRate;\n\n    /// @notice The block number when rewards were last updated.\n    uint256 public lastUpdateBlock;\n\n    /// @notice The amount of rewards distributed per staked token stored.\n    uint256 public rewardPerTokenStored;\n\n    /// @notice The amount of rewards waiting in the queue to be distributed.\n    uint256 public queuedRewards;\n\n    /// @notice The amount of current rewards being distributed.\n    uint256 public currentRewards;\n\n    /// @notice The total amount of rewards distributed historically.\n    uint256 public historicalRewards;\n\n    /// @notice The amount of reward per token paid to each user.\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    /// @notice The amount of rewards for each user.\n    mapping(address => uint256) public rewards;\n\n    /// @notice The duration for locking the Toke token rewards.\n    uint256 public tokeLockDuration;\n\n    /// @notice Whitelisted addresses for queuing new rewards.\n    mapping(address => bool) public whitelistedAddresses;\n\n    /**\n     * @param _systemRegistry Address of the system registry.\n     * @param _stakeTracker Address of the stake tracker.\n     * @param _rewardToken Address of the reward token.\n     * @param _newRewardRate The new reward rate.\n     * @param _durationInBlock The duration of the reward period in blocks.\n     */\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _stakeTracker,\n        address _rewardToken,\n        uint256 _newRewardRate,\n        uint256 _durationInBlock\n    ) SecurityBase(address(_systemRegistry.accessController())) {\n        Errors.verifyNotZero(_stakeTracker, \"_stakeTracker\");\n        Errors.verifyNotZero(_rewardToken, \"_rewardToken\");\n\n        systemRegistry = _systemRegistry;\n        if (!systemRegistry.isRewardToken(_rewardToken)) {\n            revert Errors.InvalidParam(\"_rewardToken\");\n        }\n        rewardToken = _rewardToken;\n        stakeTracker = IStakeTracking(_stakeTracker);\n        newRewardRatio = _newRewardRate;\n        durationInBlock = _durationInBlock;\n    }\n\n    /// @notice Restricts access to the stake tracker only.\n    modifier onlyStakeTracker() {\n        if (msg.sender != address(stakeTracker)) {\n            revert Errors.AccessDenied();\n        }\n        _;\n    }\n\n    /// @notice Restricts access to whitelisted addresses or holders of the liquidator role.\n    modifier onlyWhitelisted() {\n        if (!whitelistedAddresses[msg.sender] && !_hasRole(Roles.LIQUIDATOR_ROLE, msg.sender)) {\n            revert Errors.AccessDenied();\n        }\n        _;\n    }\n\n    /**\n     * @notice Internal function that updates the user's rewards.\n     * @param account The address of the user to update the rewards for.\n     */\n    function _updateReward(address account) internal {\n        uint256 earnedRewards = 0;\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateBlock = lastBlockRewardApplicable();\n\n        if (account != address(0)) {\n            earnedRewards = earned(account);\n            rewards[account] = earnedRewards;\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n\n        emit UserRewardUpdated(account, earnedRewards, rewardPerTokenStored, lastUpdateBlock);\n    }\n\n    /**\n     * @notice Retrieves the total supply of staked tokens.\n     * @return The total supply of staked tokens.\n     */\n    function totalSupply() public view returns (uint256) {\n        return stakeTracker.totalSupply();\n    }\n\n    /**\n     * @notice Retrieves the balance of staked tokens for a specific account.\n     * @param account The address of the account to retrieve the balance for.\n     * @return The balance of staked tokens for the specified account.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return stakeTracker.balanceOf(account);\n    }\n\n    /**\n     * @notice Determines the last block number applicable for rewards calculation.\n     * @return The block number used for rewards calculation.\n     * @dev If the current block number is less than the period finish => current block number,\n     *      Else => the period finish block number.\n     */\n    function lastBlockRewardApplicable() public view returns (uint256) {\n        return block.number < periodInBlockFinish ? block.number : periodInBlockFinish;\n    }\n\n    /**\n     * @notice Calculates the current reward per token value.\n     * @return The reward per token value.\n     * @dev It takes into account the total supply, reward rate, and duration of the reward period.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        uint256 total = totalSupply();\n        if (total == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + ((lastBlockRewardApplicable() - lastUpdateBlock) * rewardRate * 1e18 / total);\n    }\n\n    /**\n     * @notice Calculates the amount of rewards earned by an account.\n     * @dev\n     * The function calculates the earned rewards based on the balance of the account,\n     * the total supply of the staked tokens, the rewards per token and the last reward rate\n     * the user has been paid at. The reward rate is determined by the `rewardPerToken`\n     * function and is a measure of the amount of rewards distributed per staked token\n     * per block.\n     *\n     * The amount of earned rewards is calculated as follows:\n     * - First, it calculates the difference between the current reward per token and\n     *   the last reward rate the user was paid at, which gives the reward rate per token\n     *   since the user last claimed rewards.\n     * - This difference is multiplied by the balance of the account to find the total\n     *   amount of rewards the account has earned since it last claimed rewards.\n     * - Finally, the function adds the rewards that have not yet been claimed by the\n     *   user to find the total amount of earned rewards.\n     *\n     * @param account The address of the account to calculate the earned rewards for.\n     * @return The total amount of rewards that the account has earned.\n     */\n    function earned(address account) public view returns (uint256) {\n        return (balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18) + rewards[account];\n    }\n\n    /**\n     * @notice Updates the duration of the reward period in blocks.\n     * @param _durationInBlock The new duration of the reward period in blocks.\n     */\n    function setDurationInBlock(uint256 _durationInBlock) external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        durationInBlock = _durationInBlock;\n        emit RewardDurationUpdated(_durationInBlock);\n    }\n\n    /**\n     * @notice Updates the new reward ratio.\n     * @param _newRewardRate The new reward ratio to determine the distribution of rewards.\n     */\n    function setNewRewardRate(uint256 _newRewardRate) external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        newRewardRatio = _newRewardRate;\n        emit NewRewardRateUpdated(_newRewardRate);\n    }\n\n    /**\n     * @notice Queues the specified amount of new rewards for distribution to stakers.\n     * @param newRewards The amount of new rewards.\n     * @dev First, the function transfers the new rewards from the caller to this contract,\n     *      ensuring that the deposited amount matches the declared rewards.\n     *      Then, irrespective of whether we're near the start or the end of a reward period, if the accrued rewards\n     *      are too large relative to the new rewards (i.e., queuedRatio is greater than newRewardRatio), the new\n     *      rewards will be added to the queue rather than being immediately distributed.\n     */\n    function queueNewRewards(uint256 newRewards) external onlyWhitelisted {\n        uint256 startingQueuedRewards = queuedRewards;\n        uint256 startingNewRewards = newRewards;\n\n        newRewards += startingQueuedRewards;\n\n        if (block.number >= periodInBlockFinish) {\n            notifyRewardAmount(newRewards);\n            queuedRewards = 0;\n        } else {\n            uint256 elapsedBlock = block.number - (periodInBlockFinish - durationInBlock);\n            uint256 currentAtNow = rewardRate * elapsedBlock;\n            uint256 queuedRatio = currentAtNow * 1000 / newRewards;\n\n            if (queuedRatio < newRewardRatio) {\n                notifyRewardAmount(newRewards);\n                queuedRewards = 0;\n            } else {\n                queuedRewards = newRewards;\n            }\n        }\n\n        emit QueuedRewardsUpdated(startingQueuedRewards, startingNewRewards, queuedRewards);\n\n        // Transfer the new rewards from the caller to this contract.\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), newRewards);\n    }\n\n    /**\n     * @notice Notifies the contract about the amount of reward tokens to be distributed.\n     * @param reward The amount of reward tokens to be distributed.\n     * @dev The function updates the rewardRate, lastUpdateBlock, periodInBlockFinish, and historicalRewards.\n     *      It calculates the remaining reward based on the current block number and adjusts the reward rate\n     *      accordingly.\n     *\n     *      If the current block number is within the reward period, the remaining reward is added to the reward queue\n     *      and will be distributed gradually over the remaining duration.\n     *      If the current block number exceeds the reward period, the remaining reward is distributed immediately.\n     */\n    function notifyRewardAmount(uint256 reward) internal {\n        _updateReward(address(0));\n        historicalRewards += reward;\n\n        if (block.number < periodInBlockFinish) {\n            uint256 remaining = periodInBlockFinish - block.number;\n            // slither-disable-next-line divide-before-multiply\n            uint256 leftover = remaining * rewardRate;\n            reward += leftover;\n        }\n\n        rewardRate = reward / durationInBlock;\n        currentRewards = reward;\n        lastUpdateBlock = block.number;\n        periodInBlockFinish = block.number + durationInBlock;\n\n        emit RewardAdded(reward, rewardRate, lastUpdateBlock, periodInBlockFinish, historicalRewards);\n    }\n\n    /**\n     * @notice Sets the lock duration for staked Toke tokens.\n     * @dev If the lock duration is set to 0, it turns off the staking functionality for Toke tokens.\n     * @dev If the lock duration is greater than 0, it should be long enough to satisfy the minimum staking duration\n     * requirement of the gpToke contract.\n     * @param _tokeLockDuration The lock duration for staked Toke tokens.\n     */\n    function setTokeLockDuration(uint256 _tokeLockDuration) external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        // if duration is not set to 0 (that would turn off functionality), make sure it's long enough for gpToke\n        if (_tokeLockDuration > 0) {\n            Errors.verifyNotZero(address(systemRegistry.gpToke()), \"gpToke\");\n            if (_tokeLockDuration < systemRegistry.gpToke().minStakeDuration()) {\n                revert IGPToke.StakingDurationTooShort();\n            }\n        }\n\n        tokeLockDuration = _tokeLockDuration;\n        emit TokeLockDurationUpdated(_tokeLockDuration);\n    }\n\n    /**\n     * @notice Add an address to the whitelist.\n     * @param wallet The address to be added to the whitelist.\n     */\n    function addToWhitelist(address wallet) external override hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        Errors.verifyNotZero(wallet, \"wallet\");\n        if (whitelistedAddresses[wallet]) {\n            revert Errors.ItemExists();\n        }\n        whitelistedAddresses[wallet] = true;\n\n        emit AddedToWhitelist(wallet);\n    }\n\n    /**\n     * @notice Remove an address from the whitelist.\n     * @param wallet The address to be removed from the whitelist.\n     */\n    function removeFromWhitelist(address wallet) external override hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        if (!whitelistedAddresses[wallet]) {\n            revert Errors.ItemNotFound();\n        }\n\n        whitelistedAddresses[wallet] = false;\n\n        emit RemovedFromWhitelist(wallet);\n    }\n\n    /**\n     * @notice Check if an address is whitelisted.\n     * @param wallet The address to be checked.\n     * @return bool indicating if the address is whitelisted.\n     */\n    function isWhitelisted(address wallet) external view override returns (bool) {\n        return whitelistedAddresses[wallet];\n    }\n\n    /**\n     * @notice Internal function to distribute rewards to a specific account.\n     * @param account The address of the user to distribute rewards to.\n     */\n    function _getReward(address account) internal {\n        Errors.verifyNotZero(account, \"account\");\n\n        uint256 reward = earned(account);\n        (IGPToke gpToke, address tokeAddress) = (systemRegistry.gpToke(), address(systemRegistry.toke()));\n\n        // slither-disable-next-line incorrect-equality\n        if (reward == 0) return;\n\n        rewards[account] = 0;\n        emit RewardPaid(account, reward);\n\n        // if NOT toke, or staking is turned off (by duration = 0), just send reward back\n        if (rewardToken != tokeAddress || tokeLockDuration == 0) {\n            IERC20(rewardToken).safeTransfer(account, reward);\n        } else {\n            // authorize gpToke to get our reward Toke\n            // slither-disable-next-line unused-return\n            IERC20(address(tokeAddress)).approve(address(gpToke), reward);\n\n            // stake Toke\n            gpToke.stake(reward, tokeLockDuration, account);\n        }\n    }\n\n    /**\n     * @notice Internal function to handle withdrawals.\n     * @param account The address of the user to handle withdrawal.\n     * @dev This function primarily checks for valid parameters and emits an event.\n     *      It adopts a pattern established by Convex. It helps with:\n     *      - Identifying system errors (if a revert happens here, there is an issue within our system).\n     *      - Enhancing system monitoring capabilities through emitted events.\n     * @param amount The amount to be withdrawn.\n     */\n    function _withdraw(address account, uint256 amount) internal {\n        Errors.verifyNotZero(account, \"account\");\n        Errors.verifyNotZero(amount, \"amount\");\n\n        emit Withdrawn(account, amount);\n    }\n\n    /**\n     * @notice Internal function to handle staking.\n     * @dev This function primarily checks for valid parameters and emits an event.\n     *      It adopts a pattern established by Convex. It helps with:\n     *      - Identifying system errors (if a revert happens here, there is an issue within our system).\n     *      - Enhancing system monitoring capabilities through emitted events.\n     * @param account The address of the user to handle staking.\n     * @param amount The amount to be staked.\n     */\n    function _stake(address account, uint256 amount) internal {\n        Errors.verifyNotZero(account, \"account\");\n        Errors.verifyNotZero(amount, \"amount\");\n\n        emit Staked(account, amount);\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/rewarders/AbstractRewarder.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\n\nimport { IStakeTracking } from \"src/interfaces/rewarders/IStakeTracking.sol\";\nimport { IBaseRewarder } from \"src/interfaces/rewarders/IBaseRewarder.sol\";\n\nimport { IGPToke } from \"src/interfaces/staking/IGPToke.sol\";\n\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\n/**\n * @dev An abstract contract that serves as the base for rewarder contracts.\n * It implements common functionalities for reward distribution, including calculating rewards per token,\n * tracking user rewards, and handling stake-related operations.\n * Inherited by rewarder contracts, such as MainRewarder and ExtraRewarder.\n * The contract is inspired by the Convex contract but uses block-based duration instead of timestamp-based duration.\n * Unlike Convex, it does not own the LP token but it interacts with an external LP token contract.\n */\n\nabstract contract AbstractRewarder is IBaseRewarder, SecurityBase {\n    using SafeERC20 for IERC20;\n\n    /// @notice The duration of the reward period in blocks.\n    uint256 public durationInBlock;\n\n    ///  @notice It is used to determine if the new rewards should be distributed immediately or queued for later. If\n    /// the ratio of current rewards to the sum of new and queued rewards is less than newRewardRatio, the new rewards\n    /// are distributed immediately; otherwise, they are added to the queue.\n    uint256 public newRewardRatio;\n\n    /// @notice An instance of the system registry contract.\n    ISystemRegistry internal immutable systemRegistry;\n\n    /// @notice The address of the token to be distributed as rewards.\n    address public immutable rewardToken;\n\n    /// @notice An instance of the stake tracking contract, for managing staked tokens.\n    IStakeTracking public immutable stakeTracker;\n\n    /// @notice The block number when the current reward period ends.\n    uint256 public periodInBlockFinish;\n\n    /// @notice The rate of reward distribution per block.\n    uint256 public rewardRate;\n\n    /// @notice The block number when rewards were last updated.\n    uint256 public lastUpdateBlock;\n\n    /// @notice The amount of rewards distributed per staked token stored.\n    uint256 public rewardPerTokenStored;\n\n    /// @notice The amount of rewards waiting in the queue to be distributed.\n    uint256 public queuedRewards;\n\n    /// @notice The amount of current rewards being distributed.\n    uint256 public currentRewards;\n\n    /// @notice The total amount of rewards distributed historically.\n    uint256 public historicalRewards;\n\n    /// @notice The amount of reward per token paid to each user.\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    /// @notice The amount of rewards for each user.\n    mapping(address => uint256) public rewards;\n\n    /// @notice The duration for locking the Toke token rewards.\n    uint256 public tokeLockDuration;\n\n    /// @notice Whitelisted addresses for queuing new rewards.\n    mapping(address => bool) public whitelistedAddresses;\n\n    /**\n     * @param _systemRegistry Address of the system registry.\n     * @param _stakeTracker Address of the stake tracker.\n     * @param _rewardToken Address of the reward token.\n     * @param _newRewardRate The new reward rate.\n     * @param _durationInBlock The duration of the reward period in blocks.\n     */\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _stakeTracker,\n        address _rewardToken,\n        uint256 _newRewardRate,\n        uint256 _durationInBlock\n    ) SecurityBase(address(_systemRegistry.accessController())) {\n        Errors.verifyNotZero(_stakeTracker, \"_stakeTracker\");\n        Errors.verifyNotZero(_rewardToken, \"_rewardToken\");\n\n        systemRegistry = _systemRegistry;\n        if (!systemRegistry.isRewardToken(_rewardToken)) {\n            revert Errors.InvalidParam(\"_rewardToken\");\n        }\n        rewardToken = _rewardToken;\n        stakeTracker = IStakeTracking(_stakeTracker);\n        newRewardRatio = _newRewardRate;\n        durationInBlock = _durationInBlock;\n    }\n\n    /// @notice Restricts access to the stake tracker only.\n    modifier onlyStakeTracker() {\n        if (msg.sender != address(stakeTracker)) {\n            revert Errors.AccessDenied();\n        }\n        _;\n    }\n\n    /// @notice Restricts access to whitelisted addresses or holders of the liquidator role.\n    modifier onlyWhitelisted() {\n        if (!whitelistedAddresses[msg.sender] && !_hasRole(Roles.LIQUIDATOR_ROLE, msg.sender)) {\n            revert Errors.AccessDenied();\n        }\n        _;\n    }\n\n    /**\n     * @notice Internal function that updates the user's rewards.\n     * @param account The address of the user to update the rewards for.\n     */\n    function _updateReward(address account) internal {\n        uint256 earnedRewards = 0;\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateBlock = lastBlockRewardApplicable();\n\n        if (account != address(0)) {\n            earnedRewards = earned(account);\n            rewards[account] = earnedRewards;\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n\n        emit UserRewardUpdated(account, earnedRewards, rewardPerTokenStored, lastUpdateBlock);\n    }\n\n    /**\n     * @notice Retrieves the total supply of staked tokens.\n     * @return The total supply of staked tokens.\n     */\n    function totalSupply() public view returns (uint256) {\n        return stakeTracker.totalSupply();\n    }\n\n    /**\n     * @notice Retrieves the balance of staked tokens for a specific account.\n     * @param account The address of the account to retrieve the balance for.\n     * @return The balance of staked tokens for the specified account.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return stakeTracker.balanceOf(account);\n    }\n\n    /**\n     * @notice Determines the last block number applicable for rewards calculation.\n     * @return The block number used for rewards calculation.\n     * @dev If the current block number is less than the period finish => current block number,\n     *      Else => the period finish block number.\n     */\n    function lastBlockRewardApplicable() public view returns (uint256) {\n        return block.number < periodInBlockFinish ? block.number : periodInBlockFinish;\n    }\n\n    /**\n     * @notice Calculates the current reward per token value.\n     * @return The reward per token value.\n     * @dev It takes into account the total supply, reward rate, and duration of the reward period.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        uint256 total = totalSupply();\n        if (total == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + ((lastBlockRewardApplicable() - lastUpdateBlock) * rewardRate * 1e18 / total);\n    }\n\n    /**\n     * @notice Calculates the amount of rewards earned by an account.\n     * @dev\n     * The function calculates the earned rewards based on the balance of the account,\n     * the total supply of the staked tokens, the rewards per token and the last reward rate\n     * the user has been paid at. The reward rate is determined by the `rewardPerToken`\n     * function and is a measure of the amount of rewards distributed per staked token\n     * per block.\n     *\n     * The amount of earned rewards is calculated as follows:\n     * - First, it calculates the difference between the current reward per token and\n     *   the last reward rate the user was paid at, which gives the reward rate per token\n     *   since the user last claimed rewards.\n     * - This difference is multiplied by the balance of the account to find the total\n     *   amount of rewards the account has earned since it last claimed rewards.\n     * - Finally, the function adds the rewards that have not yet been claimed by the\n     *   user to find the total amount of earned rewards.\n     *\n     * @param account The address of the account to calculate the earned rewards for.\n     * @return The total amount of rewards that the account has earned.\n     */\n    function earned(address account) public view returns (uint256) {\n        return (balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18) + rewards[account];\n    }\n\n    /**\n     * @notice Updates the duration of the reward period in blocks.\n     * @param _durationInBlock The new duration of the reward period in blocks.\n     */\n    function setDurationInBlock(uint256 _durationInBlock) external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        durationInBlock = _durationInBlock;\n        emit RewardDurationUpdated(_durationInBlock);\n    }\n\n    /**\n     * @notice Updates the new reward ratio.\n     * @param _newRewardRate The new reward ratio to determine the distribution of rewards.\n     */\n    function setNewRewardRate(uint256 _newRewardRate) external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        newRewardRatio = _newRewardRate;\n        emit NewRewardRateUpdated(_newRewardRate);\n    }\n\n    /**\n     * @notice Queues the specified amount of new rewards for distribution to stakers.\n     * @param newRewards The amount of new rewards.\n     * @dev First, the function transfers the new rewards from the caller to this contract,\n     *      ensuring that the deposited amount matches the declared rewards.\n     *      Then, irrespective of whether we're near the start or the end of a reward period, if the accrued rewards\n     *      are too large relative to the new rewards (i.e., queuedRatio is greater than newRewardRatio), the new\n     *      rewards will be added to the queue rather than being immediately distributed.\n     */\n    function queueNewRewards(uint256 newRewards) external onlyWhitelisted {\n        uint256 startingQueuedRewards = queuedRewards;\n        uint256 startingNewRewards = newRewards;\n\n        newRewards += startingQueuedRewards;\n\n        if (block.number >= periodInBlockFinish) {\n            notifyRewardAmount(newRewards);\n            queuedRewards = 0;\n        } else {\n            uint256 elapsedBlock = block.number - (periodInBlockFinish - durationInBlock);\n            uint256 currentAtNow = rewardRate * elapsedBlock;\n            uint256 queuedRatio = currentAtNow * 1000 / newRewards;\n\n            if (queuedRatio < newRewardRatio) {\n                notifyRewardAmount(newRewards);\n                queuedRewards = 0;\n            } else {\n                queuedRewards = newRewards;\n            }\n        }\n\n        emit QueuedRewardsUpdated(startingQueuedRewards, startingNewRewards, queuedRewards);\n\n        // Transfer the new rewards from the caller to this contract.\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), newRewards);\n    }\n\n    /**\n     * @notice Notifies the contract about the amount of reward tokens to be distributed.\n     * @param reward The amount of reward tokens to be distributed.\n     * @dev The function updates the rewardRate, lastUpdateBlock, periodInBlockFinish, and historicalRewards.\n     *      It calculates the remaining reward based on the current block number and adjusts the reward rate\n     *      accordingly.\n     *\n     *      If the current block number is within the reward period, the remaining reward is added to the reward queue\n     *      and will be distributed gradually over the remaining duration.\n     *      If the current block number exceeds the reward period, the remaining reward is distributed immediately.\n     */\n    function notifyRewardAmount(uint256 reward) internal {\n        _updateReward(address(0));\n        historicalRewards += reward;\n\n        if (block.number < periodInBlockFinish) {\n            uint256 remaining = periodInBlockFinish - block.number;\n            // slither-disable-next-line divide-before-multiply\n            uint256 leftover = remaining * rewardRate;\n            reward += leftover;\n        }\n\n        rewardRate = reward / durationInBlock;\n        currentRewards = reward;\n        lastUpdateBlock = block.number;\n        periodInBlockFinish = block.number + durationInBlock;\n\n        emit RewardAdded(reward, rewardRate, lastUpdateBlock, periodInBlockFinish, historicalRewards);\n    }\n\n    /**\n     * @notice Sets the lock duration for staked Toke tokens.\n     * @dev If the lock duration is set to 0, it turns off the staking functionality for Toke tokens.\n     * @dev If the lock duration is greater than 0, it should be long enough to satisfy the minimum staking duration\n     * requirement of the gpToke contract.\n     * @param _tokeLockDuration The lock duration for staked Toke tokens.\n     */\n    function setTokeLockDuration(uint256 _tokeLockDuration) external hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        // if duration is not set to 0 (that would turn off functionality), make sure it's long enough for gpToke\n        if (_tokeLockDuration > 0) {\n            Errors.verifyNotZero(address(systemRegistry.gpToke()), \"gpToke\");\n            if (_tokeLockDuration < systemRegistry.gpToke().minStakeDuration()) {\n                revert IGPToke.StakingDurationTooShort();\n            }\n        }\n\n        tokeLockDuration = _tokeLockDuration;\n        emit TokeLockDurationUpdated(_tokeLockDuration);\n    }\n\n    /**\n     * @notice Add an address to the whitelist.\n     * @param wallet The address to be added to the whitelist.\n     */\n    function addToWhitelist(address wallet) external override hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        Errors.verifyNotZero(wallet, \"wallet\");\n        if (whitelistedAddresses[wallet]) {\n            revert Errors.ItemExists();\n        }\n        whitelistedAddresses[wallet] = true;\n\n        emit AddedToWhitelist(wallet);\n    }\n\n    /**\n     * @notice Remove an address from the whitelist.\n     * @param wallet The address to be removed from the whitelist.\n     */\n    function removeFromWhitelist(address wallet) external override hasRole(Roles.DV_REWARD_MANAGER_ROLE) {\n        if (!whitelistedAddresses[wallet]) {\n            revert Errors.ItemNotFound();\n        }\n\n        whitelistedAddresses[wallet] = false;\n\n        emit RemovedFromWhitelist(wallet);\n    }\n\n    /**\n     * @notice Check if an address is whitelisted.\n     * @param wallet The address to be checked.\n     * @return bool indicating if the address is whitelisted.\n     */\n    function isWhitelisted(address wallet) external view override returns (bool) {\n        return whitelistedAddresses[wallet];\n    }\n\n    /**\n     * @notice Internal function to distribute rewards to a specific account.\n     * @param account The address of the user to distribute rewards to.\n     */\n    function _getReward(address account) internal {\n        Errors.verifyNotZero(account, \"account\");\n\n        uint256 reward = earned(account);\n        (IGPToke gpToke, address tokeAddress) = (systemRegistry.gpToke(), address(systemRegistry.toke()));\n\n        // slither-disable-next-line incorrect-equality\n        if (reward == 0) return;"
    }
  ]
}