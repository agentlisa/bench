{
  "Title": "[M-03] There is no re-register or re-assign function",
  "Content": "\n<https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/CIP-001/src/Turnstile.sol#L86-L101>\n\n<https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/CIP-001/src/Turnstile.sol#L107-L120>\n\n### Impact\n\nThere is no re-register or re-assign option for the smart contracts.\n\nLet's assume a smart contract is registered either through the `register()` function with a new NFT minted or the `assign()` function to an existing NFT.\n\nHowever, if somehow, the NFT is burned by the owner or transferred to another owner either by an approval or compromised tx, there is no option to re-register for these contracts which create gas fees but might not get a fee distribution in return.\n\nAnd if the NFT is burned or transferred to another owner, the smart contracts will lose the fees generated if not previously withdrawn.\n\n### Proof of Concept\n\n`register` function;\n\n```solidity\n    function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n        address smartContract = msg.sender;\n\n        if (_recipient == address(0)) revert InvalidRecipient();\n\n        tokenId = _tokenIdTracker.current();\n        _mint(_recipient, tokenId);\n        _tokenIdTracker.increment();\n\n        emit Register(smartContract, _recipient, tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: tokenId,\n            registered: true\n        });\n    }\n```\n\n[Permalink](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/CIP-001/src/Turnstile.sol#L86-L101)\n\n`assign` function;\n\n```solidity\n    function assign(uint256 _tokenId) public onlyUnregistered returns (uint256) {\n        address smartContract = msg.sender;\n\n        if (!_exists(_tokenId)) revert InvalidTokenId();\n\n        emit Assign(smartContract, _tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: _tokenId,\n            registered: true\n        });\n\n        return _tokenId;\n    }\n```\n\n[Permalink](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/CIP-001/src/Turnstile.sol#L107-L120)\n\n### Recommended Mitigation Steps\n\nThe team might consider adding an option to validate historical registrations and re-register those contracts accordingly.\n\n**[tkkwon1998 (Canto) acknowledged and commented](https://github.com/code-423n4/2022-11-canto-findings/issues/131#issuecomment-1356486212):**\n > Currently there is no way to re-assign or re-register. This is a known limitation, and will be made extremely clear to all devs registering their contracts. \n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-11-canto",
  "Code": [
    {
      "filename": "CIP-001/src/Turnstile.sol",
      "content": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.8.17;\n\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"openzeppelin/utils/Counters.sol\";\n\n/// @notice Implementation of CIP-001 https://github.com/Canto-Improvement-Proposals/CIPs/blob/main/CIP-001.md\n/// @dev Every contract is responsible to register itself in the constructor by calling `register(address)`.\n///      If contract is using proxy pattern, it's possible to register retroactively, however past fees will be lost.\n///      Recipient withdraws fees by calling `withdraw(uint256,address,uint256)`.\ncontract Turnstile is Ownable, ERC721Enumerable {\n    using Counters for Counters.Counter;\n\n    struct NftData {\n        uint256 tokenId;\n        bool registered;\n    }\n\n    Counters.Counter private _tokenIdTracker;\n\n    /// @notice maps smart contract address to tokenId\n    mapping(address => NftData) public feeRecipient;\n\n    /// @notice maps tokenId to fees earned\n    mapping(uint256 => uint256) public balances;\n\n    event Register(address smartContract, address recipient, uint256 tokenId);\n    event Assign(address smartContract, uint256 tokenId);\n    event Withdraw(uint256 tokenId, address recipient, uint256 feeAmount);\n    event DistributeFees(uint256 tokenId, uint256 feeAmount);\n\n    error NotAnOwner();\n    error AlreadyRegistered();\n    error Unregistered();\n    error InvalidRecipient();\n    error InvalidTokenId();\n    error NothingToWithdraw();\n    error NothingToDistribute();\n\n    /// @dev only owner of _tokenId can call this function\n    modifier onlyNftOwner(uint256 _tokenId) {\n        if (ownerOf(_tokenId) != msg.sender) revert NotAnOwner();\n\n        _;\n    }\n\n    /// @dev only smart contract that is unregistered can call this function\n    modifier onlyUnregistered() {\n        address smartContract = msg.sender;\n\n        if (isRegistered(smartContract)) revert AlreadyRegistered();\n\n        _;\n    }\n\n    constructor() ERC721(\"Turnstile\", \"Turnstile\") {}\n\n    /// @notice Returns current value of counter used to tokenId of new minted NFTs\n    /// @return current counter value\n    function currentCounterId() external view returns (uint256) {\n        return _tokenIdTracker.current();\n    }\n\n    /// @notice Returns tokenId that collects fees generated by the smart contract\n    /// @param _smartContract address of the smart contract\n    /// @return tokenId that collects fees generated by the smart contract\n    function getTokenId(address _smartContract) external view returns (uint256) {\n        if (!isRegistered(_smartContract)) revert Unregistered();\n\n        return feeRecipient[_smartContract].tokenId;\n    }\n\n    /// @notice Returns true if smart contract is registered to collect fees\n    /// @param _smartContract address of the smart contract\n    /// @return true if smart contract is registered to collect fees, false otherwise\n    function isRegistered(address _smartContract) public view returns (bool) {\n        return feeRecipient[_smartContract].registered;\n    }\n\n    /// @notice Mints ownership NFT that allows the owner to collect fees earned by the smart contract.\n    ///         `msg.sender` is assumed to be a smart contract that earns fees. Only smart contract itself\n    ///         can register a fee receipient.\n    /// @param _recipient recipient of the ownership NFT\n    /// @return tokenId of the ownership NFT that collects fees\n    function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n        address smartContract = msg.sender;\n\n        if (_recipient == address(0)) revert InvalidRecipient();\n\n        tokenId = _tokenIdTracker.current();\n        _mint(_recipient, tokenId);\n        _tokenIdTracker.increment();\n\n        emit Register(smartContract, _recipient, tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: tokenId,\n            registered: true\n        });\n    }\n\n    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.\n    ///         Callable only by smart contract itself.\n    /// @param _tokenId tokenId which will collect fees\n    /// @return tokenId of the ownership NFT that collects fees\n    function assign(uint256 _tokenId) public onlyUnregistered returns (uint256) {\n        address smartContract = msg.sender;\n\n        if (!_exists(_tokenId)) revert InvalidTokenId();\n\n        emit Assign(smartContract, _tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: _tokenId,\n            registered: true\n        });\n\n        return _tokenId;\n    }\n\n    /// @notice Withdraws earned fees to `_recipient` address. Only callable by NFT owner.\n    /// @param _tokenId token Id\n    /// @param _recipient recipient of fees\n    /// @param _amount amount of fees to withdraw\n    /// @return amount of fees withdrawn\n    function withdraw(uint256 _tokenId, address payable _recipient, uint256 _amount)\n        public\n        onlyNftOwner(_tokenId)\n        returns (uint256)\n    {\n        uint256 earnedFees = balances[_tokenId];\n\n        if (earnedFees == 0 || _amount == 0) revert NothingToWithdraw();\n        if (_amount > earnedFees) _amount = earnedFees;\n\n        balances[_tokenId] = earnedFees - _amount;\n\n        emit Withdraw(_tokenId, _recipient, _amount);\n\n        Address.sendValue(_recipient, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Distributes collected fees to the smart contract. Only callable by owner.\n    /// @param _tokenId NFT that earned fees\n    function distributeFees(uint256 _tokenId) public onlyOwner payable {\n        if (msg.value == 0) revert NothingToDistribute();\n\n        balances[_tokenId] += msg.value;\n        emit DistributeFees(_tokenId, msg.value);\n    }\n}"
    },
    {
      "filename": "CIP-001/src/Turnstile.sol",
      "content": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.8.17;\n\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"openzeppelin/utils/Counters.sol\";\n\n/// @notice Implementation of CIP-001 https://github.com/Canto-Improvement-Proposals/CIPs/blob/main/CIP-001.md\n/// @dev Every contract is responsible to register itself in the constructor by calling `register(address)`.\n///      If contract is using proxy pattern, it's possible to register retroactively, however past fees will be lost.\n///      Recipient withdraws fees by calling `withdraw(uint256,address,uint256)`.\ncontract Turnstile is Ownable, ERC721Enumerable {\n    using Counters for Counters.Counter;\n\n    struct NftData {\n        uint256 tokenId;\n        bool registered;\n    }\n\n    Counters.Counter private _tokenIdTracker;\n\n    /// @notice maps smart contract address to tokenId\n    mapping(address => NftData) public feeRecipient;\n\n    /// @notice maps tokenId to fees earned\n    mapping(uint256 => uint256) public balances;\n\n    event Register(address smartContract, address recipient, uint256 tokenId);\n    event Assign(address smartContract, uint256 tokenId);\n    event Withdraw(uint256 tokenId, address recipient, uint256 feeAmount);\n    event DistributeFees(uint256 tokenId, uint256 feeAmount);\n\n    error NotAnOwner();\n    error AlreadyRegistered();\n    error Unregistered();\n    error InvalidRecipient();\n    error InvalidTokenId();\n    error NothingToWithdraw();\n    error NothingToDistribute();\n\n    /// @dev only owner of _tokenId can call this function\n    modifier onlyNftOwner(uint256 _tokenId) {\n        if (ownerOf(_tokenId) != msg.sender) revert NotAnOwner();\n\n        _;\n    }\n\n    /// @dev only smart contract that is unregistered can call this function\n    modifier onlyUnregistered() {\n        address smartContract = msg.sender;\n\n        if (isRegistered(smartContract)) revert AlreadyRegistered();\n\n        _;\n    }\n\n    constructor() ERC721(\"Turnstile\", \"Turnstile\") {}\n\n    /// @notice Returns current value of counter used to tokenId of new minted NFTs\n    /// @return current counter value\n    function currentCounterId() external view returns (uint256) {\n        return _tokenIdTracker.current();\n    }\n\n    /// @notice Returns tokenId that collects fees generated by the smart contract\n    /// @param _smartContract address of the smart contract\n    /// @return tokenId that collects fees generated by the smart contract\n    function getTokenId(address _smartContract) external view returns (uint256) {\n        if (!isRegistered(_smartContract)) revert Unregistered();\n\n        return feeRecipient[_smartContract].tokenId;\n    }\n\n    /// @notice Returns true if smart contract is registered to collect fees\n    /// @param _smartContract address of the smart contract\n    /// @return true if smart contract is registered to collect fees, false otherwise\n    function isRegistered(address _smartContract) public view returns (bool) {\n        return feeRecipient[_smartContract].registered;\n    }\n\n    /// @notice Mints ownership NFT that allows the owner to collect fees earned by the smart contract.\n    ///         `msg.sender` is assumed to be a smart contract that earns fees. Only smart contract itself\n    ///         can register a fee receipient.\n    /// @param _recipient recipient of the ownership NFT\n    /// @return tokenId of the ownership NFT that collects fees\n    function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n        address smartContract = msg.sender;\n\n        if (_recipient == address(0)) revert InvalidRecipient();\n\n        tokenId = _tokenIdTracker.current();\n        _mint(_recipient, tokenId);\n        _tokenIdTracker.increment();\n\n        emit Register(smartContract, _recipient, tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: tokenId,\n            registered: true\n        });\n    }\n\n    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.\n    ///         Callable only by smart contract itself.\n    /// @param _tokenId tokenId which will collect fees\n    /// @return tokenId of the ownership NFT that collects fees\n    function assign(uint256 _tokenId) public onlyUnregistered returns (uint256) {\n        address smartContract = msg.sender;\n\n        if (!_exists(_tokenId)) revert InvalidTokenId();\n\n        emit Assign(smartContract, _tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: _tokenId,\n            registered: true\n        });\n\n        return _tokenId;\n    }\n\n    /// @notice Withdraws earned fees to `_recipient` address. Only callable by NFT owner.\n    /// @param _tokenId token Id\n    /// @param _recipient recipient of fees\n    /// @param _amount amount of fees to withdraw\n    /// @return amount of fees withdrawn\n    function withdraw(uint256 _tokenId, address payable _recipient, uint256 _amount)\n        public\n        onlyNftOwner(_tokenId)\n        returns (uint256)\n    {\n        uint256 earnedFees = balances[_tokenId];\n\n        if (earnedFees == 0 || _amount == 0) revert NothingToWithdraw();\n        if (_amount > earnedFees) _amount = earnedFees;\n\n        balances[_tokenId] = earnedFees - _amount;\n\n        emit Withdraw(_tokenId, _recipient, _amount);\n\n        Address.sendValue(_recipient, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Distributes collected fees to the smart contract. Only callable by owner.\n    /// @param _tokenId NFT that earned fees\n    function distributeFees(uint256 _tokenId) public onlyOwner payable {\n        if (msg.value == 0) revert NothingToDistribute();\n\n        balances[_tokenId] += msg.value;\n        emit DistributeFees(_tokenId, msg.value);\n    }\n}"
    },
    {
      "filename": "CIP-001/src/Turnstile.sol",
      "content": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.8.17;\n\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"openzeppelin/utils/Counters.sol\";\n\n/// @notice Implementation of CIP-001 https://github.com/Canto-Improvement-Proposals/CIPs/blob/main/CIP-001.md\n/// @dev Every contract is responsible to register itself in the constructor by calling `register(address)`.\n///      If contract is using proxy pattern, it's possible to register retroactively, however past fees will be lost.\n///      Recipient withdraws fees by calling `withdraw(uint256,address,uint256)`.\ncontract Turnstile is Ownable, ERC721Enumerable {\n    using Counters for Counters.Counter;\n\n    struct NftData {\n        uint256 tokenId;\n        bool registered;\n    }\n\n    Counters.Counter private _tokenIdTracker;\n\n    /// @notice maps smart contract address to tokenId\n    mapping(address => NftData) public feeRecipient;\n\n    /// @notice maps tokenId to fees earned\n    mapping(uint256 => uint256) public balances;\n\n    event Register(address smartContract, address recipient, uint256 tokenId);\n    event Assign(address smartContract, uint256 tokenId);\n    event Withdraw(uint256 tokenId, address recipient, uint256 feeAmount);\n    event DistributeFees(uint256 tokenId, uint256 feeAmount);\n\n    error NotAnOwner();\n    error AlreadyRegistered();\n    error Unregistered();\n    error InvalidRecipient();\n    error InvalidTokenId();\n    error NothingToWithdraw();\n    error NothingToDistribute();\n\n    /// @dev only owner of _tokenId can call this function\n    modifier onlyNftOwner(uint256 _tokenId) {\n        if (ownerOf(_tokenId) != msg.sender) revert NotAnOwner();\n\n        _;\n    }\n\n    /// @dev only smart contract that is unregistered can call this function\n    modifier onlyUnregistered() {\n        address smartContract = msg.sender;\n\n        if (isRegistered(smartContract)) revert AlreadyRegistered();\n\n        _;\n    }\n\n    constructor() ERC721(\"Turnstile\", \"Turnstile\") {}\n\n    /// @notice Returns current value of counter used to tokenId of new minted NFTs\n    /// @return current counter value\n    function currentCounterId() external view returns (uint256) {\n        return _tokenIdTracker.current();\n    }\n\n    /// @notice Returns tokenId that collects fees generated by the smart contract\n    /// @param _smartContract address of the smart contract\n    /// @return tokenId that collects fees generated by the smart contract\n    function getTokenId(address _smartContract) external view returns (uint256) {\n        if (!isRegistered(_smartContract)) revert Unregistered();\n\n        return feeRecipient[_smartContract].tokenId;\n    }\n\n    /// @notice Returns true if smart contract is registered to collect fees\n    /// @param _smartContract address of the smart contract\n    /// @return true if smart contract is registered to collect fees, false otherwise\n    function isRegistered(address _smartContract) public view returns (bool) {\n        return feeRecipient[_smartContract].registered;\n    }\n\n    /// @notice Mints ownership NFT that allows the owner to collect fees earned by the smart contract.\n    ///         `msg.sender` is assumed to be a smart contract that earns fees. Only smart contract itself\n    ///         can register a fee receipient.\n    /// @param _recipient recipient of the ownership NFT\n    /// @return tokenId of the ownership NFT that collects fees\n    function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n        address smartContract = msg.sender;\n\n        if (_recipient == address(0)) revert InvalidRecipient();\n\n        tokenId = _tokenIdTracker.current();\n        _mint(_recipient, tokenId);\n        _tokenIdTracker.increment();\n\n        emit Register(smartContract, _recipient, tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: tokenId,\n            registered: true\n        });\n    }\n\n    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.\n    ///         Callable only by smart contract itself.\n    /// @param _tokenId tokenId which will collect fees\n    /// @return tokenId of the ownership NFT that collects fees\n    function assign(uint256 _tokenId) public onlyUnregistered returns (uint256) {\n        address smartContract = msg.sender;\n\n        if (!_exists(_tokenId)) revert InvalidTokenId();\n\n        emit Assign(smartContract, _tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: _tokenId,\n            registered: true\n        });\n\n        return _tokenId;\n    }\n\n    /// @notice Withdraws earned fees to `_recipient` address. Only callable by NFT owner.\n    /// @param _tokenId token Id\n    /// @param _recipient recipient of fees\n    /// @param _amount amount of fees to withdraw\n    /// @return amount of fees withdrawn\n    function withdraw(uint256 _tokenId, address payable _recipient, uint256 _amount)\n        public\n        onlyNftOwner(_tokenId)\n        returns (uint256)\n    {\n        uint256 earnedFees = balances[_tokenId];\n\n        if (earnedFees == 0 || _amount == 0) revert NothingToWithdraw();\n        if (_amount > earnedFees) _amount = earnedFees;\n\n        balances[_tokenId] = earnedFees - _amount;\n\n        emit Withdraw(_tokenId, _recipient, _amount);\n\n        Address.sendValue(_recipient, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Distributes collected fees to the smart contract. Only callable by owner.\n    /// @param _tokenId NFT that earned fees\n    function distributeFees(uint256 _tokenId) public onlyOwner payable {\n        if (msg.value == 0) revert NothingToDistribute();\n\n        balances[_tokenId] += msg.value;\n        emit DistributeFees(_tokenId, msg.value);\n    }\n}"
    },
    {
      "filename": "CIP-001/src/Turnstile.sol",
      "content": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.8.17;\n\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"openzeppelin/utils/Counters.sol\";\n\n/// @notice Implementation of CIP-001 https://github.com/Canto-Improvement-Proposals/CIPs/blob/main/CIP-001.md\n/// @dev Every contract is responsible to register itself in the constructor by calling `register(address)`.\n///      If contract is using proxy pattern, it's possible to register retroactively, however past fees will be lost.\n///      Recipient withdraws fees by calling `withdraw(uint256,address,uint256)`.\ncontract Turnstile is Ownable, ERC721Enumerable {\n    using Counters for Counters.Counter;\n\n    struct NftData {\n        uint256 tokenId;\n        bool registered;\n    }\n\n    Counters.Counter private _tokenIdTracker;\n\n    /// @notice maps smart contract address to tokenId\n    mapping(address => NftData) public feeRecipient;\n\n    /// @notice maps tokenId to fees earned\n    mapping(uint256 => uint256) public balances;\n\n    event Register(address smartContract, address recipient, uint256 tokenId);\n    event Assign(address smartContract, uint256 tokenId);\n    event Withdraw(uint256 tokenId, address recipient, uint256 feeAmount);\n    event DistributeFees(uint256 tokenId, uint256 feeAmount);\n\n    error NotAnOwner();\n    error AlreadyRegistered();\n    error Unregistered();\n    error InvalidRecipient();\n    error InvalidTokenId();\n    error NothingToWithdraw();\n    error NothingToDistribute();\n\n    /// @dev only owner of _tokenId can call this function\n    modifier onlyNftOwner(uint256 _tokenId) {\n        if (ownerOf(_tokenId) != msg.sender) revert NotAnOwner();\n\n        _;\n    }\n\n    /// @dev only smart contract that is unregistered can call this function\n    modifier onlyUnregistered() {\n        address smartContract = msg.sender;\n\n        if (isRegistered(smartContract)) revert AlreadyRegistered();\n\n        _;\n    }\n\n    constructor() ERC721(\"Turnstile\", \"Turnstile\") {}\n\n    /// @notice Returns current value of counter used to tokenId of new minted NFTs\n    /// @return current counter value\n    function currentCounterId() external view returns (uint256) {\n        return _tokenIdTracker.current();\n    }\n\n    /// @notice Returns tokenId that collects fees generated by the smart contract\n    /// @param _smartContract address of the smart contract\n    /// @return tokenId that collects fees generated by the smart contract\n    function getTokenId(address _smartContract) external view returns (uint256) {\n        if (!isRegistered(_smartContract)) revert Unregistered();\n\n        return feeRecipient[_smartContract].tokenId;\n    }\n\n    /// @notice Returns true if smart contract is registered to collect fees\n    /// @param _smartContract address of the smart contract\n    /// @return true if smart contract is registered to collect fees, false otherwise\n    function isRegistered(address _smartContract) public view returns (bool) {\n        return feeRecipient[_smartContract].registered;\n    }\n\n    /// @notice Mints ownership NFT that allows the owner to collect fees earned by the smart contract.\n    ///         `msg.sender` is assumed to be a smart contract that earns fees. Only smart contract itself\n    ///         can register a fee receipient.\n    /// @param _recipient recipient of the ownership NFT\n    /// @return tokenId of the ownership NFT that collects fees\n    function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n        address smartContract = msg.sender;\n\n        if (_recipient == address(0)) revert InvalidRecipient();\n\n        tokenId = _tokenIdTracker.current();\n        _mint(_recipient, tokenId);\n        _tokenIdTracker.increment();\n\n        emit Register(smartContract, _recipient, tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: tokenId,\n            registered: true\n        });\n    }\n\n    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.\n    ///         Callable only by smart contract itself.\n    /// @param _tokenId tokenId which will collect fees\n    /// @return tokenId of the ownership NFT that collects fees\n    function assign(uint256 _tokenId) public onlyUnregistered returns (uint256) {\n        address smartContract = msg.sender;\n\n        if (!_exists(_tokenId)) revert InvalidTokenId();\n\n        emit Assign(smartContract, _tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: _tokenId,\n            registered: true\n        });\n\n        return _tokenId;\n    }\n\n    /// @notice Withdraws earned fees to `_recipient` address. Only callable by NFT owner.\n    /// @param _tokenId token Id\n    /// @param _recipient recipient of fees\n    /// @param _amount amount of fees to withdraw\n    /// @return amount of fees withdrawn\n    function withdraw(uint256 _tokenId, address payable _recipient, uint256 _amount)\n        public\n        onlyNftOwner(_tokenId)\n        returns (uint256)\n    {\n        uint256 earnedFees = balances[_tokenId];\n\n        if (earnedFees == 0 || _amount == 0) revert NothingToWithdraw();\n        if (_amount > earnedFees) _amount = earnedFees;\n\n        balances[_tokenId] = earnedFees - _amount;\n\n        emit Withdraw(_tokenId, _recipient, _amount);\n\n        Address.sendValue(_recipient, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Distributes collected fees to the smart contract. Only callable by owner.\n    /// @param _tokenId NFT that earned fees\n    function distributeFees(uint256 _tokenId) public onlyOwner payable {\n        if (msg.value == 0) revert NothingToDistribute();\n\n        balances[_tokenId] += msg.value;\n        emit DistributeFees(_tokenId, msg.value);\n    }\n}"
    }
  ]
}