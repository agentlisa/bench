{
  "Title": "Incorrect policy fee",
  "Content": "There are two discrepancies when calculating a policy fee rate:\n\n\n* It is always [strictly higher](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/PolicyHelperV1.sol#L55-L57) than the configured floor.\n* The [amount of days charged](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/PolicyHelperV1.sol#L64) does not account for a non-standard [coverage lag period](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/PolicyHelperV1.sol#L259).\n\n\nConsider updating the calculation accordingly.\n\n\n**Update:** *Fixed as of commit `84a6fc3167adfb61b6f16666f0ba422b60bc0b2c` in [pull request #159](https://github.com/neptune-mutual-blue/protocol/pull/159) and commit `4b929c274100a981107e35d40fbf5b57fabc9be4` in [pull request #196](https://github.com/neptune-mutual-blue/protocol/pull/196). The Neptune team have chosen not to address the first bullet.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/PolicyHelperV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./ProtoUtilV1.sol\";\nimport \"./CoverUtilV1.sol\";\nimport \"./ValidationLibV1.sol\";\nimport \"./RoutineInvokerLibV1.sol\";\nimport \"../interfaces/ICxToken.sol\";\nimport \"../interfaces/IStore.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../libraries/NTransferUtilV2.sol\";\n\nlibrary PolicyHelperV1 {\n  using ProtoUtilV1 for IStore;\n  using RoutineInvokerLibV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using NTransferUtilV2 for IERC20;\n  using RegistryLibV1 for IStore;\n  using CoverUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n\n  uint256 public constant COVER_LAG_FALLBACK_VALUE = 1 days;\n\n  function calculatePolicyFeeInternal(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration,\n    uint256 amountToCover\n  )\n    public\n    view\n    returns (\n      uint256 fee,\n      uint256 utilizationRatio,\n      uint256 totalAvailableLiquidity,\n      uint256 floor,\n      uint256 ceiling,\n      uint256 rate\n    )\n  {\n    (floor, ceiling) = getPolicyRatesInternal(s, coverKey);\n    (uint256 availableLiquidity, uint256 commitment, uint256 reassuranceFund) = _getCoverPoolAmounts(s, coverKey, productKey);\n\n    require(amountToCover > 0, \"Please enter an amount\");\n    require(coverDuration > 0 && coverDuration <= ProtoUtilV1.MAX_POLICY_DURATION, \"Invalid duration\");\n    require(floor > 0 && ceiling > floor, \"Policy rate config error\");\n\n    require(availableLiquidity - commitment > amountToCover, \"Insufficient fund\");\n\n    totalAvailableLiquidity = availableLiquidity + reassuranceFund;\n    utilizationRatio = (ProtoUtilV1.MULTIPLIER * (commitment + amountToCover)) / totalAvailableLiquidity;\n\n    rate = utilizationRatio > floor ? utilizationRatio : floor;\n\n    rate = rate + (coverDuration * 100);\n\n    if (rate > ceiling) {\n      rate = ceiling;\n    }\n\n    uint256 expiryDate = CoverUtilV1.getExpiryDateInternal(block.timestamp, coverDuration); // solhint-disable-line\n    uint256 daysCovered = BokkyPooBahsDateTimeLibrary.diffDays(block.timestamp, expiryDate); // solhint-disable-line\n\n    fee = (amountToCover * rate * daysCovered) / (365 * ProtoUtilV1.MULTIPLIER);\n  }\n\n  function getPolicyFeeInternal(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration,\n    uint256 amountToCover\n  ) public view returns (uint256 fee, uint256 platformFee) {\n    (fee, , , , , ) = calculatePolicyFeeInternal(s, coverKey, productKey, coverDuration, amountToCover);\n\n    uint256 rate = s.getUintByKey(ProtoUtilV1.NS_COVER_PLATFORM_FEE);\n    platformFee = (fee * rate) / ProtoUtilV1.MULTIPLIER;\n  }\n\n  function _getCoverPoolAmounts(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  )\n    private\n    view\n    returns (\n      uint256 availableLiquidity,\n      uint256 commitment,\n      uint256 reassuranceFund\n    )\n  {\n    uint256[] memory values = s.getCoverPoolSummaryInternal(coverKey, productKey);\n\n    /*\n     * values[0] stablecoinOwnedByVault --> The total amount in the cover pool\n     * values[1] commitment --> The total commitment amount\n     * values[2] reassurance\n     * values[3] reassurancePoolWeight\n     * values[4] count --> Count of products under this cover\n     * values[5] leverage\n     * values[6] efficiency --> Cover product efficiency weight\n     */\n\n    availableLiquidity = values[0];\n    commitment = values[1];\n\n    // (reassurance * reassurancePoolWeight) / multiplier\n    reassuranceFund = (values[2] * values[3]) / ProtoUtilV1.MULTIPLIER;\n\n    if (s.supportsProductsInternal(coverKey)) {\n      require(values[4] > 0, \"Misconfigured or retired product\");\n\n      // (stablecoinOwnedByVault * leverage * efficiency) / (count * multiplier)\n      availableLiquidity = (values[0] * values[5] * values[6]) / (values[4] * ProtoUtilV1.MULTIPLIER);\n    }\n  }\n\n  function getPolicyRatesInternal(IStore s, bytes32 coverKey) public view returns (uint256 floor, uint256 ceiling) {\n    if (coverKey > 0) {\n      floor = s.getUintByKeys(ProtoUtilV1.NS_COVER_POLICY_RATE_FLOOR, coverKey);\n      ceiling = s.getUintByKeys(ProtoUtilV1.NS_COVER_POLICY_RATE_CEILING, coverKey);\n    }\n\n    if (floor == 0) {\n      // Fallback to default values\n      floor = s.getUintByKey(ProtoUtilV1.NS_COVER_POLICY_RATE_FLOOR);\n      ceiling = s.getUintByKey(ProtoUtilV1.NS_COVER_POLICY_RATE_CEILING);\n    }\n  }\n\n  function getCxTokenInternal(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration\n  ) public view returns (address cxToken, uint256 expiryDate) {\n    expiryDate = CoverUtilV1.getExpiryDateInternal(block.timestamp, coverDuration); // solhint-disable-line\n    bytes32 k = keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_CXTOKEN, coverKey, productKey, expiryDate));\n\n    cxToken = s.getAddress(k);\n  }\n\n  /**\n   * @dev Gets the instance of cxToken or deploys a new one based on the cover expiry timestamp\n   * @param coverKey Enter the cover key\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\n   */\n  function getCxTokenOrDeployInternal(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration\n  ) public returns (ICxToken) {\n    (address cxToken, uint256 expiryDate) = getCxTokenInternal(s, coverKey, productKey, coverDuration);\n\n    if (cxToken != address(0)) {\n      return ICxToken(cxToken);\n    }\n\n    ICxTokenFactory factory = s.getCxTokenFactory();\n    cxToken = factory.deploy(coverKey, productKey, _getCxTokenName(coverKey, productKey, expiryDate), expiryDate);\n\n    // @warning: Do not uncomment the following line\n    // Reason: cxTokens are no longer protocol members\n    // as we will end up with way too many contracts\n    // s.getProtocol().addMember(cxToken);\n    return ICxToken(cxToken);\n  }\n\n  /**\n   * @dev Returns month name of a given date\n   */\n  function _getMonthName(uint256 date) private pure returns (bytes3) {\n    bytes3[13] memory m = [bytes3(0), \"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"];\n    uint256 month = BokkyPooBahsDateTimeLibrary.getMonth(date);\n\n    return m[month];\n  }\n\n  /**\n   * @dev Returns cxToken name from the supplied inputs.\n   *\n   * Format:\n   *\n   * For basket cover pool product\n   * --> cxusd:dex:uni:nov (cxUSD)\n   *\n   * For standalone cover pool\n   * --> cxusd:bal:nov (cxUSD)\n   */\n  function _getCxTokenName(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 expiry\n  ) private pure returns (string memory) {\n    bytes3 month = _getMonthName(expiry);\n\n    if (productKey > 0) {\n      return string(abi.encodePacked(\"cxusd:\", string(abi.encodePacked(coverKey)), \":\", string(abi.encodePacked(productKey)), \":\", string(abi.encodePacked(month))));\n    }\n\n    return string(abi.encodePacked(\"cxusd:\", string(abi.encodePacked(coverKey)), \":\", string(abi.encodePacked(month))));\n  }\n\n  /**\n   *\n   * @dev Purchase cover for the specified amount. <br /> <br />\n   * When you purchase covers, you receive equal amount of cxTokens back.\n   * You need the cxTokens to claim the cover when resolution occurs.\n   * Each unit of cxTokens are fully redeemable at 1:1 ratio to the given\n   * stablecoins (like wxDai, DAI, USDC, or BUSD) based on the chain.\n   *\n   * @custom:suppress-malicious-erc The ERC-20 `stablecoin` can't be manipulated via user input.\n   *\n   * @param onBehalfOf Enter the address where the claim tokens (cxTokens) should be sent.\n   * @param coverKey Enter the cover key you wish to purchase the policy for\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\n   * @param amountToCover Enter the amount of the stablecoin to cover.\n   *\n   */\n  function purchaseCoverInternal(\n    IStore s,\n    address onBehalfOf,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration,\n    uint256 amountToCover\n  )\n    external\n    returns (\n      ICxToken cxToken,\n      uint256 fee,\n      uint256 platformFee\n    )\n  {\n    (fee, platformFee) = getPolicyFeeInternal(s, coverKey, productKey, coverDuration, amountToCover);\n    require(fee > 0, \"Insufficient fee\");\n    require(platformFee > 0, \"Insufficient platform fee\");\n\n    address stablecoin = s.getStablecoin();\n    require(stablecoin != address(0), \"Cover liquidity uninitialized\");\n\n    IERC20(stablecoin).ensureTransferFrom(msg.sender, address(this), fee);\n    IERC20(stablecoin).ensureTransfer(s.getVaultAddress(coverKey), fee - platformFee);\n    IERC20(stablecoin).ensureTransfer(s.getTreasury(), platformFee);\n\n    uint256 stablecoinPrecision = s.getStablecoinPrecision();\n    uint256 toMint = (amountToCover * ProtoUtilV1.CXTOKEN_PRECISION) / stablecoinPrecision;\n\n    cxToken = getCxTokenOrDeployInternal(s, coverKey, productKey, coverDuration);\n    cxToken.mint(coverKey, productKey, onBehalfOf, toMint);\n\n    s.updateStateAndLiquidity(coverKey);\n  }\n\n  function getCoverageLagInternal(IStore s, bytes32 coverKey) external view returns (uint256) {\n    uint256 custom = s.getUintByKeys(ProtoUtilV1.NS_COVERAGE_LAG, coverKey);\n\n    // Custom means set for this exact cover\n    if (custom > 0) {\n      return custom;\n    }\n\n    // Global means set for all covers (without specifying a cover key)\n    uint256 global = s.getUintByKey(ProtoUtilV1.NS_COVERAGE_LAG);\n\n    if (global > 0) {\n      return global;\n    }\n\n    // Fallback means the default option\n    return COVER_LAG_FALLBACK_VALUE;\n  }\n}"
    },
    {
      "filename": "contracts/libraries/PolicyHelperV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./ProtoUtilV1.sol\";\nimport \"./CoverUtilV1.sol\";\nimport \"./ValidationLibV1.sol\";\nimport \"./RoutineInvokerLibV1.sol\";\nimport \"../interfaces/ICxToken.sol\";\nimport \"../interfaces/IStore.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../libraries/NTransferUtilV2.sol\";\n\nlibrary PolicyHelperV1 {\n  using ProtoUtilV1 for IStore;\n  using RoutineInvokerLibV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using NTransferUtilV2 for IERC20;\n  using RegistryLibV1 for IStore;\n  using CoverUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n\n  uint256 public constant COVER_LAG_FALLBACK_VALUE = 1 days;\n\n  function calculatePolicyFeeInternal(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration,\n    uint256 amountToCover\n  )\n    public\n    view\n    returns (\n      uint256 fee,\n      uint256 utilizationRatio,\n      uint256 totalAvailableLiquidity,\n      uint256 floor,\n      uint256 ceiling,\n      uint256 rate\n    )\n  {\n    (floor, ceiling) = getPolicyRatesInternal(s, coverKey);\n    (uint256 availableLiquidity, uint256 commitment, uint256 reassuranceFund) = _getCoverPoolAmounts(s, coverKey, productKey);\n\n    require(amountToCover > 0, \"Please enter an amount\");\n    require(coverDuration > 0 && coverDuration <= ProtoUtilV1.MAX_POLICY_DURATION, \"Invalid duration\");\n    require(floor > 0 && ceiling > floor, \"Policy rate config error\");\n\n    require(availableLiquidity - commitment > amountToCover, \"Insufficient fund\");\n\n    totalAvailableLiquidity = availableLiquidity + reassuranceFund;\n    utilizationRatio = (ProtoUtilV1.MULTIPLIER * (commitment + amountToCover)) / totalAvailableLiquidity;\n\n    rate = utilizationRatio > floor ? utilizationRatio : floor;\n\n    rate = rate + (coverDuration * 100);\n\n    if (rate > ceiling) {\n      rate = ceiling;\n    }\n\n    uint256 expiryDate = CoverUtilV1.getExpiryDateInternal(block.timestamp, coverDuration); // solhint-disable-line\n    uint256 daysCovered = BokkyPooBahsDateTimeLibrary.diffDays(block.timestamp, expiryDate); // solhint-disable-line\n\n    fee = (amountToCover * rate * daysCovered) / (365 * ProtoUtilV1.MULTIPLIER);\n  }\n\n  function getPolicyFeeInternal(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration,\n    uint256 amountToCover\n  ) public view returns (uint256 fee, uint256 platformFee) {\n    (fee, , , , , ) = calculatePolicyFeeInternal(s, coverKey, productKey, coverDuration, amountToCover);\n\n    uint256 rate = s.getUintByKey(ProtoUtilV1.NS_COVER_PLATFORM_FEE);\n    platformFee = (fee * rate) / ProtoUtilV1.MULTIPLIER;\n  }\n\n  function _getCoverPoolAmounts(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  )\n    private\n    view\n    returns (\n      uint256 availableLiquidity,\n      uint256 commitment,\n      uint256 reassuranceFund\n    )\n  {\n    uint256[] memory values = s.getCoverPoolSummaryInternal(coverKey, productKey);\n\n    /*\n     * values[0] stablecoinOwnedByVault --> The total amount in the cover pool\n     * values[1] commitment --> The total commitment amount\n     * values[2] reassurance\n     * values[3] reassurancePoolWeight\n     * values[4] count --> Count of products under this cover\n     * values[5] leverage\n     * values[6] efficiency --> Cover product efficiency weight\n     */\n\n    availableLiquidity = values[0];\n    commitment = values[1];\n\n    // (reassurance * reassurancePoolWeight) / multiplier\n    reassuranceFund = (values[2] * values[3]) / ProtoUtilV1.MULTIPLIER;\n\n    if (s.supportsProductsInternal(coverKey)) {\n      require(values[4] > 0, \"Misconfigured or retired product\");\n\n      // (stablecoinOwnedByVault * leverage * efficiency) / (count * multiplier)\n      availableLiquidity = (values[0] * values[5] * values[6]) / (values[4] * ProtoUtilV1.MULTIPLIER);\n    }\n  }\n\n  function getPolicyRatesInternal(IStore s, bytes32 coverKey) public view returns (uint256 floor, uint256 ceiling) {\n    if (coverKey > 0) {\n      floor = s.getUintByKeys(ProtoUtilV1.NS_COVER_POLICY_RATE_FLOOR, coverKey);\n      ceiling = s.getUintByKeys(ProtoUtilV1.NS_COVER_POLICY_RATE_CEILING, coverKey);\n    }\n\n    if (floor == 0) {\n      // Fallback to default values\n      floor = s.getUintByKey(ProtoUtilV1.NS_COVER_POLICY_RATE_FLOOR);\n      ceiling = s.getUintByKey(ProtoUtilV1.NS_COVER_POLICY_RATE_CEILING);\n    }\n  }\n\n  function getCxTokenInternal(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration\n  ) public view returns (address cxToken, uint256 expiryDate) {\n    expiryDate = CoverUtilV1.getExpiryDateInternal(block.timestamp, coverDuration); // solhint-disable-line\n    bytes32 k = keccak256(abi.encodePacked(ProtoUtilV1.NS_COVER_CXTOKEN, coverKey, productKey, expiryDate));\n\n    cxToken = s.getAddress(k);\n  }\n\n  /**\n   * @dev Gets the instance of cxToken or deploys a new one based on the cover expiry timestamp\n   * @param coverKey Enter the cover key\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\n   */\n  function getCxTokenOrDeployInternal(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration\n  ) public returns (ICxToken) {\n    (address cxToken, uint256 expiryDate) = getCxTokenInternal(s, coverKey, productKey, coverDuration);\n\n    if (cxToken != address(0)) {\n      return ICxToken(cxToken);\n    }\n\n    ICxTokenFactory factory = s.getCxTokenFactory();\n    cxToken = factory.deploy(coverKey, productKey, _getCxTokenName(coverKey, productKey, expiryDate), expiryDate);\n\n    // @warning: Do not uncomment the following line\n    // Reason: cxTokens are no longer protocol members\n    // as we will end up with way too many contracts\n    // s.getProtocol().addMember(cxToken);\n    return ICxToken(cxToken);\n  }\n\n  /**\n   * @dev Returns month name of a given date\n   */\n  function _getMonthName(uint256 date) private pure returns (bytes3) {\n    bytes3[13] memory m = [bytes3(0), \"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"];\n    uint256 month = BokkyPooBahsDateTimeLibrary.getMonth(date);\n\n    return m[month];\n  }\n\n  /**\n   * @dev Returns cxToken name from the supplied inputs.\n   *\n   * Format:\n   *\n   * For basket cover pool product\n   * --> cxusd:dex:uni:nov (cxUSD)\n   *\n   * For standalone cover pool\n   * --> cxusd:bal:nov (cxUSD)\n   */\n  function _getCxTokenName(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 expiry\n  ) private pure returns (string memory) {\n    bytes3 month = _getMonthName(expiry);\n\n    if (productKey > 0) {\n      return string(abi.encodePacked(\"cxusd:\", string(abi.encodePacked(coverKey)), \":\", string(abi.encodePacked(productKey)), \":\", string(abi.encodePacked(month))));\n    }\n\n    return string(abi.encodePacked(\"cxusd:\", string(abi.encodePacked(coverKey)), \":\", string(abi.encodePacked(month))));\n  }\n\n  /**\n   *\n   * @dev Purchase cover for the specified amount. <br /> <br />\n   * When you purchase covers, you receive equal amount of cxTokens back.\n   * You need the cxTokens to claim the cover when resolution occurs.\n   * Each unit of cxTokens are fully redeemable at 1:1 ratio to the given\n   * stablecoins (like wxDai, DAI, USDC, or BUSD) based on the chain.\n   *\n   * @custom:suppress-malicious-erc The ERC-20 `stablecoin` can't be manipulated via user input.\n   *\n   * @param onBehalfOf Enter the address where the claim tokens (cxTokens) should be sent.\n   * @param coverKey Enter the cover key you wish to purchase the policy for\n   * @param coverDuration Enter the number of months to cover. Accepted values: 1-3.\n   * @param amountToCover Enter the amount of the stablecoin to cover.\n   *\n   */\n  function purchaseCoverInternal(\n    IStore s,\n    address onBehalfOf,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 coverDuration,\n    uint256 amountToCover\n  )\n    external\n    returns (\n      ICxToken cxToken,\n      uint256 fee,\n      uint256 platformFee\n    )\n  {\n    (fee, platformFee) = getPolicyFeeInternal(s, coverKey, productKey, coverDuration, amountToCover);\n    require(fee > 0, \"Insufficient fee\");\n    require(platformFee > 0, \"Insufficient platform fee\");\n\n    address stablecoin = s.getStablecoin();\n    require(stablecoin != address(0), \"Cover liquidity uninitialized\");\n\n    IERC20(stablecoin).ensureTransferFrom(msg.sender, address(this), fee);\n    IERC20(stablecoin).ensureTransfer(s.getVaultAddress(coverKey), fee - platformFee);\n    IERC20(stablecoin).ensureTransfer(s.getTreasury(), platformFee);\n\n    uint256 stablecoinPrecision = s.getStablecoinPrecision();\n    uint256 toMint = (amountToCover * ProtoUtilV1.CXTOKEN_PRECISION) / stablecoinPrecision;\n\n    cxToken = getCxTokenOrDeployInternal(s, coverKey, productKey, coverDuration);\n    cxToken.mint(coverKey, productKey, onBehalfOf, toMint);\n\n    s.updateStateAndLiquidity(coverKey);\n  }\n\n  function getCoverageLagInternal(IStore s, bytes32 coverKey) external view returns (uint256) {\n    uint256 custom = s.getUintByKeys(ProtoUtilV1.NS_COVERAGE_LAG, coverKey);\n\n    // Custom means set for this exact cover\n    if (custom > 0) {\n      return custom;\n    }\n\n    // Global means set for all covers (without specifying a cover key)\n    uint256 global = s.getUintByKey(ProtoUtilV1.NS_COVERAGE_LAG);\n\n    if (global > 0) {\n      return global;\n    }\n\n    // Fallback means the default option\n    return COVER_LAG_FALLBACK_VALUE;\n  }\n}"
    }
  ]
}