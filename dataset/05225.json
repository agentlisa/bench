{
  "Title": "[M-04] Potential loss of capital due to fixed fee calculations",
  "Content": "\nThe `StargateBridgeAdapter` relies on a fixed fee calculation (0.06% of the current Stargate fee), but as explained in the Stargate documentation, fees can be automatically adjusted to meet demand. ([here](https://stargateprotocol.gitbook.io/stargate/v/user-docs/tokenomics/protocol-fees))\n\nThis reward can be adjusted ([StargateFeeLibraryV02.sol#L68](https://github.com/stargate-protocol/stargate/blob/c647a3a647fc693c38b16ef023c54e518b46e206/contracts/libraries/StargateFeeLibraryV02.sol#L68)) to “To incentivize users to conduct swaps that ‘refill’ native asset balances”.\nA problem arises because the `StargateBridgeAdapter` doesn't account for this variable fee.\n\nThen the callback function (triggered on the target chain) will receive a token amount greater than `amountIn`. [StargateBridgeAdapter.sol#L207](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/bridge_adapters/StargateBridgeAdapter.sol#L207)\n\n```solidity\nIERC20(swapParams.tokenIn).approve(utb, swapParams.amountIn);\n```\n\nAs you can see, here the difference between the received amount [StargateBridgeAdapter.sol#L188](https://github.com/code-423n4/2024-01-decent/blob/011f62059f3a0b1f3577c8ccd1140f0cf3e7bb29/src/bridge_adapters/StargateBridgeAdapter.sol#L188) and `swapParams.amountIn` gets lost in the adapter.\n\n### Recommended Mitigation Steps\n\nIt’s recommended approve the `amountLD` instead of the `swapParams.amountIn` . This way, all token received during the callback will be transfered.\n\n<Details>\n\n```solidity\nfunction sgReceive(\n    uint16, // _srcChainid\n    bytes memory, // _srcAddress\n    uint256, // _nonce\n-  \taddress, // _token\n-   uint256, // amountLD\n+   address _token,\n+   uint256 amountLD,\n    bytes memory payload\n) external override onlyExecutor {\n    (\n        SwapInstructions memory postBridge,\n        address target,\n        address paymentOperator,\n        bytes memory utbPayload,\n        address payable refund\n    ) = abi.decode(\n            payload,\n            (SwapInstructions, address, address, bytes, address)\n        );\n\n    SwapParams memory swapParams = abi.decode(\n        postBridge.swapPayload,\n        (SwapParams)\n    );\n- IERC20(swapParams.tokenIn).approve(utb, swapParams.amountIn);\n+ IERC20(_token).approve(utb, amountLD); // _token == swapParams.tokenIn\n\n+ swapParams.amountIn = amountLD // swapParams also needs to be updated to swap the correct amount\n+ postBridge.swapPayload = abi.encode(swapParams);\n\n    IUTB(utb).receiveFromBridge(\n        postBridge,\n        target,\n        paymentOperator,\n        utbPayload,\n        refund\n    );\n}\n```\n\n</details>\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "contracts/libraries/StargateFeeLibraryV02.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IStargateFeeLibrary.sol\";\nimport \"../Pool.sol\";\nimport \"../Factory.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract StargateFeeLibraryV02 is IStargateFeeLibrary, Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //---------------------------------------------------------------------------\n    // VARIABLES\n\n    // equilibrium func params. all in BPs * 10 ^ 2, i.e. 1 % = 10 ^ 6 units\n    uint256 public constant DENOMINATOR = 1e18;\n    uint256 public constant DELTA_1 = 6000 * 1e14;\n    uint256 public constant DELTA_2 = 500 * 1e14;\n    uint256 public constant LAMBDA_1 = 40 * 1e14;\n    uint256 public constant LAMBDA_2 = 9960 * 1e14;\n    uint256 public constant LP_FEE = 45 * 1e13;\n    uint256 public constant PROTOCOL_FEE = 15 * 1e13;\n    uint256 public constant PROTOCOL_SUBSIDY = 3 * 1e13;\n\n    Factory public immutable factory;\n\n    constructor(address _factory) {\n        require(_factory != address(0x0), \"FeeLibrary: Factory cannot be 0x0\");\n        factory = Factory(_factory);\n    }\n\n    function getFees(\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint16 _dstChainId,\n        address, /*_from*/\n        uint256 _amountSD\n    ) external view override returns (Pool.SwapObj memory s) {\n        // calculate the protocol fee\n        s.protocolFee = _amountSD.mul(PROTOCOL_FEE).div(DENOMINATOR);\n\n        // calculate the equilibrium Fee\n        Pool pool = factory.getPool(_srcPoolId);\n        Pool.ChainPath memory chainPath = pool.getChainPath(_dstChainId, _dstPoolId);\n\n        // calculate the equilibrium fee\n        (uint256 eqFee, uint256 protocolSubsidy) = _getEquilibriumFee(chainPath.idealBalance, chainPath.balance, _amountSD);\n        s.eqFee = eqFee;\n        s.protocolFee = s.protocolFee.sub(protocolSubsidy);\n\n        // calculate the equilibrium reward\n        address tokenAddress = pool.token();\n        uint256 currentAssetSD = IERC20(tokenAddress).balanceOf(address(pool)).div(pool.convertRate());\n        uint256 lpAsset = pool.totalLiquidity();\n        if (lpAsset > currentAssetSD) {\n            // in deficit\n            uint256 poolDeficit = lpAsset.sub(currentAssetSD);\n            uint256 rewardPoolSize = pool.eqFeePool();\n            // reward capped at rewardPoolSize\n            uint256 eqRewards = rewardPoolSize.mul(_amountSD).div(poolDeficit);\n            if (eqRewards > rewardPoolSize) {\n                eqRewards = rewardPoolSize;\n            }\n            s.eqReward = eqRewards;\n        }\n\n        // calculate the LP fee.\n        s.lpFee = _amountSD.mul(LP_FEE).div(DENOMINATOR);\n\n        return s;\n    }\n\n    function getEquilibriumFee(\n        uint256 idealBalance,\n        uint256 beforeBalance,\n        uint256 amountSD\n    ) external pure returns (uint256, uint256) {\n        return _getEquilibriumFee(idealBalance, beforeBalance, amountSD);\n    }\n\n    function getTrapezoidArea(\n        uint256 lambda,\n        uint256 yOffset,\n        uint256 xUpperBound,\n        uint256 xLowerBound,\n        uint256 xStart,\n        uint256 xEnd\n    ) external pure returns (uint256) {\n        return _getTrapezoidArea(lambda, yOffset, xUpperBound, xLowerBound, xStart, xEnd);\n    }\n\n    function _getEquilibriumFee(\n        uint256 idealBalance,\n        uint256 beforeBalance,\n        uint256 amountSD\n    ) internal pure returns (uint256, uint256) {\n        require(beforeBalance >= amountSD, \"Stargate: not enough balance\");\n        uint256 afterBalance = beforeBalance.sub(amountSD);\n\n        uint256 safeZoneMax = idealBalance.mul(DELTA_1).div(DENOMINATOR);\n        uint256 safeZoneMin = idealBalance.mul(DELTA_2).div(DENOMINATOR);\n\n        uint256 eqFee = 0;\n        uint256 protocolSubsidy = 0;\n\n        if (afterBalance >= safeZoneMax) {\n            // no fee zone, protocol subsidize it.\n            eqFee = amountSD.mul(PROTOCOL_SUBSIDY).div(DENOMINATOR);\n            protocolSubsidy = eqFee;\n        } else if (afterBalance >= safeZoneMin) {\n            // safe zone\n            uint256 proxyBeforeBalance = beforeBalance < safeZoneMax ? beforeBalance : safeZoneMax;\n            eqFee = _getTrapezoidArea(LAMBDA_1, 0, safeZoneMax, safeZoneMin, proxyBeforeBalance, afterBalance);\n        } else {\n            // danger zone\n            if (beforeBalance >= safeZoneMin) {\n                // across 2 or 3 zones\n                // part 1\n                uint256 proxyBeforeBalance = beforeBalance < safeZoneMax ? beforeBalance : safeZoneMax;\n                eqFee = eqFee.add(_getTrapezoidArea(LAMBDA_1, 0, safeZoneMax, safeZoneMin, proxyBeforeBalance, safeZoneMin));\n                // part 2\n                eqFee = eqFee.add(_getTrapezoidArea(LAMBDA_2, LAMBDA_1, safeZoneMin, 0, safeZoneMin, afterBalance));\n            } else {\n                // only in danger zone\n                // part 2 only\n                eqFee = eqFee.add(_getTrapezoidArea(LAMBDA_2, LAMBDA_1, safeZoneMin, 0, beforeBalance, afterBalance));\n            }\n        }\n        return (eqFee, protocolSubsidy);\n    }\n\n    function _getTrapezoidArea(\n        uint256 lambda,\n        uint256 yOffset,\n        uint256 xUpperBound,\n        uint256 xLowerBound,\n        uint256 xStart,\n        uint256 xEnd\n    ) internal pure returns (uint256) {\n        require(xEnd >= xLowerBound && xStart <= xUpperBound, \"Stargate: balance out of bound\");\n        uint256 xBoundWidth = xUpperBound.sub(xLowerBound);\n\n        // xStartDrift = xUpperBound.sub(xStart);\n        uint256 yStart = xUpperBound.sub(xStart).mul(lambda).div(xBoundWidth).add(yOffset);\n\n        // xEndDrift = xUpperBound.sub(xEnd)\n        uint256 yEnd = xUpperBound.sub(xEnd).mul(lambda).div(xBoundWidth).add(yOffset);\n\n        // compute the area\n        uint256 deltaX = xStart.sub(xEnd);\n        return yStart.add(yEnd).mul(deltaX).div(2).div(DENOMINATOR);\n    }\n\n    function getVersion() external pure override returns (string memory) {\n        return \"2.0.0\";\n    }\n}"
    },
    {
      "filename": "src/bridge_adapters/StargateBridgeAdapter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {UTBOwned} from \"../UTBOwned.sol\";\nimport {IUTB} from \"../interfaces/IUTB.sol\";\nimport {IBridgeAdapter} from \"../interfaces/IBridgeAdapter.sol\";\nimport {SwapInstructions} from \"../CommonTypes.sol\";\nimport {SwapParams} from \"../swappers/SwapParams.sol\";\nimport {IStargateRouter, LzBridgeData} from \"./stargate/IStargateRouter.sol\";\nimport {IStargateReceiver} from \"./stargate/IStargateReceiver.sol\";\nimport {BaseAdapter} from \"./BaseAdapter.sol\";\n\n// pool ids: https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n// chain ids: https://stargateprotocol.gitbook.io/stargate/developers/chain-ids\n\ncontract StargateBridgeAdapter is\n    BaseAdapter,\n    IBridgeAdapter,\n    IStargateReceiver\n{\n    uint8 public constant BRIDGE_ID = 1;\n    uint8 public constant SG_FEE_BPS = 6;\n    address public stargateEth;\n    mapping(uint256 => address) public destinationBridgeAdapter;\n    mapping(uint256 => uint16) lzIdLookup;\n    mapping(uint16 => uint256) chainIdLookup;\n\n    constructor() BaseAdapter() {}\n\n    IStargateRouter public router;\n\n    function setRouter(address _router) public onlyOwner {\n        router = IStargateRouter(_router);\n    }\n\n    function setStargateEth(address _sgEth) public onlyOwner {\n        stargateEth = _sgEth;\n    }\n\n    function getId() public pure returns (uint8) {\n        return BRIDGE_ID;\n    }\n\n    function registerRemoteBridgeAdapter(\n        uint256 dstChainId,\n        uint16 dstLzId,\n        address decentBridgeAdapter\n    ) public onlyOwner {\n        lzIdLookup[dstChainId] = dstLzId;\n        chainIdLookup[dstLzId] = dstChainId;\n        destinationBridgeAdapter[dstChainId] = decentBridgeAdapter;\n    }\n\n    function getBridgeToken(\n        bytes calldata additionalArgs\n    ) external pure returns (address bridgeToken) {\n        bridgeToken = abi.decode(additionalArgs, (address));\n    }\n\n    function getBridgedAmount(\n        uint256 amt2Bridge,\n        address /*tokenIn*/,\n        address /*tokenOut*/\n    ) external pure returns (uint256) {\n        return (amt2Bridge * (1e4 - SG_FEE_BPS)) / 1e4;\n    }\n\n    function bridge(\n        uint256 amt2Bridge,\n        SwapInstructions memory postBridge,\n        uint256 dstChainId,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        bytes calldata additionalArgs,\n        address payable refund\n    ) public payable onlyUtb returns (bytes memory bridgePayload) {\n        address bridgeToken = abi.decode(additionalArgs, (address));\n\n        bridgePayload = abi.encode(\n            postBridge,\n            target,\n            paymentOperator,\n            payload,\n            refund\n        );\n        IERC20(bridgeToken).transferFrom(msg.sender, address(this), amt2Bridge);\n        IERC20(bridgeToken).approve(address(router), amt2Bridge);\n\n        callBridge(\n            amt2Bridge,\n            dstChainId,\n            bridgePayload,\n            additionalArgs,\n            refund\n        );\n    }\n\n    function getValue(\n        bytes calldata additionalArgs,\n        uint256 amt2Bridge\n    ) private view returns (uint value) {\n        (address bridgeToken, LzBridgeData memory lzBridgeData) = abi.decode(\n            additionalArgs,\n            (address, LzBridgeData)\n        );\n        return\n            bridgeToken == stargateEth\n                ? (lzBridgeData.fee + amt2Bridge)\n                : lzBridgeData.fee;\n    }\n\n    function getLzTxObj(\n        bytes calldata additionalArgs\n    ) private pure returns (IStargateRouter.lzTxObj memory) {\n        (, , IStargateRouter.lzTxObj memory lzTxObj) = abi.decode(\n            additionalArgs,\n            (address, LzBridgeData, IStargateRouter.lzTxObj)\n        );\n        return lzTxObj;\n    }\n\n    function getDstChainId(\n        bytes calldata additionalArgs\n    ) private pure returns (uint16) {\n        (, LzBridgeData memory lzBridgeData, ) = abi.decode(\n            additionalArgs,\n            (address, LzBridgeData, IStargateRouter.lzTxObj)\n        );\n        return lzBridgeData._dstChainId;\n    }\n\n    function getSrcPoolId(\n        bytes calldata additionalArgs\n    ) private pure returns (uint120) {\n        (, LzBridgeData memory lzBridgeData, ) = abi.decode(\n            additionalArgs,\n            (address, LzBridgeData, IStargateRouter.lzTxObj)\n        );\n        return lzBridgeData._srcPoolId;\n    }\n\n    function getDstPoolId(\n        bytes calldata additionalArgs\n    ) private pure returns (uint120) {\n        (, LzBridgeData memory lzBridgeData, ) = abi.decode(\n            additionalArgs,\n            (address, LzBridgeData, IStargateRouter.lzTxObj)\n        );\n        return lzBridgeData._dstPoolId;\n    }\n\n    function getDestAdapter(uint chainId) private view returns (address dstAddr) {\n        dstAddr = destinationBridgeAdapter[chainId];\n\n        require(\n            dstAddr != address(0),\n            string.concat(\"dst chain address not set \")\n        );\n    }\n\n    function callBridge(\n        uint256 amt2Bridge,\n        uint256 dstChainId,\n        bytes memory bridgePayload,\n        bytes calldata additionalArgs,\n        address payable refund\n    ) private {\n        router.swap{value: msg.value}(\n            getDstChainId(additionalArgs), //lzBridgeData._dstChainId, // send to LayerZero chainId\n            getSrcPoolId(additionalArgs), //lzBridgeData._srcPoolId, // source pool id\n            getDstPoolId(additionalArgs), //lzBridgeData._dstPoolId, // dst pool id\n            refund, // refund adddress. extra gas (if any) is returned to this address\n            amt2Bridge, // quantity to swap\n            (amt2Bridge * (10000 - SG_FEE_BPS)) / 10000, // the min qty you would accept on the destination, fee is 6 bips\n            getLzTxObj(additionalArgs), // additional gasLimit increase, airdrop, at address\n            abi.encodePacked(getDestAdapter(dstChainId)),\n            bridgePayload // bytes param, if you wish to send additional payload you can abi.encode() them here\n        );\n    }\n\n    function sgReceive(\n        uint16, // _srcChainid\n        bytes memory, // _srcAddress\n        uint256, // _nonce\n        address, // _token\n        uint256, // amountLD\n        bytes memory payload\n    ) external override onlyExecutor {\n        (\n            SwapInstructions memory postBridge,\n            address target,\n            address paymentOperator,\n            bytes memory utbPayload,\n            address payable refund\n        ) = abi.decode(\n                payload,\n                (SwapInstructions, address, address, bytes, address)\n            );\n\n        SwapParams memory swapParams = abi.decode(\n            postBridge.swapPayload,\n            (SwapParams)\n        );\n\n        IERC20(swapParams.tokenIn).approve(utb, swapParams.amountIn);\n\n        IUTB(utb).receiveFromBridge(\n            postBridge,\n            target,\n            paymentOperator,\n            utbPayload,\n            refund\n        );\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/bridge_adapters/StargateBridgeAdapter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {UTBOwned} from \"../UTBOwned.sol\";\nimport {IUTB} from \"../interfaces/IUTB.sol\";\nimport {IBridgeAdapter} from \"../interfaces/IBridgeAdapter.sol\";\nimport {SwapInstructions} from \"../CommonTypes.sol\";\nimport {SwapParams} from \"../swappers/SwapParams.sol\";\nimport {IStargateRouter, LzBridgeData} from \"./stargate/IStargateRouter.sol\";\nimport {IStargateReceiver} from \"./stargate/IStargateReceiver.sol\";\nimport {BaseAdapter} from \"./BaseAdapter.sol\";\n\n// pool ids: https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n// chain ids: https://stargateprotocol.gitbook.io/stargate/developers/chain-ids\n\ncontract StargateBridgeAdapter is\n    BaseAdapter,\n    IBridgeAdapter,\n    IStargateReceiver\n{\n    uint8 public constant BRIDGE_ID = 1;\n    uint8 public constant SG_FEE_BPS = 6;\n    address public stargateEth;\n    mapping(uint256 => address) public destinationBridgeAdapter;\n    mapping(uint256 => uint16) lzIdLookup;\n    mapping(uint16 => uint256) chainIdLookup;\n\n    constructor() BaseAdapter() {}\n\n    IStargateRouter public router;\n\n    function setRouter(address _router) public onlyOwner {\n        router = IStargateRouter(_router);\n    }\n\n    function setStargateEth(address _sgEth) public onlyOwner {\n        stargateEth = _sgEth;\n    }\n\n    function getId() public pure returns (uint8) {\n        return BRIDGE_ID;\n    }\n\n    function registerRemoteBridgeAdapter(\n        uint256 dstChainId,\n        uint16 dstLzId,\n        address decentBridgeAdapter\n    ) public onlyOwner {\n        lzIdLookup[dstChainId] = dstLzId;\n        chainIdLookup[dstLzId] = dstChainId;\n        destinationBridgeAdapter[dstChainId] = decentBridgeAdapter;\n    }\n\n    function getBridgeToken(\n        bytes calldata additionalArgs\n    ) external pure returns (address bridgeToken) {\n        bridgeToken = abi.decode(additionalArgs, (address));\n    }\n\n    function getBridgedAmount(\n        uint256 amt2Bridge,\n        address /*tokenIn*/,\n        address /*tokenOut*/\n    ) external pure returns (uint256) {\n        return (amt2Bridge * (1e4 - SG_FEE_BPS)) / 1e4;\n    }\n\n    function bridge(\n        uint256 amt2Bridge,\n        SwapInstructions memory postBridge,\n        uint256 dstChainId,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        bytes calldata additionalArgs,\n        address payable refund\n    ) public payable onlyUtb returns (bytes memory bridgePayload) {\n        address bridgeToken = abi.decode(additionalArgs, (address));\n\n        bridgePayload = abi.encode(\n            postBridge,\n            target,\n            paymentOperator,\n            payload,\n            refund\n        );\n        IERC20(bridgeToken).transferFrom(msg.sender, address(this), amt2Bridge);\n        IERC20(bridgeToken).approve(address(router), amt2Bridge);\n\n        callBridge(\n            amt2Bridge,\n            dstChainId,\n            bridgePayload,\n            additionalArgs,\n            refund\n        );\n    }\n\n    function getValue(\n        bytes calldata additionalArgs,\n        uint256 amt2Bridge\n    ) private view returns (uint value) {\n        (address bridgeToken, LzBridgeData memory lzBridgeData) = abi.decode(\n            additionalArgs,\n            (address, LzBridgeData)\n        );\n        return\n            bridgeToken == stargateEth\n                ? (lzBridgeData.fee + amt2Bridge)\n                : lzBridgeData.fee;\n    }\n\n    function getLzTxObj(\n        bytes calldata additionalArgs\n    ) private pure returns (IStargateRouter.lzTxObj memory) {\n        (, , IStargateRouter.lzTxObj memory lzTxObj) = abi.decode(\n            additionalArgs,\n            (address, LzBridgeData, IStargateRouter.lzTxObj)\n        );\n        return lzTxObj;\n    }\n\n    function getDstChainId(\n        bytes calldata additionalArgs\n    ) private pure returns (uint16) {\n        (, LzBridgeData memory lzBridgeData, ) = abi.decode(\n            additionalArgs,\n            (address, LzBridgeData, IStargateRouter.lzTxObj)\n        );\n        return lzBridgeData._dstChainId;\n    }\n\n    function getSrcPoolId(\n        bytes calldata additionalArgs\n    ) private pure returns (uint120) {\n        (, LzBridgeData memory lzBridgeData, ) = abi.decode(\n            additionalArgs,\n            (address, LzBridgeData, IStargateRouter.lzTxObj)\n        );\n        return lzBridgeData._srcPoolId;\n    }\n\n    function getDstPoolId(\n        bytes calldata additionalArgs\n    ) private pure returns (uint120) {\n        (, LzBridgeData memory lzBridgeData, ) = abi.decode(\n            additionalArgs,\n            (address, LzBridgeData, IStargateRouter.lzTxObj)\n        );\n        return lzBridgeData._dstPoolId;\n    }\n\n    function getDestAdapter(uint chainId) private view returns (address dstAddr) {\n        dstAddr = destinationBridgeAdapter[chainId];\n\n        require(\n            dstAddr != address(0),\n            string.concat(\"dst chain address not set \")\n        );\n    }\n\n    function callBridge(\n        uint256 amt2Bridge,\n        uint256 dstChainId,\n        bytes memory bridgePayload,\n        bytes calldata additionalArgs,\n        address payable refund\n    ) private {\n        router.swap{value: msg.value}(\n            getDstChainId(additionalArgs), //lzBridgeData._dstChainId, // send to LayerZero chainId\n            getSrcPoolId(additionalArgs), //lzBridgeData._srcPoolId, // source pool id\n            getDstPoolId(additionalArgs), //lzBridgeData._dstPoolId, // dst pool id\n            refund, // refund adddress. extra gas (if any) is returned to this address\n            amt2Bridge, // quantity to swap\n            (amt2Bridge * (10000 - SG_FEE_BPS)) / 10000, // the min qty you would accept on the destination, fee is 6 bips\n            getLzTxObj(additionalArgs), // additional gasLimit increase, airdrop, at address\n            abi.encodePacked(getDestAdapter(dstChainId)),\n            bridgePayload // bytes param, if you wish to send additional payload you can abi.encode() them here\n        );\n    }\n\n    function sgReceive(\n        uint16, // _srcChainid\n        bytes memory, // _srcAddress\n        uint256, // _nonce\n        address, // _token\n        uint256, // amountLD\n        bytes memory payload\n    ) external override onlyExecutor {\n        (\n            SwapInstructions memory postBridge,\n            address target,\n            address paymentOperator,\n            bytes memory utbPayload,\n            address payable refund\n        ) = abi.decode(\n                payload,\n                (SwapInstructions, address, address, bytes, address)\n            );\n\n        SwapParams memory swapParams = abi.decode(\n            postBridge.swapPayload,\n            (SwapParams)\n        );\n\n        IERC20(swapParams.tokenIn).approve(utb, swapParams.amountIn);\n\n        IUTB(utb).receiveFromBridge(\n            postBridge,\n            target,\n            paymentOperator,\n            utbPayload,\n            refund\n        );\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    }
  ]
}