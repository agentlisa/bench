{
  "Title": "Typo in `FertilizerFacet::getMintFertilizerOut` NatSpec",
  "Content": "The NatSpec of [`FertilizerFacet::getMintFertilizerOut`](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/beanstalk/barn/FertilizerFacet.sol#L108) currently refers to Fertilizer as `Fertilize` which should be corrected.\n\n**Beanstalk Farms:** Fixed in commit [373c094](https://github.com/BeanstalkFarms/Beanstalk/pull/655/commits/373c0948cce9730446111a943a4fd96dabd90025).\n\n**Cyfrin:** Acknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/barn/FertilizerFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IFertilizer} from \"contracts/interfaces/IFertilizer.sol\";\nimport {AppStorage} from \"../AppStorage.sol\";\nimport {LibTransfer} from \"contracts/libraries/Token/LibTransfer.sol\";\nimport {LibEthUsdOracle} from \"contracts/libraries/Oracle/LibEthUsdOracle.sol\";\nimport {LibFertilizer} from \"contracts/libraries/LibFertilizer.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\n\n/**\n * @author Publius\n * @title FertilizerFacet handles Minting Fertilizer and Rinsing Sprouts earned from Fertilizer.\n **/\n\ncontract FertilizerFacet {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using LibSafeMath128 for uint128;\n\n    event SetFertilizer(uint128 id, uint128 bpf);\n\n    uint256 private constant FERTILIZER_AMOUNT_PRECISION = 1e24;\n\n    AppStorage internal s;\n\n    struct Supply {\n        uint128 endBpf;\n        uint256 supply;\n    }\n\n\n    /**\n     * @notice Rinses Rinsable Sprouts earned from Fertilizer.\n     * @param ids The ids of the Fertilizer to rinse.\n     * @param mode The balance to transfer Beans to; see {LibTrasfer.To}\n     */\n    function claimFertilized(uint256[] calldata ids, LibTransfer.To mode)\n        external\n        payable\n    {\n        uint256 amount = C.fertilizer().beanstalkUpdate(msg.sender, ids, s.bpf);\n        LibTransfer.sendToken(C.bean(), amount, msg.sender, mode);\n    }\n\n    /**\n     * @notice Purchase Fertilizer from the Barn Raise with WETH.\n     * @param wethAmountIn Amount of WETH to buy Fertilizer with 18 decimal precision.\n     * @param minFertilizerOut The minimum amount of Fertilizer to purchase. Protects against a significant ETH/USD price decrease.\n     * @param minLPTokensOut The minimum amount of LP tokens to receive after adding liquidity with `weth`.\n     * @param mode The balance to transfer Beans to; see {LibTrasfer.To}\n     * @dev The # of Fertilizer minted is equal to the value of the Ether paid in USD.\n     */\n    function mintFertilizer(\n        uint256 wethAmountIn,\n        uint256 minFertilizerOut,\n        uint256 minLPTokensOut,\n        LibTransfer.From mode\n    ) external payable returns (uint256 fertilizerAmountOut) {\n        // Transfer the WETH directly to the Well for gas efficiency purposes. The WETH is later synced in {LibFertilizer.addUnderlying}.\n        wethAmountIn = LibTransfer.transferToken(\n            IERC20(C.WETH),\n            msg.sender,\n            C.BEAN_ETH_WELL,\n            uint256(wethAmountIn),\n            mode,\n            LibTransfer.To.EXTERNAL\n        );\n\n        fertilizerAmountOut = getMintFertilizerOut(wethAmountIn);\n\n        require(fertilizerAmountOut >= minFertilizerOut, \"Fertilizer Not enough bought.\");\n\n        uint128 remaining = uint128(LibFertilizer.remainingRecapitalization().div(1e6)); // remaining <= 77_000_000 so downcasting is safe.\n        require(fertilizerAmountOut <= remaining, \"Fertilizer: Not enough remaining.\");\n\n        uint128 id = LibFertilizer.addFertilizer(\n            uint128(s.season.current),\n            fertilizerAmountOut,\n            minLPTokensOut\n        );\n        C.fertilizer().beanstalkMint(msg.sender, uint256(id), (fertilizerAmountOut).toUint128(), s.bpf);\n    }\n\n    /**\n     * @dev Callback from Fertilizer contract in `claimFertilized` function.\n     */\n    function payFertilizer(address account, uint256 amount) external payable {\n        require(msg.sender == C.fertilizerAddress());\n        LibTransfer.sendToken(\n            C.bean(),\n            amount,\n            account,\n            LibTransfer.To.INTERNAL\n        );\n    }\n\n    /**\n     * @dev Returns the amount of Fertilize that can be purchased with `wethAmountIn` WETH.\n     * Can be used to help calculate `minFertilizerOut` in `mintFertilizer`.\n     * `wethAmountIn` has 18 decimals, `getEthUsdPrice()` has 6 decimals and `fertilizerAmountOut` has 0 decimals.\n     */\n    function getMintFertilizerOut(\n        uint256 wethAmountIn\n    ) public view returns (uint256 fertilizerAmountOut) {\n        fertilizerAmountOut = wethAmountIn.mul(\n            LibEthUsdOracle.getEthUsdPrice()\n        ).div(FERTILIZER_AMOUNT_PRECISION);\n    }\n\n    function totalFertilizedBeans() external view returns (uint256 beans) {\n        return s.fertilizedIndex;\n    }\n\n    function totalUnfertilizedBeans() external view returns (uint256 beans) {\n        return s.unfertilizedIndex - s.fertilizedIndex;\n    }\n\n    function totalFertilizerBeans() external view returns (uint256 beans) {\n        return s.unfertilizedIndex;\n    }\n\n    function getFertilizer(uint128 id) external view returns (uint256) {\n        return s.fertilizer[id];\n    }\n\n    function getNext(uint128 id) external view returns (uint128) {\n        return LibFertilizer.getNext(id);\n    }\n\n    function getFirst() external view returns (uint128) {\n        return s.fFirst;\n    }\n\n    function getLast() external view returns (uint128) {\n        return s.fLast;\n    }\n\n    function getActiveFertilizer() external view returns (uint256) {\n        return s.activeFertilizer;\n    }\n\n    function isFertilizing() external view returns (bool) {\n        return s.season.fertilizing;\n    }\n\n    function beansPerFertilizer() external view returns (uint128 bpf) {\n        return s.bpf;\n    }\n\n    function getHumidity(uint128 _s) external pure returns (uint128 humidity) {\n        humidity = LibFertilizer.getHumidity(_s);\n    }\n\n    function getCurrentHumidity() external view returns (uint128 humidity) {\n        humidity = LibFertilizer.getHumidity(s.season.current);\n    }\n\n    function getEndBpf() external view returns (uint128 endBpf) {\n        endBpf = s.bpf.add(LibFertilizer.getBpf(uint128(s.season.current)));\n    }\n\n    function remainingRecapitalization() external view returns (uint256) {\n        return LibFertilizer.remainingRecapitalization();\n    }\n\n    function balanceOfUnfertilized(address account, uint256[] memory ids)\n        external\n        view\n        returns (uint256 beans)\n    {\n        return C.fertilizer().balanceOfUnfertilized(account, ids);\n    }\n\n    function balanceOfFertilized(address account, uint256[] memory ids)\n        external\n        view\n        returns (uint256 beans)\n    {\n        return C.fertilizer().balanceOfFertilized(account, ids);\n    }\n\n    function balanceOfFertilizer(address account, uint256 id)\n        external\n        view\n        returns (IFertilizer.Balance memory)\n    {\n        return C.fertilizer().lastBalanceOf(account, id);\n    }\n\n    function balanceOfBatchFertilizer(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) external view returns (IFertilizer.Balance[] memory) {\n        return C.fertilizer().lastBalanceOfBatch(accounts, ids);\n    }\n\n    function getFertilizers()\n        external\n        view\n        returns (Supply[] memory fertilizers)\n    {\n        uint256 numFerts = 0;\n        uint128 idx = s.fFirst;\n        while (idx > 0) {\n            numFerts = numFerts.add(1);\n            idx = LibFertilizer.getNext(idx);\n        }\n        fertilizers = new Supply[](numFerts);\n        numFerts = 0;\n        idx = s.fFirst;\n        while (idx > 0) {\n            fertilizers[numFerts].endBpf = idx;\n            fertilizers[numFerts].supply = LibFertilizer.getAmount(idx);\n            numFerts = numFerts.add(1);\n            idx = LibFertilizer.getNext(idx);\n        }\n    }\n}"
    }
  ]
}