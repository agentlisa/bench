{
  "Title": "[H-02] Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` makes it unable to unlock `lockedAmount` in `CreditLimitByMedian` model",
  "Content": "_Submitted by WatchPug_\n\n[`CreditLimitByMedian.sol` L27-L78](https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/CreditLimitByMedian.sol#L27-L78)\n\n```solidity\nfunction getLockedAmount(\n    LockedInfo[] memory array,\n    address account,\n    uint256 amount,\n    bool isIncrease\n) public pure override returns (uint256) {\n    if (array.length == 0) return 0;\n\n    uint256 newLockedAmount;\n    if (isIncrease) {\n        ...\n    } else {\n        for (uint256 i = 0; i < array.length; i++) {\n            if (array[i].lockedAmount > amount) {\n                newLockedAmount = array[i].lockedAmount - 1;\n            } else {\n                newLockedAmount = 0;\n            }\n\n            if (account == array[i].staker) {\n                return newLockedAmount;\n            }\n        }\n    }\n\n    return 0;\n}\n```\n\n`getLockedAmount()` is used by `UserManager.sol#updateLockedData()` to update locked amounts.\n\nBased on the context, at L66, `newLockedAmount = array[i].lockedAmount - 1;` should be `newLockedAmount = array[i].lockedAmount - amount;`.\n\nThe current implementation is wrong and makes it impossible to unlock `lockedAmount` in `CreditLimitByMedian` model.\n\n##### Recommendation\nChange to:\n\n`newLockedAmount = array[i].lockedAmount - amount;`\n\n**[kingjacob (Union) acknowledged](https://github.com/code-423n4/2021-10-union-findings/issues/80)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/80#issuecomment-966740802):**\n > The warden identified a mistake in the accounting that would make it impossible to unlock funds, mitigation seems to be straightfoward\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-10-union",
  "Code": [
    {
      "filename": "contracts/user/CreditLimitByMedian.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/ICreditLimitModel.sol\";\n\ncontract CreditLimitByMedian is Ownable, ICreditLimitModel {\n    using Math for uint256;\n\n    bool public constant override isCreditLimitModel = true;\n    uint256 public override effectiveNumber;\n\n    constructor(uint256 effectiveNumber_) {\n        effectiveNumber = effectiveNumber_;\n    }\n\n    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {\n        if (vouchs.length >= effectiveNumber) {\n            return _findMedian(vouchs);\n        } else {\n            return 0;\n        }\n    }\n\n    function getLockedAmount(\n        LockedInfo[] memory array,\n        address account,\n        uint256 amount,\n        bool isIncrease\n    ) public pure override returns (uint256) {\n        if (array.length == 0) return 0;\n\n        uint256 newLockedAmount;\n        if (isIncrease) {\n            for (uint256 i = 0; i < array.length; i++) {\n                uint256 remainingVouchingAmount;\n                if (array[i].vouchingAmount > array[i].lockedAmount) {\n                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n                } else {\n                    remainingVouchingAmount = 0;\n                }\n\n                if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                    if (array[i].availableStakingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                    }\n                } else {\n                    if (remainingVouchingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                    }\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < array.length; i++) {\n                if (array[i].lockedAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount - 1;\n                } else {\n                    newLockedAmount = 0;\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    function setEffectNumber(uint256 number) external onlyOwner {\n        effectiveNumber = number;\n    }\n\n    /**\n     *  @dev Find median from uint array\n     *  @param array array\n     *  @return uint256\n     */\n    function _findMedian(uint256[] memory array) private pure returns (uint256) {\n        uint256[] memory arr = _sortArray(array);\n        if (arr.length == 0) return 0;\n\n        if (arr.length % 2 == 0) {\n            uint256 num1 = arr[arr.length >> 1];\n            uint256 num2 = arr[(arr.length >> 1) - 1];\n            return num1.average(num2);\n        } else {\n            return arr[arr.length >> 1];\n        }\n    }\n\n    /**\n     *  @dev Sort uint array\n     *  @param arr array\n     *  @return uint256 array\n     */\n    function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {\n        uint256 length = arr.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            for (uint256 j = i + 1; j < length; j++) {\n                if (arr[i] < arr[j]) {\n                    uint256 temp = arr[j];\n                    arr[j] = arr[i];\n                    arr[i] = temp;\n                }\n            }\n        }\n\n        return arr;\n    }\n}"
    }
  ]
}