{
  "Title": "H-4: Lending pool state transition will be broken when pool is expired in late state",
  "Content": "# Issue H-4: Lending pool state transition will be broken when pool is expired in late state \n\nSource: https://github.com/sherlock-audit/2023-02-carapace-judging/issues/230 \n\n## Found by \nJeiwan, rvierdiiev\n\n## Summary\nLending pool state transition will be broken when pool is expired in late state\n## Vulnerability Detail\nEach lending pool has its state. State is calculated inside `ReferenceLendingPools._getLendingPoolStatus` function.\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ReferenceLendingPools.sol#L318-L349\n```solidity\n  function _getLendingPoolStatus(address _lendingPoolAddress)\n    internal\n    view\n    returns (LendingPoolStatus)\n  {\n    if (!_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n      return LendingPoolStatus.NotSupported;\n    }\n\n\n    ILendingProtocolAdapter _adapter = _getLendingProtocolAdapter(\n      _lendingPoolAddress\n    );\n\n\n    if (_adapter.isLendingPoolExpired(_lendingPoolAddress)) {\n      return LendingPoolStatus.Expired;\n    }\n\n\n    if (\n      _adapter.isLendingPoolLateWithinGracePeriod(\n        _lendingPoolAddress,\n        Constants.LATE_PAYMENT_GRACE_PERIOD_IN_DAYS\n      )\n    ) {\n      return LendingPoolStatus.LateWithinGracePeriod;\n    }\n\n\n    if (_adapter.isLendingPoolLate(_lendingPoolAddress)) {\n      return LendingPoolStatus.Late;\n    }\n\n\n    return LendingPoolStatus.Active;\n  }\n```\n\nPls, note, that the first state that is checked is `expired`.\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/adapters/GoldfinchAdapter.sol#L62-L77\n```solidity\n  function isLendingPoolExpired(address _lendingPoolAddress)\n    external\n    view\n    override\n    returns (bool)\n  {\n    ICreditLine _creditLine = _getCreditLine(_lendingPoolAddress);\n    uint256 _termEndTimestamp = _creditLine.termEndTime();\n\n\n    /// Repaid logic derived from Goldfinch frontend code:\n    /// https://github.com/goldfinch-eng/mono/blob/bd9adae6fbd810d1ebb5f7ef22df5bb6f1eaee3b/packages/client2/lib/pools/index.ts#L54\n    /// when the credit line has zero balance with valid term end, it is considered repaid\n    return\n      block.timestamp >= _termEndTimestamp ||\n      (_termEndTimestamp > 0 && _creditLine.balance() == 0);\n  }\n```\nAs you can see, pool is expired if time of credit line [has ended](https://github.com/goldfinch-eng/mono/blob/main/packages/protocol/contracts/protocol/core/CreditLine.sol#L43) or loan is fully paid.\n\nState transition for lending pool is done inside `DefaultStateManager._assessState` function. This function is responsible to lock capital, when state is late and unlock it when it's changed from late to active again.\n\nBecause the first state that is checked is `expired` there can be few problems.\n\nFirst problem. Suppose that lending pool is in late state. So capital is locked. There are 2 options now: payment was done, so pool becomes active and capital unlocked, payment was not done then pool has defaulted. But in case when state is late, and lending pool expired or loan is fully repaid(so it's also becomes expired), then capital will not be unlocked [as there is no such transition Late -> Expired](https://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/DefaultStateManager.sol#L324-L375). The state will be changed to Expired and no more actions will be done. Also in this case it's not possible to detect if lending pool expired because of time or because no payment was done.\n\nSecond problem.\nLending pool is in active state. Last payment should be done some time before `_creditLine.termEndTime()`. Payment was not done, which means that state should be changed to Late and capital should be locked, but state was checked when loan has ended, so it became Expired and again there is no such transition that can detect that capital should be locked in this case. The state will be changed to Expired and no more actions will be done.\n## Impact\nDepending on situation, capital can be locked forever or protection buyers will not be compensated.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nThese are tricky cases, think about transition for lending pool in such cases.\n\n## Discussion\n\n**vnadoda**\n\n@clems4ev3r We are planning to fix this, possibly using recommendation mentioned in a duplicate #251 \n\n**clems4ev3r**\n\n@vnadoda agreed\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/40",
  "Code": [
    {
      "filename": "contracts/core/pool/ReferenceLendingPools.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeableBase} from \"../../UUPSUpgradeableBase.sol\";\n\nimport {IReferenceLendingPools, LendingPoolStatus, LendingProtocol, ProtectionPurchaseParams, ReferenceLendingPoolInfo} from \"../../interfaces/IReferenceLendingPools.sol\";\nimport {ILendingProtocolAdapter} from \"../../interfaces/ILendingProtocolAdapter.sol\";\nimport {ILendingProtocolAdapterFactory} from \"../../interfaces/ILendingProtocolAdapterFactory.sol\";\n\nimport \"../../libraries/Constants.sol\";\n\n/**\n * @title ReferenceLendingPools\n * @author Carapace Finance\n * @notice ReferenceLendingPools manages the basket of reference lending pools,\n * against which the carapace protocol can provide the protection.\n *\n * @dev This contract is upgradeable using the UUPS pattern.\n */\ncontract ReferenceLendingPools is UUPSUpgradeableBase, IReferenceLendingPools {\n  /////////////////////////////////////////////////////\n  ///             STORAGE - START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice the lending protocol adapter factory\n  ILendingProtocolAdapterFactory private lendingProtocolAdapterFactory;\n\n  /// @notice the mapping of the lending pool address to the lending pool info\n  mapping(address => ReferenceLendingPoolInfo) public referenceLendingPools;\n\n  /// @notice an array of all the added lending pools in this basket\n  address[] private lendingPools;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /** modifiers */\n\n  /// @dev modifier to check if the lending pool is supported,\n  /// i.e. added to this basket and is active\n  modifier whenLendingPoolSupported(address _lendingPoolAddress) {\n    if (!_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n      revert ReferenceLendingPoolNotSupported(_lendingPoolAddress);\n    }\n    _;\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function initialize(\n    address _owner,\n    address[] calldata _lendingPools,\n    LendingProtocol[] calldata _lendingPoolProtocols,\n    uint256[] calldata _protectionPurchaseLimitsInDays,\n    address _lendingProtocolAdapterFactory\n  ) external override initializer {\n    if (\n      _lendingPools.length != _lendingPoolProtocols.length ||\n      _lendingPools.length != _protectionPurchaseLimitsInDays.length\n    ) {\n      revert ReferenceLendingPoolsConstructionError(\n        \"Array inputs length must match\"\n      );\n    }\n\n    if (_owner == Constants.ZERO_ADDRESS) {\n      revert ReferenceLendingPoolsConstructionError(\n        \"Owner address must not be zero\"\n      );\n    }\n\n    /// Initialize the UUPSUpgradeableBase\n    __UUPSUpgradeableBase_init();\n\n    lendingProtocolAdapterFactory = ILendingProtocolAdapterFactory(\n      _lendingProtocolAdapterFactory\n    );\n\n    /// Transfer ownership of this contract to the specified owner address\n    _transferOwnership(_owner);\n\n    /// Add the specified lending pools to the basket\n    uint256 length = _lendingPools.length;\n    for (uint256 i; i < length; ) {\n      _addReferenceLendingPool(\n        _lendingPools[i],\n        _lendingPoolProtocols[i],\n        _protectionPurchaseLimitsInDays[i]\n      );\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /** state changing functions */\n\n  /**\n   * @notice Adds a new reference lending pool to the basket.\n   * @dev This function can only be called by the owner of this contract.\n   * @dev This function is marked as payable for gas optimization.\n   * @param _lendingPoolAddress address of the lending pool\n   * @param _lendingPoolProtocol the protocol of underlying lending pool\n   * @param _protectionPurchaseLimitInDays the protection purchase limit in days.\n   * i.e. 90 days means the protection can be purchased within {_protectionPurchaseLimitInDays} days of\n   * lending pool being added to this contract.\n   */\n  function addReferenceLendingPool(\n    address _lendingPoolAddress,\n    LendingProtocol _lendingPoolProtocol,\n    uint256 _protectionPurchaseLimitInDays\n  ) external payable onlyOwner {\n    _addReferenceLendingPool(\n      _lendingPoolAddress,\n      _lendingPoolProtocol,\n      _protectionPurchaseLimitInDays\n    );\n  }\n\n  /** view functions */\n\n  /// @inheritdoc IReferenceLendingPools\n  function getLendingPools() public view override returns (address[] memory) {\n    return lendingPools;\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function canBuyProtection(\n    address _buyer,\n    ProtectionPurchaseParams calldata _purchaseParams,\n    bool _isRenewal\n  )\n    external\n    view\n    override\n    whenLendingPoolSupported(_purchaseParams.lendingPoolAddress)\n    returns (bool)\n  {\n    ReferenceLendingPoolInfo storage lendingPoolInfo = referenceLendingPools[\n      _purchaseParams.lendingPoolAddress\n    ];\n\n    /// When buyer is not renewing the existing protection and\n    /// the protection purchase is NOT within purchase limit duration after\n    /// a lending pool added, the buyer cannot purchase protection.\n    /// i.e. if the purchase limit is 90 days, the buyer cannot purchase protection\n    /// after 90 days of lending pool added to the basket\n    if (\n      !_isRenewal &&\n      block.timestamp > lendingPoolInfo.protectionPurchaseLimitTimestamp\n    ) {\n      return false;\n    }\n\n    /// Verify that protection amount is less than or equal to the remaining principal\n    /// that buyer has lent to the underlying lending pool\n    return\n      _purchaseParams.protectionAmount <=\n      calculateRemainingPrincipal(\n        _purchaseParams.lendingPoolAddress,\n        _buyer,\n        _purchaseParams.nftLpTokenId\n      );\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function calculateProtectionBuyerAPR(address _lendingPoolAddress)\n    public\n    view\n    override\n    whenLendingPoolSupported(_lendingPoolAddress)\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPoolAddress)\n        .calculateProtectionBuyerAPR(_lendingPoolAddress);\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function assessState()\n    public\n    view\n    override\n    returns (\n      address[] memory _lendingPools,\n      LendingPoolStatus[] memory _statuses\n    )\n  {\n    uint256 _length = lendingPools.length;\n    _lendingPools = new address[](_length);\n    _statuses = new LendingPoolStatus[](_length);\n\n    /// Iterate through all the lending pools in this basket and get their statuses\n    for (uint256 i; i < _length; ) {\n      _lendingPools[i] = lendingPools[i];\n      _statuses[i] = _getLendingPoolStatus(lendingPools[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function calculateRemainingPrincipal(\n    address _lendingPool,\n    address _lender,\n    uint256 _nftLpTokenId\n  )\n    public\n    view\n    override\n    whenLendingPoolSupported(_lendingPool)\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPool).calculateRemainingPrincipal(\n        _lendingPool,\n        _lender,\n        _nftLpTokenId\n      );\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function getLatestPaymentTimestamp(address _lendingPool)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPool).getLatestPaymentTimestamp(\n        _lendingPool\n      );\n  }\n\n  /// @inheritdoc IReferenceLendingPools\n  function getPaymentPeriodInDays(address _lendingPool)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _getLendingProtocolAdapter(_lendingPool).getPaymentPeriodInDays(\n        _lendingPool\n      );\n  }\n\n  /** internal functions */\n\n  /**\n   * @dev Adds a new reference lending pool to the basket if it is not already added.\n   */\n  function _addReferenceLendingPool(\n    address _lendingPoolAddress,\n    LendingProtocol _lendingPoolProtocol,\n    uint256 _protectionPurchaseLimitInDays\n  ) internal {\n    if (_lendingPoolAddress == Constants.ZERO_ADDRESS) {\n      revert ReferenceLendingPoolIsZeroAddress();\n    }\n\n    if (_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n      revert ReferenceLendingPoolAlreadyAdded(_lendingPoolAddress);\n    }\n\n    uint256 _protectionPurchaseLimitTimestamp = block.timestamp +\n      (_protectionPurchaseLimitInDays * Constants.SECONDS_IN_DAY_UINT);\n\n    /// add the underlying lending pool to this basket\n    referenceLendingPools[_lendingPoolAddress] = ReferenceLendingPoolInfo({\n      protocol: _lendingPoolProtocol,\n      addedTimestamp: block.timestamp,\n      protectionPurchaseLimitTimestamp: _protectionPurchaseLimitTimestamp\n    });\n    lendingPools.push(_lendingPoolAddress);\n\n    LendingPoolStatus _poolStatus = _getLendingPoolStatus(_lendingPoolAddress);\n    if (_poolStatus != LendingPoolStatus.Active) {\n      revert ReferenceLendingPoolIsNotActive(_lendingPoolAddress);\n    }\n\n    emit ReferenceLendingPoolAdded(\n      _lendingPoolAddress,\n      _lendingPoolProtocol,\n      block.timestamp,\n      _protectionPurchaseLimitTimestamp\n    );\n  }\n\n  /// @dev Returns the lending protocol adapter for the given lending pool address\n  function _getLendingProtocolAdapter(address _lendingPoolAddress)\n    internal\n    view\n    returns (ILendingProtocolAdapter)\n  {\n    return\n      lendingProtocolAdapterFactory.getLendingProtocolAdapter(\n        referenceLendingPools[_lendingPoolAddress].protocol\n      );\n  }\n\n  /// @dev Specifies whether the given lending pool is added to the basket or not\n  function _isReferenceLendingPoolAdded(address _lendingPoolAddress)\n    internal\n    view\n    returns (bool)\n  {\n    return referenceLendingPools[_lendingPoolAddress].addedTimestamp != 0;\n  }\n\n  /// @dev Returns the status of the given lending pool\n  function _getLendingPoolStatus(address _lendingPoolAddress)\n    internal\n    view\n    returns (LendingPoolStatus)\n  {\n    if (!_isReferenceLendingPoolAdded(_lendingPoolAddress)) {\n      return LendingPoolStatus.NotSupported;\n    }\n\n    ILendingProtocolAdapter _adapter = _getLendingProtocolAdapter(\n      _lendingPoolAddress\n    );\n\n    if (_adapter.isLendingPoolExpired(_lendingPoolAddress)) {\n      return LendingPoolStatus.Expired;\n    }\n\n    if (\n      _adapter.isLendingPoolLateWithinGracePeriod(\n        _lendingPoolAddress,\n        Constants.LATE_PAYMENT_GRACE_PERIOD_IN_DAYS\n      )\n    ) {\n      return LendingPoolStatus.LateWithinGracePeriod;\n    }\n\n    if (_adapter.isLendingPoolLate(_lendingPoolAddress)) {\n      return LendingPoolStatus.Late;\n    }\n\n    return LendingPoolStatus.Active;\n  }\n}"
    },
    {
      "filename": "contracts/adapters/GoldfinchAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@prb/math/contracts/PRBMathUD60x18.sol\";\n\nimport {UUPSUpgradeableBase} from \"../UUPSUpgradeableBase.sol\";\n\nimport {IPoolTokens} from \"../external/goldfinch/IPoolTokens.sol\";\nimport {ITranchedPool} from \"../external/goldfinch/ITranchedPool.sol\";\nimport {ICreditLine} from \"../external/goldfinch/ICreditLine.sol\";\nimport {IGoldfinchConfig} from \"../external/goldfinch/IGoldfinchConfig.sol\";\nimport {ConfigOptions} from \"../external/goldfinch/ConfigOptions.sol\";\nimport {ISeniorPoolStrategy} from \"../external/goldfinch/ISeniorPoolStrategy.sol\";\nimport {ISeniorPool} from \"../external/goldfinch/ISeniorPool.sol\";\n\nimport {ILendingProtocolAdapter} from \"../interfaces/ILendingProtocolAdapter.sol\";\nimport {IReferenceLendingPools, ProtectionPurchaseParams} from \"../interfaces/IReferenceLendingPools.sol\";\nimport \"../libraries/Constants.sol\";\n\n/**\n * @title GoldfinchAdapter\n * @author Carapace Finance\n * @notice Adapter for Goldfinch lending protocol\n * This contract is upgradeable using the UUPS pattern.\n */\ncontract GoldfinchAdapter is UUPSUpgradeableBase, ILendingProtocolAdapter {\n  using PRBMathUD60x18 for uint256;\n\n  /// Copied from Goldfinch's TranchingLogic.sol:\n  /// https://github.com/goldfinch-eng/mono/blob/main/packages/protocol/contracts/protocol/core/TranchingLogic.sol#L42\n  uint256 private constant NUM_TRANCHES_PER_SLICE = 2;\n\n  /// This is the address of the goldfinch config contract\n  /// which is used to access other goldfinch contracts and config vars.\n  /// See: https://dev.goldfinch.finance/docs/reference/contracts/core/GoldfinchConfig\n  address private constant GOLDFINCH_CONFIG_ADDRESS =\n    0xaA425F8BfE82CD18f634e2Fe91E5DdEeFD98fDA1;\n\n  /////////////////////////////////////////////////////\n  ///             STORAGE - START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// This contract stores mappings of useful goldfinch's \"protocol config state\".\n  /// These config vars are enumerated in the `ConfigOptions` library.\n  IGoldfinchConfig private goldfinchConfig;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /*** initializer ***/\n  function initialize(address _owner) external initializer {\n    __UUPSUpgradeableBase_init();\n    _transferOwnership(_owner);\n    goldfinchConfig = IGoldfinchConfig(GOLDFINCH_CONFIG_ADDRESS);\n  }\n\n  /// @inheritdoc ILendingProtocolAdapter\n  function isLendingPoolExpired(address _lendingPoolAddress)\n    external\n    view\n    override\n    returns (bool)\n  {\n    ICreditLine _creditLine = _getCreditLine(_lendingPoolAddress);\n    uint256 _termEndTimestamp = _creditLine.termEndTime();\n\n    /// Repaid logic derived from Goldfinch frontend code:\n    /// https://github.com/goldfinch-eng/mono/blob/bd9adae6fbd810d1ebb5f7ef22df5bb6f1eaee3b/packages/client2/lib/pools/index.ts#L54\n    /// when the credit line has zero balance with valid term end, it is considered repaid\n    return\n      block.timestamp >= _termEndTimestamp ||\n      (_termEndTimestamp > 0 && _creditLine.balance() == 0);\n  }\n\n  /// @inheritdoc ILendingProtocolAdapter\n  function isLendingPoolLate(address _lendingPoolAddress)\n    external\n    view\n    override\n    returns (bool)\n  {\n    return _isLendingPoolLate(_lendingPoolAddress);\n  }\n\n  /// @inheritdoc ILendingProtocolAdapter\n  function isLendingPoolLateWithinGracePeriod(\n    address _lendingPoolAddress,\n    uint256 _gracePeriodInDays\n  ) external view override returns (bool) {\n    uint256 _lastPaymentTimestamp = _getLatestPaymentTimestamp(\n      _lendingPoolAddress\n    );\n\n    /// Lending pool is considered late but within grace period if:\n    /// 1. Lending pool is late and\n    /// 2. Current time is less than the last payment time plus the payment period plus the grace period\n    return\n      _isLendingPoolLate(_lendingPoolAddress) &&\n      block.timestamp <=\n      (_lastPaymentTimestamp +\n        ((_getCreditLine(_lendingPoolAddress).paymentPeriodInDays() +\n          _gracePeriodInDays) * Constants.SECONDS_IN_DAY_UINT));\n  }\n\n  /// @inheritdoc ILendingProtocolAdapter\n  function getLendingPoolTermEndTimestamp(address _lendingPoolAddress)\n    external\n    view\n    override\n    returns (uint256 _termEndTimestamp)\n  {\n    /// Term end time in goldfinch is timestamp of first drawdown + term length in seconds\n    _termEndTimestamp = _getCreditLine(_lendingPoolAddress).termEndTime();\n  }\n\n  /// @inheritdoc ILendingProtocolAdapter\n  function calculateProtectionBuyerAPR(address _lendingPoolAddress)\n    external\n    view\n    override\n    returns (uint256 _interestRate)\n  {\n    ITranchedPool _tranchedPool = ITranchedPool(_lendingPoolAddress);\n    ICreditLine _creditLine = _tranchedPool.creditLine();\n\n    uint256 _loanInterestRate = _creditLine.interestApr();\n    uint256 _protocolFeePercent = _getProtocolFeePercent();\n\n    /// Junior Reallocation Percent is plain uint, so we need to scale it to 18 decimals\n    /// For example, juniorReallocationPercent of 20 => 0.2 => 20% => 20 * 10^16\n    uint256 _juniorReallocationPercent = (_tranchedPool.juniorFeePercent() *\n      Constants.SCALE_18_DECIMALS) / 100;\n\n    uint256 _leverageRatio = _getLeverageRatio(_tranchedPool);\n\n    /// Backers receive an effective interest rate of:\n    /// I(junior) = Interest Rate Percent ∗ (1 − Protocol Fee Percent + (Leverage Ratio ∗ Junior Reallocation Percent))\n    /// details: https://docs.goldfinch.finance/goldfinch/protocol-mechanics/backers\n    /// For example: Consider a Borrower Pool with a 15% interest rate and 4X leverage ratio.\n    /// junior tranche(backers/buyers) interest rate: 0.15 * (1 - 0.1 + (4 * 0.2)) = 0.255 = 25.5%\n    _interestRate = _loanInterestRate.mul(\n      Constants.SCALE_18_DECIMALS -\n        _protocolFeePercent +\n        _leverageRatio.mul(_juniorReallocationPercent)\n    );\n  }\n\n  /// @inheritdoc ILendingProtocolAdapter\n  function calculateRemainingPrincipal(\n    address _lendingPoolAddress,\n    address _lender,\n    uint256 _nftLpTokenId\n  ) public view override returns (uint256 _principalRemaining) {\n    IPoolTokens _poolTokens = _getPoolTokens();\n\n    /// If lender owns the NFT, then calculate the remaining principal\n    /// otherwise, the remaining principal is zero\n    if (_poolTokens.ownerOf(_nftLpTokenId) == _lender) {\n      IPoolTokens.TokenInfo memory _tokenInfo = _poolTokens.getTokenInfo(\n        _nftLpTokenId\n      );\n\n      /// If the token is for the specified lending pool and is a junior tranche, then calculate the remaining principal\n      /// otherwise, the remaining principal is zero\n      /// Only junior tranche is allowed to have protection coverage\n      if (\n        _tokenInfo.pool == _lendingPoolAddress &&\n        _isJuniorTrancheId(_tokenInfo.tranche)\n      ) {\n        _principalRemaining =\n          _tokenInfo.principalAmount -\n          _tokenInfo.principalRedeemed;\n      }\n    }\n  }\n\n  /// @inheritdoc ILendingProtocolAdapter\n  function getPaymentPeriodInDays(address _lendingPool)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return _getCreditLine(_lendingPool).paymentPeriodInDays();\n  }\n\n  /// @inheritdoc ILendingProtocolAdapter\n  function getLatestPaymentTimestamp(address _lendingPool)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return _getLatestPaymentTimestamp(_lendingPool);\n  }\n\n  /** internal functions */\n\n  /**\n   * @dev copied from TranchingLogic: https://github.com/goldfinch-eng/mono/blob/main/packages/protocol/contracts/protocol/core/TranchingLogic.sol#L419\n   */\n  function _isJuniorTrancheId(uint256 trancheId) internal pure returns (bool) {\n    return trancheId != 0 && (trancheId % NUM_TRANCHES_PER_SLICE) == 0;\n  }\n\n  /**\n   * @dev Calculates the protocol fee percent based on reserve denominator\n   * @return _feePercent protocol fee percent scaled to 18 decimals\n   */\n  function _getProtocolFeePercent()\n    internal\n    view\n    returns (uint256 _feePercent)\n  {\n    uint256 reserveDenominator = goldfinchConfig.getNumber(\n      uint256(ConfigOptions.Numbers.ReserveDenominator)\n    );\n\n    /// Convert the denominator to percent and scale by 18 decimals\n    /// reserveDenominator = 10 => 0.1 percent => (1 * 10 ** 18)/10 => 10 ** 17\n    _feePercent = Constants.SCALE_18_DECIMALS / reserveDenominator;\n  }\n\n  /**\n   * @dev Provides the leverage ratio used for specified tranched pool.\n   * @param _tranchedPool address of tranched pool\n   * @return _leverageRatio scaled to 18 decimals. For example: 4X leverage ratio => 4 * 10 ** 18\n   */\n  function _getLeverageRatio(ITranchedPool _tranchedPool)\n    internal\n    view\n    returns (uint256 _leverageRatio)\n  {\n    ISeniorPoolStrategy _seniorPoolStrategy = ISeniorPoolStrategy(\n      goldfinchConfig.getAddress(\n        uint256(ConfigOptions.Addresses.SeniorPoolStrategy)\n      )\n    );\n    return _seniorPoolStrategy.getLeverageRatio(_tranchedPool);\n  }\n\n  /**\n   * @dev Provides the PoolTokens contract\n   */\n  function _getPoolTokens() internal view returns (IPoolTokens) {\n    return\n      IPoolTokens(\n        goldfinchConfig.getAddress(uint256(ConfigOptions.Addresses.PoolTokens))\n      );\n  }\n\n  /**\n   * @dev Provides the credit line contract for specified tranched pool(lending pool) address\n   * @param _lendingPoolAddress address of tranched pool\n   */\n  function _getCreditLine(address _lendingPoolAddress)\n    internal\n    view\n    returns (ICreditLine)\n  {\n    return ITranchedPool(_lendingPoolAddress).creditLine();\n  }\n\n  /**\n   * @dev Provides the latest payment timestamp for specified tranched pool(lending pool) address\n   * @param _lendingPool address of tranched pool\n   */\n  function _getLatestPaymentTimestamp(address _lendingPool)\n    internal\n    view\n    returns (uint256)\n  {\n    return _getCreditLine(_lendingPool).lastFullPaymentTime();\n  }\n\n  /**\n   * @dev Checks if the tranched pool(lending pool) is late\n   * @param _lendingPoolAddress address of tranched pool\n   */\n  function _isLendingPoolLate(address _lendingPoolAddress)\n    internal\n    view\n    returns (bool)\n  {\n    return _getCreditLine(_lendingPoolAddress).isLate();\n  }\n}"
    },
    {
      "filename": "packages/client2/lib/pools/index.ts",
      "content": "import { gql } from \"@apollo/client\";\nimport { BigNumber, FixedNumber, utils } from \"ethers\";\n\nimport { IconNameType } from \"@/components/design-system\";\nimport { FIDU_DECIMALS, USDC_DECIMALS } from \"@/constants\";\nimport { API_BASE_URL } from \"@/constants\";\nimport {\n  SupportedCrypto,\n  TranchedPoolStatusFieldsFragment,\n  UserEligibilityFieldsFragment,\n  UidType,\n  TransactionCategory,\n  StakedPositionType,\n  SeniorPoolStakedPosition,\n} from \"@/lib/graphql/generated\";\nimport { Erc20, Fidu } from \"@/types/ethers-contracts\";\n\nimport { toastTransaction } from \"../toast\";\n\n/**\n * Include this graphQL fragment on a query for TranchedPool to ensure it has the correct fields for computing PoolStatus\n */\nexport const TRANCHED_POOL_STATUS_FIELDS = gql`\n  fragment TranchedPoolStatusFields on TranchedPool {\n    id\n    isPaused\n    remainingCapacity\n    fundableAt\n    creditLine {\n      id\n      balance\n      termEndTime\n    }\n  }\n`;\n\nexport enum PoolStatus {\n  Paused,\n  Repaid,\n  Full,\n  ComingSoon,\n  Open,\n}\n\n/**\n * Get the current status of the tranched pool\n * @param pool TranchedPool to get the status for. Use the TranchedPoolStatusFields fragment to guarantee your query has the right fields for this computation.\n * @returns the status of the pool\n */\nexport function getTranchedPoolStatus(pool: TranchedPoolStatusFieldsFragment) {\n  if (pool.isPaused) {\n    return PoolStatus.Paused;\n  } else if (\n    pool.creditLine.balance.isZero() &&\n    pool.creditLine.termEndTime.gt(0)\n  ) {\n    return PoolStatus.Repaid;\n  } else if (pool.remainingCapacity.isZero()) {\n    return PoolStatus.Full;\n  } else if (\n    pool.creditLine.termEndTime.isZero() &&\n    Date.now() / 1000 < parseInt(pool.fundableAt.toString())\n  ) {\n    return PoolStatus.ComingSoon;\n  } else {\n    return PoolStatus.Open;\n  }\n}\n\nexport function computeApyFromGfiInFiat(\n  apyFromGfiRaw: FixedNumber,\n  fiatPerGfi: number\n): FixedNumber {\n  return apyFromGfiRaw.mulUnsafe(FixedNumber.fromString(fiatPerGfi.toString()));\n}\n\nconst usdcMantissa = BigNumber.from(10).pow(USDC_DECIMALS);\nconst fiduMantissa = BigNumber.from(10).pow(FIDU_DECIMALS);\nconst sharePriceMantissa = fiduMantissa;\n\n/**\n * A utility function for converting senior pool shares to a USDC amount\n * @param numShares Number of shares. This could be staked or unstaked FIDU balance, for example.\n * @param sharePrice `sharePrice` as it is reported from the Senior Pool contract\n * @returns a `CryptoAmount` in USDC\n */\nexport function sharesToUsdc(numShares: BigNumber, sharePrice: BigNumber) {\n  const amount = numShares\n    .mul(sharePrice)\n    .div(fiduMantissa)\n    .div(sharePriceMantissa.div(usdcMantissa));\n\n  return { token: SupportedCrypto.Usdc, amount };\n}\n\n/**\n * A utility function for converting an amount of USDC to an amount of FIDU in the senior pool.\n * @param usdcAmount USDC amount\n * @param sharePrice `sharePrice` as it reported from the Senior Pool contract\n * @returns a `CryptoAmount` in FIDU\n */\nexport function usdcToShares(usdcAmount: BigNumber, sharePrice: BigNumber) {\n  const numShares = usdcAmount\n    .mul(fiduMantissa)\n    .div(usdcMantissa)\n    .mul(sharePriceMantissa)\n    .div(sharePrice);\n  return { token: SupportedCrypto.Fidu, amount: numShares };\n}\n\nexport const USER_ELIGIBILITY_FIELDS = gql`\n  fragment UserEligibilityFields on User {\n    id\n    isUsEntity\n    isNonUsEntity\n    isUsAccreditedIndividual\n    isUsNonAccreditedIndividual\n    isNonUsIndividual\n    isGoListed\n  }\n`;\n\nexport function canUserParticipateInPool(\n  poolAllowedUids: UidType[],\n  user: UserEligibilityFieldsFragment\n): boolean {\n  if (user.isGoListed) {\n    return true;\n  }\n  if (\n    user.isNonUsIndividual &&\n    poolAllowedUids.includes(UidType.NonUsIndividual)\n  ) {\n    return true;\n  }\n  if (\n    user.isUsAccreditedIndividual &&\n    poolAllowedUids.includes(UidType.UsAccreditedIndividual)\n  ) {\n    return true;\n  }\n  if (\n    user.isUsNonAccreditedIndividual &&\n    poolAllowedUids.includes(UidType.UsNonAccreditedIndividual)\n  ) {\n    return true;\n  }\n  if (user.isUsEntity && poolAllowedUids.includes(UidType.UsEntity)) {\n    return true;\n  }\n  if (user.isNonUsEntity && poolAllowedUids.includes(UidType.NonUsEntity)) {\n    return true;\n  }\n  return false;\n}\n\nexport async function signAgreement(\n  account: string,\n  fullName: string,\n  pool: string\n) {\n  try {\n    const response = await fetch(`${API_BASE_URL}/signAgreement`, {\n      method: \"POST\",\n      headers: {\n        \"x-goldfinch-address\": account,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ fullName, pool }),\n    });\n    if (!response.ok) {\n      const responseBody = await response.json();\n      throw new Error(`Unable to sign agreement. ${responseBody.error}`);\n    }\n  } catch (e) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.warn(\n        `Could not sign agreement for pool. Message: ${\n          (e as Error).message\n        }. Ignoring this because it's not production.`\n      );\n    } else {\n      throw e;\n    }\n  }\n}\n\n/**\n * A utility function that tells you if n1 is within one epsilon of n2. This means that the n1 is \"reasonably close\" to n2. \"Reasonably close\" is relative to USDC amounts.\n * For use in sticky situations where the user has to enter an imprecise amount.\n * @param n1\n * @param n2\n */\nexport function usdcWithinEpsilon(n1: BigNumber, n2: BigNumber): boolean {\n  const epsilon = utils.parseUnits(\"1\", 4);\n  return n2.sub(epsilon).lte(n1) && n1.lte(n2.add(epsilon));\n}\n\n/**\n * Utility function that will perform an ERC20 approval if it's necessary, and will toast messages for this approval too.\n */\nexport async function approveErc20IfRequired({\n  account,\n  spender,\n  amount,\n  erc20Contract,\n}: {\n  account: string;\n  spender: string;\n  amount: BigNumber;\n  erc20Contract: Erc20 | Fidu;\n}) {\n  const allowance = await erc20Contract.allowance(account, spender);\n  const isApprovalRequired = allowance.lt(amount);\n  if (isApprovalRequired) {\n    await toastTransaction({\n      transaction: erc20Contract.approve(spender, amount),\n      pendingPrompt: \"Awaiting approval to spend tokens.\",\n      successPrompt: \"Successfully approved spending.\",\n      errorPrompt: \"Failed to approved spending\",\n    });\n  }\n}\n\nconst transactionLabels: Record<TransactionCategory, string> = {\n  [TransactionCategory.SeniorPoolStake]: \"Senior Pool Stake\",\n  [TransactionCategory.SeniorPoolDeposit]: \"Senior Pool Supply\",\n  [TransactionCategory.SeniorPoolDepositAndStake]:\n    \"Senior Pool Supply and Stake\",\n  [TransactionCategory.SeniorPoolUnstake]: \"Senior Pool Unstake\",\n  [TransactionCategory.SeniorPoolWithdrawal]: \"Senior Pool Withdrawal\",\n  [TransactionCategory.SeniorPoolUnstakeAndWithdrawal]:\n    \"Senior Pool Unstake and Withdraw\",\n  [TransactionCategory.SeniorPoolRedemption]: \"Senior Pool Auto Transfer\",\n  [TransactionCategory.TranchedPoolDeposit]: \"Borrower Pool Supply\",\n  [TransactionCategory.TranchedPoolWithdrawal]: \"Borrower Pool Withdrawal\",\n  [TransactionCategory.TranchedPoolRepayment]: \"Repayment\",\n  [TransactionCategory.TranchedPoolDrawdown]: \"Drawdown\",\n  [TransactionCategory.UidMinted]: \"Mint UID\",\n};\n\nexport function getTransactionLabel(transaction: {\n  category: TransactionCategory;\n}): string {\n  return transactionLabels[transaction.category];\n}\n\nconst shortTransactionLabels: Record<TransactionCategory, string> = {\n  [TransactionCategory.SeniorPoolStake]: \"Stake\",\n  [TransactionCategory.SeniorPoolDeposit]: \"Supply\",\n  [TransactionCategory.SeniorPoolDepositAndStake]: \"Supply and Stake\",\n  [TransactionCategory.SeniorPoolUnstake]: \"Unstake\",\n  [TransactionCategory.SeniorPoolWithdrawal]: \"Withdrawal\",\n  [TransactionCategory.SeniorPoolUnstakeAndWithdrawal]: \"Unstake and Withdraw\",\n  [TransactionCategory.SeniorPoolRedemption]: \"Auto Transfer\",\n  [TransactionCategory.TranchedPoolDeposit]: \"Supply\",\n  [TransactionCategory.TranchedPoolWithdrawal]: \"Withdrawal\",\n  [TransactionCategory.TranchedPoolRepayment]: \"Repayment\",\n  [TransactionCategory.TranchedPoolDrawdown]: \"Drawdown\",\n  [TransactionCategory.UidMinted]: \"Mint UID\",\n};\n\n/**\n * Less descriptive but more brief than regular getTransactionLabel(). Use this only when it's appropriate in context.\n * @param transaction Transaction object\n * @returns Short label describing the transaction\n */\nexport function getShortTransactionLabel(transaction: {\n  category: TransactionCategory;\n}): string {\n  return shortTransactionLabels[transaction.category];\n}\n\nconst transactionIcons: Record<TransactionCategory, IconNameType> = {\n  [TransactionCategory.SeniorPoolStake]: \"ArrowUpCircle\",\n  [TransactionCategory.SeniorPoolDeposit]: \"ArrowUpCircle\",\n  [TransactionCategory.SeniorPoolDepositAndStake]: \"ArrowUpCircle\",\n  [TransactionCategory.SeniorPoolUnstake]: \"ArrowDownCircle\",\n  [TransactionCategory.SeniorPoolWithdrawal]: \"ArrowDownCircle\",\n  [TransactionCategory.SeniorPoolUnstakeAndWithdrawal]: \"ArrowDownCircle\",\n  [TransactionCategory.SeniorPoolRedemption]: \"ArrowDownCircle\",\n  [TransactionCategory.TranchedPoolDeposit]: \"ArrowUpCircle\",\n  [TransactionCategory.TranchedPoolWithdrawal]: \"ArrowDownCircle\",\n  [TransactionCategory.TranchedPoolRepayment]: \"ArrowUpCircle\",\n  [TransactionCategory.TranchedPoolDrawdown]: \"ArrowDownCircle\",\n  [TransactionCategory.UidMinted]: \"CheckmarkCircle\",\n};\n\n/**\n * Returns the icon for the transaction category\n * @param transaction Transaction object\n * @returns Icon to use for the transaction\n */\nexport function getTransactionIcon(transaction: {\n  category: TransactionCategory;\n}): IconNameType {\n  return transactionIcons[transaction.category];\n}\n\n/**\n * Mapping of position type to value for transactions\n */\nexport const positionTypeToValue: Record<StakedPositionType, string> = {\n  [StakedPositionType.Fidu]: \"0\",\n  [StakedPositionType.CurveLp]: \"1\",\n};\n\n/**\n * Get the optimal positions to unstake\n * @param positions     Array of the positions\n * @param amount        The amount to unstake\n * @returns Sorted array of positions to unstake\n */\nexport function getOptimalPositionsToUnstake(\n  positions: Pick<SeniorPoolStakedPosition, \"id\" | \"amount\" | \"endTime\">[],\n  amount: BigNumber\n): { id: string; amount: BigNumber }[] {\n  const unstakeableAmount = sum(\"amount\", positions);\n\n  if (unstakeableAmount.lt(amount)) {\n    throw new Error(`Cannot unstake more than ${unstakeableAmount}.`);\n  }\n\n  const sortedUnstakeablePositions = positions\n    .slice()\n    .sort((a, b) =>\n      a.endTime && b.endTime ? b.endTime.sub(a.endTime).toNumber() : 0\n    );\n\n  let amountRemaining = BigNumber.from(amount);\n\n  return sortedUnstakeablePositions\n    .reduce((acc: { id: string; amount: BigNumber }[], position) => {\n      if (!position.id) return acc;\n\n      const id = position.id;\n      const positionAmount = position.amount ?? BigNumber.from(0);\n      const amountToUnstake = positionAmount.lt(amountRemaining)\n        ? positionAmount\n        : amountRemaining;\n\n      amountRemaining = amountRemaining.sub(amountToUnstake);\n\n      return acc.concat([{ id, amount: amountToUnstake }]);\n    }, [])\n    .filter(({ amount }) => amount.gt(BigNumber.from(0)));\n}\n\n/**\n * Convenience function that allows you to sum one field of an array of objects.\n * @param field The field to extract from each of the objects.\n * @param summable Array of objects to be summed over. Each object should have a key named the same as `field` with a value that is a BigNumber\n * @returns The sum of all `summable[field]` values.\n */\nexport function sum<T extends string, U extends Record<T, BigNumber>>(\n  field: T,\n  summable: U[] = []\n): BigNumber {\n  return summable.reduce(\n    (prev, current) => prev.add(current[field]),\n    BigNumber.from(0)\n  );\n}"
    },
    {
      "filename": "packages/protocol/contracts/protocol/core/CreditLine.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npra"
    }
  ]
}