{
  "Title": "[M-01] Fee on transfer tokens will not behave as expected",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-01-numoen/blob/main/src/core/Lendgine.sol#L99\n\n\n# Vulnerability details\n\n## Impact\nIn Numoen, it does not specifically restrict the type of ERC20 collateral used for borrowing.\n\nIf fee on transfer token(s) is/are entailed, it will specifically make mint() revert in Lendgine.sol when checking if balanceAfter < balanceBefore + collateral.\n\n## Proof of Concept\n[File: Lendgine.sol#L71-L102](https://github.com/code-423n4/2023-01-numoen/blob/main/src/core/Lendgine.sol#L71-L102)\n\n```solidity\n  function mint(\n    address to,\n    uint256 collateral,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 shares)\n  {\n    _accrueInterest();\n\n    uint256 liquidity = convertCollateralToLiquidity(collateral);\n    shares = convertLiquidityToShare(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n    if (liquidity > totalLiquidity) revert CompleteUtilizationError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalSupply > 0 && totalLiquidityBorrowed == 0) revert CompleteUtilizationError();\n\n    totalLiquidityBorrowed += liquidity;\n    (uint256 amount0, uint256 amount1) = burn(to, liquidity);\n    _mint(to, shares);\n\n    uint256 balanceBefore = Balance.balance(token1);\n    IMintCallback(msg.sender).mintCallback(collateral, amount0, amount1, liquidity, data);\n    uint256 balanceAfter = Balance.balance(token1);\n\n99:    if (balanceAfter < balanceBefore + collateral) revert InsufficientInputError();\n\n    emit Mint(msg.sender, collateral, shares, liquidity, to);\n  }\n```\nAs can be seen from the code block above, line 99 is meant to be reverting when `balanceAfter < balanceBefore + collateral`. So in the case of deflationary tokens, the error is going to be thrown even though the token amount has been received due to the fee factor.\n\n## Tools Used\nManual inspection\n\n## Recommended Mitigation Steps\nConsider:\n\n1. whitelisting token0 and token1 ensuring no fee-on-transfer token is allowed when a new instance of a market is created using the factory, or\n2. calculating the balance before and after the transfer of token1 (collateral), and use the difference between those two balances as the amount received rather than using the input amount `collateral` if deflationary token is going to be allowed in the protocol.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-numoen-contest",
  "Code": [
    {
      "filename": "src/core/Lendgine.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ERC20 } from \"./ERC20.sol\";\nimport { JumpRate } from \"./JumpRate.sol\";\nimport { Pair } from \"./Pair.sol\";\n\nimport { ILendgine } from \"./interfaces/ILendgine.sol\";\nimport { IMintCallback } from \"./interfaces/callback/IMintCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { Position } from \"./libraries/Position.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\n\ncontract Lendgine is ERC20, JumpRate, Pair, ILendgine {\n  using Position for mapping(address => Position.Info);\n  using Position for Position.Info;\n\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(address indexed sender, uint256 collateral, uint256 shares, uint256 liquidity, address indexed to);\n\n  event Burn(address indexed sender, uint256 collateral, uint256 shares, uint256 liquidity, address indexed to);\n\n  event Deposit(address indexed sender, uint256 size, uint256 liquidity, address indexed to);\n\n  event Withdraw(address indexed sender, uint256 size, uint256 liquidity, address indexed to);\n\n  event AccrueInterest(uint256 timeElapsed, uint256 collateral, uint256 liquidity);\n\n  event AccruePositionInterest(address indexed owner, uint256 rewardPerPosition);\n\n  event Collect(address indexed owner, address indexed to, uint256 amount);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InputError();\n\n  error CompleteUtilizationError();\n\n  error InsufficientInputError();\n\n  error InsufficientPositionError();\n\n  /*//////////////////////////////////////////////////////////////\n                          LENDGINE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc ILendgine\n  mapping(address => Position.Info) public override positions;\n\n  /// @inheritdoc ILendgine\n  uint256 public override totalPositionSize;\n\n  /// @inheritdoc ILendgine\n  uint256 public override totalLiquidityBorrowed;\n\n  /// @inheritdoc ILendgine\n  uint256 public override rewardPerPositionStored;\n\n  /// @inheritdoc ILendgine\n  uint256 public override lastUpdate;\n\n  /// @inheritdoc ILendgine\n  function mint(\n    address to,\n    uint256 collateral,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 shares)\n  {\n    _accrueInterest();\n\n    uint256 liquidity = convertCollateralToLiquidity(collateral);\n    shares = convertLiquidityToShare(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n    if (liquidity > totalLiquidity) revert CompleteUtilizationError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalSupply > 0 && totalLiquidityBorrowed == 0) revert CompleteUtilizationError();\n\n    totalLiquidityBorrowed += liquidity;\n    (uint256 amount0, uint256 amount1) = burn(to, liquidity);\n    _mint(to, shares);\n\n    uint256 balanceBefore = Balance.balance(token1);\n    IMintCallback(msg.sender).mintCallback(collateral, amount0, amount1, liquidity, data);\n    uint256 balanceAfter = Balance.balance(token1);\n\n    if (balanceAfter < balanceBefore + collateral) revert InsufficientInputError();\n\n    emit Mint(msg.sender, collateral, shares, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function burn(address to, bytes calldata data) external override nonReentrant returns (uint256 collateral) {\n    _accrueInterest();\n\n    uint256 shares = balanceOf[address(this)];\n    uint256 liquidity = convertShareToLiquidity(shares);\n    collateral = convertLiquidityToCollateral(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n\n    totalLiquidityBorrowed -= liquidity;\n    _burn(address(this), shares);\n    SafeTransferLib.safeTransfer(token1, to, collateral); // optimistically transfer\n    mint(liquidity, data);\n\n    emit Burn(msg.sender, collateral, shares, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function deposit(\n    address to,\n    uint256 liquidity,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 size)\n  {\n    _accrueInterest();\n\n    uint256 _totalPositionSize = totalPositionSize; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + totalLiquidityBorrowed;\n\n    size = Position.convertLiquidityToPosition(liquidity, totalLiquiditySupplied, _totalPositionSize);\n\n    if (liquidity == 0 || size == 0) revert InputError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalLiquiditySupplied == 0 && totalPositionSize > 0) revert CompleteUtilizationError();\n\n    positions.update(to, SafeCast.toInt256(size), rewardPerPositionStored);\n    totalPositionSize = _totalPositionSize + size;\n    mint(liquidity, data);\n\n    emit Deposit(msg.sender, size, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function withdraw(\n    address to,\n    uint256 size\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 amount0, uint256 amount1, uint256 liquidity)\n  {\n    _accrueInterest();\n\n    uint256 _totalPositionSize = totalPositionSize; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n    uint256 totalLiquiditySupplied = _totalLiquidity + totalLiquidityBorrowed;\n\n    Position.Info memory positionInfo = positions[msg.sender]; // SLOAD\n    liquidity = Position.convertPositionToLiquidity(size, totalLiquiditySupplied, _totalPositionSize);\n\n    if (liquidity == 0 || size == 0) revert InputError();\n\n    if (size > positionInfo.size) revert InsufficientPositionError();\n    if (liquidity > _totalLiquidity) revert CompleteUtilizationError();\n\n    positions.update(msg.sender, -SafeCast.toInt256(size), rewardPerPositionStored);\n    totalPositionSize -= size;\n    (amount0, amount1) = burn(to, liquidity);\n\n    emit Withdraw(msg.sender, size, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function accrueInterest() external override nonReentrant {\n    _accrueInterest();\n  }\n\n  /// @inheritdoc ILendgine\n  function accruePositionInterest() external override nonReentrant {\n    _accrueInterest();\n    _accruePositionInterest(msg.sender);\n  }\n\n  /// @inheritdoc ILendgine\n  function collect(address to, uint256 collateralRequested) external override nonReentrant returns (uint256 collateral) {\n    Position.Info storage position = positions[msg.sender]; // SLOAD\n    uint256 tokensOwed = position.tokensOwed;\n\n    collateral = collateralRequested > tokensOwed ? tokensOwed : collateralRequested;\n\n    if (collateral > 0) {\n      position.tokensOwed = tokensOwed - collateral; // SSTORE\n      SafeTransferLib.safeTransfer(token1, to, collateral);\n    }\n\n    emit Collect(msg.sender, to, collateral);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc ILendgine\n  function convertLiquidityToShare(uint256 liquidity) public view override returns (uint256) {\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    return _totalLiquidityBorrowed == 0 ? liquidity : FullMath.mulDiv(liquidity, totalSupply, _totalLiquidityBorrowed);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertShareToLiquidity(uint256 shares) public view override returns (uint256) {\n    return FullMath.mulDiv(totalLiquidityBorrowed, shares, totalSupply);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertCollateralToLiquidity(uint256 collateral) public view override returns (uint256) {\n    return FullMath.mulDiv(collateral * token1Scale, 1e18, 2 * upperBound);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertLiquidityToCollateral(uint256 liquidity) public view override returns (uint256) {\n    return FullMath.mulDiv(liquidity, 2 * upperBound, 1e18) / token1Scale;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         INTERNAL INTEREST LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Helper function for accruing lendgine interest\n  function _accrueInterest() private {\n    if (totalSupply == 0 || totalLiquidityBorrowed == 0) {\n      lastUpdate = block.timestamp;\n      return;\n    }\n\n    uint256 timeElapsed = block.timestamp - lastUpdate;\n    if (timeElapsed == 0) return;\n\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + _totalLiquidityBorrowed; // SLOAD\n\n    uint256 borrowRate = getBorrowRate(_totalLiquidityBorrowed, totalLiquiditySupplied);\n\n    uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;\n    uint256 dilutionLP = dilutionLPRequested > _totalLiquidityBorrowed ? _totalLiquidityBorrowed : dilutionLPRequested;\n    uint256 dilutionSpeculative = convertLiquidityToCollateral(dilutionLP);\n\n    totalLiquidityBorrowed = _totalLiquidityBorrowed - dilutionLP;\n    rewardPerPositionStored += FullMath.mulDiv(dilutionSpeculative, 1e18, totalPositionSize);\n    lastUpdate = block.timestamp;\n\n    emit AccrueInterest(timeElapsed, dilutionSpeculative, dilutionLP);\n  }\n\n  /// @notice Helper function for accruing interest to a position\n  /// @dev Assume the global interest is up to date\n  /// @param owner The address that this position belongs to\n  function _accruePositionInterest(address owner) private {\n    uint256 _rewardPerPositionStored = rewardPerPositionStored; // SLOAD\n\n    positions.update(owner, 0, _rewardPerPositionStored);\n\n    emit AccruePositionInterest(owner, _rewardPerPositionStored);\n  }\n}"
    }
  ]
}