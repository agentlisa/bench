{
  "Title": "[M-08] Early contributor can always become majority of crowdfund leading to rugging risks.",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L114-L135\n\n\n# Vulnerability details\n\n## Description\nVoting power is distributed to crowdfund contributors according to the amount contributed divided by NFT purchase price. Attacker can call the buy() function of BuyCrowdfund / CollectionBuyCrowdfund, and use only the first X amount of contribution from the crowdfund, such that attacker's contribution > X/2. He will pass his contract to the buy call, which will receive X and will need to add some additional funds, to purchase the NFT. If the purchase is successful, attacker will have majority rule in the created party. If the party does not do anything malicious, this is a losing move for attacker, because the funds they added on top of X to compensate for the NFT price will eventually be split between group members. However, with majority rule there are various different exploitation vectors attacker may use to steal the NFT from the party ( detailed in separate reports). Because it is accepted that single actor majority is dangerous, but without additional vulnerabilities attacker cannot take ownership of the party's assets, I classify this as a medium. The point is that users were not aware they could become minority under this attack flow.\n\n\n## Impact\nEarly contributor can always become majority of crowdfund leading to rugging risks.\n\n## Proof of Concept\n1. Victim A opens BuyCrowdfund and deposits 20 ETH\n2. Attacker deposits 30 ETH\n3. Victim B deposits 50 ETH\n4. Suppose NFT costs 100 ETH\n5. Attacker will call buy(), requesting 59ETH buy price. His contract will add 41 additional ETH and buy the NFT.\n6. Voting power distributed will be: 20 / 59 for Victim A, 30 / 59 for Attacker, 9 / 59 for Victim B. Attacker has majority.\n7. User can use some majority attack to take control of the NFT, netting 100 (NFT value) - 41 (external contribution) - 30 (own contribution) = 29 ETH\n\n\t\n## Tools Used\nManual audit.\n\n## Recommended Mitigation Steps\nAdd a Crowdfund property called minimumPrice, which will be visible to all. Buy() function should not accept NFT price < minimumPrice. Users now have assurances that are not susceptible to majority rule if they deposited enough ETH below the minimumPrice.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/crowdfund/BuyCrowdfundBase.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./Crowdfund.sol\";\n\n// Base for BuyCrowdfund and CollectionBuyCrowdfund\nabstract contract BuyCrowdfundBase is Implementation, Crowdfund {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n    using LibRawResult for bytes;\n\n    struct BuyCrowdfundBaseOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum amount this crowdfund will pay for the NFT.\n        // If zero, no maximum.\n        uint96 maximumPrice;\n        // An address that receieves an extra share of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund.\n        IGateKeeper gateKeeper;\n        // The gatekeeper contract to use (if non-null).\n        bytes12 gateKeeperId;\n        // Governance options.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    event Won(Party party, IERC721 token, uint256 tokenId, uint256 settledPrice);\n\n    error MaximumPriceError(uint96 callValue, uint96 maximumPrice);\n    error NoContributionsError();\n    error FailedToBuyNFTError(IERC721 token, uint256 tokenId);\n    error InvalidCallTargetError(address callTarget);\n\n    /// @notice When this crowdfund expires.\n    uint40 public expiry;\n    /// @notice Maximum amount this crowdfund will pay for the NFT. If zero, no maximum.\n    uint96 public maximumPrice;\n    /// @notice What the NFT was actually bought for.\n    uint96 public settledPrice;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) Crowdfund(globals) {}\n\n    // Initialize storage for proxy contracts.\n    function _initialize(BuyCrowdfundBaseOptions memory opts)\n        internal\n    {\n        expiry = uint40(opts.duration + block.timestamp);\n        maximumPrice = opts.maximumPrice;\n        Crowdfund._initialize(CrowdfundOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n    }\n\n    // Execute arbitrary calldata to perform a buy, creating a party\n    // if it successfully buys the NFT.\n    function _buy(\n        IERC721 token,\n        uint256 tokenId,\n        address payable callTarget,\n        uint96 callValue,\n        bytes calldata callData,\n        FixedGovernanceOpts memory governanceOpts\n    )\n        internal\n        onlyDelegateCall\n        returns (Party party_)\n    {\n        // Ensure the call target isn't trying to reenter or trying to do\n        // anything weird with `PartyFactory`.\n        IPartyFactory partyFactory = _getPartyFactory();\n        if (callTarget == address(partyFactory) || callTarget == address(this)) {\n            revert InvalidCallTargetError(callTarget);\n        }\n        // Check that the crowdfund is still active.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active) {\n            revert WrongLifecycleError(lc);\n        }\n        // Used to store the price the NFT was bought for.\n        uint96 settledPrice_;\n        {\n            uint96 maximumPrice_ = maximumPrice;\n            if (maximumPrice_ != 0 && callValue > maximumPrice_) {\n                revert MaximumPriceError(callValue, maximumPrice);\n            }\n            // If the purchase would be free, set the settled price to\n            // `totalContributions` so everybody who contributed wins.\n            settledPrice_ = callValue == 0 ? totalContributions : callValue;\n            if (settledPrice_ == 0) {\n                // Still zero, which means no contributions.\n                revert NoContributionsError();\n            }\n            settledPrice = settledPrice_;\n        }\n        {\n            // Execute the call to buy the NFT.\n            (bool s, bytes memory r) = callTarget.call{ value: callValue }(callData);\n            if (!s) {\n                r.rawRevert();\n            }\n        }\n        // Make sure we acquired the NFT we want.\n        if (token.safeOwnerOf(tokenId) != address(this)) {\n            revert FailedToBuyNFTError(token, tokenId);\n        }\n        emit Won(\n            // Create a party around the newly bought NFT.\n            party_ = _createParty(partyFactory, governanceOpts, token, tokenId),\n            token,\n            tokenId,\n            settledPrice_\n        );\n    }\n\n    /// @inheritdoc Crowdfund\n    function getCrowdfundLifecycle() public override view returns (CrowdfundLifecycle) {\n        // If there is a settled price then we tried to buy the NFT.\n        if (settledPrice != 0) {\n            return address(party) != address(0)\n                // If we have a party, then we succeeded buying the NFT.\n                ? CrowdfundLifecycle.Won\n                // Otherwise we're in the middle of the buy().\n                : CrowdfundLifecycle.Busy;\n        }\n        if (block.timestamp >= expiry) {\n            // Expired but nothing to do so skip straight to lost.\n            return CrowdfundLifecycle.Lost;\n        }\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256)\n    {\n        return settledPrice;\n    }\n}"
    }
  ]
}