{
  "Title": "M-1: Division by Zero in CvgRewards::_distributeCvgRewards leads to locked funds",
  "Content": "# Issue M-1: Division by Zero in CvgRewards::_distributeCvgRewards leads to locked funds \n\nSource: https://github.com/sherlock-audit/2023-11-convergence-judging/issues/131 \n\n## Found by \ncergyk\n## Summary\n\nThe bug occurs when `CvgRewards::_setTotalWeight` sets `totalWeightLocked` to zero, leading to a division by zero error in \n`CvgRewards::_distributeCvgRewards`, and blocking cycle increments. The blocking results in all Cvg locked to be unlockable permanently.\n\n## Vulnerability Detail\n\nThe function `_distributeCvgRewards` of `CvgRewards.sol` is designed to calculate and distribute CVG rewards among staking contracts. It calculates the `cvgDistributed` for each gauge based on its weight and the total staking inflation. However, if the `totalWeightLocked` remains at zero (due to some gauges that are available but no user has voted for any gauge), the code attempts to divide by zero.\n\nThe DoS of `_distributeCvgRewards` will prevent cycle from advancing to the next state `State.CONTROL_TOWER_SYNC`, thus forever locking the users’ locked CVG tokens.\n\n## Impact\n\nLoss of users’ CVG tokens due to DoS of `_distributeCvgRewards` blocking the state.\n\n## Code Snippet\n\n```solidity\n    function _setTotalWeight() internal {\n        ...\n❌      totalWeightLocked += _gaugeController.get_gauge_weight_sum(_getGaugeChunk(_cursor, _endChunk)); //@audit `totalWeightLocked` can be set to 0 if no gauge has received any vote\n        ...\n    }\n\n```\n\n```solidity\n    function _distributeCvgRewards() internal {\n        ...\n        uint256 _totalWeight = totalWeightLocked;\n        ...\n        for (uint256 i; i < gaugeWeights.length; ) {\n            /// @dev compute the amount of CVG to distribute in the gauge\n❌          cvgDistributed = (stakingInflation * gaugeWeights[i]) / _totalWeight; //@audit will revert if `_totalWeight` is zero\n        ...\n\n```\n\n```solidity\n/**\n* @notice Unlock CVG tokens under the NFT Locking Position : Burn the NFT, Transfer back the CVG to the user.  Rewards from YsDistributor must be claimed before or they will be lost.    * @dev The locking time must be over\n* @param tokenId to burn\n*/\nfunction burnPosition(uint256 tokenId) external {\n...\n❌      require(_cvgControlTower.cvgCycle() > lastEndCycle, \"LOCKED\"); //@audit funds are locked if current `cycle <= lastEndCycle`\n...\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Rewards/CvgRewards.sol#L321\n\n## Tool used\n\n## Recommendation\nIf the _totalWeight is zero, just consider the cvg rewards to be zero for that cycle, and continue with other logic:\n\n```diff\n-cvgDistributed = (stakingInflation * gaugeWeights[i]) / _totalWeight; \n+cvgDistributed = _totalWeight == 0 ? 0 : (stakingInflation * gaugeWeights[i]) / _totalWeight;\n```\n\n\n\n## Discussion\n\n**0xR3vert**\n\nHello,\n\nThanks a lot for your attention.\n\nWe are aware of the potential for a division by zero if there are no votes at all in one of our gauges. However, this scenario is unlikely to occur in reality because there will always be votes deployed (by us and/or others) in the gauges. Nevertheless, your point is valid, and we will address it to be prepared for this case.\n\nTherefore, in conclusion, we must acknowledge your issue as correct, even though we are already aware of it.\n\nRegards,\nConvergence Team\n\n**nevillehuang**\n\nSince DoS is not permanent where in as long as protocol/users themselves vote for the gauge, I think this is a low severity issue.\n\n**CergyK**\n\nEscalate\n\nEscalating based on latest comment:\n> Since DoS is not permanent where in as long as protocol/users themselves vote for the gauge, I think this is a low severity issue.\n\nIf we reach this case (`totalWeights == 0`), the DoS is permanent. There would be no other way to reset this variable, and all user funds would be locked permanently.\n\nIt is acknowledged that there is a low chance of this happening, but due to the severe impact and acknowledged validity this should be a medium \n\n**sherlock-admin2**\n\n > Escalate\n> \n> Escalating based on latest comment:\n> > Since DoS is not permanent where in as long as protocol/users themselves vote for the gauge, I think this is a low severity issue.\n> \n> If we reach this case (`totalWeights == 0`), the DoS is permanent. There would be no other way to reset this variable, and all user funds would be locked permanently.\n> \n> It is acknowledged that there is a low chance of this happening, but due to the severe impact and acknowledged validity this should be a medium \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@CergyK As mentioned by the sponsor, they will always ensure there is votes present to prevent this scenario, so I can see this as an \"admin error\" if the scenario is allowed to happen, but I also see your point given this was not made known to watsons. If totalWeight  goes to zero, it will indeed be irrecoverable.\n\nUnlikely but possible, so can be valid based on this sherlock [rule](https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue)\n\n> Causes a loss of funds but requires certain external conditions or specific states.\n\n**Czar102**\n\nI believe this impact warrants medium severity. Planning to accept the escalation.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [CergyK](https://github.com/sherlock-audit/2023-11-convergence-judging/issues/131/#issuecomment-1869562974): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/126",
  "Code": [
    {
      "filename": "sherlock-cvg/contracts/Rewards/CvgRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICvgControlTower.sol\";\nimport \"../interfaces/ICvgAssetStaking.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n/// @title Cvg-Finance - CvgRewards\n/// @notice Distribute rewards among staking contracts\n/// @dev The function in charge of distributing CVG rewards is following th estate machine pattern\ncontract CvgRewards is Ownable2StepUpgradeable {\n    enum State {\n        CHECKPOINT,\n        LOCK_TOTAL_WEIGHT,\n        DISTRIBUTE,\n        CONTROL_TOWER_SYNC\n    }\n\n    struct InflationInfo {\n        address gauge;\n        uint256 cvgDistributed;\n        uint256 gaugeWeight;\n    }\n\n    struct CvgRewardsConfig {\n        uint88 maxChunkCheckpoint;\n        uint88 maxLoopSetTotalWeight;\n        uint80 maxChunkDistribute;\n    }\n\n    event Checkpoints(uint256 cvgCycle);\n    event SetTotalWeight(uint256 cvgCycle, uint256 totalWeight);\n    event EventChunkWriteStakingRewards(uint256 cvgCycle, uint256 totalGaugeWeight, InflationInfo[] inflationInfos);\n    event InflationAdjustment(uint256 indexed cycleId, uint256 adjustment);\n    event StakingDistribution(uint256 indexed cycleId, address indexed gaugeAddress, uint256 amount);\n\n    /// @dev 60,576.46 CVG distributed each cycle on the first 105 cycles\n    uint256 public constant INITIAL_CYCLE_INFLATION = 60576923076923076923076;\n\n    /// @dev On cycle 1041, inflation doesn't reduce anymore\n    uint256 public constant END_INFLATION_CYCLE = 1041;\n\n    /// @dev After the 1561 cycle, 923.2354137 CVG are distributed by cycle\n    uint256 public constant END_INFLATION_AMOUNT = 1893028846153846164575;\n\n    /// @dev approximation value for square root of 2\n    uint256 private constant SQRT_2 = 1414213562373095048;\n\n    /// @dev each 105 cycles, inflation is reduced by SRQT2\n    uint256 private constant INFLATION_CHANGE_INTERVAL_CYCLE = 105;\n\n    /// @dev convergence ecosystem address\n    ICvgControlTower public cvgControlTower;\n\n    /// @dev Percentage of CVG to distribute weekly. Can be between 80% and 120% of the planned inflation.\n    ///      This can be used to augment or reduce the APR in CVG after votes from the DAO.\n    uint256 public inflationRatio;\n\n    /// @dev current rewards distribution state\n    State public state;\n\n    /// @dev current cursor, used to determine the starting index of the next chunk\n    uint128 public cursor;\n\n    /// @dev timestamp corresponding to the last update of the cvg cycle\n    uint256 public lastUpdatedTimestamp;\n\n    /// @dev sum of all gauges weight excluding killed ones\n    /// @dev this is reset and incremented at each cycle during the LOCK_TOTAL_WEIGHT step\n    uint256 public totalWeightLocked;\n\n    /// @dev configuration of the distribution process, contains chunks length to process\n    CvgRewardsConfig public cvgRewardsConfig;\n\n    /// @dev array containing the addresses of all gauges\n    address[] public gauges;\n\n    /// @dev mapping containing the ID of a gauge by its address\n    mapping(address => uint256) public gaugesId; // gauge address => ID\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            CONSTRUCTOR\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(ICvgControlTower _cvgControlTower) external initializer {\n        cvgControlTower = _cvgControlTower;\n        address _treasuryDao = _cvgControlTower.treasuryDao();\n        require(_treasuryDao != address(0), \"TREASURY_DAO_ZERO\");\n        _transferOwnership(_treasuryDao);\n        lastUpdatedTimestamp = block.timestamp;\n        cvgRewardsConfig = CvgRewardsConfig({\n            maxChunkCheckpoint: 50,\n            maxLoopSetTotalWeight: 50,\n            maxChunkDistribute: 50\n        });\n        inflationRatio = 10_000;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        ADMIN FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n     *  @notice update rewards distribution's configuration of chunks length\n     *  @param newConfig distribution's configuration\n     */\n    function setMaxChunkConfigs(CvgRewardsConfig calldata newConfig) external onlyOwner {\n        cvgRewardsConfig = newConfig;\n    }\n\n    /**\n     *  @notice Add a gauge in the gauge list\n     *  @param gaugeAddress gaugeAddress to add\n     */\n    function addGauge(address gaugeAddress) external {\n        require(address(cvgControlTower.gaugeController()) == msg.sender, \"NOT_GAUGE_CONTROLLER\");\n        gauges.push(gaugeAddress);\n        gaugesId[gaugeAddress] = gauges.length - 1;\n    }\n\n    /**\n     *  @notice Remove a gauge from the array, replace it by the last gauge of the array\n     *  @param gaugeAddress gaugeAddress to remove\n     */\n    function removeGauge(address gaugeAddress) external {\n        require(address(cvgControlTower.gaugeController()) == msg.sender, \"NOT_GAUGE_CONTROLLER\");\n        uint256 idGaugeToRemove = gaugesId[gaugeAddress];\n        address lastGauge = gauges[gauges.length - 1];\n\n        /// @dev replace id of last gauge by deleted one\n        gaugesId[lastGauge] = idGaugeToRemove;\n        /// @dev Set ID of gauge as 0\n        gaugesId[gaugeAddress] = 0;\n\n        /// @dev moove last gauge address to the id of the deleted one\n        gauges[idGaugeToRemove] = lastGauge;\n\n        /// @dev remove last array element\n        gauges.pop();\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        VIEW FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     *  @notice Compute the amount of CVG to be distributed through staking gauge contracts.\n                Made by subtracting the lastInflation with the one with the active stakingCycle\n     *  @param stakingCycle uint256\n     */\n    function stakingInflationAtCycle(uint256 stakingCycle) public view returns (uint256) {\n        if (stakingCycle <= 1) return 0;\n        if (stakingCycle >= END_INFLATION_CYCLE) return (END_INFLATION_AMOUNT * inflationRatio) / 10_000;\n\n        uint256 inflationTarget = INITIAL_CYCLE_INFLATION;\n        uint256 inflationCycle = stakingCycle / INFLATION_CHANGE_INTERVAL_CYCLE;\n\n        for (uint256 i; i < inflationCycle; ) {\n            inflationTarget = (inflationTarget * 10 ** 18) / SQRT_2;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (inflationTarget * inflationRatio) / 10_000;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                    EXTERNAL FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /// @notice start or continue the rewards distribution process\n    function writeStakingRewards() external {\n        State _state = state;\n        if (_state == State.CHECKPOINT) {\n            _checkpoints();\n        } else if (_state == State.LOCK_TOTAL_WEIGHT) {\n            _setTotalWeight();\n        } else if (_state == State.DISTRIBUTE) {\n            _distributeCvgRewards();\n        } else {\n            _triggerCvgCycle();\n        }\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                    INTERNAL FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /// @notice Refresh in a chunked way, all gauge weights in GaugeController\n    function _checkpoints() internal {\n        require(lastUpdatedTimestamp + 7 days <= block.timestamp, \"NEED_WAIT_7_DAYS\");\n\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        IGaugeController _gaugeController = _cvgControlTower.gaugeController();\n        uint128 _cursor = cursor;\n        uint128 _totalGaugeNumber = uint128(gauges.length);\n\n        /// @dev if first chunk, to don't break gauges votes if someone votes between 2 writeStakingRewards chunks we need to lock the gauge votes on GaugeController\n        if (_cursor == 0) {\n            /// @dev Lock votes\n            _gaugeController.set_lock(true);\n        }\n\n        /// @dev compute the theoretical end of the chunk\n        uint128 _maxEnd = _cursor + cvgRewardsConfig.maxChunkCheckpoint;\n        /// @dev compute the real end of the chunk regarding the length of the tAssetArray\n        uint128 _endChunk = _maxEnd < _totalGaugeNumber ? _maxEnd : _totalGaugeNumber;\n\n        /// @dev if last chunk of the checkpoint process\n        if (_endChunk == _totalGaugeNumber) {\n            /// @dev reset the cursor to 0 for _setTotalWeight\n            cursor = 0;\n            /// @dev set the step as LOCK_TOTAL_WEIGHT for reward distribution\n            state = State.LOCK_TOTAL_WEIGHT;\n        } else {\n            /// @dev setup the cursor at the index start for the next chunk\n            cursor = _endChunk;\n        }\n\n        /// @dev updates the weight of the chunked gauges\n        _gaugeController.gauge_relative_weight_writes(_getGaugeChunk(_cursor, _endChunk));\n\n        /// @dev emit the event only at the last chunk\n        if (_endChunk == _totalGaugeNumber) {\n            emit Checkpoints(_cvgControlTower.cvgCycle());\n        }\n    }\n\n    /// @notice get the total weight of all gauges excluding killed ones\n    function _setTotalWeight() internal {\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        IGaugeController _gaugeController = _cvgControlTower.gaugeController();\n        uint128 _cursor = cursor;\n        uint128 _totalGaugeNumber = uint128(gauges.length);\n\n        /// @dev compute the theoric end of the chunk\n        uint128 _maxEnd = _cursor + cvgRewardsConfig.maxLoopSetTotalWeight;\n        /// @dev compute the real end of the chunk regarding the length of staking contracts\n        uint128 _endChunk = _maxEnd < _totalGaugeNumber ? _maxEnd : _totalGaugeNumber;\n\n        /// @dev if last chunk of the total weighted locked processs\n        if (_endChunk == _totalGaugeNumber) {\n            /// @dev reset the cursor to 0 for _distributeRewards\n            cursor = 0;\n            /// @dev set the step as DISTRIBUTE for reward distribution\n            state = State.DISTRIBUTE;\n        } else {\n            /// @dev setup the cursor at the index start for the next chunk\n            cursor = _endChunk;\n        }\n\n        totalWeightLocked += _gaugeController.get_gauge_weight_sum(_getGaugeChunk(_cursor, _endChunk));\n\n        /// @dev emit the event only at the last chunk\n        if (_endChunk == _totalGaugeNumber) {\n            emit SetTotalWeight(_cvgControlTower.cvgCycle(), totalWeightLocked);\n        }\n    }\n\n    /**\n     *  @notice Compute the amount of CVG to be distributed through staking gauge contracts.\n     *  Made by getting the inflation of the current CVG cycle and dispersing tokens to staking contracts\n     *  according to the weight of their associated gauge\n     */\n    function _distributeCvgRewards() internal {\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        IGaugeController gaugeController = _cvgControlTower.gaugeController();\n\n        uint256 _cvgCycle = _cvgControlTower.cvgCycle();\n\n        /// @dev number of gauge in GaugeController\n        uint128 _totalGaugeNumber = uint128(gauges.length);\n        uint128 _cursor = cursor;\n\n        uint256 _totalWeight = totalWeightLocked;\n        /// @dev cursor of the end of the actual chunk\n        uint128 cursorEnd = _cursor + cvgRewardsConfig.maxChunkDistribute;\n\n        /// @dev if the new cursor is higher than the number of gauge, cursor become the number of gauge\n        if (cursorEnd > _totalGaugeNumber) {\n            cursorEnd = _totalGaugeNumber;\n        }\n\n        /// @dev reset the cursor if the distribution has been done\n        if (cursorEnd == _totalGaugeNumber) {\n            cursor = 0;\n\n            /// @dev reset the total weight of the gauge\n            totalWeightLocked = 0;\n\n            /// @dev update the states to the control_tower sync\n            state = State.CONTROL_TOWER_SYNC;\n        }\n        /// @dev update the global cursor in order to be taken into account on next chunk\n        else {\n            cursor = cursorEnd;\n        }\n\n        uint256 stakingInflation = stakingInflationAtCycle(_cvgCycle);\n        uint256 cvgDistributed;\n        InflationInfo[] memory inflationInfos = new InflationInfo[](cursorEnd - _cursor);\n        address[] memory addresses = _getGaugeChunk(_cursor, cursorEnd);\n        /// @dev fetch weight of gauge relative to the cursor\n        uint256[] memory gaugeWeights = gaugeController.get_gauge_weights(addresses);\n        for (uint256 i; i < gaugeWeights.length; ) {\n            /// @dev compute the amount of CVG to distribute in the gauge\n            cvgDistributed = (stakingInflation * gaugeWeights[i]) / _totalWeight;\n\n            /// @dev Write the amount of CVG to distribute in the staking contract\n            ICvgAssetStaking(addresses[i]).processStakersRewards(cvgDistributed);\n\n            inflationInfos[i] = InflationInfo({\n                gauge: addresses[i],\n                cvgDistributed: cvgDistributed,\n                gaugeWeight: gaugeWeights[i]\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit EventChunkWriteStakingRewards(_cvgCycle, _totalWeight, inflationInfos);\n    }\n\n    /// @notice Synchronize the Global Cvg Cycle on the CvgControlTower\n    function _triggerCvgCycle() internal {\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        _cvgControlTower.updateCvgCycle();\n        state = State.CHECKPOINT;\n        lastUpdatedTimestamp = block.timestamp;\n\n        /// @dev unlock the votes after that distribution is done\n        _cvgControlTower.gaugeController().set_lock(false);\n    }\n\n    function _getGaugeChunk(uint256 from, uint256 to) internal view returns (address[] memory) {\n        address[] memory chunk = new address[](to - from);\n        for (uint256 i = from; i < to; ) {\n            chunk[i - from] = gauges[i];\n            unchecked {\n                ++i;\n            }\n        }\n        return chunk;\n    }\n\n    struct GaugeView {\n        string symbol;\n        address stakingAddress;\n        uint256 weight;\n        uint256 typeWeight;\n        int128 gaugeType;\n    }\n\n    /**\n     * @notice get the total number of gauges\n     * @return number of gauges\n     */\n    function gaugesLength() external view returns (uint256) {\n        return gauges.length;\n    }\n\n    /**\n     * @notice get a list of gauges with pagination\n     * @param from beginning of the pagination\n     * @param to end of the pagination\n     * @return array containing gauges information\n     */\n    function getGaugeChunk(uint256 from, uint256 to) external view returns (GaugeView[] memory) {\n        uint256 _gaugesLength = gauges.length;\n        address[] memory chunk = _getGaugeChunk(from, to > _gaugesLength ? _gaugesLength : to);\n        uint256 chunkLength = chunk.length;\n        IGaugeController.WeightType[] memory votes = cvgControlTower.gaugeController().get_gauge_weights_and_types(\n            chunk\n        );\n\n        GaugeView[] memory gaugesView = new GaugeView[](chunkLength);\n        for (uint256 i; i < chunk.length; ) {\n            gaugesView[i] = GaugeView({\n                symbol: ICvgAssetStaking(chunk[i]).symbol(),\n                stakingAddress: chunk[i],\n                weight: votes[i].weight,\n                gaugeType: votes[i].gauge_type,\n                typeWeight: votes[i].type_weight\n            });\n            unchecked {\n                ++i;\n            }\n        }\n        return gaugesView;\n    }\n\n    /**\n     * @notice Set up the inflation ratio of the staking inflation.\n     *         Callable only by the DAO.\n     * @param _inflationRatio New inflation ratio, between 80% and 120%.\n     */\n    function setInflationRatio(uint256 _inflationRatio) external onlyOwner {\n        require(_inflationRatio >= 8_000 && _inflationRatio <= 12_000, \"RATIO_OUT_OF_RANGE\");\n        inflationRatio = _inflationRatio;\n    }\n}"
    }
  ]
}