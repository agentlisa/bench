{
  "Title": "[M-01] Borrowers can avoid liquidations, if ERC777 token is configured as an `emissionToken`",
  "Content": "\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/MErc20.sol#L139-L142> \n\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/MToken.sol#L1002> \n\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/MultiRewardDistributor/MultiRewardDistributor.sol#L1235-L1239>\n\nIf a borrower is `undercollateralized` then he can be liquidated by a liquidator by calling the `MErc20.liquidateBorrow` function. `liquidateBorrow` function calls the `MToken.liquidateBorrowFresh` in its execution process. Inside the `liquidateBorrowFresh` function the `MToken.repayBorrowFresh` is called which verifies whether repayment of borrowed amount is allowed by calling the `Comptroller.repayBorrowAllowed` function. The `repayBorrowAllowed` function updates the `borrower eligible rewards` by calling the `MultiRewardDistributor.updateMarketBorrowIndexAndDisburseBorrowerRewards`.\n\nThe `MultiRewardDistributor.updateMarketBorrowIndexAndDisburseBorrowerRewards` function calls the `disburseBorrowerRewardsInternal` to ditribute the multi rewards to the `borrower`.\nThe `disburseBorrowerRewardsInternal` calls the `sendReward` function if the `_sendTokens` flag is set to `true`.\n\n`sendReward` function is called for each `emissionConfig.config.emissionToken` token of the `MarketEmissionConfig[]` array of the given `_mToken` market.\n\n`sendReward` function transafers the rewards to the `borrower` using the `safeTransfer` function as shown below:\n\n            token.safeTransfer(_user, _amount);\n\nProblem here is that `emissionToken` can be `ERC777` token (which is backward compatible with ERC20) thus allowing a `malicious borrower` (the `recipient contract` of rewards in this case) to implement `tokensReceived` hook in its contract and revert the transaction inside the hook. This will revert the entire `liquidation` transaction. Hence the `undercollateralized borrower` can avoid the liquidation thus putting both depositors and protocol in danger.\n\n### Proof of Concept\n\n```solidity\n    function liquidateBorrow(address borrower, uint repayAmount, MTokenInterface mTokenCollateral) override external returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, mTokenCollateral);\n        return err;\n    }\n```\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/MErc20.sol#L139-L142>\n\n```solidity\n        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n```\n\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/MToken.sol#L1002>\n\n```solidity\n        if (_amount > 0 && _amount <= currentTokenHoldings) {\n            // Ensure we use SafeERC20 to revert even if the reward token isn't ERC20 compliant\n            token.safeTransfer(_user, _amount);\n            return 0;\n        } else {\n```\n\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/MultiRewardDistributor/MultiRewardDistributor.sol#L1235-L1239>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nHence it is recommended to disallow any ERC777 tokens being configured as `emissionToken` in any `MToken` market and only allow ERC20 tokens as `emissionTokens`.\n\n**[sorrynotsorry (Lookout) commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/343#issuecomment-1663473308):**\n > This logic is a bit off as the malicious user will not be having the ERC777 MToken rewards anyway, so the value extracted from this scenario doesn't match. \n> \n> > Only allow ERC20 tokens as emissionTokens\n> \n> Above mitigation recommendation is also matching the start of the submission. Erc777's are Erc20 tokens as well.\n> \n**[alcueca (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/343#issuecomment-1679011711):**\n > The finding shows that rewards are distributed as part of a liquidation.\n> \n> If an ERC777 token is set as an emissionsToken, which has transfer hooks, a malicious borrower can revert on receiving rewards, and avoid liquidation. Avoiding liquidation in certain situations accrues bad debt for the protocol, or can be compounded with other vulnerabilities. This would be a valid Medium.\n> \n> @ElliotFriedman, do you have in your documentation anything mentioning that ERC777 tokens should not be used as emission tokens?\n\n**[ElliotFriedman (Moonwell) confirmed and commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/343#issuecomment-1679335514):**\n > This is a valid finding.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-moonwell",
  "Code": [
    {
      "filename": "src/core/MErc20.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./MToken.sol\";\n\n/**\n * @title Moonwell's MErc20 Contract\n * @notice MTokens which wrap an EIP-20 underlying\n * @author Moonwell\n */\ncontract MErc20 is MToken, MErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(address underlying_,\n                        ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        // MToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives mTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) override external returns (uint) {\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Supply assets but without a 2-step approval process, EIP-2612\n     * @dev Simply calls the underlying token's `permit()` function and then assumes things worked\n     * @param mintAmount The amount of the underlying asset to supply\n     * @param deadline The amount of the underlying asset to supply\n     * @param v ECDSA recovery id for the signature\n     * @param r ECDSA r parameter for the signature\n     * @param s ECDSA s parameter for the signature\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mintWithPermit(\n        uint mintAmount,\n        uint deadline,\n        uint8 v, bytes32 r, bytes32 s\n    ) override external returns (uint) {\n        IERC20Permit token = IERC20Permit(underlying);\n\n        // Go submit our pre-approval signature data to the underlying token, but\n        // explicitly fail if there is an issue.\n        SafeERC20.safePermit(\n            token,\n            msg.sender, address(this),\n            mintAmount, deadline,\n            v, r, s\n        );\n\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems mTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of mTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) override external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems mTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) override external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) override external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or uint.max for the full outstanding amount\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) override external returns (uint) {\n        (uint err,) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or uint.max for the full outstanding amount\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this mToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param mTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint repayAmount, MTokenInterface mTokenCollateral) override external returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, mTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n     * @param token The address of the ERC-20 token to sweep\n     */\n    function sweepToken(EIP20NonStandardInterface token) override external {\n        require(msg.sender == admin, \"MErc20::sweepToken: only admin can sweep tokens\");\n        require(address(token) != underlying, \"MErc20::sweepToken: can not sweep underlying token\");\n    \tuint256 balance = token.balanceOf(address(this));\n    \ttoken.transfer(admin, balance);\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) override external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() virtual override internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) virtual override internal returns (uint) {\n        // Read from storage once\n        address underlying_ = underlying;\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\n        uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\n        token.transferFrom(from, address(this), amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                       // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                      // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) virtual override internal {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        token.transfer(to, amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                     // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of override external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n    }\n}"
    },
    {
      "filename": "src/core/MToken.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./MTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./IRModels/InterestRateModel.sol\";\n\n/**\n * @title Moonwell's MToken Contract\n * @notice Abstract base for MTokens\n * @author Moonwell\n */\nabstract contract MToken is MTokenInterface, Exponential, TokenErrorReporter {\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockTimestamp == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block timestamp and borrow index (block timestamp mocks depend on comptroller being set)\n        accrualBlockTimestamp = getBlockTimestamp();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block timestamp / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint).max;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != type(uint).max) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (uint.max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) override external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (uint.max means infinite)\n     */\n    function allowance(address owner, address spender) override external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) override external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) override external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\n        uint mTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), mTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block timestamp\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockTimestamp() virtual internal view returns (uint) {\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Returns the current per-timestamp borrow interest rate for this mToken\n     * @return The borrow interest rate per timestamp, scaled by 1e18\n     */\n    function borrowRatePerTimestamp() override external view returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-timestamp supply interest rate for this mToken\n     * @return The supply interest rate per timestamp, scaled by 1e18\n     */\n    function supplyRatePerTimestamp() override external view returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() override external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) override external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) override public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the MToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() override public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the MToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() virtual internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this mToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() override external view returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() virtual override public returns (uint) {\n        /* Remember the initial block timestamp */\n        uint currentBlockTimestamp = getBlockTimestamp();\n        uint accrualBlockTimestampPrior = accrualBlockTimestamp;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockTimestampPrior == currentBlockTimestamp) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockTimestamp, accrualBlockTimestampPrior);\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockTimestamp = currentBlockTimestamp;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives mTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives mTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block timestamp equals current block timestamp"
    }
  ]
}