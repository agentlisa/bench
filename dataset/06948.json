{
  "Title": "[M-05] Unsafe casting from `uint256` to `uint16` could cause ticket prizes to become much smaller than intended",
  "Content": "\nIn `LotterySetup.sol`, the `packFixedRewards()` function packs a `uint256` array into a `uint256` through bitwise arithmetic:\n\n[`LotterySetup.sol#L164-L176`](https://github.com/code-423n4/2023-03-wenwin/blob/main/src/LotterySetup.sol#L164-L176):\n\n```solidity\nfunction packFixedRewards(uint256[] memory rewards) private view returns (uint256 packed) {\n    if (rewards.length != (selectionSize) || rewards[0] != 0) {\n        revert InvalidFixedRewardSetup();\n    }\n    uint256 divisor = 10 ** (IERC20Metadata(address(rewardToken)).decimals() - 1);\n    for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n        uint16 reward = uint16(rewards[winTier] / divisor);\n        if ((rewards[winTier] % divisor) != 0) {\n            revert InvalidFixedRewardSetup();\n        }\n        packed |= uint256(reward) << (winTier * 16);\n    }\n}\n```\n\nThe `rewards[]` parameter stores the prize amount per each `winTier`, where `winTier` is the number of matching numbers a ticket has. `packFixedRewards()` is used when the lottery is first initialized to store the prize for each non-jackpot `winTier`.\n\nThe vulnerability lies in the following line:\n\n```solidity\nuint16 reward = uint16(rewards[winTier] / divisor);\n```\n\nIt casts `rewards[winTier] / divisor`, which is a `uint256`, to a `uint16`. If `rewards[winTier] / divisor` is larger than `2 ** 16 - 1`, the unsafe cast will only keep its rightmost bits, causing the result to be much smaller than defined in `rewards[]`.\n\nAs `divisor` is defined as `10 ** (tokenDecimals - 1)`, the upperbound of `rewards[winTier]` evaluates to `6553.5 * 10 ** tokenDecimals`. This means that the prize of any `winTier` must not be larger than 6553.5 tokens, otherwise the unsafe cast causes it to become smaller than expected.\n\n### Impact\n\nIf a deployer is unaware of this upper limit, he could deploy the lottery with ticket prizes larger than 6553.5 tokens, causing non-jackpot ticket prizes to become significantly smaller. The likelihood of this occuring is increased as:\n\n1.  The upper limit is not mentioned anywhere in the documentation.\n2.  The upper limit is not immediately obvious when looking at the code.\n\nThis upper limit also restricts the protocol from using low price tokens. For example, if the protocol uses SHIB (`$0.00001087` per token), the highest possible prize with 6553.5 tokens is worth only `$0.071236545`.\n\n### Proof of Concept\n\nIf the lottery is initialized with `rewards = [0, 6500, 7000]`, the prize for each `winTier` would become the following:\n\n| `winTier` | Token Amount (in tokenDecimals) |\n| --------- | ------------------------------- |\n| 0         | 0                               |\n| 1         | 6500                            |\n| 2         | 446                             |\n\nThe prize for `winTier = 2` can be derived as such:\n\n    (tokenAmount * 10) & type(uint16).max = (7000 * 10) & (2 ** 16 - 1) = 4464\n    4464 / 10 = 446\n\nThe following test demonstrates the above:\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/LotterySetup.sol\";\nimport \"./TestToken.sol\";\n\ncontract RewardUnsafeCastTest is Test {\n    ERC20 public rewardToken;\n\n    uint8 public constant SELECTION_SIZE = 3;\n    uint8 public constant SELECTION_MAX = 10;\n\n    function setUp() public {\n        rewardToken = new TestToken();\n    }\n\n    function testRewardIsSmallerThanExpected() public {\n        // Get 1 token unit\n        uint256 tokenUnit = 10 ** rewardToken.decimals();\n\n        // Define fixedRewards as [0, 6500, 7000]\n        uint256[] memory fixedRewards = new uint256[](SELECTION_SIZE);\n        fixedRewards[1] = 6500 * tokenUnit;\n        fixedRewards[2] = 7000 * tokenUnit;\n\n        // Initialize LotterySetup contract\n        LotterySetup lotterySetup = new LotterySetup(\n            LotterySetupParams(\n                rewardToken,\n                LotteryDrawSchedule(block.timestamp + 2*100, 100, 60),\n                5 ether,\n                SELECTION_SIZE,\n                SELECTION_MAX,\n                38e16,\n                fixedRewards\n            )\n        );\n\n        // Reward for winTier 1 is 6500\n        assertEq(lotterySetup.fixedReward(1) / tokenUnit, 6500);\n\n        // Reward for winTier 2 is 446 instead of 7000\n        assertEq(lotterySetup.fixedReward(2) / tokenUnit, 446);\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider storing the prize amount of each `winTier` in a mapping instead of packing them into a `uint256` using bitwise arithmetic. This approach removes the upper limit (6553.5) and lower limit (0.1) for prizes, which would allow the protocol to use tokens with extremely high or low prices.\n\nAlternatively, check if `rewards[winTier] > type(uint256).max` and revert if so. This can be done through OpenZeppelin's [SafeCast](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast-toUint16-uint256-).\n\n**[rand0c0des (Wenwin) confirmed](https://github.com/code-423n4/2023-03-wenwin-findings/issues/245)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-03-wenwin-contest",
  "Code": [
    {
      "filename": "src/LotterySetup.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"src/PercentageMath.sol\";\nimport \"src/LotteryToken.sol\";\nimport \"src/interfaces/ILotterySetup.sol\";\nimport \"src/Ticket.sol\";\n\ncontract LotterySetup is ILotterySetup {\n    using PercentageMath for uint256;\n\n    uint256 public immutable override minInitialPot;\n    uint256 public immutable override jackpotBound;\n\n    IERC20 public immutable override rewardToken;\n    IERC20 public immutable override nativeToken;\n\n    uint256 public immutable override ticketPrice;\n\n    uint256 public override initialPot;\n\n    uint256 public immutable override initialPotDeadline;\n    uint256 internal immutable firstDrawSchedule;\n    uint256 public immutable override drawPeriod;\n    uint256 public immutable override drawCoolDownPeriod;\n\n    uint8 public immutable override selectionSize;\n    uint8 public immutable override selectionMax;\n    uint256 public immutable override expectedPayout;\n\n    uint256 private immutable nonJackpotFixedRewards;\n\n    uint256 private constant BASE_JACKPOT_PERCENTAGE = 30_030; // 30.03%\n\n    /// @dev Constructs a new lottery contract\n    /// @param lotterySetupParams Setup parameter for the lottery\n    // solhint-disable-next-line code-complexity\n    constructor(LotterySetupParams memory lotterySetupParams) {\n        if (address(lotterySetupParams.token) == address(0)) {\n            revert RewardTokenZero();\n        }\n        if (lotterySetupParams.ticketPrice == uint256(0)) {\n            revert TicketPriceZero();\n        }\n        if (lotterySetupParams.selectionSize == 0) {\n            revert SelectionSizeZero();\n        }\n        if (lotterySetupParams.selectionMax >= 120) {\n            revert SelectionSizeMaxTooBig();\n        }\n        if (\n            lotterySetupParams.expectedPayout < lotterySetupParams.ticketPrice / 100\n                || lotterySetupParams.expectedPayout >= lotterySetupParams.ticketPrice\n        ) {\n            revert InvalidExpectedPayout();\n        }\n        if (\n            lotterySetupParams.selectionSize > 16 || lotterySetupParams.selectionSize >= lotterySetupParams.selectionMax\n        ) {\n            revert SelectionSizeTooBig();\n        }\n        if (\n            lotterySetupParams.drawSchedule.drawCoolDownPeriod >= lotterySetupParams.drawSchedule.drawPeriod\n                || lotterySetupParams.drawSchedule.firstDrawScheduledAt < lotterySetupParams.drawSchedule.drawPeriod\n        ) {\n            revert DrawPeriodInvalidSetup();\n        }\n        initialPotDeadline =\n            lotterySetupParams.drawSchedule.firstDrawScheduledAt - lotterySetupParams.drawSchedule.drawPeriod;\n        // slither-disable-next-line timestamp\n        if (initialPotDeadline < (block.timestamp + lotterySetupParams.drawSchedule.drawPeriod)) {\n            revert InitialPotPeriodTooShort();\n        }\n\n        nativeToken = new LotteryToken();\n        uint256 tokenUnit = 10 ** IERC20Metadata(address(lotterySetupParams.token)).decimals();\n        minInitialPot = 4 * tokenUnit;\n        jackpotBound = 2_000_000 * tokenUnit;\n        rewardToken = lotterySetupParams.token;\n        firstDrawSchedule = lotterySetupParams.drawSchedule.firstDrawScheduledAt;\n        drawPeriod = lotterySetupParams.drawSchedule.drawPeriod;\n        drawCoolDownPeriod = lotterySetupParams.drawSchedule.drawCoolDownPeriod;\n        ticketPrice = lotterySetupParams.ticketPrice;\n        selectionSize = lotterySetupParams.selectionSize;\n        selectionMax = lotterySetupParams.selectionMax;\n        expectedPayout = lotterySetupParams.expectedPayout;\n\n        nonJackpotFixedRewards = packFixedRewards(lotterySetupParams.fixedRewards);\n\n        emit LotteryDeployed(\n            lotterySetupParams.token,\n            lotterySetupParams.drawSchedule,\n            lotterySetupParams.ticketPrice,\n            lotterySetupParams.selectionSize,\n            lotterySetupParams.selectionMax,\n            lotterySetupParams.expectedPayout,\n            lotterySetupParams.fixedRewards\n        );\n    }\n\n    modifier requireJackpotInitialized() {\n        // slither-disable-next-line incorrect-equality\n        if (initialPot == 0) {\n            revert JackpotNotInitialized();\n        }\n        _;\n    }\n\n    modifier beforeTicketRegistrationDeadline(uint128 drawId) {\n        // slither-disable-next-line timestamp\n        if (block.timestamp > ticketRegistrationDeadline(drawId)) {\n            revert TicketRegistrationClosed(drawId);\n        }\n        _;\n    }\n\n    function fixedReward(uint8 winTier) public view override returns (uint256 amount) {\n        if (winTier == selectionSize) {\n            return _baseJackpot(initialPot);\n        } else if (winTier == 0 || winTier > selectionSize) {\n            return 0;\n        } else {\n            uint256 mask = uint256(type(uint16).max) << (winTier * 16);\n            uint256 extracted = (nonJackpotFixedRewards & mask) >> (winTier * 16);\n            return extracted * (10 ** (IERC20Metadata(address(rewardToken)).decimals() - 1));\n        }\n    }\n\n    function finalizeInitialPotRaise() external override {\n        if (initialPot > 0) {\n            revert JackpotAlreadyInitialized();\n        }\n        // slither-disable-next-line timestamp\n        if (block.timestamp <= initialPotDeadline) {\n            revert FinalizingInitialPotBeforeDeadline();\n        }\n        uint256 raised = rewardToken.balanceOf(address(this));\n        if (raised < minInitialPot) {\n            revert RaisedInsufficientFunds(raised);\n        }\n        initialPot = raised;\n\n        // must hold after this call, this will be used as a check that jackpot is initialized\n        assert(initialPot > 0);\n\n        emit InitialPotPeriodFinalized(raised);\n    }\n\n    function drawScheduledAt(uint128 drawId) public view override returns (uint256 time) {\n        time = firstDrawSchedule + (drawId * drawPeriod);\n    }\n\n    function ticketRegistrationDeadline(uint128 drawId) public view override returns (uint256 time) {\n        time = drawScheduledAt(drawId) - drawCoolDownPeriod;\n    }\n\n    function _baseJackpot(uint256 _initialPot) internal view returns (uint256) {\n        return Math.min(_initialPot.getPercentage(BASE_JACKPOT_PERCENTAGE), jackpotBound);\n    }\n\n    function packFixedRewards(uint256[] memory rewards) private view returns (uint256 packed) {\n        if (rewards.length != (selectionSize) || rewards[0] != 0) {\n            revert InvalidFixedRewardSetup();\n        }\n        uint256 divisor = 10 ** (IERC20Metadata(address(rewardToken)).decimals() - 1);\n        for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n            uint16 reward = uint16(rewards[winTier] / divisor);\n            if ((rewards[winTier] % divisor) != 0) {\n                revert InvalidFixedRewardSetup();\n            }\n            packed |= uint256(reward) << (winTier * 16);\n        }\n    }\n}"
    }
  ]
}