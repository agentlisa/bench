{
  "Title": "[L16] Uncommon ERC20 are not managed",
  "Content": "The [`ReserveSwapper` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L33) allows the `Governance` to list limit orders of ERC20 tokens.\n\n\nThere is no limitation on the type of ERC20 tokens that can be listed and swapped, but parallelly, tokens like the ERC20 [Tether `USDT`](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code) can have implicit fees that are accounted when transferring. However, this internal fees are not being handled by the `ReserveSwapper` contract.\n\n\nTherefore, the governance should be aware that the protocol currently does not fully support tokens that charge fees during transfers, and whitelisting such tokens can result in unexpected behavior, such as insolvency. If the protocol is expected to be compatible with these type of tokens, consider modifying the internal accounting mechanism to use the actual amount of assets deposited. One plausible approach would be to query the contract’s token balance before and after the execution of the token transfers to obtain the real amount of tokens deposited. For reference, consider how Compound’s protocol handles this scenario in their [CErc20 contract](https://github.com/compound-finance/compound-protocol/blob/857c223d84cc89d773d5248fb7a5c1c92b95e6d4/contracts/CErc20.sol#L142-L167).\n\n\n***Update**: Acknowledged. The EmptySetSquad team statement for this issue:*\n\n\n\n> \n> *Updated docs with a guide on acceptable ERC20 properties for [governance](https://emptysetsquad.gitbook.io/continuous-esd/governance).*\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/reserve/ReserveSwapper.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"./ReserveComptroller.sol\";\nimport \"./ReserveState.sol\";\n\n/**\n * @title ReserveSwapper\n * @notice Logic for managing outstanding limit orders, allow the reserve to swap its held tokens\n */\ncontract ReserveSwapper is ReentrancyGuard, ReserveComptroller {\n    using SafeMath for uint256;\n    using Decimal for Decimal.D256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `amount` of the `makerToken`-`takerToken` order is registered with price `price`\n     */\n    event OrderRegistered(address indexed makerToken, address indexed takerToken, uint256 price, uint256 amount);\n\n    /**\n     * @notice Emitted when the reserve pays `takerAmount` of `takerToken` in exchange for `makerAmount` of `makerToken`\n     */\n    event Swap(address indexed makerToken, address indexed takerToken, uint256 takerAmount, uint256 makerAmount);\n\n    /**\n     * @notice Sets the `price` and `amount` of the specified `makerToken`-`takerToken` order\n     * @dev Owner only - governance hook\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the reserve wishes to sell\n     * @param takerToken Token that the reserve wishes to buy\n     * @param price Price as a ratio of takerAmount:makerAmount times 10^18\n     * @param amount Amount to decrement in ESD\n     */\n    function registerOrder(address makerToken, address takerToken, uint256 price, uint256 amount) external onlyOwner {\n        _updateOrder(makerToken, takerToken, price, amount);\n\n        emit OrderRegistered(makerToken, takerToken, price, amount);\n    }\n\n    /**\n     * @notice Purchases `makerToken` from the reserve in exchange for `takerAmount` of `takerToken`\n     * @dev Non-reentrant\n     *      Uses the state-defined price for the `makerToken`-`takerToken` order\n     *      Maker and taker tokens must be different\n     *      Cannot swap ESD\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the caller wishes to buy\n     * @param takerToken Token that the caller wishes to sell\n     * @param takerAmount Amount of takerToken to sell\n     */\n    function swap(address makerToken, address takerToken, uint256 takerAmount) external nonReentrant {\n        address dollar = registry().dollar();\n        require(makerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(takerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(makerToken != takerToken, \"ReserveSwapper: tokens equal\");\n\n        ReserveTypes.Order memory order = order(makerToken, takerToken);\n        uint256 makerAmount = Decimal.from(takerAmount).div(order.price, \"ReserveSwapper: no order\").asUint256();\n\n        if (order.amount != uint256(-1))\n            _decrementOrderAmount(makerToken, takerToken, makerAmount, \"ReserveSwapper: insufficient amount\");\n\n        _transferFrom(takerToken, msg.sender, address(this), takerAmount);\n        _transfer(makerToken, msg.sender, makerAmount);\n\n        emit Swap(makerToken, takerToken, takerAmount, makerAmount);\n    }\n}"
    },
    {
      "filename": "contracts/CErc20.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(address underlying_,\n                        ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        // CToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) internal returns (uint) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        token.transferFrom(from, address(this), amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                       // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                      // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) internal {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        token.transfer(to, amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n    }\n}"
    }
  ]
}