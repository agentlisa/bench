{
  "Title": "[M-07] Funds can be stuck due to wrong order of operations",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81-L87\n\n\n# Vulnerability details\n\n## Impact\nThe contract `ERC20Quest.sol` has two functions of interest here. The first is `withdrawFee()`, which is responsible for transferring out the fee amount from the contract once endTime has been passed, and the second is `withdrawRemainingTokens()` which recovers the remaining tokens in the contract which haven't been claimed yet.\n\nFunction `withdrawRemainingTokens()`:\n```solidity\nfunction withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n    }\n```\n\nAs evident from this excerpt, calling this recovery function subtracts the tokens which are already assigned to someone who completed the quest, and the fee, and returns the rest. However, there is no check for whether the fee has already been paid or not. The owner is expected to first call `withdrawRemainingTokens()`, and then call `withdrawFee()`.\n\nHowever, if the owner calls `withdrawFee()` before calling the function `withdrawRemainingTokens()`, the fee will be paid out by the first call, but the same fee amount will still be kept in the contract after the second function call, basically making it unrecoverable. Since there are no checks in place to prevent this, this is classified as a high severity since it is an easy mistake to make and leads to loss of funds of the owner.\n\n## Proof of Concept\n\nThis can be demonstrated with this test\n```javascript\ndescribe('Funds stuck due to wrong order of function calls', async () => {\n    it('should trap funds', async () => {\n      await deployedFactoryContract.connect(firstAddress).mintReceipt(questId, messageHash, signature)\n      await deployedQuestContract.start()\n      await ethers.provider.send('evm_increaseTime', [86400])\n      await deployedQuestContract.connect(firstAddress).claim()\n\n      await ethers.provider.send('evm_increaseTime', [100001])\n      await deployedQuestContract.withdrawFee()\n      await deployedQuestContract.withdrawRemainingTokens(owner.address)\n\n      expect(await deployedSampleErc20Contract.balanceOf(deployedQuestContract.address)).to.equal(200)\n      expect(await deployedSampleErc20Contract.balanceOf(owner.address)).to.be.lessThan(\n        totalRewardsPlusFee * 100 - 1 * 1000 - 200\n      )\n      await ethers.provider.send('evm_increaseTime', [-100001])\n      await ethers.provider.send('evm_increaseTime', [-86400])\n    })\n  })\n```\nEven though the fee is paid, the contract still retains the fee amount. The owner receives less than the expected amount. This test is a modification of the test `should transfer non-claimable rewards back to owner` already present in `ERC20Quest.spec.ts`.\n## Tools Used\nHardhat\n## Recommended Mitigation Steps\nOnly allow fee to be withdrawn after the owner has withdrawn the funds. \n```solidity\n// Declare a boolean to check if recovery happened\nbool recoveryDone;\n\nfunction withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n   \n        // Set recovery bool\n        recoveryDone = true;\n    }\nfunction withdrawFee() public onlyAdminWithdrawAfterEnd {\n        // Check recovery\n        require(recoveryDone,\"Recover tokens before withdrawing Fees\");\n        IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n    }\n```\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/Erc20Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Quest} from './Quest.sol';\nimport {QuestFactory} from './QuestFactory.sol';\n\n/// @title Erc20Quest\n/// @author RabbitHole.gg\n/// @notice This contract is used to create a quest that rewards ERC20 tokens.\ncontract Erc20Quest is Quest {\n    using SafeERC20 for IERC20;\n    uint256 public immutable questFee;\n    address public immutable protocolFeeRecipient;\n    QuestFactory public immutable questFactoryContract;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_,\n        uint256 questFee_,\n        address protocolFeeRecipient_\n    )\n        Quest(\n            rewardTokenAddress_,\n            endTime_,\n            startTime_,\n            totalParticipants_,\n            rewardAmountInWeiOrTokenId_,\n            questId_,\n            receiptContractAddress_\n        )\n    {\n        questFee = questFee_;\n        protocolFeeRecipient = protocolFeeRecipient_;\n        questFactoryContract = QuestFactory(msg.sender);\n    }\n\n    /// @dev Function that gets the maximum amount of rewards that can be claimed by all users. It does not include the protocol fee\n    /// @return The maximum amount of rewards that can be claimed by all users\n    function maxTotalRewards() public view returns (uint256) {\n        return totalParticipants * rewardAmountInWeiOrTokenId;\n    }\n\n    /// @notice Function that gets the maximum amount of rewards that can be claimed by the protocol or the quest deployer\n    /// @dev The 10_000 comes from Basis Points: https://www.investopedia.com/terms/b/basispoint.asp\n    /// @return The maximum amount of rewards that can be claimed by the protocol or the quest deployer\n    function maxProtocolReward() public view returns (uint256) {\n        return (maxTotalRewards() * questFee) / 10_000;\n    }\n\n    /// @notice Starts the quest by marking it ready to start at the contract level. Marking a quest ready to start does not mean that it is live. It also requires that the start time has passed\n    /// @dev Requires that the balance of the rewards in the contract is greater than or equal to the maximum amount of rewards that can be claimed by all users and the protocol\n    function start() public override {\n        if (IERC20(rewardToken).balanceOf(address(this)) < maxTotalRewards() + maxProtocolReward())\n            revert TotalAmountExceedsBalance();\n        super.start();\n    }\n\n    /// @notice Internal function that transfers the rewards to the msg.sender\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal override {\n        IERC20(rewardToken).safeTransfer(msg.sender, amount_);\n    }\n\n    /// @notice Internal function that calculates the reward amount\n    /// @dev It is possible for users to have multiple receipts (if they buy others on secondary markets)\n    /// @param redeemableTokenCount_ The amount of tokens that can be redeemed\n    /// @return The total amount of rewards that can be claimed by a user\n    function _calculateRewards(uint256 redeemableTokenCount_) internal view override returns (uint256) {\n        return redeemableTokenCount_ * rewardAmountInWeiOrTokenId;\n    }\n\n    /// @notice Function that allows the owner to withdraw the remaining tokens in the contract\n    /// @dev Every receipt minted should still be able to claim rewards (and cannot be withdrawn). This function can only be called after the quest end time\n    /// @param to_ The address to send the remaining tokens to\n    function withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n    }\n\n    /// @notice Call the QuestFactory contract to get the amount of receipts that have been minted\n    /// @return The amount of receipts that have been minted for the given quest\n    function receiptRedeemers() public view returns (uint256) {\n        return questFactoryContract.getNumberMinted(questId);\n    }\n\n    /// @notice Function that calculates the protocol fee\n    function protocolFee() public view returns (uint256) {\n        return (receiptRedeemers() * rewardAmountInWeiOrTokenId * questFee) / 10_000;\n    }\n\n    /// @notice Sends the protocol fee to the protocolFeeRecipient\n    /// @dev Only callable when the quest is ended\n    function withdrawFee() public onlyAdminWithdrawAfterEnd {\n        IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n    }\n}"
    },
    {
      "filename": "contracts/Erc20Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Quest} from './Quest.sol';\nimport {QuestFactory} from './QuestFactory.sol';\n\n/// @title Erc20Quest\n/// @author RabbitHole.gg\n/// @notice This contract is used to create a quest that rewards ERC20 tokens.\ncontract Erc20Quest is Quest {\n    using SafeERC20 for IERC20;\n    uint256 public immutable questFee;\n    address public immutable protocolFeeRecipient;\n    QuestFactory public immutable questFactoryContract;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_,\n        uint256 questFee_,\n        address protocolFeeRecipient_\n    )\n        Quest(\n            rewardTokenAddress_,\n            endTime_,\n            startTime_,\n            totalParticipants_,\n            rewardAmountInWeiOrTokenId_,\n            questId_,\n            receiptContractAddress_\n        )\n    {\n        questFee = questFee_;\n        protocolFeeRecipient = protocolFeeRecipient_;\n        questFactoryContract = QuestFactory(msg.sender);\n    }\n\n    /// @dev Function that gets the maximum amount of rewards that can be claimed by all users. It does not include the protocol fee\n    /// @return The maximum amount of rewards that can be claimed by all users\n    function maxTotalRewards() public view returns (uint256) {\n        return totalParticipants * rewardAmountInWeiOrTokenId;\n    }\n\n    /// @notice Function that gets the maximum amount of rewards that can be claimed by the protocol or the quest deployer\n    /// @dev The 10_000 comes from Basis Points: https://www.investopedia.com/terms/b/basispoint.asp\n    /// @return The maximum amount of rewards that can be claimed by the protocol or the quest deployer\n    function maxProtocolReward() public view returns (uint256) {\n        return (maxTotalRewards() * questFee) / 10_000;\n    }\n\n    /// @notice Starts the quest by marking it ready to start at the contract level. Marking a quest ready to start does not mean that it is live. It also requires that the start time has passed\n    /// @dev Requires that the balance of the rewards in the contract is greater than or equal to the maximum amount of rewards that can be claimed by all users and the protocol\n    function start() public override {\n        if (IERC20(rewardToken).balanceOf(address(this)) < maxTotalRewards() + maxProtocolReward())\n            revert TotalAmountExceedsBalance();\n        super.start();\n    }\n\n    /// @notice Internal function that transfers the rewards to the msg.sender\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal override {\n        IERC20(rewardToken).safeTransfer(msg.sender, amount_);\n    }\n\n    /// @notice Internal function that calculates the reward amount\n    /// @dev It is possible for users to have multiple receipts (if they buy others on secondary markets)\n    /// @param redeemableTokenCount_ The amount of tokens that can be redeemed\n    /// @return The total amount of rewards that can be claimed by a user\n    function _calculateRewards(uint256 redeemableTokenCount_) internal view override returns (uint256) {\n        return redeemableTokenCount_ * rewardAmountInWeiOrTokenId;\n    }\n\n    /// @notice Function that allows the owner to withdraw the remaining tokens in the contract\n    /// @dev Every receipt minted should still be able to claim rewards (and cannot be withdrawn). This function can only be called after the quest end time\n    /// @param to_ The address to send the remaining tokens to\n    function withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n    }\n\n    /// @notice Call the QuestFactory contract to get the amount of receipts that have been minted\n    /// @return The amount of receipts that have been minted for the given quest\n    function receiptRedeemers() public view returns (uint256) {\n        return questFactoryContract.getNumberMinted(questId);\n    }\n\n    /// @notice Function that calculates the protocol fee\n    function protocolFee() public view returns (uint256) {\n        return (receiptRedeemers() * rewardAmountInWeiOrTokenId * questFee) / 10_000;\n    }\n\n    /// @notice Sends the protocol fee to the protocolFeeRecipient\n    /// @dev Only callable when the quest is ended\n    function withdrawFee() public onlyAdminWithdrawAfterEnd {\n        IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n    }\n}"
    }
  ]
}