{
  "Title": "[M-18] Incorrect calculations in `debtCeiling`",
  "Content": "\nIncorrect `debtCeiling` value will prevent users from withdrawing Guild tokens out of the gauge.\n\n### Proof of Concept\n\nIf there is a loan in the gauge and user wants to decrement the weight, we need to check it's ceiling first:\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L224-L231>\n\n            // check if gauge is currently using its allocated debt ceiling.\n            // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.\n            uint256 issuance = LendingTerm(gauge).issuance();\n            if (issuance != 0) {\n                uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n                require(\n                    issuance <= debtCeilingAfterDecrement,\n                    \"GuildToken: debt ceiling used\"\n                );\n            }\n\n This is needed to ensure that loans are distributed between the gauges according to their weights and tolerance. This only matters if there are multiple gauges of the same type. If there is, only one gauge ceiling is limited by the hardcap and the minter buffer. \n \n <https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L287>\n\n            } else if (gaugeWeight == totalWeight) {\n                // one gauge, unlimited debt ceiling\n                // returns min(hardCap, creditMinterBuffer)\n                return\n                    _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n            }\n\nUnfortunately, `debtCeiling(int256 gaugeWeightDelta)` applies delta only to the `gaugeWeight` leaving `totalWeight` as-is:\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L270>\n\n        function debtCeiling(\n            int256 gaugeWeightDelta\n        ) public view returns (uint256) {\n            address _guildToken = refs.guildToken; // cached SLOAD\n            uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(\n                address(this)\n            );\n            gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);\n            uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this));\n            uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(\n                gaugeType\n            );\n\nCheck this test case for `GuildToken.t.sol`, where the user is unable to withdraw tokens from the gauge even it it's the only gauge of it's type and ceiling should be \"unlimited\".\n\nModify `debtCeiling` to act like a `LendingTerm`:\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/test/unit/tokens/GuildToken.t.sol#L27>\n\n\n        function debtCeiling(int256 gaugeWeightDelta) public view returns (uint256) {\n            uint256 gaugeWeight = token.getGaugeWeight(address(this));\n            gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);\n            uint256 gaugeType = token.gaugeType(address(this));\n            uint256 totalWeight = token.totalTypeWeight(gaugeType);\n            if (gaugeWeight == 0) {\n                return 0; // no gauge vote, 0 debt ceiling\n            } else if (gaugeWeight == totalWeight) {\n                // one gauge, unlimited debt ceiling\n                // return unlimited\n                return 1_000_000 ether;\n            }\n            uint256 _issuance = issuance; // cached SLOAD\n            uint256 totalBorrowedCredit = credit.totalSupply();\n            uint256 gaugeWeightTolerance = 1e18;\n            if (totalBorrowedCredit == 0 && gaugeWeight != 0) {\n                // first-ever CREDIT mint on a non-zero gauge weight term\n                // does not check the relative debt ceilings\n                return 1_000_000 ether;\n            }\n            uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /\n                1e18;\n            uint256 debtCeilingBefore = (totalBorrowedCredit *\n                toleratedGaugeWeight) / totalWeight;\n            if (_issuance >= debtCeilingBefore) {\n                return debtCeilingBefore; // no more borrows allowed\n            }\n            uint256 remainingDebtCeiling = debtCeilingBefore - _issuance; // always >0\n            if (toleratedGaugeWeight >= totalWeight) {\n                // if the gauge weight is above 100% when we include tolerance,\n                // the gauge relative debt ceilings are not constraining.\n                return 1_000_000 ether;\n            }\n            uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight; // always >0\n            uint256 maxBorrow = (remainingDebtCeiling * totalWeight) /\n                otherGaugesWeight;\n            uint256 _debtCeiling = _issuance + maxBorrow;\n            // return min(creditMinterBuffer, hardCap, debtCeiling)\n            if (1_000_000 ether < _debtCeiling) {\n                return 1_000_000 ether;\n            }\n            return _debtCeiling;\n        }\n\nrun the test\n\n        function testDebtCeilingOneGauge() public {\n            // grant roles to test contract\n            vm.startPrank(governor);\n            core.grantRole(CoreRoles.CREDIT_MINTER, address(this));\n            core.grantRole(CoreRoles.GUILD_MINTER, address(this));\n            core.grantRole(CoreRoles.GAUGE_ADD, address(this));\n            core.grantRole(CoreRoles.GAUGE_REMOVE, address(this));\n            core.grantRole(CoreRoles.GAUGE_PARAMETERS, address(this));\n            vm.stopPrank();\n\n            // setup\n            token.mint(alice, 100e18);\n\n            token.setMaxGauges(3);\n            token.addGauge(1, address(this));\n\n            vm.startPrank(alice);\n            token.incrementGauge(address(this), 10e18);\n            vm.stopPrank();\n\n            credit.mint(alice, 100e18);\n            issuance = 100e18;\n\n            vm.prank(alice);\n            // will revert with \"GuildToken: debt ceiling used\"\n            token.decrementGauge(address(this), 8e18);\n        }\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nApply delta to `totalWeight` as well:\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L270>\n\n        function debtCeiling(\n            int256 gaugeWeightDelta\n        ) public view returns (uint256) {\n            address _guildToken = refs.guildToken; // cached SLOAD\n            uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(\n                address(this)\n            );\n            gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);\n            uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this));\n            uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(\n               gaugeType\n            );\n    +     totalWeight = uint256(int256(totalWeight) + gaugeWeightDelta);\n\n### Assessed type\n\nMath\n\n**[eswak (Ethereum Credit Guild) confirmed via duplicate issue #880](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/880#issuecomment-1893219121)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/tokens/GuildToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {ERC20Gauges} from \"@src/tokens/ERC20Gauges.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {ERC20MultiVotes} from \"@src/tokens/ERC20MultiVotes.sol\";\n\n/** \n@title  GUILD ERC20 Token\n@author eswak\n@notice This is the governance token of the Ethereum Credit Guild.\n    On deploy, this token is non-transferrable.\n    During the non-transferrable period, GUILD can still be minted & burnt, only\n    `transfer` and `transferFrom` are reverting.\n\n    The gauge system is used to define debt ceilings on a set of lending terms.\n    Lending terms can be whitelisted by adding a gauge for their address, if GUILD\n    holders vote for these lending terms in the gauge system, the lending terms will\n    have a non-zero debt ceiling, and borrowing will be available under these terms.\n\n    When a lending term creates bad debt, a loss is notified in a gauge on this\n    contract (`notifyGaugeLoss`). When a loss is notified, all the GUILD token weight voting\n    for this gauge becomes non-transferable and can be permissionlessly slashed. Until the\n    loss is realized (`applyGaugeLoss`), a user cannot transfer their locked tokens or\n    decrease the weight they assign to the gauge that suffered a loss.\n    Even when a loss occur, users can still transfer tokens with which they vote for gauges\n    that did not suffer a loss.\n*/\ncontract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice reference to ProfitManager\n    address public profitManager;\n\n    constructor(\n        address _core,\n        address _profitManager\n    )\n        CoreRef(_core)\n        ERC20(\"Ethereum Credit Guild - GUILD\", \"GUILD\")\n        ERC20Permit(\"Ethereum Credit Guild - GUILD\")\n    {\n        profitManager = _profitManager;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTING MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set `maxDelegates`, the maximum number of addresses any account can delegate voting power to.\n    function setMaxDelegates(\n        uint256 newMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setMaxDelegates(newMax);\n    }\n\n    /// @notice Allow or disallow an address to delegate voting power to more addresses than `maxDelegates`.\n    function setContractExceedMaxDelegates(\n        address account,\n        bool canExceedMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setContractExceedMaxDelegates(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n    function addGauge(\n        uint256 _type,\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) {\n        return _addGauge(_type, gauge);\n    }\n\n    function removeGauge(\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) {\n        _removeGauge(gauge);\n    }\n\n    function setMaxGauges(\n        uint256 max\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setMaxGauges(max);\n    }\n\n    function setCanExceedMaxGauges(\n        address who,\n        bool can\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setCanExceedMaxGauges(who, can);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LOSS MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when a loss in a gauge is notified.\n    event GaugeLoss(address indexed gauge, uint256 indexed when);\n    /// @notice emitted when a loss in a gauge is applied (for each user).\n    event GaugeLossApply(\n        address indexed gauge,\n        address indexed who,\n        uint256 weight,\n        uint256 when\n    );\n\n    /// @notice last block.timestamp when a loss occurred in a given gauge\n    mapping(address => uint256) public lastGaugeLoss;\n\n    /// @notice last block.timestamp when a user apply a loss that occurred in a given gauge\n    mapping(address => mapping(address => uint256)) public lastGaugeLossApplied;\n\n    /// @notice notify loss in a given gauge\n    function notifyGaugeLoss(address gauge) external {\n        require(msg.sender == profitManager, \"UNAUTHORIZED\");\n\n        // save gauge loss\n        lastGaugeLoss[gauge] = block.timestamp;\n        emit GaugeLoss(gauge, block.timestamp);\n    }\n\n    /// @notice apply a loss that occurred in a given gauge\n    /// anyone can apply the loss on behalf of anyone else\n    function applyGaugeLoss(address gauge, address who) external {\n        // check preconditions\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];\n        require(\n            _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,\n            \"GuildToken: no loss to apply\"\n        );\n\n        // read user weight allocated to the lossy gauge\n        uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];\n\n        // remove gauge weight allocation\n        lastGaugeLossApplied[gauge][who] = block.timestamp;\n        _decrementGaugeWeight(who, gauge, _userGaugeWeight);\n        if (!_deprecatedGauges.contains(gauge)) {\n            totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;\n            totalWeight -= _userGaugeWeight;\n        }\n\n        // apply loss\n        _burn(who, uint256(_userGaugeWeight));\n        emit GaugeLossApply(\n            gauge,\n            who,\n            uint256(_userGaugeWeight),\n            block.timestamp\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        TRANSFERABILITY\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice at deployment, tokens are not transferable (can only mint/burn).\n    /// Governance can enable transfers with `enableTransfers()`.\n    bool public transferable; // default = false\n\n    /// @notice emitted when transfers are enabled.\n    event TransfersEnabled(uint256 block, uint256 timestamp);\n\n    /// @notice permanently enable token transfers.\n    function enableTransfer() external onlyCoreRole(CoreRoles.GOVERNOR) {\n        transferable = true;\n        emit TransfersEnabled(block.number, block.timestamp);\n    }\n\n    /// @dev prevent transfers if they are not globally enabled.\n    /// mint and burn (transfers to and from address 0) are accepted.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* amount*/\n    ) internal view override {\n        require(\n            transferable || from == address(0) || to == address(0),\n            \"GuildToken: transfers disabled\"\n        );\n    }\n\n    /// @notice emitted when reference to ProfitManager is updated\n    event ProfitManagerUpdated(uint256 timestamp, address newValue);\n\n    /// @notice set reference to ProfitManager\n    function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        profitManager = _newProfitManager;\n        emit ProfitManagerUpdated(block.timestamp, _newProfitManager);\n    }\n\n    /// @dev prevent outbound token transfers (_decrementWeightUntilFree) and gauge weight decrease\n    /// (decrementGauge, decrementGauges) for users who have an unrealized loss in a gauge, or if the\n    /// gauge is currently using its allocated debt ceiling. To decrement gauge weight, guild holders\n    /// might have to call loans if the debt ceiling is used.\n    /// Also update the user profit index and claim rewards.\n    function _decrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        require(\n            _lastGaugeLossApplied >= _lastGaugeLoss,\n            \"GuildToken: pending loss\"\n        );\n\n        // update the user profit index and claim rewards\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        // check if gauge is currently using its allocated debt ceiling.\n        // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.\n        uint256 issuance = LendingTerm(gauge).issuance();\n        if (issuance != 0) {\n            uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n            require(\n                issuance <= debtCeilingAfterDecrement,\n                \"GuildToken: debt ceiling used\"\n            );\n        }\n\n        super._decrementGaugeWeight(user, gauge, weight);\n    }\n\n    /// @dev prevent weight increment for gauge if user has an unapplied loss.\n    /// If the user has 0 weight (i.e. no loss to realize), allow incrementing\n    /// gauge weight & update lastGaugeLossApplied to current time.\n    /// Also update the user profit index an claim rewards.\n    /// @dev note that users voting for a gauge that is not a proper lending term could result in this\n    /// share of the user's tokens to be frozen, due to being unable to decrement weight.\n    function _incrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        if (getUserGaugeWeight[user][gauge] == 0) {\n            lastGaugeLossApplied[gauge][user] = block.timestamp;\n        } else {\n            require(\n                _lastGaugeLossApplied >= _lastGaugeLoss,\n                \"GuildToken: pending loss\"\n            );\n        }\n\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        super._incrementGaugeWeight(user, gauge, weight);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        MINT / BURN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice mint new tokens to the target address\n    function mint(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_MINTER) {\n        _mint(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Inheritance reconciliation\n    //////////////////////////////////////////////////////////////*/\n\n    function _burn(\n        address from,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        ERC20._burn(from, amount);\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(msg.sender, amount);\n        _decrementVotesUntilFree(msg.sender, amount);\n        return ERC20.transfer(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        return ERC20.transferFrom(from, to, amount);\n    }\n}"
    },
    {
      "filename": "src/loan/LendingTerm.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {AuctionHouse} from \"@src/loan/AuctionHouse.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice Lending Term contract of the Ethereum Credit Guild, a base implementation of\n/// smart contract issuing CREDIT debt and escrowing collateral assets.\n/// Note that interest rate is non-compounding and the percentage is expressed per\n/// period of `YEAR` seconds.\ncontract LendingTerm is CoreRef {\n    using SafeERC20 for IERC20;\n\n    // events for the lifecycle of loans that happen in the lending term\n    /// @notice emitted when new loans are opened (mint debt to borrower, pull collateral from borrower).\n    event LoanOpen(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed borrower,\n        uint256 collateralAmount,\n        uint256 borrowAmount\n    );\n    /// @notice emitted when a loan is called.\n    event LoanCall(uint256 indexed when, bytes32 indexed loanId);\n    /// @notice emitted when a loan is closed (repay, onBid after a call, forgive).\n    enum LoanCloseType {\n        Repay,\n        Call,\n        Forgive\n    }\n    event LoanClose(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        LoanCloseType indexed closeType,\n        uint256 debtRepaid\n    );\n    /// @notice emitted when someone adds collateral to a loan\n    event LoanAddCollateral(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed borrower,\n        uint256 collateralAmount\n    );\n    /// @notice emitted when someone partially repays a loan\n    event LoanPartialRepay(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed repayer,\n        uint256 repayAmount\n    );\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice timestamp of last partial repayment for a given loanId.\n    /// during borrow(), this is initialized to the borrow timestamp, if\n    /// maxDelayBetweenPartialRepay is != 0\n    mapping(bytes32 => uint256) public lastPartialRepay;\n\n    struct Loan {\n        address borrower; // address of a loan's borrower\n        uint256 borrowTime; // the time the loan was initiated\n        uint256 borrowAmount; // initial CREDIT debt of a loan\n        uint256 borrowCreditMultiplier; // creditMultiplier when loan was opened\n        uint256 collateralAmount; // balance of collateral token provided by the borrower\n        address caller; // a caller of 0 indicates that the loan has not been called\n        uint256 callTime; // a call time of 0 indicates that the loan has not been called\n        uint256 callDebt; // the CREDIT debt when the loan was called\n        uint256 closeTime; // the time the loan was closed (repaid or call+bid or forgive)\n    }\n\n    /// @notice the list of all loans that existed or are still active.\n    /// @dev see public getLoan(loanId) getter.\n    mapping(bytes32 => Loan) internal loans;\n\n    /// @notice current number of CREDIT issued in active loans on this term\n    /// @dev this can be lower than the sum of all loan's CREDIT debts because\n    /// interests accrue and some loans might have been opened before the creditMultiplier\n    /// was last updated, resulting in higher CREDIT debt than what was originally borrowed.\n    uint256 public issuance;\n\n    struct LendingTermReferences {\n        /// @notice reference to the ProfitManager\n        address profitManager;\n        /// @notice reference to the GUILD token\n        address guildToken;\n        /// @notice reference to the auction house contract used to\n        /// sell loan collateral for CREDIT if loans are called.\n        address auctionHouse;\n        /// @notice reference to the credit minter contract\n        address creditMinter;\n        /// @notice reference to the CREDIT token\n        address creditToken;\n    }\n\n    /// @notice References to other protocol contracts (see struct for more details)\n    LendingTermReferences internal refs;\n\n    struct LendingTermParams {\n        /// @notice reference to the collateral token\n        address collateralToken;\n        /// @notice max number of debt tokens issued per collateral token.\n        /// @dev be mindful of the decimals here, because if collateral\n        /// token doesn't have 18 decimals, this variable is used to scale\n        /// the decimals.\n        /// For example, for USDC collateral, this variable should be around\n        /// ~1e30, to allow 1e6 * 1e30 / 1e18 ~= 1e18 CREDIT to be borrowed for\n        /// each 1e6 units (1 USDC) of collateral, if CREDIT is targeted to be\n        /// worth around 1 USDC.\n        uint256 maxDebtPerCollateralToken;\n        /// @notice interest rate paid by the borrower, expressed as an APR\n        /// with 18 decimals (0.01e18 = 1% APR). The base for 1 year is the YEAR constant.\n        uint256 interestRate;\n        /// @notice maximum delay, in seconds, between partial debt repayments.\n        /// if set to 0, no periodic partial repayments are expected.\n        /// if a partial repayment is missed (delay has passed), the loan\n        /// can be called.\n        uint256 maxDelayBetweenPartialRepay;\n        /// @notice minimum percent of the total debt (principal + interests) to\n        /// repay during partial debt repayments.\n        /// percentage is expressed with 18 decimals, e.g. 0.05e18 = 5% debt.\n        uint256 minPartialRepayPercent;\n        /// @notice the opening fee is a percent of interest that instantly accrues\n        /// when the loan is opened.\n        /// The opening fee is expressed as a percentage of the borrowAmount, with 18\n        /// decimals, e.g. 0.05e18 = 5% of the borrowed amount.\n        /// A loan with 2% openingFee and 3% interestRate will owe 102% of the borrowed\n        /// amount just after being open, and after 1 year will owe 105%.\n        uint256 openingFee;\n        /// @notice the absolute maximum amount of debt this lending term can issue\n        /// at any given time, regardless of the gauge allocations.\n        uint256 hardCap;\n    }\n\n    /// @notice Params of the LendingTerm (see struct for more details)\n    LendingTermParams internal params;\n\n    constructor() CoreRef(address(1)) {\n        // core is set to address(1) to prevent implementation from being initialized,\n        // only proxies on the implementation can be initialized.\n    }\n\n    /// @notice initialize storage with references to other protocol contracts\n    /// and the lending term parameters for this instance.\n    function initialize(\n        address _core,\n        LendingTermReferences calldata _refs,\n        LendingTermParams calldata _params\n    ) external {\n        // can initialize only once\n        assert(address(core()) == address(0));\n        assert(_core != address(0));\n\n        // initialize storage\n        _setCore(_core);\n        refs = _refs;\n        params = _params;\n    }\n\n    /// @notice get references of this term to other protocol contracts\n    function getReferences()\n        external\n        view\n        returns (LendingTermReferences memory)\n    {\n        return refs;\n    }\n\n    /// @notice get parameters of this term\n    function getParameters() external view returns (LendingTermParams memory) {\n        return params;\n    }\n\n    /// @notice get parameter 'collateralToken' of this term\n    function collateralToken() external view returns (address) {\n        return params.collateralToken;\n    }\n\n    /// @notice get a loan\n    function getLoan(bytes32 loanId) external view returns (Loan memory) {\n        return loans[loanId];\n    }\n\n    /// @notice outstanding borrowed amount of a loan, including interests\n    function getLoanDebt(bytes32 loanId) public view returns (uint256) {\n        Loan storage loan = loans[loanId];\n        uint256 borrowTime = loan.borrowTime;\n\n        if (borrowTime == 0) {\n            return 0;\n        }\n\n        if (loan.closeTime != 0) {\n            return 0;\n        }\n\n        if (loan.callTime != 0) {\n            return loan.callDebt;\n        }\n\n        // compute interest owed\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 interest = (borrowAmount *\n            params.interestRate *\n            (block.timestamp - borrowTime)) /\n            YEAR /\n            1e18;\n        uint256 loanDebt = borrowAmount + interest;\n        uint256 _openingFee = params.openingFee;\n        if (_openingFee != 0) {\n            loanDebt += (borrowAmount * _openingFee) / 1e18;\n        }\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;\n\n        return loanDebt;\n    }\n\n    /// @notice returns true if the term has a maximum delay between partial repays\n    /// and the loan has passed the delay for partial repayments.\n    function partialRepayDelayPassed(\n        bytes32 loanId\n    ) public view returns (bool) {\n        // if no periodic partial repays are expected, always return false\n        if (params.maxDelayBetweenPartialRepay == 0) return false;\n\n        // if loan doesn't exist, return false\n        if (loans[loanId].borrowTime == 0) return false;\n\n        // if loan is closed, return false\n        if (loans[loanId].closeTime != 0) return false;\n\n        // return true if delay is passed\n        return\n            lastPartialRepay[loanId] <\n            block.timestamp - params.maxDelayBetweenPartialRepay;\n    }\n\n    /// @notice returns the maximum amount of debt that can be issued by this term\n    /// according to the current gauge allocations.\n    /// Note that the debt ceiling can be lower than the current issuance under 4 conditions :\n    /// - params.hardCap is lower than since last borrow happened\n    /// - gauge votes are fewer than when last borrow happened\n    /// - profitManager.totalBorrowedCredit() decreased since last borrow\n    /// - creditMinter.buffer() is close to being depleted\n    /// @dev this solves the following equation :\n    /// borrowAmount + issuance <=\n    /// (totalBorrowedCredit + borrowAmount) * gaugeWeight * gaugeWeightTolerance / totalWeight / 1e18\n    /// which is the formula to check debt ceiling in the borrow function.\n    /// This gives the maximum borrowable amount to achieve 100% utilization of the debt\n    /// ceiling, and if we add the current issuance to it, we get the current debt ceiling.\n    /// @param gaugeWeightDelta an hypothetical change in gauge weight\n    /// @return the maximum amount of debt that can be issued by this term\n    function debtCeiling(\n        int256 gaugeWeightDelta\n    ) public view returns (uint256) {\n        address _guildToken = refs.guildToken; // cached SLOAD\n        uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(\n            address(this)\n        );\n        gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);\n        uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this));\n        uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(\n            gaugeType\n        );\n        uint256 creditMinterBuffer = RateLimitedMinter(refs.creditMinter)\n            .buffer();\n        uint256 _hardCap = params.hardCap; // cached SLOAD\n        if (gaugeWeight == 0) {\n            return 0; // no gauge vote, 0 debt ceiling\n        } else if (gaugeWeight == totalWeight) {\n            // one gauge, unlimited debt ceiling\n            // returns min(hardCap, creditMinterBuffer)\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 _issuance = issuance; // cached SLOAD\n        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n            .totalBorrowedCredit();\n        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n            .gaugeWeightTolerance();\n        if (totalBorrowedCredit == 0 && gaugeWeight != 0) {\n            // first-ever CREDIT mint on a non-zero gauge weight term\n            // does not check the relative debt ceilings\n            // returns min(hardCap, creditMinterBuffer)\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /\n            1e18;\n        uint256 debtCeilingBefore = (totalBorrowedCredit *\n            toleratedGaugeWeight) / totalWeight;\n        if (_issuance >= debtCeilingBefore) {\n            return debtCeilingBefore; // no more borrows allowed\n        }\n        uint256 remainingDebtCeiling = debtCeilingBefore - _issuance; // always >0\n        if (toleratedGaugeWeight >= totalWeight) {\n            // if the gauge weight is above 100% when we include tolerance,\n            // the gauge relative debt ceilings are not constraining.\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight; // always >0\n        uint256 maxBorrow = (remainingDebtCeiling * totalWeight) /\n            otherGaugesWeight;\n        uint256 _debtCeiling = _issuance + maxBorrow;\n        // return min(creditMinterBuffer, hardCap, debtCeiling)\n        if (creditMinterBuffer < _debtCeiling) {\n            return creditMinterBuffer;\n        }\n        if (_hardCap < _debtCeiling) {\n            return _hardCap;\n        }\n        return _debtCeiling;\n    }\n\n    /// @notice returns the debt ceiling without change to gauge weight\n    function debtCeiling() external view returns (uint256) {\n        return debtCeiling(0);\n    }\n\n    /// @notice initiate a new loan\n    function _borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 collateralAmount\n    ) internal returns (bytes32 loanId) {\n        require(borrowAmount != 0, \"LendingTerm: cannot borrow 0\");\n        require(collateralAmount != 0, \"LendingTerm: cannot stake 0\");\n\n        loanId = keccak256(\n            abi.encode(borrower, address(this), block.timestamp)\n        );\n\n        // check that the loan doesn't already exist\n        require(loans[loanId].borrowTime == 0, \"LendingTerm: loan exists\");\n\n        // check that enough collateral is provided\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 maxBorrow = (collateralAmount *\n            params.maxDebtPerCollateralToken) / creditMultiplier;\n        require(\n            borrowAmount <= maxBorrow,\n            \"LendingTerm: not enough collateral\"\n        );\n\n        // check that enough CREDIT is borrowed\n        require(\n            borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),\n            \"LendingTerm: borrow amount too low\"\n        );\n\n        // check the hardcap\n        uint256 _issuance = issuance;\n        uint256 _postBorrowIssuance = _issuance + borrowAmount;\n        require(\n            _postBorrowIssuance <= params.hardCap,\n            \"LendingTerm: hardcap reached\"\n        );\n\n        // check the debt ceiling\n        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n            .totalBorrowedCredit();\n        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n            .gaugeWeightTolerance();\n        uint256 _debtCeiling = (GuildToken(refs.guildToken)\n            .calculateGaugeAllocation(\n                address(this),\n                totalBorrowedCredit + borrowAmount\n            ) * gaugeWeightTolerance) / 1e18;\n        if (totalBorrowedCredit == 0) {\n            // if the lending term is deprecated, `calculateGaugeAllocation` will return 0, and the borrow\n            // should revert because the debt ceiling is reached (no borrows should be allowed anymore).\n            // first borrow in the system does not check proportions of issuance, just that the term is not deprecated.\n            require(_debtCeiling != 0, \"LendingTerm: debt ceiling reached\");\n        } else {\n            require(\n                _postBorrowIssuance <= _debtCeiling,\n                \"LendingTerm: debt ceiling reached\"\n            );\n        }\n\n        // save loan in state\n        loans[loanId] = Loan({\n            borrower: borrower,\n            borrowTime: block.timestamp,\n            borrowAmount: borrowAmount,\n            borrowCreditMultiplier: creditMultiplier,\n            collateralAmount: collateralAmount,\n            caller: address(0),\n            callTime: 0,\n            callDebt: 0,\n            closeTime: 0\n        });\n        issuance = _postBorrowIssuance;\n        if (params.maxDelayBetweenPartialRepay != 0) {\n            lastPartialRepay[loanId] = block.timestamp;\n        }\n\n        // mint debt to the borrower\n        RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);\n\n        // pull the collateral from the borrower\n        IERC20(params.collateralToken).safeTransferFrom(\n            borrower,\n            address(this),\n            collateralAmount\n        );\n\n        // emit event\n        emit LoanOpen(\n            block.timestamp,\n            loanId,\n            borrower,\n            collateralAmount,\n            borrowAmount\n        );\n    }\n\n    /// @notice initiate a new loan\n    function borrow(\n        uint256 borrowAmount,\n        uint256 collateralAmount\n    ) external whenNotPaused returns (bytes32 loanId) {\n        loanId = _borrow(msg.sender, borrowAmount, collateralAmount);\n    }\n\n    /// @notice add collateral on an open loan.\n    /// a borrower might want to add collateral so that his position does not go underwater due to\n    /// interests growing up over time.\n    function _addCollateral(\n        address borrower,\n        bytes32 loanId,\n        uint256 collateralToAdd\n    ) internal {\n        require(collateralToAdd != 0, \"LendingTerm: cannot add 0\");\n\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // update loan in state\n        loans[loanId].collateralAmount += collateralToAdd;\n\n        // pull the collateral from the borrower\n        IERC20(params.collateralToken).safeTransferFrom(\n            borrower,\n            address(this),\n            collateralToAdd\n        );\n\n        // emit event\n        emit LoanAddCollateral(\n            block.timestamp,\n            loanId,\n            borrower,\n            collateralToAdd\n        );\n    }\n\n    /// @notice add collateral on an open loan.\n    function addCollateral(bytes32 loanId, uint256 collateralToAdd) external {\n        _addCollateral(msg.sender, loanId, collateralToAdd);\n    }\n\n    /// @notice partially repay an open loan.\n    /// a borrower might want to partially repay debt so that his position does not go underwater\n    /// due to interests building up.\n    /// some lending terms might also impose periodic partial repayments.\n    function _partialRepay(\n        address repayer,\n        bytes32 loanId,\n        uint256 debtToRepay\n    ) internal {\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        uint256 borrowTime = loan.borrowTime;\n        require(borrowTime != 0, \"LendingTerm: loan not found\");\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // compute partial repayment\n        uint256 loanDebt = getLoanDebt(loanId);\n        require(debtToRepay < loanDebt, \"LendingTerm: full repayment\");\n        uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; // [0, 1e18[\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 principal = (borrowAmount * loan.borrowCredi"
    }
  ]
}