{
  "Title": "H-1: All funds can be stolen from JOJODealer",
  "Content": "# Issue H-1: All funds can be stolen from JOJODealer \n\nSource: https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/7 \n\n## Found by \n0x52, 0xhashiman, T1MOH, bughuntoor, cawfree, giraffe, vvv\n## Summary\n`Funding._withdraw()` makes arbitrary call with user specified params. User can for example make ERC20 to himself and steal funds. \n\n## Vulnerability Detail\nUser can specify parameters `param` and `to` when withdraws:\n```solidity\n    function executeWithdraw(address from, address to, bool isInternal, bytes memory param) external nonReentrant {\n        Funding.executeWithdraw(state, from, to, isInternal, param);\n    }\n```\n\nIn the end of `_withdraw()` function address `to` is called with that `bytes param`:\n```solidity\n    function _withdraw(\n        Types.State storage state,\n        address spender,\n        address from,\n        address to,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isInternal,\n        bytes memory param\n    )\n        private\n    {\n        ...\n\n        if (param.length != 0) {\n@>          require(Address.isContract(to), \"target is not a contract\");\n            (bool success,) = to.call(param);\n            if (success == false) {\n                assembly {\n                    let ptr := mload(0x40)\n                    let size := returndatasize()\n                    returndatacopy(ptr, 0, size)\n                    revert(ptr, size)\n                }\n            }\n        }\n    }\n```\n\nAs an attack vector attacker can execute withdrawal of 1 wei to USDC contract and pass calldata to transfer arbitrary USDC amount to himself via USDC contract.\n\n## Impact\nAll funds can be stolen from JOJODealer\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-jojo-exchange-update/blob/ed4a8483da11bcc04ced10de899038bcead087b3/smart-contract-EVM/src/libraries/Funding.sol#L173-L184\n\n## Tool used\n\nManual Review\n\n## Recommendation\nDon't make arbitrary call with user specified params\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { This is valid and i can validate it with POC from report 076}\n\n\n\n**JoscelynFarr**\n\nFixed PR: https://github.com/JOJOexchange/smart-contract-EVM/commit/763de53a36243490ef46a2c702c5a1480554f286\n\n**IAm0x52**\n\nFix looks good. To must now be a whitelisted contract\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/136",
  "Code": [
    {
      "filename": "smart-contract-EVM/src/libraries/Funding.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1\n*/\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/internal/IPriceSource.sol\";\nimport \"../interfaces/IPerpetual.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/SignedDecimalMath.sol\";\nimport \"./Liquidation.sol\";\nimport \"./Operation.sol\";\nimport \"./Types.sol\";\n\nlibrary Funding {\n    using SafeERC20 for IERC20;\n\n    // ========== events ==========\n\n    event Deposit(address indexed to, address indexed payer, uint256 primaryAmount, uint256 secondaryAmount);\n\n    event Withdraw(address indexed to, address indexed payer, uint256 primaryAmount, uint256 secondaryAmount);\n\n    event RequestWithdraw(\n        address indexed payer, uint256 primaryAmount, uint256 secondaryAmount, uint256 executionTimestamp\n    );\n\n    event TransferIn(address trader, uint256 primaryAmount, uint256 secondaryAmount);\n\n    event TransferOut(address trader, uint256 primaryAmount, uint256 secondaryAmount);\n\n    // ========== deposit ==========\n\n    function deposit(Types.State storage state, uint256 primaryAmount, uint256 secondaryAmount, address to) external {\n        if (primaryAmount > 0) {\n            IERC20(state.primaryAsset).safeTransferFrom(msg.sender, address(this), primaryAmount);\n            state.primaryCredit[to] += SafeCast.toInt256(primaryAmount);\n        }\n        if (secondaryAmount > 0) {\n            IERC20(state.secondaryAsset).safeTransferFrom(msg.sender, address(this), secondaryAmount);\n            state.secondaryCredit[to] += secondaryAmount;\n        }\n        emit Deposit(to, msg.sender, primaryAmount, secondaryAmount);\n    }\n\n    // ========== withdraw ==========\n\n    function isWithdrawValid(\n        Types.State storage state,\n        address spender,\n        address from,\n        uint256 primaryAmount,\n        uint256 secondaryAmount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return spender == from\n            || (\n                state.primaryCreditAllowed[from][spender] >= primaryAmount\n                    && state.secondaryCreditAllowed[from][spender] >= secondaryAmount\n            );\n    }\n\n    function requestWithdraw(\n        Types.State storage state,\n        address from,\n        uint256 primaryAmount,\n        uint256 secondaryAmount\n    )\n        external\n    {\n        require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n        state.pendingPrimaryWithdraw[msg.sender] = primaryAmount;\n        state.pendingSecondaryWithdraw[msg.sender] = secondaryAmount;\n        state.withdrawExecutionTimestamp[msg.sender] = block.timestamp + state.withdrawTimeLock;\n        emit RequestWithdraw(msg.sender, primaryAmount, secondaryAmount, state.withdrawExecutionTimestamp[msg.sender]);\n    }\n\n    function executeWithdraw(\n        Types.State storage state,\n        address from,\n        address to,\n        bool isInternal,\n        bytes memory param\n    )\n        external\n    {\n        require(state.withdrawExecutionTimestamp[from] <= block.timestamp, Errors.WITHDRAW_PENDING);\n        uint256 primaryAmount = state.pendingPrimaryWithdraw[from];\n        uint256 secondaryAmount = state.pendingSecondaryWithdraw[from];\n        require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n        state.pendingPrimaryWithdraw[from] = 0;\n        state.pendingSecondaryWithdraw[from] = 0;\n        // No need to change withdrawExecutionTimestamp, because we set pending\n        // withdraw amount to 0.\n        _withdraw(state, msg.sender, from, to, primaryAmount, secondaryAmount, isInternal, param);\n    }\n\n    function fastWithdraw(\n        Types.State storage state,\n        address from,\n        address to,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isInternal,\n        bytes memory param\n    )\n        external\n    {\n        require(\n            !state.fastWithdrawDisabled || state.fastWithdrawalWhitelist[msg.sender], Errors.FAST_WITHDRAW_NOT_ALLOWED\n        );\n        require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n        _withdraw(state, msg.sender, from, to, primaryAmount, secondaryAmount, isInternal, param);\n    }\n\n    function _withdraw(\n        Types.State storage state,\n        address spender,\n        address from,\n        address to,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isInternal,\n        bytes memory param\n    )\n        private\n    {\n        if (spender != from) {\n            state.primaryCreditAllowed[from][spender] -= primaryAmount;\n            state.secondaryCreditAllowed[from][spender] -= secondaryAmount;\n            emit Operation.FundOperatorAllowedChange(\n                from, spender, state.primaryCreditAllowed[from][spender], state.secondaryCreditAllowed[from][spender]\n            );\n        }\n        if (primaryAmount > 0) {\n            state.primaryCredit[from] -= SafeCast.toInt256(primaryAmount);\n            if (isInternal) {\n                state.primaryCredit[to] += SafeCast.toInt256(primaryAmount);\n            } else {\n                IERC20(state.primaryAsset).safeTransfer(to, primaryAmount);\n            }\n        }\n        if (secondaryAmount > 0) {\n            state.secondaryCredit[from] -= secondaryAmount;\n            if (isInternal) {\n                state.secondaryCredit[to] += secondaryAmount;\n            } else {\n                IERC20(state.secondaryAsset).safeTransfer(to, secondaryAmount);\n            }\n        }\n\n        if (primaryAmount > 0) {\n            // if trader withdraw primary asset, we should check if solid safe\n            require(Liquidation._isSolidIMSafe(state, from), Errors.ACCOUNT_NOT_SAFE);\n        } else {\n            // if trader didn't withdraw primary asset, normal safe check is enough\n            require(Liquidation._isIMSafe(state, from), Errors.ACCOUNT_NOT_SAFE);\n        }\n\n        if (isInternal) {\n            emit TransferIn(to, primaryAmount, secondaryAmount);\n            emit TransferOut(from, primaryAmount, secondaryAmount);\n        } else {\n            emit Withdraw(to, from, primaryAmount, secondaryAmount);\n        }\n\n        if (param.length != 0) {\n            require(Address.isContract(to), \"target is not a contract\");\n            (bool success,) = to.call(param);\n            if (success == false) {\n                assembly {\n                    let ptr := mload(0x40)\n                    let size := returndatasize()\n                    returndatacopy(ptr, 0, size)\n                    revert(ptr, size)\n                }\n            }\n        }\n    }\n}"
    }
  ]
}