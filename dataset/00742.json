{
  "Title": "Lack of Input Validation",
  "Content": "Throughout the [codebase](https://github.com/Ion-Protocol/ion-protocol/tree/98e282514ac5827196b49f688938e1e44709505a/), functions lack validation of input arguments:\n\n\n* Within the `ReserveOracle` contract:\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/reserve/ReserveOracle.sol#L41) does not validate that the `_feeds.length` is exactly `MAX_FEED_COUNT`. If `_feeds.length < MAX_FEED_COUNT`, the constructor will revert when assigning the `FEED0`, `FEED1`, and `FEED2` variables.\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/reserve/ReserveOracle.sol#L41) does not validate that the `_maxChange` argument is non-zero and less than `1e27` (1 RAY).\n\t+ The [`_bound` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/reserve/ReserveOracle.sol#L81) does not validate that the `min` value is strictly less than the `max` value and may lead to inaccurate output if this does not hold.\n* Within the `SwEthSpotOracle` contract:\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/spot/SwEthSpotOracle.sol#L17-L22) does not validate that the `_secondsAgo` argument is non-zero.\n* Within the `YieldOracle` contract:\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/YieldOracle.sol#L73-L79) does not validate that none of the `_historicalExchangeRates` values are non-zero. A zero value would result in a division by zero on [line 127](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/YieldOracle.sol#L127).\n\t+ The [`_getExchangeRate` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/YieldOracle.sol#L145) does not validate that the `ilkIndex` value is within the expected range and will return `0` for an invalid input.\n* Within the `InterestRate` contract:\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/InterestRate.sol#L113) does not validate that the `minimumKinkRate` values are at least as large as the `minimumBaseRate` values. If this condition does not hold, the `calculateInterestRate` function will [revert](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/InterestRate.sol#L289).\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/InterestRate.sol#L113) does not validate that the `ilkDataList` argument has a maximum length of 8. If an array with a length greater than 8 is passed, it is possible that the [`distributionFactorSum` will be `1e4`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/InterestRate.sol#L127) when the data stored within the contract will not sum to `1e4`.\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/InterestRate.sol#L113) does not validate that the `optimalUtilizationRate` values are non-zero. A zero `optimalUtilizationRate` will cause the `calculateInterestRate` function to [revert](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/InterestRate.sol#L285).\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/InterestRate.sol#L113) does not validate that the `reserveFactor` values are less than 1 RAY (`1e27`). A `reserveFactor` value larger than `1e27` would cause the `_calculateRewardAndDebtDistribution` function in the `IonPool` contract to [revert](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L489).\n* Within the `IonPool` contract:\n\t+ The [`mintAndBurnGem`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L828-L832), [`collateral`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L959), [`normalizedDebt`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L967), [`vault`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L975), and [`gem`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L983) functions do not validate that their `ilkIndex` arguments are within the supported range.\n\t+ The [`initialize` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L155-L167) does not validate that the value of `_underlying` token is the WETH token which is assumed loan contracts, specifically the `IonHandlerBase` contract will assume it has a \"WETH\" interface.\n* Within the `Liquidation` contract:\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L50-L58) does not validate that the length of the `_maxDiscount` array is 3.\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L50-L58) does not validate that the `_liquidationThresholds` values should be non-zero. This is instead checked within the [`liquidate` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L175). Passing in a zero value for the `_liquidationThresholds` would result in a contract that will deploy but will not be able to perform liquidations as the `liquidate` function will always revert.\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L50-L58) does not validate that `_targetHealth` is at least 1 RAY (`1e27`). A value less than `1e27` would cause the `liquidate` function to always revert due to an [underflow in subtraction in the `_getRepayAmt` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L144).\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L50-L58) does not validate that the `_maxDiscount` values are less than 1 RAY (`1e27`). If a value greater than `1e27` is passed, the contract will deploy correctly but liquidations will always revert due to an [underflow within the `liquidate` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L195).\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L50-L58) does not validate that for each collateral index (`i`), `_targetHealth >= _liquidationThresholds[i] / (RAY - _maxDiscount[i])`. This invariant must hold otherwise all liquidations will revert when `discount == configs.maxDiscount` within the [`_getRepayAmt` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L144).\n\t+ The [`_getConfigs` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Liquidation.sol#L99-L103) does not validate that the `ilkIndex` argument is within the expected range.\n* Within the `UniswapFlashswapHandler` contract:\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashswapHandler.sol#L48) `_poolFee` argument is not validated to match the fee of the input `_pool`. This argument can be removed and the fee can be read directly from the `UniswapV3Pool` contract.\n\t+ The [constructor](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashswapHandler.sol#L48) `_wethIsToken0` argument should be validated explicitly against the pool or assigned directly from the `_pool`.\n\t+ The [`flashswapLeverage` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashswapHandler.sol#L82-L89) does not validate that `resultingAdditionalCollateral >= initialDeposit`.\n\t+ The [`flashswapLeverage` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashswapHandler.sol#L82-L89) does not validate that `sqrtPriceLimitX96` is either `0` or [between the current price and `MIN_SQRT_RATIO` or `MAX_SQRT_RATIO` (depending on token ordering in the pool)](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L609-L612).\n\t+ The [`flashswapDeleverage` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashswapHandler.sol#L127-L133) does not validate that `sqrtPriceLimitX96` is either `0` or [between the current price and `MIN_SQRT_RATIO` or `MAX_SQRT_RATIO` (depending on token ordering in the pool)](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L609-L612).\n\n\nConsider validating the input to all constructors to ensure the contracts cannot be deployed with invalid arguments. A misconfigured contract may cause problems when later attempting to interact with the contract (e.g., liquidate a vault) and could delay performing critical actions. Additionally, ensure input arguments to all functions are properly validated with a preference to fail early and loudly.\n\n\n***Update:** Partially resolved in [pull request #33](https://github.com/Ion-Protocol/ion-protocol/pull/33). Note that the `_getConfigs` function of the `Liquidation` contract still does not validate that the `ilkIndex` is within the expected range. Ion Protocol team stated:*\n\n\n\n> *1. Will not fix `IonPool` input validation.*\n> \n> \n> *2. Will not fix: “The `flashswapLeverage` function does not validate that `resultingAdditionalCollateral >= initialDeposit`”. This is Implicitly checked by Solidity’s overflow protection and does not need to be fixed.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/oracles/reserve/ReserveOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IReserveFeed } from \"src/interfaces/IReserveFeed.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\n\n// should equal to the number of feeds available in the contract\nuint8 constant MAX_FEED_COUNT = 3;\n\nabstract contract ReserveOracle {\n    using SafeCast for *;\n    using WadRayMath for uint256;\n\n    uint8 public immutable ILK_INDEX;\n    uint8 public immutable QUORUM; // the number of feeds to aggregate\n    uint256 public immutable MAX_CHANGE; // maximum change allowed in percentage [ray] i.e. 3e25 [ray] would be 3%\n\n    IReserveFeed public immutable FEED0; // different reserve oracle feeds excluding the protocol exchange rate\n    IReserveFeed public immutable FEED1;\n    IReserveFeed public immutable FEED2;\n\n    uint256 public currentExchangeRate; // [wad] the bounded queried last time\n\n    // --- Events ---\n    event UpdateExchangeRate(uint256 exchangeRate);\n\n    // --- Errors ---\n    error InvalidQuorum(uint8 quorum);\n    error InvalidFeedLength(uint256 length);\n    error InvalidInitialization(uint256 exchangeRate);\n\n    // --- Override ---\n    function _getProtocolExchangeRate() internal view virtual returns (uint256);\n\n    function getProtocolExchangeRate() external view returns (uint256) {\n        return _getProtocolExchangeRate();\n    }\n\n    constructor(uint8 _ilkIndex, address[] memory _feeds, uint8 _quorum, uint256 _maxChange) {\n        if (_feeds.length > MAX_FEED_COUNT) {\n            revert InvalidFeedLength(_feeds.length);\n        }\n        if (_quorum > MAX_FEED_COUNT) {\n            revert InvalidQuorum(_quorum);\n        }\n\n        ILK_INDEX = _ilkIndex;\n        QUORUM = _quorum;\n        MAX_CHANGE = _maxChange;\n\n        FEED0 = IReserveFeed(_feeds[0]);\n        FEED1 = IReserveFeed(_feeds[1]);\n        FEED2 = IReserveFeed(_feeds[2]);\n    }\n\n    /**\n     * @dev queries values from whitelisted data feeds and calculates\n     *      the min. Does not include the protocol exchange rate.\n     * @notice if quorum isn't met, should revert\n     */\n    function _aggregate(uint8 _ILK_INDEX) internal view returns (uint256 val) {\n        if (QUORUM == 0) {\n            return type(uint256).max;\n        } else if (QUORUM == 1) {\n            val = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n        } else if (QUORUM == 2) {\n            uint256 feed0ExchangeRate = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n            uint256 feed1ExchangeRate = IReserveFeed(FEED1).getExchangeRate(_ILK_INDEX);\n            val = ((feed0ExchangeRate + feed1ExchangeRate) / uint256(QUORUM));\n        } else if (QUORUM == 3) {\n            uint256 feed0ExchangeRate = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n            uint256 feed1ExchangeRate = IReserveFeed(FEED1).getExchangeRate(_ILK_INDEX);\n            uint256 feed2ExchangeRate = IReserveFeed(FEED2).getExchangeRate(_ILK_INDEX);\n            val = ((feed0ExchangeRate + feed1ExchangeRate + feed2ExchangeRate) / uint256(QUORUM));\n        }\n    }\n\n    // bound the final reported value between the min and the max\n    function _bound(uint256 value, uint256 min, uint256 max) internal pure returns (uint256) {\n        return Math.max(min, Math.min(max, value));\n    }\n\n    function _initializeExchangeRate() internal {\n        currentExchangeRate = Math.min(_getProtocolExchangeRate(), _aggregate(ILK_INDEX));\n        if (currentExchangeRate == 0) {\n            revert InvalidInitialization(currentExchangeRate);\n        }\n    }\n\n    // @dev Takes the minimum between the aggregated values and the protocol exchange rate,\n    // then bounds it up to the maximum change and writes the bounded value to the state.\n    // NOTE: keepers should call this update to reflect recent values\n    function updateExchangeRate() public {\n        uint256 _currentExchangeRate = currentExchangeRate;\n\n        uint256 minimum = Math.min(_getProtocolExchangeRate(), _aggregate(ILK_INDEX));\n        uint256 diff = _currentExchangeRate.rayMulDown(MAX_CHANGE);\n\n        uint256 bounded = _bound(minimum, _currentExchangeRate - diff, _currentExchangeRate + diff);\n        currentExchangeRate = bounded;\n\n        emit UpdateExchangeRate(bounded);\n    }\n}"
    },
    {
      "filename": "src/oracles/reserve/ReserveOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IReserveFeed } from \"src/interfaces/IReserveFeed.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\n\n// should equal to the number of feeds available in the contract\nuint8 constant MAX_FEED_COUNT = 3;\n\nabstract contract ReserveOracle {\n    using SafeCast for *;\n    using WadRayMath for uint256;\n\n    uint8 public immutable ILK_INDEX;\n    uint8 public immutable QUORUM; // the number of feeds to aggregate\n    uint256 public immutable MAX_CHANGE; // maximum change allowed in percentage [ray] i.e. 3e25 [ray] would be 3%\n\n    IReserveFeed public immutable FEED0; // different reserve oracle feeds excluding the protocol exchange rate\n    IReserveFeed public immutable FEED1;\n    IReserveFeed public immutable FEED2;\n\n    uint256 public currentExchangeRate; // [wad] the bounded queried last time\n\n    // --- Events ---\n    event UpdateExchangeRate(uint256 exchangeRate);\n\n    // --- Errors ---\n    error InvalidQuorum(uint8 quorum);\n    error InvalidFeedLength(uint256 length);\n    error InvalidInitialization(uint256 exchangeRate);\n\n    // --- Override ---\n    function _getProtocolExchangeRate() internal view virtual returns (uint256);\n\n    function getProtocolExchangeRate() external view returns (uint256) {\n        return _getProtocolExchangeRate();\n    }\n\n    constructor(uint8 _ilkIndex, address[] memory _feeds, uint8 _quorum, uint256 _maxChange) {\n        if (_feeds.length > MAX_FEED_COUNT) {\n            revert InvalidFeedLength(_feeds.length);\n        }\n        if (_quorum > MAX_FEED_COUNT) {\n            revert InvalidQuorum(_quorum);\n        }\n\n        ILK_INDEX = _ilkIndex;\n        QUORUM = _quorum;\n        MAX_CHANGE = _maxChange;\n\n        FEED0 = IReserveFeed(_feeds[0]);\n        FEED1 = IReserveFeed(_feeds[1]);\n        FEED2 = IReserveFeed(_feeds[2]);\n    }\n\n    /**\n     * @dev queries values from whitelisted data feeds and calculates\n     *      the min. Does not include the protocol exchange rate.\n     * @notice if quorum isn't met, should revert\n     */\n    function _aggregate(uint8 _ILK_INDEX) internal view returns (uint256 val) {\n        if (QUORUM == 0) {\n            return type(uint256).max;\n        } else if (QUORUM == 1) {\n            val = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n        } else if (QUORUM == 2) {\n            uint256 feed0ExchangeRate = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n            uint256 feed1ExchangeRate = IReserveFeed(FEED1).getExchangeRate(_ILK_INDEX);\n            val = ((feed0ExchangeRate + feed1ExchangeRate) / uint256(QUORUM));\n        } else if (QUORUM == 3) {\n            uint256 feed0ExchangeRate = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n            uint256 feed1ExchangeRate = IReserveFeed(FEED1).getExchangeRate(_ILK_INDEX);\n            uint256 feed2ExchangeRate = IReserveFeed(FEED2).getExchangeRate(_ILK_INDEX);\n            val = ((feed0ExchangeRate + feed1ExchangeRate + feed2ExchangeRate) / uint256(QUORUM));\n        }\n    }\n\n    // bound the final reported value between the min and the max\n    function _bound(uint256 value, uint256 min, uint256 max) internal pure returns (uint256) {\n        return Math.max(min, Math.min(max, value));\n    }\n\n    function _initializeExchangeRate() internal {\n        currentExchangeRate = Math.min(_getProtocolExchangeRate(), _aggregate(ILK_INDEX));\n        if (currentExchangeRate == 0) {\n            revert InvalidInitialization(currentExchangeRate);\n        }\n    }\n\n    // @dev Takes the minimum between the aggregated values and the protocol exchange rate,\n    // then bounds it up to the maximum change and writes the bounded value to the state.\n    // NOTE: keepers should call this update to reflect recent values\n    function updateExchangeRate() public {\n        uint256 _currentExchangeRate = currentExchangeRate;\n\n        uint256 minimum = Math.min(_getProtocolExchangeRate(), _aggregate(ILK_INDEX));\n        uint256 diff = _currentExchangeRate.rayMulDown(MAX_CHANGE);\n\n        uint256 bounded = _bound(minimum, _currentExchangeRate - diff, _currentExchangeRate + diff);\n        currentExchangeRate = bounded;\n\n        emit UpdateExchangeRate(bounded);\n    }\n}"
    },
    {
      "filename": "src/oracles/reserve/ReserveOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IReserveFeed } from \"src/interfaces/IReserveFeed.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\n\n// should equal to the number of feeds available in the contract\nuint8 constant MAX_FEED_COUNT = 3;\n\nabstract contract ReserveOracle {\n    using SafeCast for *;\n    using WadRayMath for uint256;\n\n    uint8 public immutable ILK_INDEX;\n    uint8 public immutable QUORUM; // the number of feeds to aggregate\n    uint256 public immutable MAX_CHANGE; // maximum change allowed in percentage [ray] i.e. 3e25 [ray] would be 3%\n\n    IReserveFeed public immutable FEED0; // different reserve oracle feeds excluding the protocol exchange rate\n    IReserveFeed public immutable FEED1;\n    IReserveFeed public immutable FEED2;\n\n    uint256 public currentExchangeRate; // [wad] the bounded queried last time\n\n    // --- Events ---\n    event UpdateExchangeRate(uint256 exchangeRate);\n\n    // --- Errors ---\n    error InvalidQuorum(uint8 quorum);\n    error InvalidFeedLength(uint256 length);\n    error InvalidInitialization(uint256 exchangeRate);\n\n    // --- Override ---\n    function _getProtocolExchangeRate() internal view virtual returns (uint256);\n\n    function getProtocolExchangeRate() external view returns (uint256) {\n        return _getProtocolExchangeRate();\n    }\n\n    constructor(uint8 _ilkIndex, address[] memory _feeds, uint8 _quorum, uint256 _maxChange) {\n        if (_feeds.length > MAX_FEED_COUNT) {\n            revert InvalidFeedLength(_feeds.length);\n        }\n        if (_quorum > MAX_FEED_COUNT) {\n            revert InvalidQuorum(_quorum);\n        }\n\n        ILK_INDEX = _ilkIndex;\n        QUORUM = _quorum;\n        MAX_CHANGE = _maxChange;\n\n        FEED0 = IReserveFeed(_feeds[0]);\n        FEED1 = IReserveFeed(_feeds[1]);\n        FEED2 = IReserveFeed(_feeds[2]);\n    }\n\n    /**\n     * @dev queries values from whitelisted data feeds and calculates\n     *      the min. Does not include the protocol exchange rate.\n     * @notice if quorum isn't met, should revert\n     */\n    function _aggregate(uint8 _ILK_INDEX) internal view returns (uint256 val) {\n        if (QUORUM == 0) {\n            return type(uint256).max;\n        } else if (QUORUM == 1) {\n            val = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n        } else if (QUORUM == 2) {\n            uint256 feed0ExchangeRate = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n            uint256 feed1ExchangeRate = IReserveFeed(FEED1).getExchangeRate(_ILK_INDEX);\n            val = ((feed0ExchangeRate + feed1ExchangeRate) / uint256(QUORUM));\n        } else if (QUORUM == 3) {\n            uint256 feed0ExchangeRate = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n            uint256 feed1ExchangeRate = IReserveFeed(FEED1).getExchangeRate(_ILK_INDEX);\n            uint256 feed2ExchangeRate = IReserveFeed(FEED2).getExchangeRate(_ILK_INDEX);\n            val = ((feed0ExchangeRate + feed1ExchangeRate + feed2ExchangeRate) / uint256(QUORUM));\n        }\n    }\n\n    // bound the final reported value between the min and the max\n    function _bound(uint256 value, uint256 min, uint256 max) internal pure returns (uint256) {\n        return Math.max(min, Math.min(max, value));\n    }\n\n    function _initializeExchangeRate() internal {\n        currentExchangeRate = Math.min(_getProtocolExchangeRate(), _aggregate(ILK_INDEX));\n        if (currentExchangeRate == 0) {\n            revert InvalidInitialization(currentExchangeRate);\n        }\n    }\n\n    // @dev Takes the minimum between the aggregated values and the protocol exchange rate,\n    // then bounds it up to the maximum change and writes the bounded value to the state.\n    // NOTE: keepers should call this update to reflect recent values\n    function updateExchangeRate() public {\n        uint256 _currentExchangeRate = currentExchangeRate;\n\n        uint256 minimum = Math.min(_getProtocolExchangeRate(), _aggregate(ILK_INDEX));\n        uint256 diff = _currentExchangeRate.rayMulDown(MAX_CHANGE);\n\n        uint256 bounded = _bound(minimum, _currentExchangeRate - diff, _currentExchangeRate + diff);\n        currentExchangeRate = bounded;\n\n        emit UpdateExchangeRate(bounded);\n    }\n}"
    },
    {
      "filename": "src/oracles/spot/SwEthSpotOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { TickMath } from \"src/libraries/uniswap/TickMath.sol\";\nimport { UniswapOracleLibrary } from \"src/libraries/uniswap/UniswapOracleLibrary.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SpotOracle } from \"./SpotOracle.sol\";\nimport { WAD } from \"src/libraries/math/WadRayMath.sol\";\n\ncontract SwEthSpotOracle is SpotOracle {\n    using Math for uint256;\n\n    IUniswapV3Pool immutable POOL;\n    uint32 immutable SECONDS_AGO;\n\n    constructor(\n        uint256 _ltv,\n        address _reserveOracle,\n        address _uniswapPool,\n        uint32 _secondsAgo\n    )\n        SpotOracle(_ltv, _reserveOracle)\n    {\n        POOL = IUniswapV3Pool(_uniswapPool);\n        SECONDS_AGO = _secondsAgo;\n    }\n\n    // @notice Gets the price of swETH in ETH. \n    // @dev Uniswap returns price in swETH per ETH. This needs to be inversed.\n    // @return ethPerSwEth price of swETH in ETH [wad] \n    function getPrice() public view override returns (uint256 ethPerSwEth) {\n        (int24 arithmeticMeanTick,) = UniswapOracleLibrary.consult(address(POOL), SECONDS_AGO);\n        uint256 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(arithmeticMeanTick);\n        // swETH per ETH\n        uint256 swEthPerEth = _getPriceX96FromSqrtPriceX96(sqrtPriceX96); // [wad]\n        ethPerSwEth = WAD * WAD / swEthPerEth; // [wad] * [wad] / [wad]\n    }\n\n    function _getPriceX96FromSqrtPriceX96(uint256 sqrtPriceX96) internal pure returns (uint256 priceX96) {\n        return (sqrtPriceX96 * sqrtPriceX96).mulDiv(WAD, 2 ** 192); // [wad]\n    }\n}"
    },
    {
      "filename": "src/YieldOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport { IonPool } from \"src/IonPool.sol\";\nimport { IWstEth, IStaderStakePoolsManager, ISwEth } from \"src/interfaces/ProviderInterfaces.sol\";\n\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IYieldOracle } from \"./interfaces/IYieldOracle.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n// historicalExchangeRates can be thought of as a matrix of past exchange rates by collateral types. With a uint64 type\n// storing exchange rates, 4 can be stored in one storage slot. So each day will consume ceil(ILK_COUNT / 4) storage\n// slots.\n//\n//  look back days  | storage slot  ||                             data\n//\n//                  |                  256             172             128              64              0\n//                  |               ||  |     ilk_4     |     ilk_3     |     ilk_2     |     ilk_1     |\n//        1         |     n + 0     ||  |               |               |               |               |\n//        2         |     n + 1     ||  |               |               |               |               |\n//       ...        |    n + ...    ||  |               |               |               |               |\n//        n         |     n + n     ||  |               |               |               |               |\n//\n// A uint64 has the capacity to store up to around ~18e18 which is more than enough to fit an exchange rate that only\n// ever hovers around 1e18.\n\nuint8 constant APY_PRECISION = 8;\nuint8 constant PROVIDER_PRECISION = 18;\n\nuint32 constant LOOK_BACK = 7;\nuint256 constant PERIODS = 365 * (10 ** APY_PRECISION) / LOOK_BACK; // 52.142... eAPY_PRECISION\nuint32 constant ILK_COUNT = 3;\n// Seconds in 23.5 hours. This will allow for updates around the same time of day\nuint256 constant UPDATE_LOCK_LENGTH = 84_600;\n\n/**\n * @dev This contract stores a history of the exchange rates of each collateral\n * for the past `LOOK_BACK` days. Every time, that `updateAll()` is called, it\n * will update the value at `currentIndex` in the `historicalExchangeRates` with the\n * current exchange rate and it will also calculate the APY for each collateral\n * type based on the data currently in the buffer. The APY is calculated by\n * taking the difference between the new element being added and the element\n * being replaced. This provides a growth amount of `LOOK_BACK` days. This value\n * is then projected out to a year.\n */\ncontract YieldOracle is IYieldOracle, Ownable2Step {\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    // --- Errors ---\n\n    error InvalidExchangeRate(uint256 ilkIndex);\n    error AlreadyUpdated();\n\n    // --- Events ---\n\n    event ApyUpdate(uint256 indexed ilkIndex, uint256 newApy);\n\n    uint32[ILK_COUNT] public apys;\n\n    uint64[ILK_COUNT][LOOK_BACK] public historicalExchangeRates;\n    address public immutable ADDRESS0;\n    address public immutable ADDRESS1;\n    address public immutable ADDRESS2;\n\n    IonPool public ionPool;\n\n    uint32 public currentIndex;\n    uint48 public lastUpdated;\n\n    constructor(\n        uint64[ILK_COUNT][LOOK_BACK] memory _historicalExchangeRates,\n        address _wstEth,\n        address _stader,\n        address _swell,\n        address owner\n    )\n        Ownable(owner)\n    {\n        historicalExchangeRates = _historicalExchangeRates;\n\n        ADDRESS0 = _wstEth;\n        ADDRESS1 = _stader;\n        ADDRESS2 = _swell;\n\n        _updateAll();\n    }\n\n    /**\n     * @param _ionPool pool instance\n     */\n    function updateIonPool(IonPool _ionPool) external onlyOwner {\n        ionPool = _ionPool;\n    }\n\n    /**\n     * @dev Every update should also accrue interest on `IonPool`. This is\n     * because an update to the apy changes interest rates which means the\n     * previous interest rate must be accrued, or else its effect will be lost.\n     */\n    function updateAll() external {\n        ionPool.accrueInterest();\n        _updateAll();\n    }\n\n    function _updateAll() internal {\n        if (lastUpdated + UPDATE_LOCK_LENGTH > block.timestamp) revert AlreadyUpdated();\n\n        uint256 _currentIndex = currentIndex;\n        uint64[ILK_COUNT] storage previousExchangeRates = historicalExchangeRates[_currentIndex];\n\n        for (uint8 i = 0; i < ILK_COUNT;) {\n            uint64 newExchangeRate = _getExchangeRate(i);\n            uint64 previousExchangeRate = previousExchangeRates[i];\n\n            // Enforce that the exchange rate is not 0 and that it is greater\n            // than the previous exchange rate\n            if (newExchangeRate == 0 || newExchangeRate < previousExchangeRate) revert InvalidExchangeRate(i);\n\n            uint256 exchangeRateIncrease = newExchangeRate - previousExchangeRate;\n\n            // It should be noted that if this exchange rate increase were too\n            // large, it could overflow the uint32.\n            // [WAD] * [APY_PRECISION] / [WAD] = [APY_PRECISION]\n            uint32 newApy = exchangeRateIncrease.mulDiv(PERIODS, previousExchangeRate).toUint32();\n            apys[i] = newApy;\n\n            // Replace previous exchange rates with new exchange rates\n            previousExchangeRates[i] = newExchangeRate;\n\n            emit ApyUpdate(i, newApy);\n\n            // forgefmt: disable-next-line\n            unchecked { ++i; }\n        }\n\n        // update Apy, history with new exchangeRates, and currentIndex\n        currentIndex = (currentIndex + 1) % LOOK_BACK;\n        // Unsafe cast OK\n        lastUpdated = uint48(block.timestamp);\n    }\n\n    function _getExchangeRate(uint256 ilkIndex) internal view returns (uint64 exchangeRate) {\n        if (ilkIndex == 0) {\n            IWstEth wstEth = IWstEth(ADDRESS0);\n            exchangeRate = wstEth.stEthPerToken().toUint64();\n        } else if (ilkIndex == 1) {\n            IStaderStakePoolsManager stader = IStaderStakePoolsManager(ADDRESS1);\n            exchangeRate = stader.getExchangeRate().toUint64();\n        } else {\n            ISwEth swell = ISwEth(ADDRESS2);\n            exchangeRate = swell.swETHToETHRate().toUint64();\n        }\n    }\n}"
    },
    {
      "filename": "src/YieldOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport { IonPool } from \"src/IonPool.sol\";\nimport { IWstEth, IStaderStakePoolsManager, ISwEth } from \"src/interfaces/ProviderInterfaces.sol\";\n\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IYieldOracle } from \"./interfaces/IYieldOracle.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n// historicalExchangeRates can be thought of as a matrix of past exchange rates by collateral types. With a uint64 type\n// storing exchange rates, 4 can be stored in one storage slot. So each day will consume ceil(ILK_COUNT / 4) storage\n// slots.\n//\n//  look back days  | storage slot  ||                             data\n//\n//                  |                  256             172             128              64              0\n//                  |               ||  |     ilk_4     |     ilk_3     |     ilk_2     |     ilk_1     |\n//        1         |     n + 0     ||  |               |               |               |               |\n//        2         |     n + 1     ||  |               |               |               |               |\n//       ...        |    n + ...    ||  |               |               |               |               |\n//        n         |     n + n     ||  |               |               |               |               |\n//\n// A uint64 has the capacity to store up to around ~18e18 which is more than enough to fit an exchange rate that only\n// ever hovers around 1e18.\n\nuint8 constant APY_PRECISION = 8;\nuint8 constant PROVIDER_PRECISION = 18;\n\nuint32 constant LOOK_BACK = 7;\nuint256 constant PERIODS = 365 * (10 ** APY_PRECISION) / LOOK_BACK; // 52.142... eAPY_PRECISION\nuint32 constant ILK_COUNT = 3;\n// Seconds in 23.5 hours. This will allow for updates around the same time of day\nuint256 constant UPDATE_LOCK_LENGTH = 84_600;\n\n/**\n * @dev This contract stores a history of the exchange rates of each collateral\n * for the past `LOOK_BACK` days. Every time, that `updateAll()` is called, it\n * will update the value at `currentIndex` in the `historicalExchangeRates` with the\n * current exchange rate and it will also calculate the APY for each collateral\n * type based on the data currently in the buffer. The APY is calculated by\n * taking the difference between the new element being added and the element\n * being replaced. This provides a growth amount of `LOOK_BACK` days. This value\n * is then projected out to a year.\n */\ncontract YieldOracle is IYieldOracle, Ownable2Step {\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    // --- Errors ---\n\n    error InvalidExchangeRate(uint256 ilkIndex);\n    error AlreadyUpdated();\n\n    // --- Events ---\n\n    event ApyUpdate(uint256 indexed ilkIndex, uint256 newApy);\n\n    uint32[ILK_COUNT] public apys;\n\n    uint64[ILK_COUNT][LOOK_BACK] public historicalExchangeRates;\n    address public immutable ADDRESS0;\n    address public immutable ADDRESS1;\n    address public immutable ADDRESS2;\n\n    IonPool public ionPool;\n\n    uint32 public currentIndex;\n    uint48 public lastUpdated;\n\n    constructor(\n        uint64[ILK_COUNT][LOOK_BACK] memory _historicalExchangeRates,\n        address _wstEth,\n        address _stader,\n        address _swell,\n        address owner\n    )\n        Ownable(owner)\n    {\n        historicalExchangeRates = _historicalExchangeRates;\n\n        ADDRESS0 = _wstEth;\n        ADDRESS1 = _stader;\n        ADDRESS2 = _swell;\n\n        _updateAll();\n    }\n\n    /**\n     * @param _ionPool pool instance\n     */\n    function updateIonPool(IonPool _ionPool) external onlyOwner {\n        ionPool = _ionPool;\n    }\n\n    /**\n     * @dev Every update should also accrue interest on `IonPool`. This is\n     * because an update to the apy changes interest rates which means the\n     * previous interest rate must be accrued, or else its effect will be lost.\n     */\n    function updateAll() external {\n        ionPool.accrueInterest();\n        _updateAll();\n    }\n\n    function _updateAll() internal {\n        if (lastUpdated + UPDATE_LOCK_LENGTH > block.timestamp) revert AlreadyUpdated();\n\n        uint256 _currentIndex = currentIndex;\n        uint64[ILK_COUNT] storage previousExchangeRates = historicalExchangeRates[_currentIndex];\n\n        for (uint8 i = 0; i < ILK_COUNT;) {\n            uint64 newExchangeRate = _getExchangeRate(i);\n            uint64 previousExchangeRate = previousExchangeRates[i];\n\n            // Enforce that the exchange rate is not 0 and that it is greater\n            // than the previous exchange rate\n            if (newExchangeRate == 0 || newExchangeRate < previousExchangeRate) revert InvalidExchangeRate(i);\n\n            uint256 exchangeRateIncrease = newExchangeRate - previousExchangeRate;\n\n            // It should be noted that if this exchange rate increase were too\n            // large, it could overflow the uint32.\n            // [WAD] * [APY_PRECISION] / [WAD] = [APY_PRECISION]\n            uint32 newApy = exchangeRateIncrease.mulDiv(PERIODS, previousExchangeRate).toUint32();\n            apys[i] = newApy;\n\n            // Replace previous exchange rates with new exchange rates\n            previousExchangeRates[i] = newExchangeRate;\n\n            emit ApyUpdate(i, newApy);\n\n            // forgefmt: disable-next-line\n            unchecked { ++i; }\n        }\n\n        // update Apy, history with new exchangeRates, and currentIndex\n        currentIndex = (currentIndex + 1) % LOOK_BACK;\n        // Unsafe cast OK\n        lastUpdated = uint48(block.timestamp);\n    }\n\n    function _getExchangeRate(uint256 ilkIndex) internal view returns (uint64 exchangeRate) {\n        if (ilkIndex == 0) {\n            IWstEth wstEth = IWstEth(ADDRESS0);\n            exchangeRate = wstEth.stEthPerToken().toUint64();\n        } else if (ilkIndex == 1) {\n            IStaderStakePoolsManager stader = IStaderStakePoolsManager(ADDRESS1);\n            exchangeRate = stader.getExchangeRate().toUint64();\n        } else {\n            ISwEth swell = ISwEth(ADDRESS2);\n            exchangeRate = swell.swETHToETHRate().toUint64();\n        }\n    }\n}"
    },
    {
      "filename": "src/InterestRate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IYieldOracle } from \"src/interfaces/IYieldOracle.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\n\n// forgefmt: disable-start\n\nstruct IlkData {\n    // Word 1\n    uint96 adjustedProfitMargin; // 27 decimals\n    uint96 minimumKinkRate; // 27 decimals\n\n    // Word 2\n    uint16 reserveFactor; // 4 decimals\n    uint96 adjustedBaseRate; // 27 decimals\n    uint96 minimumBaseRate; // 27 decimals\n    uint16 optimalUtilizationRate; // 4 decimals\n    uint16 distributionFactor; // 4 decimals\n\n    // Word 3\n    uint96 adjustedAboveKinkSlope; // 27 decimals\n    uint96 minimumAboveKinkSlope; // 27 decimals\n}\n\n// Word 1\n//\n//                                                256  240   216   192                     96                      0\n//                                                 |    |     |     |     min_kink_rate     |   adj_profit_margin  |\n//\nuint256 constant ADJUSTED_PROFIT_MARGIN_MASK =    0x0000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF; \nuint256 constant MINIMUM_KINK_RATE_MASK =         0x0000000000000000FFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;\n\n// Word 2\n//\n//                                                256  240 224 208                     112                     16   0\n//                                                 | __ |   |   |     min_base_rate     |     adj_base_rate     |   |\n//                                                        ^   ^                                                   ^\n//                                                        ^  opt_util                                 reserve_factor\n//                                       distribution_factor\n\nuint256 constant RESERVE_FACTOR_MASK =            0x000000000000000000000000000000000000000000000000000000000000FFFF;\nuint256 constant ADJUSTED_BASE_RATE_MASK =        0x000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000;\nuint256 constant MINIMUM_BASE_RATE_MASK =         0x000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000;\nuint256 constant OPTIMAL_UTILIZATION_MASK =       0x00000000FFFF0000000000000000000000000000000000000000000000000000;\nuint256 constant DISTRIBUTION_FACTOR_MASK =       0x0000FFFF00000000000000000000000000000000000000000000000000000000;\n\n// Word 3\n//                                                256  240   216   192                     96                      0\n//                                                 |    |     |     |  min_above_kink_slope | adj_above_kink_slope |\n//\nuint256 constant ADJUSTED_ABOVE_KINK_SLOPE_MASK =  0x0000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\nuint256 constant MINIMUM_ABOVE_KINK_SLOPE_MASK =   0x0000000000000000FFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000; \n\n// forgefmt: disable-end\n\n// Word 1\nuint8 constant ADJUSTED_PROFIT_MARGIN_SHIFT = 0;\nuint8 constant MINIMUM_KINK_RATE_SHIFT = 96;\n\n// Word 2\nuint8 constant RESERVE_FACTOR_SHIFT = 0;\nuint8 constant ADJUSTED_BASE_RATE_SHIFT = 16;\nuint8 constant MINIMUM_BASE_RATE_SHIFT = 16 + 96;\nuint8 constant OPTIMAL_UTILIZATION_SHIFT = 16 + 96 + 96;\nuint8 constant DISTRIBUTION_FACTOR_SHIFT = 16 + 96 + 96 + 16;\n\n// Word 3\nuint8 constant ADJUSTED_ABOVE_KINK_SLOPE_SHIFT = 0;\nuint8 constant MINIMUM_ABOVE_KINK_SLOPE_SHIFT = 96;\n\nuint48 constant SECONDS_IN_A_YEAR = 31_536_000;\n\ncontract InterestRate {\n    using WadRayMath for *;\n\n    error CollateralIndexOutOfBounds();\n    error DistributionFactorsDoNotSumToOne(uint256 sum);\n    error TotalDebtsLength(uint256 COLLATERAL_COUNT, uint256 totalIlkDebtsLength);\n    error InvalidYieldOracleAddress();\n\n    /**\n     * @dev Packed collateral configs\n     */\n    uint256 internal immutable ILKCONFIG_0A;\n    uint256 internal immutable ILKCONFIG_0B;\n    uint256 internal immutable ILKCONFIG_0C;\n    uint256 internal immutable ILKCONFIG_1A;\n    uint256 internal immutable ILKCONFIG_1B;\n    uint256 internal immutable ILKCONFIG_1C;\n    uint256 internal immutable ILKCONFIG_2A;\n    uint256 internal immutable ILKCONFIG_2B;\n    uint256 internal immutable ILKCONFIG_2C;\n    uint256 internal immutable ILKCONFIG_3A;\n    uint256 internal immutable ILKCONFIG_3B;\n    uint256 internal immutable ILKCONFIG_3C;\n    uint256 internal immutable ILKCONFIG_4A;\n    uint256 internal immutable ILKCONFIG_4B;\n    uint256 internal immutable ILKCONFIG_4C;\n    uint256 internal immutable ILKCONFIG_5A;\n    uint256 internal immutable ILKCONFIG_5B;\n    uint256 internal immutable ILKCONFIG_5C;\n    uint256 internal immutable ILKCONFIG_6A;\n    uint256 internal immutable ILKCONFIG_6B;\n    uint256 internal immutable ILKCONFIG_6C;\n    uint256 internal immutable ILKCONFIG_7A;\n    uint256 internal immutable ILKCONFIG_7B;\n    uint256 internal immutable ILKCONFIG_7C;\n\n    uint256 public immutable COLLATERAL_COUNT;\n    IYieldOracle public immutable YIELD_ORACLE;\n\n    constructor(IlkData[] memory ilkDataList, IYieldOracle _yieldOracle) {\n        if (address(_yieldOracle) == address(0)) revert InvalidYieldOracleAddress();\n\n        COLLATERAL_COUNT = ilkDataList.length;\n        YIELD_ORACLE = _yieldOracle;\n\n        uint256 distributionFactorSum = 0;\n        for (uint256 i = 0; i < COLLATERAL_COUNT;) {\n            distributionFactorSum += i"
    }
  ]
}