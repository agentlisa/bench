{
  "Title": "TroveManager bytecodes are not recommended to be different",
  "Content": "##### Description\n`Factory` allows selecting any implementation addresses for `TroveManager` and `SortedTroves`.\n- https://github.com/prisma-fi/prisma-contracts/blob/52b26b8a2f1904b048754d5443e08d2144610b92/contracts/core/Factory.sol#L83-L84\n\nThe problem is that TroveManagers are not completely separated and the TCR calculation is made via iterating through each TroveManager. Thus, the issue in one TroveManager can break the whole system. That is why it is risky that potentially not audited implementations are allowed.\n\n##### Recommendation\nWe recommend ensuring that all connected TroveManagers share the same code. It is better to have new features separated from the audited codebase, e.g. in v2 of the protocol.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/Factory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../dependencies/PrismaOwnable.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/IDebtToken.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/IStabilityPool.sol\";\nimport \"../interfaces/ILiquidationManager.sol\";\n\n/**\n    @title Prisma Trove Factory\n    @notice Deploys cloned pairs of `TroveManager` and `SortedTroves` in order to\n            add new collateral types within the system.\n */\ncontract Factory is PrismaOwnable {\n    using Clones for address;\n\n    // fixed single-deployment contracts\n    IDebtToken public immutable debtToken;\n    IStabilityPool public immutable stabilityPool;\n    ILiquidationManager public immutable liquidationManager;\n    IBorrowerOperations public immutable borrowerOperations;\n\n    // implementation contracts, redeployed each time via clone proxy\n    address public sortedTrovesImpl;\n    address public troveManagerImpl;\n\n    mapping(address collateral => address troveManagerImpl) public troveManagerOverrides;\n    mapping(address collateral => bool deployed) public collateralDeployed;\n\n    struct DeploymentParams {\n        uint256 minuteDecayFactor;\n        uint256 redemptionFeeFloor;\n        uint256 maxRedemptionFee;\n        uint256 borrowingFeeFloor;\n        uint256 maxBorrowingFee;\n        uint256 interestRate;\n        uint256 maxDebt;\n    }\n\n    error CollateralAlreadyDeployed(address collateral);\n\n    event NewDeployment(address collateral, address priceFeed, address troveManager, address sortedTroves);\n\n    constructor(\n        address _prismaCore,\n        IDebtToken _debtToken,\n        IStabilityPool _stabilityPool,\n        IBorrowerOperations _borrowerOperations,\n        address _sortedTroves,\n        address _troveManager,\n        ILiquidationManager _liquidationManager\n    ) PrismaOwnable(_prismaCore) {\n        debtToken = _debtToken;\n        stabilityPool = _stabilityPool;\n        borrowerOperations = _borrowerOperations;\n\n        sortedTrovesImpl = _sortedTroves;\n        troveManagerImpl = _troveManager;\n        liquidationManager = _liquidationManager;\n    }\n\n    /**\n        @notice Deploy new instances of `TroveManager` and `SortedTroves`, adding\n                a new collateral type to the system.\n        @dev After calling this function, the owner should also call `Treasury.registerReceiver`\n             to enable PRISMA emissions on the newly deployed `TroveManager`\n        @param collateral Collateral token to use in new deployment\n        @param priceFeed Custom `PriceFeed` deployment. Leave as `address(0)` to use the default.\n        @param customTroveManagerImpl Custom `TroveManager` implementation to clone from.\n                                      Leave as `address(0)` to use the default.\n        @param customSortedTrovesImpl Custom `SortedTroves` implementation to clone from.\n                                      Leave as `address(0)` to use the default.\n        @param params Struct of initial parameters to be set on the new trove manager\n     */\n    function deployNewInstance(\n        address collateral,\n        address priceFeed,\n        address customTroveManagerImpl,\n        address customSortedTrovesImpl,\n        DeploymentParams memory params\n    ) external onlyOwner {\n        if (collateralDeployed[collateral]) revert CollateralAlreadyDeployed(collateral);\n        address troveManager;\n        if (customTroveManagerImpl == address(0)) {\n            troveManager = troveManagerImpl.cloneDeterministic(bytes32(bytes20(collateral)));\n        } else {\n            troveManager = customTroveManagerImpl.cloneDeterministic(bytes32(bytes20(collateral)));\n            troveManagerOverrides[collateral] = customTroveManagerImpl;\n        }\n        address sortedTroves;\n        if (customSortedTrovesImpl == address(0)) {\n            sortedTroves = sortedTrovesImpl.cloneDeterministic(bytes32(bytes20(collateral)));\n        } else {\n            sortedTroves = customSortedTrovesImpl.cloneDeterministic(bytes32(bytes20(collateral)));\n        }\n\n        ITroveManager(troveManager).setAddresses(priceFeed, sortedTroves, collateral);\n        ISortedTroves(sortedTroves).setAddresses(troveManager);\n\n        stabilityPool.enableCollateral(collateral);\n        liquidationManager.enableCollateral(troveManager, collateral);\n        debtToken.enableCollateral(troveManager);\n        borrowerOperations.enableCollateral(troveManager, collateral);\n\n        ITroveManager(troveManager).setParameters(\n            params.minuteDecayFactor,\n            params.redemptionFeeFloor,\n            params.maxRedemptionFee,\n            params.borrowingFeeFloor,\n            params.maxBorrowingFee,\n            params.interestRate,\n            params.maxDebt\n        );\n        collateralDeployed[collateral] = true;\n        emit NewDeployment(collateral, priceFeed, troveManager, sortedTroves);\n    }\n\n    function setImplementations(address _troveManagerImpl, address _sortedTrovesImpl) external onlyOwner {\n        troveManagerImpl = _troveManagerImpl;\n        sortedTrovesImpl = _sortedTrovesImpl;\n    }\n\n    function getTroveManager(address collateral) public view returns (ITroveManager) {\n        if (!collateralDeployed[collateral]) return ITroveManager(address(0));\n        address overrideImpl = troveManagerOverrides[collateral];\n        address actualTroveManagerImpl = overrideImpl == address(0) ? troveManagerImpl : overrideImpl;\n        return ITroveManager(Clones.predictDeterministicAddress(actualTroveManagerImpl, bytes32(bytes20(collateral))));\n    }\n}"
    }
  ]
}