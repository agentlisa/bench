{
  "Title": "[M-06] Missing slippage parameter on Uniswap `addLiquidity()` function",
  "Content": "\nThe Uniswap `addLiquidity()` function expects the slippage params `amountAMin`, and `amountBMin` to be passed.\n\nThe `reLP()` sets those values as `0`, which in other terms, means that the contract is ok with receiveing less amount of tokens than the fair market price when providing liquidity.\n\n### Impact\n\nLess LP tokens will be received during the `reLP()` call, as it will accept any amount of tokens while adding liquidity to Uniswap.\n\n### Proof of Concept\n\nThe `reLP()` is used by the bond functions, and uses `0` for the `amountAMin`, and `amountBMin` values passed to the `addLiquidity()` function on the Uniswap router:\n\n```solidity\n    (, , uint256 lp) = IUniswapV2Router(addresses.ammRouter).addLiquidity(\n      addresses.tokenA,\n      addresses.tokenB,\n      tokenAAmountOut,\n      amountB / 2,\n      0,                    // @audit\n      0,                    // @audit\n      address(this),\n      block.timestamp + 10\n    );\n```\n\n*   [ReLPContract.sol#L286-L295](https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/reLP/ReLPContract.sol#L286-L295)\n*   [addLiquidity() on Uniswap](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02#addliquidity)\n\nThis will make the function return less lp tokens than expected, while rebalancing.\n\n### Recommended Mitigation Steps\n\nSet the `amountAMin` and `amountBMin` parameters to the expected minimum values.\n\n**[psytama (Dopex) confirmed](https://github.com/code-423n4/2023-08-dopex-findings/issues/1032#issuecomment-1734120992)**\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/reLP/ReLPContract.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IUniswapV2Router } from \"../uniswap_V2/IUniswapV2Router.sol\";\nimport { IUniswapV2Pair } from \"../uniswap_V2/IUniswapV2Pair.sol\";\nimport { IRdpxReserve } from \"../reserve/IRdpxReserve.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IRdpxV2Core } from \"../core/IRdpxV2Core.sol\";\nimport { IUniV2LiquidityAmo } from \"../interfaces/IUniV2LiquidityAmo.sol\";\n\n// Libraries\nimport { UniswapV2Library } from \"../uniswap_V2/libraries/UniswapV2Library.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title reLP contract\n/// @author Dopex\n/// @notice The reLP contract is a contract that ReLP's liquidity\ncontract ReLPContract is AccessControl {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeMath for uint256;\n\n  // ================================ STATE VARIABLES ================================ //\n  struct Addresses {\n    // token A address\n    address tokenA; // rdpx\n    // token B address\n    address tokenB; // weth\n    // pair address\n    address pair;\n    // rdpxV2Core address\n    address rdpxV2Core;\n    // tokenA reserve address\n    address tokenAReserve;\n    // amo address\n    address amo;\n    // rdpx price oracle\n    address rdpxOracle;\n    // AMM Factory\n    address ammFactory;\n    // AMM Router\n    address ammRouter;\n  }\n\n  struct TokenAInfo {\n    // tokenA reserves\n    uint256 tokenAReserve;\n    // rdpx price\n    uint256 tokenAPrice;\n    // tokenA LP reserves\n    uint256 tokenALpReserve;\n  }\n\n  /// @notice  addresses of the contracts\n  Addresses public addresses;\n\n  /// @notice reLP factor\n  uint256 public reLPFactor;\n\n  /// @notice Precision used for prices, percentages and other calculations\n  uint256 public constant DEFAULT_PRECISION = 1e8;\n\n  /// @notice rdpxV2Core role\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  /// @notice liquidity slippage tolerance\n  uint256 public liquiditySlippageTolerance = 5e5; // 0.5%\n\n  /// @notice The slippage tolernce in swaps in 1e8 precision\n  uint256 public slippageTolerance = 5e5; // 0.5%\n\n  // ================================ CONSTRUCTOR ================================ //\n  constructor() {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(RDPXV2CORE_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n  /**\n   * @notice Set the re-LP factor\n   * @dev    Can only be called by admin\n   * @param  _reLPFactor the bond discount factor\n   **/\n  function setreLpFactor(\n    uint256 _reLPFactor\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _reLPFactor > 0,\n      \"reLPContract: reLP factor must be greater than 0\"\n    );\n    reLPFactor = _reLPFactor;\n\n    emit LogSetReLpFactor(_reLPFactor);\n  }\n\n  /**\n   * @notice Set the addresses of the contracts\n   * @dev    Can only be called by admin\n   * @param  _tokenA the token A address\n   * @param  _tokenB the token B address\n   * @param _pair the pair address\n   * @param _rdpxV2Core the rdpxV2Core address\n   * @param _tokenAReserve the token A reserve address\n   * @param _amo the AMO address\n   * @param _rdpxOracle the rdpx price oracle\n   * @param _ammFactory the AMM Factory\n   * @param _ammRouter the AMM Router\n   **/\n  function setAddresses(\n    address _tokenA,\n    address _tokenB,\n    address _pair,\n    address _rdpxV2Core,\n    address _tokenAReserve,\n    address _amo,\n    address _rdpxOracle,\n    address _ammFactory,\n    address _ammRouter\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _tokenA != address(0) &&\n        _tokenB != address(0) &&\n        _pair != address(0) &&\n        _rdpxV2Core != address(0) &&\n        _tokenAReserve != address(0) &&\n        _amo != address(0) &&\n        _rdpxOracle != address(0) &&\n        _ammFactory != address(0) &&\n        _ammRouter != address(0),\n      \"reLPContract: address cannot be 0\"\n    );\n    addresses = Addresses({\n      tokenA: _tokenA,\n      tokenB: _tokenB,\n      pair: _pair,\n      rdpxV2Core: _rdpxV2Core,\n      tokenAReserve: _tokenAReserve,\n      amo: _amo,\n      rdpxOracle: _rdpxOracle,\n      ammFactory: _ammFactory,\n      ammRouter: _ammRouter\n    });\n\n    IERC20WithBurn(addresses.pair).safeApprove(\n      addresses.ammRouter,\n      type(uint256).max\n    );\n\n    IERC20WithBurn(addresses.tokenA).safeApprove(\n      addresses.ammRouter,\n      type(uint256).max\n    );\n\n    IERC20WithBurn(addresses.tokenB).safeApprove(\n      addresses.ammRouter,\n      type(uint256).max\n    );\n  }\n\n  /**\n   * @notice sets the liquidity slippage tolerance\n   * @dev    Can only be called by admin\n   * @param  _liquiditySlippageTolerance the liquidity slippage tolerance\n   */\n  function setLiquiditySlippageTolerance(\n    uint256 _liquiditySlippageTolerance\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _liquiditySlippageTolerance > 0,\n      \"reLPContract: liquidity slippage tolerance must be greater than 0\"\n    );\n    liquiditySlippageTolerance = _liquiditySlippageTolerance;\n  }\n\n  /**\n   * @notice sets the slippage tolerance\n   * @dev    Can only be called by admin\n   * @param  _slippageTolerance the slippage tolerance\n   */\n  function setSlippageTolerance(\n    uint256 _slippageTolerance\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _slippageTolerance > 0,\n      \"reLPContract: slippage tolerance must be greater than 0\"\n    );\n    slippageTolerance = _slippageTolerance;\n  }\n\n  // ================================ RdpxV2Core FUNCTIONS ================================ //\n\n  /**\n   * @dev   re-LPs the pool\n   * @param _amount the amount to reLP\n   **/\n  function reLP(uint256 _amount) external onlyRole(RDPXV2CORE_ROLE) {\n    // get the pool reserves\n    (address tokenASorted, address tokenBSorted) = UniswapV2Library.sortTokens(\n      addresses.tokenA,\n      addresses.tokenB\n    );\n    (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(\n      addresses.ammFactory,\n      tokenASorted,\n      tokenBSorted\n    );\n\n    TokenAInfo memory tokenAInfo = TokenAInfo(0, 0, 0);\n\n    // get tokenA reserves\n    tokenAInfo.tokenAReserve = IRdpxReserve(addresses.tokenAReserve)\n      .rdpxReserve(); // rdpx reserves\n\n    // get rdpx price\n    tokenAInfo.tokenAPrice = IRdpxEthOracle(addresses.rdpxOracle)\n      .getRdpxPriceInEth();\n\n    tokenAInfo.tokenALpReserve = addresses.tokenA == tokenASorted\n      ? reserveA\n      : reserveB;\n\n    uint256 baseReLpRatio = (reLPFactor *\n      Math.sqrt(tokenAInfo.tokenAReserve) *\n      1e2) / (Math.sqrt(1e18)); // 1e6 precision\n\n    uint256 tokenAToRemove = ((((_amount * 4) * 1e18) /\n      tokenAInfo.tokenAReserve) *\n      tokenAInfo.tokenALpReserve *\n      baseReLpRatio) / (1e18 * DEFAULT_PRECISION * 1e2);\n\n    uint256 totalLpSupply = IUniswapV2Pair(addresses.pair).totalSupply();\n\n    uint256 lpToRemove = (tokenAToRemove * totalLpSupply) /\n      tokenAInfo.tokenALpReserve;\n\n    // transfer LP tokens from the AMO\n    IERC20WithBurn(addresses.pair).transferFrom(\n      addresses.amo,\n      address(this),\n      lpToRemove\n    );\n\n    // calculate min amounts to remove\n    uint256 mintokenAAmount = tokenAToRemove -\n      ((tokenAToRemove * liquiditySlippageTolerance) / 1e8);\n    uint256 mintokenBAmount = ((tokenAToRemove * tokenAInfo.tokenAPrice) /\n      1e8) -\n      ((tokenAToRemove * tokenAInfo.tokenAPrice) * liquiditySlippageTolerance) /\n      1e16;\n\n    (, uint256 amountB) = IUniswapV2Router(addresses.ammRouter).removeLiquidity(\n      addresses.tokenA,\n      addresses.tokenB,\n      lpToRemove,\n      mintokenAAmount,\n      mintokenBAmount,\n      address(this),\n      block.timestamp + 10\n    );\n\n    address[] memory path;\n    path = new address[](2);\n    path[0] = addresses.tokenB;\n    path[1] = addresses.tokenA;\n\n    // calculate min amount of tokenA to be received\n    mintokenAAmount =\n      (((amountB / 2) * tokenAInfo.tokenAPrice) / 1e8) -\n      (((amountB / 2) * tokenAInfo.tokenAPrice * slippageTolerance) / 1e16);\n\n    uint256 tokenAAmountOut = IUniswapV2Router(addresses.ammRouter)\n      .swapExactTokensForTokens(\n        amountB / 2,\n        mintokenAAmount,\n        path,\n        address(this),\n        block.timestamp + 10\n      )[path.length - 1];\n\n    (, , uint256 lp) = IUniswapV2Router(addresses.ammRouter).addLiquidity(\n      addresses.tokenA,\n      addresses.tokenB,\n      tokenAAmountOut,\n      amountB / 2,\n      0,\n      0,\n      address(this),\n      block.timestamp + 10\n    );\n\n    // transfer the lp to the amo\n    IERC20WithBurn(addresses.pair).safeTransfer(addresses.amo, lp);\n    IUniV2LiquidityAmo(addresses.amo).sync();\n\n    // transfer rdpx to rdpxV2Core\n    IERC20WithBurn(addresses.tokenA).safeTransfer(\n      addresses.rdpxV2Core,\n      IERC20WithBurn(addresses.tokenA).balanceOf(address(this))\n    );\n    IRdpxV2Core(addresses.rdpxV2Core).sync();\n  }\n\n  // ================================ Events FUNCTIONS ================================ //\n\n  event LogSetReLpFactor(uint256 _reLPFactor);\n}"
    }
  ]
}