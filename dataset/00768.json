{
  "Title": "M-3: FundRateArbitrage is vulnerable to inflation attacks",
  "Content": "# Issue M-3: FundRateArbitrage is vulnerable to inflation attacks \n\nSource: https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/54 \n\n## Found by \n0x52, Ignite, bughuntoor, detectiveking, giraffe, rvierdiiev\n## Summary\n\nWhen index is calculated, it is figured by dividing the net value of the contract (including USDC held) by the current supply of earnUSDC. Through deposit and donation this ratio can be inflated. Then when others deposit, their deposit can be taken almost completely via rounding.\n\n## Vulnerability Detail\n\n[FundingRateArbitrage.sol#L98-L104](https://github.com/sherlock-audit/2023-12-jojo-exchange-update/blob/main/smart-contract-EVM/src/FundingRateArbitrage.sol#L98-L104)\n\n    function getIndex() public view returns (uint256) {\n        if (totalEarnUSDCBalance == 0) {\n            return 1e18;\n        } else {\n            return SignedDecimalMath.decimalDiv(getNetValue(), totalEarnUSDCBalance);\n        }\n    }\n\nIndex is calculated is by dividing the net value of the contract (including USDC held) by the current supply of totalEarnUSDCBalance. This can be inflated via donation. Assume the user deposits 1 share then donates 100,000e6 USDC. The exchange ratio is now 100,000e18 which causes issues during deposits.\n\n[FundingRateArbitrage.sol#L258-L275](https://github.com/sherlock-audit/2023-12-jojo-exchange-update/blob/main/smart-contract-EVM/src/FundingRateArbitrage.sol#L258-L275)\n\n    function deposit(uint256 amount) external {\n        require(amount != 0, \"deposit amount is zero\");\n        uint256 feeAmount = amount.decimalMul(depositFeeRate);\n        if (feeAmount > 0) {\n            amount -= feeAmount;\n            IERC20(usdc).transferFrom(msg.sender, owner(), feeAmount);\n        }\n        uint256 earnUSDCAmount = amount.decimalDiv(getIndex());\n        IERC20(usdc).transferFrom(msg.sender, address(this), amount);\n        JOJODealer(jojoDealer).deposit(0, amount, msg.sender);\n        earnUSDCBalance[msg.sender] += earnUSDCAmount;\n        jusdOutside[msg.sender] += amount;\n        totalEarnUSDCBalance += earnUSDCAmount;\n        require(getNetValue() <= maxNetValue, \"net value exceed limitation\");\n        uint256 quota = maxUsdcQuota[msg.sender] == 0 ? defaultUsdcQuota : maxUsdcQuota[msg.sender];\n        require(earnUSDCBalance[msg.sender].decimalMul(getIndex()) <= quota, \"usdc amount bigger than quota\");\n        emit DepositToHedging(msg.sender, amount, feeAmount, earnUSDCAmount);\n    }\n\nNotice earnUSDCAmount is amount / index. With the inflated index that would mean that any deposit under 100,000e6 will get zero shares, making it exactly like the standard ERC4626 inflation attack.\n\n## Impact\n\nSubsequent user deposits can be stolen\n\n## Code Snippet\n\n[FundingRateArbitrage.sol#L258-L275](https://github.com/sherlock-audit/2023-12-jojo-exchange-update/blob/main/smart-contract-EVM/src/FundingRateArbitrage.sol#L258-L275)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a virtual offset as suggested by [OZ](https://docs.openzeppelin.com/contracts/4.x/erc4626) for their ERC4626 contracts\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { valid as watson demostrated how this implementation will lead to an inflation attack of the ERC4626 but its medium due to the possibility of it is very low and that front-tun in arbitrum is very unlikely }\n\n\n\n**detectiveking123**\n\nEscalate\n\nI am not completely sure about the judgement here and am therefore escalating to get @Czar102 's opinion on how this should be judged.\n\nI believe that #56 and #21 should be treated as different issues than this one. I am not even sure if this issue and other duplicates are valid, as they rely on the front-running on Arbitrum assumption, which has not been explicitly confirmed to be valid or invalid on Sherlock. \n\nPlease take a look at the thread on #56 to better understand the differences. But the TLDR is:\n\n1. This issue requires Arbitrum frontrunning to work, the other one in #56 doesn't\n2. The one in #56 takes advantage of a separate rounding error as well to fully drain funds inside the contract\n\n\n**sherlock-admin**\n\n> Escalate\n> \n> I am not completely sure about the judgement here and am therefore escalating to get @Czar102 's opinion on how this should be judged.\n> \n> I believe that #56 and #21 should be treated as different issues than this one. I am not even sure if this issue and other duplicates are valid, as they rely on the front-running on Arbitrum assumption, which has not been explicitly confirmed to be valid or invalid on Sherlock. \n> \n> Please take a look at the thread on #56 to better understand the differences. But the TLDR is:\n> \n> 1. This issue requires Arbitrum frontrunning to work, the other one in #56 doesn't\n> 2. The one in #56 takes advantage of a separate rounding error as well to fully drain funds inside the contract\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**JoscelynFarr**\n\nFixed PR: https://github.com/JOJOexchange/smart-contract-EVM/commit/b3cf3d6d6b761059f814efb84af53c5ead4f6446\n\n**nevillehuang**\n\n@detectiveking123 \n\n- I think both this issue and your issue implies that the user needs to be the first depositor, especially the scenario highlighted. This does not explicitly requires a front-run, given a meticulous user can make their own EV calculations.\n\nThis issue:\n\n> Assume the user deposits 1 share then donates 100,000e6 USDC. The exchange ratio is now 100,000e18 which causes issues during deposits.\n\nYour issue:\n> The execution of this is a bit more complicated, let's go through an example. We will assume there's a bunch of JUSD existing in the contract and the attacker is the first to deposit.\n\n- I think one of the watsons in the discord channel highlighted a valid design of the protocol to mitigate this issue, where withdrawals must be explicitly requested. Because of this, this could possibly be medium severity.\n\n**giraffe0x**\n\nDisagree that the request/permit design prevents this. \n\nAs described in code comments for `requestWithdraw()`: \"The main purpose of this function is to capture the interest and avoid the DOS attacks\". It is unlikely that withdraw requests are individually scrutinized and manually permitted by owner but automatically executed by bots in batches. Even if the owner does monitor each request, it would be tricky to spot dishonest deposits/withdrawals. \n\nIt is better to implement native contract defence a classic ERC4626 attack. Should be kept as a high finding. \n\n**nevillehuang**\n\n@giraffe0x Again you are speculating on off-chain mechanisms. While it is a valid concern, the focus should be on contract level code logic, and sherlocks assumption is that admin will make the right decisions when permitting withdrawal requests.\n\nAlso, here is the most recent example of where first depositor inflation is rated as medium:\n\nhttps://github.com/sherlock-audit/2023-12-dodo-gsp-judging/issues/55\n\n**detectiveking123**\n\n@nevillehuang \n\n\"I think both this issue and your issue implies that the user needs to be the first depositor, especially the scenario highlighted. This does not explicitly requires a front-run, given a meticulous user can make their own EV calculations.\"\n\nHow would you run this attack without front-running? Share inflation attacks explicitly require front-running\n\n**nevillehuang**\n\n@detectiveking123 I agree that the only possible reason for this issue to be valid is if \n\n- It so happens that a depositor is the first depositor, and he made his own EV calculations and realized so based on the shares obtained and current exchange ratios (slim chance of happening given front-running is a non-issue on arbitrum, but not impossible)\n- If the attack does not explicitly require a first depositor inflation attack (to my knowledge not possible), which I believe none of the **original** issues showed a scenario/explanation it is so (Even #21 and #57 is highlighting a first depositor scenario)\n\nIf both of the above scenario does not apply, all of the issues and its duplicates should be low severity.\n\n**IAm0x52**\n\nFix looks good. Adds a virtual offset which prevents this issue.\n\n**Evert0x**\n\nFront-running isn't necessary as the attacker can deposit 1 wei + donate and just wait for someone to make a deposit under 100,000e6.\n\nBut this way the attack is still risky to execute as the attacker will lose the donated USDC in case he isn't the first depositor. \n\nHowever, this can be mitigated if the attacker created a contract the does the 1 wei deposit + donate action in a single transaction BUT revert in case it isn't the first deposit in the protocol.\n\nPlanning to reject escalation and keep issue state as is.  \n\n**detectiveking123**\n\n@Evert0x not sure that makes sense, if you just wait for someone then they should just not deposit (it's a user mistake to deposit, they should be informed that they'll retrieve no shares back in the UI).\n\n\n**Czar102**\n\nAfter a discussion with @Evert0x, planning to make it a Medium severity issue â€“ frontend can display information for users not to fall victim to this exploit by displaying a number of output shares.\nEven though frontrunning a tx can't be done easily (there is no mempool), one can obtain information about a transaction being submitted in another way. Since this puts severe constraints on this being exploitable, planning to consider it a medium severity issue.\n\n**detectiveking123**\n\n@Czar102 My issue that has been duplicated with this (https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/57) drains the entire contract (clearly a high) and requires no front-running. The purpose of the escalation was primarily to request deduplication. \n\n**Czar102**\n\nPlanning to consider #57 a separate High severity issue. #57 linked this finding together with another bug (ability to withdraw 1 wei of vault token in value for free) to construct a more severe exploit.\n\nAlso, planning to consider this issue a Medium severity one, as mentioned above.\n\n**deadrosesxyz**\n\nWith all due respect, this is against the rules\n\n> Issues identifying a core vulnerability can be considered duplicates.\nScenario A:\nThere is a root cause/error/vulnerability A in the code. This vulnerability A -> leads to two attack paths:\n- B -> high severity path\n- C -> medium severity attack path/just identifying the vulnerability.\nBoth B & C would not have been possible if error A did not exist in the first place. In this case, both B & C should be put together as duplicates.\n\n**detectiveking123**\n\nIt's worth noting that you can still drain the contract with the exploit described in #57 and #21, even without share inflation (The main issue is a rounding issue that allows you to get one more share than intended, so your profit will be the current share value). If the share price is trivial though, the exploiter will likely lose money to gas fees while draining. \n\nThis is why I said I'm not sure about the judging of this issue in the initial escalation, as it seems rather subjective. \n\n**Czar102**\n\n@deadrosesxyz There are two different vulnerabilities requiring two different fixes. In the fragment of the docs you quoted, all B and C are a result of a single vulnerability A, which is not the case here.\n\n**Czar102**\n\nPlanning to make #57 a separate high, I don't see how is #21 presenting the same vulnerability. This issue and duplicates (including #21) will be considered a Medium.\n\n**IAm0x52**\n\nWhy exactly would it be high and this one medium? Both rely on being first depositor (not frontrunning) and inflation\n\nEdit: As stated in the other submission it is technically possible outside of first depositor but profit would be marginal and wouldn't cover gas costs. IMO hard to even call it a different exploit when both have the same prerequisites and same basic attack structure (first depositor and inflation).\n\n**Czar102**\n\n#57 presents a way to withdraw equivalent of 1 wei of the vault token for free. This issue and duplicates present a way to inflate the share price being the first depositor, and in case of the frontend displaying all needed information, one needs to frontrun a deposit transaction to execute the attack.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [detectiveking123](https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/54/#issuecomment-1913270709): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/136",
  "Code": [
    {
      "filename": "smart-contract-EVM/src/FundingRateArbitrage.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1\n*/\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./JOJODealer.sol\";\nimport \"./interfaces/IPerpetual.sol\";\nimport \"./interfaces/IJUSDBank.sol\";\nimport \"./libraries/SignedDecimalMath.sol\";\n\npragma solidity ^0.8.20;\n\n/// @notice This contract involves offsetting trades in both the spot and perpetual contract markets\n/// to capture the funding rate income in perpetual contract trading. Liquidy provider can deposit usdc\n/// to this pool and accumulate interest.\ncontract FundingRateArbitrage is Ownable {\n    struct WithdrawalRequest {\n        uint256 earnUSDCAmount;\n        address user;\n        bool isExecuted;\n    }\n\n    using SafeERC20 for IERC20;\n    using SignedDecimalMath for uint256;\n\n    address public immutable collateral;\n    address public immutable jusdBank;\n    address public immutable jojoDealer;\n    address public immutable perpMarket;\n    address public immutable usdc;\n    address public immutable jusd;\n\n    uint256 public maxNetValue;\n    uint256 public totalEarnUSDCBalance;\n    uint256 public depositFeeRate;\n    uint256 public withdrawFeeRate;\n    uint256 public withdrawSettleFee;\n    uint256 public defaultUsdcQuota;\n\n    mapping(address => uint256) public earnUSDCBalance;\n    mapping(address => uint256) public jusdOutside;\n    mapping(address => uint256) public maxUsdcQuota;\n\n    WithdrawalRequest[] public withdrawalRequests;\n\n    // Event\n    event DepositToHedging(address from, uint256 USDCAmount, uint256 feeAmount, uint256 earnUSDCAmount);\n\n    event RequestWithdrawFromHedging(\n        address from, uint256 RepayJUSDAmount, uint256 withdrawEarnUSDCAmount, uint256 index\n    );\n\n    event PermitWithdraw(address from, uint256 USDCAmount, uint256 feeAmount, uint256 earnUSDCAmount, uint256 index);\n\n    event Swap(address fromToken, address toToken, uint256 payAmount, uint256 receivedAmount);\n\n    constructor(\n        address _collateral,\n        address _jusdBank,\n        address _jojoDealer,\n        address _perpMarket,\n        address _Operator\n    )\n        Ownable()\n    {\n        collateral = _collateral;\n        jusdBank = _jusdBank;\n        jojoDealer = _jojoDealer;\n        perpMarket = _perpMarket;\n        (address USDC, address JUSD,,,,,) = JOJODealer(jojoDealer).state();\n        usdc = USDC;\n        jusd = JUSD;\n        JOJODealer(jojoDealer).setOperator(_Operator, true);\n        IERC20(collateral).approve(jusdBank, type(uint256).max);\n        IERC20(jusd).approve(jusdBank, type(uint256).max);\n        IERC20(jusd).approve(jojoDealer, type(uint256).max);\n        IERC20(usdc).approve(jojoDealer, type(uint256).max);\n    }\n\n    // View\n\n    /// @notice this function is to return the sum of netValue in whole system.\n    /// including the netValue in collateral system, trading system and buffer usdc\n    function getNetValue() public view returns (uint256) {\n        uint256 jusdBorrowed = IJUSDBank(jusdBank).getBorrowBalance(address(this));\n        uint256 collateralAmount = IJUSDBank(jusdBank).getDepositBalance(collateral, address(this));\n        uint256 usdcBuffer = IERC20(usdc).balanceOf(address(this));\n        uint256 collateralPrice = IJUSDBank(jusdBank).getCollateralPrice(collateral);\n        (int256 perpNetValue,,,) = JOJODealer(jojoDealer).getTraderRisk(address(this));\n        return\n            SafeCast.toUint256(perpNetValue) + collateralAmount.decimalMul(collateralPrice) + usdcBuffer - jusdBorrowed;\n    }\n\n    /// @notice this function is to return the ratio between netValue and totalEarnUSDCBalance\n    function getIndex() public view returns (uint256) {\n        if (totalEarnUSDCBalance == 0) {\n            return 1e18;\n        } else {\n            return SignedDecimalMath.decimalDiv(getNetValue(), totalEarnUSDCBalance);\n        }\n    }\n\n    function buildSpotSwapData(\n        address approveTarget,\n        address swapTarget,\n        uint256 payAmount,\n        bytes memory callData\n    )\n        public\n        pure\n        returns (bytes memory spotTradeParam)\n    {\n        spotTradeParam = abi.encode(approveTarget, swapTarget, payAmount, callData);\n    }\n\n    //Only Owner\n\n    /// @notice this function is to set Operator who can operate this pool\n    function setOperator(address operator, bool isValid) public onlyOwner {\n        JOJODealer(jojoDealer).setOperator(operator, isValid);\n    }\n\n    function setMaxNetValue(uint256 newMaxNetValue) public onlyOwner {\n        maxNetValue = newMaxNetValue;\n    }\n\n    function setDepositFeeRate(uint256 newDepositFeeRate) public onlyOwner {\n        depositFeeRate = newDepositFeeRate;\n    }\n\n    function setWithdrawFeeRate(uint256 newWithdrawFeeRate) public onlyOwner {\n        withdrawFeeRate = newWithdrawFeeRate;\n    }\n\n    function setDefaultQuota(uint256 defaultQuota) public onlyOwner {\n        defaultUsdcQuota = defaultQuota;\n    }\n\n    /// @notice this function is to set the personal deposit quota\n    function setPersonalQuota(address to, uint256 personalQuota) public onlyOwner {\n        maxUsdcQuota[to] = personalQuota;\n    }\n\n    function setWithdrawSettleFee(uint256 newWithdrawSettleFee) public onlyOwner {\n        withdrawSettleFee = newWithdrawSettleFee;\n    }\n\n    function refundJUSD(uint256 amount) public onlyOwner {\n        IERC20(jusd).safeTransfer(msg.sender, amount);\n    }\n\n    /// @notice this function is to swap usdc to eth and deposit to collateral system\n    /// @param minReceivedCollateral is the minimum eth received\n    /// @param spotTradeParam is param to swap usdc to eth, can build by this function: `buildSpotSwapData`\n    function swapBuyEth(uint256 minReceivedCollateral, bytes memory spotTradeParam) public onlyOwner {\n        uint256 receivedCollateral = _swap(spotTradeParam, true);\n        require(receivedCollateral >= minReceivedCollateral, \"SWAP SLIPPAGE\");\n        _depositToJUSDBank(IERC20(collateral).balanceOf(address(this)));\n    }\n\n    /// @notice this function is to withdraw eth to the pool and swap eth to usdc\n    /// @param minReceivedUSDC is the minimum usdc received\n    /// @param collateralAmount is the expected eth amount which withdraw from collateral system\n    /// @param spotTradeParam is param to swap eth to usdc, can build by this function: `buildSpotSwapData`\n    function swapSellEth(\n        uint256 minReceivedUSDC,\n        uint256 collateralAmount,\n        bytes memory spotTradeParam\n    )\n        public\n        onlyOwner\n    {\n        _withdrawFromJUSDBank(collateralAmount);\n        uint256 receivedUSDC = _swap(spotTradeParam, false);\n        require(receivedUSDC >= minReceivedUSDC, \"SWAP SLIPPAGE\");\n    }\n\n    /// @notice this function is to borrow jusd from collateral system and deposit to trading system\n    /// @param JUSDAmount is the expected borrowed amount.\n    function borrow(uint256 JUSDAmount) public onlyOwner {\n        _borrowJUSD(JUSDAmount);\n    }\n\n    /// @notice this function is to withdraw jusd from trading system and repay to collateral system\n    /// @param JUSDRebalanceAmount is the expected repay amount.\n    function repay(uint256 JUSDRebalanceAmount) public onlyOwner {\n        JOJODealer(jojoDealer).fastWithdraw(address(this), address(this), 0, JUSDRebalanceAmount, false, \"\");\n        _repayJUSD(JUSDRebalanceAmount);\n    }\n\n    function _swap(bytes memory param, bool isBuyingEth) private returns (uint256 receivedAmount) {\n        address fromToken;\n        address toToken;\n        if (isBuyingEth) {\n            fromToken = usdc;\n            toToken = collateral;\n        } else {\n            fromToken = collateral;\n            toToken = usdc;\n        }\n        uint256 toTokenReserve = IERC20(toToken).balanceOf(address(this));\n        (address approveTarget, address swapTarget, uint256 payAmount, bytes memory callData) =\n            abi.decode(param, (address, address, uint256, bytes));\n        IERC20(fromToken).safeApprove(approveTarget, payAmount);\n        (bool isSuccess,) = swapTarget.call(callData);\n        if (!isSuccess) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n        receivedAmount = IERC20(toToken).balanceOf(address(this)) - toTokenReserve;\n        emit Swap(fromToken, toToken, payAmount, receivedAmount);\n    }\n\n    // JUSDBank Operations\n    function _borrowJUSD(uint256 JUSDAmount) internal {\n        IJUSDBank(jusdBank).borrow(JUSDAmount, address(this), true);\n    }\n\n    function _repayJUSD(uint256 amount) internal {\n        IJUSDBank(jusdBank).repay(amount, address(this));\n    }\n\n    function _withdrawFromJUSDBank(uint256 amount) internal {\n        IJUSDBank(jusdBank).withdraw(collateral, amount, address(this), false);\n    }\n\n    function _depositToJUSDBank(uint256 amount) internal {\n        IJUSDBank(jusdBank).deposit(address(this), collateral, amount, address(this));\n    }\n\n    // JOJODealer Operations\n\n    /// @notice this function is to deposit the buffered usdc from pool to trading system\n    /// @param primaryAmount is the expected deposit primary amount.\n    function depositUSDCToPerp(uint256 primaryAmount) public onlyOwner {\n        JOJODealer(jojoDealer).deposit(primaryAmount, 0, address(this));\n    }\n\n    /// @notice this function is to withdraw the buffered usdc from trading system to pool\n    /// @param primaryAmount is the expected withdraw primary amount.\n    function fastWithdrawUSDCFromPerp(uint256 primaryAmount) public onlyOwner {\n        JOJODealer(jojoDealer).fastWithdraw(address(this), address(this), primaryAmount, 0, false, \"\");\n    }\n\n    // LP Functions\n\n    /// @notice this function is called by liquidity providers, users can deposit usdc to arbitrage\n    /// @dev During the deposit, users usdc will transfer to the system and system will return\n    /// the equivalent amount of jusd which deposit to the trading system.\n    /// @param amount is the expected deposit usdc amount.\n    function deposit(uint256 amount) external {\n        require(amount != 0, \"deposit amount is zero\");\n        uint256 feeAmount = amount.decimalMul(depositFeeRate);\n        if (feeAmount > 0) {\n            amount -= feeAmount;\n            IERC20(usdc).transferFrom(msg.sender, owner(), feeAmount);\n        }\n        uint256 earnUSDCAmount = amount.decimalDiv(getIndex());\n        IERC20(usdc).transferFrom(msg.sender, address(this), amount);\n        JOJODealer(jojoDealer).deposit(0, amount, msg.sender);\n        earnUSDCBalance[msg.sender] += earnUSDCAmount;\n        jusdOutside[msg.sender] += amount;\n        totalEarnUSDCBalance += earnUSDCAmount;\n        require(getNetValue() <= maxNetValue, \"net value exceed limitation\");\n        uint256 quota = maxUsdcQuota[msg.sender] == 0 ? defaultUsdcQuota : maxUsdcQuota[msg.sender];\n        require(earnUSDCBalance[msg.sender].decimalMul(getIndex()) <= quota, \"usdc amount bigger than quota\");\n        emit DepositToHedging(msg.sender, amount, feeAmount, earnUSDCAmount);\n    }\n\n    /// @notice this function is to submit a withdrawal which wiil permit by our system in 24 hours\n    /// The main purpose of this function is to capture the interest and avoid the DOS attacks.\n    /// @dev users need to withdraw jusd from trading system firstly or by jusd, then transfer jusd to\n    /// the pool and get usdc back\n    /// @param repayJUSDAmount is the repat jusd amount\n    function requestWithdraw(uint256 repayJUSDAmount) external returns (uint256 withdrawEarnUSDCAmount) {\n        IERC20(jusd).safeTransferFrom(msg.sender, address(this), repayJUSDAmount);\n        require(repayJUSDAmount <= jusdOutside[msg.sender], \"Request Withdraw too big\");\n        jusdOutside[msg.sender] -= repayJUSDAmount;\n        uint256 index = getIndex();\n        uint256 lockedEarnUSDCAmount = jusdOutside[msg.sender].decimalDiv(index);\n        require(\n            earnUSDCBalance[msg.sender] >= lockedEarnUSDCAmount, \"lockedEarnUSDCAmount is bigger than earnUSDCBalance\"\n        );\n        withdrawEarnUSDCAmount = earnUSDCBalance[msg.sender] - lockedEarnUSDCAmount;\n        withdrawalRequests.push(WithdrawalRequest(withdrawEarnUSDCAmount, msg.sender, false));\n        require(\n            withdrawEarnUSDCAmount.decimalMul(index) >= withdrawSettleFee, \"Withdraw amount is smaller than settleFee\"\n        );\n        earnUSDCBalance[msg.sender] = lockedEarnUSDCAmount;\n        uint256 withdrawIndex = withdrawalRequests.length - 1;\n        emit RequestWithdrawFromHedging(msg.sender, repayJUSDAmount, withdrawEarnUSDCAmount, withdrawIndex);\n        return withdrawIndex;\n    }\n\n    /// @notice this function is to permit withdrawals which are submit by liqudity provider\n    /// @param requestIDList is the request ids\n    function permitWithdrawRequests(uint256[] memory requestIDList) external onlyOwner {\n        uint256 index = getIndex();\n        for (uint256 i; i < requestIDList.length; i++) {\n            WithdrawalRequest storage request = withdrawalRequests[requestIDList[i]];\n            require(!request.isExecuted, \"request has been executed\");\n            uint256 USDCAmount = request.earnUSDCAmount.decimalMul(index);\n            require(USDCAmount >= withdrawSettleFee, \"USDCAmount need to bigger than withdrawSettleFee\");\n            uint256 feeAmount = (USDCAmount - withdrawSettleFee).decimalMul(withdrawFeeRate) + withdrawSettleFee;\n            if (feeAmount > 0) {\n                IERC20(usdc).transfer(owner(), feeAmount);\n            }\n            IERC20(usdc).transfer(request.user, USDCAmount - feeAmount);\n            request.isExecuted = true;\n            totalEarnUSDCBalance -= request.earnUSDCAmount;\n            emit PermitWithdraw(request.user, USDCAmount, feeAmount, request.earnUSDCAmount, requestIDList[i]);\n        }\n    }\n}"
    },
    {
      "filename": "smart-contract-EVM/src/FundingRateArbitrage.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1\n*/\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./JOJODealer.sol\";\nimport \"./interfaces/IPerpetual.sol\";\nimport \"./interfaces/IJUSDBank.sol\";\nimport \"./libraries/SignedDecimalMath.sol\";\n\npragma solidity ^0.8.20;\n\n/// @notice This contract involves offsetting trades in both the spot and perpetual contract markets\n/// to capture the funding rate income in perpetual contract trading. Liquidy provider can deposit usdc\n/// to this pool and accumulate interest.\ncontract FundingRateArbitrage is Ownable {\n    struct WithdrawalRequest {\n        uint256 earnUSDCAmount;\n        address user;\n        bool isExecuted;\n    }\n\n    using SafeERC20 for IERC20;\n    using SignedDecimalMath for uint256;\n\n    address public immutable collateral;\n    address public immutable jusdBank;\n    address public immutable jojoDealer;\n    address public immutable perpMarket;\n    address public immutable usdc;\n    address public immutable jusd;\n\n    uint256 public maxNetValue;\n    uint256 public totalEarnUSDCBalance;\n    uint256 public depositFeeRate;\n    uint256 public withdrawFeeRate;\n    uint256 public withdrawSettleFee;\n    uint256 public defaultUsdcQuota;\n\n    mapping(address => uint256) public earnUSDCBalance;\n    mapping(address => uint256) public jusdOutside;\n    mapping(address => uint256) public maxUsdcQuota;\n\n    WithdrawalRequest[] public withdrawalRequests;\n\n    // Event\n    event DepositToHedging(address from, uint256 USDCAmount, uint256 feeAmount, uint256 earnUSDCAmount);\n\n    event RequestWithdrawFromHedging(\n        address from, uint256 RepayJUSDAmount, uint256 withdrawEarnUSDCAmount, uint256 index\n    );\n\n    event PermitWithdraw(address from, uint256 USDCAmount, uint256 feeAmount, uint256 earnUSDCAmount, uint256 index);\n\n    event Swap(address fromToken, address toToken, uint256 payAmount, uint256 receivedAmount);\n\n    constructor(\n        address _collateral,\n        address _jusdBank,\n        address _jojoDealer,\n        address _perpMarket,\n        address _Operator\n    )\n        Ownable()\n    {\n        collateral = _collateral;\n        jusdBank = _jusdBank;\n        jojoDealer = _jojoDealer;\n        perpMarket = _perpMarket;\n        (address USDC, address JUSD,,,,,) = JOJODealer(jojoDealer).state();\n        usdc = USDC;\n        jusd = JUSD;\n        JOJODealer(jojoDealer).setOperator(_Operator, true);\n        IERC20(collateral).approve(jusdBank, type(uint256).max);\n        IERC20(jusd).approve(jusdBank, type(uint256).max);\n        IERC20(jusd).approve(jojoDealer, type(uint256).max);\n        IERC20(usdc).approve(jojoDealer, type(uint256).max);\n    }\n\n    // View\n\n    /// @notice this function is to return the sum of netValue in whole system.\n    /// including the netValue in collateral system, trading system and buffer usdc\n    function getNetValue() public view returns (uint256) {\n        uint256 jusdBorrowed = IJUSDBank(jusdBank).getBorrowBalance(address(this));\n        uint256 collateralAmount = IJUSDBank(jusdBank).getDepositBalance(collateral, address(this));\n        uint256 usdcBuffer = IERC20(usdc).balanceOf(address(this));\n        uint256 collateralPrice = IJUSDBank(jusdBank).getCollateralPrice(collateral);\n        (int256 perpNetValue,,,) = JOJODealer(jojoDealer).getTraderRisk(address(this));\n        return\n            SafeCast.toUint256(perpNetValue) + collateralAmount.decimalMul(collateralPrice) + usdcBuffer - jusdBorrowed;\n    }\n\n    /// @notice this function is to return the ratio between netValue and totalEarnUSDCBalance\n    function getIndex() public view returns (uint256) {\n        if (totalEarnUSDCBalance == 0) {\n            return 1e18;\n        } else {\n            return SignedDecimalMath.decimalDiv(getNetValue(), totalEarnUSDCBalance);\n        }\n    }\n\n    function buildSpotSwapData(\n        address approveTarget,\n        address swapTarget,\n        uint256 payAmount,\n        bytes memory callData\n    )\n        public\n        pure\n        returns (bytes memory spotTradeParam)\n    {\n        spotTradeParam = abi.encode(approveTarget, swapTarget, payAmount, callData);\n    }\n\n    //Only Owner\n\n    /// @notice this function is to set Operator who can operate this pool\n    function setOperator(address operator, bool isValid) public onlyOwner {\n        JOJODealer(jojoDealer).setOperator(operator, isValid);\n    }\n\n    function setMaxNetValue(uint256 newMaxNetValue) public onlyOwner {\n        maxNetValue = newMaxNetValue;\n    }\n\n    function setDepositFeeRate(uint256 newDepositFeeRate) public onlyOwner {\n        depositFeeRate = newDepositFeeRate;\n    }\n\n    function setWithdrawFeeRate(uint256 newWithdrawFeeRate) public onlyOwner {\n        withdrawFeeRate = newWithdrawFeeRate;\n    }\n\n    function setDefaultQuota(uint256 defaultQuota) public onlyOwner {\n        defaultUsdcQuota = defaultQuota;\n    }\n\n    /// @notice this function is to set the personal deposit quota\n    function setPersonalQuota(address to, uint256 personalQuota) public onlyOwner {\n        maxUsdcQuota[to] = personalQuota;\n    }\n\n    function setWithdrawSettleFee(uint256 newWithdrawSettleFee) public onlyOwner {\n        withdrawSettleFee = newWithdrawSettleFee;\n    }\n\n    function refundJUSD(uint256 amount) public onlyOwner {\n        IERC20(jusd).safeTransfer(msg.sender, amount);\n    }\n\n    /// @notice this function is to swap usdc to eth and deposit to collateral system\n    /// @param minReceivedCollateral is the minimum eth received\n    /// @param spotTradeParam is param to swap usdc to eth, can build by this function: `buildSpotSwapData`\n    function swapBuyEth(uint256 minReceivedCollateral, bytes memory spotTradeParam) public onlyOwner {\n        uint256 receivedCollateral = _swap(spotTradeParam, true);\n        require(receivedCollateral >= minReceivedCollateral, \"SWAP SLIPPAGE\");\n        _depositToJUSDBank(IERC20(collateral).balanceOf(address(this)));\n    }\n\n    /// @notice this function is to withdraw eth to the pool and swap eth to usdc\n    /// @param minReceivedUSDC is the minimum usdc received\n    /// @param collateralAmount is the expected eth amount which withdraw from collateral system\n    /// @param spotTradeParam is param to swap eth to usdc, can build by this function: `buildSpotSwapData`\n    function swapSellEth(\n        uint256 minReceivedUSDC,\n        uint256 collateralAmount,\n        bytes memory spotTradeParam\n    )\n        public\n        onlyOwner\n    {\n        _withdrawFromJUSDBank(collateralAmount);\n        uint256 receivedUSDC = _swap(spotTradeParam, false);\n        require(receivedUSDC >= minReceivedUSDC, \"SWAP SLIPPAGE\");\n    }\n\n    /// @notice this function is to borrow jusd from collateral system and deposit to trading system\n    /// @param JUSDAmount is the expected borrowed amount.\n    function borrow(uint256 JUSDAmount) public onlyOwner {\n        _borrowJUSD(JUSDAmount);\n    }\n\n    /// @notice this function is to withdraw jusd from trading system and repay to collateral system\n    /// @param JUSDRebalanceAmount is the expected repay amount.\n    function repay(uint256 JUSDRebalanceAmount) public onlyOwner {\n        JOJODealer(jojoDealer).fastWithdraw(address(this), address(this), 0, JUSDRebalanceAmount, false, \"\");\n        _repayJUSD(JUSDRebalanceAmount);\n    }\n\n    function _swap(bytes memory param, bool isBuyingEth) private returns (uint256 receivedAmount) {\n        address fromToken;\n        address toToken;\n        if (isBuyingEth) {\n            fromToken = usdc;\n            toToken = collateral;\n        } else {\n            fromToken = collateral;\n            toToken = usdc;\n        }\n        uint256 toTokenReserve = IERC20(toToken).balanceOf(address(this));\n        (address approveTarget, address swapTarget, uint256 payAmount, bytes memory callData) =\n            abi.decode(param, (address, address, uint256, bytes));\n        IERC20(fromToken).safeApprove(approveTarget, payAmount);\n        (bool isSuccess,) = swapTarget.call(callData);\n        if (!isSuccess) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n        receivedAmount = IERC20(toToken).balanceOf(address(this)) - toTokenReserve;\n        emit Swap(fromToken, toToken, payAmount, receivedAmount);\n    }\n\n    // JUSDBank Operations\n    function _borrowJUSD(uint256 JUSDAmount) internal {\n        IJUSDBank(jusdBank).borrow(JUSDAmount, address(this), true);\n    }\n\n    function _repayJUSD(uint256 amount) internal {\n        IJUSDBank(jusdBank).repay(amount, address(this));\n    }\n\n    function _withdrawFromJUSDBank(uint256 amount) internal {\n        IJUSDBank(jusdBank).withdraw(collateral, amount, address(this), false);\n    }\n\n    function _depositToJUSDBank(uint256 amount) internal {\n        IJUSDBank(jusdBank).deposit(address(this), collateral, amount, address(this));\n    }\n\n    // JOJODealer Operations\n\n    /// @notice this function is to deposit the buffered usdc from pool to trading system\n    /// @param primaryAmount is the expected deposit primary amount.\n    function depositUSDCToPerp(uint256 primaryAmount) public onlyOwner {\n        JOJODealer(jojoDealer).deposit(primaryAmount, 0, address(this));\n    }\n\n    /// @notice this function is to withdraw the buffered usdc from trading system to pool\n    /// @param primaryAmount is the expected withdraw primary amount.\n    function fastWithdrawUSDCFromPerp(uint256 primaryAmount) public onlyOwner {\n        JOJODealer(jojoDealer).fastWithdraw(address(this), address(this), primaryAmount, 0, false, \"\");\n    }\n\n    // LP Functions\n\n    /// @notice this function is called by liquidity providers, users can deposit usdc to arbitrage\n    /// @dev During the deposit, users usdc will transfer to the system and system will return\n    /// the equivalent amount of jusd which deposit to the trading system.\n    /// @param amount is the expected deposit usdc amount.\n    function deposit(uint256 amount) external {\n        require(amount != 0, \"deposit amount is zero\");\n        uint256 feeAmount = amount.decimalMul(depositFeeRate);\n        if (feeAmount > 0) {\n            amount -= feeAmount;\n            IERC20(usdc).transferFrom(msg.sender, owner(), feeAmount);\n        }\n        uint256 earnUSDCAmount = amount.decimalDiv(getIndex());\n        IERC20(usdc).transferFrom(msg.sender, address(this), amount);\n        JOJODealer(jojoDealer).deposit(0, amount, msg.sender);\n        earnUSDCBalance[msg.sender] += earnUSDCAmount;\n        jusdOutside[msg.sender] += amount;\n        totalEarnUSDCBalance += earnUSDCAmount;\n        require(getNetValue() <= maxNetValue, \"net value exceed limitation\");\n        uint256 quota = maxUsdcQuota[msg.sender] == 0 ? defaultUsdcQuota : maxUsdcQuota[msg.sender];\n        require(earnUSDCBalance[msg.sender].decimalMul(getIndex()) <= quota, \"usdc amount bigger than quota\");\n        emit DepositToHedging(msg.sender, amount, feeAmount, earnUSDCAmount);\n    }\n\n    /// @notice this function is to submit a withdrawal which wiil permit by our system in 24 hours\n    /// The main purpose of this function is to capture the interest and avoid the DOS attacks.\n    /// @dev users need to withdraw jusd from trading system firstly or by jusd, then transfer jusd to\n    /// the pool and get usdc back\n    /// @param repayJUSDAmount is the repat jusd amount\n    function requestWithdraw(uint256 repayJUSDAmount) external returns (uint256 withdrawEarnUSDCAmount) {\n        IERC20(jusd).safeTransferFrom(msg.sender, address(this), repayJUSDAmount);\n        require(repayJUSDAmount <= jusdOutside[msg.sender], \"Request Withdraw too big\");\n        jusdOutside[msg.sender] -= repayJUSDAmount;\n        uint256 index = getIndex();\n        uint256 lockedEarnUSDCAmount = jusdOutside[msg.sender].decimalDiv(index);\n        require(\n            earnUSDCBalance[msg.sender] >= lockedEarnUSDCAmount, \"lockedEarnUSDCAmount is bigger than earnUSDCBalance\"\n        );\n        withdrawEarnUSDCAmount = earnUSDCBalance[msg.sender] - lockedEarnUSDCAmount;\n        withdrawalRequests.push(WithdrawalRequest(withdrawEarnUSDCAmount, msg.sender, false));\n        require(\n            withdrawEarnUSDCAmount.decimalMul(index) >= withdrawSettleFee, \"Withdraw amount is smaller than settleFee\"\n        );\n        earnUSDCBalance[msg.sender] = lockedEarnUSDCAmount;\n        uint256 withdrawIndex = withdrawalRequests.length - 1;\n        emit RequestWithdrawFromHedging(msg.sender, repayJUSDAmount, withdrawEarnUSDCAmount, withdrawIndex);\n        return withdrawIndex;\n    }\n\n    /// @notice this function is to permit withdrawals which are submit by liqudity provider\n    /// @param requestIDList is the request ids\n    function permitWithdrawRequests(uint256[] memory requestIDList) external onlyOwner {\n        uint256 index = getIndex();\n        for (uint256 i; i < requestIDList.length; i++) {\n            WithdrawalRequest storage request = withdrawalRequests[requestIDList[i]];\n            require(!request.isExecuted, \"request has been executed\");\n            uint256 USDCAmount = request.earnUSDCAmount.decimalMul(index);\n            require(USDCAmount >= withdrawSettleFee, \"USDCAmount need to bigger than withdrawSettleFee\");\n            uint256 feeAmount = (USDCAmount - withdrawSettleFee).decimalMul(withdrawFeeRate) + withdrawSettleFee;\n            if (feeAmount > 0) {\n                IERC20(usdc).transfer(owner(), feeAmount);\n            }\n            IERC20(usdc).transfer(request.user, USDCAmount - feeAmount);\n            request.isExecuted = true;\n            totalEarnUSDCBalance -= request.earnUSDCAmount;\n            emit PermitWithdraw(request.user, USDCAmount, feeAmount, request.earnUSDCAmount, requestIDList[i]);\n        }\n    }\n}"
    },
    {
      "filename": "smart-contract-EVM/src/FundingRateArbitrage.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1\n*/\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./JOJODealer.sol\";\nimport \"./interfaces/IPerpetual.sol\";\nimport \"./interfaces/IJUSDBank.sol\";\nimport \"./libraries/SignedDecimalMath.sol\";\n\npragma solidity ^0.8.20;\n\n/// @notice This contract involves offsetting trades in both the spot and perpetual contract markets\n/// to capture the funding rate income in perpetual contract trading. Liquidy provider can deposit usdc\n/// to this pool and accumulate interest.\ncontract FundingRateArbitrage is Ownable {\n    struct WithdrawalRequest {\n        uint256 earnUSDCAmount;\n        address user;\n        bool isExecuted;\n    }\n\n    using SafeERC20 for IERC20;\n    using SignedDecimalMath for uint256;\n\n    address public immutable collateral;\n    address public immutable jusdBank;\n    address public immutable jojoDealer;\n    address public immutable perpMarket;\n    address public immutable usdc;\n    address public immutable jusd;\n\n    uint256 public maxNetValue;\n    uint256 public totalEarnUSDCBalance;\n    uint256 public depositFeeRate;\n    uint256 public withdrawFeeRate;\n    uint256 public withdrawSettleFee;\n    uint256 public defaultUsdcQuota;\n\n    mapping(address => uint256) public earnUSDCBalance;\n    mapping(address => uint256) public jusdOutside;\n    mapping(address => uint256) public maxUsdcQuota;\n\n    WithdrawalRequest[] public withdrawalRequests;\n\n    // Event\n    event DepositToHedging(address from, uint256 USDCAmount, uint256 feeAmount, uint256 earnUSDCAmount);\n\n    event RequestWithdrawFromHedging(\n        address from, uint256 RepayJUSDAmount, uint256 withdrawEarnUSDCAmount, uint256 index\n    );\n\n    event PermitWithdraw(address from, uint256 USDCAmount, uint256 feeAmount, uint256 earnUSDCAmount, uint256 index);\n\n    event Swap(address fromToken, address toToken, uint256 payAmount, uint256 receivedAmount);\n\n    constructor(\n        address _collateral,\n        address _jusdBank,\n        address _jojoDealer,\n        address _perpMarket,\n        address _Operator\n    )\n        Ownable()\n    {\n        collateral = _collateral;\n        jusdBank = _jusdBank;\n        jojoDealer = _jojoDealer;\n        perpMarket = _perpMarket;\n        (address USDC, address JUSD,,,,,) = JOJODealer(jojoDealer).state();\n        usdc = USDC;\n        jusd = JUSD;\n        JOJODealer(jojoDealer).setOperator(_Operator, true);\n        IERC20(collateral).approve(jusdBank, type(uint256).max);\n        IERC20(jusd).approve(jusdBank, type(uint256).max);\n        IERC20(jusd).approve(jojoDealer, type(uint256).max);\n        IERC20(usdc).approve(jojoDealer, type(uint256).max);\n    }\n\n    // View\n\n    /// @notice this function is to return the sum of netValue in whole system.\n    /// including the netValue in collateral system, trading system and buffer usdc\n    function getNetValue() public view returns (uint256) {\n        uint256 jusdBorrowed = IJUSDBank(jusdBank).getBorrowBalance(address(this));\n        uint256 collateralAmount = IJUSDBank(jusdBank).getDepositBalance(collateral, address(this));\n        uint256 usdcBuffer = IERC20(usdc).balanceOf(address(this));\n        uint256 collateralPrice = IJUSDBank(jusdBank).getCollateralPrice(collateral);\n        (int256 perpNetValue,,,) = JOJODealer(jojoDealer).getTraderRisk(address(this));\n        return\n            SafeCast.toUint256(perpNetValue) + collateralAmount.decimalMul(collateralPrice) + usdcBuffer - jusdBorrowed;\n    }\n\n    /// @notice this function is to return the ratio between netValue and totalEarnUSDCBalance\n    function getIndex() public view returns (uint256) {\n        if (totalEarnUSDCBalance == 0) {\n            return 1e18;\n        } else {\n            return SignedDecimalMath.decimalDiv(getNetValue(), totalEarnUSDCBalance);\n        }\n    }\n\n    function buildSpotSwapData(\n        address approveTarget,\n        address swapTarget,\n        uint256 payAmount,\n        bytes memory callData\n    )\n        public\n        pure\n        returns (bytes memory spotTradeParam)\n    {\n        spotTradeParam = abi.encode(approveTarget, swapTarget, payAmount, callData);\n    }\n\n    //Only Owner\n\n    /// @notice this function is to set Operator who can operate this pool\n    function setOperator(address operator, bool isValid) public onlyOwner {\n        JOJODealer(jojoDealer).setOperator(operator, isValid);\n    }\n\n    function setMaxNetValue(uint256 newMaxNetValue) public onlyOwner {\n        maxNetValue = newMaxNetValue;\n    }\n\n    function setDepositFeeRate(uint256 newDepositFeeRate) public onlyOwner {\n        depositFeeRate = newDepositFeeRate;\n    }\n\n    function setWithdrawFeeRate(uint256"
    }
  ]
}