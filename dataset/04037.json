{
  "Title": "[L07] Incorrect error message",
  "Content": "The [`Liquidatable` constructor](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/expiring-multiparty/Liquidatable.sol#L189) and the [`PerpetualLiquidatable` constructor](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/perpetual-multiparty/PerpetualLiquidatable.sol#L186) both revert if the collateral requirement is not greater than 100%, but the error message states “CR is more than 100%”. Consider updating these messages to describe the error condition instead of the success condition.\n\n\n**Update**: *Fixed in [PR#2304](https://github.com/UMAprotocol/protocol/pull/2304/files).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/financial-templates/expiring-multiparty/Liquidatable.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./PricelessPositionManager.sol\";\n\nimport \"../../common/implementation/FixedPoint.sol\";\n\n/**\n * @title Liquidatable\n * @notice Adds logic to a position-managing contract that enables callers to liquidate an undercollateralized position.\n * @dev The liquidation has a liveness period before expiring successfully, during which someone can \"dispute\" the\n * liquidation, which sends a price request to the relevant Oracle to settle the final collateralization ratio based on\n * a DVM price. The contract enforces dispute rewards in order to incentivize disputers to correctly dispute false\n * liquidations and compensate position sponsors who had their position incorrectly liquidated. Importantly, a\n * prospective disputer must deposit a dispute bond that they can lose in the case of an unsuccessful dispute.\n */\ncontract Liquidatable is PricelessPositionManager {\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /****************************************\n     *     LIQUIDATION DATA STRUCTURES      *\n     ****************************************/\n\n    // Because of the check in withdrawable(), the order of these enum values should not change.\n    enum Status { Uninitialized, PreDispute, PendingDispute, DisputeSucceeded, DisputeFailed }\n\n    struct LiquidationData {\n        // Following variables set upon creation of liquidation:\n        address sponsor; // Address of the liquidated position's sponsor\n        address liquidator; // Address who created this liquidation\n        Status state; // Liquidated (and expired or not), Pending a Dispute, or Dispute has resolved\n        uint256 liquidationTime; // Time when liquidation is initiated, needed to get price from Oracle\n        // Following variables determined by the position that is being liquidated:\n        FixedPoint.Unsigned tokensOutstanding; // Synthetic tokens required to be burned by liquidator to initiate dispute\n        FixedPoint.Unsigned lockedCollateral; // Collateral locked by contract and released upon expiry or post-dispute\n        // Amount of collateral being liquidated, which could be different from\n        // lockedCollateral if there were pending withdrawals at the time of liquidation\n        FixedPoint.Unsigned liquidatedCollateral;\n        // Unit value (starts at 1) that is used to track the fees per unit of collateral over the course of the liquidation.\n        FixedPoint.Unsigned rawUnitCollateral;\n        // Following variable set upon initiation of a dispute:\n        address disputer; // Person who is disputing a liquidation\n        // Following variable set upon a resolution of a dispute:\n        FixedPoint.Unsigned settlementPrice; // Final price as determined by an Oracle following a dispute\n        FixedPoint.Unsigned finalFee;\n    }\n\n    // Define the contract's constructor parameters as a struct to enable more variables to be specified.\n    // This is required to enable more params, over and above Solidity's limits.\n    struct ConstructorParams {\n        // Params for PricelessPositionManager only.\n        uint256 expirationTimestamp;\n        uint256 withdrawalLiveness;\n        address collateralAddress;\n        address tokenAddress;\n        address finderAddress;\n        address timerAddress;\n        address excessTokenBeneficiary;\n        address financialProductLibraryAddress;\n        bytes32 priceFeedIdentifier;\n        FixedPoint.Unsigned minSponsorTokens;\n        // Params specifically for Liquidatable.\n        uint256 liquidationLiveness;\n        FixedPoint.Unsigned collateralRequirement;\n        FixedPoint.Unsigned disputeBondPct;\n        FixedPoint.Unsigned sponsorDisputeRewardPct;\n        FixedPoint.Unsigned disputerDisputeRewardPct;\n    }\n\n    // This struct is used in the `withdrawLiquidation` method that disperses liquidation and dispute rewards.\n    // `payToX` stores the total collateral to withdraw from the contract to pay X. This value might differ\n    // from `paidToX` due to precision loss between accounting for the `rawCollateral` versus the\n    // fee-adjusted collateral. These variables are stored within a struct to avoid the stack too deep error.\n    struct RewardsData {\n        FixedPoint.Unsigned payToSponsor;\n        FixedPoint.Unsigned payToLiquidator;\n        FixedPoint.Unsigned payToDisputer;\n        FixedPoint.Unsigned paidToSponsor;\n        FixedPoint.Unsigned paidToLiquidator;\n        FixedPoint.Unsigned paidToDisputer;\n    }\n\n    // Liquidations are unique by ID per sponsor\n    mapping(address => LiquidationData[]) public liquidations;\n\n    // Total collateral in liquidation.\n    FixedPoint.Unsigned public rawLiquidationCollateral;\n\n    // Immutable contract parameters:\n    // Amount of time for pending liquidation before expiry.\n    // !!Note: The lower the liquidation liveness value, the more risk incurred by sponsors.\n    //       Extremely low liveness values increase the chance that opportunistic invalid liquidations\n    //       expire without dispute, thereby decreasing the usability for sponsors and increasing the risk\n    //       for the contract as a whole. An insolvent contract is extremely risky for any sponsor or synthetic\n    //       token holder for the contract.\n    uint256 public liquidationLiveness;\n    // Required collateral:TRV ratio for a position to be considered sufficiently collateralized.\n    FixedPoint.Unsigned public collateralRequirement;\n    // Percent of a Liquidation/Position's lockedCollateral to be deposited by a potential disputer\n    // Represented as a multiplier, for example 1.5e18 = \"150%\" and 0.05e18 = \"5%\"\n    FixedPoint.Unsigned public disputeBondPct;\n    // Percent of oraclePrice paid to sponsor in the Disputed state (i.e. following a successful dispute)\n    // Represented as a multiplier, see above.\n    FixedPoint.Unsigned public sponsorDisputeRewardPct;\n    // Percent of oraclePrice paid to disputer in the Disputed state (i.e. following a successful dispute)\n    // Represented as a multiplier, see above.\n    FixedPoint.Unsigned public disputerDisputeRewardPct;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event LiquidationCreated(\n        address indexed sponsor,\n        address indexed liquidator,\n        uint256 indexed liquidationId,\n        uint256 tokensOutstanding,\n        uint256 lockedCollateral,\n        uint256 liquidatedCollateral,\n        uint256 liquidationTime\n    );\n    event LiquidationDisputed(\n        address indexed sponsor,\n        address indexed liquidator,\n        address indexed disputer,\n        uint256 liquidationId,\n        uint256 disputeBondAmount\n    );\n    event DisputeSettled(\n        address indexed caller,\n        address indexed sponsor,\n        address indexed liquidator,\n        address disputer,\n        uint256 liquidationId,\n        bool disputeSucceeded\n    );\n    event LiquidationWithdrawn(\n        address indexed caller,\n        uint256 paidToLiquidator,\n        uint256 paidToDisputer,\n        uint256 paidToSponsor,\n        Status indexed liquidationStatus,\n        uint256 settlementPrice\n    );\n\n    /****************************************\n     *              MODIFIERS               *\n     ****************************************/\n\n    modifier disputable(uint256 liquidationId, address sponsor) {\n        _disputable(liquidationId, sponsor);\n        _;\n    }\n\n    modifier withdrawable(uint256 liquidationId, address sponsor) {\n        _withdrawable(liquidationId, sponsor);\n        _;\n    }\n\n    /**\n     * @notice Constructs the liquidatable contract.\n     * @param params struct to define input parameters for construction of Liquidatable. Some params\n     * are fed directly into the PricelessPositionManager's constructor within the inheritance tree.\n     */\n    constructor(ConstructorParams memory params)\n        public\n        PricelessPositionManager(\n            params.expirationTimestamp,\n            params.withdrawalLiveness,\n            params.collateralAddress,\n            params.tokenAddress,\n            params.finderAddress,\n            params.priceFeedIdentifier,\n            params.minSponsorTokens,\n            params.timerAddress,\n            params.excessTokenBeneficiary,\n            params.financialProductLibraryAddress\n        )\n        nonReentrant()\n    {\n        require(params.collateralRequirement.isGreaterThan(1), \"CR is more than 100%\");\n        require(\n            params.sponsorDisputeRewardPct.add(params.disputerDisputeRewardPct).isLessThan(1),\n            \"Rewards are more than 100%\"\n        );\n\n        // Set liquidatable specific variables.\n        liquidationLiveness = params.liquidationLiveness;\n        collateralRequirement = params.collateralRequirement;\n        disputeBondPct = params.disputeBondPct;\n        sponsorDisputeRewardPct = params.sponsorDisputeRewardPct;\n        disputerDisputeRewardPct = params.disputerDisputeRewardPct;\n    }\n\n    /****************************************\n     *        LIQUIDATION FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice Liquidates the sponsor's position if the caller has enough\n     * synthetic tokens to retire the position's outstanding tokens. Liquidations above\n     * a minimum size also reset an ongoing \"slow withdrawal\"'s liveness.\n     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be\n     * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`.\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\n     * @param sponsor address of the sponsor to liquidate.\n     * @param minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.\n     * @param maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.\n     * @param maxTokensToLiquidate max number of tokens to liquidate.\n     * @param deadline abort the liquidation if the transaction is mined after this timestamp.\n     * @return liquidationId ID of the newly created liquidation.\n     * @return tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.\n     * @return finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.\n     */\n    function createLiquidation(\n        address sponsor,\n        FixedPoint.Unsigned calldata minCollateralPerToken,\n        FixedPoint.Unsigned calldata maxCollateralPerToken,\n        FixedPoint.Unsigned calldata maxTokensToLiquidate,\n        uint256 deadline\n    )\n        external\n        fees()\n        onlyPreExpiration()\n        nonReentrant()\n        returns (\n            uint256 liquidationId,\n            FixedPoint.Unsigned memory tokensLiquidated,\n            FixedPoint.Unsigned memory finalFeeBond\n        )\n    {\n        // Check that this transaction was mined pre-deadline.\n        require(getCurrentTime() <= deadline, \"Mined after deadline\");\n\n        // Retrieve Position data for sponsor\n        PositionData storage positionToLiquidate = _getPositionData(sponsor);\n\n        tokensLiquidated = FixedPoint.min(maxTokensToLiquidate, positionToLiquidate.tokensOutstanding);\n        require(tokensLiquidated.isGreaterThan(0), \"Liquidating 0 tokens\");\n\n        // Starting values for the Position being liquidated. If withdrawal request amount is > position's collateral,\n        // then set this to 0, otherwise set it to (startCollateral - withdrawal request amount).\n        FixedPoint.Unsigned memory startCollateral = _getFeeAdjustedCollateral(positionToLiquidate.rawCollateral);\n        FixedPoint.Unsigned memory startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\n        if (positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(startCollateral)) {\n            startCollateralNetOfWithdrawal = startCollateral.sub(positionToLiquidate.withdrawalRequestAmount);\n        }\n\n        // Scoping to get rid of a stack too deep error.\n        {\n            FixedPoint.Unsigned memory startTokens = positionToLiquidate.tokensOutstanding;\n\n            // The Position's collateralization ratio must be between [minCollateralPerToken, maxCollateralPerToken].\n            // maxCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\n            require(\n                maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal),\n                \"CR is more than max liq. price\"\n            );\n            // minCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\n            require(\n                minCollateralPerToken.mul(startTokens).isLessThanOrEqual(startCollateralNetOfWithdrawal),\n                \"CR is less than min liq. price\"\n            );\n        }\n\n        // Compute final fee at time of liquidation.\n        finalFeeBond = _computeFinalFees();\n\n        // These will be populated within the scope below.\n        FixedPoint.Unsigned memory lockedCollateral;\n        FixedPoint.Unsigned memory liquidatedCollateral;\n\n        // Scoping to get rid of a stack too deep error.\n        {\n            FixedPoint.Unsigned memory ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding);\n\n            // The actual amount of collateral that gets moved to the liquidation.\n            lockedCollateral = startCollateral.mul(ratio);\n\n            // For purposes of disputes, it's actually this liquidatedCollateral value that's used. This value is net of\n            // withdrawal requests.\n            liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio);\n\n            // Part of the withdrawal request is also removed. Ideally:\n            // liquidatedCollateral + withdrawalAmountToRemove = lockedCollateral.\n            FixedPoint.Unsigned memory withdrawalAmountToRemove =\n                positionToLiquidate.withdrawalRequestAmount.mul(ratio);\n            _reduceSponsorPosition(sponsor, tokensLiquidated, lockedCollateral, withdrawalAmountToRemove);\n        }\n\n        // Add to the global liquidation collateral count.\n        _addCollateral(rawLiquidationCollateral, lockedCollateral.add(finalFeeBond));\n\n        // Construct liquidation object.\n        // Note: All dispute-related values are zeroed out until a dispute occurs. liquidationId is the index of the new\n        // LiquidationData that is pushed into the array, which is equal to the current length of the array pre-push.\n        liquidationId = liquidations[sponsor].length;\n        liquidations[sponsor].push(\n            LiquidationData({\n                sponsor: sponsor,\n                liquidator: msg.sender,\n                state: Status.PreDispute,\n                liquidationTime: getCurrentTime(),\n                tokensOutstanding: tokensLiquidated,\n                lockedCollateral: lockedCollateral,\n                liquidatedCollateral: liquidatedCollateral,\n                rawUnitCollateral: _convertToRawCollateral(FixedPoint.fromUnscaledUint(1)),\n                disputer: address(0),\n                settlementPrice: FixedPoint.fromUnscaledUint(0),\n                finalFee: finalFeeBond\n            })\n        );\n\n        // If this liquidation is a subsequent liquidation on the position, and the liquidation size is larger than\n        // some \"griefing threshold\", then re-set the liveness. This enables a liquidation against a withdraw request to be\n        // \"dragged out\" if the position is very large and liquidators need time to gather funds. The griefing threshold\n        // is enforced so that liquidations for trivially small # of tokens cannot drag out an honest sponsor's slow withdrawal.\n\n        // We arbitrarily set the \"griefing threshold\" to `minSponsorTokens` because it is the only parameter\n        // denominated in token currency units and we can avoid adding another parameter.\n        FixedPoint.Unsigned memory griefingThreshold = minSponsorTokens;\n        if (\n            positionToLiquidate.withdrawalRequestPassTimestamp > 0 && // The position is undergoing a slow withdrawal.\n            positionToLiquidate.withdrawalRequestPassTimestamp > getCurrentTime() && // The slow withdrawal has not yet expired.\n            tokensLiquidated.isGreaterThanOrEqual(griefingThreshold) // The liquidated token count is above a \"griefing threshold\".\n        ) {\n            positionToLiquidate.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\n        }\n\n        emit LiquidationCreated(\n            sponsor,\n            msg.sender,\n            liquidationId,\n            tokensLiquidated.rawValue,\n            lockedCollateral.rawValue,\n            liquidatedCollateral.rawValue,\n            getCurrentTime()\n        );\n\n        // Destroy tokens\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensLiquidated.rawValue);\n        tokenCurrency.burn(tokensLiquidated.rawValue);\n\n        // Pull final fee from liquidator.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), finalFeeBond.rawValue);\n    }\n\n    /**\n     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond\n     * and pay a fixed final fee charged on each price request.\n     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.\n     * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute\n     * bond amount is calculated from `disputeBondPct` times the collateral in the liquidation.\n     * @param liquidationId of the disputed liquidation.\n     * @param sponsor the address of the sponsor whose liquidation is being disputed.\n     * @return totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).\n     */\n    function dispute(uint256 liquidationId, address sponsor)\n        external\n        disputable(liquidationId, sponsor)\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory totalPaid)\n    {\n        LiquidationData storage disputedLiquidation = _getLiquidationData(sponsor, liquidationId);\n\n        // Multiply by the unit collateral so the dispute bond is a percentage of the locked collateral after fees.\n        FixedPoint.Unsigned memory disputeBondAmount =\n            disputedLiquidation.lockedCollateral.mul(disputeBondPct).mul(\n                _getFeeAdjustedCollateral(disputedLiquidation.rawUnitCollateral)\n            );\n        _addCollateral(rawLiquidationCollateral, disputeBondAmount);\n\n        // Request a price from DVM. Liquidation is pending dispute until DVM returns a price.\n        disputedLiquidation.state = Status.PendingDispute;\n        disputedLiquidation.disputer = msg.sender;\n\n        // Enqueue a request with the DVM.\n        _requestOraclePriceLiquidation(disputedLiquidation.liquidationTime);\n\n        emit LiquidationDisputed(\n            sponsor,\n            disputedLiquidation.liquidator,\n            msg.sender,\n            liquidationId,\n            disputeBondAmount.rawValue\n        );\n        totalPaid = disputeBondAmount.add(disputedLiquidation.finalFee);\n\n        // Pay the final fee for requesting price from the DVM.\n        _payFinalFees(msg.sender, disputedLiquidation.finalFee);\n\n        // Transfer the dispute bond amount from the caller to this contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), disputeBondAmount.rawValue);\n    }\n\n    /**\n     * @notice After a dispute has settled or after a non-disputed liquidation has expired,\n     * anyone can call this method to disperse payments to the sponsor, liquidator, and disdputer.\n     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment.\n     * If the dispute FAILED: only the liquidator can receive payment.\n     * This method will revert if rewards have already been dispersed.\n     * @param liquidationId uniquely identifies the sponsor's liquidation.\n     * @param sponsor address of the sponsor associated with the liquidation.\n     * @return data about rewards paid out.\n     */\n    function withdrawLiquidation(uint256 liquidationId, address sponsor)\n        public\n        withdrawable(liquidationId, sponsor)\n        fees()\n        nonReentrant()\n        returns (RewardsData memory)\n    {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n\n        // Settles the liquidation if necessary. This call will revert if the price has not resolved yet.\n        _settle(liquidationId, sponsor);\n\n        // Calculate rewards as a function of the TRV.\n        // Note: all payouts are scaled by the unit collateral value so all payouts are charged the fees pro rata.\n        FixedPoint.Unsigned memory feeAttenuation = _getFeeAdjustedCollateral(liquidation.rawUnitCollateral);\n        FixedPoint.Unsigned memory settlementPrice = liquidation.settlementPrice;\n        FixedPoint.Unsigned memory tokenRedemptionValue =\n            liquidation.tokensOutstanding.mul(settlementPrice).mul(feeAttenuation);\n        FixedPoint.Unsigned memory collateral = liquidation.lockedCollateral.mul(feeAttenuation);\n        FixedPoint.Unsigned memory disputerDisputeReward = disputerDisputeRewardPct.mul(tokenRedemptionValue);\n        FixedPoint.Unsigned memory sponsorDisputeReward = sponsorDisputeRewardPct.mul(tokenRedemptionValue);\n        FixedPoint.Unsigned memory disputeBondAmount = collateral.mul(disputeBondPct);\n        FixedPoint.Unsigned memory finalFee = liquidation.finalFee.mul(feeAttenuation);\n\n        // There are three main outcome states: either the dispute succeeded, failed or was not updated.\n        // Based on the state, different parties of a liquidation receive different amounts.\n        // After assigning rewards based on the liquidation status, decrease the total collateral held in this contract\n        // by the amount to pay each party. The actual amounts withdrawn might differ if _removeCollateral causes\n        // precision loss.\n        RewardsData memory rewards;\n        if (liquidation.state == Status.DisputeSucceeded) {\n            // If the dispute is successful then all three users should receive rewards:\n\n            // Pay DISPUTER: disputer reward + dispute bond + returned final fee\n            rewards.payToDisputer = disputerDisputeReward.add(disputeBondAmount).add(finalFee);\n\n            // Pay SPONSOR: remaining collateral (collateral - TRV) + sponsor reward\n            rewards.payToSponsor = sponsorDisputeReward.add(collateral.sub(tokenRedemptionValue));\n\n            // Pay LIQUIDATOR: TRV - dispute reward - sponsor reward\n            // If TRV > Collateral, then subtract rewards from collateral\n            // NOTE: This should never be below zero since we prevent (sponsorDisputePct+disputerDisputePct) >= 0 in\n            // the constructor when these params are set.\n            rewards.payToLiquidator = tokenRedemptionValue.sub(sponsorDisputeReward).sub(disputerDisputeReward);\n\n            // Transfer rewards and debit collateral\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n            rewards.paidToSponsor = _removeCollateral(rawLiquidationCollateral, rewards.payToSponsor);\n            rewards.paidToDisputer = _removeCollateral(rawLiquidationCollateral, rewards.payToDisputer);\n\n            collateralCurrency.safeTransfer(liquidation.disputer, rewards.paidToDisputer.rawValue);\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n            collateralCurrency.safeTransfer(liquidation.sponsor, rewards.paidToSponsor.rawValue);\n\n            // In the case of a failed dispute only the liquidator can withdraw.\n        } else if (liquidation.state == Status.DisputeFailed) {\n            // Pay LIQUIDATOR: collateral + dispute bond + returned final fee\n            rewards.payToLiquidator = collateral.add(disputeBondAmount).add(finalFee);\n\n            // Transfer rewards and debit collateral\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n\n            // If the state is pre-dispute but time has passed liveness then there was no dispute. We represent this\n            // state as a dispute failed and the liquidator can withdraw.\n        } else if (liquidation.state == Status.PreDispute) {\n            // Pay LIQUIDATOR: collateral + returned final fee\n            rewards.payToLiquidator = collateral.add(finalFee);\n\n            // Transfer rewards and debit collateral\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n        }\n\n        emit LiquidationWithdrawn(\n            msg.sender,\n            rewards.paidToLiquidator.rawValue,\n            rewards.paidToDisputer.rawValue,\n            rewards.paidToSponsor.rawValue,\n            liquidation.state,\n            settlementPrice.rawValue\n        );\n\n        // Free up space after collateral is withdrawn by removing the liquidation object from the array.\n        delete liquidations[sponsor][liquidationId];\n\n        return rewards;\n    }\n\n    /**\n     * @notice Gets all liquidation information for a given sponsor address.\n     * @param sponsor address of the position sponsor.\n     * @return liquidationData array of all liquidation information for the given sponsor address.\n     */\n    function getLiquidations(address sponsor)\n        external\n        view\n        nonReentrantView()\n        returns (LiquidationData[] memory liquidationData)\n    {\n        return liquidations[sponsor];\n    }\n\n    /**\n     * @notice Accessor method to calculate a transformed collateral requirement using the finanical product library\n      specified during contract deployment. If no library was provided then no modification to the collateral requirement is done.\n     * @param price input price used as an input to transform the collateral requirement.\n     * @return transformedCollateralRequirement collateral requirement with transformation applied to it.\n     * @dev This method should never revert.\n     */\n    function transformCollateralRequirement(FixedPoint.Unsigned memory price)\n        public\n        view\n        nonReentrantView()\n        returns (FixedPoint.Unsigned memory)\n    {\n        return _transformCollateralRequirement(price);\n    }\n\n    /****************************************\n     *          INTERNAL FUNCTIONS          *\n     ****************************************/\n\n    // This settles a liquidation if it is in the PendingDispute state. If not, it will immediately return.\n    // If the liquidation is in the PendingDispute state, but a price is not available, this will revert.\n    function _settle(uint256 liquidationId, address sponsor) internal {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n\n        // Settlement only happens when state == PendingDispute and will only happen once per liquidation.\n        // If this liquidation is not ready to be settled, this method should return immediately.\n        if (liquidation.state != Status.PendingDispute) {\n            return;\n        }\n\n        // Get the returned price from the oracle. If this has not yet resolved will revert.\n        liquidation.settlementPrice = _getOraclePriceLiquidation(liquidation.liquidationTime);\n\n        // Find the value of the tokens in the underlying collateral.\n        FixedPoint.Unsigned memory tokenRedemptionValue =\n            liquidation.tokensOutstanding.mul(liquidation.settlementPrice);\n\n        // The required collateral is the value of the tokens in underlying * required collateral ratio. The Transform\n        // Collateral requirement method applies a from the financial Product library to change the scaled the collateral\n        // requirement based on the settlement price. If no library was specified when deploying the emp then this makes no change.\n        FixedPoint.Unsigned memory requiredCollateral =\n            tokenRedemptionValue.mul(_transformCollateralRequirement(liquidation.settlementPrice));\n\n        // If the position has more than the required collateral it is solvent and the dispute is valid(liquidation is invalid)\n        // Note that this check uses the liquidatedCollateral not the lockedCollateral as this considers withdrawals.\n        bool disputeSucceeded = liquidation.liquidatedCollateral.isGreaterThanOrEqual(requiredCollateral);\n        liquidation.state = disputeSucceeded ? Status.DisputeSucceeded : Status.DisputeFailed;\n\n        emit DisputeSettled(\n            msg.sender,\n            sponsor,\n            liquidation.liquidator,\n            liquidation.disputer,\n            liquidationId,\n            disputeSucceeded\n        );\n    }\n\n    function _pfc() internal view override returns (FixedPoint.Unsigned memory) {\n        return super._pfc().add(_getFeeAdjustedCollateral(rawLiquidationCollateral));\n    }\n\n    function _getLiquidationData(address sponsor, uint256 liquidationId)\n        internal\n        view\n        returns (LiquidationData storage liquidation)\n    {\n        LiquidationData[] storage liquidationArray = liquidations[sponsor];\n\n        // Revert if the caller is attempting to access an invalid liquidation\n        // (one that has never been created or one has never been initialized).\n        require(\n            liquidationId < liquidationArray.length && liquidationArray[liquidationId].state != Status.Uninitialized,\n            \"Invalid liquidation ID\"\n        );\n        return liquidationArray[liquidationId];\n    }\n\n    function _getLiquidationExpiry(LiquidationData storage liquidation) internal view returns (uint256) {\n        return liquidation.liquidationTime.add(liquidationLiveness);\n    }\n\n    // These internal functions are supposed to act identically to modifiers, but re-used modifiers\n    // unnecessarily increase contract bytecode size.\n    // source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\n    function _disputable(uint256 liquidationId, address sponsor) internal view {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n        require(\n            (getCurrentTime() < _getLiquidationExpiry(liquidation)) && (liquidation.state == Status.PreDispute),\n            \"Liquidation not disputable\"\n        );\n    }\n\n    function _withdrawable(uint256 liquidationId, address sponsor) internal view {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n        Status state = liquidation.state;\n\n        // Must be disputed or the liquidation has passed expiry.\n        require(\n            (state > Status.PreDispute) ||\n                ((_getLiquidationExpiry(liquidation) <= getCurrentTime()) && (state == Status.PreDispute)),\n            \"Liquidation not withdrawable\"\n        );\n    }\n\n    function _transformCollateralRequirement(FixedPoint.Unsigned memory price)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory)\n    {\n        if (!address(financialProductLibrary).isContract()) return collateralRequirement;\n        try financialProductLibrary.transformCollateralRequirement(price, collateralRequirement) returns (\n            FixedPoint.Unsigned memory transformedCollateralRequirement\n        ) {\n            return transformedCollateralRequirement;\n        } catch {\n            return collateralRequirement;\n        }\n    }\n}"
    }
  ]
}