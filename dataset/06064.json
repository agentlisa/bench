{
  "Title": "[G-15] Using this to access functions results in an external call, wasting gas",
  "Content": "External calls have an overhead of 100 gas, which can be avoided by not referencing the function using this. Contracts are [allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from external to public, so make this change if it's required in order to call the function internally.\n\nHere are some of the instances entailed:\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/AppreciatingFiatCollateral.sol#L104\n\n```solidity\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192 pegPrice) {\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/Asset.sol\n\n```solidity\n89:        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n\n113:        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n\n129:        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n```\n\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/assets/AppreciatingFiatCollateral.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"./FiatCollateral.sol\";\nimport \"./Asset.sol\";\nimport \"./OracleLib.sol\";\n\n/**\n * @title AppreciatingFiatCollateral\n * Collateral that may need revenue hiding to become truly \"up only\"\n *\n * For: {tok} != {ref}, {ref} != {target}, {target} == {UoA}\n * Inheritors _must_ implement _underlyingRefPerTok()\n * Can be easily extended by (optionally) re-implementing:\n *   - tryPrice()\n *   - refPerTok()\n *   - targetPerRef()\n *   - claimRewards()\n * Should not have to re-implement any other methods.\n *\n * Can intentionally disable default checks by setting config.defaultThreshold to 0\n * Can intentionally do no revenue hiding by setting revenueHiding to 0\n */\nabstract contract AppreciatingFiatCollateral is FiatCollateral {\n    using FixLib for uint192;\n    using OracleLib for AggregatorV3Interface;\n\n    // revenueShowing = FIX_ONE.minus(revenueHiding)\n    uint192 public immutable revenueShowing; // {1} The maximum fraction of refPerTok to show\n\n    // does not become nonzero until after first refresh()\n    uint192 public exposedReferencePrice; // {ref/tok} max ref price observed, sub revenue hiding\n\n    /// @param config.chainlinkFeed Feed units: {UoA/ref}\n    /// @param revenueHiding {1} A value like 1e-6 that represents the maximum refPerTok to hide\n    constructor(CollateralConfig memory config, uint192 revenueHiding) FiatCollateral(config) {\n        require(revenueHiding < FIX_ONE, \"revenueHiding out of range\");\n        revenueShowing = FIX_ONE.minus(revenueHiding);\n    }\n\n    /// Can revert, used by other contract functions in order to catch errors\n    /// Should not return FIX_MAX for low\n    /// Should only return FIX_MAX for high if low is 0\n    /// @dev Override this when pricing is more complicated than just a single oracle\n    /// @return low {UoA/tok} The low price estimate\n    /// @return high {UoA/tok} The high price estimate\n    /// @return pegPrice {target/ref} The actual price observed in the peg\n    function tryPrice()\n        external\n        view\n        virtual\n        override\n        returns (\n            uint192 low,\n            uint192 high,\n            uint192 pegPrice\n        )\n    {\n        // {target/ref} = {UoA/ref} / {UoA/target} (1)\n        pegPrice = chainlinkFeed.price(oracleTimeout);\n\n        // {UoA/tok} = {target/ref} * {ref/tok} * {UoA/target} (1)\n        uint192 p = pegPrice.mul(_underlyingRefPerTok());\n        uint192 err = p.mul(oracleError, CEIL);\n\n        low = p - err;\n        high = p + err;\n        // assert(low <= high); obviously true just by inspection\n    }\n\n    /// Should not revert\n    /// Refresh exchange rates and update default status.\n    /// @dev Should not need to override: can handle collateral with variable refPerTok()\n    function refresh() public virtual override {\n        if (alreadyDefaulted()) {\n            // continue to update rates\n            exposedReferencePrice = _underlyingRefPerTok().mul(revenueShowing);\n            return;\n        }\n\n        CollateralStatus oldStatus = status();\n\n        // Check for hard default\n        // must happen before tryPrice() call since `refPerTok()` returns a stored value\n\n        // revenue hiding: do not DISABLE if drawdown is small\n        uint192 underlyingRefPerTok = _underlyingRefPerTok();\n\n        // {ref/tok} = {ref/tok} * {1}\n        uint192 hiddenReferencePrice = underlyingRefPerTok.mul(revenueShowing);\n\n        // uint192(<) is equivalent to Fix.lt\n        if (underlyingRefPerTok < exposedReferencePrice) {\n            exposedReferencePrice = hiddenReferencePrice;\n            markStatus(CollateralStatus.DISABLED);\n        } else if (hiddenReferencePrice > exposedReferencePrice) {\n            exposedReferencePrice = hiddenReferencePrice;\n        }\n\n        // Check for soft default + save prices\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192 pegPrice) {\n            // {UoA/tok}, {UoA/tok}, {target/ref}\n            // (0, 0) is a valid price; (0, FIX_MAX) is unpriced\n\n            // Save prices if priced\n            if (high < FIX_MAX) {\n                savedLowPrice = low;\n                savedHighPrice = high;\n                lastSave = uint48(block.timestamp);\n            } else {\n                // must be unpriced\n                assert(low == 0);\n            }\n\n            // If the price is below the default-threshold price, default eventually\n            // uint192(+/-) is the same as Fix.plus/minus\n            if (pegPrice < pegBottom || pegPrice > pegTop || low == 0) {\n                markStatus(CollateralStatus.IFFY);\n            } else {\n                markStatus(CollateralStatus.SOUND);\n            }\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            markStatus(CollateralStatus.IFFY);\n        }\n\n        CollateralStatus newStatus = status();\n        if (oldStatus != newStatus) {\n            emit CollateralStatusChanged(oldStatus, newStatus);\n        }\n    }\n\n    /// @return {ref/tok} Exposed quantity of whole reference units per whole collateral tokens\n    function refPerTok() public view virtual override returns (uint192) {\n        return exposedReferencePrice;\n    }\n\n    /// Should update in inheritors\n    /// @return {ref/tok} Actual quantity of whole reference units per whole collateral tokens\n    function _underlyingRefPerTok() internal view virtual returns (uint192);\n}"
    }
  ]
}