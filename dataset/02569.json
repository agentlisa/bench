{
  "Title": "H-2: Rounding differences when computing the invariant",
  "Content": "# Issue H-2: Rounding differences when computing the invariant \n\nSource: https://github.com/sherlock-audit/2022-12-notional-judging/issues/17 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe invariant used within Boosted3Token vault to compute the spot price is not aligned with the Balancer's ComposableBoostedPool due to rounding differences. The spot price is used to verify if the pool has been manipulated before executing certain key vault actions (e.g. settle vault, reinvest rewards). In the worst-case scenario, it might potentially fail to detect the pool has been manipulated as the spot price computed might be inaccurate.\n\n## Vulnerability Detail\n\nThe Boosted3Token leverage vault relies on the old version of the `StableMath._calculateInvariant` that allows the caller to specify if the computation should round up or down via the `roundUp` parameter.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/StableMath.sol#L28\n\n```solidity\nFile: StableMath.sol\n28:     function _calculateInvariant(\n29:         uint256 amplificationParameter,\n30:         uint256[] memory balances,\n31:         bool roundUp\n32:     ) internal pure returns (uint256) {\n33:         /**********************************************************************************************\n34:         // invariant                                                                                 //\n35:         // D = invariant                                                  D^(n+1)                    //\n36:         // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n37:         // S = sum of balances                                             n^n P                     //\n38:         // P = product of balances                                                                   //\n39:         // n = number of tokens                                                                      //\n40:         *********x************************************************************************************/\n41: \n42:         unchecked {\n43:             // We support rounding up or down.\n44:             uint256 sum = 0;\n45:             uint256 numTokens = balances.length;\n46:             for (uint256 i = 0; i < numTokens; i++) {\n47:                 sum = sum.add(balances[i]);\n48:             }\n49:             if (sum == 0) {\n50:                 return 0;\n51:             }\n52: \n53:             uint256 prevInvariant = 0;\n54:             uint256 invariant = sum;\n55:             uint256 ampTimesTotal = amplificationParameter * numTokens;\n56: \n57:             for (uint256 i = 0; i < 255; i++) {\n58:                 uint256 P_D = balances[0] * numTokens;\n59:                 for (uint256 j = 1; j < numTokens; j++) {\n60:                     P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n61:                 }\n62:                 prevInvariant = invariant;\n63:                 invariant = Math.div(\n64:                     Math.mul(Math.mul(numTokens, invariant), invariant).add(\n65:                         Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n66:                     ),\n67:                     Math.mul(numTokens + 1, invariant).add(\n68:                         // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n69:                         Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\n70:                     ),\n71:                     roundUp\n72:                 );\n73: \n74:                 if (invariant > prevInvariant) {\n75:                     if (invariant - prevInvariant <= 1) {\n76:                         return invariant;\n77:                     }\n78:                 } else if (prevInvariant - invariant <= 1) {\n79:                     return invariant;\n80:                 }\n81:             }\n82:         }\n83: \n84:         revert CalculationDidNotConverge();\n85:     }\n```\n\nWithin the `Boosted3TokenPoolUtils._getSpotPrice` and `Boosted3TokenPoolUtils._getValidatedPoolData` functions, the `StableMath._calculateInvariant` is computed rounding up.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L15\n\n```solidity\nFile: Boosted3TokenPoolUtils.sol\n76:     function _getSpotPrice(\n77:         ThreeTokenPoolContext memory poolContext, \n78:         BoostedOracleContext memory oracleContext,\n79:         uint8 tokenIndex\n80:     ) internal pure returns (uint256 spotPrice) {\n..SNIP..\n88:         uint256[] memory balances = _getScaledBalances(poolContext);\n89:         uint256 invariant = StableMath._calculateInvariant(\n90:             oracleContext.ampParam, balances, true // roundUp = true\n91:         );\n```\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L284\n\n```solidity\nFile: Boosted3TokenPoolUtils.sol\n284:     function _getValidatedPoolData(\n285:         ThreeTokenPoolContext memory poolContext,\n286:         BoostedOracleContext memory oracleContext,\n287:         StrategyContext memory strategyContext\n288:     ) internal view returns (uint256 virtualSupply, uint256[] memory balances, uint256 invariant) {\n289:         (virtualSupply, balances) =\n290:             _getVirtualSupplyAndBalances(poolContext, oracleContext);\n291: \n292:         // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n293:         invariant = StableMath._calculateInvariant(\n294:             oracleContext.ampParam, balances, true // roundUp = true\n295:         );\n```\n\nHowever, Balancer has since migrated its Boosted3Token pool from the legacy BoostedPool structure to a new ComposableBoostedPool contract.\n\nThe new ComposableBoostedPool contract uses a newer version of the StableMath library where the `StableMath._calculateInvariant` function always rounds down.\n\nhttps://etherscan.io/address/0xa13a9247ea42d743238089903570127dda72fe44#code#F16#L57\n\n```solidity\n    function _calculateInvariant(uint256 amplificationParameter, uint256[] memory balances)\n        internal\n        pure\n        returns (uint256)\n    {\n        /**********************************************************************************************\n        // invariant                                                                                 //\n        // D = invariant                                                  D^(n+1)                    //\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n        // S = sum of balances                                             n^n P                     //\n        // P = product of balances                                                                   //\n        // n = number of tokens                                                                      //\n        **********************************************************************************************/\n\n        // Always round down, to match Vyper's arithmetic (which always truncates).\n\n        uint256 sum = 0; // S in the Curve version\n        uint256 numTokens = balances.length;\n        for (uint256 i = 0; i < numTokens; i++) {\n            sum = sum.add(balances[i]);\n        }\n        if (sum == 0) {\n            return 0;\n        }\n        ..SNIP..\n```\n\nThus, Notional round up when calculating the invariant while Balancer's ComposableBoostedPool round down when calculating the invariant. This inconsistency will result in a different invariant\n\n## Impact\n\nThe invariant is used to compute the spot price to verify if the pool has been manipulated before executing certain key vault actions (e.g. settle vault, reinvest rewards). If the inputted invariant is inaccurate, the spot price computed might not be accurate and might not match the actual spot price of the Balancer Pool. In the worst-case scenario, it might potentially fail to detect the pool has been manipulated and the trade proceeds to execute against the manipulated pool leading to a loss of assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/StableMath.sol#L28\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L15\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L284\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo avoid any discrepancy in the result, ensure that the StableMath library used by Balancer's ComposableBoostedPool and Notional's Boosted3Token leverage vault are aligned, and the implementation of the StableMath functions is the same between them.\n\n## Discussion\n\n**weitianjie2000**\n\nvalid, will fix\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/31",
  "Code": [
    {
      "filename": "contracts/vaults/balancer/internal/math/StableMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Math} from \"./Math.sol\";\nimport {FixedPoint} from \"./FixedPoint.sol\";\n\nlibrary StableMath {\n    using FixedPoint for uint256;\n    \n    uint256 internal constant _AMP_PRECISION = 1e3;\n\n    error CalculationDidNotConverge();\n\n    // Note on unchecked arithmetic:\n    // This contract performs a large number of additions, subtractions, multiplications and divisions, often inside\n    // loops. Since many of these operations are gas-sensitive (as they happen e.g. during a swap), it is important to\n    // not make any unnecessary checks. We rely on a set of invariants to avoid having to use checked arithmetic (the\n    // Math library), including:\n    //  - the number of tokens is bounded by _MAX_STABLE_TOKENS\n    //  - the amplification parameter is bounded by _MAX_AMP * _AMP_PRECISION, which fits in 23 bits\n    //  - the token balances are bounded by 2^112 (guaranteed by the Vault) times 1e18 (the maximum scaling factor),\n    //    which fits in 172 bits\n    //\n    // This means e.g. we can safely multiply a balance by the amplification parameter without worrying about overflow.\n\n    // Computes the invariant given the current balances, using the Newton-Raphson approximation.\n    // The amplification parameter equals: A n^(n-1)\n    function _calculateInvariant(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        /**********************************************************************************************\n        // invariant                                                                                 //\n        // D = invariant                                                  D^(n+1)                    //\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n        // S = sum of balances                                             n^n P                     //\n        // P = product of balances                                                                   //\n        // n = number of tokens                                                                      //\n        *********x************************************************************************************/\n\n        unchecked {\n            // We support rounding up or down.\n            uint256 sum = 0;\n            uint256 numTokens = balances.length;\n            for (uint256 i = 0; i < numTokens; i++) {\n                sum = sum.add(balances[i]);\n            }\n            if (sum == 0) {\n                return 0;\n            }\n\n            uint256 prevInvariant = 0;\n            uint256 invariant = sum;\n            uint256 ampTimesTotal = amplificationParameter * numTokens;\n\n            for (uint256 i = 0; i < 255; i++) {\n                uint256 P_D = balances[0] * numTokens;\n                for (uint256 j = 1; j < numTokens; j++) {\n                    P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n                }\n                prevInvariant = invariant;\n                invariant = Math.div(\n                    Math.mul(Math.mul(numTokens, invariant), invariant).add(\n                        Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n                    ),\n                    Math.mul(numTokens + 1, invariant).add(\n                        // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n                        Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\n                    ),\n                    roundUp\n                );\n\n                if (invariant > prevInvariant) {\n                    if (invariant - prevInvariant <= 1) {\n                        return invariant;\n                    }\n                } else if (prevInvariant - invariant <= 1) {\n                    return invariant;\n                }\n            }\n        }\n\n        revert CalculationDidNotConverge();\n    }\n\n    /**\n     * @dev Calculates the spot price of token Y in token X.\n     */\n    function _calcSpotPrice(\n        uint256 amplificationParameter,\n        uint256 invariant, \n        uint256 balanceX,\n        uint256 balanceY\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        //                                                                                                           //\n        //                             2.a.x.y + a.y^2 + b.y                                                         //\n        // spot price Y/X = - dx/dy = -----------------------                                                        //\n        //                             2.a.x.y + a.x^2 + b.x                                                         //\n        //                                                                                                           //\n        // n = 2                                                                                                     //\n        // a = amp param * n                                                                                         //\n        // b = D + a.(S - D)                                                                                         //\n        // D = invariant                                                                                             //\n        // S = sum of balances but x,y = 0 since x  and y are the only tokens                                        //\n        **************************************************************************************************************/\n\n        unchecked {\n            uint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n            uint256 b = Math.mul(invariant, a).sub(invariant);\n\n            uint256 axy2 = Math.mul(a * 2, balanceX).mulDown(balanceY); // n = 2\n\n            // dx = a.x.y.2 + a.y^2 - b.y\n            uint256 derivativeX = axy2.add(Math.mul(a, balanceY).mulDown(balanceY)).sub(b.mulDown(balanceY));\n\n            // dy = a.x.y.2 + a.x^2 - b.x\n            uint256 derivativeY = axy2.add(Math.mul(a, balanceX).mulDown(balanceX)).sub(b.mulDown(balanceX));\n\n            // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n            // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\n            // result of zero is therefore only possible with zero balances, which are prevented via other means.\n            return derivativeX.divUp(derivativeY);\n        }\n    }\n\n    function _balances(uint256 balanceX, uint256 balanceY) internal pure returns (uint256[] memory balances) {\n        balances = new uint256[](2);\n        balances[0] = balanceX;\n        balances[1] = balanceY;\n    }\n\n    // This function calculates the balance of a given token (tokenIndex)\n    // given all the other balances and the invariant\n    function _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint256 tokenIndex\n    ) internal pure returns (uint256) {\n        // Rounds result up overall\n        unchecked {\n            uint256 ampTimesTotal = amplificationParameter * balances.length;\n            uint256 sum = balances[0];\n            uint256 P_D = balances[0] * balances.length;\n            for (uint256 j = 1; j < balances.length; j++) {\n                P_D = Math.divDown(Math.mul(Math.mul(P_D, balances[j]), balances.length), invariant);\n                sum = sum.add(balances[j]);\n            }\n            // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\n            sum = sum - balances[tokenIndex];\n\n            uint256 inv2 = Math.mul(invariant, invariant);\n            // We remove the balance fromm c by multiplying it\n            uint256 c = Math.mul(\n                Math.mul(Math.divUp(inv2, Math.mul(ampTimesTotal, P_D)), _AMP_PRECISION),\n                balances[tokenIndex]\n            );\n            uint256 b = sum.add(Math.mul(Math.divDown(invariant, ampTimesTotal), _AMP_PRECISION));\n\n            // We iterate to find the balance\n            uint256 prevTokenBalance = 0;\n            // We multiply the first iteration outside the loop with the invariant to set the value of the\n            // initial approximation.\n            uint256 tokenBalance = Math.divUp(inv2.add(c), invariant.add(b));\n\n            for (uint256 i = 0; i < 255; i++) {\n                prevTokenBalance = tokenBalance;\n\n                tokenBalance = Math.divUp(\n                    Math.mul(tokenBalance, tokenBalance).add(c),\n                    Math.mul(tokenBalance, 2).add(b).sub(invariant)\n                );\n\n                if (tokenBalance > prevTokenBalance) {\n                    if (tokenBalance - prevTokenBalance <= 1) {\n                        return tokenBalance;\n                    }\n                } else if (prevTokenBalance - tokenBalance <= 1) {\n                    return tokenBalance;\n                }\n            }\n        }\n\n        revert CalculationDidNotConverge();\n    }\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256 tokenIndex,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage,\n        uint256 currentInvariant\n    ) internal pure returns (uint256) {\n        // Token out, so we round down overall.\n\n        unchecked {\n            uint256 newInvariant = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply).mulUp(currentInvariant);\n\n            // Calculate amount out without fee\n            uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amp,\n                balances,\n                newInvariant,\n                tokenIndex\n            );\n            uint256 amountOutWithoutFee = balances[tokenIndex].sub(newBalanceTokenIndex);\n\n            // First calculate the sum of all token balances, which will be used to calculate\n            // the current weight of each token\n            uint256 sumBalances = 0;\n            for (uint256 i = 0; i < balances.length; i++) {\n                sumBalances = sumBalances.add(balances[i]);\n            }\n\n            // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n            // in swap fees.\n            uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\n            uint256 taxablePercentage = currentWeight.complement();\n\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n            // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n            uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\n            uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n            // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n            return nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\n        }\n    }\n\n    // Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the current balances.\n    // The amplification parameter equals: A n^(n-1)\n    function _calcOutGivenIn(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint256 tokenAmountIn,\n        uint256 invariant\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // outGivenIn token x for y - polynomial equation to solve                                                   //\n        // ay = amount out to calculate                                                                              //\n        // by = balance token out                                                                                    //\n        // y = by - ay (finalBalanceOut)                                                                             //\n        // D = invariant                                               D                     D^(n+1)                 //\n        // A = amplification coefficient               y^2 + ( S - ----------  - D) * y -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but y                                                                           //\n        // P = product of final balances but y                                                                       //\n        **************************************************************************************************************/\n\n        // Amount out, so we round down overall.\n        unchecked {\n            balances[tokenIndexIn] = balances[tokenIndexIn].add(tokenAmountIn);\n\n            uint256 finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amplificationParameter,\n                balances,\n                invariant,\n                tokenIndexOut\n            );\n\n            // No need to use checked arithmetic since `tokenAmountIn` was actually added to the same balance right before\n            // calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n            balances[tokenIndexIn] = balances[tokenIndexIn] - tokenAmountIn;\n\n            return balances[tokenIndexOut].sub(finalBalanceOut).sub(1);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 primaryBalance,\n        uint256 secondaryBalance,\n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        /// Apply scale factors\n        uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n\n        /// @notice poolContext balances are always in BALANCER_PRECISION (1e18)\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (scaledPrimaryBalance, scaledSecondaryBalance) :\n            (scaledSecondaryBalance, scaledPrimaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n\n        /// Apply secondary scale factor in reverse\n        uint256 scaleFactor = tokenIndex == 0 ?\n            poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor :\n            poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n    }\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal view {\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 oraclePrice,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: primaryAmount,\n            secondaryBalance: secondaryAmount,\n            tokenIndex: 0\n        });\n\n        /// @notice Check the calculated primary/secondary price against the oracle price\n        /// to make sure that we are joining the pool proportionally\n        _checkPriceLimit(strategyContext, oraclePrice, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    ThreeTokenPoolContext,\n    TwoTokenPoolContext,\n    BoostedOracleContext,\n    UnderlyingPoolContext,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../pool/Boosted3TokenPoolUtils.sol\";\nimport {StableMath} from \"../math/StableMath.sol\";\nimport {LinearMath} from \"../math/LinearMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {ILinearPool} from \"../../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./TwoTokenPoolUtils.sol\";\nimport {FixedPoint} from \"../math/FixedPoint.sol\";\n\nlibrary Boosted3TokenPoolUtils {\n    using TypeConvert for uint256;\n    using FixedPoint for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    // Preminted BPT is sometimes called Phantom BPT, as the preminted BPT (which is deposited in the Vault as balance of\n    // the Pool) doesn't belong to any entity until transferred out of the Pool. The Pool's arithmetic behaves as if it\n    // didn't exist, and the BPT total supply is not a useful value: we rely on the 'virtual supply' (how much BPT is\n    // actually owned by some entity) instead.\n    uint256 private constant _MAX_TOKEN_BALANCE = 2**(112) - 1;\n\n    function _getScaleFactor(\n        ThreeTokenPoolContext memory poolContext,\n        uint8 tokenIndex\n    ) private pure returns(uint256 scaleFactor) {\n        if (tokenIndex == 0) {\n            scaleFactor = poolContext.basePool.primaryScaleFactor;\n        } else if (tokenIndex == 1) {\n            scaleFactor = poolContext.basePool.secondaryScaleFactor;\n        } else if (tokenIndex == 2) {\n            scaleFactor = poolContext.tertiaryScaleFactor;\n        }\n    }\n\n    function _getPrecision(\n        ThreeTokenPoolContext memory poolContext,\n        uint8 tokenIndex\n    ) private pure returns(uint256 precision) {\n        if (tokenIndex == 0) {\n            precision = 10**poolContext.basePool.primaryDecimals;\n        } else if (tokenIndex == 1) {\n            precision = 10**poolContext.basePool.secondaryDecimals;\n        } else if (tokenIndex == 2) {\n            precision = 10**poolContext.tertiaryDecimals;\n        }\n    }\n\n    /// @notice Spot price is always expressed in terms of the primary currency\n    function _getSpotPrice(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        uint8 tokenIndex\n    ) internal pure returns (uint256 spotPrice) {\n        require(tokenIndex < 3);  /// @dev invalid token index\n\n        // Exchange rate of primary currency = 1\n        if (tokenIndex == 0) {\n            return BalancerConstants.BALANCER_PRECISION;\n        }\n\n        uint256[] memory balances = _getScaledBalances(poolContext);\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n        spotPrice = _getSpotPriceWithInvariant({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            balances: balances, \n            invariant: invariant,\n            tokenIndex: tokenIndex\n        });\n    }\n\n    function _getUnderlyingBPTOut(\n        UnderlyingPoolContext memory pool,\n        uint256 mainIn\n    ) private pure returns (uint256) {\n        uint256 scaledMainBalance = pool.mainBalance * pool.mainScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledWrappedBalance = pool.wrappedBalance * pool.wrappedScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n\n        // Convert from linear pool BPT to primary Amount\n        return LinearMath._calcBptOutPerMainIn({\n            mainIn: mainIn,\n            mainBalance: scaledMainBalance,\n            wrappedBalance: scaledWrappedBalance,\n            bptSupply: pool.virtualSupply,\n            params: LinearMath.Params({\n                fee: pool.fee,\n                lowerTarget: pool.lowerTarget,\n                upperTarget: pool.upperTarget\n            }) \n        });\n    }\n\n    function _getUnderlyingMainOut(\n        UnderlyingPoolContext memory pool,\n        uint256 bptIn\n    ) private pure returns (uint256) {\n        uint256 scaledMainBalance = pool.mainBalance * pool.mainScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledWrappedBalance = pool.wrappedBalance * pool.wrappedScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n\n        // Convert from linear pool BPT to primary Amount\n        return LinearMath._calcMainOutPerBptIn({\n            bptIn: bptIn,\n            mainBalance: scaledMainBalance,\n            wrappedBalance: scaledWrappedBalance,\n            bptSupply: pool.virtualSupply,\n            params: LinearMath.Params({\n                fee: pool.fee,\n                lowerTarget: pool.lowerTarget,\n                upperTarget: pool.upperTarget\n            }) \n        });\n    }\n\n    /// @notice Spot price is always expressed in terms of the primary currency\n    function _getSpotPriceWithInvariant(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint8 tokenIndex\n    ) private pure returns (uint256 spotPrice) {\n        // Trade 1 unit of tokenIn for tokenOut to get the spot price\n        // AmountIn needs to be in underlying precision because mainScaleFactor\n        // will convert it to 1e18\n        uint256 amountIn = _getPrecision(poolContext, tokenIndex);\n\n        UnderlyingPoolContext memory inPool = oracleContext.underlyingPools[tokenIndex];\n        amountIn = amountIn * inPool.mainScaleFactor / BalancerConstants.BALANCER_PRECISION;\n        uint256 linearBPTIn = _getUnderlyingBPTOut(inPool, amountIn);\n\n        linearBPTIn = linearBPTIn * _getScaleFactor(poolContext, tokenIndex) / BalancerConstants.BALANCER_PRECISION;\n\n        uint256 linearBPTOut = StableMath._calcOutGivenIn({\n            amplificationParameter: oracleContext.ampParam,\n            balances: balances,\n            tokenIndexIn: tokenIndex,\n            tokenIndexOut: 0, // Primary index\n            tokenAmountIn: linearBPTIn,\n            invariant: invariant\n        });\n\n        linearBPTOut = linearBPTOut * BalancerConstants.BALANCER_PRECISION / _getScaleFactor(poolContext, 0);\n\n        UnderlyingPoolContext memory outPool = oracleContext.underlyingPools[0];\n        spotPrice = _getUnderlyingMainOut(outPool, linearBPTOut);\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / outPool.mainScaleFactor;\n\n        // Convert precision back to 1e18 after downscaling by mainScaleFactor\n        // primary currency = index 0\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / _getPrecision(poolContext, 0);\n    }\n\n    function _validateSpotPrice(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory context,\n        address tokenIn,\n        address tokenOut,\n        uint8 tokenIndex,\n        uint256[] memory balances,\n        uint256 invariant\n    ) private view {\n        (int256 answer, int256 decimals) = context.tradingModule.getOraclePrice(tokenOut, tokenIn);\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n        \n        uint256 spotPrice = _getSpotPriceWithInvariant({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            balances: balances, \n            invariant: invariant,\n            tokenIndex: tokenIndex\n        });\n\n        uint256 oraclePrice = answer.toUint();\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        // Check spot price against oracle price to make sure it hasn't been manipulated\n        if (spotPrice < lowerLimit || upperLimit < spotPrice) {\n            revert Errors.InvalidPrice(oraclePrice, spotPrice);\n        }\n    }\n\n    function _validateTokenPrices(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256[] memory balances,\n        uint256 invariant\n    ) private view {\n        address primaryUnderlying = ILinearPool(address(poolContext.basePool.primaryToken)).getMainToken();\n        address secondaryUnderlying = ILinearPool(address(poolContext.basePool.secondaryToken)).getMainToken();\n        address tertiaryUnderlying = ILinearPool(address(poolContext.tertiaryToken)).getMainToken();\n\n        _validateSpotPrice({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenOut: secondaryUnderlying,\n            tokenIndex: 1, // secondary index\n            balances: balances,\n            invariant: invariant\n        });\n\n        _validateSpotPrice({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenOut: tertiaryUnderlying,\n            tokenIndex: 2, // tertiary index\n            balances: balances,\n            invariant: invariant\n        });\n    }\n\n    function _getVirtualSupply(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) internal view returns (uint256 virtualSupply) {\n        // The initial amount of BPT pre-minted is _PREMINTED_TOKEN_BALANCE, and it goes entirely to the pool balance in\n        // the vault. So the virtualSupply (the amount of BPT supply in circulation) is defined as:\n        // virtualSupply = totalSupply() - _balances[_bptIndex]\n        virtualSupply = poolContext.basePool.basePool.pool.totalSupply() - oracleContext.bptBalance;\n    }\n\n    function _getScaledBalances(ThreeTokenPoolContext memory poolContext) \n        private pure returns (uint256[] memory amountsWithoutBpt) {\n        amountsWithoutBpt = new uint256[](3);\n        amountsWithoutBpt[0] = poolContext.basePool.primaryBalance * poolContext.basePool.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        amountsWithoutBpt[1] = poolContext.basePool.secondaryBalance * poolContext.basePool.secondaryScaleFactor\n            / BalancerConstants.BALANCER_PRECISION;\n        amountsWithoutBpt[2] = poolContext.tertiaryBalance * poolContext.tertiaryScaleFactor\n            / BalancerConstants.BALANCER_PRECISION;        \n    }\n\n    function _getVirtualSupplyAndBalances(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) private view returns (uint256 virtualSupply, uint256[] memory amountsWithoutBpt) {\n        virtualSupply = _getVirtualSupply(poolContext, oracleContext);\n        amountsW"
    }
  ]
}