{
  "Title": "M-3: No slippage or deadline control for swapping while stability burning",
  "Content": "# Issue M-3: No slippage or deadline control for swapping while stability burning \n\nSource: https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/88 \n\n## Found by \n0x4non, 0xGoodess, Jiamin, Juntao, PawelK, circlelooper, ctf\\_sec, moneyversed, okolicodes, radev\\_sw, stopthecap, tsvetanovv\n## Summary\nNo slippage or deadline control for swapping while stability burning\n\n## Vulnerability Detail\n\nEven though Unitas claims there will not be slippage because if it is burned from one side, it is minted in the other one, there is an edge-case where it does create a slight slippage depending on the burn amount.  Unitas intends to make stability burns when the reserve ratio is below 130% to try and get it back to normal levels. This burn, is a one sided burn of `usd1`, which reduces the `totalSupply` of `usd1` unilaterally.\nhttps://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/Unitas.sol#L208\n\nIf any user is trying to swap `usd1` while there is a stability burn being conducted, they will be affected by that slippage.\n\nThe other recommendation is the usage of a deadline param. Without a deadline parameter, the transaction may sit in the mempool and be executed at a much later time potentially resulting in a swap after/before a stability burn.\n\n## Impact\nUser will be affected by unintended and unhandled slippage, potentially affecting the funds they get back from the swap\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/Unitas.sol#L208\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAllow a user to specify to key parameters, a `deadline` and a `minOutAmount`. And make a check for both at start and end of the execution in the swap function.\n\n\n\n## Discussion\n\n**SunXrex**\n\nSun: In this phase we don’t support stability burn.\n\nAditya: Slippage on a swap DEX like Uniswap is part of the design. This is to ensure that the pool does not get fully empty. So if the user places a large order, they see a slippage in price. Every order on a DEX like Uniswap, moves the price. Large orders move the price in higher degree. As the order grows, the slippage also grows. This is inherent property of xy=k bonding curve on which Uniswap operate.\n\nIn case of Unitas, every swap order is essentially mint/burn order. As long as there is enough USDT in reserve and insurance pool, protocol can mint and burn any amount. This leads to 1:1 value transfer without slippage. Unitas does not mint on a bondig curve, instead the protocol simply mints new tokens or burns the existing.\nEg: On uniswap if I buy 1 ETH, I will face low slippage but if I buy 1000 ETH, the slippage will be much higher. However, in case of Unitas whether the user mints 1000 USD91 or 1million USD91, the user will get all the tokens at Oracle price.\n\nIn case of Uniswap, the DEX does not have the authority to mint/burn but only facilitate a swap. In case of Unitas, the protocol has the authority to mint and burn. This leads to no slippage for minters/burners.\n\n**Adityaxrex**\n\nThis style of slippage is low probability for our design. We may fix it in the future but edge case scenario for now. \n\n**SunXrex**\n\nIt should be considered a low-medium risk because the chances of encountering it are very low.\n\n**ctf-sec**\n\n> This style of slippage is low probability for our design. We may fix it in the future but edge case scenario for now.\n\nmedium\n\n**hrishibhat**\n\nConsidering this issue as a medium based on the above comments\n\n**Shogoki**\n\nEscalate for 10 USDC\nI think this issue should be rated as a valid low instead of medium.\nReasons:\n\n- Sponsor stated here already that they consider it low probability.\n- In the contest Readme: “getting different price for price update in the same block” was excluded, which is similiar.\n- according to the sponsor price updates are not that frequent, so the tx would have to stay a long time in the mempool, for this issue\n- Issue #67 was downgraded because the prices are in general quite stable, same goes here and diminishes the impact of the issue\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> I think this issue should be rated as a valid low instead of medium.\n> Reasons:\n> \n> - Sponsor stated here already that they consider it low probability.\n> - In the contest Readme: “getting different price for price update in the same block” was excluded, which is similiar.\n> - according to the sponsor price updates are not that frequent, so the tx would have to stay a long time in the mempool, for this issue\n> - Issue #67 was downgraded because the prices are in general quite stable, same goes here and diminishes the impact of the issue\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**juntzhan**\n\nEscalate for 10 USDC\n\nHi @Shogoki glad to know your thoughts.\n\nThis issue is a valid medium, because price is based on currency exchange rates and it is not fair to say the price is stable or not (depends on the currency itself).\n \nWhen EMC appriciates / depreciates, the sponsor **HAVE TO** update price or the protocol will not work properly.\n\n Please see [#96](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/96) for a reference.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Hi @Shogoki glad to know your thoughts.\n> \n> This issue is a valid medium, because price is based on currency exchange rates and it is not fair to say the price is stable or not (depends on the currency itself).\n>  \n> When EMC appriciates / depreciates, the sponsor **HAVE TO** update price or the protocol will not work properly.\n> \n>  Please see [#96](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/96) for a reference.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nCan keep the medium severity\n\n**0xffff11**\n\nI strongly believe it should keep a med too.\n\n**jacksanford1**\n\nIn order to be Medium severity, the magnitude of the loss has to be quite material. \n\nI don't see anything that points to the magnitude of loss with this slippage issue being very material. \n@Shogoki makes a good point that there also needs to be proof that this issue doesn't fall into the \"known issues\" category from the README:\n\n> In the contest Readme: “getting different price for price update in the same block” was excluded, which is similiar.\n\nI also agree with @juntzhan that we can't rely on the idea that the price is stable:\n\n> because price is based on currency exchange rates and it is not fair to say the price is stable or not (depends on the currency itself).\n\nThe probability of this loss seems fairly low, but even if the probability were medium (instead of low) the impact needs to be large enough to be considered material. And it seems hard to prove that the magnitude of loss could be large, especially considering the stability burn mechanism is probably set up in a way where it shouldn't cause large slippage (someone can check me on that). \n\n@0xffff11 @ctf-sec In order for this to be considered Medium I think two things need to be cleared up:\n1) This technically does not fall under the README known issue above\n2) The magnitude of loss can be large enough to warrant a Medium\n\n**juntzhan**\n\n> In order to be Medium severity, the magnitude of the loss has to be quite material.\n> \n> I don't see anything that points to the magnitude of loss with this slippage issue being very material. @Shogoki makes a good point that there also needs to be proof that this issue doesn't fall into the \"known issues\" category from the README:\n> \n> > In the contest Readme: “getting different price for price update in the same block” was excluded, which is similiar.\n> \n> I also agree with @juntzhan that we can't rely on the idea that the price is stable:\n> \n> > because price is based on currency exchange rates and it is not fair to say the price is stable or not (depends on the currency itself).\n> \n> The probability of this loss seems fairly low, but even if the probability were medium (instead of low) the impact needs to be large enough to be considered material. And it seems hard to prove that the magnitude of loss could be large, especially considering the stability burn mechanism is probably set up in a way where it shouldn't cause large slippage (someone can check me on that).\n> \n> @0xffff11 @ctf-sec In order for this to be considered Medium I think two things need to be cleared up:\n> \n> 1. This technically does not fall under the README known issue above\n> 2. The magnitude of loss can be large enough to warrant a Medium\n\n1. the README known issue \"getting different price for price update in the same block\" assumes the price update and swap happen at the same **POINT** of time and the possibility is very low, while this issue decribes a **PERIOD** of time during which the price update happens, the possibility is much higher, so they are different issues\n2. similar to traditional DEX, user may suffer a large loss without slippage protection, (assume USDEMC/USD1 is 1 : 10) a swap with 10000 USDEMC could result in 100 LESS USD1 due to 10% slippage caused by depreciation, and user could lose more if he swaps more or USDEMC depreciates more\n\nUPDATE:\nI don't think stability burn mechanism does much help to migitate slippage, as the price would be significantly influenced by the currency exchage rates in external financial markets (as confirmed by sponsor,  price data is from multiple cex)\n\n**jacksanford1**\n\n@Shogoki What do you think about juntzhan's points?\n\n**Shogoki**\n\n> @Shogoki What do you think about juntzhan's points?\n\nThanks for enquiring my feedback. Appreciate it :-)\n\nRegarding 1. the mentioned issue in the Readme:\nIt does not say, it happens at the same time, but only “in the same block”. One might say it is probably assumed like this, but it is not clearly stated…\n\nHowever, as also stated in my escalation on #67, if we do not count the argument from the sponsor of stable prices, which was the reason why #67 was downgraded, i believe this one can also be counted as Medium.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [juntzhan](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/88/#issuecomment-1605278986): accepted\n- [Shogoki](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/88/#issuecomment-1604553496): rejected\n\n**jacksanford1**\n\nAcknowledged by protocol team (won't fix). \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/73",
  "Code": [
    {
      "filename": "Unitas-Protocol/src/Unitas.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interfaces/IERC20Token.sol\";\nimport \"./interfaces/IInsurancePool.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IUnitas.sol\";\nimport \"./utils/AddressUtils.sol\";\nimport \"./utils/Errors.sol\";\nimport \"./utils/ScalingUtils.sol\";\nimport \"./SwapFunctions.sol\";\nimport \"./PoolBalances.sol\";\n\n/**\n * @title Unitas\n * @notice This contract is primarily used for exchanging tokens and managing reserve assets\n */\ncontract Unitas is\n    Initializable,\n    PausableUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IUnitas,\n    PoolBalances,\n    SwapFunctions\n{\n    using MathUpgradeable for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n    bytes32 public constant PORTFOLIO_ROLE = keccak256(\"PORTFOLIO_ROLE\");\n\n    IOracle public oracle;\n    address public surplusPool;\n    address public insurancePool;\n    ITokenManager public tokenManager;\n\n    /**\n     * @notice Emitted when `oracle` is updated\n     */\n    event SetOracle(address indexed newOracle);\n    /**\n     * @notice Emitted when `surplusPool` is updated\n     */\n    event SetSurplusPool(address indexed newSurplusPool);\n    /**\n     * @notice Emitted when `insurancePool` is updated\n     */\n    event SetInsurancePool(address indexed newInsurancePool);\n    /**\n     * @notice Emitted when `tokenManager` is updated\n     */\n    event SetTokenManager(ITokenManager indexed newTokenManager);\n    /**\n     * @notice Emitted when `sender` swap tokens\n     */\n    event Swapped(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        address indexed sender,\n        uint256 amountIn,\n        uint256 amountOut,\n        address feeToken,\n        uint256 fee,\n        uint24 feeNumerator,\n        uint256 price\n    );\n    /**\n     * @notice Emitted when swapping `fee` is sent to `receiver`\n     */\n    event SwapFeeSent(address indexed feeToken, address indexed receiver, uint256 fee);\n\n    // ============================== ERRORS ==============================\n\n    error NotTimelock(address caller);\n    error NotGuardian(address caller);\n    error NotPortfolio(address caller);\n\n    // ============================== MODIFIERS ==============================\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `TIMELOCK_ROLE`\n     */\n    modifier onlyTimelock() {\n        if (!hasRole(TIMELOCK_ROLE, msg.sender))\n            revert NotTimelock(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `GUARDIAN_ROLE`\n     */\n    modifier onlyGuardian() {\n        if (!hasRole(GUARDIAN_ROLE, msg.sender))\n            revert NotGuardian(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `account` does not have `PORTFOLIO_ROLE`\n     */\n    modifier onlyPortfolio(address account) {\n        if (!hasRole(PORTFOLIO_ROLE, account)) {\n            revert NotPortfolio(account);\n        }\n        _;\n    }\n\n\n    // ============================== CONSTRUCTOR ==============================\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract\n     * @param config_ `InitializeConfig` to init states\n     */\n    function initialize(InitializeConfig calldata config_) public initializer {\n        __Pausable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);\n        _setRoleAdmin(TIMELOCK_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(PORTFOLIO_ROLE, GUARDIAN_ROLE);\n\n        _grantRole(GOVERNOR_ROLE, config_.governor);\n        _grantRole(GUARDIAN_ROLE, config_.guardian);\n        _grantRole(TIMELOCK_ROLE, config_.timelock);\n        _grantRole(PORTFOLIO_ROLE, config_.guardian);\n\n        _setOracle(config_.oracle);\n        _setSurplusPool(config_.surplusPool);\n        _setInsurancePool(config_.insurancePool);\n        _setTokenManager(config_.tokenManager);\n    }\n\n    // ============================== Timelock FUNCTIONS ===========================\n\n    /**\n     * @notice Updates the address of `oracle` by `newOracle`\n     */\n    function setOracle(address newOracle) external onlyTimelock {\n        _setOracle(newOracle);\n    }\n\n    /**\n     * @notice Updates the address of `surplusPool` by `newSurplusPool`\n     */\n    function setSurplusPool(address newSurplusPool) external onlyTimelock {\n        _setSurplusPool(newSurplusPool);\n    }\n\n    /**\n     * @notice Updates the address of `insurancePool` by `newInsurancePool`\n     */\n    function setInsurancePool(address newInsurancePool) external onlyTimelock {\n        _setInsurancePool(newInsurancePool);\n    }\n\n    /**\n     * @notice Updates the address of `tokenManager`\n     */\n    function setTokenManager(ITokenManager newTokenManager) external onlyTimelock {\n        _setTokenManager(newTokenManager);\n    }\n\n    // ============================== GUARDIAN FUNCTIONS ===========================\n\n    /**\n     * @notice Pause token swapping\n     */\n    function pause() public onlyGuardian {\n        _pause();\n    }\n\n    /**\n     * @notice Resume token swapping\n     */\n    function unpause() public onlyGuardian {\n        _unpause();\n    }\n\n    // ============================== EXTERNAL FUNCTIONS ===========================\n\n    /**\n     * @notice Swaps tokens\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` spent\n     * @return amountOut The amount of `tokenOut` obtained\n     */\n    function swap(address tokenIn, address tokenOut, AmountType amountType, uint256 amount)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (uint256 amountIn, uint256 amountOut)\n    {\n        IERC20Token feeToken;\n        uint256 fee;\n        uint24 feeNumerator;\n        uint256 price;\n        ITokenManager.PairConfig memory pair = tokenManager.getPair(tokenIn, tokenOut);\n\n        (amountIn, amountOut, feeToken, fee, feeNumerator, price) = _getSwapResult(pair, tokenIn, tokenOut, amountType, amount);\n\n        _require(IERC20(tokenIn).balanceOf(msg.sender) >= amountIn, Errors.BALANCE_INSUFFICIENT);\n\n        _swapIn(tokenIn, msg.sender, amountIn);\n\n        _swapOut(tokenOut, msg.sender, amountOut);\n\n        if (fee > 0) {\n            address feeReceiver = surplusPool;\n            feeToken.mint(feeReceiver, fee);\n            emit SwapFeeSent(address(feeToken), feeReceiver, fee);\n        }\n\n        _checkReserveRatio(tokenOut == pair.baseToken ? pair.buyReserveRatioThreshold : pair.sellReserveRatioThreshold);\n\n        emit Swapped(tokenIn, tokenOut, msg.sender, amountIn, amountOut, address(feeToken), fee, feeNumerator, price);\n    }\n\n    /**\n     * @notice Receives the portfolio from caller\n     * @param token Address of the token\n     * @param amount Amount of the portfolio\n     */\n    function receivePortfolio(address token, uint256 amount)\n        external\n        onlyPortfolio(msg.sender)\n        nonReentrant\n    {\n        _receivePortfolio(token, msg.sender, amount);\n    }\n\n    /**\n     * @notice Sends the portfolio to the receiver\n     * @param token Address of the token\n     * @param receiver Account to receive the portfolio\n     * @param amount Amount of the portfolio\n     */\n    function sendPortfolio(address token, address receiver, uint256 amount)\n        external\n        onlyTimelock\n        onlyPortfolio(receiver)\n        nonReentrant\n    {\n        _sendPortfolio(token, receiver, amount);\n    }\n\n    /**\n     * @notice Estimates swapping result for quoting\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return feeToken The fee token\n     * @return fee Swapping fee calculated in `feeToken`\n     * @return feeNumerator The numerator of the fee fraction\n     * @return price The price of `tokenIn`/`tokenOut`\n     */\n    function estimateSwapResult(address tokenIn, address tokenOut, AmountType amountType, uint256 amount)\n        external\n        view\n        returns (uint256 amountIn, uint256 amountOut, IERC20Token feeToken, uint256 fee, uint24 feeNumerator, uint256 price)\n    {\n        ITokenManager.PairConfig memory pair = tokenManager.getPair(tokenIn, tokenOut);\n\n        (amountIn, amountOut, feeToken, fee, feeNumerator, price) = _getSwapResult(pair, tokenIn, tokenOut, amountType, amount);\n    }\n\n    // ============================== PUBLIC FUNCTIONS ==============================\n\n    /**\n     * @notice Gets the reserve of `token`\n     */\n    function getReserve(address token) public view returns (uint256) {\n        return _getBalance(token);\n    }\n\n    /**\n     * @notice Gets the portfolio of `token`\n     */\n    function getPortfolio(address token) public view returns (uint256) {\n        return _getPortfolio(token);\n    }\n\n    /**\n     * @notice Gets the reserve status\n     * @return reserveStatus `Undefined` when `reserves`, `collaterals` and `liabilities` are zero.\n                              `Infinite` when `liabilities` is zero.\n                              Otherwise `Finite`.\n     * @return reserves Total reserves denominated in USD1\n     * @return collaterals Total collaterals denominated in USD1\n     * @return liabilities Total liabilities denominated in USD1\n     * @return reserveRatio The numerator of the reserve ratio is expressed in 18 decimal places\n     */\n    function getReserveStatus()\n        public\n        view\n        returns (ReserveStatus reserveStatus, uint256 reserves, uint256 collaterals, uint256 liabilities, uint256 reserveRatio)\n    {\n        (reserves, collaterals) = _getTotalReservesAndCollaterals();\n        liabilities = _getTotalLiabilities();\n\n        (reserveStatus, reserveRatio) = _getReserveStatus(reserves + collaterals, liabilities);\n    }\n\n    // ============================== INTERNAL FUNCTIONS ==============================\n\n    function _setOracle(address newOracle) internal {\n        AddressUtils.checkContract(newOracle);\n        oracle = IOracle(newOracle);\n        emit SetOracle(newOracle);\n    }\n\n    function _setSurplusPool(address newSurplusPool) internal {\n        _require(newSurplusPool != address(0), Errors.ADDRESS_ZERO);\n        surplusPool = newSurplusPool;\n        emit SetSurplusPool(newSurplusPool);\n    }\n\n    function _setInsurancePool(address newInsurancePool) internal {\n        AddressUtils.checkContract(newInsurancePool);\n        insurancePool = newInsurancePool;\n        emit SetInsurancePool(newInsurancePool);\n    }\n\n    function _setTokenManager(ITokenManager newTokenManager) internal {\n        AddressUtils.checkContract(address(newTokenManager));\n        tokenManager = newTokenManager;\n        emit SetTokenManager(newTokenManager);\n    }\n\n    /**\n     * @notice Spends tokens for swapping\n     * @param token The address of the token\n     * @param spender The account to spend tokens\n     * @param amount The amount to be consumed\n     */\n    function _swapIn(address token, address spender, uint256 amount) internal {\n        ITokenManager.TokenType tokenType = tokenManager.getTokenType(token);\n\n        require(tokenType != ITokenManager.TokenType.Undefined);\n\n        if (tokenType == ITokenManager.TokenType.Asset) {\n            _setBalance(token, _getBalance(token) + amount);\n            IERC20(token).safeTransferFrom(spender, address(this), amount);\n        } else {\n            IERC20Token(token).burn(spender, amount);\n        }\n    }\n\n    /**\n     * @notice Receives tokens for swapping\n     * @param token The address of the token\n     * @param receiver The account to receive tokens\n     * @param amount The amount to be obtained\n     */\n    function _swapOut(address token, address receiver, uint256 amount) internal {\n        ITokenManager.TokenType tokenType = tokenManager.getTokenType(token);\n\n        require(tokenType != ITokenManager.TokenType.Undefined);\n\n        if (tokenType == ITokenManager.TokenType.Asset) {\n            uint256 tokenReserve = _getBalance(token);\n            uint256 reserveAmount = amount.min(tokenReserve - _getPortfolio(token));\n\n            if (amount > reserveAmount) {\n                uint256 collateralAmount = amount - reserveAmount;\n\n                // Pull the collateral from insurance pool\n                IInsurancePool(insurancePool).withdrawCollateral(token, collateralAmount);\n            }\n\n            _setBalance(token, tokenReserve - reserveAmount);\n            IERC20(token).safeTransfer(receiver, amount);\n        } else {\n            IERC20Token(token).mint(receiver, amount);\n        }\n    }\n\n    /**\n     * @notice Gets the swapping result\n     * @param pair The setting of the pair\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return feeToken The fee token is always USD1\n     * @return fee Swapping fee calculated in USD1\n     * @return feeNumerator The numerator of the fee fraction\n     * @return price The price of `tokenIn`/`tokenOut`\n     */\n    function _getSwapResult(\n        ITokenManager.PairConfig memory pair,\n        address tokenIn,\n        address tokenOut,\n        AmountType amountType,\n        uint256 amount\n    )\n        internal\n        view\n        returns (uint256 amountIn, uint256 amountOut, IERC20Token feeToken, uint256 fee, uint24 feeNumerator, uint256 price)\n    {\n        _checkAmountPositive(amount);\n\n        // Checks the tokens of the pair config are valid\n        bool isBuy = tokenOut == pair.baseToken;\n        _require(\n            (isBuy && tokenIn == pair.quoteToken) ||\n                (tokenOut == pair.quoteToken && tokenIn == pair.baseToken),\n            Errors.PAIR_INVALID\n        );\n\n        address priceQuoteToken = _getPriceQuoteToken(tokenIn, tokenOut);\n        price = oracle.getLatestPrice(priceQuoteToken);\n        _checkPrice(priceQuoteToken, price);\n\n        feeNumerator = isBuy ? pair.buyFee : pair.sellFee;\n        feeToken = IERC20Token(priceQuoteToken == tokenIn ? tokenOut : tokenIn);\n\n        SwapRequest memory request;\n        request.tokenIn = tokenIn;\n        request.tokenOut = tokenOut;\n        request.amountType = amountType;\n        request.amount = amount;\n        request.feeNumerator = feeNumerator;\n        request.feeBase = tokenManager.SWAP_FEE_BASE();\n        request.feeToken = address(feeToken);\n        request.price = price;\n        request.priceBase = 10 ** oracle.decimals();\n        request.quoteToken = priceQuoteToken;\n\n        (amountIn, amountOut, fee) = _calculateSwapResult(request);\n\n        _require(amountIn > 0 && amountOut > 0, Errors.SWAP_RESULT_INVALID);\n\n        if (tokenIn == priceQuoteToken) {\n            // The base currency of oracle price is USD1, inverts the price when buying USD1\n            price = request.priceBase * request.priceBase / price;\n        }\n    }\n\n    /**\n     * @notice Gets the reserve status and reserve ratio.\n     * @param allReserves Sum of the reserves and the collaterals denominated in USD1\n     * @param liabilities Total liabilities denominated in USD1\n     * @return reserveStatus `Undefined` when `allReserves` and `liabilities` are zero.\n                              `Infinite` when `liabilities` is zero.\n                              Otherwise `Finite`.\n     * @return reserveRatio The numerator of the reserve ratio is expressed in 18 decimal places\n     */\n    function _getReserveStatus(uint256 allReserves, uint256 liabilities)\n        internal\n        view\n        returns (ReserveStatus reserveStatus, uint256 reserveRatio)\n    {\n        if (liabilities == 0) {\n            reserveStatus = allReserves == 0 ? ReserveStatus.Undefined : ReserveStatus.Infinite;\n        } else {\n            reserveStatus = ReserveStatus.Finite;\n\n            // All decimals of parameters are the same as USD1\n            uint256 valueBase = 10 ** tokenManager.usd1().decimals();\n\n            reserveRatio = ScalingUtils.scaleByBases(\n                allReserves * valueBase / liabilities,\n                valueBase,\n                tokenManager.RESERVE_RATIO_BASE()\n            );\n        }\n    }\n\n    /**\n     * @notice Gets total reserves and total collaterals in USD1\n     */\n    function _getTotalReservesAndCollaterals() internal view returns (uint256 reserves, uint256 collaterals) {\n        address baseToken = address(tokenManager.usd1());\n        uint8 tokenTypeValue = uint8(ITokenManager.TokenType.Asset);\n        uint256 tokenCount = tokenManager.tokenLength(tokenTypeValue);\n        uint256 priceBase = 10 ** oracle.decimals();\n\n        for (uint256 i; i < tokenCount; i++) {\n            address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n            uint256 tokenReserve = _getBalance(token);\n            uint256 tokenCollateral = IInsurancePool(insurancePool).getCollateral(token);\n\n            if (tokenReserve > 0 || tokenCollateral > 0) {\n                uint256 price = oracle.getLatestPrice(token);\n\n                reserves += _convert(\n                    token,\n                    baseToken,\n                    tokenReserve,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n\n                collaterals += _convert(\n                    token,\n                    baseToken,\n                    tokenCollateral,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Gets total liabilities in USD1\n     */\n    function _getTotalLiabilities() internal view returns (uint256 liabilities) {\n        address baseToken = address(tokenManager.usd1());\n        uint8 tokenTypeValue = uint8(ITokenManager.TokenType.Stable);\n        uint256 tokenCount = tokenManager.tokenLength(tokenTypeValue);\n        uint256 priceBase = 10 ** oracle.decimals();\n\n        for (uint256 i; i < tokenCount; i++) {\n            address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n            uint256 tokenSupply = IERC20Token(token).totalSupply();\n\n            if (token == baseToken) {\n                // Adds up directly when the token is USD1\n                liabilities += tokenSupply;\n            } else if (tokenSupply > 0) {\n                uint256 price = oracle.getLatestPrice(token);\n\n                liabilities += _convert(\n                    token,\n                    baseToken,\n                    tokenSupply,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Gets the quote token of oracle price by two token addresses.\n     *          Because of the base currencies of all oracle prices are always USD1 (e.g., USD1/USDT and USD1/USD91),\n     *          one of `tokenX` or `tokenY` must be USD1, and the other must not be USD1.\n     * @dev The caller must ensure that both tokens are in the pool\n     * @param tokenX Address of base currency or quote currency\n     * @param tokenY Address of base currency or quote currency\n     * @return quoteToken The quote currency of oracle price\n     */\n    function _getPriceQuoteToken(address tokenX, address tokenY) internal view returns (address quoteToken) {\n        _require(tokenX != tokenY, Errors.PAIR_INVALID);\n\n        address baseToken = address(tokenManager.usd1());\n        _require(baseToken != address(0), Errors.USD1_NOT_SET);\n\n        bool isXBase = tokenX == baseToken;\n        _require(isXBase || tokenY == baseToken, Errors.PAIR_INVALID);\n\n        quoteToken = isXBase ? tokenY : tokenX;\n    }\n\n    /**\n     * @notice Reverts if the price or the tolerance range is invalid\n     * @param quoteToken Address of quote token to get the tolerance range\n     * @param price The price of USD1/`quoteToken`\n     */\n    function _checkPrice(address quoteToken, uint256 price) internal view {\n        (uint256 minPrice, uint256 maxPrice) = tokenManager.getPriceTolerance(quoteToken);\n\n        _require(minPrice > 0 && maxPrice > 0, Errors.PRICE_TOLERANCE_INVALID);\n        _require(minPrice <= price && price <= maxPrice, Errors.PRICE_INVALID);\n    }\n\n    /**\n     * @notice Checks the reserve ratio is sufficient when `reserveRatioThreshold` is greater than zero\n     */\n    function _checkReserveRatio(uint232 reserveRatioThreshold) internal view {\n        if (reserveRatioThreshold == 0) {\n            return;\n        } else {\n            (uint256 reserves, uint256 collaterals) = _getTotalReservesAndCollaterals();\n            uint256 allReserves = reserves + collaterals;\n            uint256 liabilities = _getTotalLiabilities();\n\n            (ReserveStatus reserveStatus, uint256 reserveRatio) = _getReserveStatus(allReserves, liabilities);\n\n            if (reserveStatus != ReserveStatus.Infinite) {\n                _require(reserveRatio > reserveRatioThreshold, Errors.RESERVE_RATIO_NOT_GREATER_THAN_THRESHOLD);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "Unitas-Protocol/src/Unitas.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interfaces/IERC20Token.sol\";\nimport \"./interfaces/IInsurancePool.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IUnitas.sol\";\nimport \"./utils/AddressUtils.sol\";\nimport \"./utils/Errors.sol\";\nimport \"./utils/ScalingUtils.sol\";\nimport \"./SwapFunctions.sol\";\nimport \"./PoolBalances.sol\";\n\n/**\n * @title Unitas\n * @notice This contract is primarily used for exchanging tokens and managing reserve assets\n */\ncontract Unitas is\n    Initializable,\n    PausableUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IUnitas,\n    PoolBalances,\n    SwapFunctions\n{\n    using MathUpgradeable for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n    bytes32 public constant PORTFOLIO_ROLE = keccak256(\"PORTFOLIO_ROLE\");\n\n    IOracle public oracle;\n    address public surplusPool;\n    address public insurancePool;\n    ITokenManager public tokenManager;\n\n    /**\n     * @notice Emitted when `oracle` is updated\n     */\n    event SetOracle(address indexed newOracle);\n    /**\n     * @notice Emitted when `surplusPool` is updated\n     */\n    event SetSurplusPool(address indexed newSurplusPool);\n    /**\n     * @notice Emitted when `insurancePool` is updated\n     */\n    event SetInsurancePool(address indexed newInsurancePool);\n    /**\n     * @notice Emitted when `tokenManager` is updated\n     */\n    event SetTokenManager(ITokenManager indexed newTokenManager);\n    /**\n     * @notice Emitted when `sender` swap tokens\n     */\n    event Swapped(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        address indexed sender,\n        uint256 amountIn,\n        uint256 amountOut,\n        address feeToken,\n        uint256 fee,\n        uint24 feeNumerator,\n        uint256 price\n    );\n    /**\n     * @notice Emitted when swapping `fee` is sent to `receiver`\n     */\n    event SwapFeeSent(address indexed feeToken, address indexed receiver, uint256 fee);\n\n    // ============================== ERRORS ==============================\n\n    error NotTimelock(address caller);\n    error NotGuardian(address caller);\n    error NotPortfolio(address caller);\n\n    // ============================== MODIFIERS ==============================\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `TIMELOCK_ROLE`\n     */\n    modifier onlyTimelock() {\n        if (!hasRole(TIMELOCK_ROLE, msg.sender))\n            revert NotTimelock(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `GUARDIAN_ROLE`\n     */\n    modifier onlyGuardian() {\n        if (!hasRole(GUARDIAN_ROLE, msg.sender))\n            revert NotGuardian(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `account` does not have `PORTFOLIO_ROLE`\n     */\n    modifier onlyPortfolio(address account) {\n        if (!hasRole(PORTFOLIO_ROLE, account)) {\n            revert NotPortfolio(account);\n        }\n        _;\n    }\n\n\n    // ============================== CONSTRUCTOR ==============================\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract\n     * @param config_ `InitializeConfig` to init states\n     */\n    function initialize(InitializeConfig calldata config_) public initializer {\n        __Pausable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);\n        _setRoleAdmin(TIMELOCK_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(PORTFOLIO_ROLE, GUARDIAN_ROLE);\n\n        _grantRole(GOVERNOR_ROLE, config_.governor);\n        _grantRole(GUARDIAN_ROLE, config_.guardian);\n        _grantRole(TIMELOCK_ROLE, config_.timelock);\n        _grantRole(PORTFOLIO_ROLE, config_.guardian);\n\n        _setOracle(config_.oracle);\n        _setSurplusPool(config_.surplusPool);\n        _setInsurancePool(config_.insurancePool);\n        _setTokenManager(config_.tokenManager);\n    }\n\n    // ============================== Timelock FUNCTIONS ===========================\n\n    /**\n     * @notice Updates the address of `oracle` by `newOracle`\n     */\n    function setOracle(address newOracle) external onlyTimelock {\n        _setOracle(newOracle);\n    }\n\n    /**\n     * @notice Updates the address of `surplusPool` by `newSurplusPool`\n     */\n    function setSurplusPool(address newSurplusPool) external onlyTimelock {\n        _setSurplusPool(newSurplusPool);\n    }\n\n    /**\n     * @notice Updates the address of `insurancePool` by `newInsurancePool`\n     */\n    function setInsurancePool(address newInsurancePool) external onlyTimelock {\n        _setInsurancePool(newInsurancePool);\n    }\n\n    /**\n     * @notice Updates the address of `tokenManager`\n     */\n    function setTokenManager(ITokenManager newTokenManager) external onlyTimelock {\n        _setTokenManager(newTokenManager);\n    }\n\n    // ============================== GUARDIAN FUNCTIONS ===========================\n\n    /**\n     * @notice Pause token swapping\n     */\n    function pause() public onlyGuardian {\n        _pause();\n    }\n\n    /**\n     * @notice Resume token swapping\n     */\n    function unpause() public onlyGuardian {\n        _unpause();\n    }\n\n    // ============================== EXTERNAL FUNCTIONS ===========================\n\n    /**\n     * @notice Swaps tokens\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` spent\n     * @return amountOut The amount of `tokenOut` obtained\n     */\n    function swap(address tokenIn, address tokenOut, AmountType amountType, uint256 amount)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (uint256 amountIn, uint256 amountOut)\n    {\n        IERC20Token feeToken;\n        uint256 fee;\n        uint24 feeNumerator;\n        uint256 price;\n        ITokenManager.PairConfig memory pair = tokenManager.getPair(tokenIn, tokenOut);\n\n        (amountIn, amountOut, feeToken, fee, feeNumerator, price) = _getSwapResult(pair, tokenIn, tokenOut, amountType, amount);\n\n        _require(IERC20(tokenIn).balanceOf(msg.sender) >= amountIn, Errors.BALANCE_INSUFFICIENT);\n\n        _swapIn(tokenIn, msg.sender, amountIn);\n\n        _swapOut(tokenOut, msg.sender, amountOut);\n\n        if (fee > 0) {\n            address feeReceiver = surplusPool;\n            feeToken.mint(feeReceiver, fee);\n            emit SwapFeeSent(address(feeToken), feeReceiver, fee);\n        }\n\n        _checkReserveRatio(tokenOut == pair.baseToken ? pair.buyReserveRatioThreshold : pair.sellReserveRatioThreshold);\n\n        emit Swapped(tokenIn, tokenOut, msg.sender, amountIn, amountOut, address(feeToken), fee, feeNumerator, price);\n    }\n\n    /**\n     * @notice Receives the portfolio from caller\n     * @param token Address of the token\n     * @param amount Amount of the portfolio\n     */\n    function receivePortfolio(address token, uint256 amount)\n        external\n        onlyPortfolio(msg.sender)\n        nonReentrant\n    {\n        _receivePortfolio(token, msg.sender, amount);\n    }\n\n    /**\n     * @notice Sends the portfolio to the receiver\n     * @param token Address of the token\n     * @param receiver Account to receive the portfolio\n     * @param amount Amount of the portfolio\n     */\n    function sendPortfolio(address token, address receiver, uint256 amount)\n        external\n        onlyTimelock\n        onlyPortfolio(receiver)\n        nonReentrant\n    {\n        _sendPortfolio(token, receiver, amount);\n    }\n\n    /**\n     * @notice Estimates swapping result for quoting\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return feeToken The fee token\n     * @return fee Swapping fee calculated in `feeToken`\n     * @return feeNumerator The numerator of the fee fraction\n     * @return price The price of `tokenIn`/`tokenOut`\n     */\n    function estimateSwapResult(address tokenIn, address tokenOut, AmountType amountType, uint256 amount)\n        external\n        view\n        returns (uint256 amountIn, uint256 amountOut, IERC20Token feeToken, uint256 fee, uint24 feeNumerator, uint256 price)\n    {\n        ITokenManager.PairConfig memory pair = tokenManage"
    }
  ]
}