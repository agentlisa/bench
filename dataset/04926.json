{
  "Title": "[M-02] `_maxYieldVaultWithdraw()` uses `yieldVault.convertToAssets()`",
  "Content": "\n### Proof of Concept\n\n```solidity\nfunction _maxYieldVaultWithdraw() internal view returns (uint256) {\n    return yieldVault.convertToAssets(yieldVault.maxRedeem(address(this)));\n}\n```\n\nThe above code uses `yieldVault.convertToAssets()` which, per EIP-4626, is only approximate. Especially, it might return too much, and thus `_maxYieldVaultWithdraw()` might return too much.\n`_maxYieldVaultWithdraw()` is used [in `maxWithdraw()`](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L405), [in `maxRedeem()`](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L416), and [in `liquidatableBalanceOf()`](https://github.com/code-423n4/2024-03-pooltogether/blob/480d58b9e8611c13587f28811864aea138a0021a/pt-v5-vault/src/PrizeVault.sol#L639) which functions may thus return too much. In the case of `maxWithdraw()` and `maxRedeem()` this violates EIP-4626.\n\n### Recommended Mitigation Steps\n\nUse `yieldVault.previewRedeem(yieldVault.maxRedeem(address(this)))`.\n\n### Assessed type\n\nERC4626\n\n**[trmid (PoolTogether) confirmed and commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/336#issuecomment-2018842026):**\n > Mitigation [here](https://github.com/GenerationSoftware/pt-v5-vault/pull/97). Also see [here](https://github.com/GenerationSoftware/pt-v5-vault/pull/96) for more details.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-pooltogether",
  "Code": [
    {
      "filename": "pt-v5-vault/src/PrizeVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC4626 } from \"openzeppelin/interfaces/IERC4626.sol\";\nimport { SafeERC20, IERC20Permit } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20, IERC20, IERC20Metadata } from \"openzeppelin/token/ERC20/ERC20.sol\";\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\nimport { Ownable } from \"owner-manager-contracts/Ownable.sol\";\n\nimport { Claimable } from \"./abstract/Claimable.sol\";\nimport { TwabERC20 } from \"./TwabERC20.sol\";\n\nimport { ILiquidationSource } from \"pt-v5-liquidator-interfaces/ILiquidationSource.sol\";\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\nimport { TwabController, SPONSORSHIP_ADDRESS } from \"pt-v5-twab-controller/TwabController.sol\";\n\n/// @title  PoolTogether V5 Prize Vault\n/// @author G9 Software Inc.\n/// @notice The prize vault takes deposits of an asset and earns yield with the deposits through an underlying yield\n///         vault. The yield is then expected to be liquidated and contributed to the prize pool as prize tokens. The\n///         depositors of the prize vault will then be eligible to win prizes from the pool. If a prize is won, The \n///         permitted claimer contract for the prize vault will claim the prize on behalf of the winner. Depositors\n///         can also set custom hooks that are called directly before and after their prize is claimed.\n/// @dev    Share balances are stored in the TwabController contract.\n/// @dev    Depositors should always expect to be able to withdraw their full deposit amount and no more as long as\n///         global withdrawal limits meet or exceed their balance. However, if the underlying yield source loses\n///         assets, depositors will only be able to withdraw a proportional amount of remaining assets based on their\n///         share balance and the total debt balance.\n/// @dev    The prize vault is designed to embody the \"no loss\" spirit of PoolTogether, down to the last wei. Most \n///         ERC4626 yield vaults incur small, necessary rounding errors on deposit and withdrawal to ensure the\n///         internal accounting cannot be taken advantage of. The prize vault employs two strategies in an attempt\n///         to cover these rounding errors with yield to ensure that depositors can withdraw every last wei of their\n///         initial deposit:\n///\n///             1. The \"dust collection strategy\":\n///\n///                Rounding errors are directly related to the exchange rate of the underlying yield vault; the more\n///                assets a single yield vault share is worth, the more severe the rounding errors can become. For\n///                example, if the exchange rate is 100 assets for 1 yield vault share and we assume 0 decimal\n///                precision; if alice deposits 199 assets, the yield vault will round down on the conversion and mint\n///                alice 1 share, essentially donating the remaining 99 assets to the yield vault. This behavior can\n///                open pathways for exploits in the prize vault since a bad actor could repeatedly make deposits and\n///                withdrawals that result in large rounding errors and since the prize vault covers rounding errors\n///                with yield, the attacker could withdraw without loss while essentially donating the yield back to\n///                the yield vault.\n///\n///                To mitigate this issue, the prize vault calculates the amount of yield vault shares that would be\n///                minted during a deposit, but mints those shares directly instead, ensuring that only the exact\n///                amount of assets needed are sent to the yield vault while keeping the remainder as a latent balance\n///                in the prize vault until it can be used in the next deposit or withdraw. An inverse strategy is also\n///                used when withdrawing assets from the yield vault. This reduces the possible rounding errors to just\n///                1 wei per deposit or withdraw.\n///\n///             2. The \"yield buffer\":\n///\n///                Since the prize vault can still incur minimal rounding errors from the yield vault, a yield buffer\n///                is required to ensure that there is always enough yield reserved to cover the rounding errors on \n///                deposits and withdrawals. This buffer should never run dry during normal operating conditions and\n///                expected yield rates. If the yield buffer is ever depleted, new deposits will be prevented and the\n///                prize vault will enter a lossy withdrawal state where depositors will incur the rounding errors on\n///                withdraw.\n///\n/// @dev    The prize vault does not support underlying yield vaults that take a fee on deposit or withdraw.\n///\ncontract PrizeVault is TwabERC20, Claimable, IERC4626, ILiquidationSource, Ownable {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Public Constants and Variables\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The yield fee decimal precision.\n    uint32 public constant FEE_PRECISION = 1e9;\n    \n    /// @notice The max yield fee that can be set.\n    /// @dev Decimal precision is defined by `FEE_PRECISION`.\n    /// @dev If the yield fee is set too high, liquidations won't occur on a regular basis. If a use case requires\n    /// a yield fee higher than this max, a custom liquidation pair can be set to manipulate the yield as required.\n    uint32 public constant MAX_YIELD_FEE = 9e8;\n\n    /// @notice The yield buffer that is reserved for covering rounding errors on withdrawals and deposits.\n    /// @dev The buffer prevents the entire yield balance from being liquidated, which would leave the vault\n    /// in a state where a single rounding error could reduce the totalAssets to less than the totalSupply.\n    /// \n    /// The yield buffer is expected to be of insignificant value and is used to cover rounding\n    /// errors on deposits and withdrawals. Yield is expected to accrue faster than the yield buffer\n    /// can be reasonably depleted.\n    ///\n    /// IT IS RECOMMENDED TO DONATE ASSETS DIRECTLY TO THE PRIZE VAULT AFTER DEPLOYMENT TO FILL THE YIELD\n    /// BUFFER AND COVER ROUNDING ERRORS UNTIL THE DEPOSITS CAN GENERATE ENOUGH YIELD TO KEEP THE BUFFER \n    /// FULL WITHOUT ASSISTANCE.\n    ///\n    /// The yield buffer should be set as high as possible while still being considered insignificant\n    /// for the underlying asset. For example, a reasonable yield buffer for USDC with 6 decimals might be\n    /// 1e5 ($0.10), which will cover up to 100k rounding errors while still being an insignificant value.\n    /// Some assets may be considered incompatible with the prize vault if the yield vault incurs rounding\n    /// errors and the underlying asset has a low precision per dollar ratio.\n    /// \n    /// Precision per dollar (PPD) can be calculated by: (10 ^ DECIMALS) / ($ value of 1 asset).\n    /// For example, USDC has a PPD of (10 ^ 6) / ($1) = 10e6 p/$.\n    /// \n    /// As a rule of thumb, assets with lower PPD than USDC should not be assumed to be compatible since\n    /// the potential loss of a single unit rounding error is likely too high to be made up by yield at \n    /// a reasonable rate. Actual results may vary based on expected gas costs, asset fluctuation, and yield\n    /// accrual rates. If the underlying yield vault does not incur any rounding errors, then the yield buffer\n    /// can be set to zero.\n    ///\n    /// If the yield buffer is depleted on the prize vault, new deposits will be prevented if it would result in\n    /// a rounding error and any rounding errors incurred by withdrawals will not be covered by yield. The yield\n    /// buffer will be replenished automatically as yield accrues.\n    uint256 public immutable yieldBuffer;\n\n    /// @notice Address of the underlying ERC4626 vault generating yield.\n    IERC4626 public immutable yieldVault;\n\n    /// @notice Yield fee percentage represented in integer format with decimal precision defined by `FEE_PRECISION`.\n    /// @dev For example, if `FEE_PRECISION` were 1e9 a value of 1e7 = 0.01 = 1%.\n    uint32 public yieldFeePercentage;\n\n    /// @notice Address of the yield fee recipient.\n    address public yieldFeeRecipient;\n\n    /// @notice The accrued yield fee balance that the fee recipient can claim as vault shares.\n    uint256 public yieldFeeBalance;\n\n    /// @notice Address of the liquidation pair used to liquidate yield for prize token.\n    address public liquidationPair;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Private Variables\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Address of the underlying asset used by the Vault.\n    IERC20 private immutable _asset;\n\n    /// @notice Underlying asset decimals.\n    uint8 private immutable _underlyingDecimals;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Events\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Emitted when a new yield fee recipient has been set.\n    /// @param yieldFeeRecipient Address of the new yield fee recipient\n    event YieldFeeRecipientSet(address indexed yieldFeeRecipient);\n\n    /// @notice Emitted when a new yield fee percentage has been set.\n    /// @param yieldFeePercentage New yield fee percentage\n    event YieldFeePercentageSet(uint256 yieldFeePercentage);\n\n    /// @notice Emitted when a user sponsors the Vault.\n    /// @param caller Address that called the function\n    /// @param assets Amount of assets deposited into the Vault\n    /// @param shares Amount of shares minted to the caller address\n    event Sponsor(address indexed caller, uint256 assets, uint256 shares);\n\n    /// @notice Emitted when yield is transferred out by the liquidation pair address.\n    /// @param liquidationPair The liquidation pair address that initiated the transfer\n    /// @param tokenOut The token that was transferred out\n    /// @param recipient The recipient of the tokens\n    /// @param amountOut The amount of tokens sent to the recipient\n    /// @param yieldFee The amount of shares accrued on the yield fee balance\n    event TransferYieldOut(\n        address indexed liquidationPair,\n        address indexed tokenOut,\n        address indexed recipient,\n        uint256 amountOut,\n        uint256 yieldFee\n    );\n\n    /// @notice Emitted when yield fee shares are claimed by the yield fee recipient.\n    /// @param recipient Address receiving the fee shares\n    /// @param shares Amount of shares claimed\n    event ClaimYieldFeeShares(address indexed recipient, uint256 shares);\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Errors\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Thrown when the Yield Vault is set to the zero address.\n    error YieldVaultZeroAddress();\n\n    /// @notice Thrown when the Owner is set to the zero address.\n    error OwnerZeroAddress();\n\n    /// @notice Thrown when a withdrawal of zero assets on the yield vault is attempted\n    error WithdrawZeroAssets();\n\n    /// @notice Thrown when no shares are being burnt during a withdrawal of assets\n    error BurnZeroShares();\n\n    /// @notice Thrown when zero assets are being deposited\n    error DepositZeroAssets();\n\n    /// @notice Thrown when zero shares are being minted\n    error MintZeroShares();\n\n    /// @notice Thrown if `totalAssets` is zero during a withdraw\n    error ZeroTotalAssets();\n\n    /// @notice Thrown when the Liquidation Pair being set is the zero address.\n    error LPZeroAddress();\n\n    /// @notice Thrown when `sweep` is called but no underlying assets are currently held by the Vault.\n    error SweepZeroAssets();\n\n    /// @notice Thrown during the liquidation process when the liquidation amount out is zero.\n    error LiquidationAmountOutZero();\n\n    /// @notice Thrown during the liquidation process when the caller is not the liquidation pair contract.\n    /// @param caller The caller address\n    /// @param liquidationPair The LP address\n    error CallerNotLP(address caller, address liquidationPair);\n\n    /// @notice Thrown if the caller is not the yield fee recipient when withdrawing yield fee shares.\n    /// @param caller The caller address\n    /// @param yieldFeeRecipient The yield fee recipient address\n    error CallerNotYieldFeeRecipient(address caller, address yieldFeeRecipient);\n\n    /// @notice Thrown when the caller of a permit function is not the owner of the assets being permitted.\n    /// @param caller The address of the caller\n    /// @param owner The address of the owner\n    error PermitCallerNotOwner(address caller, address owner);\n\n    /// @notice Thrown when the yield fee percentage being set exceeds the max yield fee allowed.\n    /// @param yieldFeePercentage The yield fee percentage in integer format\n    /// @param maxYieldFeePercentage The max yield fee percentage in integer format\n    error YieldFeePercentageExceedsMax(uint256 yieldFeePercentage, uint256 maxYieldFeePercentage);\n\n    /// @notice Thrown when the yield fee shares being withdrawn exceeds the available yieldFee Balance.\n    /// @param shares The shares being withdrawn\n    /// @param yieldFeeBalance The available yield fee shares\n    error SharesExceedsYieldFeeBalance(uint256 shares, uint256 yieldFeeBalance);\n\n    /// @notice Thrown during the liquidation process when the token in is not the prize token.\n    /// @param tokenIn The provided tokenIn address\n    /// @param prizeToken The prize token address\n    error LiquidationTokenInNotPrizeToken(address tokenIn, address prizeToken);\n\n    /// @notice Thrown during the liquidation process when the token out is not supported.\n    /// @param tokenOut The provided tokenOut address\n    error LiquidationTokenOutNotSupported(address tokenOut);\n\n    /// @notice Thrown during the liquidation process if the total to withdraw is greater than the available yield.\n    /// @param totalToWithdraw The total yield to withdraw\n    /// @param availableYield The available yield\n    error LiquidationExceedsAvailable(uint256 totalToWithdraw, uint256 availableYield);\n\n    /// @notice Thrown when a deposit results in a state where the total assets are less than the total share supply.\n    /// @param totalAssets The total assets controlled by the vault\n    /// @param totalSupply The total shares minted and internally accounted for by the vault\n    error LossyDeposit(uint256 totalAssets, uint256 totalSupply);\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Modifiers\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Requires the caller to be the liquidation pair.\n    modifier onlyLiquidationPair() {\n        if (msg.sender != liquidationPair) {\n            revert CallerNotLP(msg.sender, liquidationPair);\n        }\n        _;\n    }\n\n    /// @notice Requires the caller to be the yield fee recipient.\n    modifier onlyYieldFeeRecipient() {\n        if (msg.sender != yieldFeeRecipient) {\n            revert CallerNotYieldFeeRecipient(msg.sender, yieldFeeRecipient);\n        }\n        _;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Constructor\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Vault constructor\n    /// @param name_ Name of the ERC20 share minted by the vault\n    /// @param symbol_ Symbol of the ERC20 share minted by the vault\n    /// @param yieldVault_ Address of the underlying ERC4626 vault in which assets are deposited to generate yield\n    /// @param prizePool_ Address of the PrizePool that computes prizes\n    /// @param claimer_ Address of the claimer\n    /// @param yieldFeeRecipient_ Address of the yield fee recipient\n    /// @param yieldFeePercentage_ Yield fee percentage\n    /// @param yieldBuffer_ Amount of yield to keep as a buffer\n    /// @param owner_ Address that will gain ownership of this contract\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        IERC4626 yieldVault_,\n        PrizePool prizePool_,\n        address claimer_,\n        address yieldFeeRecipient_,\n        uint32 yieldFeePercentage_,\n        uint256 yieldBuffer_,\n        address owner_\n    ) TwabERC20(name_, symbol_, prizePool_.twabController()) Claimable(prizePool_, claimer_) Ownable(owner_) {\n        if (address(yieldVault_) == address(0)) revert YieldVaultZeroAddress();\n        if (owner_ == address(0)) revert OwnerZeroAddress();\n\n        IERC20 asset_ = IERC20(yieldVault_.asset());\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n\n        yieldVault = yieldVault_;\n        yieldBuffer = yieldBuffer_;\n\n        _setYieldFeeRecipient(yieldFeeRecipient_);\n        _setYieldFeePercentage(yieldFeePercentage_);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ERC20 Overrides\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IERC20Metadata\n    function decimals() public view override(ERC20, IERC20Metadata) returns (uint8) {\n        return _underlyingDecimals;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ERC4626 Implementation\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IERC4626\n    function asset() external view returns (address) {\n        return address(_asset);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev The latent asset balance is included in the total asset count to account for the \"dust collection\n    /// strategy\".\n    function totalAssets() public view returns (uint256) {\n        return yieldVault.convertToAssets(yieldVault.balanceOf(address(this))) + _asset.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 _assets) public view returns (uint256) {\n        uint256 totalDebt_ = totalDebt();\n        uint256 _totalAssets = totalAssets();\n        if (_totalAssets >= totalDebt_) {\n            return _assets;\n        } else {\n            // If the vault controls less assets than what has been deposited a share will be worth a\n            // proportional amount of the total assets. This can happen due to fees, slippage, or loss\n            // of funds in the underlying yield vault.\n            return _assets.mulDiv(totalDebt_, _totalAssets, Math.Rounding.Down);\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 _shares) public view returns (uint256) {\n        uint256 totalDebt_ = totalDebt();\n        uint256 _totalAssets = totalAssets();\n        if (_totalAssets >= totalDebt_) {\n            return _shares;\n        } else {\n            // If the vault controls less assets than what has been deposited a share will be worth a\n            // proportional amount of the total assets. This can happen due to fees, slippage, or loss\n            // of funds in the underlying yield vault.\n            return _shares.mulDiv(_totalAssets, totalDebt_, Math.Rounding.Down);\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Considers the uint96 limit on total share supply in the TwabController\n    /// @dev Returns zero if any deposit would result in a loss of assets\n    /// @dev Any latent balance of assets in the prize vault will be swept in with the deposit as a part of\n    /// the \"dust collection strategy\". This means that the max deposit must account for the latent balance\n    /// by subtracting it from the max deposit available otherwise.\n    function maxDeposit(address) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        uint256 totalDebt_ = _totalDebt(_totalSupply);\n        if (totalAssets() < totalDebt_) return 0;\n\n        // the vault will never mint more than 1 share per asset, so no need to convert supply limit to assets\n        uint256 twabSupplyLimit_ = _twabSupplyLimit(_totalSupply);\n        uint256 _maxDeposit;\n        uint256 _latentBalance = _asset.balanceOf(address(this));\n        uint256 _maxYieldVaultDeposit = yieldVault.maxDeposit(address(this));\n        if (_latentBalance >= _maxYieldVaultDeposit) {\n            return 0;\n        } else {\n            unchecked {\n                _maxDeposit = _maxYieldVaultDeposit - _latentBalance;\n            }\n            return twabSupplyLimit_ < _maxDeposit ? twabSupplyLimit_ : _maxDeposit;\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Returns the same value as `maxDeposit` since shares and assets are 1:1 on mint\n    /// @dev Returns zero if any deposit would result in a loss of assets\n    function maxMint(address _owner) public view returns (uint256) {\n        return maxDeposit(_owner);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev The prize vault maintains a latent balance of assets as part of the \"dust collection strategy\".\n    /// This latent balance are accounted for in the max withdraw limits.\n    function maxWithdraw(address _owner) public view returns (uint256) {\n        uint256 _maxWithdraw = _maxYieldVaultWithdraw() + _asset.balanceOf(address(this));\n\n        // the owner may receive less than 1 asset per share, so we must convert their balance here\n        uint256 _ownerAssets = convertToAssets(balanceOf(_owner));\n        return _ownerAssets < _maxWithdraw ? _ownerAssets : _maxWithdraw;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev The prize vault maintains a latent balance of assets as part of the \"dust collection strategy\".\n    /// This latent balance are accounted for in the max redeem limits.\n    function maxRedeem(address _owner) public view returns (uint256) {\n        uint256 _maxWithdraw = _maxYieldVaultWithdraw() + _asset.balanceOf(address(this));\n        uint256 _ownerShares = balanceOf(_owner);\n\n        // The owner will never receive more than 1 asset per share, so there is no need to convert max\n        // withdraw to shares unless the owner has more shares than the max withdraw and is redeeming\n        // at a loss (when 1 share is worth less than 1 asset).\n        if (_ownerShares > _maxWithdraw) {\n            uint256 _totalAssets = totalAssets();\n            uint256 totalDebt_ = totalDebt();\n            if (_totalAssets >= totalDebt_) {\n                return _maxWithdraw;\n            } else {\n                // Convert to shares while rounding up. Since 1 asset is guaranteed to be worth more than\n                // 1 share and any upwards rounding will not exceed 1 share, we can be sure that when the\n                // shares are converted back to assets (rounding down) the resulting asset value won't\n                // exceed `_maxWithdraw`.\n                uint256 _maxScaledRedeem = _maxWithdraw.mulDiv(totalDebt_, _totalAssets, Math.Rounding.Up);\n                return _maxScaledRedeem >= _ownerShares ? _ownerShares : _maxScaledRedeem;\n            }\n        } else {\n            return _ownerShares;\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 _assets) public pure returns (uint256) {\n        // shares represent how many assets an account has deposited, so they are 1:1 on deposit\n        return _assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 _shares) public pure returns (uint256) {\n        // shares represent how many assets an account has deposited, so they are 1:1 on mint\n        return _shares;\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev Reverts if `totalAssets` in the vault is zero\n    function previewWithdraw(uint256 _assets) public view returns (uint256) {\n        uint256 _totalAssets = totalAssets();\n\n        // No withdrawals can occur if the vault controls no assets.\n        if (_totalAssets == 0) revert ZeroTotalAssets();\n\n        uint256 totalDebt_ = totalDebt();\n        if (_totalAssets >= totalDebt_) {\n            return _assets;\n        } else {\n            // Follows the inverse conversion of `convertToAssets`\n            return _assets.mulDiv(totalDebt_, _totalAssets, Math.Rounding.Up);\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 _shares) public view returns (uint256) {\n        return convertToAssets(_shares);\n    }\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 _assets, address _receiver) external returns (uint256) {\n        uint256 _shares = previewDeposit(_assets);\n        _depositAndMint(msg.sender, _receiver, _assets, _shares);\n        return _shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 _shares, address _receiver) external returns (uint256) {\n        uint256 _assets = previewMint(_shares);\n        _depositAndMint(msg.sender, _receiver, _assets, _shares);\n        return _assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(\n        uint256 _assets,\n        address _receiver,\n        address _owner\n    ) external returns (uint256) {\n        uint256 _shares = previewWithdraw(_assets);\n        _burnAndWithdraw(msg.sender, _receiver, _owner, _shares, _assets);\n        return _shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) external returns (uint256) {\n        uint256 _assets = previewRedeem(_shares);\n        _burnAndWithdraw(msg.sender, _receiver, _owner, _shares, _assets);\n        return _assets;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Additional Deposit Flows\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Approve underlying asset with permit, deposit into the Vault and mint Vault shares to `_owner`.\n    /// @dev Can't be used to deposit on behalf of another user since `permit` does not accept a receiver parameter,\n    /// meaning that anyone could reuse the signature and pass an arbitrary receiver to this function.\n    /// @param _assets Amount of assets to approve and deposit\n    /// @param _owner Address of the owner depositing `_assets` and signing the permit\n    /// @param _deadline Timestamp after which the approval is no longer valid\n    /// @param _v V part of the secp256k1 signature\n    /// @param _r R part of the secp256k1 signature\n    /// @param _s S part of the secp256k1 signature\n    /// @return Amount of Vault shares minted to `_owner`.\n    function depositWithPermit(\n        uint256 _assets,\n        address _owner,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256) {\n        if (_owner != msg.sender) {\n            revert PermitCallerNotOwner(msg.sender, _owner);\n        }\n\n        // Skip the permit call if the allowance has already been set to exactly what is needed. This prevents\n        // griefing attacks where the signature is used by another actor to complete the permit before this\n        // function is executed.\n        if (_asset.allowance(_owner, address(this)) != _assets) {\n            IERC20Permit(address(_asset)).permit(_owner, address(this), _assets, _deadline, _v, _r, _s);\n        }\n\n        uint256 _shares = previewDeposit(_assets);\n        _depositAndMint(_owner, _owner, _assets, _shares);\n        return _shares;\n    }\n\n    /// @notice Deposit assets into the Vault and delegate to the sponsorship address.\n    /// @dev Emits a `Sponsor` event\n    /// @param _assets Amount of assets to deposit\n    /// @return Amount of shares minted to caller.\n    function sponsor(uint256 _assets) external returns (uint256) {\n        address _owner = msg.sender;\n\n        uint256 _shares = previewDeposit(_assets);\n        _depositAndMint(_owner, _owner, _assets, _shares);\n\n        if (twabController.delegateOf(address(this), _owner) != SPONSORSHIP_ADDRESS) {\n            twabController.sponsor(_owner);\n        }\n\n        emit Sponsor(_owner, _assets, _shares);\n\n        return _shares;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Additional Accounting\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Returns the total assets that are owed to share holders and any other internal balances.\n    /// @return The total asset debt of the vault\n    function totalDebt() public view returns (uint256) {\n        return _totalDebt(totalSupply());\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Yield Functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Total yield balance of the vault\n    /// @dev Equal to total assets minus total debt\n    /// @return The total yield balance\n    function totalYieldBalance() public view returns (uint256) {\n        return _totalYieldBalance(totalAssets(), totalDebt());\n    }\n\n    /// @notice Total available yield on the vault\n    /// @dev Equal to total assets minus total allocation (total debt + yield buffer)\n    /// @return The available yield balance\n    function availableYieldBalance() public view returns (uint256) {\n        return _availableYieldBalance(totalAssets(), totalDebt());\n    }\n\n    /// @notice Current amount of assets available in the yield buffer\n    /// @return The available assets in the yield buffer\n    function currentYieldBuffer() external view returns (uint256) {\n        uint256 totalYieldBalance_ = _totalYieldBalance(totalAssets(), totalDebt());\n        uint256 _yieldBuffer = yieldBuffer;\n        if (totalYieldBalance_ >= _yieldBuffer) {\n            return _yieldBuffer;\n        } else {\n            return totalYieldBalance_;\n        }\n    }\n\n    /// @notice Transfers yield fee shares to the yield fee recipient\n    /// @param _shares The shares to mint to the yield fee recipient\n    /// @dev Emits a `ClaimYieldFeeShares` event\n    /// @dev Will revert if the caller is not the yield fee recipient or if zero shares are withdrawn\n    function claimYieldFeeShares(uint256 _shares) external onlyYieldFeeRecipient {\n        if (_shares == 0) revert MintZeroShares();\n\n        uint256 _yieldFeeBalance = yieldFeeBalance;\n        if (_shares > _yieldFeeBalance) revert SharesExceedsYieldFeeBalance(_shares, _yieldFeeBalance);\n\n        yieldFeeBalance -= _yieldFeeBalance;\n\n        _mint(msg.sender, _shares);\n\n        emit ClaimYieldFeeShares(msg.sender, _shares);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // LiquidationSource Functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc ILiquidationSource\n    /// @dev Returns the liquid amount of `_tokenOut` minus any yield fees.\n    /// @dev Supports the liquidation of either assets or prize vault shares.\n    function liquidatableBalanceOf(address _tokenOut) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        uint256 _maxAmountOut;\n        if (_tokenOut == address(this)) {\n            // Liquidation of vault shares is capped to the TWAB supply limit.\n            _maxAmountOut = _twabSupplyLimit(_totalSupply);\n        } else if (_tokenOut == address(_asset)) {\n            // Liquidation of yield assets is capped at the max yield vault withdraw plus any latent balance.\n            _maxAmountOut = _maxYieldVaultWithdraw() + _asset.balanceOf(address(this));\n        } else {\n            return 0;\n        }\n\n        // The liquid yield is computed by taking the available yield balance and multiplying it\n        // by (1 - yieldFeePercentage), rounding down, to ensure that enough yield is left for the\n        // yield fee.\n        uint256 _liquidYield = \n            _availableYieldBalance(totalAssets(), _totalDebt(_totalSupply))\n            .mulDiv(FEE_PRECISION - yieldFeePercentage, FEE_PRECISION);\n\n        // The liquid yield is limited by the max that can be minted or withdrawn, depending on\n        // `_tokenOut`.\n        return _liquidYield >= _maxAmountOut ? _maxAmountOut : _liquidYield;\n    }\n\n    /// @inheritdoc ILiquidationSource\n    /// @dev Emits a `TransferYieldOut` event\n    /// @dev Supports the liquidation of either assets or prize vault shares.\n    function transferTokensOut(\n        address,\n        address _receiver,\n        address _tokenOut,\n        uint256 _amountOut\n    ) p"
    }
  ]
}