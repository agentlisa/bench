{
  "Title": "M-8: ConvexSpell is completely broken for any curve LP that utilizes native ETH",
  "Content": "# Issue M-8: ConvexSpell is completely broken for any curve LP that utilizes native ETH \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/105 \n\n## Found by \n0x52, 0xjoseph\n\nWhen a Curve pool utilizes native ETH it uses the address `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`. This is problematic because it will try to call balanceOf on this address which will always revert.\n\n## Vulnerability Detail\n\n[ConvexSpell.sol#L120-L127](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L120-L127)\n\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i; i != 2; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n\nConvexSpell#openPositionFarm attempts to call balanceOf on each component of the LP. Since native ETH uses the `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee` this call will always revert. This breaks compatibility with EVERY curve pool that uses native ETH which make most of the highest volume pools on the platfrom.\n\n## Impact\n\nConvexSpell is completely incompatible with a majority of Curve pools\n\n## Code Snippet\n\n[ConvexSpell.sol#L92-L173](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L92-L173)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI would recommend conversion between native ETH and wETH to prevent this issue.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because the design of the protocol does not show desire for ETH compatibility so the issue can be classified as informational\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/ConvexSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title ConvexSpell\n/// @author BlueberryProtocol\n/// @notice This contract serves as the factory for defining how the Blueberry Protocol \n///         interacts with Convex pools. It handles strategies, interactions with external contracts, \n///         and facilitates operations related to liquidity provision.\ncontract ConvexSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address of the Wrapped Convex Pools\n    IWConvexPools public wConvexPools;\n    /// @dev address of CurveOracle to retrieve pool information\n    ICurveOracle public crvOracle;\n    /// @dev address of CVX token\n    address public CVX;\n\n    /// @dev paraswap AugustusSwapper address for token swaps\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy address for efficient token transfers\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n        \n    /// @notice Initializes the ConvexSpell contract with required parameters.\n    /// @param bank_ Address of the bank contract.\n    /// @param werc20_ Address of the wrapped ERC20 contract.\n    /// @param weth_ Address of the wrapped Ethereum contract.\n    /// @param wConvexPools_ Address of the wrapped Convex pools contract.\n    /// @param crvOracle_ Address of the Curve Oracle contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wConvexPools_,\n        address crvOracle_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wConvexPools_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wConvexPools = IWConvexPools(wConvexPools_);\n        CVX = address(wConvexPools.CVX());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWConvexPools(wConvexPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Adds a new strategy to the spell.\n    /// @param crvLp Address of the Curve LP token for the strategy.\n    /// @param minPosSize Minimum position size in USD for the strategy (with 1e18 precision).\n    /// @param maxPosSize Maximum position size in USD for the strategy (with 1e18 precision).\n    function addStrategy(\n        address crvLp,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(crvLp, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Curve pool with two underlying tokens and stakes in Curve gauge.\n    /// @param param Struct containing all required parameters for opening a position.\n    /// @param minLPMint Minimum LP tokens expected to mint for slippage control.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        (address lpToken, , , , , ) = wConvexPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        /// 3. Add liquidity on curve, get crvLp\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            lpToken\n        );\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i; i != 2; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i; i != 3; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i; i != 4; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        /// 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Validate Max Pos Size\n        _validatePosSize(param.strategyId);\n        /// 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wConvexPools.burn(pos.collId, pos.collateralSize);\n            // distribute multiple rewards to users\n            uint256 tokensLength = rewardTokens.length;\n            for (uint256 i; i != tokensLength; ++i) {\n                _doRefundRewards(rewardTokens[i]);\n            }\n        }\n\n        /// 7. Deposit on Convex Pool, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wConvexPools), lpAmount);\n        uint256 id = wConvexPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wConvexPools), id, lpAmount);\n    }\n\n    /// @notice Closes an existing liquidity position, unstakes from Curve gauge, and swaps rewards.\n    /// @param param Struct containing all required parameters for closing a position.\n    /// @param expectedRewards List of expected reward amounts for each token.\n    /// @param swapDatas Swap data for each reward token.\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wConvexPools))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wConvexPools.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        uint256 amountPosRemove = param.amountPosRemove;\n\n        /// 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(amountPosRemove);\n        (address[] memory rewardTokens, ) = wConvexPools.burn(\n            pos.collId,\n            amountPosRemove\n        );\n\n        /// 2. Swap rewards tokens to debt token\n        _sellRewards(rewardTokens, expectedRewards, swapDatas);\n\n        /// 3. Remove liquidity\n        _removeLiquidity(param, pos, crvLp, amountPosRemove);\n\n        /// 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 5. Repay\n        {\n            /// Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        /// 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(CVX);\n    }\n\n    /// @dev Removes liquidity from a Curve pool for a given position.\n    /// @param param Contains data required to close the position.\n    /// @param pos Data structure representing the current bank position.\n    /// @param crvLp Address of the Curve LP token.\n    /// @param amountPosRemove Amount of LP tokens to be removed from the pool. \n    ///        If set to max, will remove all available LP tokens.\n    function _removeLiquidity(\n        ClosePosParam memory param,\n        IBank.Position memory pos,\n        address crvLp,\n        uint256 amountPosRemove\n    ) internal {\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            crvLp\n        );\n\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = IERC20Upgradeable(crvLp).balanceOf(address(this));\n        }\n\n        int128 tokenIndex;\n        uint256 tokensLength = tokens.length;\n        for (uint256 i; i != tokensLength; ++i) {\n            if (tokens[i] == pos.debtToken) {\n                tokenIndex = int128(uint128(i));\n                break;\n            }\n        }\n\n        /// Removes liquidity from the Curve pool for the specified token.\n        ICurvePool(pool).remove_liquidity_one_coin(\n            amountPosRemove,\n            int128(tokenIndex),\n            param.amountOutMin\n        );\n    }\n\n    /// @dev Internal function Sells the accumulated reward tokens.\n    /// @param rewardTokens An array of addresses of the reward tokens to be sold.\n    /// @param expectedRewards Array containing the expected amounts of each reward token.\n    /// @param swapDatas Data required for performing the swaps.\n    function _sellRewards(\n        address[] memory rewardTokens,\n        uint[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    ) internal {\n        uint256 tokensLength = rewardTokens.length;\n        for (uint256 i; i != tokensLength; ++i) {\n            address sellToken = rewardTokens[i];\n\n            /// Apply any potential fees on the reward.\n            _doCutRewardsFee(sellToken);\n\n            uint expectedReward = expectedRewards[i];\n            /// If the expected reward is zero, skip to the next token.\n            if (expectedReward == 0) continue;\n            /// Swap the reward token for another desired token. If the swap fails, revert with an error.\n            if (\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedReward,\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n            /// Refund any leftover (dust) amounts after the swap to the contract owner\n            _doRefund(sellToken);\n        }\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/ConvexSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title ConvexSpell\n/// @author BlueberryProtocol\n/// @notice This contract serves as the factory for defining how the Blueberry Protocol \n///         interacts with Convex pools. It handles strategies, interactions with external contracts, \n///         and facilitates operations related to liquidity provision.\ncontract ConvexSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address of the Wrapped Convex Pools\n    IWConvexPools public wConvexPools;\n    /// @dev address of CurveOracle to retrieve pool information\n    ICurveOracle public crvOracle;\n    /// @dev address of CVX token\n    address public CVX;\n\n    /// @dev paraswap AugustusSwapper address for token swaps\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy address for efficient token transfers\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n        \n    /// @notice Initializes the ConvexSpell contract with required parameters.\n    /// @param bank_ Address of the bank contract.\n    /// @param werc20_ Address of the wrapped ERC20 contract.\n    /// @param weth_ Address of the wrapped Ethereum contract.\n    /// @param wConvexPools_ Address of the wrapped Convex pools contract.\n    /// @param crvOracle_ Address of the Curve Oracle contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wConvexPools_,\n        address crvOracle_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wConvexPools_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wConvexPools = IWConvexPools(wConvexPools_);\n        CVX = address(wConvexPools.CVX());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWConvexPools(wConvexPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Adds a new strategy to the spell.\n    /// @param crvLp Address of the Curve LP token for the strategy.\n    /// @param minPosSize Minimum position size in USD for the strategy (with 1e18 precision).\n    /// @param maxPosSize Maximum position size in USD for the strategy (with 1e18 precision).\n    function addStrategy(\n        address crvLp,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(crvLp, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Curve pool with two underlying tokens and stakes in Curve gauge.\n    /// @param param Struct containing all required parameters for opening a position.\n    /// @param minLPMint Minimum LP tokens expected to mint for slippage control.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        (address lpToken, , , , , ) = wConvexPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        /// 3. Add liquidity on curve, get crvLp\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            lpToken\n        );\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i; i != 2; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i; i != 3; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i; i != 4; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        /// 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Validate Max Pos Size\n        _validatePosSize(param.strategyId);\n        /// 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wConvexPools.burn(pos.collId, pos.collateralSize);\n            // distribute multiple rewards to users\n            uint256 tokensLength = rewardTokens.length;\n            for (uint256 i; i != tokensLength; ++i) {\n                _doRefundRewards(rewardTokens[i]);\n            }\n        }\n\n        /// 7. Deposit on Convex Pool, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wConvexPools), lpAmount);\n        uint256 id = wConvexPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wConvexPools), id, lpAmount);\n    }\n\n    /// @notice Closes an existing liquidity position, unstakes from Curve gauge, and swaps rewards.\n    /// @param param Struct containing all required parameters for closing a position.\n    /// @param expectedRewards List of expected reward amounts for each token.\n    /// @param swapDatas Swap data for each reward token.\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wConvexPools))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wConvexPools.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        uint256 amountPosRemove = param.amountPosRemove;\n\n        /// 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(amountPosRemove);\n        (address[] memory rewardTokens, ) = wConvexPools.burn(\n            pos.collId,\n            amountPosRemove\n        );\n\n        /// 2. Swap rewards tokens to debt token\n        _sellRewards(rewardTokens, expectedRewards, swapDatas);\n\n        /// 3. Remove liquidity\n        _removeLiquidity(param, pos, crvLp, amountPosRemove);\n\n        /// 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 5. Repay\n        {\n            /// Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        /// 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(CVX);\n    }\n\n    /// @dev Removes liquidity from a Curve pool for a given position.\n    /// @param param Contains data required to close the position.\n    /// @param pos Data structure representing the current bank position.\n    /// @param crvLp Address of the Curve LP token.\n    /// @param amountPosRemove Amount of LP tokens to be removed from the pool. \n    ///        If set to max, will remove all available LP tokens.\n    function _removeLiquidity(\n        ClosePosParam memory param,\n        IBank.Position memory pos,\n        address crvLp,\n        uint256 amountPosRemove\n    ) internal {\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            crvLp\n        );\n\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = IERC20Upgradeable(crvLp).balanceOf(address(this));\n        }\n\n        int128 tokenIndex;\n        uint256 tokensLength = tokens.length;\n        for (uint256 i; i != tokensLength; ++i) {\n            if (tokens[i] == pos.debtToken) {\n                tokenIndex = int128(uint128(i));\n                break;\n            }\n        }\n\n        /// Removes liquidity from the Curve pool for the specified token.\n        ICurvePool(pool).remove_liquidity_one_coin(\n            amountPosRemove,\n            int128(tokenIndex),\n            param.amountOutMin\n        );\n    }\n\n    /// @dev Internal function Sells the accumulated reward tokens.\n    /// @param rewardTokens An array of addresses of the reward tokens to be sold.\n    /// @param expectedRewards Array containing the expected amounts of each reward token.\n    /// @param swapDatas Data required for performing the swaps.\n    function _sellRewards(\n        address[] memory rewardTokens,\n        uint[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    ) internal {\n        uint256 tokensLength = rewardTokens.length;\n        for (uint256 i; i != tokensLength; ++i) {\n            address sellToken = rewardTokens[i];\n\n            /// Apply any potential fees on the reward.\n            _doCutRewardsFee(sellToken);\n\n            uint expectedReward = expectedRewards[i];\n            /// If the expected reward is zero, skip to the next token.\n            if (expectedReward == 0) continue;\n            /// Swap the reward token for another desired token. If the swap fails, revert with an error.\n            if (\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedReward,\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n            /// Refund any leftover (dust) amounts after the swap to the contract owner\n            _doRefund(sellToken);\n        }\n    }\n}"
    }
  ]
}