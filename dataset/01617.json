{
  "Title": "M-5: Any user can avoid paying most of the protocol fees on short positions, and can unknowingly pay very high fee on long positions",
  "Content": "# Issue M-5: Any user can avoid paying most of the protocol fees on short positions, and can unknowingly pay very high fee on long positions \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/139 \n\n## Found by \npanprog\n## Summary\n\nProtocol fee paid by the user for LIMIT orders is calculated based on the LIMIT `price` provided by the user. For short positions, a very low LIMIT `price` allows to basically open short position close to MARKET order (using current market price). However, the fee paid will be based on very low LIMIT `price`, which is far below current market price, allowing the user to pay very low fee (close to 0), which is the funds lost by the protocol (the user steals his fee from the protocol).\n\nFor long positions, if the LIMIT `price` provided is very high (which basically equals a MARKET long order), the user will unknowningly overpay the fee due to the same bug.\n\n## Vulnerability Detail\n\nFor LIMIT orders, the protocol fee user pays is calculated as percentage of `quantity * requestedOpenPrice`, which is a price provided by the user in the quote.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L126-L130\n\nFor short positions, a user can provide very low price (for example, if current ETH price is $1000, user can provide $1) and be charged a very low fee ($0.01 instead of $10). Since the provided price is very low, the order will basically be equal to MARKET order. This allows users to avoid paying the protocol fee, which is a loss of fees funds for the protocol.\n\nFor long positions, if a user uses a high limit price (which basically equals long MARKET order), he will unknowingly pay very large fee (for example, if current ETH price is $1000, user provides a $10000 LIMIT price, paying $100 fee instead of $10). This is a loss of funds for the user, which he didn't expect to pay.\n\n## Impact\n\nFor short positions, users can avoid paying protocol fees for opened positions, resulting in protocol fee loss.\n\nFor long positions, users can pay very large fee, resulting in user funds loss.\n\n## Code Snippet\n\nAdd this to any test, for example to `ClosePosition.behavior.ts`\n\n```ts\n  it(\"1. Paying very low fees\", async function () {\n    const context: RunContext = this.context;\n\n    this.user_allocated = decimal(500);\n    this.hedger_allocated = decimal(4000);\n\n    this.user = new User(this.context, this.context.signers.user);\n    await this.user.setup();\n    await this.user.setBalances(this.user_allocated, this.user_allocated, this.user_allocated);\n\n    this.hedger = new Hedger(this.context, this.context.signers.hedger);\n    await this.hedger.setup();\n    await this.hedger.setBalances(this.hedger_allocated, this.hedger_allocated);\n\n    // Quote1 SHORT opened\n    await this.user.sendQuote(limitQuoteRequestBuilder().positionType(PositionType.SHORT).quantity(decimal(500)).build());\n    await this.hedger.lockQuote(1);\n    await this.hedger.openPosition(1, limitOpenRequestBuilder().filledAmount(decimal(500)).build());\n\n    var feeCollectorAddress = await context.viewFacet.getFeeCollector();\n    var feeBalance = await context.viewFacet.balanceOf(feeCollectorAddress);\n\n    console.log(\"Fee collected (LIMIT SHORT 500 @ 1.0, filled at 1.0): \" + feeBalance/1e18);\n\n    // Quote2 SHORT opened\n    await this.user.sendQuote(limitQuoteRequestBuilder().positionType(PositionType.SHORT).quantity(decimal(500)).price(decimal(2, 17)).build());\n    await this.hedger.lockQuote(2);\n    await this.hedger.openPosition(2, limitOpenRequestBuilder().filledAmount(decimal(500)).build());\n\n    feeBalance = await context.viewFacet.balanceOf(feeCollectorAddress) - feeBalance;\n\n    console.log(\"Fee collected (LIMIT SHORT 500 @ 0.2, filled at 1.0): \" + feeBalance/1e18);\n\n  });\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere are a couple of options depending on team preference:\n\n1. Always calculate fee based on market price (`quote.marketPrice`), both for MARKET and LIMIT orders. Upside is very easy fix, downside is that for LIMIT orders which are on the market for a long time (aiming for prices away from current market), the fees will be wrong (the market price at openPosition time can be very different from the price at the sendQuote time).\n\n2. The fee should be taken based on actual position openPrice (at the time of opening the position), rather than any price at the sendQuote time. Upside is completely correct fees in any conditions, downside is more difficult fix (and slight differences from the preliminary fees paid at sendQuote time). It will require returning the fees before opening a position, and taking it again (but based on openPrice) after the position is opened.\n\n\n\n## Discussion\n\n**panprog**\n\nEscalate\n\nThis is at least a valid medium. If long quote is opened with very high limit price, but is executed at the current market price, then fee is taken using user-specified limit price, not the execution price. For example:\n\n1. ETH is trading at about $1000, fee is 1%\n2. PartyA send a quote long 1 ETH at LIMIT `price = $100000`, the fee locked is `1 * $100000 * 1% = $1000`\n3. PartyB locks the quote and opens position with the current market price ($1000). \n4. Fee taken is $1000 instead of expected $10, which is an unexpected loss of funds for the PartyA\n\nIt can be argued that user sending a long quote with LIMIT `price = $100000` risks having his position opened at this extremely high price, however this is still possible (so a valid scenario, even if not very likely) and this also requires partyB to act maliciously risking its reputation (a fair partyB should open positions with its market price, not with the best price it can get). If partyB behaves this way, it risks being banned from the platform or users starting to blacklist it (or rather not including in whitelist in the current implementation) due to such story getting public attention.\n\nAdditionally, #225 is a valid medium with a very similar requirement (user specifying very low LIMIT price), but a different core reason and impact.\n\nDue to the scenario of user losing significant amount possible (even if not very likely), this should be at least a valid medium.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is at least a valid medium. If long quote is opened with very high limit price, but is executed at the current market price, then fee is taken using user-specified limit price, not the execution price. For example:\n> \n> 1. ETH is trading at about $1000, fee is 1%\n> 2. PartyA send a quote long 1 ETH at LIMIT `price = $100000`, the fee locked is `1 * $100000 * 1% = $1000`\n> 3. PartyB locks the quote and opens position with the current market price ($1000). \n> 4. Fee taken is $1000 instead of expected $10, which is an unexpected loss of funds for the PartyA\n> \n> It can be argued that user sending a long quote with LIMIT `price = $100000` risks having his position opened at this extremely high price, however this is still possible (so a valid scenario, even if not very likely) and this also requires partyB to act maliciously risking its reputation (a fair partyB should open positions with its market price, not with the best price it can get). If partyB behaves this way, it risks being banned from the platform or users starting to blacklist it (or rather not including in whitelist in the current implementation) due to such story getting public attention.\n> \n> Additionally, #225 is a valid medium with a very similar requirement (user specifying very low LIMIT price), but a different core reason and impact.\n> \n> Due to the scenario of user losing significant amount possible (even if not very likely), this should be at least a valid medium.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**MoonKnightDev**\n\nThis isn't a bug. It's not a free workaround that users can employ to pay less in fees. In fact, by doing this, they are taking a substantial risk. We cannot guarantee that Party B will open the position at the market price. Consequently, Party B could open that short position at the lowest possible price, potentially causing the user to suffer a significant loss.\n\n**panprog**\n\n> This isn't a bug. It's not a free workaround that users can employ to pay less in fees. In fact, by doing this, they are taking a substantial risk. We cannot guarantee that Party B will open the position at the market price. Consequently, Party B could open that short position at the lowest possible price, potentially causing the user to suffer a significant loss.\n\nI agree that not paying fee is connected with a high risk, although this is still possible, like some partyB can let people pay less fees this way by promising to fill them at market price if they specify a LIMIT price close to 0.\n\nIt is, however, possible for the user to unexpectedly pay substantially more in fees (for long position with limit price much higher than market) than he should like in example in [previous comment](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/139#issuecomment-1653754477). Yes, he risks being filled at that inflated price, but if he's filled at the market price (which *can* happen, not all partyBs will fill at the price very far from the market), the fees will still be paid from the limit price, so he'll pay much higher fees than he should, effectively protocol will steal a large amount from user. Yes, not very likely, but possible, so should be valid medium.\n\nAlso, I want to repeat that #225 is a valid medium and the requirements for it to happen are the same.\n\n**Evert0x**\n\n> 1. ETH is trading at about $1000, fee is 1%\n> 2. PartyA send a quote long 1 ETH at LIMIT `price = $100000`, the fee locked is `1 * $100000 * 1% = $1000`\n> 3. PartyB locks the quote and opens position with the current market price ($1000).\n> 4. Fee taken is $1000 instead of expected $10, which is an unexpected loss of funds for the PartyA\n\n@panprog why is this an unexpected loss for PartyA? It is a known fact the fee will be $1000 at step 2), right?\n\n\n**panprog**\n\n> @panprog why is this an unexpected loss for PartyA? It is a known fact the fee will be $1000 at step 2), right?\n\nThe fee is 1% of **notional**. Notional = size * price. Position is opened at a price = $1000, so Notional = 1 * 1000 = $1000. So the fee should be $1000 * 1% = $10.\n**IF** the quote was executed at the requested price of $100000, then yes, notional would be $100000 and fee would be $1000.\n\nBut the quote was opened at a price of $1000. Why does the protocol charge such high fee (equal to position notional) when the real position notional is just $1000? The fact that user requested a price $100000 doesn't mean that protocol should charge the fee off this price regardless of real open price.\n\nAnother example: imagine you open long 1 ETH position at a LIMIT price of $1.000.000 at Binance. Since the orderbook is deep, you get executed close to current price of $1000, so a notional of $1000. The fee (0.1%) would be $1. Do you **expect** that binance will charge you off $1.000.000 notional for a fee of $1000 just because you specified LIMIT price of $1.000.000?\n\n**panprog**\n\nFor comparison, if the user requested a price of $100.000 with a MARKET order, but is filled at the current price of $1000, he's charged a $10 fee, not $1000, although it's also possible that he's filled at the requested price of $100.000. So why charge $10 for a MARKET order, but $1000 for the same LIMIT order?\n\nAnd regarding - if it's a **known fact** that fee is $1000 for such LIMIT order. I don't think it's specified anywhere, but it's just common sense and how all the other protocols work - charging fee based on **actual** executed price, not based on **requested** price.\n\n**panprog**\n\nIf you mean that the fee is already taken at the sendQuote time, this is preliminary fee based on the current data and it can change. For example, if quote is canceled, the fee is refunded. So I don't think that preliminary fee can serve as a \"known fact\" of the final fee. As a user, I'd expect the fee to be refunded if quote is canceled, and the fee to be adjusted if the actual price differs from the requested one, like the locked values are adjusted. \n\n**hrishibhat**\n\nSponsor comment:\n>  when someone places a short limit order at a low price, they indeed pay reduced fees. However, they also accept the potential risk of unfavorable opening prices for their position. Ideally, fees should be charged at the position's opening, but due to certain complexities, we plan to implement this in upcoming versions.\n\n**panprog**\n\nAs I understand, sponsor confirms this is a valid issue. I want to note that the report talks both about lower or higher fees (although POC supplied is about lower fees):\n1. For SHORT quotes, partyA will pay reduced fees (loss of funds for the protocol)\n2. For LONG quotes, partyA will pay inflated fees (loss of funds for the user)\n\nWhile the sponsor only mentions the 1st impact (user can pay lower fees), I think the higher impact is the 2nd, where user pays inflated fees, which can be orders of magnitude higher than the user should pay. And the fact that the users bears the risk of unfavorable opening prices shouldn't influence the validity of this issue.\nStill, I think both impacts make this a valid medium.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nAfter reviewing the comments above and further discussion, agree with the points in the escalation, considering this issue a valid medium although unlikely there are situations where this would have an impact.  \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [panprog](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/139/#issuecomment-1653754477): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/libraries/LibQuote.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"./LibLockedValues.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\nimport \"../storages/GlobalAppStorage.sol\";\nimport \"../storages/SymbolStorage.sol\";\nimport \"../storages/MAStorage.sol\";\n\nlibrary LibQuote {\n    using LockedValuesOps for LockedValues;\n\n    function getAmountToLockOfQuote(Quote storage quote) internal view returns (uint256) {\n        return quote.lockedValues.total();\n    }\n\n    function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n        return quote.quantity - quote.closedAmount;\n    }\n\n    function getIndexOfItem(\n        uint256[] storage array_,\n        uint256 item\n    ) internal view returns (uint256) {\n        for (uint256 index = 0; index < array_.length; index++) {\n            if (array_[index] == item) return index;\n        }\n        return type(uint256).max;\n    }\n\n    function removeFromArray(uint256[] storage array_, uint256 item) internal {\n        uint256 index = getIndexOfItem(array_, item);\n        require(index != type(uint256).max, \"LibQuote: Item not Found\");\n        array_[index] = array_[array_.length - 1];\n        array_.pop();\n    }\n\n    function removeFromPartyAPendingQuotes(Quote storage quote) internal {\n        removeFromArray(QuoteStorage.layout().partyAPendingQuotes[quote.partyA], quote.id);\n    }\n\n    function removeFromPartyBPendingQuotes(Quote storage quote) internal {\n        removeFromArray(\n            QuoteStorage.layout().partyBPendingQuotes[quote.partyB][quote.partyA],\n            quote.id\n        );\n    }\n\n    function removeFromPendingQuotes(Quote storage quote) internal {\n        removeFromPartyAPendingQuotes(quote);\n        removeFromPartyBPendingQuotes(quote);\n    }\n\n    function addToOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n\n        quoteLayout.partyAOpenPositions[quote.partyA].push(quote.id);\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].push(quote.id);\n\n        quoteLayout.partyAPositionsIndex[quote.id] = quoteLayout.partyAPositionsCount[quote.partyA];\n        quoteLayout.partyBPositionsIndex[quote.id] = quoteLayout.partyBPositionsCount[quote.partyB][\n            quote.partyA\n        ];\n\n        quoteLayout.partyAPositionsCount[quote.partyA] += 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] += 1;\n    }\n\n    function removeFromOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        uint256 indexOfPartyAPosition = quoteLayout.partyAPositionsIndex[quote.id];\n        uint256 indexOfPartyBPosition = quoteLayout.partyBPositionsIndex[quote.id];\n        uint256 lastOpenPositionIndex = quoteLayout.partyAPositionsCount[quote.partyA] - 1;\n        quoteLayout.partyAOpenPositions[quote.partyA][indexOfPartyAPosition] = quoteLayout\n            .partyAOpenPositions[quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyAPositionsIndex[\n            quoteLayout.partyAOpenPositions[quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyAPosition;\n        quoteLayout.partyAOpenPositions[quote.partyA].pop();\n\n        lastOpenPositionIndex = quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] - 1;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][\n            indexOfPartyBPosition\n        ] = quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyBPositionsIndex[\n            quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyBPosition;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].pop();\n\n        quoteLayout.partyAPositionsIndex[quote.id] = 0;\n        quoteLayout.partyBPositionsIndex[quote.id] = 0;\n    }\n\n    function getValueOfQuoteForPartyA(\n        uint256 currentPrice,\n        uint256 filledAmount,\n        Quote storage quote\n    ) internal view returns (bool hasMadeProfit, uint256 pnl) {\n        if (currentPrice > quote.openedPrice) {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = true;\n            } else {\n                hasMadeProfit = false;\n            }\n            pnl = ((currentPrice - quote.openedPrice) * filledAmount) / 1e18;\n        } else {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = false;\n            } else {\n                hasMadeProfit = true;\n            }\n            pnl = ((quote.openedPrice - currentPrice) * filledAmount) / 1e18;\n        }\n    }\n\n    function getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        Symbol storage symbol = SymbolStorage.layout().symbols[quote.symbolId];\n        if (quote.orderType == OrderType.LIMIT) {\n            fee =\n                (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * symbol.tradingFee) /\n                1e36;\n        } else {\n            fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * symbol.tradingFee) / 1e36;\n        }\n    }\n\n    function returnTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] += tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] -= tradingFee;\n    }\n\n    function receiveTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] -= tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] += tradingFee;\n    }\n\n    function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        quote.modifyTimestamp = block.timestamp;\n\n        LockedValues memory lockedValues = LockedValues(\n            quote.lockedValues.cva -\n                ((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.mm -\n                ((quote.lockedValues.mm * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.lf -\n                ((quote.lockedValues.lf * filledAmount) / (LibQuote.quoteOpenAmount(quote)))\n        );\n        accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n        accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(\n            lockedValues\n        );\n        quote.lockedValues = lockedValues;\n\n        (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(\n            closedPrice,\n            filledAmount,\n            quote\n        );\n        if (hasMadeProfit) {\n            accountLayout.allocatedBalances[quote.partyA] += pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n        } else {\n            accountLayout.allocatedBalances[quote.partyA] -= pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n        }\n\n        quote.avgClosedPrice =\n            (quote.avgClosedPrice * quote.closedAmount + filledAmount * closedPrice) /\n            (quote.closedAmount + filledAmount);\n\n        quote.closedAmount += filledAmount;\n        quote.quantityToClose -= filledAmount;\n\n        if (quote.closedAmount == quote.quantity) {\n            quote.quoteStatus = QuoteStatus.CLOSED;\n            quote.requestedClosePrice = 0;\n            removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n        ) {\n            quote.quoteStatus = QuoteStatus.OPENED;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n        } else {\n            require(\n                quote.lockedValues.total() >=\n                    SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"LibQuote: Remaining quote value is low\"\n            );\n        }\n    }\n\n    function expireQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(block.timestamp > quote.deadline, \"LibQuote: Quote isn't expired\");\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING ||\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"LibQuote: Invalid state\"\n        );\n        require(\n            !MAStorage.layout().liquidationStatus[quote.partyA],\n            \"LibQuote: PartyA isn't solvent\"\n        );\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[quote.partyB][quote.partyA],\n            \"LibQuote: PartyB isn't solvent\"\n        );\n        if (\n            quote.quoteStatus == QuoteStatus.PENDING ||\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            // send trading Fee back to partyA\n            LibQuote.returnTradingFee(quoteId);\n            removeFromPartyAPendingQuotes(quote);\n            if (\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n            ) {\n                accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n                removeFromPartyBPendingQuotes(quote);\n            }\n            quote.quoteStatus = QuoteStatus.EXPIRED;\n            result = QuoteStatus.EXPIRED;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0;\n            quote.quoteStatus = QuoteStatus.OPENED;\n            result = QuoteStatus.OPENED;\n        }\n    }\n}"
    }
  ]
}