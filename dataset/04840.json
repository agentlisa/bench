{
  "Title": "[G-08] Repack struct by putting data types that fit together into one slot next to each other",
  "Content": "\nThis issue, in comparison to `# [5] Alter some struct's fields datatype to improve packing`  is related to changing the order of fields in the struct (while `[5]` suggests changing the datatype of fields) - thus it's being reported separately.\n\n**File:** `IExecutor.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-interfaces/IExecutor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-interfaces/IExecutor.sol#L83)\n```solidity\n83:     struct StoredBatchInfo {\n84:         uint64 batchNumber;\n85:         bytes32 batchHash;\n86:         uint64 indexRepeatedStorageChanges; \n87:         uint256 numberOfLayer1Txs;\n88:         bytes32 priorityOperationsHash;\n89:         bytes32 l2LogsTreeRoot;\n90:         uint256 timestamp;\n91:         bytes32 commitment;\n92:     }\n```\n\n`batchNumber` and `indexRepeatedStorageChanges` will fit into one slot.\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-interfaces/IExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IZkSyncStateTransitionBase} from \"./IZkSyncStateTransitionBase.sol\";\n\n/// @dev Enum used by L2 System Contracts to differentiate logs.\nenum SystemLogKey {\n    L2_TO_L1_LOGS_TREE_ROOT_KEY,\n    TOTAL_L2_TO_L1_PUBDATA_KEY,\n    STATE_DIFF_HASH_KEY,\n    PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY,\n    PREV_BATCH_HASH_KEY,\n    CHAINED_PRIORITY_TXN_HASH_KEY,\n    NUMBER_OF_LAYER_1_TXS_KEY,\n    BLOB_ONE_HASH_KEY,\n    BLOB_TWO_HASH_KEY,\n    EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY\n}\n\n/// @dev Enum used to determine the source of pubdata. At first we will support calldata and blobs but this can be extended.\nenum PubdataSource {\n    Calldata,\n    Blob\n}\n\nstruct LogProcessingOutput {\n    uint256 numberOfLayer1Txs;\n    bytes32 chainedPriorityTxsHash;\n    bytes32 previousBatchHash;\n    bytes32 pubdataHash;\n    bytes32 stateDiffHash;\n    bytes32 l2LogsTreeRoot;\n    uint256 packedBatchAndL2BlockTimestamp;\n    bytes32 blob1Hash;\n    bytes32 blob2Hash;\n}\n\n/// @dev Offset used to pull Address From Log. Equal to 4 (bytes for isService)\nuint256 constant L2_LOG_ADDRESS_OFFSET = 4;\n\n/// @dev Offset used to pull Key From Log. Equal to 4 (bytes for isService) + 20 (bytes for address)\nuint256 constant L2_LOG_KEY_OFFSET = 24;\n\n/// @dev Offset used to pull Value From Log. Equal to 4 (bytes for isService) + 20 (bytes for address) + 32 (bytes for key)\nuint256 constant L2_LOG_VALUE_OFFSET = 56;\n\n/// @dev BLS Modulus value defined in EIP-4844 and the magic value returned from a successful call to the\n/// point evaluation precompile\nuint256 constant BLS_MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513;\n\n/// @dev Packed pubdata commitments.\n/// @dev Format: list of: opening point (16 bytes) || claimed value (32 bytes) || commitment (48 bytes) || proof (48 bytes)) = 144 bytes\nuint256 constant PUBDATA_COMMITMENT_SIZE = 144;\n\n/// @dev Offset in pubdata commitment of blobs for claimed value\nuint256 constant PUBDATA_COMMITMENT_CLAIMED_VALUE_OFFSET = 16;\n\n/// @dev Offset in pubdata commitment of blobs for kzg commitment\nuint256 constant PUBDATA_COMMITMENT_COMMITMENT_OFFSET = 48;\n\n/// @dev Max number of blobs currently supported\nuint256 constant MAX_NUMBER_OF_BLOBS = 2;\n\n/// @dev The number of blobs that must be present in the commitment to a batch.\n/// It represents the maximal number of blobs that circuits can support and can be larger\n/// than the maximal number of blobs supported by the contract (`MAX_NUMBER_OF_BLOBS`).\nuint256 constant TOTAL_BLOBS_IN_COMMITMENT = 16;\n\n/// @title The interface of the zkSync Executor contract capable of processing events emitted in the zkSync protocol.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ninterface IExecutor is IZkSyncStateTransitionBase {\n    /// @notice Rollup batch stored data\n    /// @param batchNumber Rollup batch number\n    /// @param batchHash Hash of L2 batch\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this batch\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this batch\n    /// @param timestamp Rollup batch timestamp, have the same format as Ethereum batch constant\n    /// @param commitment Verified input for the zkSync circuit\n    struct StoredBatchInfo {\n        uint64 batchNumber;\n        bytes32 batchHash;\n        uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n\n    /// @notice Data needed to commit new batch\n    /// @param batchNumber Number of the committed batch\n    /// @param timestamp Unix timestamp denoting the start of the batch execution\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param newStateRoot The state root of the full state tree\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this batch\n    /// @param bootloaderHeapInitialContentsHash Hash of the initial contents of the bootloader heap. In practice it serves as the commitment to the transactions in the batch.\n    /// @param eventsQueueStateHash Hash of the events queue state. In practice it serves as the commitment to the events in the batch.\n    /// @param systemLogs concatenation of all L2 -> L1 system logs in the batch\n    /// @param pubdataCommitments Packed pubdata commitments/data.\n    /// @dev pubdataCommitments format: This will always start with a 1 byte pubdataSource flag. Current allowed values are 0 (calldata) or 1 (blobs)\n    ///                             kzg: list of: opening point (16 bytes) || claimed value (32 bytes) || commitment (48 bytes) || proof (48 bytes) = 144 bytes\n    ///                             calldata: pubdataCommitments.length - 1 - 32 bytes of pubdata\n    ///                                       and 32 bytes appended to serve as the blob commitment part for the aux output part of the batch commitment\n    /// @dev For 2 blobs we will be sending 288 bytes of calldata instead of the full amount for pubdata.\n    /// @dev When using calldata, we only need to send one blob commitment since the max number of bytes in calldata fits in a single blob and we can pull the\n    ///     linear hash from the system logs\n    struct CommitBatchInfo {\n        uint64 batchNumber;\n        uint64 timestamp;\n        uint64 indexRepeatedStorageChanges;\n        bytes32 newStateRoot;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 bootloaderHeapInitialContentsHash;\n        bytes32 eventsQueueStateHash;\n        bytes systemLogs;\n        bytes pubdataCommitments;\n    }\n\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\n    struct ProofInput {\n        uint256[] recursiveAggregationInput;\n        uint256[] serializedProof;\n    }\n\n    /// @notice Function called by the operator to commit new batches. It is responsible for:\n    /// - Verifying the correctness of their timestamps.\n    /// - Processing their L2->L1 logs.\n    /// - Storing batch commitments.\n    /// @param _lastCommittedBatchData Stored data of the last committed batch.\n    /// @param _newBatchesData Data of the new batches to be committed.\n    function commitBatches(\n        StoredBatchInfo calldata _lastCommittedBatchData,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) external;\n\n    /// @notice same as `commitBatches` but with the chainId so ValidatorTimelock can sort the inputs.\n    function commitBatchesSharedBridge(\n        uint256 _chainId,\n        StoredBatchInfo calldata _lastCommittedBatchData,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) external;\n\n    /// @notice Batches commitment verification.\n    /// @dev Only verifies batch commitments without any other processing.\n    /// @param _prevBatch Stored data of the last committed batch.\n    /// @param _committedBatches Stored data of the committed batches.\n    /// @param _proof The zero knowledge proof.\n    function proveBatches(\n        StoredBatchInfo calldata _prevBatch,\n        StoredBatchInfo[] calldata _committedBatches,\n        ProofInput calldata _proof\n    ) external;\n\n    /// @notice same as `proveBatches` but with the chainId so ValidatorTimelock can sort the inputs.\n    function proveBatchesSharedBridge(\n        uint256 _chainId,\n        StoredBatchInfo calldata _prevBatch,\n        StoredBatchInfo[] calldata _committedBatches,\n        ProofInput calldata _proof\n    ) external;\n\n    /// @notice The function called by the operator to finalize (execute) batches. It is responsible for:\n    /// - Processing all pending operations (commpleting priority requests).\n    /// - Finalizing this batch (i.e. allowing to withdraw funds from the system)\n    /// @param _batchesData Data of the batches to be executed.\n    function executeBatches(StoredBatchInfo[] calldata _batchesData) external;\n\n    /// @notice same as `executeBatches` but with the chainId so ValidatorTimelock can sort the inputs.\n    function executeBatchesSharedBridge(uint256 _chainId, StoredBatchInfo[] calldata _batchesData) external;\n\n    /// @notice Reverts unexecuted batches\n    /// @param _newLastBatch batch number after which batches should be reverted\n    /// NOTE: Doesn't delete the stored data about batches, but only decreases\n    /// counters that are responsible for the number of batches\n    function revertBatches(uint256 _newLastBatch) external;\n\n    /// @notice same as `revertBatches` but with the chainId so ValidatorTimelock can sort the inputs.\n    function revertBatchesSharedBridge(uint256 _chainId, uint256 _newLastBatch) external;\n\n    /// @notice Event emitted when a batch is committed\n    /// @param batchNumber Number of the batch committed\n    /// @param batchHash Hash of the L2 batch\n    /// @param commitment Calculated input for the zkSync circuit\n    /// @dev It has the name \"BlockCommit\" and not \"BatchCommit\" due to backward compatibility considerations\n    event BlockCommit(uint256 indexed batchNumber, bytes32 indexed batchHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when batches are verified\n    /// @param previousLastVerifiedBatch Batch number of the previous last verified batch\n    /// @param currentLastVerifiedBatch Batch number of the current last verified batch\n    /// @dev It has the name \"BlocksVerification\" and not \"BatchesVerification\" due to backward compatibility considerations\n    event BlocksVerification(uint256 indexed previousLastVerifiedBatch, uint256 indexed currentLastVerifiedBatch);\n\n    /// @notice Event emitted when a batch is executed\n    /// @param batchNumber Number of the batch executed\n    /// @param batchHash Hash of the L2 batch\n    /// @param commitment Verified input for the zkSync circuit\n    /// @dev It has the name \"BlockExecution\" and not \"BatchExecution\" due to backward compatibility considerations\n    event BlockExecution(uint256 indexed batchNumber, bytes32 indexed batchHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when batches are reverted\n    /// @param totalBatchesCommitted Total number of committed batches after the revert\n    /// @param totalBatchesVerified Total number of verified batches after the revert\n    /// @param totalBatchesExecuted Total number of executed batches\n    /// @dev It has the name \"BlocksRevert\" and not \"BatchesRevert\" due to backward compatibility considerations\n    event BlocksRevert(uint256 totalBatchesCommitted, uint256 totalBatchesVerified, uint256 totalBatchesExecuted);\n}"
    }
  ]
}