{
  "Title": "Loss of ETH yield due to rounding error when updating the yield rate in the `updateYield` function",
  "Content": "# Loss of ETH yield due to rounding error when updating the yield rate in the `updateYield` function\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibVault.sol#L92\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibVault.sol#L92</a>\n\n\n## Summary\n\nUpdating the vault's yield rate in the `LibVault.updateYield` function can lead to a loss of yield if the newly received ETH yield is small due to rounding errors.\n\n## Vulnerability Details\n\nThe `updateYield` function in the `LibVault` library is called by the permissionless [`YieldFacet.updateYield`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/YieldFacet.sol#L42) function and used to update the vault's yield rate from staking rewards earned by bridge contracts holding LSD.\n\nThe newly accumulated yield, i.e., ETH received since the last update, is calculated by subtracting the current `zethTotalNew` from the previously stored yield `zethTotal`, as seen in line 75 of the `updateYield` function.\n\n[contracts/libraries/LibVault.sol#L92](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibVault.sol#L92)\n\n```solidity\n62: function updateYield(uint256 vault) internal {\n63:     AppStorage storage s = appStorage();\n64:\n65:     STypes.Vault storage Vault = s.vault[vault];\n66:     STypes.VaultUser storage TAPP = s.vaultUser[vault][address(this)];\n67:     // Retrieve vault variables\n68:     uint88 zethTotalNew = uint88(getZethTotal(vault)); // @dev(safe-cast)\n69:     uint88 zethTotal = Vault.zethTotal;\n70:     uint88 zethCollateral = Vault.zethCollateral;\n71:     uint88 zethTreasury = TAPP.ethEscrowed;\n72:\n73:     // Calculate vault yield and overwrite previous total\n74:     if (zethTotalNew <= zethTotal) return;\n75:     uint88 yield = zethTotalNew - zethTotal;\n76:     Vault.zethTotal = zethTotalNew;\n77:\n78:     // If no short records, yield goes to treasury\n79:     if (zethCollateral == 0) {\n80:         TAPP.ethEscrowed += yield;\n81:         return;\n82:     }\n83:\n84:     // Assign yield to zethTreasury\n85:     uint88 zethTreasuryReward = yield.mul(zethTreasury).divU88(zethTotal);\n86:     yield -= zethTreasuryReward;\n87:     // Assign tithe of the remaining yield to treasuryF\n88:     uint88 tithe = yield.mulU88(vault.zethTithePercent());\n89:     yield -= tithe;\n90:     // Realize assigned yields\n91:     TAPP.ethEscrowed += zethTreasuryReward + tithe;\n92: âŒ  Vault.zethYieldRate += yield.divU80(zethCollateral);\n93:     Vault.zethCollateralReward += yield;\n94: }\n```\n\nAfter determining the new yield (ETH), a fraction of the yield is assigned to the TAPP (treasury). Thereafter, the remaining yield is realized by adding it to the vault's yield rate (`zethYieldRate`), which is calculated by dividing the `yield` by the vault's short collateral, `zethCollateral`.\n\n> [!NOTE]\n> Both the `yield` and `zethCollateral` values are in 18 decimal precision due to tracking ETH balances.\n\nBy using the [`divU80` function](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/PRBMathHelper.sol#L111), the `zethYieldRate` is calculated as $zethYieldRate = \\frac{yield \\cdot 10^{18}}{zethCollateral}$\n\nHowever, if the numerator is smaller than the denominator, i.e., the received ETH yield is very small and the vault's collateral large enough, the result of the division will be rounded down to 0, leading to a loss of the remaining yield.\n\nAs anyone is able to call the public `YieldFacet.updateYield` function, this can be used to maliciously cause a loss of yield for all users if the newly received yield is small.\n\nThe following test case demonstrates the described rounding error:\n\n<details>\n  <summary><strong>Test case (click to reveal)</strong></summary>\n\n```diff\ndiff --git a/test/Yield.t.sol b/test/Yield.t.sol\nindex cc770f2..8174aed 100644\n--- a/test/Yield.t.sol\n+++ b/test/Yield.t.sol\n@@ -160,6 +160,19 @@ contract YieldTest is OBFixture {\n         assertApproxEqAbs(ethEscrowed2 - ethEscrowed, 900000000000000000, MAX_DELTA);\n     }\n\n+    function test_DistributeYieldRoundingError() public {\n+        fundLimitShortOpt(DEFAULT_PRICE, DEFAULT_AMOUNT * 10, receiver);\n+        fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT * 10, sender);\n+        skip(yieldEligibleTime);\n+        generateYield(65 wei);\n+\n+        assertEq(diamond.getVaultStruct(vault).zethCollateral, 6e19);\n+\n+        assertEq(diamond.getVaultStruct(vault).zethYieldRate, 0); // Vault's yield rate is 0 -> yield is lost\n+\n+        assertEq(diamond.getVaultUserStruct(vault, tapp).ethEscrowed, 6); // TAPP received 6 wei of yield\n+    }\n+\n     function test_view_getTithe() public {\n         assertEq(diamond.getTithe(vault), 0.1 ether);\n     }\n```\n\n**How to run this test case:**\n\nSave git diff to a file named `test.patch` and run with\n\n```bash\ngit apply test.patch\nforge test -vv --match-test \"test_DistributeYieldRoundingError\"\n```\n\n**Result:**\n\n```bash\nRunning 1 test for test/Yield.t.sol:YieldTest\n[PASS] test_DistributeYieldRoundingError() (gas: 791907)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 51.04ms\n\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n</details>\n\n## Impact\n\nLoss of LSD ETH yield for users of the same vault.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nConsider storing the rounding error and applying the correcting factor (error stored) the next time, or alternatively, prevent (skip) updating the yield if the resulting yield is 0.\n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\nimport {STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibVault {\n    using U256 for uint256;\n    using U88 for uint88;\n    using {zethTithePercent} for uint256;\n\n    // BridgeRouterFacet\n    function addZeth(uint256 vault, uint88 amount) internal {\n        AppStorage storage s = appStorage();\n        s.vaultUser[vault][msg.sender].ethEscrowed += amount;\n        s.vault[vault].zethTotal += amount;\n    }\n\n    function removeZeth(uint256 vault, uint88 amount, uint88 fee) internal {\n        AppStorage storage s = appStorage();\n        s.vaultUser[vault][msg.sender].ethEscrowed -= (amount + fee);\n        s.vault[vault].zethTotal -= amount;\n    }\n\n    // default of .1 ether, stored in uint16 as 10_00\n    // range of [0-33],\n    // i.e. 12.34% as 12_34 / 10_000 -> 0.1234 ether\n    // @dev percentage of yield given to TAPP\n    function zethTithePercent(uint256 vault) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.vault[vault].zethTithePercent) * 1 ether)\n            / Constants.FOUR_DECIMAL_PLACES;\n    }\n\n    function getZethTotal(uint256 vault) internal view returns (uint256 zethTotal) {\n        AppStorage storage s = appStorage();\n        address[] storage bridges = s.vaultBridges[vault];\n        uint256 bridgeCount = bridges.length;\n\n        for (uint256 i; i < bridgeCount;) {\n            zethTotal += IBridge(bridges[i]).getZethValue();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the vault yield rate from staking rewards earned by bridge contracts holding LSD\n     * @dev Does not distribute yield to any individual owner of shortRecords\n     *\n     * @param vault The vault that will be impacted\n     */\n\n    function updateYield(uint256 vault) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage TAPP = s.vaultUser[vault][address(this)];\n        // Retrieve vault variables\n        uint88 zethTotalNew = uint88(getZethTotal(vault)); // @dev(safe-cast)\n        uint88 zethTotal = Vault.zethTotal;\n        uint88 zethCollateral = Vault.zethCollateral;\n        uint88 zethTreasury = TAPP.ethEscrowed;\n\n        // Calculate vault yield and overwrite previous total\n        if (zethTotalNew <= zethTotal) return;\n        uint88 yield = zethTotalNew - zethTotal;\n        Vault.zethTotal = zethTotalNew;\n\n        // If no short records, yield goes to treasury\n        if (zethCollateral == 0) {\n            TAPP.ethEscrowed += yield;\n            return;\n        }\n\n        // Assign yield to zethTreasury\n        uint88 zethTreasuryReward = yield.mul(zethTreasury).divU88(zethTotal);\n        yield -= zethTreasuryReward;\n        // Assign tithe of the remaining yield to treasuryF\n        uint88 tithe = yield.mulU88(vault.zethTithePercent());\n        yield -= tithe;\n        // Realize assigned yields\n        TAPP.ethEscrowed += zethTreasuryReward + tithe;\n        Vault.zethYieldRate += yield.divU80(zethCollateral);\n        Vault.zethCollateralReward += yield;\n    }\n}"
    },
    {
      "filename": "contracts/facets/YieldFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IAsset} from \"interfaces/IAsset.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibVault} from \"contracts/libraries/LibVault.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract YieldFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n    using LibShortRecord for STypes.ShortRecord;\n    using LibVault for uint256;\n\n    IAsset private immutable DITTO;\n\n    constructor(address _ditto) {\n        DITTO = IAsset(_ditto);\n    }\n\n    /**\n     * @notice Updates the vault yield rate from staking rewards earned by bridge contracts holding LSD\n     * @dev Does not distribute yield to any individual owner of shortRecords\n     *\n     * @param vault The vault that will be impacted\n     */\n\n    function updateYield(uint256 vault) external nonReentrant {\n        vault.updateYield();\n        emit Events.UpdateYield(vault);\n    }\n\n    /**\n     * @notice Updates the vault yield rate from staking rewards earned by bridge contracts holding LSD\n     * @dev Can only distribute yield in markets that are part of the same vault\n     *\n     * @param assets Array of markets to evaluate when distributing yield from caller's shortRecords\n     */\n\n    function distributeYield(address[] calldata assets) external nonReentrant {\n        uint256 length = assets.length;\n        uint256 vault = s.asset[assets[0]].vault;\n\n        // distribute yield for the first order book\n        (uint88 yield, uint256 dittoYieldShares) = _distributeYield(assets[0]);\n\n        // distribute yield for remaining order books\n        for (uint256 i = 1; i < length;) {\n            if (s.asset[assets[i]].vault != vault) revert Errors.DifferentVaults();\n            (uint88 amtYield, uint256 amtDittoYieldShares) = _distributeYield(assets[i]);\n            yield += amtYield;\n            dittoYieldShares += amtDittoYieldShares;\n            unchecked {\n                ++i;\n            }\n        }\n        // claim all distributed yield\n        _claimYield(vault, yield, dittoYieldShares);\n        emit Events.DistributeYield(vault, msg.sender, yield, dittoYieldShares);\n    }\n\n    // Distributes yield earned from all of caller's shortRecords of this asset\n    function _distributeYield(address asset)\n        private\n        onlyValidAsset(asset)\n        returns (uint88 yield, uint256 dittoYieldShares)\n    {\n        uint256 vault = s.asset[asset].vault;\n        // Last updated zethYieldRate for this vault\n        uint80 zethYieldRate = s.vault[vault].zethYieldRate;\n        // Protocol time\n        uint256 timestamp = LibOrders.getOffsetTimeHours();\n        // Last saved oracle price\n        uint256 oraclePrice = LibOracle.getPrice(asset);\n        // CR of shortRecord collateralized at initialMargin for this asset\n        uint256 initialCR = LibAsset.initialMargin(asset) + 1 ether;\n        // Retrieve first non-HEAD short\n        uint8 id = s.shortRecords[asset][msg.sender][Constants.HEAD].nextId;\n        // Loop through all shorter's shorts of this asset\n        while (true) {\n            // One short of one shorter in this market\n            STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n            // To prevent flash loans or loans where they want to deposit to claim yield immediately\n            bool isNotRecentlyModified =\n                timestamp - short.updatedAt > Constants.YIELD_DELAY_HOURS;\n            // Check for cancelled short\n            if (short.status != SR.Cancelled && isNotRecentlyModified) {\n                uint88 shortYield =\n                    short.collateral.mulU88(zethYieldRate - short.zethYieldRate);\n                // Yield earned by this short\n                yield += shortYield;\n                // Update zethYieldRate for this short\n                short.zethYieldRate = zethYieldRate;\n                // Calculate CR to modify ditto rewards\n                uint256 cRatio = short.getCollateralRatioSpotPrice(oraclePrice);\n                if (cRatio <= initialCR) {\n                    dittoYieldShares += shortYield;\n                } else {\n                    // Reduce amount of yield credited for ditto rewards proportional to CR\n                    dittoYieldShares += shortYield.mul(initialCR).div(cRatio);\n                }\n            }\n            // Move to next short unless this is the last one\n            if (short.nextId > Constants.HEAD) {\n                id = short.nextId;\n            } else {\n                break;\n            }\n        }\n    }\n\n    // Credit ZETH and Ditto rewards earned from shortRecords from all markets\n    function _claimYield(uint256 vault, uint88 yield, uint256 dittoYieldShares) private {\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n        // Implicitly checks for a valid vault\n        if (yield <= 1) revert Errors.NoYield();\n        // Credit yield to ethEscrowed\n        VaultUser.ethEscrowed += yield;\n        // Ditto rewards earned for all shorters since inception\n        uint256 protocolTime = LibOrders.getOffsetTime();\n        uint256 dittoRewardShortersTotal = Vault.dittoShorterRate * protocolTime;\n        // Ditto reward proportion from this yield distribution\n        uint256 dittoYieldSharesTotal = Vault.zethCollateralReward;\n        uint256 dittoReward =\n            dittoYieldShares.mul(dittoRewardShortersTotal).div(dittoYieldSharesTotal);\n        // Credit ditto reward to user\n        if (dittoReward > type(uint80).max) revert Errors.InvalidAmount();\n        VaultUser.dittoReward += uint80(dittoReward);\n    }\n\n    /**\n     * @notice Credits ditto rewards earned from eligible limit orders from all markets\n     *\n     * @param vault The vault that will be impacted\n     */\n\n    function claimDittoMatchedReward(uint256 vault) external nonReentrant {\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n        // User's shares total\n        uint88 shares = VaultUser.dittoMatchedShares;\n        // Implicitly checks for a valid vault\n        if (shares <= 1) revert Errors.NoShares();\n        // Decrease by 1 wei to account for 1 wei gas saving technique\n        shares -= 1;\n        // Total token reward amount for limit orders\n        uint256 protocolTime = LibOrders.getOffsetTime() / 1 days;\n        uint256 elapsedTime = protocolTime - Vault.dittoMatchedTime;\n        uint256 totalReward =\n            Vault.dittoMatchedReward + elapsedTime * 1 days * Vault.dittoMatchedRate;\n        // User's proportion of the total token reward\n        uint256 sharesTotal = Vault.dittoMatchedShares;\n        uint256 userReward = shares.mul(totalReward).div(sharesTotal);\n        // Only update dittoMatchedTime when totalReward increases\n        if (elapsedTime > 0) {\n            Vault.dittoMatchedTime = uint16(protocolTime); // @dev(safe-cast)\n        }\n        // Update remaining records\n        Vault.dittoMatchedShares -= shares;\n        if ((totalReward - userReward) > type(uint96).max) revert Errors.InvalidAmount();\n        Vault.dittoMatchedReward = uint96(totalReward - userReward);\n        VaultUser.dittoMatchedShares = 1; // keep as non-zero to save gas\n        if (userReward > type(uint80).max) revert Errors.InvalidAmount();\n        VaultUser.dittoReward += uint80(userReward);\n        emit Events.ClaimDittoMatchedReward(vault, msg.sender);\n    }\n\n    /**\n     * @notice Mints claimed Ditto rewards\n     * @dev Includes claimed balances from shortRecords and limit orders\n     *\n     * @param vault The vault that will be impacted\n     */\n\n    function withdrawDittoReward(uint256 vault) external nonReentrant {\n        STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n        uint256 amt = VaultUser.dittoReward;\n        // Implicitly checks for a valid vault\n        if (amt <= 1) revert Errors.NoDittoReward();\n        // Decrease by 1 wei to account for 1 wei gas saving technique\n        amt -= 1;\n        VaultUser.dittoReward = 1; // keep as non-zero to save gas\n        DITTO.mint(msg.sender, amt);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\nimport {STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibVault {\n    using U256 for uint256;\n    using U88 for uint88;\n    using {zethTithePercent} for uint256;\n\n    // BridgeRouterFacet\n    function addZeth(uint256 vault, uint88 amount) internal {\n        AppStorage storage s = appStorage();\n        s.vaultUser[vault][msg.sender].ethEscrowed += amount;\n        s.vault[vault].zethTotal += amount;\n    }\n\n    function removeZeth(uint256 vault, uint88 amount, uint88 fee) internal {\n        AppStorage storage s = appStorage();\n        s.vaultUser[vault][msg.sender].ethEscrowed -= (amount + fee);\n        s.vault[vault].zethTotal -= amount;\n    }\n\n    // default of .1 ether, stored in uint16 as 10_00\n    // range of [0-33],\n    // i.e. 12.34% as 12_34 / 10_000 -> 0.1234 ether\n    // @dev percentage of yield given to TAPP\n    function zethTithePercent(uint256 vault) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.vault[vault].zethTithePercent) * 1 ether)\n            / Constants.FOUR_DECIMAL_PLACES;\n    }\n\n    function getZethTotal(uint256 vault) internal view returns (uint256 zethTotal) {\n        AppStorage storage s = appStorage();\n        address[] storage bridges = s.vaultBridges[vault];\n        uint256 bridgeCount = bridges.length;\n\n        for (uint256 i; i < bridgeCount;) {\n            zethTotal += IBridge(bridges[i]).getZethValue();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the vault yield rate from staking rewards earned by bridge contracts holding LSD\n     * @dev Does not distribute yield to any individual owner of shortRecords\n     *\n     * @param vault The vault that will be impacted\n     */\n\n    function updateYield(uint256 vault) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage TAPP = s.vaultUser[vault][address(this)];\n        // Retrieve vault variables\n        uint88 zethTotalNew = uint88(getZethTotal(vault)); // @dev(safe-cast)\n        uint88 zethTotal = Vault.zethTotal;\n        uint88 zethCollateral = Vault.zethCollateral;\n        uint88 zethTreasury = TAPP.ethEscrowed;\n\n        // Calculate vault yield and overwrite previous total\n        if (zethTotalNew <= zethTotal) return;\n        uint88 yield = zethTotalNew - zethTotal;\n        Vault.zethTotal = zethTotalNew;\n\n        // If no short records, yield goes to treasury\n        if (zethCollateral == 0) {\n            TAPP.ethEscrowed += yield;\n            return;\n        }\n\n        // Assign yield to zethTreasury\n        uint88 zethTreasuryReward = yield.mul(zethTreasury).divU88(zethTotal);\n        yield -= zethTreasuryReward;\n        // Assign tithe of the remaining yield to treasuryF\n        uint88 tithe = yield.mulU88(vault.zethTithePercent());\n        yield -= tithe;\n        // Realize assigned yields\n        TAPP.ethEscrowed += zethTreasuryReward + tithe;\n        Vault.zethYieldRate += yield.divU80(zethCollateral);\n        Vault.zethCollateralReward += yield;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/PRBMathHelper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {mulDiv as _mulDiv, mulDiv18, UNIT} from \"@prb/math/src/Common.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\nlibrary U256 {\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        return _mulDiv(x, y, denominator);\n    }\n\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is UNIT * UNIT.\n            result = 1e36 / x;\n        }\n    }\n\n    function divU80(uint256 x, uint256 y) internal pure returns (uint80 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint80).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint80(_result);\n    }\n\n    function divU64(uint256 x, uint256 y) internal pure returns (uint64 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint64).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint64(_result);\n    }\n\n    // test\n    function divU88(uint256 x, uint256 y) internal pure returns (uint88 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint88).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint88(_result);\n    }\n}\n\n// uint128\nlibrary Math128 {\n    // just passing the result of casting the first param to 256\n    function mul(uint128 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function div(uint128 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n}\n\n// uint104\nlibrary Math104 {\n    // just passing the result of casting the first param to 256\n    function mul(uint104 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function div(uint104 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n}\n\n// uint96\nlibrary U96 {\n    // just passing the result of casting the first param to 256\n    function mul(uint96 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function div(uint96 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n\n    function divU64(uint96 x, uint256 y) internal pure returns (uint64 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint64).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint64(_result);\n    }\n}\n\n// uint88\nlibrary U88 {\n    // just passing the result of casting the first param to 256\n    function mul(uint88 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function mulU88(uint88 x, uint256 y) internal pure returns (uint88 result) {\n        uint256 _result = mulDiv18(x, y);\n        if (_result > type(uint88).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint88(_result);\n    }\n\n    function div(uint88 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n\n    function divU88(uint88 x, uint256 y) internal pure returns (uint88 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint88).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint88(_result);\n    }\n\n    function divU80(uint88 x, uint256 y) internal pure returns (uint80 result) {\n        uint256 _result = _mulDiv(x, UNIT, y);\n        if (_result > type(uint80).max) revert Errors.InvalidAmount(); // assume amount?\n        result = uint80(_result);\n    }\n}\n\n// uint80\nlibrary U80 {\n    // just passing the result of casting the first param to 256\n    function mul(uint80 x, uint256 y) internal pure returns (uint256 result) {\n        result = mulDiv18(x, y);\n    }\n\n    function mulU80(uint80 x, uint256 y) internal pure returns (uint80 result) {\n        uint256 _result = mulDiv18(x, y);\n        if (_result > type(uint80).max) revert Errors.InvalidPrice(); // assume price?\n        result = uint80(_result);\n    }\n\n    function mulU88(uint80 x, uint256 y) internal pure returns (uint88 result) {\n        uint256 _result = mulDiv18(x, y);\n        if (_result > type(uint80).max) revert Errors.InvalidPrice(); // assume price?\n        result = uint88(_result);\n    }\n\n    function div(uint80 x, uint256 y) internal pure returns (uint256 result) {\n        result = _mulDiv(x, UNIT, y);\n    }\n\n    // test\n    function inv(uint80 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is UNIT * UNIT.\n            result = 1e36 / x;\n        }\n    }\n}"
    }
  ]
}