{
  "Title": "[N-18]  Variable names that consist of all capital letters should be reserved for `constant`/`immutable` variables",
  "Content": "If the variable needs to be different based on which class it comes from, a `view`/`pure` _function_ should be used instead (e.g. like [this](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/76eee35971c2541585e05cbf258510dda7b2fbc6/contracts/token/ERC20/extensions/draft-IERC20Permit.sol#L59)).\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n45:       ERC20 WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L45\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n50:       uint256 public MIN_VOTING_POWER_REQUIRED = 0;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L50\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-golom",
  "Code": [
    {
      "filename": "contracts/token/ERC20/extensions/draft-IERC20Permit.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}"
    },
    {
      "filename": "contracts/core/GolomTrader.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\ninterface ERC721 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface ERC1155 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n}\n\ninterface ERC20 {\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n\ninterface Distributor {\n    function addFee(address[2] calldata addr, uint256 fee) external;\n}\n\ncontract GolomTrader is Ownable, ReentrancyGuard {\n    bytes32 public immutable EIP712_DOMAIN_TYPEHASH;\n    mapping(address => uint256) public nonces; // all nonces other then this nonce\n    mapping(bytes32 => uint256) public filled;\n\n    ERC20 WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    struct Order {\n        address collection; // NFT contract address\n        uint256 tokenId; // order for which tokenId of the collection\n        address signer; // maker of order address\n        uint256 orderType; // 0 if selling nft for eth , 1 if offering weth for nft,2 if offering weth for collection with special criteria root\n        uint256 totalAmt; // price value of the trade // total amt maker is willing to give up per unit of amount\n        Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n        Payment prePayment; // another payment , can be used for royalty, facilating trades\n        bool isERC721; // standard of the collection , if 721 then true , if 1155 then false\n        uint256 tokenAmt; // token amt useful if standard is 1155 if >1 means whole order can be filled tokenAmt times\n        uint256 refererrAmt; // amt to pay to the address that helps in filling your order\n        bytes32 root; // A merkle root derived from each valid tokenId â€” set to 0 to indicate a collection-level or tokenId-specific order.\n        address reservedAddress; // if not address(0) , only this address can fill the order\n        uint256 nonce; // nonce of order usefull for cancelling in bulk\n        uint256 deadline; // timestamp till order is valid epoch timestamp in secs\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct Payment {\n        uint256 paymentAmt;\n        address paymentAddress;\n    }\n\n    address public governance;\n\n    Distributor public distributor;\n    address public pendingDistributor;\n    uint256 public distributorEnableDate;\n\n    // events\n    event NonceIncremented(address indexed maker, uint256 newNonce);\n\n    event OrderFilled(\n        address indexed maker,\n        address indexed taker,\n        uint256 indexed orderType,\n        bytes32 orderHash,\n        uint256 price\n    );\n\n    event OrderCancelled(bytes32 indexed orderHash);\n\n    /// @param _governance Address of the governance, responsible for setting distributor\n    constructor(address _governance) {\n        // sets governance as owner\n        _transferOwnership(_governance);\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        EIP712_DOMAIN_TYPEHASH = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes('GOLOM.IO')),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function hashPayment(Payment calldata p) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256('payment(uint256 paymentAmt,address paymentAddress)'),\n                    p.paymentAmt,\n                    p.paymentAddress\n                )\n            );\n    }\n\n    function _hashOrder(Order calldata o) private pure returns (bytes32) {\n        return _hashOrderinternal(o, [o.nonce, o.deadline]);\n    }\n\n    function _hashOrderinternal(Order calldata o, uint256[2] memory extra) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        'order(address collection,uint256 tokenId,address signer,uint256 orderType,uint256 totalAmt,payment exchange,payment prePayment,bool isERC721,uint256 tokenAmt,uint256 refererrAmt,bytes32 root,address reservedAddress,uint256 nonce,uint256 deadline)payment(uint256 paymentAmt,address paymentAddress)'\n                    ),\n                    o.collection,\n                    o.tokenId,\n                    o.signer,\n                    o.orderType,\n                    o.totalAmt,\n                    hashPayment(o.exchange),\n                    hashPayment(o.prePayment),\n                    o.isERC721,\n                    o.tokenAmt,\n                    o.refererrAmt,\n                    o.root,\n                    o.reservedAddress,\n                    extra\n                )\n            );\n    }\n\n    function payEther(uint256 payAmt, address payAddress) internal {\n        if (payAmt > 0) {\n            // if royalty has to be paid\n            payable(payAddress).transfer(payAmt); // royalty transfer to royaltyaddress\n        }\n    }\n\n    /// @dev Validates Order and returns OrderStatus, hashedorder, amountRemaining to be filled\n    ///      OrderStatus = 0 , if signature is invalid\n    ///      OrderStatus = 1 , if deadline has been\n    ///      OrderStatus = 2 , order is filled or cancelled\n    ///      OrderStatus = 3 , valid order\n    /// @param o the Order struct to be validated\n    function validateOrder(Order calldata o)\n        public\n        view\n        returns (\n            uint256,\n            bytes32,\n            uint256\n        )\n    {\n        // match signature\n        bytes32 hashStruct = _hashOrder(o);\n        bytes32 hash = keccak256(abi.encodePacked('\\x19\\x01', EIP712_DOMAIN_TYPEHASH, hashStruct));\n        address signaturesigner = ecrecover(hash, o.v, o.r, o.s);\n        require(signaturesigner == o.signer, 'invalid signature');\n        if (signaturesigner != o.signer) {\n            return (0, hashStruct, 0);\n        }\n        //deadline\n        if (block.timestamp > o.deadline) {\n            return (1, hashStruct, 0);\n        }\n        // not cancelled by nonce or by hash\n        if (o.nonce != nonces[o.signer]) {\n            return (2, hashStruct, 0);\n        }\n        if (filled[hashStruct] >= o.tokenAmt) {\n            // handles erc1155\n            return (2, hashStruct, 0);\n        }\n        return (3, hashStruct, o.tokenAmt - filled[hashStruct]);\n    }\n\n    /// @dev function to fill a signed order of ordertype 0, also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order\n    /// @param o the Order struct to be filled must be orderType 0\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    /// @param receiver address which will receive the NFT\n    function fillAsk(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p,\n        address receiver\n    ) public payable nonReentrant {\n        // check if the signed total amount has all the amounts as well as 50 basis points fee\n        require(\n            o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt + (o.totalAmt * 50) / 10000,\n            'amt not matching'\n        );\n\n        // attached ETH value should be greater than total value of one NFT * total number of NFTs + any extra payment to be given\n        require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 0, 'invalid orderType');\n\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n\n        require(status == 3, 'order not valid');\n        require(amountRemaining >= amount, 'order already filled');\n\n        filled[hashStruct] = filled[hashStruct] + amount;\n\n        if (receiver == address(0)) {\n            receiver = msg.sender;\n        }\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721(o.collection).transferFrom(o.signer, receiver, o.tokenId);\n        } else {\n            ERC1155(o.collection).safeTransferFrom(o.signer, receiver, o.tokenId, amount, '');\n        }\n\n        // pay fees of 50 basis points to the distributor\n        payEther(((o.totalAmt * 50) / 10000) * amount, address(distributor));\n\n        // pay the exchange share\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n\n        // pay the pre payment\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt -\n                    (o.totalAmt * 50) /\n                    10000 -\n                    o.exchange.paymentAmt -\n                    o.prePayment.paymentAmt -\n                    o.refererrAmt) * amount,\n                o.signer\n            );\n        } else {\n            payEther(\n                (o.totalAmt - (o.totalAmt * 50) / 10000 - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount,\n                o.signer\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n\n        distributor.addFee([o.signer, o.exchange.paymentAddress], ((o.totalAmt * 50) / 10000) * amount);\n        emit OrderFilled(o.signer, msg.sender, 0, hashStruct, o.totalAmt * amount);\n    }\n\n    /// @dev function to fill a signed order of ordertype 1 also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order\n    /// @param o the Order struct to be filled must be orderType 1\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function fillBid(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) public nonReentrant {\n        require(\n            o.totalAmt * amount >\n                (o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt) * amount + p.paymentAmt\n        ); // cause bidder eth is paying for seller payment p , dont take anything extra from seller\n        // require eth amt is sufficient\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 1);\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n        require(status == 3);\n        require(amountRemaining >= amount);\n        filled[hashStruct] = filled[hashStruct] + amount;\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721 nftcontract = ERC721(o.collection);\n            nftcontract.transferFrom(msg.sender, o.signer, o.tokenId);\n        } else {\n            ERC1155 nftcontract = ERC1155(o.collection);\n            nftcontract.safeTransferFrom(msg.sender, o.signer, o.tokenId, amount, '');\n        }\n        emit OrderFilled(msg.sender, o.signer, 1, hashStruct, o.totalAmt * amount);\n        _settleBalances(o, amount, referrer, p);\n    }\n\n    // cancel by nonce and by individual order\n\n    function cancelOrder(Order calldata o) public nonReentrant {\n        require(o.signer == msg.sender);\n        (, bytes32 hashStruct, ) = validateOrder(o);\n        filled[hashStruct] = o.tokenAmt + 1;\n        emit OrderCancelled(hashStruct);\n    }\n\n    /**\n     * Increment a particular maker's nonce, thereby invalidating all orders that were not signed\n     * with the original nonce.\n     */\n    function incrementNonce() external nonReentrant {\n        uint256 newNonce = ++nonces[msg.sender];\n        emit NonceIncremented(msg.sender, newNonce);\n    }\n\n    /// @dev function to fill a signed order of ordertype 2 also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order, Match an criteria order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root, if root is 0 then any token can be used to fill the order\n    /// @param o the Order struct to be filled must be orderType 2\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function fillCriteriaBid(\n        Order calldata o,\n        uint256 amount,\n        uint256 tokenId,\n        bytes32[] calldata proof,\n        address referrer,\n        Payment calldata p\n    ) public nonReentrant {\n        require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt);\n        // require eth amt is sufficient\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 2);\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n        require(status == 3);\n        require(amountRemaining >= amount);\n\n        filled[hashStruct] = filled[hashStruct] + amount;\n        // Proof verification is performed when there's a non-zero root.\n        if (o.root != bytes32(0)) {\n            _verifyProof(tokenId, o.root, proof);\n        }\n\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721 nftcontract = ERC721(o.collection);\n            nftcontract.transferFrom(msg.sender, o.signer, tokenId);\n        } else {\n            ERC1155 nftcontract = ERC1155(o.collection);\n            nftcontract.safeTransferFrom(msg.sender, o.signer, tokenId, amount, '');\n        }\n        emit OrderFilled(msg.sender, o.signer, 2, hashStruct, o.totalAmt * amount);\n        _settleBalances(o, amount, referrer, p);\n    }\n\n    /// @dev function to settle balances when a bid is filled succesfully\n    /// @param o the Order struct to be filled must be orderType 1\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function _settleBalances(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) internal {\n        uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n        WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n        WETH.withdraw(o.totalAmt * amount);\n        payEther(protocolfee, address(distributor));\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n        distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee);\n    }\n\n    /// @dev Ensure that a given tokenId is contained within a supplied merkle root using a supplied proof.\n    /// @param leaf The tokenId.\n    /// @param root A merkle root derived from each valid tokenId.\n    /// @param proof A proof that the supplied tokenId is contained within the associated merkle root.\n    function _verifyProof(\n        uint256 leaf,\n        bytes32 root,\n        bytes32[] memory proof\n    ) public pure {\n        bytes32 computedHash = keccak256(abi.encode(leaf));\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        if (computedHash != root) {\n            revert('invalid proof');\n        }\n    }\n\n    /// @dev Efficiently hash two bytes32 elements using memory scratch space.\n    /// @param a The first element included in the hash.\n    /// @param b The second element included in the hash.\n    /// @return value The resultant hash of the two bytes32 elements.\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @notice Sets the distributor contract\n    /// @param _distributor Address of the distributor\n    function setDistributor(address _distributor) external onlyOwner {\n        if (address(distributor) == address(0)) {\n            distributor = Distributor(_distributor);\n        } else {\n            pendingDistributor = _distributor;\n            distributorEnableDate = block.timestamp + 1 days;\n        }\n    }\n\n    /// @notice Executes the set distributor function after the timelock\n    function executeSetDistributor() external onlyOwner {\n        require(distributorEnableDate <= block.timestamp, 'not allowed');\n        distributor = Distributor(pendingDistributor);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/vote-escrow/VoteEscrowDelegation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n/// votescrow extended with delegation\n\n// import {Math} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {VoteEscrowCore} from './VoteEscrowCore.sol';\n\ninterface IVoteEscrow {\n    function balanceOf(uint256) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256, uint256) external view returns (uint256);\n\n    function ownerOf(uint256) external view returns (address);\n}\n\ncontract VoteEscrow is VoteEscrowCore, Ownable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(uint256 indexed tokenId, uint256 indexed toTokenId, address indexed currentOwner);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /// @notice Delegate of the specific token\n    mapping(uint256 => uint256) public delegates;\n\n    /// @notice Total delegated tokens to specific token\n    mapping(uint256 => uint256[]) public delegatedTokenIds;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint256 fromBlock;\n        uint256[] delegatedTokenIds;\n    }\n\n    /// @notice A record of votes checkpoints for each tokenId, by index\n    mapping(uint256 => mapping(uint256 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each delegated tokenId\n    mapping(uint256 => uint256) public numCheckpoints;\n\n    /// @notice minimum voting power required for delegation\n    uint256 public MIN_VOTING_POWER_REQUIRED = 0;\n\n    constructor(address _token) {\n        token = _token;\n        voter = msg.sender;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    /// @notice Explain to an end user what this does\n    /// @param tokenId token ID which is being delegated\n    /// @param toTokenId token ID to which the {tokenId} is being delegated\n    function delegate(uint256 tokenId, uint256 toTokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n        delegates[tokenId] = toTokenId;\n        uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n        if (nCheckpoints > 0) {\n            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            checkpoint.delegatedTokenIds.push(tokenId);\n            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n        } else {\n            uint256[] memory array = new uint256[](1);\n            array[0] = tokenId;\n            _writeCheckpoint(toTokenId, nCheckpoints, array);\n        }\n\n        emit DelegateChanged(tokenId, toTokenId, msg.sender);\n    }\n\n    /**\n     * @notice Writes the checkpoint to store current NFTs in the specific block\n     */\n    function _writeCheckpoint(\n        uint256 toTokenId,\n        uint256 nCheckpoints,\n        uint256[] memory _delegatedTokenIds\n    ) internal {\n        require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\n        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n        } else {\n            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n            numCheckpoints[toTokenId] = nCheckpoints + 1;\n        }\n    }\n\n    /**\n     * @notice Gets the current delegated nfts array for `nftid`\n     * @param tokenId The address to get votes balance\n     * @return The current delegated nfts array for `account`\n     */\n    function _getCurrentDelegated(uint256 tokenId) internal view returns (uint256[] memory) {\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        uint256[] memory myArray;\n        return nCheckpoints > 0 ? checkpoints[tokenId][nCheckpoints - 1].delegatedTokenIds : myArray;\n    }\n\n    /**\n     * @notice Determine the prior delegated nfts array for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param nftId The id of the nft to check\n     * @param blockNumber The block number to get the delegate nft array at\n     * @return The number of delegated nfts the account had as of the given block\n     */\n    function _getPriorDelegated(uint256 nftId, uint256 blockNumber) internal view returns (uint256[] memory) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory myArray;\n        uint256 nCheckpoints = numCheckpoints[nftId];\n        if (nCheckpoints == 0) {\n            return myArray;\n        }\n\n        // First check most recent balance\n        if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[nftId][0].fromBlock > blockNumber) {\n            return myArray;\n        }\n\n        uint256 lower = 0;\n        uint256 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[nftId][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegatedTokenIds;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[nftId][lower].delegatedTokenIds;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param tokenId The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getVotes(uint256 tokenId) external view returns (uint256) {\n        uint256[] memory delegated = _getCurrentDelegated(tokenId);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegated.length; index++) {\n            votes = votes + this.balanceOfNFT(delegated[index]);\n        }\n        return votes;\n    }\n\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param tokenId The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegatednft.length; index++) {\n            votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n        }\n        return votes;\n    }\n\n    /// @notice Removes specific element from the array\n    /// @param _array Whole array\n    /// @param _element The element which we need to remove\n    function removeElement(uint256[] storage _array, uint256 _element) internal {\n        for (uint256 i; i < _array.length; i++) {\n            if (_array[i] == _element) {\n                _array[i] = _array[_array.length - 1];\n                _array.pop();\n                break;\n            }\n        }\n    }\n\n    /// @notice Remove delegation\n    /// @param tokenId TokenId of which delegation needs to be removed\n    function removeDelegation(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n\n    // /// @notice Remove delegation by user\n    // function removeDelegationByOwner(uint256 delegatedTokenId, uint256 ownerTokenId) external {\n    //     require(ownerOf(ownerTokenId) == msg.sender, 'VEDelegation: Not allowed');\n    //     uint256 nCheckpoints = numCheckpoints[delegatedTokenId];\n    //     Checkpoint storage checkpoint = checkpoints[delegatedTokenId][nCheckpoints - 1];\n    //     removeElement(checkpoint.delegatedTokenIds, delegatedTokenId);\n    //     _writeCheckpoint(ownerTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    // }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        address _sender\n    ) internal override {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n        // remove the delegation\n        this.removeDelegation(_tokenId);\n\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId));\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Changes minimum voting power required for delegation\n    /// @param _newMinVotingPower New minimum voting power required\n    function changeMinVotingPower(uint256 _newMinVotingPower) external onlyOwner {\n        MIN_VOTING_POWER_REQUIRED = _newMinVotingPower;\n    }\n}"
    }
  ]
}