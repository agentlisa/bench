{
  "Title": "[M02] Proposal’s update can assume prior states",
  "Content": "The [`updateProposal`](https://github.com/graphprotocol/contracts/blob/d51553b3d70c61108852f0ffe1ed249254c91e9a/contracts/governance/GraphGovernance.sol#L78) function of the `GraphGovernance` contract is designed to update either the votes or the resolution of a proposal.\n\n\nThe function is not checking whether the new parameters for the proposal, passed as input values, are different from those stored in the [`proposals`](https://github.com/graphprotocol/contracts/blob/d51553b3d70c61108852f0ffe1ed249254c91e9a/contracts/governance/GraphGovernance.sol#L89) mapping, or even if they have been used previously.\n\n\nSpecifically, the `_votes` parameter can be reused multiple times. Even if `_votes` is an IPFS hash of a collection of signatures for each vote for the `_proposalId`, this doesn’t amount to a replay vulnerability. However, the fact that the `updateProposal` function call is revisiting prior data may lead to confusion.\n\n\nEven worse, a proposal’s resolution can be changed from `Accepted` to `Rejected` and vice versa as many times as this function is called.\n\n\nWhether this is a design choice or an unexpected outcome, consider either properly documenting this design choice or avoiding having a non-permanent or repetitive resolution on a specific proposal.\n\n\nMoreover, consider adding some checks to verify that the values passed as input parameters are different from the stored or previously referenced data.\n\n\n**Update:** *Fixed in [PR463](https://github.com/graphprotocol/contracts/pull/463) at commit [`8a4fb6e5aeaf777879258ef0b4bdacde23ae30d7`](https://github.com/graphprotocol/contracts/pull/463/commits/8a4fb6e5aeaf777879258ef0b4bdacde23ae30d7) where documentation describing the consequences of this design choice were added.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/governance/GraphGovernance.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\nimport \"../upgrades/GraphUpgradeable.sol\";\n\nimport \"./GraphGovernanceStorage.sol\";\n\n/**\n * @title Graph Governance Contract\n * @notice Governance contract used to inscribe Graph Council and community votes.\n */\ncontract GraphGovernance is GraphGovernanceV1Storage, GraphUpgradeable, IGraphGovernance {\n    // -- Events --\n\n    event ProposalCreated(\n        address submitter,\n        bytes32 proposalId,\n        bytes32 votes,\n        bytes32 metadata,\n        ProposalResolution resolution\n    );\n    event ProposalUpdated(\n        address submitter,\n        bytes32 proposalId,\n        bytes32 votes,\n        bytes32 metadata,\n        ProposalResolution resolution\n    );\n\n    /**\n     * @notice Initialize this contract.\n     */\n    function initialize(address _governor) public onlyImpl {\n        Governed._initialize(_governor);\n    }\n\n    // -- Proposals --\n\n    /**\n     * @notice Return whether the proposal is created.\n     * @param _proposalId Proposal identifier\n     * @return True if the proposal is already created\n     */\n    function isProposalCreated(bytes32 _proposalId) public view override returns (bool) {\n        return proposals[_proposalId].votes != 0;\n    }\n\n    /**\n     * @notice Submit a new proposal.\n     * @param _proposalId Proposal identifier. This is an IPFS hash to the content of the proposal\n     * @param _votes An IPFS hash of the collection of signatures for each vote\n     * @param _metadata A bytes32 field to attach metadata to the proposal if needed\n     * @param _resolution Resolution choice, either Accepted or Rejected\n     */\n    function createProposal(\n        bytes32 _proposalId,\n        bytes32 _votes,\n        bytes32 _metadata,\n        ProposalResolution _resolution\n    ) external override onlyGovernor {\n        require(_proposalId != 0x0, \"!proposalId\");\n        require(_votes != 0x0, \"!votes\");\n        require(_resolution != ProposalResolution.Null, \"!resolved\");\n        require(!isProposalCreated(_proposalId), \"proposed\");\n\n        proposals[_proposalId] = Proposal({ votes: _votes, metadata: _metadata, resolution: _resolution });\n        emit ProposalCreated(msg.sender, _proposalId, _votes, _metadata, _resolution);\n    }\n\n    /**\n     * @notice Updates an existing proposal.\n     * @param _proposalId Proposal identifier. This is an IPFS hash to the content of the proposal\n     * @param _votes An IPFS hash of the collection of signatures for each vote\n     * @param _metadata A bytes32 field to attach metadata to the proposal if needed\n     * @param _resolution Resolution choice, either Accepted or Rejected\n     */\n    function updateProposal(\n        bytes32 _proposalId,\n        bytes32 _votes,\n        bytes32 _metadata,\n        ProposalResolution _resolution\n    ) external override onlyGovernor {\n        require(_proposalId != 0x0, \"!proposalId\");\n        require(_votes != 0x0, \"!votes\");\n        require(_resolution != ProposalResolution.Null, \"!resolved\");\n        require(isProposalCreated(_proposalId), \"!proposed\");\n\n        proposals[_proposalId] = Proposal({ votes: _votes, metadata: _metadata, resolution: _resolution });\n        emit ProposalUpdated(msg.sender, _proposalId, _votes, _metadata, _resolution);\n    }\n}"
    },
    {
      "filename": "contracts/governance/GraphGovernance.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\nimport \"../upgrades/GraphUpgradeable.sol\";\n\nimport \"./GraphGovernanceStorage.sol\";\n\n/**\n * @title Graph Governance Contract\n * @notice Governance contract used to inscribe Graph Council and community votes.\n */\ncontract GraphGovernance is GraphGovernanceV1Storage, GraphUpgradeable, IGraphGovernance {\n    // -- Events --\n\n    event ProposalCreated(\n        address submitter,\n        bytes32 proposalId,\n        bytes32 votes,\n        bytes32 metadata,\n        ProposalResolution resolution\n    );\n    event ProposalUpdated(\n        address submitter,\n        bytes32 proposalId,\n        bytes32 votes,\n        bytes32 metadata,\n        ProposalResolution resolution\n    );\n\n    /**\n     * @notice Initialize this contract.\n     */\n    function initialize(address _governor) public onlyImpl {\n        Governed._initialize(_governor);\n    }\n\n    // -- Proposals --\n\n    /**\n     * @notice Return whether the proposal is created.\n     * @param _proposalId Proposal identifier\n     * @return True if the proposal is already created\n     */\n    function isProposalCreated(bytes32 _proposalId) public view override returns (bool) {\n        return proposals[_proposalId].votes != 0;\n    }\n\n    /**\n     * @notice Submit a new proposal.\n     * @param _proposalId Proposal identifier. This is an IPFS hash to the content of the proposal\n     * @param _votes An IPFS hash of the collection of signatures for each vote\n     * @param _metadata A bytes32 field to attach metadata to the proposal if needed\n     * @param _resolution Resolution choice, either Accepted or Rejected\n     */\n    function createProposal(\n        bytes32 _proposalId,\n        bytes32 _votes,\n        bytes32 _metadata,\n        ProposalResolution _resolution\n    ) external override onlyGovernor {\n        require(_proposalId != 0x0, \"!proposalId\");\n        require(_votes != 0x0, \"!votes\");\n        require(_resolution != ProposalResolution.Null, \"!resolved\");\n        require(!isProposalCreated(_proposalId), \"proposed\");\n\n        proposals[_proposalId] = Proposal({ votes: _votes, metadata: _metadata, resolution: _resolution });\n        emit ProposalCreated(msg.sender, _proposalId, _votes, _metadata, _resolution);\n    }\n\n    /**\n     * @notice Updates an existing proposal.\n     * @param _proposalId Proposal identifier. This is an IPFS hash to the content of the proposal\n     * @param _votes An IPFS hash of the collection of signatures for each vote\n     * @param _metadata A bytes32 field to attach metadata to the proposal if needed\n     * @param _resolution Resolution choice, either Accepted or Rejected\n     */\n    function updateProposal(\n        bytes32 _proposalId,\n        bytes32 _votes,\n        bytes32 _metadata,\n        ProposalResolution _resolution\n    ) external override onlyGovernor {\n        require(_proposalId != 0x0, \"!proposalId\");\n        require(_votes != 0x0, \"!votes\");\n        require(_resolution != ProposalResolution.Null, \"!resolved\");\n        require(isProposalCreated(_proposalId), \"!proposed\");\n\n        proposals[_proposalId] = Proposal({ votes: _votes, metadata: _metadata, resolution: _resolution });\n        emit ProposalUpdated(msg.sender, _proposalId, _votes, _metadata, _resolution);\n    }\n}"
    }
  ]
}