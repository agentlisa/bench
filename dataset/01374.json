{
  "Title": "M-4: MultiAccount `depositAndAllocateForAccount` function doesn't scale the allocated amount correctly, failing to allocate enough funds",
  "Content": "# Issue M-4: MultiAccount `depositAndAllocateForAccount` function doesn't scale the allocated amount correctly, failing to allocate enough funds \n\nSource: https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/15 \n\n## Found by \npanprog, tvdung94, xiaoming90\n\nThis is an issue very similar to [issue 222](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/222) from previous audit contest, but in a `MultiAccount` smart contract.\n\n`MultiAccount.depositAndAllocateForAccount` uses the same `amount` value both for `depositFor` and for `allocate`. However, deposit amount decimals are from the collateral token while allocate amount decimals = 18. This means that for USDC (decimals = 6), `depositAndAllocateForAccount` will deposit correct amount, but allocate amount which is 1e12 times smaller (dust amount).\n\n## Vulnerability Detail\n\nInternal accounting (allocatedBalances) are tracked as fixed numbers with 18 decimals, while collateral tokens can have different amount of decimals. This is correctly accounted for in `AccountFacet.depositAndAllocate`:\n```solidity\n    AccountFacetImpl.deposit(msg.sender, amount);\n    uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n    AccountFacetImpl.allocate(amountWith18Decimals);\n```\n\nBut it is treated incorrectly in `MultiAccount.depositAndAllocateForAccount`:\n```solidity\n    ISymmio(symmioAddress).depositFor(account, amount);\n    bytes memory _callData = abi.encodeWithSignature(\n        \"allocate(uint256)\",\n        amount\n    );\n    innerCall(account, _callData);\n```\n\nThis leads to incorrect allocated amounts.\n\n## Impact\n\nSimilar to 222 from previous audit contest, the user expects to have full amount deposited and allocated, but ends up with only dust amount allocated, which can lead to unexpected liquidations (for example, user is at the edge of liquidation, calls depositAndAllocate to improve account health, but is liquidated instead). For consistency reasons, since this is almost identical to 222, it should also be high.\n\n## Code Snippet\n\nThe same amount is used for `depositFor` and `allocate`:\nhttps://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/multiAccount/MultiAccount.sol#L167-L173\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nScale amount correctly before allocating it:\n```solidity\n    ISymmio(symmioAddress).depositFor(account, amount);\n+   uint256 amountWith18Decimals = (amount * 1e18) /\n+       (10 ** IERC20Metadata(collateral).decimals());\n    bytes memory _callData = abi.encodeWithSignature(\n        \"allocate(uint256)\",\n-       amount\n+       amountWith18Decimals\n    );\n    innerCall(account, _callData);\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because internally the depositAndAllocateForAccount calls the allocate function which does not use scaled amount but the actual input amount\n\n\n\n**MoonKnightDev**\n\nNo funds will be lost. The user simply needs to reallocate their balance. Therefore, the severity is not high since there's no loss of funds.\n\n**nevillehuang**\n\nRelating to this [comment](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/222#issuecomment-1653365144) in the previous contest, it has the same root cause and potential same consequence, so could be valid H.\n\n**MoonKnightDev**\n\n> Relating to this [comment](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/222#issuecomment-1653365144) in the previous contest, it has the same root cause and potential same consequence, so could be valid H.\n\nThe root cause differs. Here, you can easily rectify the allocatedBalance by allocating again. Moreover, no funds are lost\n\n**nevillehuang**\n\n> > Relating to this [comment](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/222#issuecomment-1653365144) in the previous contest, it has the same root cause and potential same consequence, so could be valid H.\n> \n> The root cause differs. Here, you can easily rectify the allocatedBalance by allocating again. Moreover, no funds are lost\n\nOk can be valid M according to Impact mentioned in the submission.\n\n**MoonKnightDev**\n\nFixed Code PR: https://github.com/SYMM-IO/symmio-core/pull/35\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/108",
  "Code": [
    {
      "filename": "symmio-core/contracts/multiAccount/MultiAccount.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../interfaces/ISymmio.sol\";\nimport \"../interfaces/ISymmioPartyA.sol\";\nimport \"../interfaces/IMultiAccount.sol\";\n\ncontract MultiAccount is\n    IMultiAccount,\n    Initializable,\n    PausableUpgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Defining roles for access control\n    bytes32 public constant SETTER_ROLE = keccak256(\"SETTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n\n    // State variables\n    mapping(address => Account[]) public accounts; // User to their accounts mapping\n    mapping(address => uint256) public indexOfAccount; // Account to its index mapping\n    mapping(address => address) public owners; // Account to its owner mapping\n\n    address public accountsAdmin; // Admin address for the contract\n    address public symmioAddress; // Address of the Symmio platform\n    uint256 public saltCounter; // Counter for generating unique addresses with create2\n    bytes public accountImplementation;\n\n    modifier onlyOwner(address account, address sender) {\n        require(\n            owners[account] == sender,\n            \"MultiAccount: Sender isn't owner of account\"\n        );\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address admin,\n        address symmioAddress_,\n        bytes memory accountImplementation_\n    ) public initializer {\n        __Pausable_init();\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(PAUSER_ROLE, admin);\n        _grantRole(UNPAUSER_ROLE, admin);\n        _grantRole(SETTER_ROLE, admin);\n        accountsAdmin = admin;\n        symmioAddress = symmioAddress_;\n        accountImplementation = accountImplementation_;\n    }\n\n    function setAccountImplementation(\n        bytes memory accountImplementation_\n    ) external onlyRole(SETTER_ROLE) {\n        emit SetAccountImplementation(\n            accountImplementation,\n            accountImplementation_\n        );\n        accountImplementation = accountImplementation_;\n    }\n\n    function setSymmioAddress(address addr) external onlyRole(SETTER_ROLE) {\n        emit SetSymmioAddress(symmioAddress, addr);\n        symmioAddress = addr;\n    }\n\n    function _deployPartyA() internal returns (address account) {\n        bytes32 salt = keccak256(\n            abi.encodePacked(\"MultiAccount_\", saltCounter)\n        );\n        saltCounter += 1;\n\n        bytes memory bytecode = abi.encodePacked(\n            accountImplementation,\n            abi.encode(accountsAdmin, address(this), symmioAddress)\n        );\n        account = _deployContract(bytecode, salt);\n        return account;\n    }\n\n    function _deployContract(\n        bytes memory bytecode,\n        bytes32 salt\n    ) internal returns (address contractAddress) {\n        assembly {\n            contractAddress := create2(\n                0,\n                add(bytecode, 32),\n                mload(bytecode),\n                salt\n            )\n        }\n        require(symmioAddress != address(0), \"MultiAccount: create2 failed\");\n        emit DeployContract(msg.sender, contractAddress);\n        return contractAddress;\n    }\n\n    function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(UNPAUSER_ROLE) {\n        _unpause();\n    }\n\n    //////////////////////////////// Account Management ////////////////////////////////////\n\n    function addAccount(string memory name) external whenNotPaused {\n        address account = _deployPartyA();\n        indexOfAccount[account] = accounts[msg.sender].length;\n        accounts[msg.sender].push(Account(account, name));\n        owners[account] = msg.sender;\n        emit AddAccount(msg.sender, account, name);\n    }\n\n    function editAccountName(\n        address accountAddress,\n        string memory name\n    ) external whenNotPaused {\n        uint256 index = indexOfAccount[accountAddress];\n        accounts[msg.sender][index].name = name;\n        emit EditAccountName(msg.sender, accountAddress, name);\n    }\n\n    function depositForAccount(\n        address account,\n        uint256 amount\n    ) external onlyOwner(account, msg.sender) whenNotPaused {\n        address collateral = ISymmio(symmioAddress).getCollateral();\n        IERC20Upgradeable(collateral).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        IERC20Upgradeable(collateral).safeApprove(symmioAddress, amount);\n        ISymmio(symmioAddress).depositFor(account, amount);\n        emit DepositForAccount(msg.sender, account, amount);\n    }\n\n    function depositAndAllocateForAccount(\n        address account,\n        uint256 amount\n    ) external onlyOwner(account, msg.sender) whenNotPaused {\n        address collateral = ISymmio(symmioAddress).getCollateral();\n        IERC20Upgradeable(collateral).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        IERC20Upgradeable(collateral).safeApprove(symmioAddress, amount);\n        ISymmio(symmioAddress).depositFor(account, amount);\n        bytes memory _callData = abi.encodeWithSignature(\n            \"allocate(uint256)\",\n            amount\n        );\n        innerCall(account, _callData);\n        emit AllocateForAccount(msg.sender, account, amount);\n        emit DepositForAccount(msg.sender, account, amount);\n    }\n\n    function withdrawFromAccount(\n        address account,\n        uint256 amount\n    ) external onlyOwner(account, msg.sender) whenNotPaused {\n        bytes memory _callData = abi.encodeWithSignature(\n            \"withdrawTo(address,uint256)\",\n            owners[account],\n            amount\n        );\n        emit WithdrawFromAccount(msg.sender, account, amount);\n        innerCall(account, _callData);\n    }\n\n    function innerCall(address account, bytes memory _callData) internal {\n        (bool _success, bytes memory _resultData) = ISymmioPartyA(account)\n            ._call(_callData);\n        emit Call(msg.sender, account, _callData, _success, _resultData);\n        require(_success, \"MultiAccount: Error occurred\");\n    }\n\n    function _call(\n        address account,\n        bytes[] memory _callDatas\n    ) public onlyOwner(account, msg.sender) whenNotPaused {\n        for (uint8 i; i < _callDatas.length; i++) {\n            innerCall(account, _callDatas[i]);\n        }\n    }\n\n    //////////////////////////////// VIEWS ////////////////////////////////////\n\n    function getAccountsLength(address user) external view returns (uint256) {\n        return accounts[user].length;\n    }\n\n    function getAccounts(\n        address user,\n        uint256 start,\n        uint256 size\n    ) external view returns (Account[] memory) {\n        uint256 len = size > accounts[user].length - start\n            ? accounts[user].length - start\n            : size;\n        Account[] memory userAccounts = new Account[](len);\n        for (uint256 i = start; i < start + len; i++) {\n            userAccounts[i - start] = accounts[user][i];\n        }\n        return userAccounts;\n    }\n}"
    }
  ]
}