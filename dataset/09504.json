{
  "Title": "[N-22] NatSpec is incomplete",
  "Content": "\n1.  File: src/Funding.sol (lines [95-112](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/Funding.sol#L95-L112))\n\n```solidity\n    /**\n     * @notice Initializer.\n     * @param _gac Global access control\n     * @param _citadel The token this contract will return in a trade\n     * @param _asset The token this contract will receive in a trade\n     * @param _xCitadel Staked citadel, citadel will be granted to funders in this form\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _assetCap The max asset that the contract can take\n     */\n    function initialize(\n        address _gac,\n        address _citadel,\n        address _asset,\n        address _xCitadel,\n        address _saleRecipient,\n        address _citadelPriceInAssetOracle,\n        uint256 _assetCap\n    ) external initializer {\n```\n\nMissing: `@param _citadelPriceInAssetOracle`\n\n2.  File: src/KnightingRound.sol (lines [98-119](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/KnightingRound.sol#L98-L119))\n\n```solidity\n    /**\n     * @notice Initializer.\n     * @param _tokenOut The token this contract will return in a trade (citadel)\n     * @param _tokenIn The token this contract will receive in a trade\n     * @param _saleStart The time when tokens can be first purchased\n     * @param _saleDuration The duration of the token sale\n     * @param _tokenOutPrice The tokenOut per tokenIn price\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _guestlist Address that will manage auction approvals\n     * @param _tokenInLimit The max tokenIn that the contract can take\n     */\n    function initialize(\n        address _globalAccessControl,\n        address _tokenOut,\n        address _tokenIn,\n        uint256 _saleStart,\n        uint256 _saleDuration,\n        uint256 _tokenOutPrice,\n        address _saleRecipient,\n        address _guestlist,\n        uint256 _tokenInLimit\n    ) external initializer {\n```\n\nMissing: `@param _globalAccessControl`\n\n3.  File: src/StakedCitadel.sol (lines [154-179](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/StakedCitadel.sol#L154-L179))\n\n```solidity\n    /// @notice Initializes the Sett. Can only be called once, ideally when the contract is deployed.\n    /// @param _token Address of the token that can be deposited into the sett.\n    /// @param _governance Address authorized as governance.\n    /// @param _keeper Address authorized as keeper.\n    /// @param _guardian Address authorized as guardian.\n    /// @param _treasury Address to distribute governance fees/rewards to.\n    /// @param _strategist Address authorized as strategist.\n    /// @param _badgerTree Address of badgerTree used for emissions.\n    /// @param _name Specify a custom sett name. Leave empty for default value.\n    /// @param _symbol Specify a custom sett symbol. Leave empty for default value.\n    /// @param _feeConfig Values for the 4 different types of fees charges by the sett\n    ///         [performanceFeeGovernance, performanceFeeStrategist, withdrawToVault, managementFee]\n    ///         Each fee should be less than the constant hard-caps defined above.\n    function initialize(\n        address _token,\n        address _governance,\n        address _keeper,\n        address _guardian,\n        address _treasury,\n        address _strategist,\n        address _badgerTree,\n        address _vesting,\n        string memory _name,\n        string memory _symbol,\n        uint256[4] memory _feeConfig\n    ) public initializer whenNotPaused {\n```\n\nMissing: `@param _vesting`\n\n4.  File: src/StakedCitadel.sol (lines [357-367](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/StakedCitadel.sol#L357-L367))\n\n```solidity\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Checks the guestlist to verify that `recipient` is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) external whenNotPaused {\n```\n\nMissing: `@param proof`\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-badger-citadel",
  "Code": [
    {
      "filename": "src/Funding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./interfaces/badger/IVault.sol\";\nimport \"./interfaces/erc20/IERC20.sol\";\nimport \"./lib/GlobalAccessControlManaged.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport \"./interfaces/citadel/IMedianOracle.sol\";\n\n/**\n * @notice Sells a token at a predetermined price to whitelisted buyers.\n * TODO: Better revert strings\n */\ncontract Funding is GlobalAccessControlManaged, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // Roles used from GAC\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE = keccak256(\"TREASURY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_VAULT_ROLE =\n        keccak256(\"TREASURY_VAULT_ROLE\");\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    uint256 public constant MAX_BPS = 10000;\n\n    IERC20 public citadel; /// token to distribute (in vested xCitadel form)\n    IVault public xCitadel; /// wrapped citadel form that is actually distributed\n    IERC20 public asset; /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n\n    uint256 public citadelPriceInAsset; /// asset per citadel price eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public minCitadelPriceInAsset; /// Lower bound on expected citadel price in asset terms. Used as circuit breaker oracle.\n    uint256 public maxCitadelPriceInAsset; /// Upper bound on expected citadel price in asset terms. Used as circuit breaker oracle.\n    bool public citadelPriceFlag; /// Flag citadel price for review by guardian if it exceeds min and max bounds;\n\n    uint256 public assetDecimalsNormalizationValue;\n\n    address public citadelPriceInAssetOracle;\n    address public saleRecipient;\n\n    struct FundingParams {\n        uint256 discount;\n        uint256 minDiscount;\n        uint256 maxDiscount;\n        address discountManager;\n        uint256 assetCumulativeFunded; /// persistent sum of asset amount in over lifetime of contract.\n        uint256 assetCap; /// Max asset token that can be taken in by the contract (defines the cap for citadel sold)\n    }\n\n    FundingParams public funding;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    // TODO: we should conform to some interface here\n    event Deposit(\n        address indexed buyer,\n        uint256 assetIn,\n        uint256 citadelOutValue\n    );\n\n    event CitadelPriceInAssetUpdated(uint256 citadelPrice);\n\n    event CitadelPriceBoundsSet(uint256 minPrice, uint256 maxPrice);\n    event CitadelPriceFlag(uint256 price, uint256 minPrice, uint256 maxPrice);\n\n    event SaleRecipientUpdated(address indexed recipient);\n    event AssetCapUpdated(uint256 assetCap);\n\n    event Sweep(address indexed token, uint256 amount);\n    event ClaimToTreasury(address indexed token, uint256 amount);\n\n    modifier onlyCitadelPriceInAssetOracle() {\n        require(\n            msg.sender == citadelPriceInAssetOracle,\n            \"onlyCitadelPriceInAssetOracle\"\n        );\n        _;\n    }\n\n    event DiscountLimitsSet(uint256 minDiscount, uint256 maxDiscount);\n    event DiscountSet(uint256 discount);\n    event DiscountManagerSet(address discountManager);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _gac Global access control\n     * @param _citadel The token this contract will return in a trade\n     * @param _asset The token this contract will receive in a trade\n     * @param _xCitadel Staked citadel, citadel will be granted to funders in this form\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _assetCap The max asset that the contract can take\n     */\n    function initialize(\n        address _gac,\n        address _citadel,\n        address _asset,\n        address _xCitadel,\n        address _saleRecipient,\n        address _citadelPriceInAssetOracle,\n        uint256 _assetCap\n    ) external initializer {\n        require(\n            _saleRecipient != address(0),\n            \"Funding: 0 sale\"\n        );\n        require(\n            _citadelPriceInAssetOracle != address(0),\n            \"Funding: 0 oracle\"\n        );\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        citadel = IERC20(_citadel);\n        xCitadel = IVault(_xCitadel);\n        asset = IERC20(_asset);\n        saleRecipient = _saleRecipient;\n\n        citadelPriceInAssetOracle = _citadelPriceInAssetOracle;\n\n        funding = FundingParams(0, 0, 0, address(0), 0, _assetCap);\n\n        assetDecimalsNormalizationValue = 10**asset.decimals();\n\n        // No circuit breaker on price by default\n        minCitadelPriceInAsset = 0;\n        maxCitadelPriceInAsset = type(uint256).max;\n\n        // Allow to deposit in vault\n        // Done last for reEntrancy concerns\n        IERC20(_citadel).safeApprove(address(_xCitadel), type(uint256).max);\n    }\n\n    modifier onlyWhenPriceNotFlagged() {\n        require(\n            citadelPriceFlag == false,\n            \"Funding: citadel price from oracle flagged and pending review\"\n        );\n        _;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_assetAmountIn` of `asset` for `citadel`\n     * @param _assetAmountIn Amount of `asset` to give\n     * @param _minCitadelOut ID of DAO to vote for\n     * @return citadelAmount_ Amount of `xCitadel` bought\n     */\n    function deposit(uint256 _assetAmountIn, uint256 _minCitadelOut)\n        external\n        onlyWhenPriceNotFlagged\n        gacPausable\n        nonReentrant\n        returns (uint256 citadelAmount_)\n    {\n        require(_assetAmountIn > 0, \"_assetAmountIn must not be 0\");\n        require(\n            funding.assetCumulativeFunded + _assetAmountIn <= funding.assetCap,\n            \"asset funding cap exceeded\"\n        );\n        funding.assetCumulativeFunded = funding.assetCumulativeFunded + _assetAmountIn;\n        // Take in asset from user\n        citadelAmount_ = getAmountOut(_assetAmountIn);\n        require(citadelAmount_ >= _minCitadelOut, \"minCitadelOut\");\n\n        asset.safeTransferFrom(msg.sender, saleRecipient, _assetAmountIn);\n        \n        // Deposit xCitadel and send to user\n        // TODO: Check gas costs. How does this relate to market buying if you do want to deposit to xCTDL?\n        xCitadel.depositFor(msg.sender, citadelAmount_);\n\n        emit Deposit(\n            msg.sender,\n            _assetAmountIn,\n            citadelAmount_\n        );\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `asset`\n     * @param _assetAmountIn Amount of `asset` to exchange\n     * @return citadelAmount_ Amount of `citadel` received\n     */\n    function getAmountOut(uint256 _assetAmountIn)\n        public\n        view\n        returns (uint256 citadelAmount_)\n    {\n        uint256 citadelAmountWithoutDiscount = _assetAmountIn * citadelPriceInAsset;\n\n        if (funding.discount > 0) {\n            citadelAmount_ =\n                (citadelAmountWithoutDiscount * MAX_BPS) /\n                (MAX_BPS - funding.discount);\n        }\n\n        citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;\n    }\n\n    /**\n     * @notice Get the amount received when exchanging `asset`, in terms of xCitadel at current price per share\n     * @param _assetAmountIn Amount of `asset` to exchange\n     * @return xCitadelAmount_ Amount of `xCitadel` received at current price per share\n     */\n    function getStakedCitadelAmountOut(uint256 _assetAmountIn) public view returns (uint256 xCitadelAmount_) {\n        uint citadelAmount = getAmountOut(_assetAmountIn);\n        xCitadelAmount_ = citadelAmount * 10**citadel.decimals() / xCitadel.getPricePerFullShare();\n    }\n\n    /**\n     * @notice Check how much `asset` can still be taken in, based on cap and cumulative amount funded\n     * @return limitLeft_ Amount of `asset` that can still be exchanged for citadel\n     */\n    function getRemainingFundable() external view returns (uint256 limitLeft_) {\n        uint256 assetCumulativeFunded = funding.assetCumulativeFunded;\n        uint256 assetCap = funding.assetCap;\n        if (assetCumulativeFunded < assetCap) {\n            limitLeft_ = assetCap - assetCumulativeFunded;\n        }\n    }\n\n    /**\n     * @notice Get all funding params\n     * @return funding all funding params\n     */\n    function getFundingParams() external view returns (FundingParams memory) {\n        return funding;\n    }\n\n    /**\n     * @notice Convenience function to get current discount rate\n     * @return discount current discount rate\n     */\n    function getDiscount() external view returns (uint256) {\n        return funding.discount;\n    }\n\n    /// ==============================\n    /// ===== Policy Ops actions =====\n    /// ==============================\n\n    /**\n     * @notice Set discount manually, within the constraints of min and max discount values\n     * @dev managed by policy operations for rapid response to market conditions\n     * @param _discount active discount (in bps)\n     */\n    function setDiscount(uint256 _discount)\n        external\n        gacPausable\n        onlyRoleOrAddress(POLICY_OPERATIONS_ROLE, funding.discountManager)\n    {\n        require(_discount >= funding.minDiscount, \"discount < minDiscount\");\n        require(_discount <= funding.maxDiscount, \"discount > maxDiscount\");\n\n        funding.discount = _discount;\n\n        emit DiscountSet(_discount);\n    }\n\n    function clearCitadelPriceFlag()\n        external\n        gacPausable\n        onlyRole(POLICY_OPERATIONS_ROLE)\n    {\n        citadelPriceFlag = false;\n    }\n\n    /**\n     * @notice Modify the max asset amount that this contract can take. Managed by policy governance.\n     * @dev This is cumulative asset cap, so must take into account the asset amount already funded.\n     * @param _assetCap New max cumulatiive amountIn\n     */\n    function setAssetCap(uint256 _assetCap)\n        external\n        gacPausable\n        onlyRole(POLICY_OPERATIONS_ROLE)\n    {\n        require(\n            _assetCap > funding.assetCumulativeFunded,\n            \"cannot decrease cap below global sum of assets in\"\n        );\n        funding.assetCap = _assetCap;\n        emit AssetCapUpdated(_assetCap);\n    }\n\n    /// ================================\n    /// ===== Treasury Ops actions =====\n    /// ================================\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `asset` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `asset`. For `citadel`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token)\n        external\n        gacPausable\n        nonReentrant\n        onlyRole(TREASURY_OPERATIONS_ROLE)\n    {\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        require(amount > 0, \"nothing to sweep\");\n        require(\n            _token != address(asset),\n            \"cannot sweep funding asset, use claimAssetToTreasury()\"\n        );\n\n        emit Sweep(_token, amount);\n        IERC20(_token).safeTransfer(saleRecipient, amount);\n    }\n\n    /// @notice Claim accumulated asset token to treasury\n    /// @dev We let assets accumulate and batch transfer to treasury (rather than transfer atomically on each deposi)t for user gas savings\n    function claimAssetToTreasury()\n        external\n        gacPausable\n        onlyRole(TREASURY_OPERATIONS_ROLE)\n    {\n        uint256 amount = asset.balanceOf(address(this));\n        require(amount > 0, \"nothing to claim\");\n        asset.safeTransfer(saleRecipient, amount);\n\n        emit ClaimToTreasury(address(asset), amount);\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    /**\n     * @notice Set minimum and maximum discount\n     * @dev managed by contract governance to place constraints around the parameter for policy operations to play within\n     * @param _minDiscount minimum discount (in bps)\n     * @param _maxDiscount maximum discount (in bps)\n     */\n    function setDiscountLimits(uint256 _minDiscount, uint256 _maxDiscount)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(_maxDiscount < MAX_BPS , \"maxDiscount >= MAX_BPS\");\n        funding.minDiscount = _minDiscount;\n        funding.maxDiscount = _maxDiscount;\n\n        emit DiscountLimitsSet(_minDiscount, _maxDiscount);\n    }\n\n    /**\n     * @notice Set a discount manager address\n     * @dev This is intended to be used for an automated discount manager contract to supplement or replace manual calls\n     * @param _discountManager discount manager address\n     */\n    function setDiscountManager(address _discountManager)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        funding.discountManager = _discountManager;\n\n        emit DiscountManagerSet(_discountManager);\n    }\n\n    function setSaleRecipient(address _saleRecipient)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleRecipient != address(0),\n            \"Funding: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    function setCitadelAssetPriceBounds(uint256 _minPrice, uint256 _maxPrice)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        minCitadelPriceInAsset = _minPrice;\n        maxCitadelPriceInAsset = _maxPrice;\n\n        emit CitadelPriceBoundsSet(_minPrice, _maxPrice);\n    }\n\n    /// ==========================\n    /// ===== Oracle actions =====\n    /// ==========================\n\n    /// @notice Update citadel price in asset terms from oracle source\n    /// @dev Note that the oracle mechanics are abstracted to the oracle address\n    function updateCitadelPriceInAsset()\n        external\n        gacPausable\n        onlyRole(KEEPER_ROLE)\n    {   \n        uint _citadelPriceInAsset;\n        bool _valid;\n\n        (_citadelPriceInAsset, _valid) = IMedianOracle(citadelPriceInAssetOracle).getData();\n\n        require(_citadelPriceInAsset > 0, \"citadel price must not be zero\");\n        require(_valid, \"oracle data must be valid\");\n\n        if (\n            _citadelPriceInAsset < minCitadelPriceInAsset ||\n            _citadelPriceInAsset > maxCitadelPriceInAsset\n        ) {\n            citadelPriceFlag = true;\n            emit CitadelPriceFlag(\n                _citadelPriceInAsset,\n                minCitadelPriceInAsset,\n                maxCitadelPriceInAsset\n            );\n        } else {\n            citadelPriceInAsset = _citadelPriceInAsset;\n            emit CitadelPriceInAssetUpdated(_citadelPriceInAsset);\n        }\n    }\n\n\n    /// @dev OUT OF AUDIT SCOPE: This is a test function that will be removed in final code\n    /// @notice Update citadel price in asset terms from oracle source\n    /// @dev Note that the oracle mechanics are abstracted to the oracle address\n    function updateCitadelPriceInAsset(uint256 _citadelPriceInAsset)\n        external\n        gacPausable\n        onlyCitadelPriceInAssetOracle\n    {\n        require(_citadelPriceInAsset > 0, \"citadel price must not be zero\");\n\n        if (\n            _citadelPriceInAsset < minCitadelPriceInAsset ||\n            _citadelPriceInAsset > maxCitadelPriceInAsset\n        ) {\n            citadelPriceFlag = true;\n            emit CitadelPriceFlag(\n                _citadelPriceInAsset,\n                minCitadelPriceInAsset,\n                maxCitadelPriceInAsset\n            );\n        } else {\n            citadelPriceInAsset = _citadelPriceInAsset;\n            emit CitadelPriceInAssetUpdated(_citadelPriceInAsset);\n        }\n    }\n}"
    },
    {
      "filename": "src/KnightingRound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./interfaces/badger/IBadgerVipGuestlist.sol\";\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\n/**\n * @title Citadel Knighting Round\n * @notice Sells citadel at a predetermined price to whitelisted buyers. Citadel tokens are not distributed until the finalize event.\n * TODO: Better revert strings\n */\ncontract KnightingRound is GlobalAccessControlManaged, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for ERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant TREASURY_GOVERNANCE_ROLE =\n        keccak256(\"TREASURY_GOVERNANCE_ROLE\");\n\n    bytes32 public constant TECH_OPERATIONS_ROLE =\n        keccak256(\"TECH_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE =\n        keccak256(\"TREASURY_OPERATIONS_ROLE\");\n\n    /// token to give out (CTDL)\n    ERC20Upgradeable public tokenOut;\n    /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n    ERC20Upgradeable public tokenIn;\n    /// time when tokens can be first purchased\n    uint256 public saleStart;\n    /// duration of the token sale, cannot purchase afterwards\n    uint256 public saleDuration;\n    /// address receiving the proceeds of the sale - will be citadel multisig\n    address public saleRecipient;\n    /// whether the sale has been finalized\n    bool public finalized;\n\n    /// tokenIn per tokenOut price\n    /// eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public tokenOutPrice;\n\n    /// Amounts bought by accounts\n    mapping(address => uint256) public boughtAmounts;\n    /// Whether an account has claimed tokens\n    /// NOTE: can reset boughtAmounts after a claim to optimize gas\n    ///       but we need to persist boughtAmounts\n    mapping(address => bool) public hasClaimed;\n\n    /// Amount of `tokenIn` taken in\n    uint256 public totalTokenIn;\n    /// Amount of `tokenOut` sold\n    uint256 public totalTokenOutBought;\n    /// Amount of `tokenOut` claimed\n    uint256 public totalTokenOutClaimed;\n\n    /// Max tokenIn that can be taken by the contract (defines the cap for tokenOut sold)\n    uint256 public tokenInLimit;\n\n    uint256 public tokenInNormalizationValue;\n\n    /// Whitelist\n    IBadgerVipGuestlist public guestlist;\n\n    /// Amount vote for each DAO\n    mapping(uint8 => uint256) public daoCommitments;\n    mapping(address => uint8) public daoVotedFor;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Sale(\n        address indexed buyer,\n        uint8 indexed daoId,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event Claim(address indexed claimer, uint256 amount);\n    event Finalized();\n\n    event SaleStartUpdated(uint256 saleStart);\n    event SaleDurationUpdated(uint256 saleDuration);\n    event TokenOutPriceUpdated(uint256 tokenOutPrice);\n    event SaleRecipientUpdated(address indexed recipient);\n    event GuestlistUpdated(address indexed guestlist);\n    event TokenInLimitUpdated(uint256 tokenInLimit);\n\n    event Sweep(address indexed token, uint256 amount);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _tokenOut The token this contract will return in a trade (citadel)\n     * @param _tokenIn The token this contract will receive in a trade\n     * @param _saleStart The time when tokens can be first purchased\n     * @param _saleDuration The duration of the token sale\n     * @param _tokenOutPrice The tokenOut per tokenIn price\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _guestlist Address that will manage auction approvals\n     * @param _tokenInLimit The max tokenIn that the contract can take\n     */\n    function initialize(\n        address _globalAccessControl,\n        address _tokenOut,\n        address _tokenIn,\n        uint256 _saleStart,\n        uint256 _saleDuration,\n        uint256 _tokenOutPrice,\n        address _saleRecipient,\n        address _guestlist,\n        uint256 _tokenInLimit\n    ) external initializer {\n        require(\n            _saleStart >= block.timestamp,\n            \"KnightingRound: start date may not be in the past\"\n        );\n        require(\n            _saleDuration > 0,\n            \"KnightingRound: the sale duration must not be zero\"\n        );\n        require(\n            _tokenOutPrice > 0,\n            \"KnightingRound: the price must not be zero\"\n        );\n        require(\n            _saleRecipient != address(0),\n            \"KnightingRound: sale recipient should not be zero\"\n        );\n\n        __GlobalAccessControlManaged_init(_globalAccessControl);\n\n        tokenOut = ERC20Upgradeable(_tokenOut);\n        tokenIn = ERC20Upgradeable(_tokenIn);\n        saleStart = _saleStart;\n        saleDuration = _saleDuration;\n        tokenOutPrice = _tokenOutPrice;\n        saleRecipient = _saleRecipient;\n        guestlist = IBadgerVipGuestlist(_guestlist);\n        tokenInLimit = _tokenInLimit;\n\n        tokenInNormalizationValue = 10**tokenIn.decimals();\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_tokenInAmount` of `tokenIn` for `tokenOut`\n     * @param _tokenInAmount Amount of `tokenIn` to give\n     * @param _daoId ID of DAO to vote for\n     * @param _proof Merkle proof for the guestlist. Use `new bytes32[](0)` if there's no guestlist\n     * @return tokenOutAmount_ Amount of `tokenOut` bought\n     */\n    function buy(\n        uint256 _tokenInAmount,\n        uint8 _daoId,\n        bytes32[] calldata _proof\n    ) external gacPausable returns (uint256 tokenOutAmount_) {\n        require(saleStart <= block.timestamp, \"KnightingRound: not started\");\n        require(\n            block.timestamp < saleStart + saleDuration,\n            \"KnightingRound: already ended\"\n        );\n        require(_tokenInAmount > 0, \"_tokenInAmount should be > 0\");\n        require(\n            totalTokenIn + _tokenInAmount <= tokenInLimit,\n            \"total amount exceeded\"\n        );\n\n        if (address(guestlist) != address(0)) {\n            require(guestlist.authorized(msg.sender, _proof), \"not authorized\");\n        }\n\n        uint256 boughtAmountTillNow = boughtAmounts[msg.sender];\n\n        if (boughtAmountTillNow > 0) {\n            require(\n                _daoId == daoVotedFor[msg.sender],\n                \"can't vote for multiple daos\"\n            );\n        } else {\n            daoVotedFor[msg.sender] = _daoId;\n        }\n\n        tokenOutAmount_ = getAmountOut(_tokenInAmount);\n\n        boughtAmounts[msg.sender] = boughtAmountTillNow + tokenOutAmount_;\n        daoCommitments[_daoId] = daoCommitments[_daoId] + tokenOutAmount_;\n\n        totalTokenIn = totalTokenIn + _tokenInAmount;\n        totalTokenOutBought = totalTokenOutBought + tokenOutAmount_;\n\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n\n        emit Sale(msg.sender, _daoId, _tokenInAmount, tokenOutAmount_);\n    }\n\n    /**\n     * @notice Claim bought tokens after sale has been finalized\n     */\n    function claim() external gacPausable returns (uint256 tokenOutAmount_) {\n        require(finalized, \"sale not finalized\");\n        require(!hasClaimed[msg.sender], \"already claimed\");\n\n        tokenOutAmount_ = boughtAmounts[msg.sender];\n\n        require(tokenOutAmount_ > 0, \"nothing to claim\");\n\n        hasClaimed[msg.sender] = true;\n        totalTokenOutClaimed = totalTokenOutClaimed + tokenOutAmount_;\n\n        tokenOut.safeTransfer(msg.sender, tokenOutAmount_);\n\n        emit Claim(msg.sender, tokenOutAmount_);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `tokenIn`\n     * @param _tokenInAmount Amount of `tokenIn` to exchange\n     * @return tokenOutAmount_ Amount of `tokenOut` received\n     */\n    function getAmountOut(uint256 _tokenInAmount)\n        public\n        view\n        returns (uint256 tokenOutAmount_)\n    {\n        tokenOutAmount_ =\n            (_tokenInAmount * tokenOutPrice) /\n            tokenInNormalizationValue;\n    }\n\n    /**\n     * @notice Check how much `tokenIn` can still be taken in\n     * @return limitLeft_ Amount of `tokenIn` that can still be exchanged\n     */\n    function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {\n        if (totalTokenIn < tokenInLimit) {\n            limitLeft_ = tokenInLimit - totalTokenIn;\n        }\n    }\n\n    /**\n     * @notice Check if the sale has ended\n     * @return hasEnded_ True if the sale has ended\n     */\n    function saleEnded() public view returns (bool hasEnded_) {\n        hasEnded_ =\n            (block.timestamp >= saleStart + saleDuration) ||\n            (totalTokenIn >= tokenInLimit);\n    }\n\n    /// ====================================\n    /// ===== Permissioned: governance =====\n    /// ====================================\n\n    /**\n     * @notice Finalize the sale after sale duration. Can only be called by owner\n       @dev Ensure contract has enough `tokenOut` before calling\n     */\n    function finalize() external onlyRole(CONTRACT_GOVERNANCE_ROLE) {\n        require(!finalized, \"KnightingRound: already finalized\");\n        require(saleEnded(), \"KnightingRound: not finished\");\n        require(\n            tokenOut.balanceOf(address(this)) >= totalTokenOutBought,\n            \"KnightingRound: not enough balance\"\n        );\n\n        finalized = true;\n\n        emit Finalized();\n    }\n\n    /**\n     * @notice Update the sale start time. Can only be called by owner\n     * @param _saleStart New start time\n     */\n    function setSaleStart(uint256 _saleStart)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleStart >= block.timestamp,\n            \"KnightingRound: start date may not be in the past\"\n        );\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        saleStart = _saleStart;\n\n        emit SaleStartUpdated(_saleStart);\n    }\n\n    /**\n     * @notice Update sale duration. Can only be called by owner\n     * @param _saleDuration New duration\n     */\n    function setSaleDuration(uint256 _saleDuration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleDuration > 0,\n            \"KnightingRound: the sale duration must not be zero\"\n        );\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        saleDuration = _saleDuration;\n\n        emit SaleDurationUpdated(_saleDuration);\n    }\n\n    /**\n     * @notice Modify the tokenOut price in. Can only be called by owner\n     * @param _tokenOutPrice New tokenOut price\n     */\n    function setTokenOutPrice(uint256 _tokenOutPrice)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _tokenOutPrice > 0,\n            \"KnightingRound: the price must not be zero\"\n        );\n\n        tokenOutPrice = _tokenOutPrice;\n\n        emit TokenOutPriceUpdated(_tokenOutPrice);\n    }\n\n    /**\n     * @notice Update the `tokenIn` receipient address. Can only be called by owner\n     * @param _saleRecipient New recipient address\n     */\n    function setSaleRecipient(address _saleRecipient)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleRecipient != address(0),\n            \"KnightingRound: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    /// ============================\n    /// ===== Tech ops actions =====\n    /// ============================\n\n    /**\n     * @notice Update the guestlist address. Can only be called by owner\n     * @param _guestlist New guestlist address\n     */\n    function setGuestlist(address _guestlist)\n        external\n        onlyRole(TECH_OPERATIONS_ROLE)\n    {\n        guestlist = IBadgerVipGuestlist(_guestlist);\n\n        emit GuestlistUpdated(_guestlist);\n    }\n\n    /**\n     * @notice Modify the max tokenIn that this contract can take. Can only be called by owner\n     * @param _tokenInLimit New max amountIn\n     */\n    function setTokenInLimit(uint256 _tokenInLimit)\n        external\n        onlyRole(TECH_OPERATIONS_ROLE)\n    {\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        tokenInLimit = _tokenInLimit;\n\n        emit TokenInLimitUpdated(_tokenInLimit);\n    }\n\n    /// ================================\n    /// ===== Treasury Ops actions =====\n    /// ================================\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `tokenIn` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `tokenIn`. For `tokenOut`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token) external gacPausable nonReentrant onlyRole(TREASURY_OPERATIONS_ROLE) {\n        uint256 amount = ERC20Upgradeable(_token).balanceOf(address(this));\n\n        if (_token == address(tokenOut)) {\n            uint256 amountLeftToBeClaimed = totalTokenOutBought -\n                totalTokenOutClaimed;\n            amount = amount - amountLeftToBeClaimed;\n        }\n\n        require(amount > 0, \"nothing to sweep\");\n\n        emit Sweep(_token, amount);\n        ERC20Upgradeable(_token).safeTransfer(saleRecipient, amount);\n    }\n}"
    },
    {
      "filename": "src/StakedCitadel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/SettAccessControl.sol\";\n\nimport {IVault} from \"./interfaces/badger/IVault.sol\";\nimport {IVesting} from \"./interfaces/citadel/IVesting.sol\";\nimport {IStrategy} from \"./interfaces/badger/IStrategy.sol\";\nimport {IERC20} from \"./interfaces/erc20/IERC20.sol\";\nimport {IBadgerGuestlist} from \"./interfaces/badger/IBadgerGuestlist.sol\";\n\n/*\n    Source: https://github.com/iearn-finance/yearn-protocol/blob/develop/contracts/vaults/yVault.sol\n    \n    Changelog:\n\n    V1.1\n    * Strategist no longer has special function calling permissions\n    * Version function added to contract\n    * All write functions, with the exception of transfer, are pausable\n    * Keeper or governance can pause\n    * Only governance can unpause\n\n    V1.2\n    * Transfer functions are now pausable along with all other non-permissioned write functions\n    * All permissioned write functions, with the exception of pause() & unpause(), are pausable as well\n\n    V1.3\n    * Add guest list functionality\n    * All deposits can be optionally gated by external guestList approval logic on set guestList contract\n\n    V1.4\n    * Add depositFor() to deposit on the half of other users. That user will then be blockLocked.\n\n    V1.5\n    * Removed Controller\n        - Removed harvest from vault (only on strategy)\n    * Params added to track autocompounded rewards (lifeTimeEarned, lastHarvestedAt, lastHarvestAmount, assetsAtLastHarvest)\n      this would work"
    }
  ]
}