{
  "Title": "Memory Corruption on Load From Storage",
  "Content": "In the `Storage` library, the [`load` function](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/Storage.sol#L183) can load data from a storage location into a memory pointer location. The loaded data can further be specified by an offset in the storage and a length to enable loading data that spans over multiple slots.\n\n\nHowever, there is an edge case in the parameter input set that causes memory corruption. This is when data is loaded from an offset position, but the length is less than the remainder of the slot:\n\n\n\n\n```\nÂ storage slot: [ 0 ---------- 10 ---------- 20 ----------- 31 ]\n                             ^ offset\n                             <-- length -->\n                             <------- word remainder ------->\n\n```\n\n\nThe problem occurs because [the bitmask](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/Storage.sol#L202) is based on the word remainder instead of accounting for the length. This leads to extra bytes being written into memory (e.g., bytes 20 to 31 in the example above).\n\n\nThere are no significant consequences in the current version of the codebase. This is because all memory loads either [use a zero offset](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/StoreCore.sol#L743) or invoke the [three-parameter version](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/StoreCore.sol#L920) which [reserves sufficient space](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/Storage.sol#L168) to cover and ignore the unwanted bytes. Nevertheless, the library is intended to support external codebases and the inconsistency may lead to arbitrarily severe memory corruption.\n\n\nConsider respecting the length when constructing the bitmask as seen in the [`store` function](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/Storage.sol#L63-L75).\n\n\n***Update:** Resolved in [pull request #1978](https://github.com/latticexyz/mud/pull/1978).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/store/src/Storage.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { leftMask } from \"./leftMask.sol\";\nimport { Memory } from \"./Memory.sol\";\n\n/**\n * @title Storage Library\n * @dev Provides functions for low-level storage manipulation, including storing and retrieving bytes.\n */\nlibrary Storage {\n  /**\n   * @notice Store a single word of data at a specific storage pointer.\n   * @param storagePointer The location to store the data.\n   * @param data The 32-byte word of data to store.\n   */\n  function store(uint256 storagePointer, bytes32 data) internal {\n    assembly {\n      sstore(storagePointer, data)\n    }\n  }\n\n  /**\n   * @notice Store bytes of data at a specific storage pointer and offset.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param data Bytes to store.\n   */\n  function store(uint256 storagePointer, uint256 offset, bytes memory data) internal {\n    store(storagePointer, offset, Memory.dataPointer(data), data.length);\n  }\n\n  /**\n   * @notice Stores raw bytes to storage at a given pointer, offset, and length, keeping the rest of the word intact.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the start of the data in memory.\n   * @param length Length of the data in bytes.\n   */\n  function store(uint256 storagePointer, uint256 offset, uint256 memoryPointer, uint256 length) internal {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(length);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from memory and offset it to match storage\n          let bitOffset := mul(offset, 8)\n          mask := shr(bitOffset, mask)\n          let offsetData := shr(bitOffset, mload(memoryPointer))\n\n          sstore(\n            storagePointer,\n            or(\n              // Store the middle part\n              and(offsetData, mask),\n              // Preserve the surrounding parts\n              and(sload(storagePointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Store full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, mload(memoryPointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(\n          storagePointer,\n          or(\n            // store the left part\n            and(mload(memoryPointer), mask),\n            // preserve the right part\n            and(sload(storagePointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Set multiple storage locations to zero.\n   * @param storagePointer The starting storage location.\n   * @param length The number of storage locations to set to zero.\n   */\n  function zero(uint256 storagePointer, uint256 length) internal {\n    // Ceil division to round up to the nearest word\n    uint256 limit = storagePointer + (length + 31) / 32;\n    while (storagePointer < limit) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, 0)\n        storagePointer := add(storagePointer, 1)\n      }\n    }\n  }\n\n  /**\n   * @notice Load a single word of data from a specific storage pointer.\n   * @param storagePointer The location to load the data from.\n   * @return word The loaded 32-byte word of data.\n   */\n  function load(uint256 storagePointer) internal view returns (bytes32 word) {\n    assembly {\n      word := sload(storagePointer)\n    }\n  }\n\n  /**\n   * @notice Load raw bytes from storage at a given pointer, offset, and length.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes of data.\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes memory result) {\n    uint256 memoryPointer;\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Solidity's YulUtilFunctions::roundUpFunction\n      function round_up_to_mul_of_32(value) -> _result {\n        _result := and(add(value, 31), not(31))\n      }\n\n      // Allocate memory\n      result := mload(0x40)\n      memoryPointer := add(result, 0x20)\n      mstore(0x40, round_up_to_mul_of_32(add(memoryPointer, length)))\n      // Store length\n      mstore(result, length)\n    }\n    load(storagePointer, length, offset, memoryPointer);\n    return result;\n  }\n\n  /**\n   * @notice Append raw bytes from storage at a given pointer, offset, and length to a specific memory pointer.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the location in memory to append the data.\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset, uint256 memoryPointer) internal view {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(wordRemainder);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from storage and offset it to match memory\n          let offsetData := shl(mul(offset, 8), sload(storagePointer))\n\n          mstore(\n            memoryPointer,\n            or(\n              // store the middle part\n              and(offsetData, mask),\n              // preserve the surrounding parts\n              and(mload(memoryPointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Load full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(memoryPointer, sload(storagePointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(\n          memoryPointer,\n          or(\n            // store the left part\n            and(sload(storagePointer), mask),\n            // preserve the right part\n            and(mload(memoryPointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Load up to 32 bytes from storage at a given pointer and offset.\n   * @dev Since fields are tightly packed, they can span more than one slot.\n   * Since the they're max 32 bytes, they can span at most 2 slots.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes, left-aligned bytes. Bytes beyond the length are zeroed.\n   */\n  function loadField(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes32 result) {\n    if (offset >= 32) {\n      unchecked {\n        storagePointer += offset / 32;\n        offset %= 32;\n      }\n    }\n\n    // Extra data past length is not truncated\n    // This assumes that the caller will handle the overflow bits appropriately\n    assembly {\n      result := shl(mul(offset, 8), sload(storagePointer))\n    }\n\n    uint256 wordRemainder;\n    // (safe because of `offset %= 32` at the start)\n    unchecked {\n      wordRemainder = 32 - offset;\n    }\n\n    // Read from the next slot if field spans 2 slots\n    if (length > wordRemainder) {\n      assembly {\n        result := or(result, shr(mul(wordRemainder, 8), sload(add(storagePointer, 1))))\n      }\n    }\n  }\n}"
    },
    {
      "filename": "packages/store/src/Storage.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { leftMask } from \"./leftMask.sol\";\nimport { Memory } from \"./Memory.sol\";\n\n/**\n * @title Storage Library\n * @dev Provides functions for low-level storage manipulation, including storing and retrieving bytes.\n */\nlibrary Storage {\n  /**\n   * @notice Store a single word of data at a specific storage pointer.\n   * @param storagePointer The location to store the data.\n   * @param data The 32-byte word of data to store.\n   */\n  function store(uint256 storagePointer, bytes32 data) internal {\n    assembly {\n      sstore(storagePointer, data)\n    }\n  }\n\n  /**\n   * @notice Store bytes of data at a specific storage pointer and offset.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param data Bytes to store.\n   */\n  function store(uint256 storagePointer, uint256 offset, bytes memory data) internal {\n    store(storagePointer, offset, Memory.dataPointer(data), data.length);\n  }\n\n  /**\n   * @notice Stores raw bytes to storage at a given pointer, offset, and length, keeping the rest of the word intact.\n   * @param storagePointer The base storage location.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the start of the data in memory.\n   * @param length Length of the data in bytes.\n   */\n  function store(uint256 storagePointer, uint256 offset, uint256 memoryPointer, uint256 length) internal {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(length);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from memory and offset it to match storage\n          let bitOffset := mul(offset, 8)\n          mask := shr(bitOffset, mask)\n          let offsetData := shr(bitOffset, mload(memoryPointer))\n\n          sstore(\n            storagePointer,\n            or(\n              // Store the middle part\n              and(offsetData, mask),\n              // Preserve the surrounding parts\n              and(sload(storagePointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Store full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, mload(memoryPointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(\n          storagePointer,\n          or(\n            // store the left part\n            and(mload(memoryPointer), mask),\n            // preserve the right part\n            and(sload(storagePointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Set multiple storage locations to zero.\n   * @param storagePointer The starting storage location.\n   * @param length The number of storage locations to set to zero.\n   */\n  function zero(uint256 storagePointer, uint256 length) internal {\n    // Ceil division to round up to the nearest word\n    uint256 limit = storagePointer + (length + 31) / 32;\n    while (storagePointer < limit) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        sstore(storagePointer, 0)\n        storagePointer := add(storagePointer, 1)\n      }\n    }\n  }\n\n  /**\n   * @notice Load a single word of data from a specific storage pointer.\n   * @param storagePointer The location to load the data from.\n   * @return word The loaded 32-byte word of data.\n   */\n  function load(uint256 storagePointer) internal view returns (bytes32 word) {\n    assembly {\n      word := sload(storagePointer)\n    }\n  }\n\n  /**\n   * @notice Load raw bytes from storage at a given pointer, offset, and length.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes of data.\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes memory result) {\n    uint256 memoryPointer;\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Solidity's YulUtilFunctions::roundUpFunction\n      function round_up_to_mul_of_32(value) -> _result {\n        _result := and(add(value, 31), not(31))\n      }\n\n      // Allocate memory\n      result := mload(0x40)\n      memoryPointer := add(result, 0x20)\n      mstore(0x40, round_up_to_mul_of_32(add(memoryPointer, length)))\n      // Store length\n      mstore(result, length)\n    }\n    load(storagePointer, length, offset, memoryPointer);\n    return result;\n  }\n\n  /**\n   * @notice Append raw bytes from storage at a given pointer, offset, and length to a specific memory pointer.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @param memoryPointer Pointer to the location in memory to append the data.\n   */\n  function load(uint256 storagePointer, uint256 length, uint256 offset, uint256 memoryPointer) internal view {\n    if (offset > 0) {\n      // Support offsets that are greater than 32 bytes by incrementing the storagePointer and decrementing the offset\n      if (offset >= 32) {\n        unchecked {\n          storagePointer += offset / 32;\n          offset %= 32;\n        }\n      }\n\n      // For the first word, if there is an offset, apply a mask to beginning\n      if (offset > 0) {\n        // Get the word's remaining length after the offset\n        uint256 wordRemainder;\n        // (safe because of `offset %= 32` at the start)\n        unchecked {\n          wordRemainder = 32 - offset;\n        }\n\n        uint256 mask = leftMask(wordRemainder);\n        /// @solidity memory-safe-assembly\n        assembly {\n          // Load data from storage and offset it to match memory\n          let offsetData := shl(mul(offset, 8), sload(storagePointer))\n\n          mstore(\n            memoryPointer,\n            or(\n              // store the middle part\n              and(offsetData, mask),\n              // preserve the surrounding parts\n              and(mload(memoryPointer), not(mask))\n            )\n          )\n        }\n        // Return if done\n        if (length <= wordRemainder) return;\n\n        // Advance pointers\n        // (safe because of `length <= wordRemainder` earlier)\n        unchecked {\n          storagePointer += 1;\n          memoryPointer += wordRemainder;\n          length -= wordRemainder;\n        }\n      }\n    }\n\n    // Load full words\n    while (length >= 32) {\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(memoryPointer, sload(storagePointer))\n      }\n      unchecked {\n        storagePointer += 1;\n        memoryPointer += 32;\n        length -= 32;\n      }\n    }\n\n    // For the last partial word, apply a mask to the end\n    if (length > 0) {\n      uint256 mask = leftMask(length);\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore(\n          memoryPointer,\n          or(\n            // store the left part\n            and(sload(storagePointer), mask),\n            // preserve the right part\n            and(mload(memoryPointer), not(mask))\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * @notice Load up to 32 bytes from storage at a given pointer and offset.\n   * @dev Since fields are tightly packed, they can span more than one slot.\n   * Since the they're max 32 bytes, they can span at most 2 slots.\n   * @param storagePointer The base storage location.\n   * @param length Length of the data in bytes.\n   * @param offset Offset within the storage location.\n   * @return result The loaded bytes, left-aligned bytes. Bytes beyond the length are zeroed.\n   */\n  function loadField(uint256 storagePointer, uint256 length, uint256 offset) internal view returns (bytes32 result) {\n    if (offset >= 32) {\n      unchecked {\n        storagePointer += offset / 32;\n        offset %= 32;\n      }\n    }\n\n    // Extra data past length is not truncated\n    // This assumes that the caller will handle the overflow bits appropriately\n    assembly {\n      result := shl(mul(offset, 8), sload(storagePointer))\n    }\n\n    uint256 wordRemainder;\n    // (safe because of `offset %= 32` at the start)\n    unchecked {\n      wordRemainder = 32 - offset;\n    }\n\n    // Read from the next slot if field spans 2 slots\n    if (length > wordRemainder) {\n      assembly {\n        result := or(result, shr(mul(wordRemainder, 8), sload(add(storagePointer, 1))))\n      }\n    }\n  }\n}"
    },
    {
      "filename": "packages/store/src/StoreCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { STORE_VERSION } from \"./version.sol\";\nimport { Bytes } from \"./Bytes.sol\";\nimport { Storage } from \"./Storage.sol\";\nimport { Memory } from \"./Memory.sol\";\nimport { FieldLayout, FieldLayoutLib } from \"./FieldLayout.sol\";\nimport { Schema, SchemaLib } from \"./Schema.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { Slice, SliceLib } from \"./Slice.sol\";\nimport { StoreHooks, Tables, TablesTableId, ResourceIds, StoreHooksTableId } from \"./codegen/index.sol\";\nimport { _fieldLayout as TablesTableFieldLayout } from \"./codegen/tables/Tables.sol\";\nimport { IStoreErrors } from \"./IStoreErrors.sol\";\nimport { IStoreHook } from \"./IStoreHook.sol\";\nimport { StoreSwitch } from \"./StoreSwitch.sol\";\nimport { Hook, HookLib } from \"./Hook.sol\";\nimport { BEFORE_SET_RECORD, AFTER_SET_RECORD, BEFORE_SPLICE_STATIC_DATA, AFTER_SPLICE_STATIC_DATA, BEFORE_SPLICE_DYNAMIC_DATA, AFTER_SPLICE_DYNAMIC_DATA, BEFORE_DELETE_RECORD, AFTER_DELETE_RECORD } from \"./storeHookTypes.sol\";\nimport { ResourceId, ResourceIdInstance } from \"./ResourceId.sol\";\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"./storeResourceTypes.sol\";\n\n/**\n * @title StoreCore Library\n * @notice This library includes implementations for all IStore methods and events related to the store actions.\n */\nlibrary StoreCore {\n  using ResourceIdInstance for ResourceId;\n  /**\n   * @notice Emitted when a new record is set in the store.\n   * @param tableId The ID of the table where the record is set.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   */\n  event Store_SetRecord(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    bytes staticData,\n    PackedCounter encodedLengths,\n    bytes dynamicData\n  );\n\n  /**\n   * @notice Emitted when static data in the store is spliced.\n   * @dev In static data, data is always overwritten starting at the start position,\n   * so the total length of the data remains the same and no data is shifted.\n   * @param tableId The ID of the table where the data is spliced.\n   * @param keyTuple An array representing the key for the record.\n   * @param start The start position in bytes for the splice operation.\n   * @param data The data to write to the static data of the record at the start byte.\n   */\n  event Store_SpliceStaticData(ResourceId indexed tableId, bytes32[] keyTuple, uint48 start, bytes data);\n\n  /**\n   * @notice Emitted when dynamic data in the store is spliced.\n   * @param tableId The ID of the table where the data is spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param start The start position in bytes for the splice operation.\n   * @param deleteCount The number of bytes to delete in the splice operation.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param data The data to insert into the dynamic data of the record at the start byte.\n   */\n  event Store_SpliceDynamicData(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    uint48 start,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes data\n  );\n\n  /**\n   * @notice Emitted when a record is deleted from the store.\n   * @param tableId The ID of the table where the record is deleted.\n   * @param keyTuple An array representing the composite key for the record.\n   */\n  event Store_DeleteRecord(ResourceId indexed tableId, bytes32[] keyTuple);\n\n  /**\n   * @notice Initialize the store address in StoreSwitch.\n   * @dev Consumers must call this function in their constructor.\n   * StoreSwitch uses the storeAddress to decide where to write data to.\n   * If StoreSwitch is called in the context of a Store contract (storeAddress == address(this)),\n   * StoreSwitch uses internal methods to write data instead of external calls.\n   */\n  function initialize() internal {\n    StoreSwitch.setStoreAddress(address(this));\n  }\n\n  /**\n   * @notice Register core tables in the store.\n   * @dev Consumers must call this function in their constructor before setting\n   * any table data to allow indexers to decode table events.\n   */\n  function registerCoreTables() internal {\n    // Register core tables\n    Tables.register();\n    StoreHooks.register();\n    ResourceIds.register();\n  }\n\n  /************************************************************************\n   *\n   *    SCHEMA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Get the field layout for the given table ID.\n   * @param tableId The ID of the table for which to get the field layout.\n   * @return The field layout for the given table ID.\n   */\n  function getFieldLayout(ResourceId tableId) internal view returns (FieldLayout) {\n    // Explicit check for the Tables table to solve the bootstraping issue\n    // of the Tables table not having a field layout before it is registered\n    // since the field layout is stored in the Tables table.\n    if (ResourceId.unwrap(tableId) == ResourceId.unwrap(TablesTableId)) {\n      return TablesTableFieldLayout;\n    }\n    return\n      FieldLayout.wrap(\n        Storage.loadField({\n          storagePointer: StoreCoreInternal._getStaticDataLocation(TablesTableId, ResourceId.unwrap(tableId)),\n          length: 32,\n          offset: 0\n        })\n      );\n  }\n\n  /**\n   * @notice Get the key schema for the given table ID.\n   * @dev Reverts if the table ID is not registered.\n   * @param tableId The ID of the table for which to get the key schema.\n   * @return keySchema The key schema for the given table ID.\n   */\n  function getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    keySchema = Tables._getKeySchema(tableId);\n    // key schemas can be empty for singleton tables, so we can't depend on key schema for table check\n    if (!ResourceIds._getExists(tableId)) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n  }\n\n  /**\n   * @notice Get the value schema for the given table ID.\n   * @dev Reverts if the table ID is not registered.\n   * @param tableId The ID of the table for which to get the value schema.\n   * @return valueSchema The value schema for the given table ID.\n   */\n  function getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    valueSchema = Tables._getValueSchema(tableId);\n    if (valueSchema.isEmpty()) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n  }\n\n  /**\n   * @notice Register a new table with the given configuration.\n   * @dev This method reverts if\n   * - The table ID is not of type RESOURCE_TABLE or RESOURCE_OFFCHAIN_TABLE.\n   * - The field layout is invalid.\n   * - The key schema is invalid.\n   * - The value schema is invalid.\n   * - The number of key names does not match the number of key schema types.\n   * - The number of field names does not match the number of field layout fields.\n   * @param tableId The ID of the table to register.\n   * @param fieldLayout The field layout of the table.\n   * @param keySchema The key schema of the table.\n   * @param valueSchema The value schema of the table.\n   * @param keyNames The names of the keys in the table.\n   * @param fieldNames The names of the fields in the table.\n   */\n  function registerTable(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    string[] memory keyNames,\n    string[] memory fieldNames\n  ) internal {\n    // Verify the table ID is of type RESOURCE_TABLE\n    if (tableId.getType() != RESOURCE_TABLE && tableId.getType() != RESOURCE_OFFCHAIN_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Verify the field layout is valid\n    fieldLayout.validate({ allowEmpty: false });\n\n    // Verify the schema is valid\n    keySchema.validate({ allowEmpty: true });\n    valueSchema.validate({ allowEmpty: false });\n\n    // Verify the number of key names matches the number of key schema types\n    if (keyNames.length != keySchema.numFields()) {\n      revert IStoreErrors.Store_InvalidKeyNamesLength(keySchema.numFields(), keyNames.length);\n    }\n\n    // Verify the number of value names\n    if (fieldNames.length != fieldLayout.numFields()) {\n      revert IStoreErrors.Store_InvalidFieldNamesLength(fieldLayout.numFields(), fieldNames.length);\n    }\n\n    // Verify the number of value schema types\n    if (valueSchema.numFields() != fieldLayout.numFields()) {\n      revert IStoreErrors.Store_InvalidValueSchemaLength(fieldLayout.numFields(), valueSchema.numFields());\n    }\n\n    // Verify there is no resource with this ID yet\n    if (ResourceIds._getExists(tableId)) {\n      revert IStoreErrors.Store_TableAlreadyExists(tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Register the table metadata\n    Tables._set(tableId, fieldLayout, keySchema, valueSchema, abi.encode(keyNames), abi.encode(fieldNames));\n\n    // Register the table ID\n    ResourceIds._setExists(tableId, true);\n  }\n\n  /************************************************************************\n   *\n   *    REGISTER HOOKS\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Register hooks to be called when a record or field is set or deleted.\n   * @dev This method reverts for all resource IDs other than tables.\n   * Hooks are not supported for offchain tables.\n   * @param tableId The ID of the table to register the hook for.\n   * @param hookAddress The address of the hook contract to register.\n   * @param enabledHooksBitmap The bitmap of enabled hooks.\n   */\n  function registerStoreHook(ResourceId tableId, IStoreHook hookAddress, uint8 enabledHooksBitmap) internal {\n    // Hooks are only supported for tables, not for offchain tables\n    if (tableId.getType() != RESOURCE_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    StoreHooks.push(tableId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * @notice Unregister a hook from the given table ID.\n   * @param tableId The ID of the table to unregister the hook from.\n   * @param hookAddress The address of the hook to unregister.\n   */\n  function unregisterStoreHook(ResourceId tableId, IStoreHook hookAddress) internal {\n    HookLib.filterListByAddress(StoreHooksTableId, tableId, address(hookAddress));\n  }\n\n  /************************************************************************\n   *\n   *    SET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Set a full record for the given table ID and key tuple.\n   * @dev Calling this method emits a Store_SetRecord event.\n   * This method internally calls another overload of setRecord by fetching the field layout for the given table ID.\n   * If the field layout is available to the caller, it is recommended to use the other overload to avoid an additional storage read.\n   * @param tableId The ID of the table to set the record for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData\n  ) internal {\n    setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Set a full data record for the given table ID, key tuple, and field layout.\n   * @dev For onchain tables, the method emits a `Store_SetRecord` event, updates the data in storage,\n   * calls `onBeforeSetRecord` hooks before actually modifying the state, and calls `onAfterSetRecord`\n   * hooks after modifying the state. For offchain tables, the method returns early after emitting the\n   * event without calling hooks or modifying the state.\n   * @param tableId The ID of the table to set the record for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   * @param fieldLayout The field layout for the record.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) internal {\n    // Emit event to notify indexers\n    emit Store_SetRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n\n    // Early return if the table is an offchain table\n    if (tableId.getType() != RESOURCE_TABLE) {\n      return;\n    }\n\n    // Call onBeforeSetRecord hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SET_RECORD)) {\n        IStoreHook(hook.getAddress()).onBeforeSetRecord(\n          tableId,\n          keyTuple,\n          staticData,\n          encodedLengths,\n          dynamicData,\n          fieldLayout\n        );"
    }
  ]
}