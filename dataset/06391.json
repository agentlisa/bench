{
  "Title": "[M-01] A Dutch trade could end up with an unintended lower closing price",
  "Content": "\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/trading/DutchTrade.sol#L160> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RevenueTrader.sol#L46> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BackingManager.sol#L81>\n\n`notTradingPausedOrFrozen` that is turned on and off during an open Dutch trade could have the auction closed with a lower price depending on the timimg, leading to lesser capability to boost the Rtoken and/or stRSR exchange rates as well as a weakened recollaterization.\n\n### Proof of Concept\n\nHere's the scenario:\n\n1.  A 30 minute Dutch trade is opened by the Revenue trader selling a suplus token for Rtoken.\n\n2.  Shortly after the price begins to decrease linearly, Alice calls [`bid()`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/trading/DutchTrade.sol#L146-L164). As can be seen in line 160 of the code block below, `settleTrade()` is externally called on the `origin`, RevenueTrader.sol in this case:\n\n```solidity\n    function bid() external returns (uint256 amountIn) {\n        require(bidder == address(0), \"bid already received\");\n\n        // {qBuyTok}\n        amountIn = bidAmount(uint48(block.timestamp)); // enforces auction ongoing\n\n        // Transfer in buy tokens\n        bidder = msg.sender;\n        buy.safeTransferFrom(bidder, address(this), amountIn);\n\n        // status must begin OPEN\n        assert(status == TradeStatus.OPEN);\n\n        // settle() via callback\n160:        origin.settleTrade(sell);\n\n        // confirm callback succeeded\n        assert(status == TradeStatus.CLOSED);\n    }\n```\n\n3.  However, her call is preceded by [`pauseTrading()`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/mixins/Auth.sol#L169-L172) invoked by a `PAUSER`, and denied on line 46 of the function below:\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RevenueTrader.sol#L43-L52>\n\n```solidity\n    function settleTrade(IERC20 sell)\n        public\n        override(ITrading, TradingP1)\n46:        notTradingPausedOrFrozen\n        returns (ITrade trade)\n    {\n        trade = super.settleTrade(sell); // nonReentrant\n        distributeTokenToBuy();\n        // unlike BackingManager, do _not_ chain trades; b2b trades of the same token are unlikely\n    }\n```\n\n4.  As the auction is nearing to `endTime`, the `PAUSER` calls [`unpauseIssuance()`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/mixins/Auth.sol#L176-L179).\n\n5.  Bob, the late comer, upon seeing this, proceeds to calling `bid()` and gets the sell token for a price much lower than he would initially expect before the trading pause.\n\n\n### Recommended Mitigation Steps\n\nConsider removing `notTradingPausedOrFrozen` from the function visibility of `RevenueTrader.settleTrade` and `BackingManager.settleTrade`. This will also have a good side effect of allowing the settling of a Gnosis trade if need be. Collectively, the settled trades could at least proceed to helping boost the RToken and/or stRSR exchange rates that is conducive to the token holders redeeming and withdrawing. The same shall apply to enhancing recollaterization, albeit future tradings will be halted if the trading pause is still enabled.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/48#issuecomment-1613819858):**\n > This also seems like QA.  It outlines a very specific set of events that are very unlikely to occur during production scenarios and would additionally come down to admin misconfiguration / mismanagement.  will wait for sponsor comment, but most likely downgrade to QA.\n\n > > - The PAUSER role should be assigned to an address that is able to act quickly in response to off-chain events, such as a Chainlink feed failing. It is acceptable for there to be false positives, since redemption remains enabled.\n> \n> It is good to consider this quote from the documentation stating that pausing may have false positives. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/48#issuecomment-1618926905):**\n > @0xean - We believe a malicious pauser attack vector is dangerous enough that the issue is Medium and deserves a mitigation. Agree with suggested mitigation.\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Allow settle trade when paused or frozen.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/876\n\n**Status:** Mitigation confirmed. Full details in reports from [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/5), [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/32), and [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/9) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/trading/DutchTrade.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"../../interfaces/ITrade.sol\";\n\nuint192 constant FORTY_PERCENT = 4e17; // {1} 0.4\nuint192 constant SIXTY_PERCENT = 6e17; // {1} 0.6\n\n// Exponential price decay with base (999999/1000000). Price starts at 1000x and decays to 1x\n//   A 30-minute auction on a chain with a 12-second blocktime has a ~10.87% price drop per block\n//   during the geometric/exponential period and a 0.05% drop during the linear period.\n//   30-minutes is the recommended length of auction for a chain with 12-second blocktimes, but\n//   longer and shorter times can be used as well. The pricing algorithm does not degrade\n//   beyond the degree to which less overall blocktime means necessarily larger price drops.\nuint192 constant MAX_EXP = 6907752 * FIX_ONE; // {1} (1000000/999999)^6907752 = ~1000x\nuint192 constant BASE = 999999e12; // {1} (999999/1000000)\n\n/**\n * @title DutchTrade\n * @notice Implements a wholesale dutch auction via a piecewise falling-price mechansim.\n *   Over the first 40% of the auction the price falls from ~1000x the best plausible price\n *   down to the best plausible price in a geometric series. The price decreases by the same %\n *   each time. At 30 minutes the decreases are 10.87% per block. Longer auctions have\n *   smaller price decreases, and shorter auctions have larger price decreases.\n *   This period DOES NOT expect to receive a bid; it just defends against manipulated prices.\n *\n *   Over the last 60% of the auction the price falls from the best plausible price to the worst\n *   price, linearly. The worst price is further discounted by the maxTradeSlippage as a fraction\n *   of how far from minTradeVolume to maxTradeVolume the trade lies.\n *   At maxTradeVolume, no further discount is applied.\n *\n * To bid:\n * - Call `bidAmount()` view to check prices at various timestamps\n * - Wait until a desirable block is reached (hopefully not in the first 40% of the auction)\n * - Provide approval of buy tokens and call bid(). The swap will be atomic\n */\ncontract DutchTrade is ITrade {\n    using FixLib for uint192;\n    using SafeERC20 for IERC20Metadata;\n\n    TradeKind public constant KIND = TradeKind.DUTCH_AUCTION;\n\n    TradeStatus public status; // reentrancy protection\n\n    ITrading public origin; // the address that initialized the contract\n\n    // === Auction ===\n    IERC20Metadata public sell;\n    IERC20Metadata public buy;\n    uint192 public sellAmount; // {sellTok}\n\n    // The auction runs from [startTime, endTime], inclusive\n    uint48 public startTime; // {s} when the dutch auction begins (12s after init())\n    uint48 public endTime; // {s} when the dutch auction ends if no bids are received\n\n    // highPrice is always 1000x the middlePrice, so we don't need to track it explicitly\n    uint192 public middlePrice; // {buyTok/sellTok} The price at which the function is piecewise\n    uint192 public lowPrice; // {buyTok/sellTok} The price the auction ends at\n\n    // === Bid ===\n    address public bidder;\n    // the bid amount is just whatever token balance is in the contract at settlement time\n\n    // This modifier both enforces the state-machine pattern and guards against reentrancy.\n    modifier stateTransition(TradeStatus begin, TradeStatus end) {\n        require(status == begin, \"Invalid trade state\");\n        status = TradeStatus.PENDING;\n        _;\n        assert(status == TradeStatus.PENDING);\n        status = end;\n    }\n\n    // === Public Bid Helper ===\n\n    /// Calculates how much buy token is needed to purchase the lot, at a particular timestamp\n    /// @param timestamp {s} The block timestamp to get price for\n    /// @return {qBuyTok} The amount of buy tokens required to purchase the lot\n    function bidAmount(uint48 timestamp) public view returns (uint256) {\n        require(timestamp >= startTime, \"auction not started\");\n        require(timestamp <= endTime, \"auction over\");\n\n        // {buyTok/sellTok}\n        uint192 price = _price(timestamp);\n\n        // {qBuyTok} = {sellTok} * {buyTok/sellTok} * {qBuyTok/buyTok}\n        return sellAmount.mul(price, CEIL).shiftl_toUint(int8(buy.decimals()), CEIL);\n    }\n\n    // === External ===\n\n    /// @param origin_ The Trader that originated the trade\n    /// @param sell_ The asset being sold by the protocol\n    /// @param buy_ The asset being bought by the protocol\n    /// @param sellAmount_ {qSellTok} The amount to sell in the auction, in token quanta\n    /// @param auctionLength {s} How many seconds the dutch auction should run for\n    function init(\n        ITrading origin_,\n        IAsset sell_,\n        IAsset buy_,\n        uint256 sellAmount_,\n        uint48 auctionLength\n    ) external stateTransition(TradeStatus.NOT_STARTED, TradeStatus.OPEN) {\n        assert(\n            address(sell_) != address(0) &&\n                address(buy_) != address(0) &&\n                auctionLength >= 2 * ONE_BLOCK\n        ); // misuse by caller\n\n        // Only start dutch auctions under well-defined prices\n        (uint192 sellLow, uint192 sellHigh) = sell_.price(); // {UoA/sellTok}\n        (uint192 buyLow, uint192 buyHigh) = buy_.price(); // {UoA/buyTok}\n        require(sellLow > 0 && sellHigh < FIX_MAX, \"bad sell pricing\");\n        require(buyLow > 0 && buyHigh < FIX_MAX, \"bad buy pricing\");\n\n        origin = origin_;\n        sell = sell_.erc20();\n        buy = buy_.erc20();\n\n        require(sellAmount_ <= sell.balanceOf(address(this)), \"unfunded trade\");\n        sellAmount = shiftl_toFix(sellAmount_, -int8(sell.decimals())); // {sellTok}\n        startTime = uint48(block.timestamp) + ONE_BLOCK; // start in the next block\n        endTime = startTime + auctionLength;\n\n        // {1}\n        uint192 slippage = _slippage(\n            sellAmount.mul(sellHigh, FLOOR), // auctionVolume\n            origin.minTradeVolume(), // minTradeVolume\n            fixMin(sell_.maxTradeVolume(), buy_.maxTradeVolume()) // maxTradeVolume\n        );\n\n        // {buyTok/sellTok} = {UoA/sellTok} * {1} / {UoA/buyTok}\n        lowPrice = sellLow.mulDiv(FIX_ONE - slippage, buyHigh, FLOOR);\n        middlePrice = sellHigh.div(buyLow, CEIL); // no additional slippage\n        // highPrice = 1000 * middlePrice\n\n        assert(lowPrice <= middlePrice);\n    }\n\n    /// Bid for the auction lot at the current price; settling atomically via a callback\n    /// @dev Caller must have provided approval\n    /// @return amountIn {qBuyTok} The quantity of tokens the bidder paid\n    function bid() external returns (uint256 amountIn) {\n        require(bidder == address(0), \"bid already received\");\n\n        // {qBuyTok}\n        amountIn = bidAmount(uint48(block.timestamp)); // enforces auction ongoing\n\n        // Transfer in buy tokens\n        bidder = msg.sender;\n        buy.safeTransferFrom(bidder, address(this), amountIn);\n\n        // status must begin OPEN\n        assert(status == TradeStatus.OPEN);\n\n        // settle() via callback\n        origin.settleTrade(sell);\n\n        // confirm callback succeeded\n        assert(status == TradeStatus.CLOSED);\n    }\n\n    /// Settle the auction, emptying the contract of balances\n    /// @return soldAmt {qSellTok} Token quantity sold by the protocol\n    /// @return boughtAmt {qBuyTok} Token quantity purchased by the protocol\n    function settle()\n        external\n        stateTransition(TradeStatus.OPEN, TradeStatus.CLOSED)\n        returns (uint256 soldAmt, uint256 boughtAmt)\n    {\n        require(msg.sender == address(origin), \"only origin can settle\");\n\n        // Received bid\n        if (bidder != address(0)) {\n            sell.safeTransfer(bidder, sellAmount);\n        } else {\n            require(block.timestamp >= endTime, \"auction not over\");\n        }\n\n        uint256 sellBal = sell.balanceOf(address(this));\n        soldAmt = sellAmount > sellBal ? sellAmount - sellBal : 0;\n        boughtAmt = buy.balanceOf(address(this));\n\n        // Transfer balances back to origin\n        buy.safeTransfer(address(origin), boughtAmt);\n        sell.safeTransfer(address(origin), sellBal);\n    }\n\n    /// Anyone can transfer any ERC20 back to the origin after the trade has been closed\n    /// @dev Escape hatch in case of accidentally transferred tokens after auction end\n    /// @custom:interaction CEI (and respects the state lock)\n    function transferToOriginAfterTradeComplete(IERC20Metadata erc20) external {\n        require(status == TradeStatus.CLOSED, \"only after trade is closed\");\n        erc20.safeTransfer(address(origin), erc20.balanceOf(address(this)));\n    }\n\n    /// @return True if the trade can be settled.\n    // Guaranteed to be true some time after init(), until settle() is called\n    function canSettle() external view returns (bool) {\n        return status == TradeStatus.OPEN && (bidder != address(0) || block.timestamp > endTime);\n    }\n\n    // === Private ===\n\n    /// Return a sliding % from 0 (at maxTradeVolume) to maxTradeSlippage (at minTradeVolume)\n    /// @param auctionVolume {UoA} The actual auction volume\n    /// @param minTradeVolume {UoA} The minimum trade volume\n    /// @param maxTradeVolume {UoA} The maximum trade volume\n    /// @return slippage {1} The fraction of auctionVolume that should be permitted as slippage\n    function _slippage(\n        uint192 auctionVolume,\n        uint192 minTradeVolume,\n        uint192 maxTradeVolume\n    ) private view returns (uint192 slippage) {\n        slippage = origin.maxTradeSlippage(); // {1}\n        if (maxTradeVolume <= minTradeVolume || auctionVolume < minTradeVolume) return slippage;\n        if (auctionVolume > maxTradeVolume) return 0; // 0% slippage beyond maxTradeVolume\n\n        // {1} = {1} * ({UoA} - {UoA}} / ({UoA} - {UoA})\n        return\n            slippage.mul(\n                FIX_ONE - divuu(auctionVolume - minTradeVolume, maxTradeVolume - minTradeVolume)\n            );\n    }\n\n    /// Return the price of the auction at a particular timestamp\n    /// @param timestamp {s} The block timestamp\n    /// @return {buyTok/sellTok}\n    function _price(uint48 timestamp) private view returns (uint192) {\n        /// Price Curve:\n        ///   - first 40%: geometrically decrease the price from 1000x the middlePrice to 1x\n        ///   - last 60: decrease linearly from middlePrice to lowPrice\n\n        uint192 progression = divuu(timestamp - startTime, endTime - startTime); // {1}\n\n        // Fast geometric decay -- 0%-40% of auction\n        if (progression < FORTY_PERCENT) {\n            uint192 exp = MAX_EXP.mulDiv(FORTY_PERCENT - progression, FORTY_PERCENT, ROUND);\n\n            // middlePrice * ((1000000/999999) ^ exp) = middlePrice / ((999999/1000000) ^ exp)\n            // safe uint48 downcast: exp is at-most 6907752\n            // {buyTok/sellTok} = {buyTok/sellTok} / {1} ^ {1}\n            return middlePrice.div(BASE.powu(uint48(exp.toUint(ROUND))), CEIL);\n            // this reverts for middlePrice >= 6.21654046e36 * FIX_ONE\n        }\n\n        // Slow linear decay -- 40%-100% of auction\n        return\n            middlePrice -\n            (middlePrice - lowPrice).mulDiv(progression - FORTY_PERCENT, SIXTY_PERCENT);\n    }\n}"
    },
    {
      "filename": "contracts/plugins/trading/DutchTrade.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"../../interfaces/ITrade.sol\";\n\nuint192 constant FORTY_PERCENT = 4e17; // {1} 0.4\nuint192 constant SIXTY_PERCENT = 6e17; // {1} 0.6\n\n// Exponential price decay with base (999999/1000000). Price starts at 1000x and decays to 1x\n//   A 30-minute auction on a chain with a 12-second blocktime has a ~10.87% price drop per block\n//   during the geometric/exponential period and a 0.05% drop during the linear period.\n//   30-minutes is the recommended length of auction for a chain with 12-second blocktimes, but\n//   longer and shorter times can be used as well. The pricing algorithm does not degrade\n//   beyond the degree to which less overall blocktime means necessarily larger price drops.\nuint192 constant MAX_EXP = 6907752 * FIX_ONE; // {1} (1000000/999999)^6907752 = ~1000x\nuint192 constant BASE = 999999e12; // {1} (999999/1000000)\n\n/**\n * @title DutchTrade\n * @notice Implements a wholesale dutch auction via a piecewise falling-price mechansim.\n *   Over the first 40% of the auction the price falls from ~1000x the best plausible price\n *   down to the best plausible price in a geometric series. The price decreases by the same %\n *   each time. At 30 minutes the decreases are 10.87% per block. Longer auctions have\n *   smaller price decreases, and shorter auctions have larger price decreases.\n *   This period DOES NOT expect to receive a bid; it just defends against manipulated prices.\n *\n *   Over the last 60% of the auction the price falls from the best plausible price to the worst\n *   price, linearly. The worst price is further discounted by the maxTradeSlippage as a fraction\n *   of how far from minTradeVolume to maxTradeVolume the trade lies.\n *   At maxTradeVolume, no further discount is applied.\n *\n * To bid:\n * - Call `bidAmount()` view to check prices at various timestamps\n * - Wait until a desirable block is reached (hopefully not in the first 40% of the auction)\n * - Provide approval of buy tokens and call bid(). The swap will be atomic\n */\ncontract DutchTrade is ITrade {\n    using FixLib for uint192;\n    using SafeERC20 for IERC20Metadata;\n\n    TradeKind public constant KIND = TradeKind.DUTCH_AUCTION;\n\n    TradeStatus public status; // reentrancy protection\n\n    ITrading public origin; // the address that initialized the contract\n\n    // === Auction ===\n    IERC20Metadata public sell;\n    IERC20Metadata public buy;\n    uint192 public sellAmount; // {sellTok}\n\n    // The auction runs from [startTime, endTime], inclusive\n    uint48 public startTime; // {s} when the dutch auction begins (12s after init())\n    uint48 public endTime; // {s} when the dutch auction ends if no bids are received\n\n    // highPrice is always 1000x the middlePrice, so we don't need to track it explicitly\n    uint192 public middlePrice; // {buyTok/sellTok} The price at which the function is piecewise\n    uint192 public lowPrice; // {buyTok/sellTok} The price the auction ends at\n\n    // === Bid ===\n    address public bidder;\n    // the bid amount is just whatever token balance is in the contract at settlement time\n\n    // This modifier both enforces the state-machine pattern and guards against reentrancy.\n    modifier stateTransition(TradeStatus begin, TradeStatus end) {\n        require(status == begin, \"Invalid trade state\");\n        status = TradeStatus.PENDING;\n        _;\n        assert(status == TradeStatus.PENDING);\n        status = end;\n    }\n\n    // === Public Bid Helper ===\n\n    /// Calculates how much buy token is needed to purchase the lot, at a particular timestamp\n    /// @param timestamp {s} The block timestamp to get price for\n    /// @return {qBuyTok} The amount of buy tokens required to purchase the lot\n    function bidAmount(uint48 timestamp) public view returns (uint256) {\n        require(timestamp >= startTime, \"auction not started\");\n        require(timestamp <= endTime, \"auction over\");\n\n        // {buyTok/sellTok}\n        uint192 price = _price(timestamp);\n\n        // {qBuyTok} = {sellTok} * {buyTok/sellTok} * {qBuyTok/buyTok}\n        return sellAmount.mul(price, CEIL).shiftl_toUint(int8(buy.decimals()), CEIL);\n    }\n\n    // === External ===\n\n    /// @param origin_ The Trader that originated the trade\n    /// @param sell_ The asset being sold by the protocol\n    /// @param buy_ The asset being bought by the protocol\n    /// @param sellAmount_ {qSellTok} The amount to sell in the auction, in token quanta\n    /// @param auctionLength {s} How many seconds the dutch auction should run for\n    function init(\n        ITrading origin_,\n        IAsset sell_,\n        IAsset buy_,\n        uint256 sellAmount_,\n        uint48 auctionLength\n    ) external stateTransition(TradeStatus.NOT_STARTED, TradeStatus.OPEN) {\n        assert(\n            address(sell_) != address(0) &&\n                address(buy_) != address(0) &&\n                auctionLength >= 2 * ONE_BLOCK\n        ); // misuse by caller\n\n        // Only start dutch auctions under well-defined prices\n        (uint192 sellLow, uint192 sellHigh) = sell_.price(); // {UoA/sellTok}\n        (uint192 buyLow, uint192 buyHigh) = buy_.price(); // {UoA/buyTok}\n        require(sellLow > 0 && sellHigh < FIX_MAX, \"bad sell pricing\");\n        require(buyLow > 0 && buyHigh < FIX_MAX, \"bad buy pricing\");\n\n        origin = origin_;\n        sell = sell_.erc20();\n        buy = buy_.erc20();\n\n        require(sellAmount_ <= sell.balanceOf(address(this)), \"unfunded trade\");\n        sellAmount = shiftl_toFix(sellAmount_, -int8(sell.decimals())); // {sellTok}\n        startTime = uint48(block.timestamp) + ONE_BLOCK; // start in the next block\n        endTime = startTime + auctionLength;\n\n        // {1}\n        uint192 slippage = _slippage(\n            sellAmount.mul(sellHigh, FLOOR), // auctionVolume\n            origin.minTradeVolume(), // minTradeVolume\n            fixMin(sell_.maxTradeVolume(), buy_.maxTradeVolume()) // maxTradeVolume\n        );\n\n        // {buyTok/sellTok} = {UoA/sellTok} * {1} / {UoA/buyTok}\n        lowPrice = sellLow.mulDiv(FIX_ONE - slippage, buyHigh, FLOOR);\n        middlePrice = sellHigh.div(buyLow, CEIL); // no additional slippage\n        // highPrice = 1000 * middlePrice\n\n        assert(lowPrice <= middlePrice);\n    }\n\n    /// Bid for the auction lot at the current price; settling atomically via a callback\n    /// @dev Caller must have provided approval\n    /// @return amountIn {qBuyTok} The quantity of tokens the bidder paid\n    function bid() external returns (uint256 amountIn) {\n        require(bidder == address(0), \"bid already received\");\n\n        // {qBuyTok}\n        amountIn = bidAmount(uint48(block.timestamp)); // enforces auction ongoing\n\n        // Transfer in buy tokens\n        bidder = msg.sender;\n        buy.safeTransferFrom(bidder, address(this), amountIn);\n\n        // status must begin OPEN\n        assert(status == TradeStatus.OPEN);\n\n        // settle() via callback\n        origin.settleTrade(sell);\n\n        // confirm callback succeeded\n        assert(status == TradeStatus.CLOSED);\n    }\n\n    /// Settle the auction, emptying the contract of balances\n    /// @return soldAmt {qSellTok} Token quantity sold by the protocol\n    /// @return boughtAmt {qBuyTok} Token quantity purchased by the protocol\n    function settle()\n        external\n        stateTransition(TradeStatus.OPEN, TradeStatus.CLOSED)\n        returns (uint256 soldAmt, uint256 boughtAmt)\n    {\n        require(msg.sender == address(origin), \"only origin can settle\");\n\n        // Received bid\n        if (bidder != address(0)) {\n            sell.safeTransfer(bidder, sellAmount);\n        } else {\n            require(block.timestamp >= endTime, \"auction not over\");\n        }\n\n        uint256 sellBal = sell.balanceOf(address(this));\n        soldAmt = sellAmount > sellBal ? sellAmount - sellBal : 0;\n        boughtAmt = buy.balanceOf(address(this));\n\n        // Transfer balances back to origin\n        buy.safeTransfer(address(origin), boughtAmt);\n        sell.safeTransfer(address(origin), sellBal);\n    }\n\n    /// Anyone can transfer any ERC20 back to the origin after the trade has been closed\n    /// @dev Escape hatch in case of accidentally transferred tokens after auction end\n    /// @custom:interaction CEI (and respects the state lock)\n    function transferToOriginAfterTradeComplete(IERC20Metadata erc20) external {\n        require(status == TradeStatus.CLOSED, \"only after trade is closed\");\n        erc20.safeTransfer(address(origin), erc20.balanceOf(address(this)));\n    }\n\n    /// @return True if the trade can be settled.\n    // Guaranteed to be true some time after init(), until settle() is called\n    function canSettle() external view returns (bool) {\n        return status == TradeStatus.OPEN && (bidder != address(0) || block.timestamp > endTime);\n    }\n\n    // === Private ===\n\n    /// Return a sliding % from 0 (at maxTradeVolume) to maxTradeSlippage (at minTradeVolume)\n    /// @param auctionVolume {UoA} The actual auction volume\n    /// @param minTradeVolume {UoA} The minimum trade volume\n    /// @param maxTradeVolume {UoA} The maximum trade volume\n    /// @return slippage {1} The fraction of auctionVolume that should be permitted as slippage\n    function _slippage(\n        uint192 auctionVolume,\n        uint192 minTradeVolume,\n        uint192 maxTradeVolume\n    ) private view returns (uint192 slippage) {\n        slippage = origin.maxTradeSlippage(); // {1}\n        if (maxTradeVolume <= minTradeVolume || auctionVolume < minTradeVolume) return slippage;\n        if (auctionVolume > maxTradeVolume) return 0; // 0% slippage beyond maxTradeVolume\n\n        // {1} = {1} * ({UoA} - {UoA}} / ({UoA} - {UoA})\n        return\n            slippage.mul(\n                FIX_ONE - divuu(auctionVolume - minTradeVolume, maxTradeVolume - minTradeVolume)\n            );\n    }\n\n    /// Return the price of the auction at a particular timestamp\n    /// @param timestamp {s} The block timestamp\n    /// @return {buyTok/sellTok}\n    function _price(uint48 timestamp) private view returns (uint192) {\n        /// Price Curve:\n        ///   - first 40%: geometrically decrease the price from 1000x the middlePrice to 1x\n        ///   - last 60: decrease linearly from middlePrice to lowPrice\n\n        uint192 progression = divuu(timestamp - startTime, endTime - startTime); // {1}\n\n        // Fast geometric decay -- 0%-40% of auction\n        if (progression < FORTY_PERCENT) {\n            uint192 exp = MAX_EXP.mulDiv(FORTY_PERCENT - progression, FORTY_PERCENT, ROUND);\n\n            // middlePrice * ((1000000/999999) ^ exp) = middlePrice / ((999999/1000000) ^ exp)\n            // safe uint48 downcast: exp is at-most 6907752\n            // {buyTok/sellTok} = {buyTok/sellTok} / {1} ^ {1}\n            return middlePrice.div(BASE.powu(uint48(exp.toUint(ROUND))), CEIL);\n            // this reverts for middlePrice >= 6.21654046e36 * FIX_ONE\n        }\n\n        // Slow linear decay -- 40%-100% of auction\n        return\n            middlePrice -\n            (middlePrice - lowPrice).mulDiv(progression - FORTY_PERCENT, SIXTY_PERCENT);\n    }\n}"
    },
    {
      "filename": "contracts/mixins/Auth.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"../interfaces/IMain.sol\";\n\nuint256 constant LONG_FREEZE_CHARGES = 6; // 6 uses\nuint48 constant MAX_UNFREEZE_AT = type(uint48).max;\nuint48 constant MAX_SHORT_FREEZE = 2592000; // 1 month\nuint48 constant MAX_LONG_FREEZE = 31536000; // 1 year\n\n/**\n * @title Auth\n * @notice Provides fine-grained access controls and exports frozen/paused states to Components.\n */\nabstract contract Auth is AccessControlUpgradeable, IAuth {\n    /**\n     * System-wide states (does not impact ERC20 functions)\n     *  - Frozen: only allow OWNER actions and staking\n     *  - Trading Paused: only allow OWNER actions, issuance, redemption, staking,\n     *                    and rewards payout\n     *  - Issuance Paused: disallow issuance\n     *\n     * Typically freezing thaws on its own in a predetermined number of blocks.\n     *   However, OWNER can freeze forever and unfreeze.\n     */\n\n    /// The rest of the contract uses the shorthand; these declarations are here for getters\n    bytes32 public constant OWNER_ROLE = OWNER;\n    bytes32 public constant SHORT_FREEZER_ROLE = SHORT_FREEZER;\n    bytes32 public constant LONG_FREEZER_ROLE = LONG_FREEZER;\n    bytes32 public constant PAUSER_ROLE = PAUSER;\n\n    // === Freezing ===\n\n    mapping(address => uint256) public longFreezes;\n\n    uint48 public unfreezeAt; // {s} uint48.max to pause indefinitely\n    uint48 public shortFreeze; // {s} length of an initial freeze\n    uint48 public longFreeze; // {s} length of a freeze extension\n\n    // === Pausing ===\n\n    /// @custom:oz-renamed-from paused\n    bool public tradingPaused;\n    bool public issuancePaused;\n\n    /* ==== Invariants ====\n       0 <= longFreeze[a] <= LONG_FREEZE_CHARGES for all addrs a\n       set{a has LONG_FREEZER} == set{a : longFreeze[a] == 0}\n    */\n\n    // checks:\n    // - __Auth_init has not previously been called\n    // - 0 < shortFreeze_ <= MAX_SHORT_FREEZE\n    // - 0 < longFreeze_ <= MAX_LONG_FREEZE\n    // effects:\n    // - caller has only the OWNER role\n    // - OWNER is the admin role for all roles\n    // - shortFreeze' == shortFreeze_\n    // - longFreeze' == longFreeze_\n    // questions: (what do I know about the values of paused and unfreezeAt?)\n    // untestable:\n    //      `else` branch of `onlyInitializing` (ie. revert) is currently untestable.\n    //      This function is only called inside other `init` functions, each of which is wrapped\n    //      in an `initializer` modifier, which would fail first.\n    // solhint-disable-next-line func-name-mixedcase\n    function __Auth_init(uint48 shortFreeze_, uint48 longFreeze_) internal onlyInitializing {\n        __AccessControl_init();\n\n        // Role setup\n        _setRoleAdmin(OWNER, OWNER);\n        _setRoleAdmin(SHORT_FREEZER, OWNER);\n        _setRoleAdmin(LONG_FREEZER, OWNER);\n        _setRoleAdmin(PAUSER, OWNER);\n\n        _grantRole(OWNER, _msgSender());\n\n        setShortFreeze(shortFreeze_);\n        setLongFreeze(longFreeze_);\n    }\n\n    // checks: caller is an admin for role, account is not 0\n    // effects:\n    // - account has the `role` role\n    // - if role is LONG_FREEZER, then longFreezes'[account] == LONG_FREEZE_CHARGES\n    function grantRole(bytes32 role, address account)\n        public\n        override(AccessControlUpgradeable, IAccessControlUpgradeable)\n        onlyRole(getRoleAdmin(role))\n    {\n        require(account != address(0), \"cannot grant role to address 0\");\n        if (role == LONG_FREEZER) longFreezes[account] = LONG_FREEZE_CHARGES;\n        _grantRole(role, account);\n    }\n\n    // ==== System-wide views ====\n    // returns: bool(main is frozen) == now < unfreezeAt\n    function frozen() public view returns (bool) {\n        return block.timestamp < unfreezeAt;\n    }\n\n    /// @dev This -or- condition is a performance optimization for the consuming Component\n    // returns: bool(main is frozen or tradingPaused) == tradingPaused || (now < unfreezeAt)\n    function tradingPausedOrFrozen() public view returns (bool) {\n        return tradingPaused || block.timestamp < unfreezeAt;\n    }\n\n    /// @dev This -or- condition is a performance optimization for the consuming Component\n    // returns: bool(main is frozen or issuancePaused) == issuancePaused || (now < unfreezeAt)\n    function issuancePausedOrFrozen() public view returns (bool) {\n        return issuancePaused || block.timestamp < unfreezeAt;\n    }\n\n    // === Freezing ===\n\n    /// Enter a freeze for the `shortFreeze` duration\n    // checks:\n    // - caller has the SHORT_FREEZER role\n    // - now + shortFreeze >= unfreezeAt (that is, this call should increase unfreezeAt)\n    // effects:\n    // - unfreezeAt' = now + shortFreeze\n    // - after, caller does not have the SHORT_FREEZER role\n    function freezeShort() external onlyRole(SHORT_FREEZER) {\n        // Revoke short freezer role after one use\n        _revokeRole(SHORT_FREEZER, _msgSender());\n        freezeUntil(uint48(block.timestamp) + shortFreeze);\n    }\n\n    /// Enter a freeze by the `longFreeze` duration\n    // checks:\n    // - caller has the LONG_FREEZER role\n    // - longFreezes[caller] > 0\n    // - now + longFreeze >= unfreezeAt (that is, this call should increase unfreezeAt)\n    // effects:\n    // - unfreezeAt' = now + longFreeze\n    // - longFreezes'[caller] = longFreezes[caller] - 1\n    // - if longFreezes'[caller] == 0 then caller loses the LONG_FREEZER role\n    function freezeLong() external onlyRole(LONG_FREEZER) {\n        longFreezes[_msgSender()] -= 1; // reverts on underflow\n\n        // Revoke on 0 charges as a cleanup step\n        if (longFreezes[_msgSender()] == 0) _revokeRole(LONG_FREEZER, _msgSender());\n        freezeUntil(uint48(block.timestamp) + longFreeze);\n    }\n\n    /// Enter a permanent freeze\n    // checks:\n    // - caller has the OWNER role\n    // - unfreezeAt != type(uint48).max\n    // effects: unfreezeAt' = type(uint48).max\n    function freezeForever() external onlyRole(OWNER) {\n        freezeUntil(MAX_UNFREEZE_AT);\n    }\n\n    /// End all freezes\n    // checks:\n    // - unfreezeAt > now  (i.e, frozen() == true before the call)\n    // - caller has the OWNER role\n    // effects: unfreezeAt' = now  (i.e, frozen() == false after the call)\n    function unfreeze() external onlyRole(OWNER) {\n        emit UnfreezeAtSet(unfreezeAt, uint48(block.timestamp));\n        unfreezeAt = uint48(block.timestamp);\n    }\n\n    // === Pausing ===\n    // checks: caller has PAUSER\n    // effects: tradingPaused' = true\n    function pauseTrading() external onlyRole(PAUSER) {\n        emit TradingPausedSet(tradingPaused, true);\n        tradingPaused = true;\n    }\n\n    // checks: caller has PAUSER\n    // effects: tradingPaused' = false\n    function unpauseTrading() external onlyRole(PAUSER) {\n        emit TradingPausedSet(tradingPaused, false);\n        tradingPaused = false;\n    }\n\n    // checks: caller has PAUSER\n    // effects: issuancePaused' = true\n    function pauseIssuance() external onlyRole(PAUSER) {\n        emit IssuancePausedSet(issuancePaused, true);\n        issuancePaused = true;\n    }\n\n    // checks: caller has PAUSER\n    // effects: issuancePaused' = false\n    function unpauseIssuance() external onlyRole(PAUSER) {\n        emit IssuancePausedSet(issuancePaused, false);\n        issuancePaused = false;\n    }\n\n    // === Gov params ===\n\n    /// @custom:governance\n    function setShortFreeze(uint48 shortFreeze_) public onlyRole(OWNER) {\n        require(shortFreeze_ > 0 && shortFreeze_ <= MAX_SHORT_FREEZE, \"short freeze out of range\");\n        emit ShortFreezeDurationSet(shortFreeze, shortFreeze_);\n        shortFreeze = shortFreeze_;\n    }\n\n    /// @custom:governance\n    function setLongFreeze(uint48 longFreeze_) public onlyRole(OWNER) {\n        require(longFreeze_ > 0 && longFreeze_ <= MAX_LONG_FREEZE, \"long freeze out of range\");\n        emit LongFreezeDurationSet(longFreeze, longFreeze_);\n        longFreeze = longFreeze_;\n    }\n\n    // === Private Helper ===\n    // checks: newUnfreezeAt > unfreezeAt\n    // effects: unfreezeAt' = newUnfreezeAt\n    function freezeUntil(uint48 newUnfreezeAt) private {\n        require(newUnfreezeAt > unfreezeAt, \"frozen\");\n        emit UnfreezeAtSet(unfreezeAt, newUnfreezeAt);\n        unfreezeAt = newUnfreezeAt;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "contracts/p1/RevenueTrader.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"./mixins/Trading.sol\";\nimport \"./mixins/TradeLib.sol\";\n\n/// Trader Component that converts all asset balances at its address to a\n/// single target asset and sends this asset to the Distributor.\n/// @custom:oz-upgrades-unsafe-allow external-library-linking\ncontract RevenueTraderP1 is TradingP1, IRevenueTrader {\n    using FixLib for uint192;\n    using SafeERC20 for IERC20;\n\n    // Immutable after init()\n    IERC20 public tokenToBuy;\n    IAssetRegistry private assetRegistry;\n    IDistributor private distributor;\n    IBackingManager private backingManager;\n    IFurnace private furnace;\n    IRToken private rToken;\n\n    function init(\n        IMain main_,\n        IERC20 tokenToBuy_,\n        uint192 maxTradeSlippage_,\n        uint192 minTradeVolume_\n    ) external initializer {\n        require(address(tokenToBuy_) != address(0), \"invalid token address\");\n        __Component_init(main_);\n        __Trading_init(main_, maxTradeSlippage_, minTradeVolume_);\n        tokenToBuy = tokenToBuy_;\n        cacheComponents();\n    }\n\n    /// Settle a single trade + distribute rev"
    }
  ]
}