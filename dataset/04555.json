{
  "Title": "Token minting is not synchronized with MigrationAgent",
  "Content": "Token minting leads to an inconsistent state as the `MigrationAgent` [tokenSupply](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) is never increased after being set in the constructor. The discrepancy between the [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) and the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) states, breaks the [`safetyInvariantCheck`](http://safetyInvariantCheck) and corrupts the migration process.\n\n\nWe suggest enforcing that the token has finalized the minitingby adding the check `require(_qbxSourceToken.mintingFinished)` in [line 21](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) of the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol). If the team wants to continue the minting after the migration is deployed we recommend increasing the `tokenSupply` by the amount of newly created tokens.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by tracking [`newTokens`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L139) and updating the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol) state in the [`updateSupply`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol#L57) function.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/MigrationAgent.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./QiibeeToken.sol\";\n\n// interface\ncontract QiibeeMigrationTokenInterface {\n  function createToken(address _target, uint256 _amount);\n  function finalizeMigration();\n  function totalSupply() returns (uint256);\n}\n\ncontract MigrationAgent is Ownable {\n\n  address public qbxSourceToken;\n  address public qbxTargetToken;\n  uint256 public tokenSupply;\n\n  function MigrationAgent(address _qbxSourceToken) {\n    require(QiibeeToken(_qbxSourceToken).migrationAgent() ==  address(0));\n    tokenSupply = QiibeeToken(_qbxSourceToken).totalSupply();\n    qbxSourceToken = _qbxSourceToken;\n  }\n\n  function safetyInvariantCheck(uint256 _value) internal {\n    require(QiibeeToken(qbxSourceToken).totalSupply() + QiibeeMigrationTokenInterface(qbxTargetToken).totalSupply() == tokenSupply - _value);\n  }\n\n  function setTargetToken(address _qbxTargetToken) public onlyOwner {\n    require(qbxTargetToken == address(0)); //Allow this change once only\n    qbxTargetToken = _qbxTargetToken;\n  }\n\n  function migrateFrom(address _from, uint256 _value) public {\n    require(msg.sender == qbxSourceToken);\n    require(qbxTargetToken != address(0));\n\n    safetyInvariantCheck(_value); // qbxSourceToken has already been updated, but corresponding QBX have not been created in the qbxTargetToken contract yet\n    QiibeeMigrationTokenInterface(qbxTargetToken).createToken(_from, _value);\n    safetyInvariantCheck(0); // totalSupply invariant must hold\n  }\n\n  function finalizeMigration() public onlyOwner {\n    require(qbxTargetToken != address(0));\n    require(QiibeeToken(qbxSourceToken).totalSupply() == 0); //only finlize if all tokens have been migrated\n    safetyInvariantCheck(0);\n    QiibeeMigrationTokenInterface(qbxTargetToken).finalizeMigration();\n\n    qbxSourceToken = address(0);\n    qbxTargetToken = address(0);\n    tokenSupply = 0;\n  }\n}"
    },
    {
      "filename": "contracts/MigrationAgent.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./QiibeeToken.sol\";\n\n// interface\ncontract QiibeeMigrationTokenInterface {\n  function createToken(address _target, uint256 _amount);\n  function finalizeMigration();\n  function totalSupply() returns (uint256);\n}\n\ncontract MigrationAgent is Ownable {\n\n  address public qbxSourceToken;\n  address public qbxTargetToken;\n  uint256 public tokenSupply;\n\n  function MigrationAgent(address _qbxSourceToken) {\n    require(QiibeeToken(_qbxSourceToken).migrationAgent() ==  address(0));\n    tokenSupply = QiibeeToken(_qbxSourceToken).totalSupply();\n    qbxSourceToken = _qbxSourceToken;\n  }\n\n  function safetyInvariantCheck(uint256 _value) internal {\n    require(QiibeeToken(qbxSourceToken).totalSupply() + QiibeeMigrationTokenInterface(qbxTargetToken).totalSupply() == tokenSupply - _value);\n  }\n\n  function setTargetToken(address _qbxTargetToken) public onlyOwner {\n    require(qbxTargetToken == address(0)); //Allow this change once only\n    qbxTargetToken = _qbxTargetToken;\n  }\n\n  function migrateFrom(address _from, uint256 _value) public {\n    require(msg.sender == qbxSourceToken);\n    require(qbxTargetToken != address(0));\n\n    safetyInvariantCheck(_value); // qbxSourceToken has already been updated, but corresponding QBX have not been created in the qbxTargetToken contract yet\n    QiibeeMigrationTokenInterface(qbxTargetToken).createToken(_from, _value);\n    safetyInvariantCheck(0); // totalSupply invariant must hold\n  }\n\n  function finalizeMigration() public onlyOwner {\n    require(qbxTargetToken != address(0));\n    require(QiibeeToken(qbxSourceToken).totalSupply() == 0); //only finlize if all tokens have been migrated\n    safetyInvariantCheck(0);\n    QiibeeMigrationTokenInterface(qbxTargetToken).finalizeMigration();\n\n    qbxSourceToken = address(0);\n    qbxTargetToken = address(0);\n    tokenSupply = 0;\n  }\n}"
    }
  ]
}