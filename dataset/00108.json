{
  "Title": "M-13: Utilization rates are 0 when average assets are 0, which may be used to game maturity borrows / deposits / withdrawals",
  "Content": "# Issue M-13: Utilization rates are 0 when average assets are 0, which may be used to game maturity borrows / deposits / withdrawals \n\nSource: https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/150 \n\nThe protocol has acknowledged this issue.\n\n## Found by \n0x73696d616f\n## Summary\n\nAt protocol launch, when `previewFloatingAssetsAverage()` is `0`, a borrow may be taken with the lowest interest rate possibel due to the utilization being `0` when the average assets are 0.\n\n## Vulnerability Detail\n\nIn `Market::initialize()`, `lastAverageUpdate` is set to `block.timestamp`. When calculating the average assets, the formula used is:\n```solidity\nfunction previewFloatingAssetsAverage() public view returns (uint256) {\n  uint256 memFloatingAssets = floatingAssets;\n  uint256 memFloatingAssetsAverage = floatingAssetsAverage;\n  uint256 dampSpeedFactor = memFloatingAssets < memFloatingAssetsAverage ? dampSpeedDown : dampSpeedUp;\n  uint256 averageFactor = uint256(1e18 - (-int256(dampSpeedFactor * (block.timestamp - lastAverageUpdate))).expWad());\n  return memFloatingAssetsAverage.mulWadDown(1e18 - averageFactor) + averageFactor.mulWadDown(memFloatingAssets);\n}\n```\nAs can be seen, if `block.timestamp == lastAverageUpdate`, `averageFactor` will be `1 - e^0 = 0`, resulting in average assets equal to  `memFloatingAssetsAverage`, which is `0` when no deposits were made. Thus, even if a user deposits and borrows, its deposit will still lead to `previewFloatingAssetsAverage() == 0`, allowing him to get a borrow, even if almost as big as its deposit (minus the adjust factor), using the lowest interest rate possible.\n\nThe following test confirms this behaviour, add it to `Market.t.sol`:\n```solidity\nfunction test_POC_BorrowAtMaturity_LowestRate() external {\n  uint256 assets = 10_000 ether;\n  ERC20 asset = market.asset();\n  deal(address(asset), ALICE, assets + 1);\n  uint256 maturity = FixedLib.INTERVAL * 2;\n\n  //skip(1 days); // Uncomment to confirm that if some time passes assetsOwed will increase\n\n  vm.startPrank(ALICE);\n  market.deposit(assets, ALICE);\n  uint256 assetsOwed = market.borrowAtMaturity(maturity, assets / 2, type(uint256).max, ALICE, ALICE);\n  assertEq(assetsOwed, 5076712328767123285000);\n}\n```\n\n## Impact\n\nUser borrows and places the protocol at a significant risk with a very small interest rate.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L121\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L878\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L1006\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L1012\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L1018\n\n## Tool used\n\nManual Review\n\nVscode\n\nFoundry\n\n## Recommendation\n\nWhen assets are `0`, the interest rate should be the maximum.\nAdditionally, when initializing, it's better to set the factor to some time in the past so the first depositor increases the utilization ratio accordingly.\n\n\n\n## Discussion\n\n**santipu03**\n\nI believe this issue may be invalid due to describing the intended design of the protocol. If I'm not mistaken, when the utilization is 0 (assets are 0), the interest rates should also be at the lowest point. \n\nWaiting for the sponsor tags to confirm it.\nC.C. @itofarina @cruzdanilo \n\n**0x73696d616f**\n\nEscalate\n\nUtilization ratio is borrows / assets. When assets == 0, this is borrows / 0. It goes to infinity (1) if borrows != 0. If borrows == 0, it's 0/0, which should also go to 1 to protect the protocol (using 0 would favor borrowers). \nRun the following POC to verify how the utilization ratios are 0 but there are 10_000 deposits and 6_400 borrows:\n```solidity\nfunction test_POC_WrongUtilizationRatio_WhenAssetsAreZero() external {\n  market.deposit(10_000 ether, address(this));\n  market.borrow(10_000 ether * 8 * 8 / 10 / 10, address(this), address(this));\n\n  uint256 assets = market.previewFloatingAssetsAverage();\n  uint256 debt = market.floatingDebt();\n  uint256 backupBorrowed = market.floatingBackupBorrowed();\n\n  /*\n    function globalUtilization(uint256 assets, uint256 debt, uint256 backupBorrowed) internal pure returns (uint256) {\n      return assets != 0 ? (debt + backupBorrowed).divWadUp(assets) : 0;\n    }\n    function floatingUtilization(uint256 assets, uint256 debt) internal pure returns (uint256) {\n      return assets != 0 ? debt.divWadUp(assets) : 0;\n    }\n  */\n  uint256 globalUtilization = assets != 0 ? (debt + backupBorrowed).divWadUp(assets) : 0;\n  uint256 floatingUtilization = assets != 0 ? debt.divWadUp(assets) : 0;\n\n  assertEq(market.totalAssets(), 10_000 ether);\n  assertEq(market.floatingDebt(), 10_000 ether * 8 * 8 / 10 / 10);\n  assertEq(globalUtilization, 0);\n  assertEq(floatingUtilization, 0);\n}\n```\n\n**sherlock-admin3**\n\n> Escalate\n> \n> Utilization ratio is borrows / assets. When assets == 0, this is borrows / 0. It goes to infinity (1) if borrows != 0. If borrows == 0, it's 0/0, which should also go to 1 to protect the protocol (using 0 would favor borrowers). \n> Run the following POC to verify how the utilization ratios are 0 but there are 10_000 deposits and 6_400 borrows:\n> ```solidity\n> function test_POC_WrongUtilizationRatio_WhenAssetsAreZero() external {\n>   market.deposit(10_000 ether, address(this));\n>   market.borrow(10_000 ether * 8 * 8 / 10 / 10, address(this), address(this));\n> \n>   uint256 assets = market.previewFloatingAssetsAverage();\n>   uint256 debt = market.floatingDebt();\n>   uint256 backupBorrowed = market.floatingBackupBorrowed();\n> \n>   /*\n>     function globalUtilization(uint256 assets, uint256 debt, uint256 backupBorrowed) internal pure returns (uint256) {\n>       return assets != 0 ? (debt + backupBorrowed).divWadUp(assets) : 0;\n>     }\n>     function floatingUtilization(uint256 assets, uint256 debt) internal pure returns (uint256) {\n>       return assets != 0 ? debt.divWadUp(assets) : 0;\n>     }\n>   */\n>   uint256 globalUtilization = assets != 0 ? (debt + backupBorrowed).divWadUp(assets) : 0;\n>   uint256 floatingUtilization = assets != 0 ? debt.divWadUp(assets) : 0;\n> \n>   assertEq(market.totalAssets(), 10_000 ether);\n>   assertEq(market.floatingDebt(), 10_000 ether * 8 * 8 / 10 / 10);\n>   assertEq(globalUtilization, 0);\n>   assertEq(floatingUtilization, 0);\n> }\n> ```\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**santipu03**\n\nThe utilization rate doesn't get updated instantly because it's using the average of deposited assets instead of the current assets, and that is the intended design of the protocol. This report describes a byproduct of that mechanism that won't have much impact because in the worst case, it will allow a user in a new market to take a loan with a lower interest rate than it should. \n\nThis issue can be classified as a design improvement suggestion but I don't think it should be more than low severity because the current design may be suboptimal but it doesn't imply a loss of funds. \n\n**0x73696d616f**\n\nFirstly, I would like to mention that I agree with this statement\n> The utilization rate doesn't get updated instantly because it's using the average of deposited assets instead of the current assets, and that is the intended design of the protocol.\n\nThe intended design of the protocol is indeed using average assets, and I am not disputing this. Now, on to the following statement\n\n> This report describes a byproduct of that mechanism that won't have much impact because in the worst case, it will allow a user in a new market to take a loan with a lower interest rate than it should.\n\nThis issue is not a byproduct of the mechanism at all. Just makes it more likely, but is not the point of it. Please note that this issue would still exist WITHOUT the mechanism. Initially or at any time really, as long as assets are 0, when there are no deposits (there may be debt), the utilization rate will always be 0, so users may take any loan, as big as they want, for the lowest fee, while the protocol is close to insolvency.\n\nNow, onto the fact that @santipu03 is trying to diminish the impact of this issue, which is issuing loans with the lowest interest rate possible when the protocol is close to insolvency. There will be times where the assets are 0, being one of these times the initial period (a fix for this was also mentioned in the report, in the recommendation).\n\nDuring these times, it's important for the protocol to protect itself from borrowers and insolvency risk by increasing the utilization rate and corresponding fee when borrowing.\n\nIn a market with an adjust factor of 0.9, the protocol could have 1000 collateral and 900 debt, and still have an utilization rate of 0 and thus issue loans with the lowest interest rates possible!\n\nI don't think it is acceptable at all for the protocol to be close to insolvency and issue loans with the lowest interest rate possible, it goes against the whole design of the interest rate model.\n\nWhen the borrowed amounts are closed to the deposits, the protocol should protect itself by increasing interest rates and disincentivize borrows, which is clearly broken here.\n\nLeave this up to the person deciding the escalations, I don't think any further clarification is needed.\n\n**santipu03**\n\nWhen the assets are zero, it's not possible to have debt on the market, this is enforced in `borrow`:\n\n```solidity\nif (floatingBackupBorrowed + newFloatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n  revert InsufficientProtocolLiquidity();\n}\n```\n\nAfter this is clear, I only see this issue exploitable when a user is the first depositor on the market and it executes a deposit and a borrow in the same block. Because the utilization uses the average of deposited assets, it will result in zero, and this will cause interest rates to be lower than they should. \n\nNow, because this issue will only be triggered on a new market, I don't think it's going to cause the claimed risk of insolvency. \n\n**0x73696d616f**\n\n> After this is clear, I only see this issue exploitable when a user is the first depositor on the market and it executes a deposit and a borrow in the same block\n\nDoes not have to be the first depositor, the market may have 0 assets at any point.\n\n> Because the utilization uses the average of deposited assets, it will result in zero, and this will cause interest rates to be lower than they should.\n\nIt's not because they use the average, but due to incorrectly assuming assets == 0 means 0 utilization rate, which is obviously wrong and heavily favors borrowers, increasing the protocol's risk of insolvency.\n\n> Now, because this issue will only be triggered on a new market, I don't think it's going to cause the claimed risk of insolvency.\n\nIt does not matter if it is triggered on a new market or old market or whatever. As long as it allows you reaching a state with possibly 1000 collateral and 900 debt, and the interest rate is 0, the market is close to insolvency. This state is dangerous and can not be disregarded.\n\n**santipu03**\n\n> Does not have to be the first depositor, the market may have 0 assets at any point.\n\nRealistically, the market only has strictly 0 assets at the start, and never again, even if the pool is abandoned, there are usually some dust assets due to rounding. \n\n> It's not because they use the average, but due to incorrectly assuming assets == 0 means 0 utilization rate, which is obviously wrong and heavily favors borrowers, increasing the protocol's risk of insolvency.\n\nWell, when assets are 0, the utilization rate should be also 0 because there cannot be any borrowed funds due to the check I showed you before. The root cause of this issue is that the protocol assumes that when the average of assets is 0, the utilization is 0, which cannot be true as demonstrated in your report. \n\nStill, I admit that this issue can be exploitable because when a new market is deployed, a user can take a fixed loan with a minimum interest rate. Given the impact of this issue is partly similar to 67 but it can only be triggered once when the market is deployed, I see this issue as a borderline low/medium.\n\n**0x73696d616f**\n\n> Realistically, the market only has strictly 0 assets at the start, and never again, even if the pool is abandoned, there are usually some dust assets due to rounding.\n\nThis may not always be the case, but the market may be left in the incorrect state regardless of it.\n\n> Well, when assets are 0, the utilization rate should be also 0 because there cannot be any borrowed funds due to the check I showed you before.\n\nI can not agree with this part. 0/0 is not 0 and should never favour borrowers. 0/0 is an indetermination and should be resolved by favouring the protocol, hence not returning 0. As it currently returns 0, it will lead to an exploitable state where the protocol is at the highest utilization ratio (1000 collateral and 900 debt), but is giving out loans with the lowest interest possible.\n\n> The root cause of this issue is that the protocol assumes that when the average of assets is 0, the utilization is 0, which cannot be true as demonstrated in your report.\n\nNot sure whay you mean but I proved that my claims are true, at least when the market is deployed.\n\n> Given the impact of this issue is partly similar to 67 but it can only be triggered once when the market is deployed, I see this issue as a borderline low/medium.\n\nI think the impact is bigger. If this is exploited to take a big loan with very low interest at the beginning, the protocol will reach the state where it is closest to insolvency.  I say this because #67 means the attacker may take a loan with some interest rate that is too low for its loan, but here it takes the loan with the lowest interest rate possible, guaranteed.\n\nThe likelihood / times of ocurrence may be lower but keep in mind that this exploit is very profitable for a borrower.\n\n**0x73696d616f**\n\n> If I'm not mistaken, when the utilization is 0 (assets are 0), the interest rates should also be at the lowest point.\n\nJust pointing out that your reason to close this issue is false as proven by the comments above. 0/0 is not 0 and should be the maximum in this case to protect the protocol, as you agree its important. Not the lowest. This is the core of this issue.\n\n**santipu03**\n\nI disagree with your argument that taking a loan with the lowest interest rate possible leads to insolvency. The trusted admins are in charge of setting the correct adjust factors for each token so that if the adjust factor is set at 0.9, it's assumed that it is safe to have 1000 collateral and 900 debt because the market is stable. Having a market with the highest utilization ratio doesn't mean that the market is close to insolvency, it just means that most of the funds are borrowed. \n\nHowever, being able to take a loan with a lower interest rate than it should be I think it warrants a medium severity because lenders are being paid less than expected. \n\nThen we have the likelihood of this issue occurring. As I pointed out before, the only possible scenario where this issue can be exploited is when the market is newly deployed and the first depositor makes a big deposit and a fixed borrow in the same block. Because of this issue, that user will take a fixed loan with the lowest interest rate possible because the average of floating assets will be 0 at that moment. \n\nTaking all of this into account, I consider the impact to be medium and the likelihood to be extremely low, and that's why I think the overall severity of this issue is a borderline low/medium. The head of judging will have the final say. \n\n**0x73696d616f**\n\n> I disagree with your argument that taking a loan with the lowest interest rate possible leads to insolvency. The trusted admins are in charge of setting the correct adjust factors for each token so that if the adjust factor is set at 0.9, it's assumed that it is safe to have 1000 collateral and 900 debt because the market is stable. Having a market with the highest utilization ratio doesn't mean that the market is close to insolvency, it just means that most of the funds are borrowed.\n\nThis is not the core part of this issue, but it is closer to insolvency anyway.\n\n> the likelihood to be extremely low\n\nI completely disagree with this statement. The market always goes through deployment and the incorrect state, so the likelihood can not be low.\n\n**cvetanovv**\n\nEven if the assets are only zero when the market is deployed, I think this issue can be Medium severity. \n\nI disagree that the likelihood is small. The likelihood is the same as a First depositor Inflation attack. \n\nHere, the impact is lower, but it still allows a user to take advantage of a loan with a lower interest rate than it should be. This will lead to potential losses for lenders. \n\nPlanning to accept the escalation and make this issue a Medium severity.\n\n\n**santipu03**\n\n@cvetanovv \nI agree that the attacker is able to take a fixed loan for a lower interest rate when the market is deployed. However, the only lender on the market at that point is the attacker so the liquidity taken for the loan is from the same attacker, meaning the only affected user of this exploit would be the attacker. \n\n**0x73696d616f**\n\n@santipu03 there can be several attackers. And the protocol would be in a high borrowing / utilization state while having the lowest interest rates on loans.\n\n**santipu03**\n\nThis attack is only possible at the market deployment because after a few blocks have passed, the average of floating assets has gotten much closer to the deposited floating assets, so the utilization rate is updated and interest rates are correct. The only impact will be that a fixed loan will have a lower interest rate, but the liquidity used for that loan will be the attacker's liquidity. \n\nFrom what I can see, the attacker will pay fewer fees for a loan but those fees should go directly to him, so, in the end, it's like self-griefing. \n\n**0x73696d616f**\n\n> The only impact will be that a fixed loan will have a lower interest rate, but the liquidity used for that loan will be the attacker's liquidity.\n\nThere may be more and honestly it does not matter. What I am saying is, the high utilization ratio of the market is not justified by the current interest the loans are earning. The market is heavily utilized, but the current loans are at the lowest interest.\n\n> From what I can see, the attacker will pay fewer fees for a loan but those fees should go directly to him, so, in the end, it's like self-griefing.\n\nThe point of a loan in the perspective of a borrower is not earning fees. The loan he's got has the lowest interest rate, which is exactly what he wants.\n\n**etherSky111**\n\n> Even if the assets are only zero when the market is deployed, I think this issue can be Medium severity.\n> \n> I disagree that the likelihood is small. The likelihood is the same as a First depositor Inflation attack.\n> \n> Here, the impact is lower, but it still allows a user to take advantage of a loan with a lower interest rate than it should be. This will lead to potential losses for lenders.\n> \n> Planning to accept the escalation and make this issue a Medium severity.\n\n@cvetanovv , what about this comment from sponsor?\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/176#issuecomment-2121372742\nExactly team will be first depositor on every market.\n\n**cvetanovv**\n\n> > Even if the assets are only zero when the market is deployed, I think this issue can be Medium severity.\n> > I disagree that the likelihood is small. The likelihood is the same as a First depositor Inflation attack.\n> > Here, the impact is lower, but it still allows a user to take advantage of a loan with a lower interest rate than it should be. This will lead to potential losses for lenders.\n> > Planning to accept the escalation and make this issue a Medium severity.\n> \n> @cvetanovv , what about this comment from sponsor? [#176 (comment)](https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/176#issuecomment-2121372742) Exactly team will be first depositor on every market.\n\nI can't consider this comment a \"Source of truth\" because it was written after the audit ended. \n\nIs it written somewhere in the documentation? If there is, this issue is invalid.\n\n**0x73696d616f**\n\n@etherSky111 the average assets will still be 0, the issue is valid regardless.\n\nAnd the information from the sponsor was given after the end of the contest.\n\n**cvetanovv**\n\nI did not find any information before the audit that the protocol would mint and burn shares at every market deployment. \n\nRemains my initial decision to accept the escalation\n\n**santipu03**\n\nIf I'm not missing something, I believe this issue doesn't have any real impact. \n\nAs we've agreed before, the only impact this issue has is that when a market is deployed, an attacker can be its first depositor and take a fixed loan with a lower interest rate than usual. Usually, an impact like this (manipulating interest rates) is categorized as medium severity because it implies a loss of fees for lenders. However, at the time of the exploit, the only lender is the attacker so this issue impacts no other users. \n\nIn other words, the attacker is paying less fees for a loan, but those fees should go to him, so the potential damage only affects the attacker. \n\nWhat do you think about this issue @santichez?\n\n**0x73696d616f**\n\nYour comment is completely false as the fees become unassigned and will later be coverted to floating assets, over time (or until someone deposits at maturity). Thus he is effectively stealing fees.\n\n**santichez**\n\nEven though the impact might seem low, the issue looks valid to me.\nExactly will be minting shares as the first deposit every time a new market is enabled, but I understand the fact that this wasn't explicitly commented on our docs.\n\n**santipu03**\n\n> Your comment is completely false as the fees become unassigned and will later be coverted to floating assets, over time (or until someone deposits at maturity). Thus he is effectively stealing fees.\n\nI agree with this statement, I'm sorry I missed that part. \n\nHowever, I've found that the interest rate is actually lower when the average assets are higher than zero, thus confronting the root cause of this issue, which is that the first depositor will get a fixed loan with the lowest interest rate. \n\n```solidity\n  function test_POC_BorrowAtMaturity_LowestRate() external {\n    uint256 assets = 10_000 ether;\n    uint256 borrow = 10_000 ether / 2;\n    ERC20 asset = market.asset();\n    deal(address(asset), ALICE, assets + 1);\n    uint256 maturity = FixedLib.INTERVAL * 2;\n    vm.startPrank(ALICE);\n\n    uint256 snapshot = vm.snapshot();\n\n    // First depositor gets a fixed loan with average assets being 0\n    market.deposit(assets, ALICE);\n    assertEq(market.previewFloatingAssetsAverage(), 0);\n    uint256 assetsOwed = market.borrowAtMaturity(maturity, borrow, type(uint256).max, ALICE, ALICE);\n    assertEq(assetsOwed - borrow, 76.712328767123285000e18); // Fixed interest is ~76e18\n\n    vm.revertTo(snapshot);\n\n    // First depositor gets a fixed loan with average assets being equal to the deposited assets\n    market.deposit(assets, ALICE);\n    skip(1 days);\n    assertEq(market.previewFloatingAssetsAverage(), assets);\n    assetsOwed = market.borrowAtMaturity(maturity, borrow, type(uint256).max, ALICE, ALICE);\n    assertEq(assetsOwed - borrow, 75.342465753424655000e18); // Fixed interest is ~75e18\n  }\n```\n\n@0x73696d616f Do you know how is this possible? I believe this may be a behavior of the IRM but I'm not sure. \n\n**0x73696d616f**\n\nI tested this in the POC of the issue, it leads to less debt.\nThe diff is in your poc, you're depositing, waiting and then borrowing. My poc above is waiting, depositing and borrowing.\n\n\n**0x73696d616f**\n\nIt's because of `block.timestamp` being `1 days` bigger.\n`assets.mulWadDown(fixedRate.mulDivDown(maturity - block.timestamp, 365 days));`\nIt's a smaller loan duration.\n\n**santipu03**\n\nBut in your original PoC, if you uncomment the line `skip(1 days)`, the assets owed actually decrease, not increase. And the fee amounts are the same as in my POC, so the difference is also based on the shorter loan?\n\n> I tested this in the POC of the issue, it leads to less debt.\n\nSir, I'd like to believe this has been a mistake on your part because your PoC directly contradicts the claims you've been making for the last week on this issue. \n\n**0x73696d616f**\n\nOk so the irm is mocked, so the rate is always the same. \nCan confirm my original poc decreases, instead of increasing due to the loan duration. My mistake, the claims are still valid.\nChange the irm from mocked to a real one and the fee calculation to `maturity` only and it works.\n```solidity\nfunction test_POC_BorrowAtMaturity_LowestRate_Test() external {\nmarket.setInterestRateModel(\n  new InterestRateModel(\n    Parameters({\n      minRate: 3.5e16,\n      naturalRate: 8e16,\n      maxUtilization: 1.1e18,\n      naturalUtilization: 0.75e18,\n      growthSpeed: 1.1e18,\n      sigmoidSpeed: 2.5e18,\n      spreadFactor: 0.2e18,\n      maturitySpeed: 0.5e18,\n      timePreference: 0.01e18,\n      fixedAllocation: 0.6e18,\n      maxRate: 15_000e16\n    }),\n    Market(address(0))\n  )\n);\n\nuint256 assets = 10_000 ether;\nuint256 borrow = 10_000 ether / 2;\nERC20 asset = market.asset();\ndeal(address(asset), ALICE, assets + 1);\nuint256 maturity = FixedLib.INTERVAL * 2;\nvm.startPrank(ALICE);\n\nuint256 snapshot = vm.snapshot();\n\n// First depositor gets a fixed loan with average assets being 0\nmarket.deposit(assets, ALICE);\nassertEq(market.previewFloatingAssetsAverage(), 0);\nuint256 assetsOwed = market.borrowAtMaturity(maturity, borrow, type(uint256).max, ALICE, ALICE);\nassertEq(assetsOwed - borrow, 26849315068493150000); // Fixed interest is ~76e18\n\nvm.revertTo(snapshot);\n\n// First depositor gets a fixed loan with average assets being equal to the deposited assets\nmarket.deposit(assets, ALICE);\nskip(1 days);\nassertEq(market.previewFloatingAssetsAverage(), assets);\nassetsOwed = market.borrowAtMaturity(maturity, borrow, type(uint256).max, ALICE, ALICE);\nassertEq(assetsOwed - borrow, 32487218504212110000); // Fixed interest is ~75e18\n}\n```\n\n**santipu03**\n\nThe test is failing: \n\n```\n[FAIL. Reason: assertion failed: 31907089602351180000 != 32487218504212110000] test_POC_BorrowAtMaturity_LowestRate_Test() (gas: 3346837)\n```\n\n**0x73696d616f**\n\nDid you change the line in the market? `fee = assets.mulWadDown(fixedRate.mulDivDown(maturity, 365 days));`\n\n**0x73696d616f**\n\nI just ran it and it works.\n\n**santipu03**\n\nDo I have to change a line in the Market for the PoC to work?\n\n**0x73696d616f**\n\nyes, to simulate the duration of the loan being the same.\n\n**0x73696d616f**\n\nIf it is bigger without changing the line, it is valid anyway.\n\n**0x73696d616f**\n\n> Sir, I'd like to believe this has been a mistake on your part because your PoC directly contradicts the claims you've been making for the last week on this issue.\n\nBtw this is false because even if the interest rate was the same/lower, it would be a bug of the irm. It makes no sense for the interest rate to be lower given a much higher utilization ratio, something would be off.\n\n**santipu03**\n\nAfter checking this last PoC, I agree that the bug is triggered and the attack is feasible, this issue warrants medium severity. \n\n**cvetanovv**\n\nAfter the discussion and the Lead Judge agreement, my [decision](https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/150#issuecomment-2124166366) remains to accept the escalation and make this issue a Medium severity. \n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0x73696d616f](https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/150/#issuecomment-2117196049): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/247",
  "Code": [
    {
      "filename": "protocol/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { ERC4626, ERC20, SafeTransferLib } from \"solmate/src/mixins/ERC4626.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { RewardsController } from \"./RewardsController.sol\";\nimport { FixedLib } from \"./utils/FixedLib.sol\";\nimport { Auditor } from \"./Auditor.sol\";\n\ncontract Market is Initializable, AccessControlUpgradeable, PausableUpgradeable, ERC4626 {\n  using FixedPointMathLib for int256;\n  using FixedPointMathLib for uint256;\n  using FixedPointMathLib for uint128;\n  using SafeTransferLib for ERC20;\n  using FixedLib for FixedLib.Pool;\n  using FixedLib for FixedLib.Position;\n  using FixedLib for uint256;\n\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant EMERGENCY_ADMIN_ROLE = keccak256(\"EMERGENCY_ADMIN_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  Auditor public immutable auditor;\n\n  /// @notice Tracks account's fixed deposit positions by maturity, account and position.\n  mapping(uint256 => mapping(address => FixedLib.Position)) public fixedDepositPositions;\n  /// @notice Tracks account's fixed borrow positions by maturity, account and position.\n  mapping(uint256 => mapping(address => FixedLib.Position)) public fixedBorrowPositions;\n  /// @notice Tracks fixed pools state by maturity.\n  mapping(uint256 => FixedLib.Pool) public fixedPools;\n\n  /// @notice Tracks fixed deposit and borrow map and floating borrow shares of an account.\n  mapping(address => Account) public accounts;\n\n  /// @notice Amount of assets lent by the floating pool to the fixed pools.\n  uint256 public floatingBackupBorrowed;\n  /// @notice Amount of assets lent by the floating pool to accounts.\n  uint256 public floatingDebt;\n\n  /// @notice Accumulated earnings from extraordinary sources to be gradually distributed.\n  uint256 public earningsAccumulator;\n  /// @notice Rate per second to be charged to delayed fixed pools borrowers after maturity.\n  uint256 public penaltyRate;\n  /// @notice Rate charged to the fixed pool to be retained by the floating pool for initially providing liquidity.\n  uint256 public backupFeeRate;\n  /// @notice Damp speed factor to update `floatingAssetsAverage` when `floatingAssets` is higher.\n  uint256 public dampSpeedUp;\n  /// @notice Damp speed factor to update `floatingAssetsAverage` when `floatingAssets` is lower.\n  uint256 public dampSpeedDown;\n\n  /// @notice Number of fixed pools to be active at the same time.\n  uint8 public maxFuturePools;\n  /// @notice Last time the accumulator distributed earnings.\n  uint32 public lastAccumulatorAccrual;\n  /// @notice Last time the floating debt was updated.\n  uint32 public lastFloatingDebtUpdate;\n  /// @notice Last time the floating assets average was updated.\n  uint32 public lastAverageUpdate;\n\n  /// @notice Interest rate model contract used to get the borrow rates.\n  InterestRateModel public interestRateModel;\n\n  /// @notice Factor used for gradual accrual of earnings to the floating pool.\n  uint128 public earningsAccumulatorSmoothFactor;\n  /// @notice Percentage factor that represents the liquidity reserves that can't be borrowed.\n  uint128 public reserveFactor;\n\n  /// @notice Amount of floating assets deposited to the pool.\n  uint256 public floatingAssets;\n  /// @notice Average of the floating assets to get fixed borrow rates and prevent rate manipulation.\n  uint256 public floatingAssetsAverage;\n\n  /// @notice Total amount of floating borrow shares assigned to floating borrow accounts.\n  uint256 public totalFloatingBorrowShares;\n\n  /// @dev gap from deprecated state.\n  /// @custom:oz-renamed-from floatingUtilization\n  uint256 private __gap;\n\n  /// @notice Address of the treasury that will receive the allocated earnings.\n  address public treasury;\n  /// @notice Rate to be charged by the treasury to floating and fixed borrows.\n  uint256 public treasuryFeeRate;\n\n  /// @notice Address of the rewards controller that will accrue rewards for accounts operating with the Market.\n  RewardsController public rewardsController;\n\n  /// @notice Flag to prevent new borrows and deposits.\n  bool public isFrozen;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor(ERC20 asset_, Auditor auditor_) ERC4626(asset_, \"\", \"\") {\n    auditor = auditor_;\n\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the contract.\n  /// @dev can only be called once.\n  function initialize(\n    string calldata assetSymbol,\n    uint8 maxFuturePools_,\n    uint128 earningsAccumulatorSmoothFactor_,\n    InterestRateModel interestRateModel_,\n    uint256 penaltyRate_,\n    uint256 backupFeeRate_,\n    uint128 reserveFactor_,\n    uint256 dampSpeedUp_,\n    uint256 dampSpeedDown_\n  ) external initializer {\n    __AccessControl_init();\n    __Pausable_init();\n\n    lastAccumulatorAccrual = uint32(block.timestamp);\n    lastFloatingDebtUpdate = uint32(block.timestamp);\n    lastAverageUpdate = uint32(block.timestamp);\n\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    setAssetSymbol(assetSymbol);\n    setMaxFuturePools(maxFuturePools_);\n    setEarningsAccumulatorSmoothFactor(earningsAccumulatorSmoothFactor_);\n    setInterestRateModel(interestRateModel_);\n    setPenaltyRate(penaltyRate_);\n    setBackupFeeRate(backupFeeRate_);\n    setReserveFactor(reserveFactor_);\n    setDampSpeed(dampSpeedUp_, dampSpeedDown_);\n  }\n\n  /// @notice Borrows a certain amount from the floating pool.\n  /// @param assets amount to be sent to receiver and repaid by borrower.\n  /// @param receiver address that will receive the borrowed assets.\n  /// @param borrower address that will repay the borrowed assets.\n  /// @return borrowShares shares corresponding to the borrowed assets.\n  function borrow(\n    uint256 assets,\n    address receiver,\n    address borrower\n  ) external whenNotPaused whenNotFrozen returns (uint256 borrowShares) {\n    spendAllowance(borrower, assets);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    depositToTreasury(updateFloatingDebt());\n\n    borrowShares = previewBorrow(assets);\n\n    uint256 newFloatingDebt = floatingDebt + assets;\n    floatingDebt = newFloatingDebt;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed, also considering the reserves\n    if (floatingBackupBorrowed + newFloatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n      revert InsufficientProtocolLiquidity();\n    }\n\n    totalFloatingBorrowShares += borrowShares;\n    accounts[borrower].floatingBorrowShares += borrowShares;\n\n    emit Borrow(msg.sender, receiver, borrower, assets, borrowShares);\n    emitMarketUpdate();\n\n    auditor.checkBorrow(this, borrower);\n    asset.safeTransfer(receiver, assets);\n  }\n\n  /// @notice Repays a certain amount of assets to the floating pool.\n  /// @param assets assets to be subtracted from the borrower's accountability.\n  /// @param borrower address of the account that has the debt.\n  /// @return actualRepay the actual amount that should be transferred into the protocol.\n  /// @return borrowShares subtracted shares from the borrower's accountability.\n  function repay(\n    uint256 assets,\n    address borrower\n  ) external whenNotPaused returns (uint256 actualRepay, uint256 borrowShares) {\n    (actualRepay, borrowShares) = noTransferRefund(previewRepay(assets), borrower);\n    emitMarketUpdate();\n    asset.safeTransferFrom(msg.sender, address(this), actualRepay);\n  }\n\n  /// @notice Repays a certain amount of shares to the floating pool.\n  /// @param borrowShares shares to be subtracted from the borrower's accountability.\n  /// @param borrower address of the account that has the debt.\n  /// @return assets subtracted assets from the borrower's accountability.\n  /// @return actualShares actual subtracted shares from the borrower's accountability.\n  function refund(\n    uint256 borrowShares,\n    address borrower\n  ) external whenNotPaused returns (uint256 assets, uint256 actualShares) {\n    (assets, actualShares) = noTransferRefund(borrowShares, borrower);\n    emitMarketUpdate();\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @notice Allows to (partially) repay a floating borrow. It does not transfer assets.\n  /// @param borrowShares shares to be subtracted from the borrower's accountability.\n  /// @param borrower the address of the account that has the debt.\n  /// @return assets the actual amount that should be transferred into the protocol.\n  /// @return actualShares actual subtracted shares from the borrower's accountability.\n  function noTransferRefund(\n    uint256 borrowShares,\n    address borrower\n  ) internal returns (uint256 assets, uint256 actualShares) {\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    depositToTreasury(updateFloatingDebt());\n    Account storage account = accounts[borrower];\n    uint256 accountBorrowShares = account.floatingBorrowShares;\n    actualShares = Math.min(borrowShares, accountBorrowShares);\n    assets = previewRefund(actualShares);\n\n    if (assets == 0) revert ZeroRepay();\n\n    floatingDebt -= assets;\n    account.floatingBorrowShares = accountBorrowShares - actualShares;\n    totalFloatingBorrowShares -= actualShares;\n\n    emit Repay(msg.sender, borrower, assets, actualShares);\n  }\n\n  /// @notice Deposits a certain amount to a maturity.\n  /// @param maturity maturity date where the assets will be deposited.\n  /// @param assets amount to receive from the msg.sender.\n  /// @param minAssetsRequired minimum amount of assets required by the depositor for the transaction to be accepted.\n  /// @param receiver address that will be able to withdraw the deposited assets.\n  /// @return positionAssets total amount of assets (principal + fee) to be withdrawn at maturity.\n  function depositAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 minAssetsRequired,\n    address receiver\n  ) external whenNotPaused whenNotFrozen returns (uint256 positionAssets) {\n    if (assets == 0) revert ZeroDeposit();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.NONE);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n\n    uint256 backupEarnings = pool.accrueEarnings(maturity);\n    floatingAssets += backupEarnings;\n\n    (uint256 fee, uint256 backupFee) = pool.calculateDeposit(assets, backupFeeRate);\n    positionAssets = assets + fee;\n    if (positionAssets < minAssetsRequired) revert Disagreement();\n\n    floatingBackupBorrowed -= pool.deposit(assets);\n    pool.unassignedEarnings -= fee + backupFee;\n    earningsAccumulator += backupFee;\n\n    // update account's position\n    FixedLib.Position storage position = fixedDepositPositions[maturity][receiver];\n\n    // if account doesn't have a current position, add it to the list\n    if (position.principal == 0) {\n      Account storage account = accounts[receiver];\n      account.fixedDeposits = account.fixedDeposits.setMaturity(maturity);\n    }\n\n    position.principal += assets;\n    position.fee += fee;\n\n    emit DepositAtMaturity(maturity, msg.sender, receiver, assets, fee);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @notice Borrows a certain amount from a maturity.\n  /// @param maturity maturity date for repayment.\n  /// @param assets amount to be sent to receiver and repaid by borrower.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept.\n  /// @param receiver address that will receive the borrowed assets.\n  /// @param borrower address that will repay the borrowed assets.\n  /// @return assetsOwed total amount of assets (principal + fee) to be repaid at maturity.\n  function borrowAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 maxAssets,\n    address receiver,\n    address borrower\n  ) external whenNotPaused whenNotFrozen returns (uint256 assetsOwed) {\n    if (assets == 0) revert ZeroBorrow();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.NONE);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n    floatingAssets += pool.accrueEarnings(maturity);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    {\n      uint256 backupDebtAddition = pool.borrow(assets);\n      if (backupDebtAddition != 0) {\n        uint256 newFloatingBackupBorrowed = floatingBackupBorrowed + backupDebtAddition;\n        depositToTreasury(updateFloatingDebt());\n        if (newFloatingBackupBorrowed + floatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n          revert InsufficientProtocolLiquidity();\n        }\n        floatingBackupBorrowed = newFloatingBackupBorrowed;\n      }\n    }\n    uint256 fee;\n    {\n      uint256 memFloatingAssetsAverage = previewFloatingAssetsAverage();\n      uint256 memFloatingDebt = floatingDebt;\n      uint256 fixedRate = interestRateModel.fixedRate(\n        maturity,\n        maxFuturePools,\n        fixedUtilization(pool.supplied, pool.borrowed, memFloatingAssetsAverage),\n        floatingUtilization(memFloatingAssetsAverage, memFloatingDebt),\n        globalUtilization(memFloatingAssetsAverage, memFloatingDebt, floatingBackupBorrowed)\n      );\n      fee = assets.mulWadDown(fixedRate.mulDivDown(maturity - block.timestamp, 365 days));\n    }\n    assetsOwed = assets + fee;\n\n    // validate that the account is not taking arbitrary fees\n    if (assetsOwed > maxAssets) revert Disagreement();\n\n    spendAllowance(borrower, assetsOwed);\n\n    {\n      // if account doesn't have a current position, add it to the list\n      FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n      if (position.principal == 0) {\n        Account storage account = accounts[borrower];\n        account.fixedBorrows = account.fixedBorrows.setMaturity(maturity);\n      }\n\n      // calculate what portion of the fees are to be accrued and what portion goes to earnings accumulator\n      (uint256 newUnassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n        chargeTreasuryFee(fee),\n        assets\n      );\n      if (newUnassignedEarnings != 0) pool.unassignedEarnings += newUnassignedEarnings;\n      collectFreeLunch(newBackupEarnings);\n\n      fixedBorrowPositions[maturity][borrower] = FixedLib.Position(position.principal + assets, position.fee + fee);\n    }\n\n    emit BorrowAtMaturity(maturity, msg.sender, receiver, borrower, assets, fee);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    auditor.checkBorrow(this, borrower);\n    asset.safeTransfer(receiver, assets);\n  }\n\n  /// @notice Withdraws a certain amount from a maturity.\n  /// @param maturity maturity date where the assets will be withdrawn.\n  /// @param positionAssets position size to be reduced.\n  /// @param minAssetsRequired minimum amount required by the account (if discount included for early withdrawal).\n  /// @param receiver address that will receive the withdrawn assets.\n  /// @param owner address that previously deposited the assets.\n  /// @return assetsDiscounted amount of assets withdrawn (can include a discount for early withdraw).\n  function withdrawAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 minAssetsRequired,\n    address receiver,\n    address owner\n  ) external whenNotPaused returns (uint256 assetsDiscounted) {\n    if (positionAssets == 0) revert ZeroWithdraw();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.MATURED);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n    floatingAssets += pool.accrueEarnings(maturity);\n\n    FixedLib.Position memory position = fixedDepositPositions[maturity][owner];\n\n    if (positionAssets > position.principal + position.fee) positionAssets = position.principal + position.fee;\n\n    {\n      // remove the supply from the fixed rate pool\n      uint256 newFloatingBackupBorrowed = floatingBackupBorrowed +\n        pool.withdraw(\n          FixedLib.Position(position.principal, position.fee).scaleProportionally(positionAssets).principal\n        );\n      if (newFloatingBackupBorrowed + floatingDebt > floatingAssets) revert InsufficientProtocolLiquidity();\n      floatingBackupBorrowed = newFloatingBackupBorrowed;\n    }\n\n    // verify if there are any penalties/fee for the account because of early withdrawal, if so discount\n    if (block.timestamp < maturity) {\n      uint256 memFloatingAssetsAverage = previewFloatingAssetsAverage();\n      uint256 memFloatingDebt = floatingDebt;\n      uint256 memFloatingBackupBorrowed = floatingBackupBorrowed;\n\n      uint256 fixedRate = interestRateModel.fixedRate(\n        maturity,\n        maxFuturePools,\n        fixedUtilization(pool.supplied, pool.borrowed, memFloatingAssetsAverage),\n        floatingUtilization(memFloatingAssetsAverage, memFloatingDebt),\n        globalUtilization(memFloatingAssetsAverage, memFloatingDebt, memFloatingBackupBorrowed)\n      );\n      assetsDiscounted = positionAssets.divWadDown(1e18 + fixedRate.mulDivDown(maturity - block.timestamp, 365 days));\n    } else {\n      assetsDiscounted = positionAssets;\n    }\n\n    if (assetsDiscounted < minAssetsRequired) revert Disagreement();\n\n    spendAllowance(owner, assetsDiscounted);\n\n    // all the fees go to unassigned or to the floating pool\n    (uint256 unassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n      chargeTreasuryFee(positionAssets - assetsDiscounted),\n      assetsDiscounted\n    );\n    pool.unassignedEarnings += unassignedEarnings;\n    collectFreeLunch(newBackupEarnings);\n\n    // the account gets discounted the full amount\n    position.reduceProportionally(positionAssets);\n    if (position.principal | position.fee == 0) {\n      delete fixedDepositPositions[maturity][owner];\n      Account storage account = accounts[owner];\n      account.fixedDeposits = account.fixedDeposits.clearMaturity(maturity);\n    } else {\n      // proportionally reduce the values\n      fixedDepositPositions[maturity][owner] = position;\n    }\n\n    emit WithdrawAtMaturity(maturity, msg.sender, receiver, owner, positionAssets, assetsDiscounted);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    asset.safeTransfer(receiver, assetsDiscounted);\n  }\n\n  /// @notice Repays a certain amount to a maturity.\n  /// @param maturity maturity date where the assets will be repaid.\n  /// @param positionAssets amount to be paid for the borrower's debt.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept to be repaid.\n  /// @param borrower address of the account that has the debt.\n  /// @return actualRepayAssets the actual amount that was transferred into the protocol.\n  function repayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower\n  ) external whenNotPaused returns (uint256 actualRepayAssets) {\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.MATURED);\n\n    actualRepayAssets = noTransferRepayAtMaturity(maturity, positionAssets, maxAssets, borrower, true);\n    emitMarketUpdate();\n\n    asset.safeTransferFrom(msg.sender, address(this), actualRepayAssets);\n  }\n\n  /// @notice Allows to (partially) repay a fixed rate position. It does not transfer assets.\n  /// @param maturity the maturity to access the pool.\n  /// @param positionAssets the amount of debt of the pool that should be paid.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept to be repaid.\n  /// @param borrower the address of the account that has the debt.\n  /// @param canDiscount should early repay discounts be applied.\n  /// @return actualRepayAssets the actual amount that should be transferred into the protocol.\n  function noTransferRepayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower,\n    bool canDiscount\n  ) internal returns (uint256 actualRepayAssets) {\n    if (positionAssets == 0) revert ZeroRepay();\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n\n    uint256 backupEarnings = pool.accrueEarnings(maturity);\n    floatingAssets += backupEarnings;\n\n    FixedLib.Position memory position = fixedBorrowPositions[maturity][borrower];\n\n    uint256 debtCovered = Math.min(positionAssets, position.principal + position.fee);\n\n    uint256 principalCovered = FixedLib\n      .Position(position.principal, position.fee)\n      .scaleProportionally(debtCovered)\n      .principal;\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    // early repayment allows a discount from the unassigned earnings\n    if (block.timestamp < maturity) {\n      if (canDiscount) {\n        // calculate the deposit fee considering the amount of debt the account'll pay\n        (uint256 discountFee, uint256 backupFee) = pool.calculateDeposit(principalCovered, backupFeeRate);\n\n        // remove the fee from unassigned earnings\n        pool.unassignedEarnings -= discountFee + backupFee;\n\n        // the fee charged to the fixed pool supplier goes to the earnings accumulator\n        earningsAccumulator += backupFee;\n\n        // the fee gets discounted from the account through `actualRepayAssets`\n        actualRepayAssets = debtCovered - discountFee;\n      } else {\n        actualRepayAssets = debtCovered;\n      }\n    } else {\n      actualRepayAssets = debtCovered + debtCovered.mulWadDown((block.timestamp - maturity) * penaltyRate);\n\n      // all penalties go to the earnings accumulator\n      earningsAccumulator += actualRepayAssets - debtCovered;\n    }\n\n    // verify that the account agrees to this discount or penalty\n    if (actualRepayAssets > maxAssets) revert Disagreement();\n\n    // reduce the borrowed from the pool and might decrease the floating backup borrowed\n    floatingBackupBorrowed -= pool.repay(principalCovered);\n\n    // update the account position\n    position.reduceProportionally(debtCovered);\n    if (position.principal | position.fee == 0) {\n      delete fixedBorrowPositions[maturity][borrower];\n      Account storage account = accounts[borrower];\n      account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n    } else {\n      // proportionally reduce the values\n      fixedBorrowPositions[maturity][borrower] = position;\n    }\n\n    emit RepayAtMaturity(maturity, msg.sender, borrower, actualRepayAssets, debtCovered);\n    emitFixedEarningsUpdate(maturity);\n  }\n\n  /// @notice Liquidates undercollateralized fixed/floating (or both) position(s).\n  /// @dev Msg.sender liquidates borrower's position(s) and repays a certain amount of debt for the floating pool,\n  /// or/and for multiple fixed pools, seizing a portion of borrower's collateral.\n  /// @param borrower account that has an outstanding debt across floating or fixed pools.\n  /// @param maxAssets maximum amount of debt that the liquidator is willing to accept. (it can be less)\n  /// @param seizeMarket market from which the collateral will be seized to give to the liquidator.\n  /// @return repaidAssets actual amount repaid.\n  function liquidate(\n    address borrower,\n    uint256 maxAssets,\n    Market seizeMarket\n  ) external whenNotPaused returns (uint256 repaidAssets) {\n    if (msg.sender == borrower) revert SelfLiquidation();\n\n    maxAssets = auditor.checkLiquidation(this, seizeMarket, borrower, maxAssets);\n    if (maxAssets == 0) revert ZeroRepay();\n\n    Account storage account = accounts[borrower];\n\n    {\n      uint256 packedMaturities = account.fixedBorrows;\n      uint256 maturity = packedMaturities & ((1 << 32) - 1);\n      packedMaturities = packedMaturities >> 32;\n      while (packedMaturities != 0 && maxAssets != 0) {\n        if (packedMaturities & 1 != 0) {\n          uint256 actualRepay;\n          if (block.timestamp < maturity) {\n            actualRepay = noTransferRepayAtMaturity(maturity, maxAssets, maxAssets, borrower, false);\n            maxAssets -= actualRepay;\n          } else {\n            uint256 position;\n            {\n              FixedLib.Position storage p = fixedBorrowPositions[maturity][borrower];\n              position = p.principal + p.fee;\n            }\n            uint256 debt = position + position.mulWadDown((block.timestamp - maturity) * penaltyRate);\n            actualRepay = debt > maxAssets ? maxAssets.mulDivDown(position, debt) : maxAssets;\n\n            if (actualRepay == 0) maxAssets = 0;\n            else {\n              actualRepay = noTransferRepayAtMaturity(maturity, actualRepay, maxAssets, borrower, false);\n              maxAssets -= actualRepay;\n            }\n          }\n          repaidAssets += actualRepay;\n        }\n        packedMaturities >>= 1;\n        maturity += FixedLib.INTERVAL;\n      }\n    }\n\n    if (maxAssets != 0 && account.floatingBorrowShares != 0) {\n      uint256 borrowShares = previewRepay(maxAssets);\n      if (borrowShares != 0) {\n        (uint256 actualRepayAssets, ) = noTransferRefund(borrowShares, borrower);\n        repaidAssets += actualRepayAssets;\n      }\n    }\n\n    // reverts on failure\n    (uint256 lendersAssets, uint256 seizeAssets) = auditor.calculateSeize(this, seizeMarket, borrower, repaidAssets);\n    earningsAccumulator += lendersAssets;\n\n    if (address(seizeMarket) == address(this)) {\n      internalSeize(this, msg.sender, borrower, seizeAssets);\n    } else {\n      seizeMarket.seize(msg.sender, borrower, seizeAssets);\n\n      emitMarketUpdate();\n    }\n\n    emit Liquidate(msg.sender, borrower, repaidAssets, lendersAssets, seizeMarket, seizeAssets);\n\n    auditor.handleBadDebt(borrower);\n\n    asset.safeTransferFrom(msg.sender, address(this), repaidAssets + lendersAssets);\n  }\n\n  /// @notice Clears floating and fixed debt for an account spreading the losses to the `earningsAccumulator`.\n  /// @dev Can only be called from the auditor.\n  /// @param borrower account with insufficient collateral to be cleared the debt.\n  function clearBadDebt(address borrower) external {\n    if (msg.sender != address(auditor)) revert NotAuditor();\n\n    floatingAssets += accrueAccumulatedEarnings();\n    Account storage account = accounts[borrower];\n    uint256 accumulator = earningsAccumulator;\n    uint256 totalBadDebt = 0;\n    uint256 packedMaturities = account.fixedBorrows;\n    uint256 maturity = packedMaturities & ((1 << 32) - 1);\n    packedMaturities = packedMaturities >> 32;\n    while (packedMaturities != 0) {\n      if (packedMaturities & 1 != 0) {\n        FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n        uint256 badDebt = position.principal + position.fee;\n        if (accumulator >= badDebt) {\n          RewardsController memRewardsController = rewardsController;\n          if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n          accumulator -= badDebt;\n          totalBadDebt += badDebt;\n          floatingBackupBorrowed -= fixedPools[maturity].repay(position.principal);\n          delete fixedBorrowPositions[maturity][borrower];\n          account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n\n          emit RepayAtMaturity(maturity, msg.sender, borrower, badDebt, badDebt);\n        }\n      }\n      packedMaturities >>= 1;\n      maturity += FixedLib.INTERVAL;\n    }\n    if (account.floatingBorrowShares != 0 && (accumulator = previewRepay(accumulator)) != 0) {\n      (uint256 badDebt, ) = noTransferRefund(accumulator, borrower);\n      totalBadDebt += badDebt;\n    }\n    if (totalBadDebt != 0) {\n      earningsAccumulator -= totalBadDebt;\n      emit SpreadBadDebt(borrower, totalBadDebt);\n    }\n    emitMarketUpdate();\n  }\n\n  /// @notice Public function to seize a certain amount of assets.\n  /// @dev Public function for liquidator to seize borrowers assets in the floating pool.\n  /// This function will only be called from another Market, on `liquidation` calls.\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a Market).\n  /// @param liquidator address which will receive the seized assets.\n  /// @param borrower address from which the assets will be seized.\n  /// @param assets amount to be removed from borrower's possession.\n  function seize(address liquidator, address borrower, uint256 assets) external whenNotPaused {\n    internalSeize(Market(msg.sender), liquidator, borrower, assets);\n  }\n\n  /// @notice Internal function to seize a certain amount of assets.\n  /// @dev Internal function for liquidator to seize borrowers assets in the floating pool.\n  /// Will only be called from this Market on `liquidation` or through `seize` calls from another Market.\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a Market).\n  /// @param seizeMarket address which is calling the seize function (see `seize` public function).\n  /// @param liquidator address which will receive the seized assets.\n  /// @param borrower address from which the assets will be seized.\n  /// @param assets amount to be removed from borrower's possession.\n  function internalSeize(Market seizeMarket, address liquidator, address borrower, uint256 assets) internal {\n    if (assets == 0) revert ZeroWithdraw();\n\n    // reverts on failure\n    auditor.checkSeize(seizeMarket, this);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(borrower);\n    uint256 shares = previewWithdraw(assets);\n    beforeWithdraw(assets, shares);\n    _burn(borrower, shares);\n    emit Withdraw(msg.sender, liquidator, borrower, assets, shares);\n    emit Seize(liquidator, borrower, assets);\n    emitMarketUpdate();\n\n    asset.safeTransfer(liquidator, assets);\n  }\n\n  /// @notice Hook to update the floating pool average, floating pool balance and distribute earnings from accumulator.\n  /// @param assets amount of assets to be withdrawn from the floating pool.\n  function beforeWithdraw(uint256 assets, uint256) internal override whenNotPaused {\n    updateFloatingAssetsAverage();\n    depositToTreasury(updateFloatingDebt());\n    uint256 earnings = accrueAccumulatedEarnings();\n    uint256 newFloatingAssets = floatingAssets + earnings - assets;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed\n    if (floatingBackupBorrowed + floatingDebt > newFloatingAssets) revert InsufficientProtocolLiquidity();\n    floatingAssets = newFloatingAssets;\n  }\n\n  /// @notice Hook to update the floating pool average, floating pool balance and distribute earnings from accumulator.\n  /// @param assets amount of assets to be deposited to the floating pool.\n  function afterDeposit(uint256 assets, uint256) internal override whenNotPaused whenNotFrozen {\n    updateFloatingAssetsAverage();\n    uint256 treasuryFee = updateFloatingDebt();\n    uint256 earnings = accrueAccumulatedEarnings();\n    floatingAssets += earnings + assets;\n    depositToTreasury(treasuryFee);\n    emitMarketUpdate();\n  }\n\n  /// @notice Withdraws the owner's floating pool assets to the receiver address.\n  /// @dev Makes sure that the owner doesn't have shortfall after withdrawing.\n  /// @param assets amount of underlying to be withdrawn.\n  /// @param receiver address to which the assets will be transferred.\n  /// @param owner address which owns the floating pool assets.\n  /// @return shares amount of shares redeemed for underlying asset.\n  function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {\n    auditor.checkShortfall(this, owner, assets);\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(owner);\n    shares = super.withdraw(assets, receiver, owner);\n    emitMarketUpdate();\n  }\n\n  /// @notice Redeems the owner's floating pool assets"
    }
  ]
}