{
  "Title": "Potential token transfer from unrelated account",
  "Content": "The `CoverReassurance` contract [contains a mechanism](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/lifecycle/CoverReassurance.sol#L66) to retrieve funds from an arbitrary account, as long as the account has provided a non-zero allowance. This would occur whenever a cover owner can front-run another cover owner’s reassurance transaction, allowing them to redirect the funds to their own cover.\n\n\nEven without front-running, there are multiple reasons an account may have a non-zero allowance, including:\n\n\n* Their `addReassurance` transaction failed and they didn’t revoke the allowance.\n* They made an unlimited approval.\n* They approved a higher allowance than the amount they eventually transferred.\n\n\nIn all cases, an attacker can retrieve those funds and direct them towards a cover.\n\n\nA recovery agent could still [retrieve](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Recoverable.sol#L49) the funds from the `CoverReassurance` contract and distribute them as desired, although it is unclear how they would distinguish a front-running attack from one where a cover owner legitimately transfers funds from a different account.\n\n\nConsider retrieving the tokens from the message sender rather than an arbitrary [`account` parameter](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/lifecycle/CoverReassurance.sol#L53).\n\n\n**Update:** *Fixed as of commit `ca55b69c5cdd80bcccdc83dd5d569933f450fa6a` in [pull request #139](https://github.com/neptune-mutual-blue/protocol/pull/139).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/lifecycle/CoverReassurance.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"../../interfaces/IStore.sol\";\nimport \"../../interfaces/ICoverReassurance.sol\";\nimport \"../../libraries/ProtoUtilV1.sol\";\nimport \"../../libraries/CoverUtilV1.sol\";\nimport \"../../libraries/ValidationLibV1.sol\";\nimport \"../../libraries/StoreKeyUtil.sol\";\nimport \"../../libraries/NTransferUtilV2.sol\";\nimport \"../../libraries/GovernanceUtilV1.sol\";\nimport \"../Recoverable.sol\";\n\n/**\n * @title Cover Reassurance\n *\n * @dev A covered project can add reassurance fund to exhibit coverage support for their project.\n * This reduces the cover fee and increases the confidence of liquidity providers.\n * A portion of the reassurance fund is awarded to liquidity providers in the event of a cover incident.\n *\n * <br />\n *\n * - [https://docs.neptunemutual.com/sdk/cover-assurance](https://docs.neptunemutual.com/sdk/cover-assurance)\n * - [https://docs.neptunemutual.com/definitions/cover-products](https://docs.neptunemutual.com/definitions/cover-products)\n *\n */\ncontract CoverReassurance is ICoverReassurance, Recoverable {\n  using ProtoUtilV1 for bytes;\n  using ProtoUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using NTransferUtilV2 for IERC20;\n  using CoverUtilV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using RegistryLibV1 for IStore;\n  using RoutineInvokerLibV1 for IStore;\n  using GovernanceUtilV1 for IStore;\n\n  constructor(IStore store) Recoverable(store) {} // solhint-disable-line\n\n  /**\n   * @dev Adds reassurance to the specified cover contract\n   *\n   * @custom:suppress-acl Reassurance can only be added by cover owner or latest cover contract\n   * @custom:suppress-malicious-erc This ERC-20 `s.getStablecoin()` is a well-known address.\n   *\n   * @param coverKey Enter the cover key\n   * @param account Specify the account from which the reassurance fund will be transferred.\n   * @param amount Enter the amount you would like to supply\n   *\n   */\n  function addReassurance(\n    bytes32 coverKey,\n    address account,\n    uint256 amount\n  ) external override nonReentrant {\n    s.mustNotBePaused();\n    s.mustBeValidCoverKey(coverKey);\n    s.mustBeCoverOwnerOrCoverContract(coverKey, msg.sender);\n\n    require(amount > 0, \"Provide valid amount\");\n\n    IERC20 stablecoin = IERC20(s.getStablecoin());\n\n    s.addUintByKey(CoverUtilV1.getReassuranceKey(coverKey), amount);\n\n    stablecoin.ensureTransferFrom(account, address(this), amount);\n\n    // Do not update state during cover creation\n    // s.updateStateAndLiquidity(coverKey);\n\n    emit ReassuranceAdded(coverKey, amount);\n  }\n\n  /**\n   * @dev Sets the reassurance weight as a percentage value.\n   *\n   * @custom:note About the Reassurance Weight:\n   *\n   * When you set a weight to reassurance fund, it used to\n   * calculate the adjusted reassurance capital available for a cover pool.\n   *\n   * ```\n   * adjusted reassurance fund = (reassurance balance * reassurancePoolWeight) / multiplier\n   * ```\n   *\n   * Since the reassurance fund gets capitalized to its liquidity pool after an incident resolution,\n   * the adjusted amount is therefore regarded as an additional capital available to a cover risks\n   * for that pool. This helps lower the policy premium fees.\n   *\n   * @param coverKey Enter the cover key for which you want to set the weight. You can\n   * provide `0x` as cover key if you want to set reassurance weight globally.\n   * @param weight Enter the weight value as percentage (see ProtoUtilV1.MULTIPLIER).\n   * You can't exceed 100%.\n   *\n   */\n  function setWeight(bytes32 coverKey, uint256 weight) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeLiquidityManager(s);\n    s.mustBeValidCoverKey(coverKey);\n\n    require(weight > 0 && weight <= ProtoUtilV1.MULTIPLIER, \"Please specify weight\");\n\n    s.setUintByKey(CoverUtilV1.getReassuranceWeightKey(coverKey), weight);\n\n    s.updateStateAndLiquidity(coverKey);\n\n    emit WeightSet(coverKey, weight);\n  }\n\n  /**\n   * @dev Capitalizes the cover liquidity pool (or Vault) with whichever\n   * is less between 25% of the suffered loss or 25% of the reassurance pool balance.\n   *\n   * <br /> <br />\n   *\n   * This function can only be invoked if the specified cover was \"claimable\"\n   * and after \"claim period\" is over.\n   *\n   * @param coverKey Enter the cover key that has suffered capital depletion or loss.\n   * @param productKey Enter the product key that has suffered capital depletion or loss.\n   * @param incidentDate Enter the date of the incident report.\n   *\n   */\n  function capitalizePool(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) external override nonReentrant {\n    require(incidentDate > 0, \"Please specify incident date\");\n\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeLiquidityManager(s);\n    s.mustBeSupportedProductOrEmpty(coverKey, productKey);\n    s.mustBeValidIncidentDate(coverKey, productKey, incidentDate);\n    s.mustBeAfterResolutionDeadline(coverKey, productKey);\n    s.mustBeClaimable(coverKey, productKey);\n    s.mustBeAfterClaimExpiry(coverKey, productKey);\n\n    IVault vault = s.getVault(coverKey);\n    IERC20 stablecoin = IERC20(s.getStablecoin());\n\n    uint256 toTransfer = s.getReassuranceTransferrableInternal(coverKey, productKey, incidentDate);\n\n    require(toTransfer > 0, \"Nothing to capitalize\");\n\n    stablecoin.ensureTransfer(address(vault), toTransfer);\n    s.subtractUintByKey(CoverUtilV1.getReassuranceKey(coverKey), toTransfer);\n    s.addReassurancePayoutInternal(coverKey, productKey, incidentDate, toTransfer);\n\n    emit PoolCapitalized(coverKey, productKey, incidentDate, toTransfer);\n  }\n\n  /**\n   * @dev Gets the reassurance amount of the specified cover contract\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   * @param coverKey Enter the cover key\n   */\n  function getReassurance(bytes32 coverKey) external view override returns (uint256) {\n    return s.getReassuranceAmountInternal(coverKey);\n  }\n\n  /**\n   * @dev Version number of this contract\n   */\n  function version() external pure override returns (bytes32) {\n    return \"v0.1\";\n  }\n\n  /**\n   * @dev Name of this contract\n   */\n  function getName() external pure override returns (bytes32) {\n    return ProtoUtilV1.CNAME_COVER_REASSURANCE;\n  }\n}"
    },
    {
      "filename": "contracts/core/Recoverable.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IRecoverable.sol\";\nimport \"../libraries/BaseLibV1.sol\";\nimport \"../libraries/ValidationLibV1.sol\";\n\n/**\n *\n * @title Recoverable Contract\n * @dev The recoverable contract enables \"Recovery Agents\" to recover\n * Ether and ERC-20 tokens sent to this address.\n *\n * To learn more about our recovery policy, please refer to the following doc:\n * https://docs.neptunemutual.com/usage/recovering-cryptocurrencies\n *\n */\nabstract contract Recoverable is ReentrancyGuard, IRecoverable {\n  using ValidationLibV1 for IStore;\n  IStore public override s;\n\n  constructor(IStore store) {\n    require(address(store) != address(0), \"Invalid Store\");\n    s = store;\n  }\n\n  /**\n   * @dev Recover all Ether held by the contract.\n   * On success, no event is emitted because the recovery feature does\n   * not have any significance in the SDK or the UI.\n   */\n  function recoverEther(address sendTo) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeRecoveryAgent(s);\n    BaseLibV1.recoverEtherInternal(sendTo);\n  }\n\n  /**\n   * @dev Recover all ERC-20 compatible tokens sent to this address.\n   * On success, no event is emitted because the recovery feature does\n   * not have any significance in the SDK or the UI.\n   *\n   * @custom:suppress-malicious-erc The malicious ERC-20 `token` should only be invoked via `NTransferUtil`.\n   * @custom:suppress-address-trust-issue Although the token can't be trusted, the recovery agent has to check the token code manually.\n   *\n   * @param token ERC-20 The address of the token contract\n   */\n  function recoverToken(address token, address sendTo) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeRecoveryAgent(s);\n    BaseLibV1.recoverTokenInternal(token, sendTo);\n  }\n}"
    },
    {
      "filename": "contracts/core/lifecycle/CoverReassurance.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"../../interfaces/IStore.sol\";\nimport \"../../interfaces/ICoverReassurance.sol\";\nimport \"../../libraries/ProtoUtilV1.sol\";\nimport \"../../libraries/CoverUtilV1.sol\";\nimport \"../../libraries/ValidationLibV1.sol\";\nimport \"../../libraries/StoreKeyUtil.sol\";\nimport \"../../libraries/NTransferUtilV2.sol\";\nimport \"../../libraries/GovernanceUtilV1.sol\";\nimport \"../Recoverable.sol\";\n\n/**\n * @title Cover Reassurance\n *\n * @dev A covered project can add reassurance fund to exhibit coverage support for their project.\n * This reduces the cover fee and increases the confidence of liquidity providers.\n * A portion of the reassurance fund is awarded to liquidity providers in the event of a cover incident.\n *\n * <br />\n *\n * - [https://docs.neptunemutual.com/sdk/cover-assurance](https://docs.neptunemutual.com/sdk/cover-assurance)\n * - [https://docs.neptunemutual.com/definitions/cover-products](https://docs.neptunemutual.com/definitions/cover-products)\n *\n */\ncontract CoverReassurance is ICoverReassurance, Recoverable {\n  using ProtoUtilV1 for bytes;\n  using ProtoUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using NTransferUtilV2 for IERC20;\n  using CoverUtilV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using RegistryLibV1 for IStore;\n  using RoutineInvokerLibV1 for IStore;\n  using GovernanceUtilV1 for IStore;\n\n  constructor(IStore store) Recoverable(store) {} // solhint-disable-line\n\n  /**\n   * @dev Adds reassurance to the specified cover contract\n   *\n   * @custom:suppress-acl Reassurance can only be added by cover owner or latest cover contract\n   * @custom:suppress-malicious-erc This ERC-20 `s.getStablecoin()` is a well-known address.\n   *\n   * @param coverKey Enter the cover key\n   * @param account Specify the account from which the reassurance fund will be transferred.\n   * @param amount Enter the amount you would like to supply\n   *\n   */\n  function addReassurance(\n    bytes32 coverKey,\n    address account,\n    uint256 amount\n  ) external override nonReentrant {\n    s.mustNotBePaused();\n    s.mustBeValidCoverKey(coverKey);\n    s.mustBeCoverOwnerOrCoverContract(coverKey, msg.sender);\n\n    require(amount > 0, \"Provide valid amount\");\n\n    IERC20 stablecoin = IERC20(s.getStablecoin());\n\n    s.addUintByKey(CoverUtilV1.getReassuranceKey(coverKey), amount);\n\n    stablecoin.ensureTransferFrom(account, address(this), amount);\n\n    // Do not update state during cover creation\n    // s.updateStateAndLiquidity(coverKey);\n\n    emit ReassuranceAdded(coverKey, amount);\n  }\n\n  /**\n   * @dev Sets the reassurance weight as a percentage value.\n   *\n   * @custom:note About the Reassurance Weight:\n   *\n   * When you set a weight to reassurance fund, it used to\n   * calculate the adjusted reassurance capital available for a cover pool.\n   *\n   * ```\n   * adjusted reassurance fund = (reassurance balance * reassurancePoolWeight) / multiplier\n   * ```\n   *\n   * Since the reassurance fund gets capitalized to its liquidity pool after an incident resolution,\n   * the adjusted amount is therefore regarded as an additional capital available to a cover risks\n   * for that pool. This helps lower the policy premium fees.\n   *\n   * @param coverKey Enter the cover key for which you want to set the weight. You can\n   * provide `0x` as cover key if you want to set reassurance weight globally.\n   * @param weight Enter the weight value as percentage (see ProtoUtilV1.MULTIPLIER).\n   * You can't exceed 100%.\n   *\n   */\n  function setWeight(bytes32 coverKey, uint256 weight) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeLiquidityManager(s);\n    s.mustBeValidCoverKey(coverKey);\n\n    require(weight > 0 && weight <= ProtoUtilV1.MULTIPLIER, \"Please specify weight\");\n\n    s.setUintByKey(CoverUtilV1.getReassuranceWeightKey(coverKey), weight);\n\n    s.updateStateAndLiquidity(coverKey);\n\n    emit WeightSet(coverKey, weight);\n  }\n\n  /**\n   * @dev Capitalizes the cover liquidity pool (or Vault) with whichever\n   * is less between 25% of the suffered loss or 25% of the reassurance pool balance.\n   *\n   * <br /> <br />\n   *\n   * This function can only be invoked if the specified cover was \"claimable\"\n   * and after \"claim period\" is over.\n   *\n   * @param coverKey Enter the cover key that has suffered capital depletion or loss.\n   * @param productKey Enter the product key that has suffered capital depletion or loss.\n   * @param incidentDate Enter the date of the incident report.\n   *\n   */\n  function capitalizePool(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) external override nonReentrant {\n    require(incidentDate > 0, \"Please specify incident date\");\n\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeLiquidityManager(s);\n    s.mustBeSupportedProductOrEmpty(coverKey, productKey);\n    s.mustBeValidIncidentDate(coverKey, productKey, incidentDate);\n    s.mustBeAfterResolutionDeadline(coverKey, productKey);\n    s.mustBeClaimable(coverKey, productKey);\n    s.mustBeAfterClaimExpiry(coverKey, productKey);\n\n    IVault vault = s.getVault(coverKey);\n    IERC20 stablecoin = IERC20(s.getStablecoin());\n\n    uint256 toTransfer = s.getReassuranceTransferrableInternal(coverKey, productKey, incidentDate);\n\n    require(toTransfer > 0, \"Nothing to capitalize\");\n\n    stablecoin.ensureTransfer(address(vault), toTransfer);\n    s.subtractUintByKey(CoverUtilV1.getReassuranceKey(coverKey), toTransfer);\n    s.addReassurancePayoutInternal(coverKey, productKey, incidentDate, toTransfer);\n\n    emit PoolCapitalized(coverKey, productKey, incidentDate, toTransfer);\n  }\n\n  /**\n   * @dev Gets the reassurance amount of the specified cover contract\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   * @param coverKey Enter the cover key\n   */\n  function getReassurance(bytes32 coverKey) external view override returns (uint256) {\n    return s.getReassuranceAmountInternal(coverKey);\n  }\n\n  /**\n   * @dev Version number of this contract\n   */\n  function version() external pure override returns (bytes32) {\n    return \"v0.1\";\n  }\n\n  /**\n   * @dev Name of this contract\n   */\n  function getName() external pure override returns (bytes32) {\n    return ProtoUtilV1.CNAME_COVER_REASSURANCE;\n  }\n}"
    }
  ]
}