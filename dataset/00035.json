{
  "Title": "M-2: Protocol won't be eligible for referral rewards for depositing ETH",
  "Content": "# Issue M-2: Protocol won't be eligible for referral rewards for depositing ETH \n\nSource: https://github.com/sherlock-audit/2024-05-sophon-judging/issues/92 \n\n## Found by \nh2134\n## Summary\nProtocol won't be eligible for referral rewards for depositing ETH, as the referral account is not properly set.\n\n## Vulnerability Detail\nWhen user sends ETH to contract **SophonFarming**, or calls ETH deposit functions, protocol will first deposit ETH on external protocols (Lido or Ether.fi) for minting staking shares, then warp the shares to the predefined assets (wstETH or weETH), then user  starts to earn reward points.\n\nThe external protocols allows caller to pass referral argument when depositing ETH, and referral account can be eligible for referral rewards if it is valid. Let's take Ether.fi for example:\n```solidity\n    function _ethTOeEth(uint256 _amount) internal returns (uint256) {\n        // deposit returns exact amount of eETH\n        return IeETHLiquidityPool(eETHLiquidityPool).deposit{value: _amount}(address(this));\n    }\n```\n\nTo convert ETH to eETH, the function `deposit` in [IeETHLiquidityPool](https://etherscan.io/address/0x605f17e88027e25e18c95be0d8011ac969426399#code) is called. In fact, **IeETHLiquidityPool** exposes 2 deposit functions for users to deposit ETH, which have different signatures:\n```solidity\n    // Used by eETH staking flow\n    function deposit() external payable returns (uint256) {\n        return deposit(address(0));\n    }\n\n    // Used by eETH staking flow\n    function deposit(address _referral) public payable whenNotPaused returns (uint256) {\n        require(_isWhitelisted(msg.sender), \"Invalid User\");\n\n        emit Deposit(msg.sender, msg.value, SourceOfFunds.EETH, _referral);\n\n        return _deposit(msg.sender, msg.value, 0);\n    }\n```\nThe `_referral` parameter in the second deposit function indicates the referral account which will be eligible for referral rewards, as stated by ether.fi [here](https://etherfi.gitbook.io/etherfi/getting-started/loyalty-points/referrals):\n> This referral program covers both ether.fi and ether.fan, each 0.1 ETH staked via ether.fi or ether.fan earns the person who stakes > and the the person who referred 100 loyalty points.\n>\n> Note: Referral points may take up to 2 hours to display in your Portfolio.\n\nApparently, by calling the second deposit function and passing **address(this)** as `_referral` argument, our protocol expects to receive the referral rewards, however, this makes the referral as the same account as the depositor itself (msg.sender), this is invalid to ether.fi and no rewards will be granted to the account which uses one's own referral code for depositing.\n\nSimilarly, protocol won't receive referral rewards from Lido as it set referral to itself when submit to deposit ETH:\n```solidity\n    function _ethTOstEth(uint256 _amount) internal returns (uint256) {\n        // submit function does not return exact amount of stETH so we need to check balances\n        uint256 balanceBefore = IERC20(stETH).balanceOf(address(this));\n@=>     IstETH(stETH).submit{value: _amount}(address(this));\n        return (IERC20(stETH).balanceOf(address(this)) - balanceBefore);\n    }\n```\n\n## Impact\nProtocol won't be eligible for referral rewards as expected, this can be significant value leak to the protocol.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-05-sophon/blob/main/farming-contracts/contracts/farm/SophonFarming.sol#L811\nhttps://github.com/sherlock-audit/2024-05-sophon/blob/main/farming-contracts/contracts/farm/SophonFarming.sol#L834\n\n## Tool used\nManual Review\n\n## Recommendation\nUser `owner` account as referral instead of the caller contract itself.\n```diff\n    function _ethTOstEth(uint256 _amount) internal returns (uint256) {\n        // submit function does not return exact amount of stETH so we need to check balances\n        uint256 balanceBefore = IERC20(stETH).balanceOf(address(this));\n-       IstETH(stETH).submit{value: _amount}(address(this));\n+       IstETH(stETH).submit{value: _amount}(owner());\n        return (IERC20(stETH).balanceOf(address(this)) - balanceBefore);\n    }\n```\n\n```diff\n    function _ethTOeEth(uint256 _amount) internal returns (uint256) {\n        // deposit returns exact amount of eETH\n-       return IeETHLiquidityPool(eETHLiquidityPool).deposit{value: _amount}(address(this));\n+       return IeETHLiquidityPool(eETHLiquidityPool).deposit{value: _amount}(owner());\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xmystery** commented:\n>  valid because referral should indeed be an EOA which can be multisig \n\n\n\n**ZdravkoHr**\n\nEscalate\nThis issue looks like Oportunity Loss which is not accepted as H/M by Sherlock. For example, a contract not opting-in for gas yield on Blast would not be a valid H/M.\n\n**sherlock-admin3**\n\n> Escalate\n> This issue looks like Oportunity Loss which is not accepted as H/M by Sherlock. For example, a contract not opting-in for gas yield on Blast would not be a valid H/M.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mystery0x**\n\n> Escalate This issue looks like Oportunity Loss which is not accepted as H/M by Sherlock. For example, a contract not opting-in for gas yield on Blast would not be a valid H/M.\n\nI think this will mean a lot more than just `Opportunity Loss` given that many transactions are going to route through these calls. \n\n**WangSecurity**\n\n@mystery0x could you please iterate why you think it's not an Opportunity loss?\n\n**0xh2134**\n\nThis issue is not opportunity loss because:\n1. It's not caused by loss of functionality but the wrong argument in the code;\n2. It's protocol design to receive referral rewards, this can be seen from the code implementation (and sponsor's confirmation of this issue)\n\nThis issue may fall into this category:\n> Loss of airdrops or liquidity fees or any other rewards that are not part of the original protocol design is not considered a valid high/medium\n\nHowever because referral rewards is the protocol design, so this issue is valid.\n\n**mystery0x**\n\n@WangSecurity \n@0xh2134 addresses a valid point because of the erring integration (In the [example](https://github.com/sherlock-audit/2023-02-openq-judging/issues/323) provided by Sherlock Criteria for Issue Validity doc, users do not have an option to claim their airdrops whereas the referral bonus in this context is readily claimable albeit is denied due to wrong input of function argument.) \n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/sophon-org/farming-contracts/commit/73adb6759b899e1a192fb5e28a5cd6202b5c3ff2\n\n\n**WangSecurity**\n\nI agree that it's not an opportunity loss and doesn't qualify for a loss of rewards, since the protocol's code wants to receive them, but it doesn't due to code issue. Hence, I believe it's part of the original protocol design.\n\nPlanning to reject the escalation and leave the issue as it is.\n\n**ZdravkoHr**\n\nIsn't the main reward from stETH coming from beacon chain staking rewards and thia refferal fee is just an additional bonus?\n\n**WangSecurity**\n\nAs I understand yes, but as I see in the code, these rewards are part of the protocol's design and they want to accrue them, but it won't happen due to an issue in the code. Or am I missing something?\n\nIf not, decision remains the same, reject the escalation and leave the issue as it is.\n\n**ZdravkoHr**\n\nHow do we understand that they want to accrue them? \n\n**WangSecurity**\n\nBy the fact that they submit an address to receive the rewards, instead of address(0) for example, it would be fair if they didn't care. But, actually, looking at this issue a couple of times more, I'm not sure about it. Is it possible to see the code implementation of that submit function? I think it might shed some light on the problem.\n\n**ZdravkoHr**\n\nI found this function from the [LIDO contract](https://github.com/lidofinance/lido-dao/blob/5fcedc6e9a9f3ec154e69cff47c2b9e25503a78a/contracts/0.4.24/Lido.sol#L922C1-L947C6) it seems the `referral` is used only in event emission.\n\n```solidity\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, \"ZERO_DEPOSIT\");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), \"STAKING_PAUSED\");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, \"STAKE_LIMIT\");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n```\nAlso, in [this article](https://blog.ts.finance/referral-programs-in-defi-analyzing-effectiveness-and-strategies-for-success/) it's explained that the rewards go to the specified address and not to the calling one - I didn't know that :D \n\n> To participate, users simply need to generate a referral URL from their Ethereum addresses and share the link with others. The referrer is rewarded with payback in LDO, Lido's native token, based on the amount of ETH staked by users who join through the referral link.\n\n\n**0xh2134**\n\nThe way I see it, it's obvious that they want to accrue referral rewards:\n1. When deposit into Lido, call `submit(address _referral)` function with `_referral ` being `address(this)` instead of `address(0)`\n2. When deposit into Ether.fi, call `deposit(address _referral)` function with `_referral ` being `address(this)`, instead of calling the default `deposit()` function\n\nThe deposit events are processed by Lido / Ether.fi offline, and referral rewards are distributed to `_referral`. However, in the context of deposit event, the `msg.sender` is **SophonFarming** contract and `_referral` is also **SophonFarming** contract, as I confirmed with Ether.fi, no referral rewards will be distributed if `_referral` is the same as the `msg.sender`.\n\n<img src=\"https://i.ibb.co/nmsxsyf/2024-06-07-10-13-15.png\" alt=\"2024-06-07-10-13-15\" border=\"0\">\n\nSo, because they want to accrue referral rewards, they need to set `_referral` to a different address other than `msg.sender`, for example, the owner, then the owner can send referral rewards back to **SophonFarming** contract.\n\nBTW, I believe it's highly likely that the referral rewards would be used as rewards to point holders, that's why the want to accrue them.\n\n**WangSecurity**\n\nThanks for both of your answers. I also confirmed with the sponsor that these referral rewards are indeed part of their original design and they intended to receive them. I know that some may say it was known only after the contest, but I believe in this situation it's quite unclear from the code if they intended to receive them and all the watsons could ask sponsors about it during the contest. With that said, since the team intends to receive these rewards, but made a code issue leading to losing these rewards, planning to reject the escalation and leave the issue as it is.\n\n**WangSecurity**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ZdravkoHr](https://github.com/sherlock-audit/2024-05-sophon-judging/issues/92/#issuecomment-2145938719): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/376",
  "Code": [
    {
      "filename": "farming-contracts/contracts/farm/SophonFarming.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IWeth.sol\";\nimport \"./interfaces/IstETH.sol\";\nimport \"./interfaces/IwstETH.sol\";\nimport \"./interfaces/IsDAI.sol\";\nimport \"./interfaces/IeETHLiquidityPool.sol\";\nimport \"./interfaces/IweETH.sol\";\nimport \"../proxies/Upgradeable2Step.sol\";\nimport \"./SophonFarmingState.sol\";\n\n/**\n * @title Sophon Farming Contract\n * @author Sophon\n */\ncontract SophonFarming is Upgradeable2Step, SophonFarmingState {\n    using SafeERC20 for IERC20;\n\n    /// @notice Emitted when a new pool is added\n    event Add(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n\n    /// @notice Emitted when a pool is updated\n    event Set(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n\n    /// @notice Emitted when a user deposits to a pool\n    event Deposit(address indexed user, uint256 indexed pid, uint256 depositAmount, uint256 boostAmount);\n\n    /// @notice Emitted when a user withdraws from a pool\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    /// @notice Emitted when a user increases the boost of an existing deposit\n    event IncreaseBoost(address indexed user, uint256 indexed pid, uint256 boostAmount);\n\n    /// @notice Emitted when all pool funds are bridged to Sophon blockchain\n    event Bridge(address indexed user, uint256 indexed pid, uint256 amount);\n\n    /// @notice Emitted when the admin withdraws booster proceeds\n    event WithdrawProceeds(uint256 indexed pid, uint256 proceeds);\n\n    error PoolExists();\n    error PoolDoesNotExist();\n    error AlreadyInitialized();\n    error NotFound(address lpToken);\n    error FarmingIsStarted();\n    error FarmingIsEnded();\n    error InvalidStartBlock();\n    error InvalidEndBlock();\n    error InvalidDeposit();\n    error InvalidBooster();\n    error WithdrawNotAllowed();\n    error WithdrawTooHigh(uint256 maxAllowed);\n    error WithdrawIsZero();\n    error NothingInPool();\n    error NoEthSent();\n    error BoostTooHigh(uint256 maxAllowed);\n    error BoostIsZero();\n    error BridgeInvalid();\n\n    address public immutable dai;\n    address public immutable sDAI;\n    address public immutable weth;\n    address public immutable stETH;\n    address public immutable wstETH;\n    address public immutable eETH;\n    address public immutable eETHLiquidityPool;\n    address public immutable weETH;\n\n    /**\n     * @notice Construct SophonFarming\n     * @param tokens_ Immutable token addresses\n     * @dev 0:dai, 1:sDAI, 2:weth, 3:stETH, 4:wstETH, 5:eETH, 6:eETHLiquidityPool, 7:weETH\n     */\n    constructor(address[8] memory tokens_) {\n        dai = tokens_[0];\n        sDAI = tokens_[1];\n        weth = tokens_[2];\n        stETH = tokens_[3];\n        wstETH = tokens_[4];\n        eETH = tokens_[5];\n        eETHLiquidityPool = tokens_[6];\n        weETH = tokens_[7];\n    }\n\n    /**\n     * @notice Allows direct deposits of ETH for deposit to the wstETH pool\n     */\n    receive() external payable {\n        if (msg.sender == weth) {\n            return;\n        }\n\n        depositEth(0, PredefinedPool.wstETH);\n    }\n\n    /**\n     * @notice Initialize the farm\n     * @param ethAllocPoint_ eth alloc points\n     * @param sDAIAllocPoint_ sdai alloc points\n     * @param _pointsPerBlock points per block\n     * @param _startBlock start block\n     * @param _boosterMultiplier booster multiplier\n     */\n    function initialize(uint256 ethAllocPoint_, uint256 sDAIAllocPoint_, uint256 _pointsPerBlock, uint256 _startBlock, uint256 _boosterMultiplier) public virtual onlyOwner {\n        if (_initialized) {\n            revert AlreadyInitialized();\n        }\n\n        pointsPerBlock = _pointsPerBlock;\n\n        if (_startBlock == 0) {\n            revert InvalidStartBlock();\n        }\n        startBlock = _startBlock;\n\n        if (_boosterMultiplier < 1e18) {\n            revert InvalidBooster();\n        }\n        boosterMultiplier = _boosterMultiplier;\n\n        poolExists[dai] = true;\n        poolExists[weth] = true;\n        poolExists[stETH] = true;\n        poolExists[eETH] = true;\n\n        // sDAI\n        typeToId[PredefinedPool.sDAI] = add(sDAIAllocPoint_, sDAI, \"sDAI\", false);\n        IERC20(dai).approve(sDAI, 2**256-1);\n\n        // wstETH\n        typeToId[PredefinedPool.wstETH] = add(ethAllocPoint_, wstETH, \"wstETH\", false);\n        IERC20(stETH).approve(wstETH, 2**256-1);\n\n        // weETH\n        typeToId[PredefinedPool.weETH] = add(ethAllocPoint_, weETH, \"weETH\", false);\n        IERC20(eETH).approve(weETH, 2**256-1);\n\n        _initialized = true;\n    }\n\n    /**\n     * @notice Adds a new pool to the farm. Can only be called by the owner.\n     * @param _allocPoint alloc point for new pool\n     * @param _lpToken lpToken address\n     * @param _description description of new pool\n     * @param _withUpdate True will update accounting for all pools\n     * @return uint256 The pid of the newly created asset\n     */\n    function add(uint256 _allocPoint, address _lpToken, string memory _description, bool _withUpdate) public onlyOwner returns (uint256) {\n        if (poolExists[_lpToken]) {\n            revert PoolExists();\n        }\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock =\n            getBlockNumber() > startBlock ? getBlockNumber() : startBlock;\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolExists[_lpToken] = true;\n\n        uint256 pid = poolInfo.length;\n\n        poolInfo.push(\n            PoolInfo({\n                lpToken: IERC20(_lpToken),\n                l2Farm: address(0),\n                amount: 0,\n                boostAmount: 0,\n                depositAmount: 0,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accPointsPerShare: 0,\n                description: _description\n            })\n        );\n\n        emit Add(_lpToken, pid, _allocPoint);\n\n        return pid;\n    }\n\n    /**\n     * @notice Updates the given pool's allocation point. Can only be called by the owner.\n     * @param _pid The pid to update\n     * @param _allocPoint The new alloc point to set for the pool\n     * @param _withUpdate True will update accounting for all pools\n     */\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        address lpToken = address(pool.lpToken);\n        if (lpToken == address(0) || !poolExists[lpToken]) {\n            revert PoolDoesNotExist();\n        }\n        totalAllocPoint = totalAllocPoint - pool.allocPoint + _allocPoint;\n        pool.allocPoint = _allocPoint;\n\n        if (getBlockNumber() < pool.lastRewardBlock) {\n            pool.lastRewardBlock = startBlock;\n        }\n\n        emit Set(lpToken, _pid, _allocPoint);\n    }\n\n    /**\n     * @notice Returns the number of pools in the farm\n     * @return uint256 number of pools\n     */\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /**\n     * @notice Checks if farming is ended\n     * @return bool True if farming is ended\n     */\n    function isFarmingEnded() public view returns (bool) {\n        uint256 _endBlock = endBlock;\n        if (_endBlock != 0 && getBlockNumber() > _endBlock) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Checks if the withdrawal period is ended\n     * @return bool True if withdrawal period is ended\n     */\n    function isWithdrawPeriodEnded() public view returns (bool) {\n        uint256 _endBlockForWithdrawals = endBlockForWithdrawals;\n        if (_endBlockForWithdrawals != 0 && getBlockNumber() > _endBlockForWithdrawals) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Updates the bridge contract\n     */\n    function setBridge(BridgeLike _bridge) public onlyOwner {\n        bridge = _bridge;\n    }\n\n    /**\n     * @notice Updates the L2 Farm for the pool\n     * @param _pid the pid\n     * @param _l2Farm the l2Farm address\n     */\n    function setL2FarmForPool(uint256 _pid, address _l2Farm) public onlyOwner {\n        poolInfo[_pid].l2Farm = _l2Farm;\n    }\n\n    /**\n     * @notice Set the start block of the farm\n     * @param _startBlock the start block\n     */\n    function setStartBlock(uint256 _startBlock) public onlyOwner {\n        if (_startBlock == 0 || (endBlock != 0 && _startBlock >= endBlock)) {\n            revert InvalidStartBlock();\n        }\n        if (getBlockNumber() > startBlock) {\n            revert FarmingIsStarted();\n        }\n        startBlock = _startBlock;\n    }\n\n    /**\n     * @notice Set the end block of the farm\n     * @param _endBlock the end block\n     * @param _withdrawalBlocks the last block that withdrawals are allowed\n     */\n    function setEndBlock(uint256 _endBlock, uint256 _withdrawalBlocks) public onlyOwner {\n        uint256 _endBlockForWithdrawals;\n        if (_endBlock != 0) {\n            if (_endBlock <= startBlock || getBlockNumber() > _endBlock) {\n                revert InvalidEndBlock();\n            }\n            if (isFarmingEnded()) {\n                revert FarmingIsEnded();\n            }\n            _endBlockForWithdrawals = _endBlock + _withdrawalBlocks;\n        } else {\n            // withdrawal blocks needs an endBlock\n            _endBlockForWithdrawals = 0;\n        }\n        massUpdatePools();\n        endBlock = _endBlock;\n        endBlockForWithdrawals = _endBlockForWithdrawals;\n    }\n\n    /**\n     * @notice Set points per block\n     * @param _pointsPerBlock points per block to set\n     */\n    function setPointsPerBlock(uint256 _pointsPerBlock) public onlyOwner {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        massUpdatePools();\n        pointsPerBlock = _pointsPerBlock;\n    }\n\n    /**\n     * @notice Set booster multiplier\n     * @param _boosterMultiplier booster multiplier to set\n     */\n    function setBoosterMultiplier(uint256 _boosterMultiplier) public onlyOwner {\n        if (_boosterMultiplier < 1e18) {\n            revert InvalidBooster();\n        }\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        massUpdatePools();\n        boosterMultiplier = _boosterMultiplier;\n    }\n\n    /**\n     * @notice Returns the block multiplier\n     * @param _from from block\n     * @param _to to block\n     * @return uint256 The block multiplier\n     */\n    function _getBlockMultiplier(uint256 _from, uint256 _to) internal view returns (uint256) {\n        uint256 _endBlock = endBlock;\n        if (_endBlock != 0) {\n            _to = Math.min(_to, _endBlock);\n        }\n        if (_to > _from) {\n            return (_to - _from) * 1e18;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns pending points for user in a pool\n     * @param _pid pid of the pool\n     * @param _user user in the pool\n     * @return uint256 pendings points\n     */\n    function _pendingPoints(uint256 _pid, address _user) internal view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n\n        uint256 accPointsPerShare = pool.accPointsPerShare * 1e18;\n\n        uint256 lpSupply = pool.amount;\n        if (getBlockNumber() > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 blockMultiplier = _getBlockMultiplier(pool.lastRewardBlock, getBlockNumber());\n\n            uint256 pointReward =\n                blockMultiplier *\n                pointsPerBlock *\n                pool.allocPoint /\n                totalAllocPoint;\n\n            accPointsPerShare = pointReward *\n                1e18 /\n                lpSupply +\n                accPointsPerShare;\n        }\n\n        return user.amount *\n            accPointsPerShare /\n            1e36 +\n            user.rewardSettled -\n            user.rewardDebt;\n    }\n\n    /**\n     * @notice Returns pending points for user in a pool\n     * @param _pid pid of the pool\n     * @param _user user in the pool\n     * @return uint256 pendings points\n     */\n    function pendingPoints(uint256 _pid, address _user) external view returns (uint256) {\n        return _pendingPoints(_pid, _user);\n    }\n\n    /**\n     * @notice Update accounting of all pools\n     */\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for(uint256 pid = 0; pid < length;) {\n            updatePool(pid);\n            unchecked { ++pid; }\n        }\n    }\n\n    /**\n     * @notice Updating accounting of a single pool\n     * @param _pid pid to update\n     */\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (getBlockNumber() <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.amount;\n        uint256 _pointsPerBlock = pointsPerBlock;\n        uint256 _allocPoint = pool.allocPoint;\n        if (lpSupply == 0 || _pointsPerBlock == 0 || _allocPoint == 0) {\n            pool.lastRewardBlock = getBlockNumber();\n            return;\n        }\n        uint256 blockMultiplier = _getBlockMultiplier(pool.lastRewardBlock, getBlockNumber());\n        uint256 pointReward =\n            blockMultiplier *\n            _pointsPerBlock *\n            _allocPoint /\n            totalAllocPoint;\n\n        pool.accPointsPerShare = pointReward /\n            lpSupply +\n            pool.accPointsPerShare;\n\n        pool.lastRewardBlock = getBlockNumber();\n    }\n\n    /**\n     * @notice Deposit assets to SophonFarming\n     * @param _pid pid of the pool\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function deposit(uint256 _pid, uint256 _amount, uint256 _boostAmount) external {\n        poolInfo[_pid].lpToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _deposit(_pid, _amount, _boostAmount);\n    }\n\n    /**\n     * @notice Deposit DAI to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function depositDai(uint256 _amount, uint256 _boostAmount) external {\n        IERC20(dai).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _depositPredefinedAsset(_amount, _amount, _boostAmount, PredefinedPool.sDAI);\n    }\n\n    /**\n     * @notice Deposit stETH to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function depositStEth(uint256 _amount, uint256 _boostAmount) external {\n        IERC20(stETH).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _depositPredefinedAsset(_amount, _amount, _boostAmount, PredefinedPool.wstETH);\n    }\n\n    /**\n     * @notice Deposit eETH to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function depositeEth(uint256 _amount, uint256 _boostAmount) external {\n        IERC20(eETH).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        _depositPredefinedAsset(_amount, _amount, _boostAmount, PredefinedPool.weETH);\n    }\n\n    /**\n     * @notice Deposit ETH to SophonFarming when specifying a pool\n     * @param _boostAmount amount to boost\n     * @param _predefinedPool specific pool type to deposit to\n     */\n    function depositEth(uint256 _boostAmount, PredefinedPool _predefinedPool) public payable {\n        if (msg.value == 0) {\n            revert NoEthSent();\n        }\n\n        uint256 _finalAmount = msg.value;\n        if (_predefinedPool == PredefinedPool.wstETH) {\n            _finalAmount = _ethTOstEth(_finalAmount);\n        } else if (_predefinedPool == PredefinedPool.weETH) {\n            _finalAmount = _ethTOeEth(_finalAmount);\n        }\n\n        _depositPredefinedAsset(_finalAmount, msg.value, _boostAmount, _predefinedPool);\n    }\n\n    /**\n     * @notice Deposit WETH to SophonFarming when specifying a pool\n     * @param _amount amount of the deposit\n     * @param _boostAmount amount to boost\n     * @param _predefinedPool specific pool type to deposit to\n     */\n    function depositWeth(uint256 _amount, uint256 _boostAmount, PredefinedPool _predefinedPool) external {\n        IERC20(weth).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        uint256 _finalAmount = _wethTOEth(_amount);\n        if (_predefinedPool == PredefinedPool.wstETH) {\n            _finalAmount = _ethTOstEth(_finalAmount);\n        } else if (_predefinedPool == PredefinedPool.weETH) {\n            _finalAmount = _ethTOeEth(_finalAmount);\n        }\n\n        _depositPredefinedAsset(_finalAmount, _amount, _boostAmount, _predefinedPool);\n    }\n\n    /**\n     * @notice Deposit a predefined asset to SophonFarming\n     * @param _amount amount of the deposit\n     * @param _initalAmount amount of the deposit prior to conversions\n     * @param _boostAmount amount to boost\n     * @param _predefinedPool specific pool type to deposit to\n     */\n    function _depositPredefinedAsset(uint256 _amount, uint256 _initalAmount, uint256 _boostAmount, PredefinedPool _predefinedPool) internal {\n\n        uint256 _finalAmount;\n\n        if (_predefinedPool == PredefinedPool.sDAI) {\n            _finalAmount = _daiTOsDai(_amount);\n        } else if (_predefinedPool == PredefinedPool.wstETH) {\n            _finalAmount = _stEthTOwstEth(_amount);\n        } else if (_predefinedPool == PredefinedPool.weETH) {\n            _finalAmount = _eethTOweEth(_amount);\n        } else {\n            revert InvalidDeposit();\n        }\n\n        // adjust boostAmount for the new asset\n        _boostAmount = _boostAmount * _finalAmount / _initalAmount;\n\n        _deposit(typeToId[_predefinedPool], _finalAmount, _boostAmount);\n    }\n\n    /**\n     * @notice Deposit an asset to SophonFarming\n     * @param _pid pid of the deposit\n     * @param _depositAmount amount of the deposit\n     * @param _boostAmount amount to boost\n     */\n    function _deposit(uint256 _pid, uint256 _depositAmount, uint256 _boostAmount) internal {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n        if (_depositAmount == 0) {\n            revert InvalidDeposit();\n        }\n        if (_boostAmount > _depositAmount) {\n            revert BoostTooHigh(_depositAmount);\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n\n        uint256 userAmount = user.amount;\n        user.rewardSettled =\n            userAmount *\n            pool.accPointsPerShare /\n            1e18 +\n            user.rewardSettled -\n            user.rewardDebt;\n\n        // booster purchase proceeds\n        heldProceeds[_pid] = heldProceeds[_pid] + _boostAmount;\n\n        // deposit amount is reduced by amount of the deposit to boost\n        _depositAmount = _depositAmount - _boostAmount;\n\n        // set deposit amount\n        user.depositAmount = user.depositAmount + _depositAmount;\n        pool.depositAmount = pool.depositAmount + _depositAmount;\n\n        // apply the boost multiplier\n        _boostAmount = _boostAmount * boosterMultiplier / 1e18;\n\n        user.boostAmount = user.boostAmount + _boostAmount;\n        pool.boostAmount = pool.boostAmount + _boostAmount;\n\n        // userAmount is increased by remaining deposit amount + full boosted amount\n        userAmount = userAmount + _depositAmount + _boostAmount;\n\n        user.amount = userAmount;\n        pool.amount = pool.amount + _depositAmount + _boostAmount;\n\n        user.rewardDebt = userAmount *\n            pool.accPointsPerShare /\n            1e18;\n\n        emit Deposit(msg.sender, _pid, _depositAmount, _boostAmount);\n    }\n\n    /**\n     * @notice Increase boost from existing deposits\n     * @param _pid pid to pool\n     * @param _boostAmount amount to boost\n     */\n    function increaseBoost(uint256 _pid, uint256 _boostAmount) external {\n        if (isFarmingEnded()) {\n            revert FarmingIsEnded();\n        }\n\n        if (_boostAmount == 0) {\n            revert BoostIsZero();\n        }\n\n        uint256 maxAdditionalBoost = getMaxAdditionalBoost(msg.sender, _pid);\n        if (_boostAmount > maxAdditionalBoost) {\n            revert BoostTooHigh(maxAdditionalBoost);\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n\n        uint256 userAmount = user.amount;\n        user.rewardSettled =\n            userAmount *\n            pool.accPointsPerShare /\n            1e18 +\n            user.rewardSettled -\n            user.rewardDebt;\n\n        // booster purchase proceeds\n        heldProceeds[_pid] = heldProceeds[_pid] + _boostAmount;\n\n        // user's remaining deposit is reduced by amount of the deposit to boost\n        user.depositAmount = user.depositAmount - _boostAmount;\n        pool.depositAmount = pool.depositAmount - _boostAmount;\n\n        // apply the multiplier\n        uint256 finalBoostAmount = _boostAmount * boosterMultiplier / 1e18;\n\n        user.boostAmount = user.boostAmount + finalBoostAmount;\n        pool.boostAmount = pool.boostAmount + finalBoostAmount;\n\n        // user amount is increased by the full boosted amount - deposit amount used to boost\n        userAmount = userAmount + finalBoostAmount - _boostAmount;\n\n        user.amount = userAmount;\n        pool.amount = pool.amount + finalBoostAmount - _boostAmount;\n\n        user.rewardDebt = userAmount *\n            pool.accPointsPerShare /\n            1e18;\n\n        emit IncreaseBoost(msg.sender, _pid, finalBoostAmount);\n    }\n\n    /**\n     * @notice Returns max additional boost amount allowed to boost current deposits\n     * @dev total allowed boost is 100% of total deposit\n     * @param _user user in pool\n     * @param _pid pid of pool\n     * @return uint256 max additional boost\n     */\n    function getMaxAdditionalBoost(address _user, uint256 _pid) public view returns (uint256) {\n        return userInfo[_pid][_user].depositAmount;\n    }\n\n    /**\n     * @notice Withdraw an asset to SophonFarming\n     * @param _pid pid of the withdraw\n     * @param _withdrawAmount amount of the withdraw\n     */\n    function withdraw(uint256 _pid, uint256 _withdrawAmount) external {\n        if (isWithdrawPeriodEnded()) {\n            revert WithdrawNotAllowed();\n        }\n        if (_withdrawAmount == 0) {\n            revert WithdrawIsZero();\n        }\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n\n        uint256 userDepositAmount = user.depositAmount;\n\n        if (_withdrawAmount == type(uint256).max) {\n            _withdrawAmount = userDepositAmount;\n        } else if (_withdrawAmount > userDepositAmount) {\n            revert WithdrawTooHigh(userDepositAmount);\n        }\n\n        uint256 userAmount = user.amount;\n        user.rewardSettled =\n            userAmount *\n            pool.accPointsPerShare /\n            1e18 +\n            user.rewardSettled -\n            user.rewardDebt;\n\n        user.depositAmount = userDepositAmount - _withdrawAmount;\n        pool.depositAmount = pool.depositAmount - _withdrawAmount;\n\n        userAmount = userAmount - _withdrawAmount;\n\n        user.amount = userAmount;\n        pool.amount = pool.amount - _withdrawAmount;\n\n        pool.lpToken.safeTransfer(msg.sender, _withdrawAmount);\n\n        user.rewardDebt = userAmount *\n            pool.accPointsPerShare /\n            1e18;\n\n        emit Withdraw(msg.sender, _pid, _withdrawAmount);\n    }\n\n    /**\n     * @notice Permissionless function to allow anyone to bridge during the correct period\n     * @param _pid pid to bridge\n     */\n    function bridgePool(uint256 _pid) external {\n        if (!isFarmingEnded() || !isWithdrawPeriodEnded() || isBridged[_pid]) {\n            revert Unauthorized();\n        }\n\n        updatePool(_pid);\n        PoolInfo storage pool = poolInfo[_pid];\n\n        uint256 depositAmount = pool.depositAmount;\n        if (depositAmount == 0 || address(bridge) == address(0) || pool.l2Farm == address(0)) {\n            revert BridgeInvalid();\n        }\n\n        IERC20 lpToken = pool.lpToken;\n        lpToken.approve(address(bridge), depositAmount);\n\n        // TODO: change _refundRecipient, verify l2Farm, _l2TxGasLimit and _l2TxGasPerPubdataByte\n        // These are pending the launch of Sophon testnet\n        bridge.deposit(\n            pool.l2Farm,            // _l2Receiver\n            address(lpToken),       // _l1Token\n            depositAmount,          // _amount\n            200000,                 // _l2TxGasLimit\n            0,                      // _l2TxGasPerPubdataByte\n            owner()                 // _refundRecipient\n        );\n\n        isBridged[_pid] = true;\n\n        emit Bridge(msg.sender, _pid, depositAmount);\n    }\n\n    // TODO: does this function need to call claimFailedDeposit on the bridge?\n    // This is pending the launch of Sophon testnet\n    /**\n     * @notice Called by an admin if a bridge process to Sophon fails\n     * @param _pid pid of the failed bridge to revert\n     */\n    function revertFailedBridge(uint256 _pid) external onlyOwner {\n        isBridged[_pid] = false;\n    }\n\n    /**\n     * @notice Converts WETH to ETH\n     * @dev WETH withdrawl\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _wethTOEth(uint256 _amount) internal returns (uint256) {\n        // unwrap weth to eth\n        IWeth(weth).withdraw(_amount);\n        return _amount;\n    }\n\n    /**\n     * @notice Converts ETH to stETH\n     * @dev Lido\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _ethTOstEth(uint256 _amount) internal returns (uint256) {\n        // submit function does not return exact amount of stETH so we need to check balances\n        uint256 balanceBefore = IERC20(stETH).balanceOf(address(this));\n        IstETH(stETH).submit{value: _amount}(address(this));\n        return (IERC20(stETH).balanceOf(address(this)) - balanceBefore);\n    }\n\n    /**\n     * @notice Converts stETH to wstETH\n     * @dev Lido\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _stEthTOwstEth(uint256 _amount) internal returns (uint256) {\n        // wrap returns exact amount of wstETH\n        return IwstETH(wstETH).wrap(_amount);\n    }\n\n    /**\n     * @notice Converts ETH to eETH\n     * @dev ether.fi\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _ethTOeEth(uint256 _amount) internal returns (uint256) {\n        // deposit returns exact amount of eETH\n        return IeETHLiquidityPool(eETHLiquidityPool).deposit{value: _amount}(address(this));\n    }\n\n    /**\n     * @notice Converts eETH to weETH\n     * @dev ether.fi\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _eethTOweEth(uint256 _amount) internal returns (uint256) {\n        // wrap returns exact amount of weETH\n        return IweETH(weETH).wrap(_amount);\n    }\n\n    /**\n     * @notice Converts DAI to sDAI\n     * @dev MakerDao\n     * @param _amount in amount\n     * @return uint256 out amount\n     */\n    function _daiTOsDai(uint256 _amount) internal returns (uint256) {\n        // deposit DAI to sDAI\n        return IsDAI(sDAI).deposit(_amount, address(this));\n    }\n\n    /**\n     * @notice Allows an admin to withdraw booster proceeds\n     * @param _pid pid to withdraw proceeds from\n     */\n    function withdrawProceeds(uint256 _pid) external onlyOwner {\n        PoolInfo storage pool = poolInfo[_pid];\n        uint256 _proceeds = heldProceeds[_pid];\n        heldProceeds[_pid] = 0;\n        pool.lpToken.safeTransfer(msg.sender, _proceeds);\n        emit WithdrawProceeds(_pid, _proceeds);\n    }\n\n    /**\n     * @notice Returns the current block number\n     * @dev Included to help with testing since it can be overridden for custom functionality\n     * @return uint256 current block number\n     */\n    function getBlockNumber() virtual public view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns info about each pool\n     * @return poolInfos all pool info\n     */\n    function getPoolInfo() external view returns (PoolInfo[] memory poolInfos) {\n        uint256 length = poolInfo.length;\n        poolInfos = new PoolInfo[](length);\n        for(uint256 pid = 0; pid < length;) {\n            poolInfos[pid] = poolInfo[pid];\n            unchecked { ++pid; }\n        }\n    }\n\n    /**\n     * @notice Returns user info for a list of users\n     * @param _users list of users\n     * @return userInfos optimized user info\n     */\n    function getOptimizedUserInfo(address[] memory _users) external view returns (uint256[4][][] memory userInfos) {\n        userInfos = new uint256[4][][](_users.length);\n        uint256 len = poolInfo.length;\n        for(uint256 i = 0; i < _users.length;) {\n            address _user = _users[i];\n            userInfos[i] = new uint256[4][](len);\n            for(uint256 pid = 0; pid < len;) {\n                UserInfo memory uinfo = userInfo[pid][_user];\n                userInfos[i][pid][0] = uinfo.amount;\n                userInfos[i][pid][1] = uinfo.boostAmount;\n                userInfos[i][pid][2] = uinfo.depositAmount;\n                userInfos[i][pid][3] = _pendingPoints(pid, _user);\n                unchecked { ++pid; }\n            }\n            unchecked { i++; }\n        }\n    }\n\n    /**\n     * @notice Returns accrued points for a list of users\n     * @param _users list of users\n     * @return pendings accured points for user\n     */\n    function getPendingPoints(address[] memory _users) external view returns (uint256[][] memory pendings) {\n        pendings = new uint256[][](_users.length);\n        uint256 len = poolInfo.length;\n        for(uint256 i = 0; i < _users.length;) {\n            address _user = _users[i];\n            pendings[i] = new uint256[](len);\n            for(uint256 pid = 0; pid < len;) {\n                pendings[i][pid] = _pendingPoints(pid, _user);\n                unchecked { ++pid; }\n            }\n            unchecked { i++; }\n        }\n    }\n}"
    },
    {
      "filename": "farming-contracts/contracts/farm/SophonFarming.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IWeth.sol\";\nimport \"./interfaces/IstETH.sol\";\nimport \"./interfaces/IwstETH.sol\";\nimport \"./interfaces/IsDAI.sol\";\nimport \"./interfaces/IeETHLiquidityPool.sol\";\nimport \"./interfaces/IweETH.sol\";\nimport \"../proxies/Upgradeable2Step.sol\";\nimport \"./SophonFarmingState.sol\";\n\n/**\n * @title Sophon Farming Contract\n * @author Sophon\n */\ncontract SophonFarming is Upgradeable2Step, SophonFarmingState {\n    using SafeERC20 for IERC20;\n\n    /// @notice Emitted when a new pool is added\n    event Add(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n\n    /// @notice Emitted when a pool is updated\n    event Set(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n\n    /// @notice Emitted when a user deposits to a pool\n    event Deposit(address indexed user, uint256 indexed pid, uint256 depositAmount, uint256 boostAmount);\n\n    /// @notice Emitted when a user withdraws from a pool\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    /// @notice Emitted when a user increases the boost of an existing deposit\n    event IncreaseBoost(address indexed user, uint256 indexed pid, uint256 boostAmount);\n\n    /// @notice Emitted when all pool funds are bridged to Sophon blockchain\n    event Bridge(address indexed user, uint256 indexed pid, uint256 amount);\n\n    /// @notice Emitted when the admin withdraws booster proceeds\n    event WithdrawProceeds(uint256 indexed pid, uint256 proceeds);\n\n    error PoolExists();\n    error PoolDoesNotExist();\n    error AlreadyInitialized();\n    error NotFound(address lpToken);\n    error FarmingIsStarted();\n    error FarmingIsEnded();\n    error InvalidStartBlock();\n    error InvalidEndBlock();"
    }
  ]
}