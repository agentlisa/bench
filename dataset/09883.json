{
  "Title": "[M-09] Ownership of Swap.vy cannot be transferred",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/curve-v2/Swap.vy#L1129\n\n\n# Vulnerability details\n\n## Impact\nOwnership transfer function of Swap.vy is commented out. Fund can be stuck if an AMM and governance change/upgrade is required.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/curve-v2/Swap.vy#L1129\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/curve-v2/Swap.vy",
      "content": "# @version 0.2.12\n# (c) Curve.Fi, 2021\n# Pool for USDT/BTC/ETH or similar\n\ninterface ERC20:  # Custom ERC20 which works for USDT, WETH and WBTC\n    def transfer(_to: address, _amount: uint256): nonpayable\n    def transferFrom(_from: address, _to: address, _amount: uint256): nonpayable\n    def balanceOf(_user: address) -> uint256: view\n\ninterface CurveToken:\n    def totalSupply() -> uint256: view\n    def mint(_to: address, _value: uint256) -> bool: nonpayable\n    def mint_relative(_to: address, frac: uint256) -> uint256: nonpayable\n    def burnFrom(_to: address, _value: uint256) -> bool: nonpayable\n\n\ninterface Math:\n    def geometric_mean(unsorted_x: uint256[N_COINS]) -> uint256: view\n    def newton_D(ANN: uint256, gamma: uint256, x_unsorted: uint256[N_COINS]) -> uint256: view\n    def newton_y(ANN: uint256, gamma: uint256, x: uint256[N_COINS], D: uint256, i: uint256) -> uint256: view\n    def halfpow(power: uint256, precision: uint256) -> uint256: view\n    def sqrt_int(x: uint256) -> uint256: view\n\n\ninterface Views:\n    def get_dy(i: uint256, j: uint256, dx: uint256, balances: uint256[N_COINS], D: uint256) -> (uint256, uint256): view\n    def get_dx(i: uint256, j: uint256, dy: uint256, balances: uint256[N_COINS], D: uint256) -> (uint256, uint256): view\n    def calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256: view\n\n\ninterface WETH:\n    def deposit(): payable\n    def withdraw(_amount: uint256): nonpayable\n\n\n# Events\nevent TokenExchange:\n    buyer: indexed(address)\n    sold_id: uint256\n    tokens_sold: uint256\n    bought_id: uint256\n    tokens_bought: uint256\n    trade_fee: uint256\n\nevent AddLiquidity:\n    provider: indexed(address)\n    token_amounts: uint256[N_COINS]\n    fee: uint256\n    token_supply: uint256\n\nevent RemoveLiquidity:\n    provider: indexed(address)\n    token_amounts: uint256[N_COINS]\n    token_supply: uint256\n\nevent RemoveLiquidityOne:\n    provider: indexed(address)\n    token_amount: uint256\n    coin_index: uint256\n    coin_amount: uint256\n\nevent CommitNewAdmin:\n    deadline: indexed(uint256)\n    admin: indexed(address)\n\nevent NewAdmin:\n    admin: indexed(address)\n\nevent CommitNewParameters:\n    deadline: indexed(uint256)\n    admin_fee: uint256\n    mid_fee: uint256\n    out_fee: uint256\n    fee_gamma: uint256\n    allowed_extra_profit: uint256\n    adjustment_step: uint256\n    ma_half_time: uint256\n\nevent NewParameters:\n    admin_fee: uint256\n    mid_fee: uint256\n    out_fee: uint256\n    fee_gamma: uint256\n    allowed_extra_profit: uint256\n    adjustment_step: uint256\n    ma_half_time: uint256\n\nevent RampAgamma:\n    initial_A: uint256\n    future_A: uint256\n    initial_gamma: uint256\n    future_gamma: uint256\n    initial_time: uint256\n    future_time: uint256\n\nevent StopRampA:\n    current_A: uint256\n    current_gamma: uint256\n    time: uint256\n\nevent ClaimAdminFee:\n    admin: indexed(address)\n    tokens: uint256\n\n\nN_COINS: constant(int128) = 2  # <- change\nPRECISION: constant(uint256) = 10 ** 18  # The precision to convert to\nA_MULTIPLIER: constant(uint256) = 10000\n\n# These addresses are replaced by the deployer\nmath: address\nviews: address\namm: address\ntotalSupply: public(uint256)\ntoken: address\n\nprice_scale: public(uint256)   # Internal price scale\nprice_oracle: public(uint256)  # Price target given by MA\n\nlast_prices: public(uint256)\nlast_prices_timestamp: public(uint256)\n\ninitial_A_gamma: public(uint256)\nfuture_A_gamma: public(uint256)\ninitial_A_gamma_time: public(uint256)\nfuture_A_gamma_time: public(uint256)\n\nallowed_extra_profit: public(uint256)  # 2 * 10**12 - recommended value\nfuture_allowed_extra_profit: public(uint256)\n\nfee_gamma: public(uint256)\nfuture_fee_gamma: public(uint256)\n\nadjustment_step: public(uint256)\nfuture_adjustment_step: public(uint256)\n\nma_half_time: public(uint256)\nfuture_ma_half_time: public(uint256)\n\nmid_fee: public(uint256)\nout_fee: public(uint256)\nadmin_fee: public(uint256)\nfuture_mid_fee: public(uint256)\nfuture_out_fee: public(uint256)\nfuture_admin_fee: public(uint256)\n\nbalances: public(uint256[N_COINS])\nD: public(uint256)\n\nowner: public(address)\nfuture_owner: public(address)\n\nxcp_profit: public(uint256)\nxcp_profit_a: public(uint256)  # Full profit at last claim of admin fees\nvirtual_price: public(uint256)  # Cached (fast to read) virtual price also used internally\nnot_adjusted: bool\n\nis_killed: public(bool)\nkill_deadline: public(uint256)\ntransfer_ownership_deadline: public(uint256)\nadmin_actions_deadline: public(uint256)\n\nKILL_DEADLINE_DT: constant(uint256) = 2 * 30 * 86400\nADMIN_ACTIONS_DELAY: constant(uint256) = 3 * 86400\nMIN_RAMP_TIME: constant(uint256) = 86400\n\nMAX_ADMIN_FEE: constant(uint256) = 10 * 10 ** 9\nMIN_FEE: constant(uint256) = 5 * 10 ** 5  # 0.5 bps\nMAX_FEE: constant(uint256) = 10 * 10 ** 9\nMAX_A: constant(uint256) = 10000 * A_MULTIPLIER * N_COINS**N_COINS\nMAX_A_CHANGE: constant(uint256) = 10\nMIN_GAMMA: constant(uint256) = 10**10\nMAX_GAMMA: constant(uint256) = 10**16\nNOISE_FEE: constant(uint256) = 10**5  # 0.1 bps\n\n# This must be changed for different N_COINS\n# For example:\n# N_COINS = 3 -> 1  (10**18 -> 10**18)\n# N_COINS = 4 -> 10**8  (10**18 -> 10**10)\n# PRICE_PRECISION_MUL: constant(uint256) = 1\nPRECISIONS: constant(uint256[N_COINS]) = [\n    10**12,\n    1,\n]\n\nINF_COINS: constant(uint256) = 15\nisInitialized: bool\n\n\n@external\ndef initialize (\n    owner: address,\n    math: address,\n    views: address,\n    A: uint256,\n    gamma: uint256,\n    mid_fee: uint256,\n    out_fee: uint256,\n    allowed_extra_profit: uint256,\n    fee_gamma: uint256,\n    adjustment_step: uint256,\n    admin_fee: uint256,\n    ma_half_time: uint256,\n    initial_price: uint256\n):\n    assert not self.isInitialized, \"VAMM: contract is already initialized\"\n    self.math = math\n    self.views = views\n    self.totalSupply = 0\n\n    self.owner = owner\n\n    # Pack A and gamma:\n    # shifted A + gamma\n    A_gamma: uint256 = shift(A, 128)\n    A_gamma = bitwise_or(A_gamma, gamma)\n    self.initial_A_gamma = A_gamma\n    self.future_A_gamma = A_gamma\n\n    self.mid_fee = mid_fee\n    self.out_fee = out_fee\n    self.allowed_extra_profit = allowed_extra_profit\n    self.fee_gamma = fee_gamma\n    self.adjustment_step = adjustment_step\n    self.admin_fee = admin_fee\n\n    self.price_scale = initial_price\n    self.price_oracle = initial_price\n    self.last_prices = initial_price\n    self.last_prices_timestamp = block.timestamp\n    self.ma_half_time = ma_half_time\n    self.xcp_profit_a = 10**18\n    self.kill_deadline = block.timestamp + KILL_DEADLINE_DT\n    self.isInitialized = True\n\n@payable\n@external\ndef __default__():\n    pass\n\n@internal\n@view\ndef xp() -> uint256[N_COINS]:\n    return [self.balances[0] * PRECISIONS[0],\n            self.balances[1] * PRECISIONS[1] * self.price_scale / PRECISION]\n\n\n@view\n@internal\ndef _A_gamma() -> uint256[2]:\n    t1: uint256 = self.future_A_gamma_time\n\n    A_gamma_1: uint256 = self.future_A_gamma\n    gamma1: uint256 = bitwise_and(A_gamma_1, 2**128-1)\n    A1: uint256 = shift(A_gamma_1, -128)\n\n    if block.timestamp < t1:\n        # handle ramping up and down of A\n        A_gamma_0: uint256 = self.initial_A_gamma\n        t0: uint256 = self.initial_A_gamma_time\n\n        # Less readable but more compact way of writing and converting to uint256\n        # gamma0: uint256 = bitwise_and(A_gamma_0, 2**128-1)\n        # A0: uint256 = shift(A_gamma_0, -128)\n        # A1 = A0 + (A1 - A0) * (block.timestamp - t0) / (t1 - t0)\n        # gamma1 = gamma0 + (gamma1 - gamma0) * (block.timestamp - t0) / (t1 - t0)\n\n        t1 -= t0\n        t0 = block.timestamp - t0\n        t2: uint256 = t1 - t0\n\n        A1 = (shift(A_gamma_0, -128) * t2 + A1 * t0) / t1\n        gamma1 = (bitwise_and(A_gamma_0, 2**128-1) * t2 + gamma1 * t0) / t1\n\n    return [A1, gamma1]\n\n\n@view\n@external\ndef A() -> uint256:\n    return self._A_gamma()[0]\n\n\n@view\n@external\ndef gamma() -> uint256:\n    return self._A_gamma()[1]\n\n\n@internal\n@view\ndef _fee(xp: uint256[N_COINS]) -> uint256:\n    return self.mid_fee\n\n\n@external\n@view\ndef fee() -> uint256:\n    return self._fee(self.xp())\n\n\n@external\n@view\ndef fee_calc(xp: uint256[N_COINS]) -> uint256:\n    return self._fee(xp)\n\n\n@internal\n@view\ndef get_xcp(D: uint256) -> uint256:\n    x: uint256[N_COINS] = [D / N_COINS, D * PRECISION / (self.price_scale * N_COINS)]\n    return Math(self.math).geometric_mean(x)\n\n\n@external\n@view\ndef get_virtual_price() -> uint256:\n    return 10**18 * self.get_xcp(self.D) / self.totalSupply\n\n\n@internal\ndef tweak_price(A_gamma: uint256[2],\n                _xp: uint256[N_COINS], p_i: uint256,\n                new_D: uint256):\n    price_oracle: uint256 = self.price_oracle\n    last_prices: uint256 = self.last_prices\n    price_scale: uint256 = self.price_scale\n    last_prices_timestamp: uint256 = self.last_prices_timestamp\n    p_new: uint256 = 0\n\n    if last_prices_timestamp < block.timestamp:\n        # MA update required\n        ma_half_time: uint256 = self.ma_half_time\n        alpha: uint256 = Math(self.math).halfpow((block.timestamp - last_prices_timestamp) * 10**18 / ma_half_time, 10**10)\n        price_oracle = (last_prices * (10**18 - alpha) + price_oracle * alpha) / 10**18\n        self.price_oracle = price_oracle\n        self.last_prices_timestamp = block.timestamp\n\n    D_unadjusted: uint256 = new_D  # Withdrawal methods know new D already\n    if new_D == 0:\n        # We will need this a few times (35k gas)\n        D_unadjusted = Math(self.math).newton_D(A_gamma[0], A_gamma[1], _xp)\n\n    if p_i > 0:\n        last_prices = p_i\n\n    else:\n        # calculate real prices\n        __xp: uint256[N_COINS] = _xp\n        dx_price: uint256 = __xp[0] / 10**6\n        __xp[0] += dx_price\n        last_prices = price_scale * dx_price / (_xp[1] - Math(self.math).newton_y(A_gamma[0], A_gamma[1], __xp, D_unadjusted, 1))\n\n    self.last_prices = last_prices\n\n    total_supply: uint256 = self.totalSupply\n    old_xcp_profit: uint256 = self.xcp_profit\n    old_virtual_price: uint256 = self.virtual_price\n\n    # Update profit numbers without price adjustment first\n    xp: uint256[N_COINS] = [D_unadjusted / N_COINS, D_unadjusted * PRECISION / (N_COINS * price_scale)]\n    xcp_profit: uint256 = 10**18\n    virtual_price: uint256 = 10**18\n\n    if old_virtual_price > 0:\n        xcp: uint256 = Math(self.math).geometric_mean(xp)\n        virtual_price = 10**18 * xcp / total_supply\n        xcp_profit = old_xcp_profit * virtual_price / old_virtual_price\n\n        t: uint256 = self.future_A_gamma_time\n        if virtual_price < old_virtual_price and t == 0:\n            raise \"Loss\"\n        if t == 1:\n            self.future_A_gamma_time = 0\n\n    self.xcp_profit = xcp_profit\n\n    norm: uint256 = price_oracle * 10**18 / price_scale\n    if norm > 10**18:\n        norm -= 10**18\n    else:\n        norm = 10**18 - norm\n    adjustment_step: uint256 = max(self.adjustment_step, norm / 10)\n\n    needs_adjustment: bool = self.not_adjusted\n    # if not needs_adjustment and (virtual_price-10**18 > (xcp_profit-10**18)/2 + self.allowed_extra_profit):\n    # (re-arrange for gas efficiency)\n    if not needs_adjustment and (virtual_price * 2 - 10**18 > xcp_profit + 2*self.allowed_extra_profit) and (norm > adjustment_step) and (old_virtual_price > 0):\n        needs_adjustment = True\n        self.not_adjusted = True\n\n    if needs_adjustment:\n        if norm > adjustment_step and old_virtual_price > 0:\n            p_new = (price_scale * (norm - adjustment_step) + adjustment_step * price_oracle) / norm\n\n            # Calculate balances*prices\n            xp = [_xp[0], _xp[1] * p_new / price_scale]\n\n            # Calculate \"extended constant product\" invariant xCP and virtual price\n            D: uint256 = Math(self.math).newton_D(A_gamma[0], A_gamma[1], xp)\n            xp = [D / N_COINS, D * PRECISION / (N_COINS * p_new)]\n            # We reuse old_virtual_price here but it's not old anymore\n            old_virtual_price = 10**18 * Math(self.math).geometric_mean(xp) / total_supply\n\n            # Proceed if we've got enough profit\n            # if (old_virtual_price > 10**18) and (2 * (old_virtual_price - 10**18) > xcp_profit - 10**18):\n            if (old_virtual_price > 10**18) and (2 * old_virtual_price - 10**18 > xcp_profit):\n                self.price_scale = p_new\n                self.D = D\n                self.virtual_price = old_virtual_price\n\n                return\n\n            else:\n                self.not_adjusted = False\n\n                # Can instead do another flag variable if we want to save bytespace\n                self.D = D_unadjusted\n                self.virtual_price = virtual_price\n                return\n\n    # If we are here, the price_scale adjustment did not happen\n    # Still need to update the profit counter and D\n    self.D = D_unadjusted\n    self.virtual_price = virtual_price\n\n    # norm appeared < adjustment_step after\n    if needs_adjustment:\n        self.not_adjusted = False\n\n\n# @payable\n@external\n@nonreentrant('lock')\ndef exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256) -> (uint256, uint256):\n    assert msg.sender == self.amm, 'VAMM: OnlyAMM'\n    assert not self.is_killed  # dev: the pool is killed\n    assert i != j  # dev: coin index out of range\n    assert i < N_COINS  # dev: coin index out of range\n    assert j < N_COINS  # dev: coin index out of range\n    assert dx > 0  # dev: do not exchange 0 coins\n\n    A_gamma: uint256[2] = self._A_gamma()\n    xp: uint256[N_COINS] = self.balances\n    p: uint256 = 0\n    dy: uint256 = 0\n    trade_fee: uint256 = 0\n\n    if True:  # scope to reduce size of memory when making internal calls later\n        # if i == 2 and use_eth:\n        #     assert msg.value == dx  # dev: incorrect eth amount\n        #     WETH(coins[2]).deposit(value=msg.value)\n        # else:\n        #     assert msg.value == 0  # dev: nonzero eth amount\n        #     # assert might be needed for some tokens - removed one to save bytespace\n        #     ERC20(_coins[i]).transferFrom(msg.sender, self, dx)\n\n        y: uint256 = xp[j]\n        x0: uint256 = xp[i]\n        xp[i] = x0 + dx\n        self.balances[i] = xp[i]\n\n        price_scale: uint256 = self.price_scale\n\n        xp = [xp[0] * PRECISIONS[0], xp[1] * price_scale * PRECISIONS[1] / PRECISION]\n\n        prec_i: uint256 = PRECISIONS[0]\n        prec_j: uint256 = PRECISIONS[1]\n        if i == 1:\n            prec_i = PRECISIONS[1]\n            prec_j = PRECISIONS[0]\n\n        # In case ramp is happening\n        if True:\n            t: uint256 = self.future_A_gamma_time\n            if t > 0:\n                x0 *= prec_i\n                if i > 0:\n                    x0 = x0 * price_scale / PRECISION\n                x1: uint256 = xp[i]  # Back up old value in xp\n                xp[i] = x0\n                self.D = Math(self.math).newton_D(A_gamma[0], A_gamma[1], xp)\n                xp[i] = x1  # And restore\n                if block.timestamp >= t:\n                    self.future_A_gamma_time = 1\n\n        dy = xp[j] - Math(self.math).newton_y(A_gamma[0], A_gamma[1], xp, self.D, j)\n        # Not defining new \"y\" here to have less variables / make subsequent calls cheaper\n        xp[j] -= dy\n        dy -= 1\n\n        if j > 0:\n            dy = dy * PRECISION / price_scale\n        dy /= prec_j\n\n        trade_fee = self._fee(xp) * dy / 10**10\n        dy -= trade_fee\n        assert dy >= min_dy, \"Slippage\"\n        y -= dy\n\n        self.balances[j] = y\n        # assert might be needed for some tokens - removed one to save bytespace\n        # if j == 2 and use_eth:\n        #     WETH(coins[2]).withdraw(dy)\n        #     raw_call(msg.sender, b\"\", value=dy)\n        # else:\n        #     ERC20(_coins[j]).transfer(msg.sender, dy)\n\n        y *= prec_j\n        if j > 0:\n            y = y * price_scale / PRECISION\n        xp[j] = y\n\n        # Calculate price\n        if dx > 10**5 and dy > 10**5:\n            _dx: uint256 = dx * prec_i\n            _dy: uint256 = dy * prec_j\n            if i == 0:\n                p = _dx * 10**18 / _dy\n            else:  # j == 0\n                p = _dy * 10**18 / _dx\n\n    self.tweak_price(A_gamma, xp, p, 0)\n\n    log TokenExchange(msg.sender, i, dx, j, dy, trade_fee)\n    return dy, self.last_prices / PRECISIONS[0]\n\n# @payable\n@external\n@nonreentrant('lock')\ndef exchangeExactOut(i: uint256, j: uint256, dy: uint256, max_dx: uint256) -> (uint256, uint256):\n    assert msg.sender == self.amm, 'VAMM: OnlyAMM'\n    assert not self.is_killed  # dev: the pool is killed\n    assert i != j  # dev: coin index out of range\n    assert i < N_COINS  # dev: coin index out of range\n    assert j < N_COINS  # dev: coin index out of range\n    assert dy > 0  # dev: do not exchange 0 coins\n\n    A_gamma: uint256[2] = self._A_gamma()\n    xp: uint256[N_COINS] = self.balances\n    p: uint256 = 0\n    dx: uint256 = 0\n    trade_fee: uint256 = 0\n\n    if True:  # scope to reduce size of memory when making internal calls later\n        # if i == 2 and use_eth:\n        #     assert msg.value == dx  # dev: incorrect eth amount\n        #     WETH(coins[2]).deposit(value=msg.value)\n        # else:\n        #     assert msg.value == 0  # dev: nonzero eth amount\n        #     # assert might be needed for some tokens - removed one to save bytespace\n        #     ERC20(_coins[i]).transferFrom(msg.sender, self, dx)\n\n        x: uint256 = xp[i]\n        y0: uint256 = xp[j]\n        xp[j] = y0 - dy\n        self.balances[j] = xp[j]\n\n        price_scale: uint256 = self.price_scale\n\n        xp = [xp[0] * PRECISIONS[0], xp[1] * price_scale * PRECISIONS[1] / PRECISION]\n\n        prec_i: uint256 = PRECISIONS[0]\n        prec_j: uint256 = PRECISIONS[1]\n        if i == 1:\n            prec_i = PRECISIONS[1]\n            prec_j = PRECISIONS[0]\n\n        # In case ramp is happening\n        if True:\n            t: uint256 = self.future_A_gamma_time\n            if t > 0:\n                y0 *= prec_j\n                if j > 0:\n                    y0 = y0 * price_scale / PRECISION\n                y1: uint256 = xp[j]  # Back up old value in xp\n                xp[j] = y0\n                self.D = Math(self.math).newton_D(A_gamma[0], A_gamma[1], xp)\n                xp[j] = y1  # And restore\n                if block.timestamp >= t:\n                    self.future_A_gamma_time = 1\n\n        dx =  Math(self.math).newton_y(A_gamma[0], A_gamma[1], xp, self.D, i) - xp[i]\n        # Not defining new \"x\" here to have less variables / make subsequent calls cheaper\n        xp[i] += dx\n        dx += 1\n\n        if i > 0:\n            dx = dx * PRECISION / price_scale\n        dx /= prec_i\n\n        trade_fee = self._fee(xp) * dx / 10**10\n        dx += trade_fee\n        assert dx <= max_dx, \"Slippage\"\n        x += dx\n\n        self.balances[i] = x\n        # assert might be needed for some tokens - removed one to save bytespace\n        # if j == 2 and use_eth:\n        #     WETH(coins[2]).withdraw(dy)\n        #     raw_call(msg.sender, b\"\", value=dy)\n        # else:\n        #     ERC20(_coins[j]).transfer(msg.sender, dy)\n\n        x *= prec_i\n        if i > 0:\n            x = x * price_scale / PRECISION\n        xp[i] = x\n\n        # Calculate price\n        if dx > 10**5 and dy > 10**5:\n            _dx: uint256 = dx * prec_i\n            _dy: uint256 = dy * prec_j\n            if i == 0:\n                p = _dx * 10**18 / _dy\n            else:  # j == 0\n                p = _dy * 10**18 / _dx\n\n    self.tweak_price(A_gamma, xp, p, 0)\n\n    log TokenExchange(msg.sender, i, dx, j, dy, trade_fee)\n    return dx, self.last_prices / PRECISIONS[0]\n\n@external\n@view\ndef get_dy(i: uint256, j: uint256, dx: uint256) -> uint256:\n    return Views(self.views).get_dy(i, j, dx, self.balances, self.D)[0]\n\n@external\n@view\ndef get_dx(i: uint256, j: uint256, dy: uint256) -> uint256:\n    return Views(self.views).get_dx(i, j, dy, self.balances, self.D)[0]\n\n@external\n@view\ndef get_dy_fee(i: uint256, j: uint256, dx: uint256) -> uint256:\n    return Views(self.views).get_dy(i, j, dx, self.balances, self.D)[1]\n\n@external\n@view\ndef get_dx_fee(i: uint256, j: uint256, dy: uint256) -> uint256:\n    return Views(self.views).get_dx(i, j, dy, self.balances, self.D)[1]\n\n@view\n@internal\ndef _calc_token_fee(amounts: uint256[N_COINS], xp: uint256[N_COINS]) -> uint256:\n    # fee = sum(amounts_i - avg(amounts)) * fee' / sum(amounts)\n    fee: uint256 = self._fee(xp) * N_COINS / (4 * (N_COINS-1))\n    S: uint256 = 0\n    for _x in amounts:\n        S += _x\n    avg: uint256 = S / N_COINS\n    Sdiff: uint256 = 0\n    for _x in amounts:\n        if _x > avg:\n            Sdiff += _x - avg\n        else:\n            Sdiff += avg - _x\n    return fee * Sdiff / S + NOISE_FEE\n\n@external\n@view\ndef calc_token_fee(amounts: uint256[N_COINS], xp: uint256[N_COINS]) -> uint256:\n    return self._calc_token_fee(amounts, xp)\n\n@external\n@nonreentrant('lock')\ndef add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) -> (uint256):\n    assert msg.sender == self.amm, 'VAMM: OnlyAMM'\n    assert not self.is_killed  # dev: the pool is killed\n    assert msg.sender == self.amm\n\n    A_gamma: uint256[2] = self._A_gamma()\n\n    xp: uint256[N_COINS] = self.balances\n    amountsp: uint256[N_COINS] = empty(uint256[N_COINS])\n    xx: uint256[N_COINS] = empty(uint256[N_COINS])\n    d_token: uint256 = 0\n    d_token_fee: uint256 = 0\n    old_D: uint256 = 0\n    ix: uint256 = INF_COINS\n\n    if True:  # Scope to avoid having extra variables in memory later\n        xp_old: uint256[N_COINS] = xp\n\n        for i in range(N_COINS):\n            bal: uint256 = xp[i] + amounts[i]\n            xp[i] = bal\n            self.balances[i] = bal\n        xx = xp\n\n        price_scale: uint256 = self.price_scale * PRECISIONS[1]\n        xp = [xp[0] * PRECISIONS[0], xp[1] * price_scale / PRECISION]\n        xp_old = [xp_old[0] * PRECISIONS[0], xp_old[1] * price_scale / PRECISION]\n\n        for i in range(N_COINS):\n            if amounts[i] > 0:\n                # assert might be needed for some tokens - removed one to save bytespace\n                # ERC20(_coins[i]).transferFrom(msg.sender, self, amounts[i])\n                amountsp[i] = xp[i] - xp_old[i]\n                if ix == INF_COINS:\n                    ix = i\n                else:\n                    ix = INF_COINS-1\n        assert ix != INF_COINS  # dev: no coins to add\n\n        t: uint256 = self.future_A_gamma_time\n        if t > 0:\n            old_D = Math(self.math).newton_D(A_gamma[0], A_gamma[1], xp_old)\n            if block.timestamp >= t:\n                self.future_A_gamma_time = 1\n        else:\n            old_D = self.D\n\n    D: uint256 = Math(self.math).newton_D(A_gamma[0], A_gamma[1], xp)\n\n    token_supply: uint256 = self.totalSupply\n    if old_D > 0:\n        d_token = token_supply * D / old_D - token_supply\n    else:\n        d_token = self.get_xcp(D)  # making initial virtual price equal to 1\n    assert d_token > 0  # dev: nothing minted\n\n    if old_D > 0:\n        d_token_fee = self._calc_token_fee(amountsp, xp) * d_token / 10**10 + 1\n        d_token -= d_token_fee\n        token_supply += d_token\n        self.totalSupply = token_supply\n        # CurveToken(token).mint(msg.sender, d_token)\n\n        # Calculate price\n        # p_i * (dx_i - dtoken / token_supply * xx_i) = sum{k!=i}(p_k * (dtoken / token_supply * xx_k - dx_k))\n        # Simplified for 2 coins\n        p: uint256 = 0\n        if d_token > 10**5:\n            if amounts[0] == 0 or amounts[1] == 0:\n                S: uint256 = 0\n                precision: uint256 = 0\n                ix = 0\n                if amounts[0] == 0:\n                    S = xx[0] * PRECISIONS[0]\n                    precision = PRECISIONS[1]\n                    ix = 1\n                else:\n                    S = xx[1] * PRECISIONS[1]\n                    precision = PRECISIONS[0]\n                S = S * d_token / token_supply\n                p = S * PRECISION / (amounts[ix] * precision - d_token * xx[ix] * precision / token_supply)\n                if ix == 0:\n                    p = (10**18)**2 / p\n\n        self.tweak_price(A_gamma, xp, p, D)\n\n    else:\n        self.D = D\n        self.virtual_price = 10**18\n        self.xcp_profit = 10**18\n        self.totalSupply += d_token\n        # CurveToken(token).mint(msg.sender, d_token)\n\n    assert d_token >= min_mint_amount, \"Slippage\"\n\n    log AddLiquidity(msg.sender, amounts, d_token_fee, self.totalSupply)\n    return d_token\n\n@internal\n@pure\ndef _get_fee_adjusted_pnl(makerPosSize: int256, makerOpenNotional: int256) -> (int256, int256):\n    unrealizedPnl: int256 = 0\n    openNotional: int256 = makerOpenNotional\n\n    if makerOpenNotional < 0:\n        if makerPosSize > 0: # profit while removing liquidity\n            unrealizedPnl = -makerOpenNotional\n        elif makerPosSize < 0: # loss while removing liquidity\n            unrealizedPnl = makerOpenNotional\n        openNotional = 0\n    elif makerOpenNotional > 0 and makerPosSize == 0: # when all positions are balanced but profit due to fee accumulation\n        unrealizedPnl = makerOpenNotional\n        openNotional = 0\n    return unrealizedPnl, openNotional\n\n@internal\n@view\ndef _get_maker_position(amount: uint256, vUSD: uint256, vAsset: uint256, makerDToken: uint256) -> (int256, uint256, int256, uint256, uint256[N_COINS]):\n    if amount == 0:\n        return 0, 0, 0, self.D, self.balances\n\n    total_supply: uint256 = self.totalSupply\n    balances: uint256[N_COINS] = self.balances\n    D: uint256 = self.D\n\n    position: int256 = 0\n    openNotional: int256 = 0\n    feeAdjustedPnl: int256 = 0\n\n    # the following leads to makers taking a slightly bigger position, hence commented out from original code\n    # amount: uint256 = amount - 1  # Make rounding errors favoring other LPs a tiny bit\n    d_balances: uint256[N_COINS] = empty(uint256[N_COINS])\n    for x in range(N_COINS):\n        d_balances[x] = balances[x] * amount / total_supply\n        balances[x] -= d_balances[x]\n    D = D - D * amount / total_supply\n\n    position = convert(d_balances[N_COINS-1], int256)\n    _vUSD: int256 = convert(vUSD, int256)\n    if amount == makerDToken:\n        position -= convert(vAsset, int256)\n    else:\n        position -= convert(vAsset * amount / makerDToken, int256)\n        _vUSD = convert(vUSD * amount / makerDToken, int256)\n\n    if position > 0:\n        openNotional =  _vUSD - convert(d_balances[0], int256)\n    elif position <= 0: # =0 when no position open but positive openNotional due to fee accumulation\n        openNotional = convert(d_balances[0], int256) - _vUSD\n\n    feeAdjustedPnl, openNotional = self._get_fee_adjusted_pnl(position, openNotional)\n    return position, convert(openNotional, uint256), feeAdjustedPnl, D, balances\n\n@internal\n@pure\ndef _abs(x: int256) -> (int256):\n    if x >= 0:\n        return x\n    else:\n        return -x\n\n@internal\n@view\ndef _get_combined_open_notional(\n        takerPosSize: int256,\n        takerOpenNotional: uint256,\n        makerPosSize: int256,\n        makerOpenNotional: uint256\n    ) -> (uint256):\n    totalOpenNotional: uint256 = 0\n    if makerPosSize * takerPosSize >= 0: # increasingPosition\n        totalOpenNotional = takerOpenNotional + makerOpenNotional\n    else: # reducePosition or reversePosition\n        _openNotional: int256 = convert(takerOpenNotional, int256) - convert(makerOpenNotional, int256)\n        totalOpenNotional = convert(self._abs(_openNotional), uint256)\n    return totalOpenNotional\n\n@external\n@nonreentrant('lock')\ndef remove_liquidity(\n        amount: uint256,\n        min_amounts: uint256[N_COINS],\n        vUSD: uint256,\n        vAsset: uint256,\n        makerDToken: uint256,\n        takerPosSize: int256,\n        takerOpenNotional: uint256\n    ) -> (int256, uint256, int256, uint256[N_COINS]):\n    \"\"\"\n    This withdrawal method is very safe, does no complex math\n    \"\"\"\n    assert msg.sender == self.amm, 'VAMM: OnlyAMM'\n\n    makerPosSize: int256 = 0\n    makerOpenNotional: uint256 = 0\n    totalOpenNotional: uint256 = 0\n    feeAdjustedPnl: int256 = 0\n    D: uint256 = 0\n    balances: uint256[N_COINS] = empty(uint256[N_COINS])\n\n    makerPosSize, makerOpenNotional, feeAdjustedPnl, D, balances = self._get_maker_position(amount, vUSD, vAsset, makerDToken)\n    totalOpenNotional = self._get_combined_open_notional(takerPosSize, takerOpenNotional, makerPosSize, makerOpenNotional)\n\n    d_balances: uint256[N_COINS] = self.balances\n    for i in range(N_COINS):\n        d_balances[i] -= balances[i]\n        assert d_balances[i] >= min_amounts[i]\n\n    self.balances = balances\n    self.D = D\n    self.totalSupply -= amount\n\n    log RemoveLiquidity(msg.sender, d_balances, self.totalSupply)\n    return makerPosSize, totalOpenNotional, feeAdjustedPnl, d_balances\n\n@internal\n@view\ndef _get_taker_notional_and_pnl(position: int256, openNotional: uint256, balances: uint256[N_COINS], D: uint256) -> (uint256, int256):\n    notionalPosition: uint256 = 0\n    unrealizedPnl: int256 = 0\n    if D > 10**17 - 1:\n        if position > 0:\n            notionalPosition = Views(self.views).get_dy(1, 0, convert(position, uint256), balances, D)[0]\n            unrealizedPnl = convert(notionalPosition, int256) - convert(openNotional, int256)\n        elif position < 0:\n            _pos: uint256 = convert(-position, uint256)\n            if _pos > balances[N_COINS-1]: # vamm doesn't have enough to sell _pos quantity of base asset\n                # @atul to think more deeply about this\n                notionalPosition = 0\n            else:\n                notionalPosition = Views(self.views).get_dx(0, 1, _pos, balances, D)[0]\n                unrealizedPnl =  convert(openNotional, int256) - convert(notionalPosition, int256)\n    return notionalPosition, unrealizedPnl\n\n@external\n@view\ndef get_maker_position(amount: uint256, vUSD: uint256, vAsset: uint256, makerDToken: uint256) -> (int256, uint256, int256):\n    makerPosSize: int256 = 0\n    makerOpenNotional: uint256 = 0\n    notionalPosition: uint256 = 0\n    feeAdjustedPnl: int256 = 0\n    unrealizedPnl: int256 = 0\n    D: uint256 = 0\n    balances: uint256[N_COINS] = empty(uint256[N_COINS])\n\n    makerPosSize, makerOpenNotional, feeAdjustedPnl, D, balances = self._get_maker_position(amount, vUSD, vAsset, makerDToken)\n    # calculate pnl after removing maker liquidity\n    (notionalPosition, unrealizedPnl) = self._get_taker_notional_and_pnl(makerPosSize, makerOpenNotional, balances, D)\n    unrealizedPnl += feeAdjustedPnl\n\n    return makerPosSize, makerOpenNotional, unrealizedPnl\n\n@external\n@view\ndef get_notional(\n        makerDToken: uint256,\n        vUSD: uint256,\n        vAsset: uint256,\n        takerPosSize: int256,\n        takerOpenNotional: uint256\n    ) -> (uint256, int256, int256, uint256):\n    assert msg.sender == self.amm, 'VAMM: OnlyAMM'\n    makerPosSize: int256 = 0\n    makerOpenNotional: uint256 = 0\n    D: uint256 = 0\n    balances: uint256[N_COINS] = empty(uint256[N_COINS])\n    feeAdjustedPnl: int256 = 0\n\n    # rug the maker liquidity, if any\n    makerPosSize, makerOpenNotional, feeAdjustedPnl, D, balances = self._get_maker_position(makerDToken, vUSD, vAsset, makerDToken)\n\n    position: int256 = takerPosSize\n    openNotional: uint256 = takerOpenNotional\n    notionalPosition: uint256 = 0\n    unrealizedPnl: int256 = 0\n\n    (notionalPosition, unrealizedPnl) = self._get_taker_notional_and_pnl(takerPosSize, takerOpenNotional, balances, D)\n\n    if makerDToken > 0:\n        makerDebt: uint256 = 2 * vUSD\n        # notionalPos = Max(debt, maker impermanent notional pos [1]) + taker notional pos [2]\n        # [1] and [2] are being calculated after removing the maker liquidity, reflected via (D, balances) returned from _get_maker_position\n        notionalPosUpperBound: uint256 = notionalPosition + makerDebt\n\n        position += makerPosSize\n        openNotional = self._get_combined_open_notional(takerPosSize, takerOpenNotional, makerPosSize, makerOpenNotional)\n        (notionalPosition, unrealizedPnl) = self._get_taker_notional_and_pnl(position, openNotional, balances, D)\n\n        notionalPosition = max(notionalPosition, notionalPosUpperBound)\n        unrealizedPnl += feeAdjustedPnl\n    return notionalPosition, position, unrealizedPnl, openNotional\n\n@view\n@external\ndef calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256:\n    return Views(self.views).calc_token_amount(amounts, deposit)\n\n\n# # Admin parameters\n@external\ndef setAMM(_address: address):\n    assert msg.sender == self.owner, 'VAMM: OnlyOwner'\n    self.amm = _address\n\n\n# @external\n# def ramp_A_gamma(future_A: uint256, future_gamma: uint256, future_time: uint256):\n#     assert msg.sender == self.owner  # dev: only owner\n#     assert block.timestamp > self.initial_A_gamma_time + (MIN_RAMP_TIME-1)\n#     assert future_time > block.timestamp + (MIN_RAMP_TIME-1)  # dev: insufficient time\n\n#     A_gamma: uint256[2] = self._A_gamma()\n#     initial_A_gamma: uint256 = shift(A_gamma[0], 128)\n#     initial_A_gamma"
    }
  ]
}