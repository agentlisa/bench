{
  "Title": "Additional documentation should be added regarding the correct use of `pricingFunction` for v2 Pod listings",
  "Content": "When creating a v2 Pod listing, users are required to pass a [pricing function](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Listing.sol#L91) that will determine the price per Pod depending on the Plot index plus the starting position of Pods inside the Plot and the historical account of harvestable Pods. The difference between these two values yields the [`placeInLine`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Order.sol#L133) parameter of `Order::_fillPodOrderV2`, which is in units of Pods/Beans and thus has six decimals of precision.\n\n[`LibPolynomial::evaluatePolynomialPiecewise`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibPolynomial.sol#L85-L94) evaluates the price per Pod by considering that its parameter `x`, which corresponds to `placeInLine`, has no fixed-point decimals and then executes a third-degree polynomial function depending on the user-supplied `pricingFunction`.\n\nIf `x` is considered to have no decimals, then there arises a problem with $placeInLine^{n}$ if $n \\neq 1$ given that the number of decimals for each term would increase to $(n -1) \\times 6$. This error must, therefore, be handled by the `pricingFunction` bytes, which can be divided into five constituent parameters:\n* n (32 bytes): Corresponds to the number of pieces to consider. Each piece consists of a third-degree polynomial.\n* breakpoint (32n bytes): `x` values where evaluation changes from one piece to another. There is one breakpoint per piece.\n* significands (128n bytes): 4 per piece, ordered from most to least significant term.\n* exponents (128n bytes): 4 per piece, ordered from the most to least significant term.\n* signs (4n bytes): 4 per piece, indicating the term sign of each piece, ordered from the most to least significant term.\n\nTaking note of the example provided in the [comments of `LibPolynomial`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibPolynomial.sol#L21-L45), it can be observed that `x` was intended not to have any additional fixed-point decimals. However, this can be handled through `pricingFunction` with the consideration that the exponents should be defined as follows:\n1. The exponent corresponding to the cubic term should be 12 plus the significand decimals. Given that $x$ has 6 decimals, then $x^{3}$ will have 18 decimals. Division by $1 \\times 10^{12}$ is necessary to keep the value consistent with the target precision.\n2. The exponent corresponding second-degree term should be 6 plus the significand decimals. Given that $x$ has 6 decimals, then $x^{2}$ will have 12 decimals. Division by $1 \\times 10^{6}$ is necessary to keep the value consistent with the target precision.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/market/MarketplaceFacet/Listing.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n**/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./PodTransfer.sol\";\nimport \"contracts/libraries/Token/LibTransfer.sol\";\nimport \"contracts/libraries/LibPolynomial.sol\";\n\n/**\n * @author Beanjoyer, Malteasy\n * @title Pod Marketplace v2\n **/\n\ncontract Listing is PodTransfer {\n\n    using SafeMath for uint256;\n\n    struct PodListing {\n        address account;\n        uint256 index;\n        uint256 start;\n        uint256 amount;\n        uint24 pricePerPod;\n        uint256 maxHarvestableIndex;\n        uint256 minFillAmount;\n        LibTransfer.To mode;\n    }\n\n    event PodListingCreated(\n        address indexed account, \n        uint256 index, \n        uint256 start, \n        uint256 amount, \n        uint24 pricePerPod, \n        uint256 maxHarvestableIndex, \n        uint256 minFillAmount,\n        bytes pricingFunction,\n        LibTransfer.To mode,\n        LibPolynomial.PriceType pricingType\n    );\n\n    event PodListingFilled(\n        address indexed from,\n        address indexed to,\n        uint256 index,\n        uint256 start,\n        uint256 amount,\n        uint256 costInBeans\n    );\n\n    event PodListingCancelled(address indexed account, uint256 index);\n\n    /*\n     * Create\n     */\n\n    function _createPodListing(\n        uint256 index,\n        uint256 start,\n        uint256 amount,\n        uint24 pricePerPod,\n        uint256 maxHarvestableIndex,\n        uint256 minFillAmount,\n        LibTransfer.To mode\n    ) internal {\n        uint256 plotSize = s.a[msg.sender].field.plots[index];\n        \n        require(plotSize >= (start.add(amount)) && amount > 0, \"Marketplace: Invalid Plot/Amount.\");\n        require(pricePerPod > 0, \"Marketplace: Pod price must be greater than 0.\");\n        require(s.f.harvestable <= maxHarvestableIndex, \"Marketplace: Expired.\");\n        \n        if (s.podListings[index] != bytes32(0)) _cancelPodListing(msg.sender, index);\n\n        s.podListings[index] = hashListing(start, amount, pricePerPod, maxHarvestableIndex, minFillAmount, mode);\n\n        bytes memory f;\n        \n        emit PodListingCreated(msg.sender, index, start, amount, pricePerPod, maxHarvestableIndex, minFillAmount, f, mode, LibPolynomial.PriceType.Fixed);\n\n    }\n\n    function _createPodListingV2(\n        uint256 index,\n        uint256 start,\n        uint256 amount,\n        uint256 maxHarvestableIndex,\n        uint256 minFillAmount,\n        bytes calldata pricingFunction,\n        LibTransfer.To mode\n    ) internal {\n        uint256 plotSize = s.a[msg.sender].field.plots[index];\n\n        require(plotSize >= (start.add(amount)) && amount > 0, \"Marketplace: Invalid Plot/Amount.\");\n        require(s.f.harvestable <= maxHarvestableIndex, \"Marketplace: Expired.\");\n        \n        if (s.podListings[index] != bytes32(0)) _cancelPodListing(msg.sender, index);\n\n        s.podListings[index] = hashListingV2(\n            start, \n            amount, \n            0, \n            maxHarvestableIndex, \n            minFillAmount,\n            pricingFunction,\n            mode\n        );\n        \n        emit PodListingCreated(\n            msg.sender, \n            index, \n            start, \n            amount, \n            0, \n            maxHarvestableIndex, \n            minFillAmount,\n            pricingFunction,\n            mode,\n            LibPolynomial.PriceType.Dynamic\n        );\n    }\n\n    /*\n     * Fill\n     */\n\n    function _fillListing(PodListing calldata l, uint256 beanAmount) internal {\n        bytes32 lHash = hashListing(\n                l.start,\n                l.amount,\n                l.pricePerPod,\n                l.maxHarvestableIndex,\n                l.minFillAmount,\n                l.mode\n            );\n        \n        require(s.podListings[l.index] == lHash, \"Marketplace: Listing does not exist.\");\n        uint256 plotSize = s.a[l.account].field.plots[l.index];\n        require(plotSize >= (l.start.add(l.amount)) && l.amount > 0, \"Marketplace: Invalid Plot/Amount.\");\n        require(s.f.harvestable <= l.maxHarvestableIndex, \"Marketplace: Listing has expired.\");\n\n        uint256 amount = getAmountPodsFromFillListing(l.pricePerPod, l.amount, beanAmount);\n\n        __fillListing(msg.sender, l, amount, beanAmount);\n        _transferPlot(l.account, msg.sender, l.index, l.start, amount);\n\n    }\n\n    function _fillListingV2(\n        PodListing calldata l, \n        uint256 beanAmount,\n        bytes calldata pricingFunction\n    ) internal {\n        bytes32 lHash = hashListingV2(\n            l.start,\n            l.amount,\n            l.pricePerPod,\n            l.maxHarvestableIndex,\n            l.minFillAmount,\n            pricingFunction,\n            l.mode\n        );\n        \n        require(s.podListings[l.index] == lHash, \"Marketplace: Listing does not exist.\");\n\n        uint256 plotSize = s.a[l.account].field.plots[l.index];\n\n        require(plotSize >= (l.start.add(l.amount)) && l.amount > 0, \"Marketplace: Invalid Plot/Amount.\");\n        require(s.f.harvestable <= l.maxHarvestableIndex, \"Marketplace: Listing has expired.\");\n\n        uint256 amount = getAmountPodsFromFillListingV2(l.index.add(l.start).sub(s.f.harvestable), l.amount, beanAmount, pricingFunction);\n\n        __fillListingV2(msg.sender, l, pricingFunction, amount, beanAmount);\n        _transferPlot(l.account, msg.sender, l.index, l.start, amount);\n\n    }\n\n    function __fillListing(\n        address to,\n        PodListing calldata l,\n        uint256 amount,\n        uint256 beanAmount\n    ) private {\n        require(amount >= l.minFillAmount, \"Marketplace: Fill must be >= minimum amount.\");\n        require(l.amount >= amount, \"Marketplace: Not enough pods in Listing.\");\n\n        delete s.podListings[l.index];\n\n        if (l.amount > amount) {\n            s.podListings[l.index.add(amount).add(l.start)] = hashListing(\n                0,\n                l.amount.sub(amount),\n                l.pricePerPod,\n                l.maxHarvestableIndex,\n                l.minFillAmount,\n                l.mode\n            );\n        }\n\n        emit PodListingFilled(l.account, to, l.index, l.start, amount, beanAmount);\n    }\n\n    function __fillListingV2(\n        address to,\n        PodListing calldata l,\n        bytes calldata pricingFunction,\n        uint256 amount,\n        uint256 beanAmount\n    ) private {\n        require(amount >= l.minFillAmount, \"Marketplace: Fill must be >= minimum amount.\");\n        require(l.amount >= amount, \"Marketplace: Not enough pods in Listing.\");\n\n        delete s.podListings[l.index];\n\n        if (l.amount > amount) {\n            s.podListings[l.index.add(amount).add(l.start)] = hashListingV2(\n                0,\n                l.amount.sub(amount),\n                l.pricePerPod,\n                l.maxHarvestableIndex,\n                l.minFillAmount,\n                pricingFunction,\n                l.mode\n            );\n        }\n\n        emit PodListingFilled(l.account, to, l.index, l.start, amount, beanAmount);\n    }\n\n    /*\n     * Cancel\n     */\n\n    function _cancelPodListing(address account, uint256 index) internal {\n        require(\n            s.a[account].field.plots[index] > 0,\n            \"Marketplace: Listing not owned by sender.\"\n        );\n\n        delete s.podListings[index];\n\n        emit PodListingCancelled(account, index);\n    }\n\n    /*\n     * Helpers\n     */\n\n    function getAmountPodsFromFillListing(uint24 pricePerPod, uint256 podListingAmount, uint256 fillBeanAmount) internal pure returns (uint256 amount) {\n        amount = (fillBeanAmount * 1000000) / pricePerPod;\n        \n        uint256 remainingAmount = podListingAmount.sub(amount, \"Marketplace: Not enough pods in Listing.\");\n        if(remainingAmount <= (1000000 / pricePerPod)) amount = podListingAmount;\n    }\n\n    function getAmountPodsFromFillListingV2(\n        uint256 placeInLine, \n        uint256 podListingAmount,\n        uint256 fillBeanAmount,\n        bytes calldata pricingFunction\n    ) public pure returns (uint256 amount) {\n        uint256 pricePerPod = LibPolynomial.evaluatePolynomialPiecewise(pricingFunction, placeInLine);\n        amount = (fillBeanAmount.mul(1000000)) / pricePerPod;\n        \n        uint256 remainingAmount = podListingAmount.sub(amount, \"Marketplace: Not enough pods in Listing.\");\n        if(remainingAmount <= (1000000 / pricePerPod)) amount = podListingAmount;\n    }\n\n    function hashListing(\n        uint256 start, \n        uint256 amount, \n        uint24 pricePerPod, \n        uint256 maxHarvestableIndex, \n        uint256 minFillAmount,\n        LibTransfer.To mode\n    ) internal pure returns (bytes32 lHash) {\n        if(minFillAmount > 0) lHash = keccak256(abi.encodePacked(start, amount, pricePerPod, maxHarvestableIndex,  minFillAmount, mode == LibTransfer.To.EXTERNAL));\n        else lHash = keccak256(abi.encodePacked(start, amount, pricePerPod, maxHarvestableIndex,  mode == LibTransfer.To.EXTERNAL));\n    }\n\n    function hashListingV2(\n        uint256 start, \n        uint256 amount, \n        uint24 pricePerPod, \n        uint256 maxHarvestableIndex, \n        uint256 minFillAmount,\n        bytes calldata pricingFunction,\n        LibTransfer.To mode\n    ) internal pure returns (bytes32 lHash) {\n        require(pricingFunction.length == LibPolynomial.getNumPieces(pricingFunction).mul(168).add(32), \"Marketplace: Invalid pricing function.\");\n        lHash = keccak256(abi.encodePacked(start, amount, pricePerPod, maxHarvestableIndex, minFillAmount, mode == LibTransfer.To.EXTERNAL, pricingFunction));\n    }\n\n}"
    },
    {
      "filename": "protocol/contracts/libraries/LibPolynomial.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\n \nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./LibBytes.sol\";\n \n/* \n* @author: Malteasy\n* @title: LibPolynomial\n*/\n\nlibrary LibPolynomial { \n\n    using SafeMath for uint256;\n\n    using LibBytes for bytes;\n\n    /**\n    The polynomial's constant terms are split into: 1) constant * 10^exponent , 2) the exponent the constant is raised to in base 10 and, 3) the sign of the coefficients.\n    Example conversion to Piecewise: \n\n        Range(0, 1) -> Polynomial(0.25*x^3 + 25*x^2 + x + 1)\n        Range(1, 2) -> Polynomial(0.0125*x^3 + 50*x^2 + x - 2)\n        Range(2, Infinity) -> Polynomial(-1)\n        \n    Resulting Piecewise:\n\n        breakpoints: [0, 1, 2]\n        significands: [1, 1, 25, 25, 2, 1, 50, 125, 1, 0, 0, 0]\n        (expanded) coefficient exponents: [0, 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0]\n        (expanded) signs: [true, true, true, true, false, true, true, true, false, false, false, false]\n\n    The resulting piecewise is then encoded into a single bytes array by concatenating as follows, where n is the number of polynomial pieces: \n        [\n            n, (32 bytes)\n            breakpoints, (32n bytes)\n            significands, (128n bytes)\n            exponents, (4n bytes)\n            signs, (4n bytes)\n        ]\n        \n    */\n\n    enum PriceType {\n        Fixed,\n        Dynamic\n    }\n\n    uint256 constant MAX_DEGREE = 3;\n\n    /**\n    * @notice Computes a cubic polynomial.\n    * @dev Polynomial is of the form a(x-k)^3 + b(x-k)^2 + c(x-k) + d where k is the start of the piecewise interval\n    * @param f The encoded piecewise polynomial\n    * @param pieceIndex Which piece of the polynomial to evaluate\n    * @param numPieces The number of pieces in the polynomial\n    * @param x The value to be evaluated at.\n    */\n    function evaluatePolynomial(\n        bytes calldata f,\n        uint256 pieceIndex,\n        uint256 numPieces,\n        uint256 x\n    ) internal pure returns (uint256) {\n        uint256 positiveSum;\n        uint256 negativeSum;\n\n        uint256[4] memory significands = getSignificands(f, pieceIndex, numPieces);\n        uint8[4] memory exponents = getExponents(f, pieceIndex, numPieces);\n        bool[4] memory signs = getSigns(f, pieceIndex, numPieces);\n        \n        for(uint256 degree; degree <= MAX_DEGREE; ++degree) {\n            if(signs[degree]) {\n                positiveSum = positiveSum.add(pow(x, degree).mul(significands[degree]).div(pow(10, exponents[degree])));\n            } else {\n                negativeSum = negativeSum.add(pow(x, degree).mul(significands[degree]).div(pow(10, exponents[degree])));\n            }\n        }\n        return positiveSum.sub(negativeSum);\n    }\n\n    function evaluatePolynomialPiecewise(\n        bytes calldata f,\n        uint256 x\n    ) internal pure returns (uint256 y) {\n        uint256 numPieces = getNumPieces(f);\n        uint256 pieceIndex = findPiecewiseIndex(f, x, numPieces);\n        y = evaluatePolynomial(f, pieceIndex, numPieces,\n            x.sub(getPiecewiseBreakpoint(f, pieceIndex), \"Evaluation must be within piecewise bounds\")\n        );\n    }\n\n    /**\n    * @notice Computes the integral of a cubic polynomial \n    * @dev Polynomial is of the form a(x-k)^3 + b(x-k)^2 + c(x-k) + d where k is the start of the piecewise interval\n    * @param f The encoded piecewise polynomial\n    * @param pieceIndex Which piece of the polynomial to evaluate\n    * @param numPieces The number of pieces in the polynomial\n    * @param start The lower bound of the integration. (can overflow past 10e13)\n    * @param end The upper bound of the integration. (can overflow past 10e13)\n    */\n    function evaluatePolynomialIntegration(\n        bytes calldata f,\n        uint256 pieceIndex,\n        uint256 numPieces,\n        uint256 start, //start of breakpoint is assumed to be subtracted\n        uint256 end //start of breakpoint is assumed to be subtracted\n    ) internal pure returns (uint256) {\n        uint256 positiveSum;\n        uint256 negativeSum;\n\n        uint256[4] memory significands = getSignificands(f, pieceIndex, numPieces);\n        uint8[4] memory exponents = getExponents(f, pieceIndex, numPieces);\n        bool[4] memory signs = getSigns(f, pieceIndex, numPieces);\n        \n        for(uint256 degree; degree <= MAX_DEGREE; ++degree) {\n\n            if(signs[degree]) {\n                //uint256 max value is 1e77 and this has been tested to work to not overflow for values less than 1e14. \n                //Note: susceptible to overflows past 1e14\n                positiveSum = positiveSum.add(pow(end, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n\n                positiveSum = positiveSum.sub(pow(start, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n            } else {\n                negativeSum = negativeSum.add(pow(end, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n\n                negativeSum = negativeSum.sub(pow(start, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n            }\n        }\n\n        return positiveSum.sub(negativeSum);\n    }\n\n    function evaluatePolynomialIntegrationPiecewise(\n        bytes calldata f,\n        uint256 start, \n        uint256 end\n    ) internal pure returns (uint256 integral) {\n        uint256 numPieces = getNumPieces(f);\n        uint256 currentPieceIndex = findPiecewiseIndex(f, start, numPieces);\n        uint256 currentPieceStart = getPiecewiseBreakpoint(f, currentPieceIndex);\n        uint256 nextPieceStart = getPiecewiseBreakpoint(f, currentPieceIndex + 1);\n        bool integrateToEnd;\n\n        while (!integrateToEnd) {\n            if(end > nextPieceStart) {\n                integrateToEnd = false;\n            } else {\n                integrateToEnd = true;\n            }\n\n            uint256 startIntegration = start.sub(currentPieceStart, \"Evaluation must be within piecewise bounds.\");\n            uint256 endIntegration = integrateToEnd ? end.sub(currentPieceStart) : nextPieceStart.sub(currentPieceStart);\n\n            integral = integral.add(evaluatePolynomialIntegration(f, currentPieceIndex, numPieces, \n                startIntegration, \n                endIntegration\n            ));\n\n            if(!integrateToEnd) {\n                start = nextPieceStart;\n                if(currentPieceIndex == (numPieces - 1)) {\n                    //reached end of piecewise\n                    integrateToEnd = true;\n                } else {\n                    //continue to next piece\n                    currentPieceIndex++;\n                    currentPieceStart = getPiecewiseBreakpoint(f, currentPieceIndex);\n                    if(currentPieceIndex != (numPieces - 1)) nextPieceStart = getPiecewiseBreakpoint(f, currentPieceIndex + 1);\n                }\n            }\n\n        }\n    }\n    \n    /**\n    * @notice Searches for index of interval containing x\n    * @dev [inclusiveStart, exclusiveEnd)\n    * @param value The value to search for.\n    * @param high The highest index of the array to search. Could be retrieved from getNumPieces(arr) - 1.\n    */\n    function findPiecewiseIndex(bytes calldata f, uint256 value, uint256 high) internal pure returns (uint256) {\n        uint256 breakpointAtIndex = getPiecewiseBreakpoint(f, 0);\n        if(value < breakpointAtIndex) return 0;\n        \n        uint256 low = 0;\n        \n        while(low < high) {\n            if(breakpointAtIndex == value) return low;\n            else if(breakpointAtIndex > value) return low - 1;\n            else low++;\n            breakpointAtIndex = getPiecewiseBreakpoint(f, low);\n        }\n\n        return low - 1;\n    }\n\n    /**\n      Function calldata parsing.\n    */\n\n    /**\n    * @notice Retrieves the length of pieces in a piecewise polynomial. \n    * @dev Stored as the first 32 bytes of the piecewise function data.\n    * @param f The function data of the piecewise polynomial.\n    */\n    function getNumPieces(bytes calldata f) internal pure returns (uint256) {\n        return f.sliceToMemory(0, 32).toUint256(0);\n    }\n\n    /**\n    * @notice Retrieves the breakpoint at the specified piecewise index.\n    * @dev Stored in function data after the first 32 bytes. Occupies 32n bytes, where n is the number of polynomial pieces.\n    * @param f The function data of the piecewise polynomial.\n    */\n    function getPiecewiseBreakpoint(bytes calldata f, uint256 pieceIndex) internal pure returns (uint256) {\n        return f.sliceToMemory((pieceIndex.mul(32)).add(32), 32).toUint256(0);\n    }\n\n    /**\n    * @notice Retrieves the coefficient significands of a cubic polynomial at specified piecewise index. (significands / 10^exponent = coefficientValue)\n    * @dev Stored in function data after the first 32 + 32n bytes. Occupies 128n bytes, where n is the number of polynomial pieces.\n    * @param f The function data of the piecewise polynomial.\n    * @param pieceIndex The index of the piecewise polynomial to get signs for.\n    * @param numPieces The number of pieces in the piecewise polynomial.\n    */\n    function getSignificands(bytes calldata f, uint256 pieceIndex, uint256 numPieces) internal pure returns (uint256[4] memory significands) {\n        bytes memory significandSlice = f.sliceToMemory((pieceIndex.mul(128)).add(numPieces.mul(32)).add(32), 128);\n        significands[0] = significandSlice.toUint256(0);\n        significands[1] = significandSlice.toUint256(32);\n        significands[2] = significandSlice.toUint256(64);\n        significands[3] = significandSlice.toUint256(96);\n    }\n\n    /**\n    * @notice Retrieves the exponents for the coefficients of a cubic polynomial at specified piecewise index. (significand / 10^exponent = coefficientValue)\n    * @dev Stored in function data after the first 32 + 32n + 128n bytes. Occupies 4n bytes, where n is the number of polynomial pieces.\n    * @param f The function data of the piecewise polynomial.\n    * @param pieceIndex The index of the piecewise polynomial to get signs for.\n    * @param numPieces The number of pieces in the piecewise polynomial.\n    */\n    function getExponents(bytes calldata f, uint256 pieceIndex, uint256 numPieces) internal pure returns(uint8[4] memory exponents) {\n        bytes memory exponentSlice = f.sliceToMemory((pieceIndex.mul(4)).add(numPieces.mul(160)).add(32), 4);\n        exponents[0] = exponentSlice.toUint8(0);\n        exponents[1] = exponentSlice.toUint8(1);\n        exponents[2] = exponentSlice.toUint8(2);\n        exponents[3] = exponentSlice.toUint8(3);\n    }\n\n    /**\n    * @notice Retrieves the signs (bool values) for the coefficients of a cubic polynomial at specified piecewise index.\n    * @dev Stored in function data after the first 32 + 32n + 128n + 4n bytes. Occupies 4n bytes, where n is the number of polynomial pieces.\n    * @param f The function data of the piecewise polynomial.\n    * @param pieceIndex The index of the piecewise polynomial to get signs for.\n    * @param numPieces The number of pieces in the piecewise polynomial.\n    */\n    function getSigns(bytes calldata f, uint256 pieceIndex, uint256 numPieces) internal pure returns(bool[4] memory signs) {\n        bytes memory signSlice = f.sliceToMemory((pieceIndex.mul(4)).add(numPieces.mul(164)).add(32), 4);\n        signs[0] = signSlice.toUint8(0) == 1;\n        signs[1] = signSlice.toUint8(1) == 1;\n        signs[2] = signSlice.toUint8(2) == 1; \n        signs[3] = signSlice.toUint8(3) == 1;\n    }\n\n    /**\n    * @notice A safe way to take the power of a number.\n    */\n    function pow(uint256 base, uint256 exponent) internal pure returns (uint256) {\n        if(exponent == 0) \n            return 1;\n            \n        else if(exponent == 1) \n            return base; \n\n        else if(base == 0 && exponent != 0) \n            return 0;\n\n        else {\n            uint256 z = base;\n            for(uint256 i = 1; i < exponent; ++i) \n                z = z.mul(base);\n            return z;\n        }\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/LibPolynomial.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\n \nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./LibBytes.sol\";\n \n/* \n* @author: Malteasy\n* @title: LibPolynomial\n*/\n\nlibrary LibPolynomial { \n\n    using SafeMath for uint256;\n\n    using LibBytes for bytes;\n\n    /**\n    The polynomial's constant terms are split into: 1) constant * 10^exponent , 2) the exponent the constant is raised to in base 10 and, 3) the sign of the coefficients.\n    Example conversion to Piecewise: \n\n        Range(0, 1) -> Polynomial(0.25*x^3 + 25*x^2 + x + 1)\n        Range(1, 2) -> Polynomial(0.0125*x^3 + 50*x^2 + x - 2)\n        Range(2, Infinity) -> Polynomial(-1)\n        \n    Resulting Piecewise:\n\n        breakpoints: [0, 1, 2]\n        significands: [1, 1, 25, 25, 2, 1, 50, 125, 1, 0, 0, 0]\n        (expanded) coefficient exponents: [0, 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0]\n        (expanded) signs: [true, true, true, true, false, true, true, true, false, false, false, false]\n\n    The resulting piecewise is then encoded into a single bytes array by concatenating as follows, where n is the number of polynomial pieces: \n        [\n            n, (32 bytes)\n            breakpoints, (32n bytes)\n            significands, (128n bytes)\n            exponents, (4n bytes)\n            signs, (4n bytes)\n        ]\n        \n    */\n\n    enum PriceType {\n        Fixed,\n        Dynamic\n    }\n\n    uint256 constant MAX_DEGREE = 3;\n\n    /**\n    * @notice Computes a cubic polynomial.\n    * @dev Polynomial is of the form a(x-k)^3 + b(x-k)^2 + c(x-k) + d where k is the start of the piecewise interval\n    * @param f The encoded piecewise polynomial\n    * @param pieceIndex Which piece of the polynomial to evaluate\n    * @param numPieces The number of pieces in the polynomial\n    * @param x The value to be evaluated at.\n    */\n    function evaluatePolynomial(\n        bytes calldata f,\n        uint256 pieceIndex,\n        uint256 numPieces,\n        uint256 x\n    ) internal pure returns (uint256) {\n        uint256 positiveSum;\n        uint256 negativeSum;\n\n        uint256[4] memory significands = getSignificands(f, pieceIndex, numPieces);\n        uint8[4] memory exponents = getExponents(f, pieceIndex, numPieces);\n        bool[4] memory signs = getSigns(f, pieceIndex, numPieces);\n        \n        for(uint256 degree; degree <= MAX_DEGREE; ++degree) {\n            if(signs[degree]) {\n                positiveSum = positiveSum.add(pow(x, degree).mul(significands[degree]).div(pow(10, exponents[degree])));\n            } else {\n                negativeSum = negativeSum.add(pow(x, degree).mul(significands[degree]).div(pow(10, exponents[degree])));\n            }\n        }\n        return positiveSum.sub(negativeSum);\n    }\n\n    function evaluatePolynomialPiecewise(\n        bytes calldata f,\n        uint256 x\n    ) internal pure returns (uint256 y) {\n        uint256 numPieces = getNumPieces(f);\n        uint256 pieceIndex = findPiecewiseIndex(f, x, numPieces);\n        y = evaluatePolynomial(f, pieceIndex, numPieces,\n            x.sub(getPiecewiseBreakpoint(f, pieceIndex), \"Evaluation must be within piecewise bounds\")\n        );\n    }\n\n    /**\n    * @notice Computes the integral of a cubic polynomial \n    * @dev Polynomial is of the form a(x-k)^3 + b(x-k)^2 + c(x-k) + d where k is the start of the piecewise interval\n    * @param f The encoded piecewise polynomial\n    * @param pieceIndex Which piece of the polynomial to evaluate\n    * @param numPieces The number of pieces in the polynomial\n    * @param start The lower bound of the integration. (can overflow past 10e13)\n    * @param end The upper bound of the integration. (can overflow past 10e13)\n    */\n    function evaluatePolynomialIntegration(\n        bytes calldata f,\n        uint256 pieceIndex,\n        uint256 numPieces,\n        uint256 start, //start of breakpoint is assumed to be subtracted\n        uint256 end //start of breakpoint is assumed to be subtracted\n    ) internal pure returns (uint256) {\n        uint256 positiveSum;\n        uint256 negativeSum;\n\n        uint256[4] memory significands = getSignificands(f, pieceIndex, numPieces);\n        uint8[4] memory exponents = getExponents(f, pieceIndex, numPieces);\n        bool[4] memory signs = getSigns(f, pieceIndex, numPieces);\n        \n        for(uint256 degree; degree <= MAX_DEGREE; ++degree) {\n\n            if(signs[degree]) {\n                //uint256 max value is 1e77 and this has been tested to work to not overflow for values less than 1e14. \n                //Note: susceptible to overflows past 1e14\n                positiveSum = positiveSum.add(pow(end, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n\n                positiveSum = positiveSum.sub(pow(start, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n            } else {\n                negativeSum = negativeSum.add(pow(end, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n\n                negativeSum = negativeSum.sub(pow(start, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n            }\n        }\n\n        return positiveSum.sub(negativeSum);\n    }\n\n    function evaluatePolynomialIntegrationPiecewise(\n        bytes calldata f,\n        uint256 start, \n        uint256 end\n    ) internal pure returns (uint256 integral) {\n        uint256 numPieces = getNumPieces(f);\n        uint256 currentPieceIndex = findPiecewiseIndex(f, start, numPieces);\n        uint256 currentPieceStart = getPiecewiseBreakpoint(f, currentPieceIndex);\n        uint256 nextPieceStart = getPiecewiseBreakpoint(f, currentPieceIndex + 1);\n        bool integrateToEnd;\n\n        while (!integrateToEnd) {\n            if(end > nextPieceStart) {\n                integrateToEnd = false;\n            } else {\n                integrateToEnd = true;\n            }\n\n            uint256 startIntegration = start.sub(currentPieceStart, \"Evaluation must be within piecewise bounds.\");\n            uint256 endIntegration = integrateToEnd ? end.sub(currentPieceStart) : nextPieceStart.sub(currentPieceStart);\n\n            integral = integral.add(evaluatePolynomialIntegration(f, currentPieceIndex, numPieces, \n                startIntegration, \n                endIntegration\n            ));\n\n            if(!integrateToEnd) {\n                start = nextPieceStart;\n                if(currentPieceIndex == (numPieces - 1)) {\n                    //reached end of piecewise\n                    integrateToEnd = true;\n                } else {\n                    //continue to next piece\n                    currentPieceIndex++;\n                    currentPieceStart = getPiecewiseBreakpoint(f, currentPieceIndex);\n                    if(currentPieceIndex != (numPieces - 1)) nextPieceStart = getPiecewiseBreakpoint(f, currentPieceIndex + 1);\n                }\n            }\n\n        }\n    }\n    \n    /**\n    * @notice Searches for index of interval containing x\n    * @dev [inclusiveStart, exclusiveEnd)\n    * @param value The value to search for.\n    * @param high The highest index of the array to search. Could be retrieved from getNumPieces(arr) - 1.\n    */\n    function findPiecewiseIndex(bytes calldata f, uint256 value, uint256 high) internal pure returns (uint256) {\n        uint256 breakpointAtIndex = getPiecewiseBreakpoint(f, 0);\n        if(value < breakpointAtIndex) return 0;\n        \n        uint256 low = 0;\n        \n        while(low < high) {\n            if(breakpointAtIndex == value) return low;\n            else if(breakpointAtIndex > value) return low - 1;\n            else low++;\n            breakpointAtIndex = getPiecewiseBreakpoint(f, low);\n        }\n\n        return low - 1;\n    }\n\n    /**\n      Function calldata parsing.\n    */\n\n    /**\n    * @notice Retrieves the length of pieces in a piecewise polynomial. \n    * @dev Stored as the first 32 bytes of the piecewise function data.\n    * @param f The function data of the piecewise polynomial.\n    */\n    function getNumPieces(bytes calldata f) internal pure returns (uint256) {\n        return f.sliceToMemory(0, 32).toUint256(0);\n    }\n\n    /**\n    * @notice Retrieves the breakpoint at the specified piecewise index.\n    * @dev Stored in function data after the first 32 bytes. Occupies 32n bytes, where n is the number of polynomial pieces.\n    * @param f The function data of the piecewise polynomial.\n    */\n    function getPiecewiseBreakpoint(bytes calldata f, uint256 pieceIndex) internal pure returns (uint256) {\n        return f.sliceToMemory((pieceIndex.mul(32)).add(32), 32).toUint256(0);\n    }\n\n    /**\n    * @notice Retrieves the coefficient significands of a cubic polynomial at specified piecewise index. (significands / 10^exponent = coefficientValue)\n    * @dev Stored in function data after the first 32 + 32n bytes. Occupies 128n bytes, where n is the number of polynomial pieces.\n    * @param f The function data of the piecewise polynomial.\n    * @param pieceIndex The index of the piecewise polynomial to get signs for.\n    * @param numPieces The number of pieces in the piecewise polynomial.\n    */\n    function getSignificands(bytes calldata f, uint256 pieceIndex, uint256 numPieces) internal pure returns (uint256[4] memory significands) {\n        bytes memory significandSlice = f.sliceToMemory((pieceIndex.mul(128)).add(numPieces.mul(32)).add(32), 128);\n        significands[0] = significandSlice.toUint256(0);\n        significands[1] = significandSlice.toUint256(32);\n        significands[2] = significandSlice.toUint256(64);\n        significands[3] = significandSlice.toUint256(96);\n    }\n\n    /**\n    * @notice Retrieves the exponents for the coefficients of a cubic polynomial at specified piecewise index. (significand / 10^exponent = coefficientValue)\n    * @dev Stored in function data after the first 32 + 32n + 128n bytes. Occupies 4n bytes, where n is the number of polynomial pieces.\n    * @param f The function data of the piecewise polynomial.\n    * @param pieceIndex The index of the piecewise polynomial to get signs for.\n    * @param numPieces The number of pieces in the piecewise polynomial.\n    */\n    function getExponents(bytes calldata f, uint256 pieceIndex, uint256 numPieces) internal pure returns(uint8[4] memory exponents) {\n        bytes memory exponentSlice = f.sliceToMemory((pieceIndex.mul(4)).add(numPieces.mul(160)).add(32), 4);\n        exponents[0] = exponentSlice.toUint8(0);\n        exponents[1] = exponentSlice.toUint8(1);\n        exponents[2] = exponentSlice.toUint8(2);\n        exponents[3] = exponentSlice.toUint8(3);\n    }\n\n    /**\n    * @notice Retrieves the signs (bool values) for the coefficients of a cubic polynomial at specified piecewise index.\n    * @dev Stored in function data after the first 32 + 32n + 128n + 4n bytes. Occupies 4n bytes, where n is the number of polynomial pieces.\n    * @param f The function data of the piecewise polynomial.\n    * @param pieceIndex The index of the piecewise polynomial to get signs fo"
    }
  ]
}