{
  "Title": "[H-05] Making `_totalSupply` and `_totalShares` imbalance significantly by providing fake income leads to stealing fund",
  "Content": "\nIf the project has just started, a malicious user can make the `_totalSupply` and `_totalShares` imbalance significantly by providing fake income. By doing so, later, when innocent users deposit and mint, the malicious user can steal protocol's stETH without burning any shares. Moreover, the protocol's income can be stolen as well.\n\n### Proof of Concept\n\nSuppose nothing is deposited in the protocol (it is day 0).\n\nBob (a malicious user) deposits `$`1000 worth of ether (equal to 1 ETH, assuming ETH price is `$`1000) to mint `200e18 + 1` eUSD. The state will be:\n*   `shares[Bob] = 200e18 + 1`\n*   `_totalShares = 200e18 + 1`\n*   `_totalSupply = 200e18 + 1`\n*   `borrowed[Bob] = 200e18 + 1`\n*   `poolTotalEUSDCirculation = 200e18 + 1`\n*   `depositAsset[Bob] = 1e18`\n*   `totalDepositedAsset = 1e18`\n*   `stETH.balanceOf(protocol) = 1e18`\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L37>\n\nThen, Bob transfers directly `0.2stETH` (worth `$`200) to the protocol. By doing so, Bob is providing a fake excess income in the protocol. So, the state will be:\n*   `shares[Bob] = 200e18 + 1`\n*   `_totalShares = 200e18 + 1`\n*   `_totalSupply = 200e18 + 1`\n*   `borrowed[Bob] = 200e18 + 1`\n*   `poolTotalEUSDCirculation = 200e18 + 1`\n*   `depositAsset[Bob] = 1e18`\n*   `totalDepositedAsset = 1e18`\n*   `stETH.balanceOf(protocol) = 1e18 + 2e17`\n\nThen, Bob calls `excessIncomeDistribution` to buy this excess income. As you see in line 63, the `excessIncome` is equal to the difference of `stETH.balanceOf(protocol)` and `totalDepositedAsset`. So, the `excessAmount = 2e17`.\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L63>\n\nThen, in line 66, this amount `2e17` is converted to eUSD amount based on the price of stETH. Since, we assumed  ETH is `$`1000, we have:\n\n    uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000 = 2e17 * 1000e18 / 1e18 = 200e18\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L66C9-L66C112>\n\nSince the protocol has just started, there is no `feeStored`, so the income is equal to zero. \n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L68>\n\nIn line 75, we have:\n\n    uint256 sharesAmount = _EUSDAmount.mul(_totalShares).div(totalMintedEUSD) = 200e18 * (200e18 + 1) / (200e18 + 1) = 200e18\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L75C13-L75C35>\n\nIn line 81, this amount of `sharesAmount` will be burned from Bob, and then in line 93, `2e17` stETH will be transferred to Bob. So, the state will be:\n\n*   `shares[Bob] = 200e18 + 1 - 200e18 = 1`\n*   `_totalShares = 200e18 + 1 - 200e18 = 1`\n*   `_totalSupply = 200e18 + 1`\n*   `borrowed[Bob] = 200e18 + 1`\n*   `poolTotalEUSDCirculation = 200e18 + 1`\n*   `depositAsset[Bob] = 1e18`\n*   `totalDepositedAsset = 1e18`\n*   `stETH.balanceOf(protocol) = 1e18 + 2e17 - 2e17 = 1e18`\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L81>\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L93>\n\n**Please note** that currently we have `_totalSupply = 200e18 + 1` and `_totalShares = 1`.\n\nSuppose, Alice (an innocent user) deposits 10ETH, and mints 4000e18 eUSD. So, the amount of shares minted to Alice will be:\n\n    sharesAmount = _EUSDAmount.mul(_totalShares).div(totalMintedEUSD) = 4000e18 * 1 / (200e18 + 1) = 19\n\nSo, the state will be:\n*   `shares[Bob] = 1`\n*   `_totalShares = 1 + 19 = 20`\n*   `_totalSupply = 200e18 + 1 + 4000e18 = 4200e18 + 1`\n*   `borrowed[Bob] = 200e18 + 1`\n*   `poolTotalEUSDCirculation = 200e18 + 1 + 4000e18 = 4200e18 + 1`\n*   `depositAsset[Bob] = 1e18`\n*   `totalDepositedAsset = 1e18 + 10e18 = 11e18`\n*   `stETH.balanceOf(protocol) = 1e18 + 10e18 = 11e18`\n*   `shares[Alice] = 19`\n*   `borrowed[Alice] = 4000e18`\n*   `depositAsset[Alice] = 10e18`\n\nNow, different issues can happen leading to loss/steal of funds:\n<details>\n\n* **First Scenario:** If Alice is a provider, Bob can redeem eUSD multiple of times to receive stETH without burning any share by calling `rigidRedemption`. To be more accurate, Bob should call this function with `eusdAmount` as parameter equal to `_totalSupply / _totalShares`. For example:\n\n    *   First call: `rigidRedemption (Alice, 210e18)`, so we will have:\n        *   `shares[Bob] = 1`\n        *   `_totalShares  = 20`\n        *   `_totalSupply = 4200e18 + 1 - 210e18 = 3990e18 + 1`\n        *   `borrowed[Bob] = 200e18 + 1`\n        *   `poolTotalEUSDCirculation = 4200e18 + 1 - 210e18 = 3990e18 + 1`\n        *   `depositAsset[Bob] = 1e18`\n        *   `totalDepositedAsset = 11e18 - 21e16`\n        *   `stETH.balanceOf(protocol) = 11e18 - 21e16`\n        *   `shares[Alice] = 19`\n        *   `borrowed[Alice] = 4000e18 - 210e18 = 3790e18`\n        *   `depositAsset[Alice] = 10e18 - 21e16`<br>\n        Please note that no shares are burned from Bob, because `getSharesByMintedEUSD` returns zero as `210e18 * 20 / (4200e18 + 1) = 0`. It means, Bob receives 0.21 stETH by burning no shares.\n\n    *   Second call: `rigidRedemption (Alice, 199e18)`, so we will have:\n        *   `shares[Bob] = 1`\n        *   `_totalShares  = 20`\n        *   `_totalSupply = 3990e18 + 1 - 199e18 = 3791e18 + 1`\n        *   `borrowed[Bob] = 200e18 + 1`\n        *   `poolTotalEUSDCirculation = 3990e18 + 1 - 199e18 = 3791e18 + 1`\n        *   `depositAsset[Bob] = 1e18`\n        *   `totalDepositedAsset = 11e18 - 210e15 - 199e15 = 11e18 - 409e15`\n        *   `stETH.balanceOf(protocol) = 11e18 - 210e15 - 199e15 = 11e18 - 409e15`\n        *   `shares[Alice] = 19`\n        *   `borrowed[Alice] = 3790e18 - 199e18 = 3591e18`\n        *   `depositAsset[Alice] = 10e18 - 210e15 - 199e15 = 10e18 - 409e15`<br>\n        Please note that no shares are burned from Bob, because `getSharesByMintedEUSD` returns zero as `199e18 * 20 / (3990e18 + 1) = 0`. It means, Bob receives 0.199 stETH by burning no shares.\n\n    *   Third call: `rigidRedemption (Alice, 189e18)`, so we will have:\n        *   `shares[Bob] = 1`\n        *   `_totalShares  = 20`\n        *   `_totalSupply = 3791e18 + 1 - 189e18 = 3602e18 + 1`\n        *   `borrowed[Bob] = 200e18 + 1`\n        *   `poolTotalEUSDCirculation = 3791e18 + 1 - 189e18 = 3602e18 + 1`\n        *   `depositAsset[Bob] = 1e18`\n        *   `totalDepositedAsset = 11e18 - 409e15 - 189e15 = 11e18 - 598e15`\n        *   `stETH.balanceOf(protocol) = 11e18 - 409e15 - 189e15 = 11e18 - 598e15`\n        *   `shares[Alice] = 19`\n        *   `borrowed[Alice] = 3591e18 - 189e18 = 3402e18`\n        *   `depositAsset[Alice] = 10e18 - 409e15 - 189e15 = 10e18 - 598e15`<br>\n        Please note that no shares are burned from Bob, because `getSharesByMintedEUSD` returns zero as `189e18 * 20 / (3791e18 + 1) = 0`. It means, Bob receives 0.189 stETH by burning no shares.<br>\n\n  So far, by just calling the function `rigidRedemption` three times, Bob received `0.21 + 0.199 + 0.189 = 0.598` stETH (worths `$`598). If Bob continues calling this function, their gain will increase more and more to the point that `_totalSupply` and `_totalShares` become closer to each other.\n\n  A simple calculation shows that if Bob calls this function 60 times (for sure each time the input parameter should be adjusted based on the `_totalSupply` and `_totalShares`), the state will be:\n\n  * `shares[Bob] = 1`\n  * `_totalShares  = 20`\n  * `_totalSupply = 203.7e18`\n  * `borrowed[Bob] = 200e18 + 1`\n  * `poolTotalEUSDCirculation = 203.7e18`\n  * `depositAsset[Bob] = 1e18`\n  * `totalDepositedAsset = 7e18`\n  * `stETH.balanceOf(protocol) = 7e18`\n  * `shares[Alice] = 19`\n  * `borrowed[Alice] = 3.7e18`\n  * `depositAsset[Alice] = 6e18`\n\n  It shows that almost the gain of Bob is 4 stETH (worth `$`4000).\n\n  The following code simply shows that how this repetitive calling of `rigidRedemption` works:\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ncontract LybraPoC {\n    mapping(address => uint256) public borrowed;\n    mapping(address => uint256) public shares;\n    address public Alice = address(1);\n    address public Bob = address(2);\n    uint256 public bobGain;\n    uint256 public num;\n\n    function redeem() public {\n        uint256 toBeRedeemed;\n        uint256 requiredShares;\n        uint256 _totalSupply = 4200e18 + 1;\n        uint256 _totalShares = 20;\n        shares[Bob] = 1;\n        shares[Alice] = 19;\n        borrowed[Bob] = 200e18 + 1;\n        borrowed[Alice] = 4000e18;\n        while (true) {\n            num++;\n            toBeRedeemed = (_totalSupply % _totalShares == 0)\n                ? (_totalSupply / _totalShares) - 1\n                : (_totalSupply / _totalShares);\n            requiredShares = (toBeRedeemed * _totalShares) / _totalSupply;\n            if (toBeRedeemed > borrowed[Alice]) {\n                break;\n            }\n            borrowed[Alice] -= toBeRedeemed;\n            _totalSupply -= toBeRedeemed;\n            _totalShares -= requiredShares;\n            shares[Bob] -= requiredShares;\n            bobGain += toBeRedeemed;\n        }\n    }\n}\n\n```\n\nPlease note that, Bob does not have enough share to repay his borrow and release all his collateral. So, assuming safe collateral rate is 160%, Bob, at most, can withdraw `1 ETH - 1.6 * (200e18 + 1) = `$`680`. He also gained `$`4000 by redeeming Alice 60 times, so Bob's balance now is: `$`680 + `$`4000 = `$`4680` which means `$`3680 is his total gain that is stolen from the protocol. In other words, protocol has minted some shares without enough stETH backed.\n\nBob can now start to repay his borrow to reduce `borrowed[Bob]` step by step, without burning any share. For example, first repays 10e18 eUSD, second repays 9e18 eUSD. But, for simplicity, I ignored this calculation, and just focused on redeeming Alice to steal big fund. By repaying multiple of times, `_totalSupply` and `_totalShares` become closer to each other. Then again, it is possible to make it imbalance by providing fake income and attack the next users. Therefore, this attack can be applied multiple of times without any restriction.\n\nAlice is just an example of all the providers in the protocol. If there are other non-provider users also, this scenario is still valid.\n\n* **Second Scenario:** If Alice is liquidated, Bob can liquidate her without burning share again similar to the mechanism described during redeeming.\n\n* **Third Scenario:** Please note that if another innocent user (Eve) is also involved in our example, she will lose funds as well. So, let's say that Eve deposited 20 ETH, and also minted 10000e18 eUSD. So, the state will be:\n    *   `shares[Bob] = 1`\n    *   `_totalShares = 20 + 47 = 67`\n    *   `_totalSupply = 4200e18 + 1 + 10000e18 = 14200e18 + 1`\n    *   `borrowed[Bob] = 200e18 + 1`\n    *   `poolTotalEUSDCirculation = 4200e18 + 1 + 10000e18 = 14200e18 + 1`\n    *   `depositAsset[Bob] = 1e18`\n    *   `totalDepositedAsset = 11e18 + 20e18 = 31e18`\n    *   `stETH.balanceOf(protocol) = 11e18 + 20e18 = 31e18`\n    *   `shares[Alice] = 19`\n    *   `borrowed[Alice] = 4000e18`\n    *   `depositAsset[Alice] = 10e18`\n    *   `shares[Eve] = 47`\n    *   `borrowed[Eve] = 10000e18`\n    *   `depositAsset[Eve] = 20e18`\n\nNow, suppose only Alice is provider, and Eve is not. So, we can redeem Alice by using the same mechanism we describe in the first scenario. Using the same piece of code for repetitive redemption, we have:\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ncontract LybraPoC {\n    mapping(address => uint256) public borrowed;\n    mapping(address => uint256) public shares;\n    address public Alice = address(1);\n    address public Bob = address(2);\n    address public Eve = address(3);\n    uint256 public bobGain;\n    uint256 public num;\n    uint256 public _totalSupply;\n    uint256 public _totalShares;\n\n    function redeem() public {\n        uint256 toBeRedeemed;\n        uint256 requiredShares;\n        _totalSupply = 14200e18 + 1;\n        _totalShares = 67;\n        shares[Bob] = 1;\n        shares[Alice] = 19;\n        shares[Eve] = 47;\n        borrowed[Bob] = 200e18 + 1;\n        borrowed[Alice] = 4000e18;\n        borrowed[Eve] = 10000e18;\n\n        while (true) {\n            num++;\n            toBeRedeemed = (_totalSupply % _totalShares == 0)\n                ? (_totalSupply / _totalShares) - 1\n                : (_totalSupply / _totalShares);\n            requiredShares = (toBeRedeemed * _totalShares) / _totalSupply;\n            if (toBeRedeemed > borrowed[Alice]) {\n                break;\n            }\n            borrowed[Alice] -= toBeRedeemed;\n            _totalSupply -= toBeRedeemed;\n            _totalShares -= requiredShares;\n            shares[Bob] -= requiredShares;\n            bobGain += toBeRedeemed;\n        }\n    }\n}\n\n```\n\nAfter redeeming Alice 23 times, the state will be:\n\n*   `shares[Bob] = 1`\n*   `_totalShares = 20 + 47 = 67`\n*   `_totalSupply = 10200.2e18`\n*   `borrowed[Bob] = 200e18 + 1`\n*   `poolTotalEUSDCirculation = 10200.2e18 + 1`\n*   `depositAsset[Bob] = 1e18`\n*   `totalDepositedAsset = 27e18`\n*   `stETH.balanceOf(protocol) = 27e18`\n*   `shares[Alice] = 19`\n*   `borrowed[Alice] = 2.1e17`\n*   `depositAsset[Alice] = 6e18`\n*   `shares[Eve] = 47`\n*   `borrowed[Eve] = 10000e18`\n*   `depositAsset[Eve] = 20e18`\n\nNow if Eve wants to repay her whole borrowed amount, she should burn almost 65 shares: `10000e18 * 67 / 10200e18`, but she has only 47 shares. So, she can only repay at most 7155e18 of her borrow. It means that Eve's fund is stolen by Bob. In other words, the collateralized ETH are taken by Bob without burning any shares, so the left shares do not have enough ETH backed.\n\nThis scenario shows that Bob made `_totalSupply` and `_totalShares` imbalance, then two innocent users deposited in the protocol and borrowed some eUSD. Since the difference between these two `_totalSupply` and `_totalShares` is large, small amount of shares are minted. Then, Bob redeemed some amount through the user who was provider. By doing so, the values of `_totalSupply` and `_totalShares` become closer to each other. Now if the second user intends to repay her borrow, she should burn more shares that she owns (because the difference of the values `_totalSupply` and `_totalShares` is now smaller).\n\n*   **Fourth Scenario:** Alice can not transfer less than 210e18 eUSD. Because, in the function `_trasnfer`, `_sharesToTransfer = 209e18 * 20 / (4200e18 + 1) = 0`\n\n    <https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/EUSD.sol#L153> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/EUSD.sol#L349>\n\n*   **Fifth Scenario:** If protocol stETH balance increases by 0.1stETH through LSD after some time. Bob can buy this income without burning any share, in other words Bob steals the income of the protocol. The flow is as follows:\n    *   Bob calls `excessIncomeDistribution(1e17)`.\n    \n        <https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L62C14-L62C38>\n\n    *   The `payAmount` will be `100e18`.\n\n        <https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L66>\n\n    *   If `income >= payAmount`, then `payAmount` should be transferred from Bob to the configurator address.\n\n        <https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L85>\n\n    *   In the `_transfer`, `100e18` will be converted to shares: `_sharesToTransfer = 100e18 * 20 / (4200e18 + 1) = 0`. So, 0 shares will be deducted from Bob, but 0.1 stETH will be transferred to him.\n\n        <https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/EUSD.sol#L348>\n\n</details>\n\n<br>\nPlease note that for sake of simplicity the fees related to the redemption/liquidation are ignored. So, considering those into our calculation does not make the scenarios invalid.\n\n<br> \n\n**In Summary:**\n\nBob makes `_totalSupply` and `_totalShares` imbalance significantly, by just providing fake income in the protocol at day 0. Now that it is imbalanced, he can redeem or liquidate users without burning any shares. He can also steal protocol's income fund without burning any shares.\n\n### Recommended Mitigation Steps\n\n**First Fix:**\nDuring the `_repay`, it should return the amount of burned shares.\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L279>\n\nSo that in the functions `liquidation`, `superLiquidation`, and `rigidRedemption`, again the burned shares should be converted to eUSD; this amount should be used for the rest of calculations.\n\n    function rigidRedemption(address provider, uint256 eusdAmount) external virtual {\n            // ...\n            uint256 brnedShares = _repay(msg.sender, provider, eusdAmount);\n            eusdAmount = getMintedEUSDByShares(brnedShares);\n            //...\n        }\n\n**Second Fix:**\nIn the `excessIncomeDistribution`, the same check should be included in the else body as well.\n\n    uint256 sharesAmount = EUSD.getSharesByMintedEUSD(payAmount - income);\n                if (sharesAmount == 0) {\n                    //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n                    sharesAmount = (payAmount - income);\n                }\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/LybraStETHVault.sol#L75-L79>\n\n### Assessed type\n\nContext\n\n**[LybraFinance acknowledged](https://github.com/code-423n4/2023-06-lybra-findings/issues/340#issuecomment-1635593185)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/pools/LybraStETHVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IEUSD.sol\";\nimport \"./base/LybraEUSDVaultBase.sol\";\n\ninterface Ilido {\n    function submit(address _referral) external payable returns (uint256 StETH);\n}\n\ncontract LybraStETHDepositVault is LybraEUSDVaultBase {\n    // Currently, the official rebase time for Lido is between 12PM to 13PM UTC.\n    uint256 public lidoRebaseTime = 12 hours;\n\n    // stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\n    // oracle = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De\n    constructor(address _config, address _stETH, address _oracle) LybraEUSDVaultBase(_stETH, _oracle, _config) {\n    }\n\n    /**\n     * @notice Sets the rebase time for Lido based on the actual situation.\n     * This function can only be called by an address with the ADMIN role.\n     */\n    function setLidoRebaseTime(uint256 _time) external {\n        require(configurator.hasRole(keccak256(\"ADMIN\"), msg.sender), \"not authorized\");\n        lidoRebaseTime = _time;\n    }\n\n    /**\n     * @notice Allows users to deposit ETH to mint eUSD.\n     * ETH is directly deposited into Lido and converted to stETH.\n     * @param mintAmount The amount of eUSD to mint.\n     * Requirements:\n     * The deposited amount of ETH must be greater than or equal to 1 ETH.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable override {\n        require(msg.value >= 1 ether, \"DNL\");\n        //convert to steth\n        uint256 sharesAmount = Ilido(address(collateralAsset)).submit{value: msg.value}(address(configurator));\n        require(sharesAmount > 0, \"ZERO_DEPOSIT\");\n\n        totalDepositedAsset += msg.value;\n        depositedAsset[msg.sender] += msg.value;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n\n        emit DepositEther(msg.sender, address(collateralAsset), msg.value, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDValueCaptured` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 stETHAmount) external override {\n        uint256 excessAmount = collateralAsset.balanceOf(address(this)) - totalDepositedAsset;\n        require(excessAmount > 0 && stETHAmount > 0, \"Only LSD excess income can be exchanged\");\n        uint256 realAmount = stETHAmount > excessAmount ? excessAmount : stETHAmount;\n        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000;\n\n        uint256 income = feeStored + _newFee();\n        if (payAmount > income) {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), income);\n            require(success, \"TF\");\n\n            try configurator.distributeRewards() {} catch {}\n\n            uint256 sharesAmount = EUSD.getSharesByMintedEUSD(payAmount - income);\n            if (sharesAmount == 0) {\n                //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n                sharesAmount = (payAmount - income);\n            }\n            //Income is distributed to LBR staker.\n            EUSD.burnShares(msg.sender, sharesAmount);\n            feeStored = 0;\n            emit FeeDistribution(address(configurator), income, block.timestamp);\n        } else {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), payAmount);\n            require(success, \"TF\");\n            try configurator.distributeRewards() {} catch {}\n            feeStored = income - payAmount;\n            emit FeeDistribution(address(configurator), payAmount, block.timestamp);\n        }\n\n        lastReportTime = block.timestamp;\n        collateralAsset.transfer(msg.sender, realAmount);\n        emit LSDValueCaptured(realAmount, payAmount, getDutchAuctionDiscountPrice(), block.timestamp);\n    }\n\n    /**\n     * @notice Reduces the discount for the issuance of additional tokens based on the rebase time using the Dutch auction method.\n     * The specific rule is that the discount rate increases by 1% every 30 minutes after the rebase occurs.\n     */\n    function getDutchAuctionDiscountPrice() public view returns (uint256) {\n        uint256 time = (block.timestamp - lidoRebaseTime) % 1 days;\n        if (time < 30 minutes) return 10000;\n        return 10000 - (time / 30 minutes - 1) * 100;\n    }\n\n    function getAssetPrice() public override returns (uint256) {\n        return _etherPrice();\n    }\n}"
    },
    {
      "filename": "contracts/lybra/pools/LybraStETHVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IEUSD.sol\";\nimport \"./base/LybraEUSDVaultBase.sol\";\n\ninterface Ilido {\n    function submit(address _referral) external payable returns (uint256 StETH);\n}\n\ncontract LybraStETHDepositVault is LybraEUSDVaultBase {\n    // Currently, the official rebase time for Lido is between 12PM to 13PM UTC.\n    uint256 public lidoRebaseTime = 12 hours;\n\n    // stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\n    // oracle = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De\n    constructor(address _config, address _stETH, address _oracle) LybraEUSDVaultBase(_stETH, _oracle, _config) {\n    }\n\n    /**\n     * @notice Sets the rebase time for Lido based on the actual situation.\n     * This function can only be called by an address with the ADMIN role.\n     */\n    function setLidoRebaseTime(uint256 _time) external {\n        require(configurator.hasRole(keccak256(\"ADMIN\"), msg.sender), \"not authorized\");\n        lidoRebaseTime = _time;\n    }\n\n    /**\n     * @notice Allows users to deposit ETH to mint eUSD.\n     * ETH is directly deposited into Lido and converted to stETH.\n     * @param mintAmount The amount of eUSD to mint.\n     * Requirements:\n     * The deposited amount of ETH must be greater than or equal to 1 ETH.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable override {\n        require(msg.value >= 1 ether, \"DNL\");\n        //convert to steth\n        uint256 sharesAmount = Ilido(address(collateralAsset)).submit{value: msg.value}(address(configurator));\n        require(sharesAmount > 0, \"ZERO_DEPOSIT\");\n\n        totalDepositedAsset += msg.value;\n        depositedAsset[msg.sender] += msg.value;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n\n        emit DepositEther(msg.sender, address(collateralAsset), msg.value, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDValueCaptured` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 stETHAmount) external override {\n        uint256 excessAmount = collateralAsset.balanceOf(address(this)) - totalDepositedAsset;\n        require(excessAmount > 0 && stETHAmount > 0, \"Only LSD excess income can be exchanged\");\n        uint256 realAmount = stETHAmount > excessAmount ? excessAmount : stETHAmount;\n        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000;\n\n        uint256 income = feeStored + _newFee();\n        if (payAmount > income) {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), income);\n            require(success, \"TF\");\n\n            try configurator.distributeRewards() {} catch {}\n\n            uint256 sharesAmount = EUSD.getSharesByMintedEUSD(payAmount - income);\n            if (sharesAmount == 0) {\n                //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n                sharesAmount = (payAmount - income);\n            }\n            //Income is distributed to LBR staker.\n            EUSD.burnShares(msg.sender, sharesAmount);\n            feeStored = 0;\n            emit FeeDistribution(address(configurator), income, block.timestamp);\n        } else {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), payAmount);\n            require(success, \"TF\");\n            try configurator.distributeRewards() {} catch {}\n            feeStored = income - payAmount;\n            emit FeeDistribution(address(configurator), payAmount, block.timestamp);\n        }\n\n        lastReportTime = block.timestamp;\n        collateralAsset.transfer(msg.sender, realAmount);\n        emit LSDValueCaptured(realAmount, payAmount, getDutchAuctionDiscountPrice(), block.timestamp);\n    }\n\n    /**\n     * @notice Reduces the discount for the issuance of additional tokens based on the rebase time using the Dutch auction method.\n     * The specific rule is that the discount rate increases by 1% every 30 minutes after the rebase occurs.\n     */\n    function getDutchAuctionDiscountPrice() public view returns (uint256) {\n        uint256 time = (block.timestamp - lidoRebaseTime) % 1 days;\n        if (time < 30 minutes) return 10000;\n        return 10000 - (time / 30 minutes - 1) * 100;\n    }\n\n    function getAssetPrice() public override returns (uint256) {\n        return _etherPrice();\n    }\n}"
    },
    {
      "filename": "contracts/lybra/pools/LybraStETHVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IEUSD.sol\";\nimport \"./base/LybraEUSDVaultBase.sol\";\n\ninterface Ilido {\n    function submit(address _referral) external payable returns (uint256 StETH);\n}\n\ncontract LybraStETHDepositVault is LybraEUSDVaultBase {\n    // Currently, the official rebase time for Lido is between 12PM to 13PM UTC.\n    uint256 public lidoRebaseTime = 12 hours;\n\n    // stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\n    // oracle = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De\n    constructor(address _config, address _stETH, address _oracle) LybraEUSDVaultBase(_stETH, _oracle, _config) {\n    }\n\n    /**\n     * @notice Sets the rebase time for Lido based on the actual situation.\n     * This function can only be called by an address with the ADMIN role.\n     */\n    function setLidoRebaseTime(uint256 _time) external {\n        require(configurator.hasRole(keccak256(\"ADMIN\"), msg.sender), \"not authorized\");\n        lidoRebaseTime = _time;\n    }\n\n    /**\n     * @notice Allows users to deposit ETH to mint eUSD.\n     * ETH is directly deposited into Lido and converted to stETH.\n     * @param mintAmount The amount of eUSD to mint.\n     * Requirements:\n     * The deposited amount of ETH must be greater than or equal to 1 ETH.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable override {\n        require(msg.value >= 1 ether, \"DNL\");\n        //convert to steth\n        uint256 sharesAmount = Ilido(address(collateralAsset)).submit{value: msg.value}(address(configurator));\n        require(sharesAmount > 0, \"ZERO_DEPOSIT\");\n\n        totalDepositedAsset += msg.value;\n        depositedAsset[msg.sender] += msg.value;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n\n        emit DepositEther(msg.sender, address(collateralAsset), msg.value, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDValueCaptured` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 stETHAmount) external override {\n        uint256 excessAmount = collateralAsset.balanceOf(address(this)) - totalDepositedAsset;\n        require(excessAmount > 0 && stETHAmount > 0, \"Only LSD excess income can be exchanged\");\n        uint256 realAmount = stETHAmount > excessAmount ? excessAmount : stETHAmount;\n        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000;\n\n        uint256 income = feeStored + _newFee();\n        if (payAmount > income) {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), income);\n            require(success, \"TF\");\n\n            try configurator.distributeRewards() {} catch {}\n\n            uint256 sharesAmount = EUSD.getSharesByMintedEUSD(payAmount - income);\n            if (sharesAmount == 0) {\n                //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n                sharesAmount = (payAmount - income);\n            }\n            //Income is distributed to LBR staker.\n            EUSD.burnShares(msg.sender, sharesAmount);\n            feeStored = 0;\n            emit FeeDistribution(address(configurator), income, block.timestamp);\n        } else {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), payAmount);\n            require(success, \"TF\");\n            try configurator.distributeRewards() {} catch {}\n            feeStored = income - payAmount;\n            emit FeeDistribution(address(configurator), payAmount, block.timestamp);\n        }\n\n        lastReportTime = block.timestamp;\n        collateralAsset.transfer(msg.sender, realAmount);\n        emit LSDValueCaptured(realAmount, payAmount, getDutchAuctionDiscountPrice(), block.timestamp);\n    }\n\n    /**\n     * @notice Reduces the discount for the issuance of additional tokens based on the rebase time using the Dutch auction method.\n     * The specific rule is that the discount rate increases by 1% every 30 minutes after the rebase occurs.\n     */\n    function getDutchAuctionDiscountPrice() public view returns (uint256) {\n        uint256 time = (block.timestamp - lidoRebaseTime) % 1 days;\n        if (time < 30 minutes) return 10000;\n        return 10000 - (time / 30 minutes - 1) * 100;\n    }\n\n    function getAssetPrice() public override returns (uint256) {\n        return _etherPrice();\n    }\n}"
    },
    {
      "filename": "contracts/lybra/pools/LybraStETHVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IEUSD.sol\";\nimport \"./base/LybraEUSDVaultBase.sol\";\n\ninterface Ilido {\n    function submit(address _referral) external payable returns (uint256 StETH);\n}\n\ncontract LybraStETHDepositVault is LybraEUSDVaultBase {\n    // Currently, the official rebase time for Lido is between 12PM to 13PM UTC.\n    uint256 public lidoRebaseTime = 12 hours;\n\n    // stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\n    // oracle = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De\n    constructor(address _config, address _stETH, address _oracle) LybraEUSDVaultBase(_stETH, _oracle, _config) {\n    }\n\n    /**\n     * @notice Sets the rebase time for Lido based on the actual situation.\n     * This function can only be called by an address with the ADMIN role.\n     */\n    function setLidoRebaseTime(uint256 _time) external {\n        require(configurator.hasRole(keccak256(\"ADMIN\"), msg.sender), \"not authorized\");\n        lidoRebaseTime = _time;\n    }\n\n    /**\n     * @notice Allows users to deposit ETH to mint eUSD.\n     * ETH is directly deposited into Lido and converted to stETH.\n     * @param mintAmount The amount of eUSD to mint.\n     * Requirements:\n     * The deposited amount of ETH must be greater than or equal to 1 ETH.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable override {\n        require(msg.value >= 1 ether, \"DNL\");\n        //convert to steth\n        uint256 sharesAmount = Ilido(address(collateralAsset)).submit{value: msg.value}(address(configurator));\n        require(sharesAmount > 0, \"ZERO_DEPOSIT\");\n\n        totalDepositedAsset += msg.value;\n        depositedAsset[msg.sender] += msg.value;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n\n        emit DepositEther(msg.sender, address(collateralAsset), msg.value, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDValueCaptured` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 stETHAmount) external override {\n        uint256 excessAmount = collateralAsset.balanceOf(address(this)) - totalDepositedAsset;\n        require(excessAmount > 0 && stETHAmount > 0, \"Only LSD excess income can be exchanged\");\n        uint256 realAmount = stETHAmount > excessAmount ? excessAmount : stETHAmount;\n        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000;\n\n        uint256 income = feeStored + _newFee();\n        if (payAmount > income) {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), income);\n            require(success, \"TF\");\n\n            try configurator.distributeRewards() {} catch {}\n\n            uint256 sharesAmount = EUSD.getSharesByMintedEUSD(payAmount - income);\n            if (sharesAmount == 0) {\n                //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n                sharesAmount = (payAmount - income);\n            }\n            //Income is distributed to LBR staker.\n            EUSD.burnShares(msg.sender, sharesAmount);\n            feeStored = 0;\n            emit FeeDistribution(address(configurator), income, block.timestamp);\n        } else {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), payAmount);\n            require(success, \"TF\");\n            try configurator.distributeRewards() {} catch {}\n            feeStored = income - payAmount;\n            emit FeeDistribution(address(configurator), payAmount, block.timestamp);\n        }\n\n        lastReportTime = block.timestamp;\n        collateralAsset.transfer(msg.sender, realAmount);\n        emit LSDValueCaptured(realAmount, payAmount, getDutchAuctionDiscountPrice(), block.timestamp);\n    }\n\n    /**\n     * @notice Reduces the discount for the issuance of additional tokens based on the rebase time using the Dutch auction method.\n     * The specific rule is that the discount rate increases by 1% every 30 minutes after the rebase occurs.\n     */\n    function getDutchAuctionDiscountPrice() public view returns (uint256) {\n        uint256 time = (block.timestamp - lidoRebaseTime) % 1 days;\n        if (time < 30 minutes) return 10000;\n        return 10000 - (time / 30 minutes - 1) * 100;\n    }\n\n    function getAssetPrice() public override returns (uint256) {\n        return _etherPrice();\n    }\n}"
    },
    {
      "filename": "contracts/lybra/pools/LybraStETHVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IEUSD.sol\";\nimport \"./base/LybraEUSDVaultBase.sol\";\n\ninterface Ilido {\n    function submit(address _referral) external payable returns (uint256 StETH);\n}\n\ncontract LybraStETHDepositVault is LybraEUSDVaultBase {\n    // Currently, the official rebase time for Lido is between 12PM to 13PM UTC.\n    uint256 public lidoRebaseTime = 12 hours;\n\n    // stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\n    // oracle = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De\n    constructor(address _config, address _stETH, address _oracle) LybraEUSDVaultBase(_stETH, _oracle, _config) {\n    }\n\n    /**\n     * @notice Sets the rebase time for Lido based on the actual situation.\n     * This function can only be called by an address with the ADMIN role.\n     */\n    function setLidoRebaseTime(uint256 _time) external {\n        require(configurator.hasRole(keccak256(\"ADMIN\"), msg.sender), \"not authorized\");\n        lidoRebaseTime = _time;\n    }\n\n    /**\n     * @notice Allows users to deposit ETH to mint eUSD.\n     * ETH is directly deposited into Lido and converted to stETH.\n     * @param mintAmount The amount of eUSD to mint.\n     * Requirements:\n     * The deposited amount of ETH must be greater than or equal to 1 ETH.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable override {\n        require(msg.value >= 1 ether, \"DNL\");\n        //convert to steth\n        uint256 sharesAmount = Ilido(address(collateralAsset)).submit{value: msg.value}(address(configurator));\n        require(sharesAmount > 0, \"ZERO_DEPOSIT\");\n\n        totalDepositedAsset += msg.value;\n        depositedAsset[msg.sender] += msg.value;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n\n        emit DepositEther(msg.sender, address(collateralAsset), msg.value, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDValueCaptured` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 stETHAmount) external override {\n        uint256 excessAmount = collateralAsset.balanceOf(address(this)) - totalDepositedAsset;\n        require(excessAmount > 0 && stETHAmount > 0, \"Only LSD excess income can be exchanged\");\n        uint256 realAmount = stETHAmount > excessAmount ? excessAmount : stETHAmount;\n        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000;\n\n        uint256 income = feeStored + _newFee();\n        if (payAmount > income) {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), income);\n            require(success, \"TF\");\n\n            try configurator.distributeRewards() {} catch {}\n\n            uint256 sharesAmount = EUSD.getSharesByMintedEUSD(payAmount - income);\n            if (sharesAmount == 0) {\n                //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n                sharesAmount = (payAmount - income);\n            }\n            //Income is distributed to LBR staker.\n            EUSD.burnShares(msg.sender, sharesAmount);\n            feeStored = 0;\n            emit FeeDistribution(address(configurator), income, block.timestamp);\n        } else {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), payAmount);\n            require(success, \"TF\");\n            try configurator.distributeRewards() {} catch {}\n            feeStored = income - payAmount;\n            emit FeeDistribution(address(configurator), payAmount, block.timestamp);\n        }\n\n        lastReportTime = block.timestamp;\n        collateralAsset.transfer(msg.sender, realAmount);\n        emit LSDValueCaptured(realAmount, payAmount, getDutchAuctionDiscountPrice(), block.timestamp);\n    }\n\n    /**\n     * @notice Reduces the discount for the issuance of additional tokens based on the rebase time using the Dutch auction method.\n     * The specific rule is that the discount rate increases by 1% every 30 minutes after the rebase occurs.\n     */\n    function getDutchAuctionDiscountPrice() public view returns (uint256) {\n        uint256 time = (block.timestamp - lidoRebaseTime) % 1 days;\n        if (time < 30 minutes) return 10000;\n        return 10000 - (time / 30 minutes - 1) * 100;\n    }\n\n    function getAssetPrice() public override returns (uint256) {\n        return _etherPrice();\n    }\n}"
    },
    {
      "filename": "contracts/lybra/pools/LybraStETHVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IEUSD.sol\";\nimport \"./base/LybraEUSDVaultBase.sol\";\n\ninterface Ilido {\n    function submit(address _referral) external payable returns (uint256 StETH);\n}\n\ncontract LybraStETHDepositVault is LybraEUSDVaultBase {\n    // Currently, the official rebase time for Lido is between 12PM to 13PM UTC.\n    uint256 public lidoRebaseTime = 12 hours;\n\n    // stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\n    // oracle = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De\n    constructor(address _config, address _stETH, address _oracle) LybraEUSDVaultBase(_stETH, _oracle, _config) {\n    }\n\n    /**\n     * @notice Sets the rebase time for Lido based on the actual situation.\n     * This function can only be called by an address with the ADMIN role.\n     */\n    function setLidoRebaseTime(uint256 _time) external {\n        require(configurator.hasRole(keccak256(\"ADMIN\"), msg.sender), \"not authorized\");\n        lidoRebaseTime = _time;\n    }\n\n    /**\n     * @notice Allows users to deposit ETH to mint eUSD.\n     * ETH is directly deposited into Lido and converted to stETH.\n     * @param mintAmount The amount of eUSD to mint.\n     * Requirements:\n     * The deposited amount of ETH must be greater than or equal to 1 ETH.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable override {\n        require(msg.value >= 1 ether, \"DNL\");\n        //convert to steth\n        uint256 sharesAmount = Ilido(address(collateralAsset)).submit{value: msg.value}(address(configurator));\n        require(sharesAmount > 0, \"ZERO_DEPOSIT\");\n\n        totalDepositedAsset += msg.value;\n        depositedAsset[msg.sender] += msg.value;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n\n        emit DepositEther(msg.sender, address(collateralAsset), msg.value, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDValueCaptured` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 stETHAmount) external override {\n        uint256 excessAmount = collateralAsset.balanceOf(address(this)) - totalDepositedAsset;\n        require(excessAmount > 0 && stETHAmount > 0, \"Only LSD excess income can be exchanged\");\n        uint256 realAmount = stETHAmount > excessAmount ? excessAmount : stETHAmount;\n        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000;\n\n        uint256 income = feeStored + _newFee();\n        if (payAmount > income) {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), income);\n            require(success, \"TF\");\n\n            try configurator.distributeRewards() {} catch {}\n\n            uint256 sharesAmount = EUSD.getSharesByMintedEUSD(payAmount - income);\n            if (sharesAmount == 0) {\n                //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n                sharesAmount = (payAmount - income);\n            }\n            //Income is distributed to LBR staker.\n            EUSD.burnShares(msg.sender, sharesAmount);\n            feeStored = 0;\n            emit FeeDistribution(address(configurator), income, block.timestamp);\n        } else {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), payAmount);\n            require(success, \"TF\");\n            try configurator.distributeRewards() {} catch {}\n            feeStored = income - payAmount;\n            emit FeeDistribution(address(configurator), payAmount, block.timestamp);\n        }\n\n        lastReportTime = block.timestamp;\n        collateralAsset.transfer(msg.sender, realAmount);\n        emit LSDValueCaptured(realAmount, payAmount, getDutchAuctionDiscountPrice(), block.timestamp);\n    }\n\n    /**\n     * @notice Reduces the discount for the issuance of additional tokens based on the rebase time using the Dutch auction method.\n     * The specific rule is that the discount rate increases by 1% every 30 minutes after the rebase occurs.\n     */\n    function getDutchAuctionDiscountPrice() public view returns (uint256) {\n        uint256 time = (block.timestamp - lidoRebaseTime) % 1 days;\n        if (time < 30 minutes) return 10000;\n        return 10000 - (time / 30 minutes - 1) * 100;\n    }\n\n    function getAssetPrice() public override returns (uint256) {\n        return _etherPrice();\n    }\n}"
    },
    {
      "filename": "contracts/lybra/pools/LybraStETHVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IEUSD.sol\";\nimport \"./base/LybraEUSDVaultBase.sol\";\n\ninterface Ilido {\n    function submit(address _referral) external payable returns (uint256 StETH);\n}\n\ncontract LybraStETHDepositVault is LybraEUSDVaultBase {\n    // Currently, the official rebase time for Lido is between 12PM to 13PM UTC.\n    uint256 public lidoRebaseTime = 12 hours;\n\n    // stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\n    // oracle = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De\n    constructor(address _config, address _stETH, address _oracle) LybraEUSDVaultBase(_stETH, _oracle, _config) {\n    }\n\n    /**\n     * @notice Sets the rebase time for Lido based on the actual situation.\n     * This function can only be called by an address with the ADMIN role.\n     */\n    function setLidoRebaseTime(uint256 _time) external {\n        require(configurator.hasRole(keccak256(\"ADMIN\"), msg.sender), \"not authorized\");\n        lidoRebaseTime = _time;\n    }\n\n    /**\n     * @notice Allows users to deposit ETH to mint eUSD.\n     * ETH is directly deposited into Lido and converted to stETH.\n     * @param mintAmount The amount of eUSD to mint.\n     * Requirements:\n     * The deposited amount of ETH must be greater than or equal to 1 ETH.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable override {\n        require(msg.value >= 1 ether, \"DNL\");\n        //convert to steth\n        uint256 sharesAmount = Ilido(address(collateralAsset)).submit{value: msg.value}(address(configurator));\n        require(sharesAmount > 0, \"ZERO_DEPOSIT\");\n\n        totalDepositedAsset += msg.value;\n        depositedAsset[msg.sender] += msg.value;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n\n        emit DepositEther(msg.sender, address(collateralAsset), msg.value, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDValueCaptured` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 stETHAmount) external override {\n        uint256 excessAmount = collateralAsset.balanceOf(address(this)) - totalDepositedAsset;\n        require(excessAmount > 0 && stETHAmount > 0, \"Only LSD excess income can be exchanged\");\n        uint256 realAmount = stETHAmount > excessAmount ? excessAmount : stETHAmount;\n        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000;\n\n        uint256 income = feeStored + _newFee();\n        if (payAmount > income) {\n            bool success = EUSD.transferFrom(msg.sender, address(configurator), income);\n            require(success, \"TF\");\n\n            try configurator.distributeRewards() {} catch {}\n\n            uint256 sharesAmount = EUSD.getSharesByMintedEUSD(payAmount - income);\n            if (sharesAmount == 0) {\n                //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n                sharesAmount = (payAmount - income);\n            }\n            //Income is distributed to LBR staker.\n            EUSD.burnShares(msg.sender, sharesAmount);\n            feeStored = 0;\n            emit FeeDistribution(address(configurator), income, block.timestamp);"
    }
  ]
}