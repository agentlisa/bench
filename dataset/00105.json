{
  "Title": "M-10: `TARGET_HEALTH` calculation does not consider the adjust factors of the picked seize and repay markets",
  "Content": "# Issue M-10: `TARGET_HEALTH` calculation does not consider the adjust factors of the picked seize and repay markets \n\nSource: https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/117 \n\nThe protocol has acknowledged this issue.\n\n## Found by \n0x73696d616f\n## Summary\n\nThe `TARGET_HEALTH` calculation is correct, but returns the debt to pay considering that this debt corresponds to the average `adjustFactor`, which is false for more than 1 market, leading to significant deviation in the resulting health factor.\n\n## Vulnerability Detail\n\nThe calculation of the required debt to repay is explained in the [MathPaper](https://github.com/exactly/papers/blob/main/ExactlyMathPaperV1.pdf), and it can be understood that the resulting debt to repay is based on the average adjust factor of all markets.\n\nHowever, when liquidating, repay and seize markets are picked, possibly having different adjust factors. Thus, depending on the picked repay and seized market, the resulting health factor will be significantly different than the `TARGET_HEALTH`. This will either lead to losses for the liquidator or the liquidatee, in case the resulting health factor is smaller or bigger, respectively. \n\nIf the resulting health factor is smaller, the liquidator would receive less assets and the protocol would be closer to accumulating bad debt (it may even be negative if the calculation is way off). Contrarily, if it is higher, the liquidator will have more assets removed than supposed, resulting in losses. \n\nA test was carried out in `Market.t.sol` showing that depending on the market picked, the health factor is either approximately `1.37` or `1.15`, due to the adjust factor.\nThe user \n- Deposited `20_000e18` in a `DAI` market with an adjust factor of `0.8`.\n- Borrowed `20_000e18*0.8^2` in the `DAI` market.\n- Deposited `10_000e18` in a `WETH` market with an adjust factor of `0.9`.\n- Borrowed `10_000e18*0.9^2` in a `WETH` market.\nThe health factor is `(20_000*0.8 + 10000*0.9) / (20000*0.8^2/0.8 + 10000*0.9^2/0.9) = 1`.\n1 second passes to make the health factor smaller than 1.\nNow, depending on the picked repay and seize markets, the resulting health factor will be very different.\n\nThe average adjust factor is `(20_000*0.8 + 10000*0.9) * (20000*0.8^2 + 10000*0.9^2) / (20000*0.8^2/0.8 + 10000*0.9^2/0.9) / (20000 + 10000) = 0.6967`.\n\nThe close factor is `(1.25 - 1) / (1.25 - 0.6967*1.1) = 0.5169`.\n\nThe debt repayed using the close factor is `(20000*0.8^2 + 10000*0.9^2)*0.5169 = 10803`.\nThe Collateral repayed is `10803 * 1.1 = 11883`.\n\nThe issue is that the debt and collateral are averaged on the adjust factor, but it is being repayed on a single market. \n\nRepaying in the `DAI` market, the resulting health factor is `((20_000 - 11883)*0.8 + 10000*0.9) / ((20000*0.8^2 - 10803)/0.8 + 10000*0.9^2/0.9) = 1.3477`.\n\nIf the test is inverted, repaying in the `WETH` market will lead to a health factor of `1.15`.\n\n```solidity\nfunction test_POC_WrongHealthFactor() external {\n  // Change to false to test liquidating in the WETH market\n  // in exactly the same conditions except the adjust factor\n  bool marketDAI = true;\n\n  uint256 assets = 10_000 ether;\n  ERC20 asset = market.asset();\n  uint256 marketAssets = marketDAI ? 2*assets : assets;\n  uint256 wethAssets = marketDAI ? assets : 2*assets;\n\n  vm.startPrank(ALICE);\n\n  // ALICE deposits and borrows DAI\n  deal(address(asset), ALICE, marketAssets);\n  market.deposit(marketAssets, ALICE);\n  market.borrow(marketAssets*8*8/10/10, ALICE, ALICE);\n  \n  // ALICE deposits and borrows weth\n  deal(address(weth), ALICE, wethAssets);\n  weth.approve(address(marketWETH), wethAssets);\n  marketWETH.deposit(wethAssets, ALICE);\n  marketWETH.borrow(wethAssets*9*9/10/10, ALICE, ALICE);\n\n  vm.stopPrank();\n\n  skip(1);\n\n  // LIQUIDATION of DAI MARKET, 0.8 adjust factor\n  if (marketDAI) {\n    deal(address(asset), address(market), 100_000 ether);\n    address liquidator = makeAddr(\"liquidator\");\n    deal(address(asset), liquidator, 100_000_000 ether);\n    vm.startPrank(liquidator);\n    asset.approve(address(market), type(uint256).max);\n    market.liquidate(ALICE, type(uint256).max, market);\n    vm.stopPrank();\n  } \n\n  // LIQUIDATION of WETH MARKET, 0.9 adjust factor\n  if (!marketDAI) {\n    deal(address(weth), address(marketWETH), 100_000 ether);\n    address liquidator = makeAddr(\"liquidator\");\n    deal(address(weth), liquidator, 100_000_000 ether);\n    vm.startPrank(liquidator);\n    weth.approve(address(marketWETH), type(uint256).max);\n    marketWETH.liquidate(ALICE, type(uint256).max, marketWETH);\n    vm.stopPrank();\n  }\n\n  // RATIO is smaller than 1.25, liquidator did not liquidate as much as if it was in\n  // a single market\n  (uint256 collateral, uint256 debt) = auditor.accountLiquidity(address(ALICE), Market(address(0)), 0);\n  assertEq(collateral*1e18 / debt, marketDAI ? 1347680781176165186 : 1146310462433177450);\n}\n```\n\n## Impact\n\nLosses for the liquidator or the liquidatee and possible accumulation of bad debt, depending on the picked market.\n\n## Code Snippet\n\nhttps://github.com/exactly/papers/blob/main/ExactlyMathPaperV1.pdf\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Auditor.sol#L238-L243\n\n## Tool used\n\nManual Review\n\nVscode\n\nFoundry\n\n## Recommendation\n\nThe debt to repay should take into account the adjust factors of the seize and repay markets. In `auditor::checkLiquidation()`, the `maxRepayAssets`, `base.totalDebt.mulWadUp(Math.min(1e18, closeFactor)), must consider the adjust factors of the chosen seize and repay markets.\n\n\n\n## Discussion\n\n**Dliteofficial**\n\n@0x73696d616f I don't see why the protocol should consider the TH of the repay market if they already considered the TH of both the loan and collateral market. The repay market has no standing on the loan to be liquidated, it is just a market from which to pay from. The collateral is where the cover is from, the loan market is where the cover withdrawn is to be used.\n\n@santipu03 I think this is Invalid\n\n**0x73696d616f**\n\n> resulting debt to repay is based on the average adjust factor of all markets.\n\nThe math calculations arrive at an average adjust factor debt to repay and collateral to seize. When you pick a repay and a seize market, they will have different adjust factors than the average, and this must be accounted for.\n\n**Dliteofficial**\n\nYes, I can see that, and I read the report fine. But by all markets, I believe that refers to the seize and repay market. I am not trying to antagonize your finding, I just don't think there is a reason to include the repay market in the calculation of the defaulter's TH since it has no effect on the collateral or the debt. The only exception to this would be when the defaulter's debt/collateral market is the same as the repay market\n\n**0x73696d616f**\n\n> I just don't think there is a reason to include the repay market in the calculation of the defaulter's TH since it has no effect on the collateral or the debt\n\nWhy do you say this?\n\n> The only exception to this would be when the defaulter's debt/collateral market is the same as the repay market\n\nAnd this?\n\n**Dliteofficial**\n\nBecause looking at this on the basis of cause and effect, if the liquidator is repaying from a market different from that of the user's collateral and debt market, it has no effect in the repay market since the borrower doesn't have a borrow there or deposited collateral into the market. As for the exception, I was referring to if the user deposited in the repay market then the market should be considered\n\n**0x73696d616f**\n\n> Because looking at this on the basis of cause and effect, if the liquidator is repaying from a market different from that of the user's collateral and debt market\n\nThis is not possible. The liquidator has to pick a debt and collateral market that the user is participating on. This is the whole point of the liquidation flow.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/247",
  "Code": [
    {
      "filename": "protocol/contracts/Auditor.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { IPriceFeed } from \"./utils/IPriceFeed.sol\";\nimport { Market } from \"./Market.sol\";\n\ncontract Auditor is Initializable, AccessControlUpgradeable {\n  using FixedPointMathLib for uint256;\n\n  /// @notice Address that a market should have as price feed to consider as base price and avoid external price call.\n  address public constant BASE_FEED = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  /// @notice Target health factor that the account should have after it's liquidated to prevent cascade liquidations.\n  uint256 public constant TARGET_HEALTH = 1.25e18;\n  /// @notice Maximum value the liquidator can send and still have granular control of max assets.\n  /// Above this threshold, they should send `type(uint256).max`.\n  uint256 public constant ASSETS_THRESHOLD = type(uint256).max / 1e18;\n\n  /// @notice Decimals that the answer of all price feeds should have.\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  uint256 public immutable priceDecimals;\n  /// @notice Base factor to scale the price returned by the feed to 18 decimals.\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  uint256 internal immutable baseFactor;\n  /// @notice Base price used if the feed to fetch the price from is `BASE_FEED`.\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  uint256 internal immutable basePrice;\n\n  /// @notice Tracks the markets' indexes that an account has entered as collateral.\n  mapping(address => uint256) public accountMarkets;\n  /// @notice Stores market parameters per each enabled market.\n  mapping(Market => MarketData) public markets;\n  /// @notice Array of all enabled markets.\n  Market[] public marketList;\n\n  /// @notice Liquidation incentive factors for the liquidator and the lenders of the market where the debt is repaid.\n  LiquidationIncentive public liquidationIncentive;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor(uint256 priceDecimals_) {\n    priceDecimals = priceDecimals_;\n    baseFactor = 10 ** (18 - priceDecimals_);\n    basePrice = 10 ** priceDecimals_;\n\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the contract.\n  /// @dev can only be called once.\n  function initialize(LiquidationIncentive memory liquidationIncentive_) external initializer {\n    __AccessControl_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    setLiquidationIncentive(liquidationIncentive_);\n  }\n\n  /// @notice Allows assets of a certain market to be used as collateral for borrowing other assets.\n  /// @param market market to enabled as collateral.\n  function enterMarket(Market market) external {\n    MarketData storage m = markets[market];\n    if (!m.isListed) revert MarketNotListed();\n\n    uint256 marketMap = accountMarkets[msg.sender];\n    uint256 marketMask = 1 << m.index;\n\n    if ((marketMap & marketMask) != 0) return;\n    accountMarkets[msg.sender] = marketMap | marketMask;\n\n    emit MarketEntered(market, msg.sender);\n  }\n\n  /// @notice Removes market from sender's account liquidity calculation.\n  /// @dev Sender must not have an outstanding borrow balance in the asset, or be providing necessary collateral\n  /// for an outstanding borrow.\n  /// @param market market to be disabled as collateral.\n  function exitMarket(Market market) external {\n    MarketData storage m = markets[market];\n    if (!m.isListed) revert MarketNotListed();\n\n    (uint256 assets, uint256 debt) = market.accountSnapshot(msg.sender);\n\n    // fail if the sender has a borrow balance\n    if (debt != 0) revert RemainingDebt();\n\n    // fail if the sender is not permitted to redeem all of their assets\n    checkShortfall(market, msg.sender, assets);\n\n    uint256 marketMap = accountMarkets[msg.sender];\n    uint256 marketMask = 1 << m.index;\n\n    if ((marketMap & marketMask) == 0) return;\n    accountMarkets[msg.sender] = marketMap & ~marketMask;\n\n    emit MarketExited(market, msg.sender);\n  }\n\n  /// @notice Returns account's liquidity calculation.\n  /// @param account account in which the liquidity will be calculated.\n  /// @param marketToSimulate market in which to simulate withdraw operation.\n  /// @param withdrawAmount amount to simulate as withdraw.\n  /// @return sumCollateral sum of all collateral, already multiplied by each adjust factor (denominated in base).\n  /// @return sumDebtPlusEffects sum of all debt divided by adjust factor considering withdrawal (denominated in base).\n  function accountLiquidity(\n    address account,\n    Market marketToSimulate,\n    uint256 withdrawAmount\n  ) public view returns (uint256 sumCollateral, uint256 sumDebtPlusEffects) {\n    AccountLiquidity memory vars; // holds all our calculation results\n\n    // for each asset the account is in\n    uint256 marketMap = accountMarkets[account];\n    for (uint256 i = 0; marketMap != 0; marketMap >>= 1) {\n      if (marketMap & 1 != 0) {\n        Market market = marketList[i];\n        MarketData storage m = markets[market];\n        uint256 baseUnit = 10 ** m.decimals;\n        uint256 adjustFactor = m.adjustFactor;\n\n        // read the balances\n        (vars.balance, vars.borrowBalance) = market.accountSnapshot(account);\n\n        // get the normalized price of the asset (18 decimals)\n        vars.price = assetPrice(m.priceFeed);\n\n        // sum all the collateral prices\n        sumCollateral += vars.balance.mulDivDown(vars.price, baseUnit).mulWadDown(adjustFactor);\n\n        // sum all the debt\n        sumDebtPlusEffects += vars.borrowBalance.mulDivUp(vars.price, baseUnit).divWadUp(adjustFactor);\n\n        // simulate the effects of withdrawing from a pool\n        if (market == marketToSimulate) {\n          // calculate the effects of redeeming markets\n          // (having less collateral is the same as having more debt for this calculation)\n          if (withdrawAmount != 0) {\n            sumDebtPlusEffects += withdrawAmount.mulDivDown(vars.price, baseUnit).mulWadDown(adjustFactor);\n          }\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @notice Validates that the current state of the position and system are valid.\n  /// @dev To be called after adding the borrowed debt to the account position.\n  /// @param market address of the market where the borrow is made.\n  /// @param borrower address of the account that will repay the debt.\n  function checkBorrow(Market market, address borrower) external {\n    MarketData storage m = markets[market];\n    if (!m.isListed) revert MarketNotListed();\n\n    uint256 marketMap = accountMarkets[borrower];\n    uint256 marketMask = 1 << m.index;\n\n    // validate borrow state\n    if ((marketMap & marketMask) == 0) {\n      // only markets may call checkBorrow if borrower not in market\n      if (msg.sender != address(market)) revert NotMarket();\n\n      accountMarkets[borrower] = marketMap | marketMask;\n      emit MarketEntered(market, borrower);\n    }\n\n    // verify that current liquidity is not short\n    (uint256 collateral, uint256 debt) = accountLiquidity(borrower, Market(address(0)), 0);\n    if (collateral < debt) revert InsufficientAccountLiquidity();\n  }\n\n  /// @notice Checks if the account has liquidity shortfall.\n  /// @param market address of the market where the operation will happen.\n  /// @param account address of the account to check for possible shortfall.\n  /// @param amount amount that the account wants to withdraw or transfer.\n  function checkShortfall(Market market, address account, uint256 amount) public view {\n    // if the account is not 'in' the market, bypass the liquidity check\n    if ((accountMarkets[account] & (1 << markets[market].index)) == 0) return;\n\n    // otherwise, perform a hypothetical liquidity check to guard against shortfall\n    (uint256 collateral, uint256 debt) = accountLiquidity(account, market, amount);\n    if (collateral < debt) revert InsufficientAccountLiquidity();\n  }\n\n  /// @notice Allows/rejects liquidation of assets.\n  /// @dev This function can be called externally, but only will have effect when called from a market.\n  /// @param repayMarket market from where the debt is being repaid.\n  /// @param seizeMarket market from where the liquidator will seize assets.\n  /// @param borrower address in which the assets are being liquidated.\n  /// @param maxLiquidatorAssets maximum amount of debt the liquidator is willing to accept.\n  /// @return maxRepayAssets capped amount of debt the liquidator is allowed to repay.\n  function checkLiquidation(\n    Market repayMarket,\n    Market seizeMarket,\n    address borrower,\n    uint256 maxLiquidatorAssets\n  ) external view returns (uint256 maxRepayAssets) {\n    // if markets are listed, they have the same auditor\n    if (!markets[repayMarket].isListed || !markets[seizeMarket].isListed) revert MarketNotListed();\n\n    MarketVars memory repay;\n    LiquidityVars memory base;\n    uint256 marketMap = accountMarkets[borrower];\n    for (uint256 i = 0; marketMap != 0; marketMap >>= 1) {\n      if (marketMap & 1 != 0) {\n        Market market = marketList[i];\n        MarketData storage marketData = markets[market];\n        MarketVars memory m = MarketVars({\n          price: assetPrice(marketData.priceFeed),\n          adjustFactor: marketData.adjustFactor,\n          baseUnit: 10 ** marketData.decimals\n        });\n\n        if (market == repayMarket) repay = m;\n\n        (uint256 collateral, uint256 debt) = market.accountSnapshot(borrower);\n\n        uint256 value = debt.mulDivUp(m.price, m.baseUnit);\n        base.totalDebt += value;\n        base.adjustedDebt += value.divWadUp(m.adjustFactor);\n\n        value = collateral.mulDivDown(m.price, m.baseUnit);\n        base.totalCollateral += value;\n        base.adjustedCollateral += value.mulWadDown(m.adjustFactor);\n        if (market == seizeMarket) base.seizeAvailable = value;\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    if (base.adjustedCollateral >= base.adjustedDebt) revert InsufficientShortfall();\n\n    LiquidationIncentive memory memIncentive = liquidationIncentive;\n    uint256 adjustFactor = base.adjustedCollateral.mulWadDown(base.totalDebt).divWadUp(\n      base.adjustedDebt.mulWadUp(base.totalCollateral)\n    );\n    uint256 closeFactor = (TARGET_HEALTH - base.adjustedCollateral.divWadUp(base.adjustedDebt)).divWadUp(\n      TARGET_HEALTH - adjustFactor.mulWadDown(1e18 + memIncentive.liquidator + memIncentive.lenders)\n    );\n    maxRepayAssets = Math.min(\n      Math\n        .min(\n          base.totalDebt.mulWadUp(Math.min(1e18, closeFactor)),\n          base.seizeAvailable.divWadUp(1e18 + memIncentive.liquidator + memIncentive.lenders)\n        )\n        .mulDivUp(repay.baseUnit, repay.price),\n      maxLiquidatorAssets < ASSETS_THRESHOLD\n        ? maxLiquidatorAssets.divWadDown(1e18 + memIncentive.lenders)\n        : maxLiquidatorAssets\n    );\n  }\n\n  /// @notice Allow/rejects seizing of assets.\n  /// @dev This function can be called externally, but only will have effect when called from a market.\n  /// @param repayMarket market from where the debt will be repaid.\n  /// @param seizeMarket market where the assets will be seized.\n  function checkSeize(Market repayMarket, Market seizeMarket) external view {\n    // if markets are listed, they also point to the same Auditor\n    if (!markets[seizeMarket].isListed || !markets[repayMarket].isListed) revert MarketNotListed();\n  }\n\n  /// @notice Calculates the amount of collateral to be seized when a position is undercollateralized.\n  /// @param repayMarket market from where the debt will be repaid.\n  /// @param seizeMarket market from where the assets will be seized by the liquidator.\n  /// @param borrower account in which assets are being seized.\n  /// @param actualRepayAssets amount being repaid.\n  /// @return lendersAssets amount to be added for other lenders as a compensation of bad debt clearing.\n  /// @return seizeAssets amount that can be seized by the liquidator.\n  function calculateSeize(\n    Market repayMarket,\n    Market seizeMarket,\n    address borrower,\n    uint256 actualRepayAssets\n  ) external view returns (uint256 lendersAssets, uint256 seizeAssets) {\n    LiquidationIncentive memory memIncentive = liquidationIncentive;\n    lendersAssets = actualRepayAssets.mulWadDown(memIncentive.lenders);\n\n    // read prices for borrowed and collateral markets\n    uint256 priceBorrowed = assetPrice(markets[repayMarket].priceFeed);\n    uint256 priceCollateral = assetPrice(markets[seizeMarket].priceFeed);\n    uint256 baseAmount = actualRepayAssets.mulDivUp(priceBorrowed, 10 ** markets[repayMarket].decimals);\n\n    seizeAssets = Math.min(\n      baseAmount.mulDivUp(10 ** markets[seizeMarket].decimals, priceCollateral).mulWadUp(\n        1e18 + memIncentive.liquidator + memIncentive.lenders\n      ),\n      seizeMarket.maxWithdraw(borrower)\n    );\n  }\n\n  /// @notice Checks if account has debt with no collateral, if so then call `clearBadDebt` from each market.\n  /// @dev Collateral is multiplied by price and adjust factor to be accurately evaluated as positive collateral asset.\n  /// @param account account in which debt is being checked.\n  function handleBadDebt(address account) external {\n    uint256 memMarketMap = accountMarkets[account];\n    uint256 marketMap = memMarketMap;\n    for (uint256 i = 0; marketMap != 0; marketMap >>= 1) {\n      if (marketMap & 1 != 0) {\n        Market market = marketList[i];\n        MarketData storage m = markets[market];\n        uint256 assets = market.maxWithdraw(account);\n        if (assets.mulDivDown(assetPrice(m.priceFeed), 10 ** m.decimals).mulWadDown(m.adjustFactor) > 0) return;\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    marketMap = memMarketMap;\n    for (uint256 i = 0; marketMap != 0; marketMap >>= 1) {\n      if (marketMap & 1 != 0) marketList[i].clearBadDebt(account);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @notice Gets the asset price of a price feed.\n  /// @dev If Chainlink's asset price is <= 0 the call is reverted.\n  /// @param priceFeed address of Chainlink's Price Feed aggregator used to query the asset price.\n  /// @return The price of the asset scaled to 18-digit decimals.\n  function assetPrice(IPriceFeed priceFeed) public view returns (uint256) {\n    if (address(priceFeed) == BASE_FEED) return basePrice;\n\n    int256 price = priceFeed.latestAnswer();\n    if (price <= 0) revert InvalidPrice();\n    return uint256(price) * baseFactor;\n  }\n\n  /// @notice Retrieves all markets.\n  function allMarkets() external view returns (Market[] memory) {\n    return marketList;\n  }\n\n  /// @notice Enables a certain market.\n  /// @dev Enabling more than 256 markets will cause an overflow when casting market index to uint8.\n  /// @param market market to add to the protocol.\n  /// @param priceFeed address of Chainlink's Price Feed aggregator used to query the asset price in base.\n  /// @param adjustFactor market's adjust factor for the underlying asset.\n  function enableMarket(\n    Market market,\n    IPriceFeed priceFeed,\n    uint128 adjustFactor\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (market.auditor() != this) revert AuditorMismatch();\n    if (markets[market].isListed) revert MarketAlreadyListed();\n    if (address(priceFeed) != BASE_FEED && priceFeed.decimals() != priceDecimals) revert InvalidPriceFeed();\n\n    uint8 decimals = market.decimals();\n    markets[market] = MarketData({\n      isListed: true,\n      adjustFactor: adjustFactor,\n      decimals: decimals,\n      index: uint8(marketList.length),\n      priceFeed: priceFeed\n    });\n\n    marketList.push(market);\n\n    emit MarketListed(market, decimals);\n    emit PriceFeedSet(market, priceFeed);\n    emit AdjustFactorSet(market, adjustFactor);\n  }\n\n  /// @notice Sets the adjust factor for a certain market.\n  /// @param market address of the market to change adjust factor for.\n  /// @param adjustFactor adjust factor for the underlying asset.\n  function setAdjustFactor(Market market, uint128 adjustFactor) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (!markets[market].isListed) revert MarketNotListed();\n\n    markets[market].adjustFactor = adjustFactor;\n    emit AdjustFactorSet(market, adjustFactor);\n  }\n\n  /// @notice Sets the Chainlink Price Feed Aggregator source for a market.\n  /// @param market market address of the asset.\n  /// @param priceFeed address of Chainlink's Price Feed aggregator used to query the asset price in base.\n  function setPriceFeed(Market market, IPriceFeed priceFeed) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (address(priceFeed) != BASE_FEED && priceFeed.decimals() != priceDecimals) revert InvalidPriceFeed();\n    markets[market].priceFeed = priceFeed;\n    emit PriceFeedSet(market, priceFeed);\n  }\n\n  /// @notice Sets liquidation incentive (liquidator and lenders) for the whole ecosystem.\n  /// @param liquidationIncentive_ new liquidation incentive.\n  function setLiquidationIncentive(\n    LiquidationIncentive memory liquidationIncentive_\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    liquidationIncentive = liquidationIncentive_;\n    emit LiquidationIncentiveSet(liquidationIncentive_);\n  }\n\n  /// @notice Emitted when a new market is listed for borrow/lending.\n  /// @param market address of the market that was listed.\n  /// @param decimals decimals of the market's underlying asset.\n  event MarketListed(Market indexed market, uint8 decimals);\n\n  /// @notice Emitted when an account enters a market to use his deposit as collateral for a loan.\n  /// @param market address of the market that the account entered.\n  /// @param account address of the account that just entered a market.\n  event MarketEntered(Market indexed market, address indexed account);\n\n  /// @notice Emitted when an account leaves a market.\n  /// Means that they would stop using their deposit as collateral and won't ask for any loans in this market.\n  /// @param market address of the market that the account just left.\n  /// @param account address of the account that just left a market.\n  event MarketExited(Market indexed market, address indexed account);\n\n  /// @notice Emitted when a adjust factor is changed by admin.\n  /// @param market address of the market that has a new adjust factor.\n  /// @param adjustFactor adjust factor for the underlying asset.\n  event AdjustFactorSet(Market indexed market, uint256 adjustFactor);\n\n  /// @notice Emitted when a new liquidationIncentive has been set.\n  /// @param liquidationIncentive represented with 18 decimals.\n  event LiquidationIncentiveSet(LiquidationIncentive liquidationIncentive);\n\n  /// @notice Emitted when a market and prie feed is changed by admin.\n  /// @param market address of the asset used to get the price.\n  /// @param priceFeed address of Chainlink's Price Feed aggregator used to query the asset price in base.\n  event PriceFeedSet(Market indexed market, IPriceFeed indexed priceFeed);\n\n  /// @notice Stores the market parameters used for liquidity calculations.\n  /// @param adjustFactor used to asses the lending power of the market's underlying asset.\n  /// @param decimals number of decimals of the market's underlying asset.\n  /// @param index index of the market in the `marketList`.\n  /// @param isListed true if the market is enabled.\n  /// @param priceFeed address of the price feed used to query the asset's price.\n  struct MarketData {\n    uint128 adjustFactor;\n    uint8 decimals;\n    uint8 index;\n    bool isListed;\n    IPriceFeed priceFeed;\n  }\n\n  /// @notice Stores the liquidator and lenders factors used in liquidations to calculate the amount to seize.\n  /// @param liquidator factor used to calculate the extra bonus a liquidator can seize.\n  /// @param lenders factor used to calculate the bonus that the pool lenders receive.\n  struct LiquidationIncentive {\n    uint128 liquidator;\n    uint128 lenders;\n  }\n\n  /// @notice Used as memory access to temporary store account liquidity data.\n  /// @param balance collateral balance of the account.\n  /// @param borrowBalance borrow balance of the account.\n  /// @param price asset price returned by the price feed with 18 decimals.\n  struct AccountLiquidity {\n    uint256 balance;\n    uint256 borrowBalance;\n    uint256 price;\n  }\n}\n\nerror AuditorMismatch();\nerror InsufficientAccountLiquidity();\nerror InsufficientShortfall();\nerror InvalidPrice();\nerror InvalidPriceFeed();\nerror MarketAlreadyListed();\nerror MarketNotListed();\nerror NotMarket();\nerror RemainingDebt();\n\nstruct MarketVars {\n  uint256 price;\n  uint256 baseUnit;\n  uint128 adjustFactor;\n}\n\nstruct LiquidityVars {\n  uint256 totalDebt;\n  uint256 totalCollateral;\n  uint256 adjustedDebt;\n  uint256 adjustedCollateral;\n  uint256 seizeAvailable;\n}"
    }
  ]
}