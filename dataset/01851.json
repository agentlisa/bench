{
  "Title": "Unprotected `sweep` function",
  "Content": "##### Description\nCurrently, any user can call the sweep function and get all tokens from the contract.\nhttps://github.com/cryptoalgebra/Algebra/blob/bddd6487c86e0d6afef39638159dc403a91ba433/src/periphery/contracts/base/PeripheryPayments.sol#L32-L48\n##### Recommendation\nWe recommend adding an admin role for calling this function.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/periphery/contracts/base/PeripheryPayments.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../interfaces/IPeripheryPayments.sol';\nimport '../interfaces/external/IWNativeToken.sol';\n\nimport '../libraries/TransferHelper.sol';\n\nimport './PeripheryImmutableState.sol';\n\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\nabstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState {\n    receive() external payable {\n        require(msg.sender == WNativeToken, 'Not WNativeToken');\n    }\n\n    /// @inheritdoc IPeripheryPayments\n    function unwrapWNativeToken(uint256 amountMinimum, address recipient) external payable override {\n        uint256 balanceWNativeToken = IWNativeToken(WNativeToken).balanceOf(address(this));\n        require(balanceWNativeToken >= amountMinimum, 'Insufficient WNativeToken');\n\n        if (balanceWNativeToken > 0) {\n            IWNativeToken(WNativeToken).withdraw(balanceWNativeToken);\n            TransferHelper.safeTransferNative(recipient, balanceWNativeToken);\n        }\n    }\n\n    /// @inheritdoc IPeripheryPayments\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable override {\n        uint256 balanceToken = IERC20(token).balanceOf(address(this));\n        require(balanceToken >= amountMinimum, 'Insufficient token');\n\n        if (balanceToken > 0) {\n            TransferHelper.safeTransfer(token, recipient, balanceToken);\n        }\n    }\n\n    /// @inheritdoc IPeripheryPayments\n    function refundNativeToken() external payable override {\n        if (address(this).balance > 0) TransferHelper.safeTransferNative(msg.sender, address(this).balance);\n    }\n\n    /// @param token The token to pay\n    /// @param payer The entity that must pay\n    /// @param recipient The entity that will receive payment\n    /// @param value The amount to pay\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == WNativeToken && address(this).balance >= value) {\n            // pay with WNativeToken\n            IWNativeToken(WNativeToken).deposit{value: value}(); // wrap only what is needed to pay\n            IWNativeToken(WNativeToken).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            TransferHelper.safeTransfer(token, recipient, value);\n        } else {\n            // pull payment\n            TransferHelper.safeTransferFrom(token, payer, recipient, value);\n        }\n    }\n}"
    }
  ]
}