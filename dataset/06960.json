{
  "Title": "[01] `DAO.execute` FUNCTION DOES NOT CONSIDER TOKEN'S `transfer` OR `transferFrom` FUNCTION CALL THAT DOES NOT REVERT BUT RETURNS `false` AS A FAILURE",
  "Content": "Some tokens do not revert but return `false` when calling their `transfer` or `transferFrom` functions fail; to cover this scenario, OpenZeppelin's `SafeERC20` library would ensure that the corresponding return data must not be false by executing this [require](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L123) statement. However, for the same scenario, when calling the following `DAO.execute` function, if `_actions[i].to` corresponds to such token and `_actions[i].data`'s function is `transfer` or `transferFrom`, `success` would be set to true after executing `(bool success, bytes memory response) = to.call{value: _actions[i].value}(_actions[i].data)`, and this call would not be considered as a failure. As a result, the DAO can result in an unexpected state; for example, because transferring such tokens to the DAO fail silently, the DAO could falsely think that it has received the corresponding funds and update its accounting system incorrectly.\n\nAs a mitigation, the `DAO.execute` function can be updated to check if `response` returned by executing `to.call` is false when `_actions[i].data`'s function is `transfer` or `transferFrom`. If it is false, the corresponding call should be considered as a failure; whether such failure can be allowed or not can then be determined by the `_allowFailureMap` input.\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/core/dao/DAO.sol#L168-L215\n```solidity\n    function execute(\n        bytes32 _callId,\n        Action[] calldata _actions,\n        uint256 _allowFailureMap\n    )\n        external\n        override\n        auth(EXECUTE_PERMISSION_ID)\n        returns (bytes[] memory execResults, uint256 failureMap)\n    {\n        ...\n        for (uint256 i = 0; i < _actions.length; ) {\n            address to = _actions[i].to;\n            (bool success, bytes memory response) = to.call{value: _actions[i].value}(\n                _actions[i].data\n            );\n\n            if (!success) {\n                // If the call failed and wasn't allowed in allowFailureMap, revert.\n                if (!hasBit(_allowFailureMap, uint8(i))) {\n                    revert ActionFailed(i);\n                }\n\n                // If the call failed, but was allowed in allowFailureMap, store that\n                // this specific action has actually failed.\n                failureMap = flipBit(failureMap, uint8(i));\n            }\n            ...\n        }\n        ...\n    }\n```\n\n**[novaknole20 (Aragon) commented](https://github.com/code-423n4/2023-03-aragon-findings/issues/179#issuecomment-1469609828):**\n > Because it is a generic executor we don't check for this and it is up to the user.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-03-aragon-findings/issues/179#issuecomment-1488498685):**\n> Low Risk\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-aragon",
  "Code": [
    {
      "filename": "contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}"
    },
    {
      "filename": "packages/contracts/src/core/dao/DAO.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nimport {PermissionManager} from \"../permission/PermissionManager.sol\";\nimport {CallbackHandler} from \"../utils/CallbackHandler.sol\";\nimport {hasBit, flipBit} from \"../utils/BitMap.sol\";\nimport {IEIP4824} from \"./IEIP4824.sol\";\nimport {IDAO} from \"./IDAO.sol\";\n\n/// @title DAO\n/// @author Aragon Association - 2021-2023\n/// @notice This contract is the entry point to the Aragon DAO framework and provides our users a simple and easy to use public interface.\n/// @dev Public API of the Aragon DAO framework.\ncontract DAO is\n    IEIP4824,\n    Initializable,\n    IERC1271,\n    ERC165StorageUpgradeable,\n    IDAO,\n    UUPSUpgradeable,\n    PermissionManager,\n    CallbackHandler\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    /// @notice The ID of the permission required to call the `execute` function.\n    bytes32 public constant EXECUTE_PERMISSION_ID = keccak256(\"EXECUTE_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_DAO_PERMISSION_ID = keccak256(\"UPGRADE_DAO_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setMetadata` function.\n    bytes32 public constant SET_METADATA_PERMISSION_ID = keccak256(\"SET_METADATA_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setTrustedForwarder` function.\n    bytes32 public constant SET_TRUSTED_FORWARDER_PERMISSION_ID =\n        keccak256(\"SET_TRUSTED_FORWARDER_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setSignatureValidator` function.\n    bytes32 public constant SET_SIGNATURE_VALIDATOR_PERMISSION_ID =\n        keccak256(\"SET_SIGNATURE_VALIDATOR_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `registerStandardCallback` function.\n    bytes32 public constant REGISTER_STANDARD_CALLBACK_PERMISSION_ID =\n        keccak256(\"REGISTER_STANDARD_CALLBACK_PERMISSION\");\n\n    /// @notice The internal constant storing the maximal action array length.\n    uint256 internal constant MAX_ACTIONS = 256;\n\n    /// @notice The [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\n    IERC1271 public signatureValidator;\n\n    /// @notice The address of the trusted forwarder verifying meta transactions.\n    address private trustedForwarder;\n\n    /// @notice The [EIP-4824](https://eips.ethereum.org/EIPS/eip-4824) DAO uri.\n    string private _daoURI;\n\n    /// @notice Thrown if the action array length is larger than `MAX_ACTIONS`.\n    error TooManyActions();\n\n    /// @notice Thrown if action execution has failed.\n    /// @param index The index of the action in the action array that failed.\n    error ActionFailed(uint256 index);\n\n    /// @notice Thrown if the deposit amount is zero.\n    error ZeroAmount();\n\n    /// @notice Thrown if there is a mismatch between the expected and actually deposited amount of native tokens.\n    /// @param expected The expected native token amount.\n    /// @param actual The actual native token amount deposited.\n    error NativeTokenDepositAmountMismatch(uint256 expected, uint256 actual);\n\n    /// @notice Emitted when a new DAO uri is set.\n    /// @param daoURI The new uri.\n    event NewURI(string daoURI);\n\n    /// @notice Disables the initializers on the implementation contract to prevent it from being left uninitialized.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the DAO by\n    /// - registering the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID\n    /// - setting the trusted forwarder for meta transactions\n    /// - giving the `ROOT_PERMISSION_ID` permission to the initial owner (that should be revoked and transferred to the DAO after setup).\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _metadata IPFS hash that points to all the metadata (logo, description, tags, etc.) of a DAO.\n    /// @param _initialOwner The initial owner of the DAO having the `ROOT_PERMISSION_ID` permission.\n    /// @param _trustedForwarder The trusted forwarder responsible for verifying meta transactions.\n    function initialize(\n        bytes calldata _metadata,\n        address _initialOwner,\n        address _trustedForwarder,\n        string calldata daoURI_\n    ) external initializer {\n        _registerInterface(type(IDAO).interfaceId);\n        _registerInterface(type(IERC1271).interfaceId);\n        _registerInterface(type(IEIP4824).interfaceId);\n        _registerTokenInterfaces();\n\n        _setMetadata(_metadata);\n        _setTrustedForwarder(_trustedForwarder);\n        _setDaoURI(daoURI_);\n        __PermissionManager_init(_initialOwner);\n    }\n\n    /// @inheritdoc PermissionManager\n    function isPermissionRestrictedForAnyAddr(\n        bytes32 _permissionId\n    ) internal pure override returns (bool) {\n        return\n            _permissionId == EXECUTE_PERMISSION_ID ||\n            _permissionId == UPGRADE_DAO_PERMISSION_ID ||\n            _permissionId == SET_METADATA_PERMISSION_ID ||\n            _permissionId == SET_TRUSTED_FORWARDER_PERMISSION_ID ||\n            _permissionId == SET_SIGNATURE_VALIDATOR_PERMISSION_ID ||\n            _permissionId == REGISTER_STANDARD_CALLBACK_PERMISSION_ID;\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeabilty mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_DAO_PERMISSION_ID` permission.\n    function _authorizeUpgrade(address) internal virtual override auth(UPGRADE_DAO_PERMISSION_ID) {}\n\n    /// @inheritdoc IDAO\n    function setTrustedForwarder(\n        address _newTrustedForwarder\n    ) external override auth(SET_TRUSTED_FORWARDER_PERMISSION_ID) {\n        _setTrustedForwarder(_newTrustedForwarder);\n    }\n\n    /// @inheritdoc IDAO\n    function getTrustedForwarder() external view virtual override returns (address) {\n        return trustedForwarder;\n    }\n\n    /// @inheritdoc IDAO\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view override returns (bool) {\n        return isGranted(_where, _who, _permissionId, _data);\n    }\n\n    /// @inheritdoc IDAO\n    function setMetadata(\n        bytes calldata _metadata\n    ) external override auth(SET_METADATA_PERMISSION_ID) {\n        _setMetadata(_metadata);\n    }\n\n    /// @inheritdoc IDAO\n    function execute(\n        bytes32 _callId,\n        Action[] calldata _actions,\n        uint256 _allowFailureMap\n    )\n        external\n        override\n        auth(EXECUTE_PERMISSION_ID)\n        returns (bytes[] memory execResults, uint256 failureMap)\n    {\n        if (_actions.length > MAX_ACTIONS) {\n            revert TooManyActions();\n        }\n\n        execResults = new bytes[](_actions.length);\n\n        for (uint256 i = 0; i < _actions.length; ) {\n            address to = _actions[i].to;\n            (bool success, bytes memory response) = to.call{value: _actions[i].value}(\n                _actions[i].data\n            );\n\n            if (!success) {\n                // If the call failed and wasn't allowed in allowFailureMap, revert.\n                if (!hasBit(_allowFailureMap, uint8(i))) {\n                    revert ActionFailed(i);\n                }\n\n                // If the call failed, but was allowed in allowFailureMap, store that\n                // this specific action has actually failed.\n                failureMap = flipBit(failureMap, uint8(i));\n            }\n\n            execResults[i] = response;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit Executed({\n            actor: msg.sender,\n            callId: _callId,\n            actions: _actions,\n            failureMap: failureMap,\n            execResults: execResults\n        });\n    }\n\n    /// @inheritdoc IDAO\n    function deposit(\n        address _token,\n        uint256 _amount,\n        string calldata _reference\n    ) external payable override {\n        if (_amount == 0) revert ZeroAmount();\n\n        if (_token == address(0)) {\n            if (msg.value != _amount)\n                revert NativeTokenDepositAmountMismatch({expected: _amount, actual: msg.value});\n        } else {\n            if (msg.value != 0)\n                revert NativeTokenDepositAmountMismatch({expected: 0, actual: msg.value});\n\n            IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        emit Deposited(msg.sender, _token, _amount, _reference);\n    }\n\n    /// @inheritdoc IDAO\n    function setSignatureValidator(\n        address _signatureValidator\n    ) external override auth(SET_SIGNATURE_VALIDATOR_PERMISSION_ID) {\n        signatureValidator = IERC1271(_signatureValidator);\n\n        emit SignatureValidatorSet({signatureValidator: _signatureValidator});\n    }\n\n    /// @inheritdoc IDAO\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) external view override(IDAO, IERC1271) returns (bytes4) {\n        if (address(signatureValidator) == address(0)) {\n            // Return the invalid magic number\n            return bytes4(0);\n        }\n        // Forward the call to the set signature validator contract\n        return signatureValidator.isValidSignature(_hash, _signature);\n    }\n\n    /// @notice Emits the `NativeTokenDeposited` event to track native token deposits that weren't made via the deposit method.\n    /// @dev This call is bound by the gas limitations for `send`/`transfer` calls introduced by EIP-2929.\n    /// Gas cost increases in future hard forks might break this function. As an alternative, EIP-2930-type transactions using access lists can be employed.\n    receive() external payable {\n        emit NativeTokenDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Fallback to handle future versions of the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) standard.\n    /// @param _input An alias being equivalent to `msg.data`. This feature of the fallback function was introduced with the [solidity compiler version 0.7.6](https://github.com/ethereum/solidity/releases/tag/v0.7.6)\n    /// @return The magic number registered for the function selector triggering the fallback.\n    fallback(bytes calldata _input) external returns (bytes memory) {\n        bytes4 magicNumber = _handleCallback(msg.sig, _input);\n        return abi.encode(magicNumber);\n    }\n\n    /// @notice Emits the MetadataSet event if new metadata is set.\n    /// @param _metadata Hash of the IPFS metadata object.\n    function _setMetadata(bytes calldata _metadata) internal {\n        emit MetadataSet(_metadata);\n    }\n\n    /// @notice Sets the trusted forwarder on the DAO and emits the associated event.\n    /// @param _trustedForwarder The trusted forwarder address.\n    function _setTrustedForwarder(address _trustedForwarder) internal {\n        trustedForwarder = _trustedForwarder;\n\n        emit TrustedForwarderSet(_trustedForwarder);\n    }\n\n    /// @notice Registers the ERC721/ERC1155 interfaces and callbacks.\n    function _registerTokenInterfaces() private {\n        _registerInterface(type(IERC721ReceiverUpgradeable).interfaceId);\n        _registerInterface(type(IERC1155ReceiverUpgradeable).interfaceId);\n\n        _registerCallback(\n            IERC721ReceiverUpgradeable.onERC721Received.selector,\n            IERC721ReceiverUpgradeable.onERC721Received.selector\n        );\n        _registerCallback(\n            IERC1155ReceiverUpgradeable.onERC1155Received.selector,\n            IERC1155ReceiverUpgradeable.onERC1155Received.selector\n        );\n        _registerCallback(\n            IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector,\n            IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector\n        );\n    }\n\n    /// @inheritdoc IDAO\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external override auth(REGISTER_STANDARD_CALLBACK_PERMISSION_ID) {\n        _registerInterface(_interfaceId);\n        _registerCallback(_callbackSelector, _magicNumber);\n        emit StandardCallbackRegistered(_interfaceId, _callbackSelector, _magicNumber);\n    }\n\n    /// @inheritdoc IEIP4824\n    function daoURI() external view returns (string memory) {\n        return _daoURI;\n    }\n\n    /// @notice Updates the set DAO uri to a new value.\n    /// @param newDaoURI The new DAO uri to be set.\n    function setDaoURI(string calldata newDaoURI) external auth(SET_METADATA_PERMISSION_ID) {\n        _setDaoURI(newDaoURI);\n    }\n\n    /// @notice Sets the new DAO uri and emits the associated event.\n    /// @param daoURI_ The new DAO uri.\n    function _setDaoURI(string calldata daoURI_) internal {\n        _daoURI = daoURI_;\n\n        emit NewURI(daoURI_);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[47] private __gap;\n}"
    }
  ]
}