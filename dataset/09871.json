{
  "Title": "[G-04] `i++` can be wrapped by `unchecked` directory.",
  "Content": "\n`mainnet/MessageProxy.sol` and `mainnet/MessageProxyForMainnet.sol` contains for loop, but `i++` can be wrapped by unchecked directory to decrease the gas cost.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/MessageProxy.sol#L221>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/MessageProxy.sol#L515>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/MessageProxyForMainnet.sol#L118>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/MessageProxyForMainnet.sol#L235>\n\nHere is an example of the modification.\n\n    for (uint256 i = 0; i < messages.length; ) {\n        data = abi.encodePacked(\n            data,\n            bytes32(bytes20(messages[i].sender)),\n            bytes32(bytes20(messages[i].destinationContract)),\n            messages[i].data\n        );\n        unchecked {\n            i++;\n        }\n    }\n\nHere is the comparison of the gas cost at MessageProxyForMainnet.sol\n\n*   Before: 3403300\n*   After: 3388788\n*   Before - After: 14512 (About 0.4% reduction)\n\nIn addition to MessageProxy.sol, here are other opportunities to decrease gas cost by wrapping `i++` by unchecked directory at following files:\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/Linker.sol#L175>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/Linker.sol#L100>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/Linker.sol#L100>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC20.sol#L276>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC721.sol#L76>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC721.sol#L260>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L79>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L275>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L398>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L444>\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/DepositBoxes/DepositBoxERC1155.sol#L459>\n\n***\n\n**[yavrsky (SKALE) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/46#issuecomment-1066996556):**\n > We prefer not to use \"unchecked\" for security reasons, even if it is applicable there. Also only marginal gas improvements.\n> \n> \n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/46#issuecomment-1112616638):**\n > To add #47 which is valued at 62500\n> \n> \n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/46#issuecomment-1118593584):**\n > G-01: Unchecked should save 20 gas per operation * 4 = 80 gas\n> \n> G-02: Valid but ultimately saves gas on the \"bad path\"\n> \n> G-03: Saves 20 gas\n> \n> G-04\n> Saves 20 gas per iteration * 4 = 80\n> \n> 11 * 20 = 220\n> \n> Additional gas saved:\n> 400\n> \n> Total Combined:\n> 62900\n\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-02-skale-contest",
  "Code": [
    {
      "filename": "contracts/MessageProxy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    // solhint-disable-next-line private-vars-leading-underscore\n    mapping(bytes32 => mapping(address => bool)) internal deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }    \n\n    /**\n     * @dev Sets gasLimit to a new value.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     * \n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     * \n     * Requirements:\n     * \n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     * \n     * Requirements:\n     * \n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     * \n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     * \n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n        \n        emit OutgoingMessage(\n            targetChainHash,\n            connectedChains[targetChainHash].outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n\n        connectedChains[targetChainHash].outgoingMessageCounter += 1;\n    }\n\n    /**\n     * @dev Allows `CHAIN_CONNECTOR_ROLE` to remove connected chain from this contract.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted `CHAIN_CONNECTOR_ROLE`.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }    \n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {      \n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n        \n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return address(0);\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                bytes(reason)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                revertData\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                bytes(reason)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                revertData\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether `msg.sender` is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );        \n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes memory data;\n        for (uint256 i = 0; i < messages.length; i++) {\n            data = abi.encodePacked(\n                data,\n                bytes32(bytes20(messages[i].sender)),\n                bytes32(bytes20(messages[i].destinationContract)),\n                messages[i].data\n            );\n        }\n        data = abi.encodePacked(\n            data,\n            bytes32(startingCounter),\n            bytes32(keccak256(abi.encodePacked(fromChainName)))\n        );\n        return keccak256(data);\n    }\n}"
    },
    {
      "filename": "contracts/MessageProxy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    // solhint-disable-next-line private-vars-leading-underscore\n    mapping(bytes32 => mapping(address => bool)) internal deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }    \n\n    /**\n     * @dev Sets gasLimit to a new value.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     * \n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     * \n     * Requirements:\n     * \n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     * \n     * Requirements:\n     * \n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     * \n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     * \n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n        \n        emit OutgoingMessage(\n            targetChainHash,\n            connectedChains[targetChainHash].outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n\n        connectedChains[targetChainHash].outgoingMessageCounter += 1;\n    }\n\n    /**\n     * @dev Allows `CHAIN_CONNECTOR_ROLE` to remove connected chain from this contract.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted `CHAIN_CONNECTOR_ROLE`.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }    \n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {      \n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n        \n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return address(0);\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                bytes(reason)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                revertData\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                bytes(reason)\n            );\n            return address(0);"
    }
  ]
}