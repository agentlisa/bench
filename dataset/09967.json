{
  "Title": "[H-10] `ConvexStakingWrapper.exitShelter()` Will Lock LP Tokens, Preventing Users From Withdrawing",
  "Content": "_Submitted by leastwood_\n\nThe shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. Conversely, the `exitShelter` function will deactivate the shelter and transfer all LP tokens back to the `ConvexStakingWrapper.sol` contract.\n\nUnfortunately, LP tokens aren't restaked in the pool, causing LP tokens to be stuck within the contract. Users will be unable to withdraw their LP tokens as the `withdraw` function attempts to `withdrawAndUnwrap` LP tokens from the staking pool. As a result, this function will always revert due to insufficient staked balance. If other users decide to deposit their LP tokens, then these tokens can be swiped by users who have had their LP tokens locked in the contract.\n\nThis guarantees poor UX for the protocol and will most definitely lead to LP token loss.\n\n### Proof of Concept\n\n[ConvexStakingWrapper.sol#L121-L130](https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L121-L130)\n\n    function exitShelter(uint256[] calldata _pids) external onlyOwner {\n        for(uint256 i = 0; i<_pids.length; i++){\n            IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);\n            IERC20 lpToken = IERC20(\n                pool.poolInfo(_pids[i]).lptoken\n            );\n            amountInShelter[lpToken] = 0;\n            shelter.deactivate(lpToken);\n        }\n    }\n\n[ConvexStakingWrapper.sol#L309-L331](https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L309-L331)\n\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        nonReentrant\n        whenNotInShelter(_pid)\n    {\n        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];\n        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\");\n        require(request.amount >= _amount, \"too much\");\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].amount -= uint192(_amount);\n        if (_amount > 0) {\n            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n            lpToken.safeTransfer(msg.sender, _amount);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.withdraw(msg.sender, pid, _amount);\n        }\n        delete withdrawRequest[_pid][msg.sender];\n        //events\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n### Tools Used\n\nManual code review.<br>\nConfirmation from Taek.\n\n### Recommended Mitigation Steps\n\nConsider re-depositing LP tokens upon calling `exitShelter`. This should ensure the same tokens can be reclaimed by users wishing to exit the `ConvexStakingWrapper.sol` contract.\n\n**[leekt (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/144)**\n\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/144#issuecomment-1101875875):**\n > The warden has identified how through a combination of using the shelter and sending funds back, the funds would actually end up being stuck and non-withdrawable by depositors.\n> \n> I believe that generally speaking this would be a Medium Severity finding as the funds would be stuck if the sponsor were to activate the shelter and then send the tokens back (conditionality).\n> \n> However, the warden has shown that the system of Contract + Shelter is effectively broken, and for this reason I believe the finding is of High Severity.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/ConvexStakingWrapper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./external/ConvexInterfaces.sol\";\nimport \"./interfaces/IConcurRewardClaim.sol\";\nimport \"./interfaces/IShelterClient.sol\";\nimport \"./interfaces/IShelter.sol\";\nimport \"./MasterChef.sol\";\n\ncontract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable, IShelterClient {\n    using SafeERC20 for IERC20;\n\n    struct RewardType {\n        address token;\n        address pool;\n        uint128 integral;\n        uint128 remaining;\n    }\n\n    struct Reward {\n        uint128 integral;\n    }\n\n    //constants/immutables\n    address public constant convexBooster =\n        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv =\n        address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx =\n        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n\n    uint256 public constant CRV_INDEX = 0;\n    uint256 public constant CVX_INDEX = 1;\n    uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000\n    MasterChef public immutable masterChef;\n\n    //convex rewards\n    mapping(uint256 => address) public convexPool;\n    mapping(uint256 => RewardType[]) public rewards;\n    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))\n        public userReward;\n    mapping(uint256 => mapping(address => uint256)) public registeredRewards;\n    mapping(IERC20 => uint256) public amountInShelter;\n\n    //management\n    address public treasury;\n    IShelter public shelter;\n    IConcurRewardClaim public claimContract;\n\n    struct Deposit {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    struct WithdrawRequest {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    mapping(address => uint256) public pids;\n    mapping(uint256 => mapping(address => Deposit)) public deposits;\n    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;\n\n    event Deposited(address indexed _user, uint256 _amount);\n    event Withdrawn(address indexed _user, uint256 _amount);\n\n    modifier whenNotInShelter(uint256 _pid) {\n        IERC20 lpToken = IERC20(\n            IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n        );\n        require(shelter.activated(lpToken) == 0, \"shelter activated\");\n        _;\n    }\n\n    constructor(address _treasury, MasterChef _masterChef) {\n        treasury = _treasury;\n        masterChef = _masterChef;\n    }\n\n    function setShelter(IShelter _shelter) external onlyOwner {\n        require(address(shelter) == address(0), \"shelter cannot be changed\");\n        shelter = _shelter;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function changeTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n    }\n\n    function setRewardPool(address _claimContract) external onlyOwner {\n        claimContract = IConcurRewardClaim(_claimContract);\n    }\n\n    function enterShelter(uint256[] calldata _pids) external onlyOwner {\n        for(uint256 i = 0; i<_pids.length; i++){\n            IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);\n            uint256 amount = pool.balanceOf(address(this));\n            pool.withdrawAndUnwrap(amount, false);\n            IERC20 lpToken = IERC20(\n                pool.poolInfo(_pids[i]).lptoken\n            );\n            amountInShelter[lpToken] = amount;\n            lpToken.safeTransfer(address(shelter), amount);\n            shelter.activate(lpToken);\n        }\n    }\n\n    function exitShelter(uint256[] calldata _pids) external onlyOwner {\n        for(uint256 i = 0; i<_pids.length; i++){\n            IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);\n            IERC20 lpToken = IERC20(\n                pool.poolInfo(_pids[i]).lptoken\n            );\n            amountInShelter[lpToken] = 0;\n            shelter.deactivate(lpToken);\n        }\n    }\n\n    function totalShare(IERC20 _token) external view override returns(uint256) {\n        // this will be zero if shelter is not activated\n        return amountInShelter[_token];\n    }\n\n    function shareOf(IERC20 _token, address _user) external view override returns(uint256) {\n        uint256 pid = pids[address(_token)];\n        return uint256(deposits[pid][_user].amount);\n    }\n\n    /// @notice function to bootstrap the reward pool and extra rewards of convex booster\n    /// @dev should be able to be called more than once\n    /// @param _pid pid of the curve lp. same as convex booster pid\n    function addRewards(uint256 _pid) public {\n        address mainPool = IRewardStaking(convexBooster)\n            .poolInfo(_pid)\n            .crvRewards;\n        if (rewards[_pid].length == 0) {\n            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;\n            convexPool[_pid] = mainPool;\n            rewards[_pid].push(\n                RewardType({\n                    token: crv,\n                    pool: mainPool,\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            rewards[_pid].push(\n                RewardType({\n                    token: cvx,\n                    pool: address(0),\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1\n            registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        for (uint256 i = 0; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            address extraToken = IRewardStaking(extraPool).rewardToken();\n            if (extraToken == cvx) {\n                //no-op for cvx, crv rewards\n                rewards[_pid][CVX_INDEX].pool = extraPool;\n            } else if (registeredRewards[_pid][extraToken] == 0) {\n                //add new token to list\n                rewards[_pid].push(\n                    RewardType({\n                        token: IRewardStaking(extraPool).rewardToken(),\n                        pool: extraPool,\n                        integral: 0,\n                        remaining: 0\n                    })\n                );\n                registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1\n            }\n        }\n    }\n\n    function rewardLength(uint256 _pid) external view returns (uint256) {\n        return rewards[_pid].length;\n    }\n\n    function _getDepositedBalance(uint256 _pid, address _account)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return deposits[_pid][_account].amount;\n    }\n\n    function _getTotalSupply(uint256 _pid)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));\n    }\n\n    function _calcRewardIntegral(\n        uint256 _pid,\n        uint256 _index,\n        address _account,\n        uint256 _balance,\n        uint256 _supply\n    ) internal {\n        RewardType memory reward = rewards[_pid][_index];\n\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.token).balanceOf(address(this));\n        uint256 d_reward = bal - reward.remaining;\n        // send 20 % of cvx / crv reward to treasury\n        if (reward.token == cvx || reward.token == crv) {\n            IERC20(reward.token).transfer(treasury, d_reward / 5);\n            d_reward = (d_reward * 4) / 5;\n        }\n        IERC20(reward.token).transfer(address(claimContract), d_reward);\n\n        if (_supply > 0 && d_reward > 0) {\n            reward.integral =\n                reward.integral +\n                uint128((d_reward * 1e20) / _supply);\n        }\n\n        //update user integrals\n        uint256 userI = userReward[_pid][_index][_account].integral;\n        if (userI < reward.integral) {\n            userReward[_pid][_index][_account].integral = reward.integral;\n            claimContract.pushReward(\n                _account,\n                reward.token,\n                (_balance * (reward.integral - userI)) / 1e20\n            );\n        }\n\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != reward.remaining) {\n            reward.remaining = uint128(bal);\n        }\n\n        rewards[_pid][_index] = reward;\n    }\n\n    function _checkpoint(uint256 _pid, address _account) internal {\n        //if shutdown, no longer checkpoint in case there are problems\n        if (paused()) return;\n\n        uint256 supply = _getTotalSupply(_pid);\n        uint256 depositedBalance = _getDepositedBalance(_pid, _account);\n\n        IRewardStaking(convexPool[_pid]).getReward(address(this), true);\n\n        uint256 rewardCount = rewards[_pid].length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);\n        }\n    }\n\n    /// @notice deposit curve lp token\n    /// @dev should approve curve lp token to this address before calling this function\n    /// @param _pid pid to deposit, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        whenNotPaused\n        whenNotInShelter(_pid)\n        nonReentrant\n    {\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].epoch = currentEpoch();\n        deposits[_pid][msg.sender].amount += uint192(_amount);\n        if (_amount > 0) {\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n\n            lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n            lpToken.safeApprove(convexBooster, _amount);\n            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);\n            lpToken.safeApprove(convexBooster, 0);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.deposit(msg.sender, pid, _amount);\n        }\n\n        emit Deposited(msg.sender, _amount);\n    }\n\n    /// @notice withdraw curve lp token\n    /// @dev should request withdraw before calling this function\n    /// @param _pid pid to withdraw, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        nonReentrant\n        whenNotInShelter(_pid)\n    {\n        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];\n        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\");\n        require(request.amount >= _amount, \"too much\");\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].amount -= uint192(_amount);\n        if (_amount > 0) {\n            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n            lpToken.safeTransfer(msg.sender, _amount);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.withdraw(msg.sender, pid, _amount);\n        }\n        delete withdrawRequest[_pid][msg.sender];\n        //events\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n    /// @notice epoch for voting cycle\n    /// @return returns the epoch in uint64 type\n    function currentEpoch() public view returns(uint64) {\n        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;\n    }\n\n    /// @notice request withdraw to be eligible for withdrawal after currentEpoch\n    /// @dev prior withdrawal request will be overwritten\n    /// @param _pid pid to withdraw\n    /// @param _amount amount to request withdrawal\n    function requestWithdraw(uint256 _pid, uint256 _amount) external {\n        require(_amount <= uint256(deposits[_pid][msg.sender].amount), \"too much\");\n        withdrawRequest[_pid][msg.sender] = WithdrawRequest({\n            epoch : currentEpoch(),\n            amount : uint192(_amount)\n        });\n    }\n}"
    },
    {
      "filename": "contracts/ConvexStakingWrapper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./external/ConvexInterfaces.sol\";\nimport \"./interfaces/IConcurRewardClaim.sol\";\nimport \"./interfaces/IShelterClient.sol\";\nimport \"./interfaces/IShelter.sol\";\nimport \"./MasterChef.sol\";\n\ncontract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable, IShelterClient {\n    using SafeERC20 for IERC20;\n\n    struct RewardType {\n        address token;\n        address pool;\n        uint128 integral;\n        uint128 remaining;\n    }\n\n    struct Reward {\n        uint128 integral;\n    }\n\n    //constants/immutables\n    address public constant convexBooster =\n        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv =\n        address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx =\n        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n\n    uint256 public constant CRV_INDEX = 0;\n    uint256 public constant CVX_INDEX = 1;\n    uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000\n    MasterChef public immutable masterChef;\n\n    //convex rewards\n    mapping(uint256 => address) public convexPool;\n    mapping(uint256 => RewardType[]) public rewards;\n    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))\n        public userReward;\n    mapping(uint256 => mapping(address => uint256)) public registeredRewards;\n    mapping(IERC20 => uint256) public amountInShelter;\n\n    //management\n    address public treasury;\n    IShelter public shelter;\n    IConcurRewardClaim public claimContract;\n\n    struct Deposit {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    struct WithdrawRequest {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    mapping(address => uint256) public pids;\n    mapping(uint256 => mapping(address => Deposit)) public deposits;\n    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;\n\n    event Deposited(address indexed _user, uint256 _amount);\n    event Withdrawn(address indexed _user, uint256 _amount);\n\n    modifier whenNotInShelter(uint256 _pid) {\n        IERC20 lpToken = IERC20(\n            IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n        );\n        require(shelter.activated(lpToken) == 0, \"shelter activated\");\n        _;\n    }\n\n    constructor(address _treasury, MasterChef _masterChef) {\n        treasury = _treasury;\n        masterChef = _masterChef;\n    }\n\n    function setShelter(IShelter _shelter) external onlyOwner {\n        require(address(shelter) == address(0), \"shelter cannot be changed\");\n        shelter = _shelter;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function changeTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n    }\n\n    function setRewardPool(address _claimContract) external onlyOwner {\n        claimContract = IConcurRewardClaim(_claimContract);\n    }\n\n    function enterShelter(uint256[] calldata _pids) external onlyOwner {\n        for(uint256 i = 0; i<_pids.length; i++){\n            IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);\n            uint256 amount = pool.balanceOf(address(this));\n            pool.withdrawAndUnwrap(amount, false);\n            IERC20 lpToken = IERC20(\n                pool.poolInfo(_pids[i]).lptoken\n            );\n            amountInShelter[lpToken] = amount;\n            lpToken.safeTransfer(address(shelter), amount);\n            shelter.activate(lpToken);\n        }\n    }\n\n    function exitShelter(uint256[] calldata _pids) external onlyOwner {\n        for(uint256 i = 0; i<_pids.length; i++){\n            IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);\n            IERC20 lpToken = IERC20(\n                pool.poolInfo(_pids[i]).lptoken\n            );\n            amountInShelter[lpToken] = 0;\n            shelter.deactivate(lpToken);\n        }\n    }\n\n    function totalShare(IERC20 _token) external view override returns(uint256) {\n        // this will be zero if shelter is not activated\n        return amountInShelter[_token];\n    }\n\n    function shareOf(IERC20 _token, address _user) external view override returns(uint256) {\n        uint256 pid = pids[address(_token)];\n        return uint256(deposits[pid][_user].amount);\n    }\n\n    /// @notice function to bootstrap the reward pool and extra rewards of convex booster\n    /// @dev should be able to be called more than once\n    /// @param _pid pid of the curve lp. same as convex booster pid\n    function addRewards(uint256 _pid) public {\n        address mainPool = IRewardStaking(convexBooster)\n            .poolInfo(_pid)\n            .crvRewards;\n        if (rewards[_pid].length == 0) {\n            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;\n            convexPool[_pid] = mainPool;\n            rewards[_pid].push(\n                RewardType({\n                    token: crv,\n                    pool: mainPool,\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            rewards[_pid].push(\n                RewardType({\n                    token: cvx,\n                    pool: address(0),\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1\n            registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        for (uint256 i = 0; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            address extraToken = IRewardStaking(extraPool).rewardToken();\n            if (extraToken == cvx) {\n                //no-op for cvx, crv rewards\n                rewards[_pid][CVX_INDEX].pool = extraPool;\n            } else if (registeredRewards[_pid][extraToken] == 0) {\n                //add new token to list\n                rewards[_pid].push(\n                    RewardType({\n                        token: IRewardStaking(extraPool).rewardToken(),\n                        pool: extraPool,\n                        integral: 0,\n                        remaining: 0\n                    })\n                );\n                registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1\n            }\n        }\n    }\n\n    function rewardLength(uint256 _pid) external view returns (uint256) {\n        return rewards[_pid].length;\n    }\n\n    function _getDepositedBalance(uint256 _pid, address _account)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return deposits[_pid][_account].amount;\n    }\n\n    function _getTotalSupply(uint256 _pid)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));\n    }\n\n    function _calcRewardIntegral(\n        uint256 _pid,\n        uint256 _index,\n        address _account,\n        uint256 _balance,\n        uint256 _supply\n    ) internal {\n        RewardType memory reward = rewards[_pid][_index];\n\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.token).balanceOf(address(this));\n        uint256 d_reward = bal - reward.remaining;\n        // send 20 % of cvx / crv reward to treasury\n        if (reward.token == cvx || reward.token == crv) {\n            IERC20(reward.token).transfer(treasury, d_reward / 5);\n            d_reward = (d_reward * 4) / 5;\n        }\n        IERC20(reward.token).transfer(address(claimContract), d_reward);\n\n        if (_supply > 0 && d_reward > 0) {\n            reward.integral =\n                reward.integral +\n                uint128((d_reward * 1e20) / _supply);\n        }\n\n        //update user integrals\n        uint256 userI = userReward[_pid][_index][_account].integral;\n        if (userI < reward.integral) {\n            userReward[_pid][_index][_account].integral = reward.integral;\n            claimContract.pushReward(\n                _account,\n                reward.token,\n                (_balance * (reward.integral - userI)) / 1e20\n            );\n        }\n\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != reward.remaining) {\n            reward.remaining = uint128(bal);\n        }\n\n        rewards[_pid][_index] = reward;\n    }\n\n    function _checkpoint(uint256 _pid, address _account) internal {\n        //if shutdown, no longer checkpoint in case there are problems\n        if (paused()) return;\n\n        uint256 supply = _getTotalSupply(_pid);\n        uint256 depositedBalance = _getDepositedBalance(_pid, _account);\n\n        IRewardStaking(convexPool[_pid]).getReward(address(this), true);\n\n        uint256 rewardCount = rewards[_pid].length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);\n        }\n    }\n\n    /// @notice deposit curve lp token\n    /// @dev should approve curve lp token to this address before calling this function\n    /// @param _pid pid to deposit, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        whenNotPaused\n        whenNotInShelter(_pid)\n        nonReentrant\n    {\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].epoch = currentEpoch();\n        deposits[_pid][msg.sender].amount += uint192(_amount);\n        if (_amount > 0) {\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n\n            lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n            lpToken.safeApprove(convexBooster, _amount);\n            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);\n            lpToken.safeApprove(convexBooster, 0);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.deposit(msg.sender, pid, _amount);\n        }\n\n        emit Deposited(msg.sender, _amount);\n    }\n\n    /// @notice withdraw curve lp token\n    /// @dev should request withdraw before calling this function\n    /// @param _pid pid to withdraw, uses same pid as convex booster\n    /// @param _amount amount to withdraw\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        nonReentrant\n        whenNotInShelter(_pid)\n    {\n        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];\n        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\");\n        require(request.amount >= _amount, \"too much\");\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].amount -= uint192(_amount);\n        if (_amount > 0) {\n            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n            lpToken.safeTransfer(msg.sender, _amount);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.withdraw(msg.sender, pid, _amount);\n        }\n        delete withdrawRequest[_pid][msg.sender];\n        //events\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n    /// @notice epoch for voting cycle\n    /// @return returns the epoch in uint64 type\n    function currentEpoch() public view returns(uint64) {\n        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;\n    }\n\n    /// @notice request withdraw to be eligible for withdrawal after currentEpoch\n    /// @dev prior withdrawal request will be overwritten\n    /// @param _pid pid to withdraw\n    /// @param _amount amount to request withdrawal\n    function requestWithdraw(uint256 _pid, uint256 _amount) external {\n        require(_amount <= uint256(deposits[_pid][msg.sender].amount), \"too much\");\n        withdrawRequest[_pid][msg.sender] = WithdrawRequest({\n            epoch : currentEpoch(),\n            amount : uint192(_amount)\n        });\n    }\n}"
    }
  ]
}