{
  "Title": "[M-01] EIP-712 signatures can be re-used in private sales",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123-L174\n\n\n# Vulnerability details\n\n## Impact\nWithin a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call `#buyFromPrivateSaleFor` providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.\n\n The problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before. \n\n## Proof of Concept\n\nConsider the following example:\n\n1. Joe the NFT owner sells a NFT to the malicious buyer Rachel via a private sale. \n2. Rachel through this private sale obtains the EIP-712 signature and uses it to purchase a NFT.\n3. Joe the NFT owner purchases back the NFT within two days of the original sale to Rachel.\n4. Joe the NFT owner puts the NFT back on sale.\n5. Rachel, who has the original EIP-712 signature, can re-purchase the NFT by calling `#buyFromPrivateSaleFor` again with the same parameters they provided in the original private sale purchase in step 1.\n\nThe `#buyFromPrivateSaleFor` [function](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123) runs several validation checks before transferring the NFT over to the buyer. The validations are as follows:\n\n1. L#132 - The signature has expired.\n2. L#135 - The deadline is beyond 48 hours from now.\n3. L#143 - The amount argument is greater than msg.value.\n4. L#149 - The msg.value is greater than the amount set.\n5. L#171 - This checks that the EIP-712 signature comes from the NFT seller.\n\nAs you can see, there are no checks that the EIP-712 signature has been used before. If the original NFT seller purchases back the NFT, then they are susceptible to having the original buyer taking back the NFT. This can be problematic if the NFT has risen in value, as the original buyer can utilize the same purchase amount from the first transaction in this malicious transaction.\n\n## Tools Used\nPen and paper\n\n## Recommended Mitigation Steps\nMost contracts utilize nonces when generating EIP-712 signatures to ensure that the contract hasn't been used for. When a nonce is injected into a signature, it makes it impossible for re-use, assuming of course the nonce feature is done correctly.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-foundation-contest",
  "Code": [
    {
      "filename": "contracts/mixins/NFTMarketPrivateSale.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./NFTMarketFees.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nerror NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();\nerror NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();\nerror NFTMarketPrivateSale_Sale_Expired();\nerror NFTMarketPrivateSale_Signature_Verification_Failed();\nerror NFTMarketPrivateSale_Too_Much_Value_Provided();\n\n/**\n * @title Allows owners to offer an NFT for sale to a specific collector.\n * @notice Private sales are authorized by the seller with an EIP-712 signature.\n * @dev Private sale offers must be accepted by the buyer before they expire, typically in 24 hours.\n */\nabstract contract NFTMarketPrivateSale is NFTMarketFees {\n  using AddressUpgradeable for address;\n\n  /// @dev This value was replaced with an immutable version.\n  bytes32 private __gap_was_DOMAIN_SEPARATOR;\n\n  /// @notice The domain used in EIP-712 signatures.\n  /// @dev It is not a constant so that the chainId can be determined dynamically.\n  /// If multiple classes use EIP-712 signatures in the future this can move to a shared file.\n  bytes32 private immutable DOMAIN_SEPARATOR;\n\n  /// @notice The hash of the private sale method signature used for EIP-712 signatures.\n  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =\n    keccak256(\"BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)\");\n  /// @notice The name used in the EIP-712 domain.\n  /// @dev If multiple classes use EIP-712 signatures in the future this can move to the shared constants file.\n  string private constant NAME = \"FNDNFTMarket\";\n\n  /**\n   * @notice Emitted when an NFT is sold in a private sale.\n   * @dev The total amount of this sale is `f8nFee` + `creatorFee` + `ownerRev`.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The ID of the NFT.\n   * @param seller The address of the seller.\n   * @param buyer The address of the buyer.\n   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\n   * @param ownerRev The amount of ETH that was sent to the owner for this sale.\n   */\n  event PrivateSaleFinalized(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address indexed seller,\n    address buyer,\n    uint256 f8nFee,\n    uint256 creatorFee,\n    uint256 ownerRev,\n    uint256 deadline\n  );\n\n  /**\n   * @notice Configures the contract to accept EIP-712 signatures.\n   * @param marketProxyAddress The address of the proxy contract which will be called when accepting a private sale.\n   */\n  constructor(address marketProxyAddress) {\n    if (!marketProxyAddress.isContract()) {\n      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();\n    }\n    uint256 chainId;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      chainId := chainid()\n    }\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n        keccak256(bytes(NAME)),\n        // Incrementing the version can be used to invalidate previously signed messages.\n        keccak256(bytes(\"1\")),\n        chainId,\n        marketProxyAddress\n      )\n    );\n  }\n\n  /**\n   * @notice Buy an NFT from a private sale.\n   * @dev The seller signs a message approving the sale and then the buyer calls this function\n   * with the `msg.value` equal to the agreed upon price.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The ID of the NFT.\n   * @param deadline The timestamp at which the offer to sell will expire.\n   * @param v The v value of the EIP-712 signature.\n   * @param r The r value of the EIP-712 signature.\n   * @param s The s value of the EIP-712 signature.\n   */\n  function buyFromPrivateSale(\n    IERC721 nftContract,\n    uint256 tokenId,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external payable {\n    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);\n  }\n\n  /**\n   * @notice Buy an NFT from a private sale.\n   * @dev The seller signs a message approving the sale and then the buyer calls this function\n   * with the `amount` equal to the agreed upon price.\n   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The ID of the NFT.\n   * @param amount The amount to buy for, if this is more than `msg.value` funds will be\n   * withdrawn from your FETH balance.\n   * @param deadline The timestamp at which the offer to sell will expire.\n   * @param v The v value of the EIP-712 signature.\n   * @param r The r value of the EIP-712 signature.\n   * @param s The s value of the EIP-712 signature.\n   */\n  function buyFromPrivateSaleFor(\n    IERC721 nftContract,\n    uint256 tokenId,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public payable nonReentrant {\n    if (deadline < block.timestamp) {\n      // The signed message from the seller has expired.\n      revert NFTMarketPrivateSale_Sale_Expired();\n    } else if (deadline > block.timestamp + 2 days) {\n      // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure\n      // that transactions do not fail due to a minor timezone error or similar during signing.\n\n      // This prevents malicious actors from requesting signatures that never expire.\n      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();\n    }\n\n    if (amount > msg.value) {\n      // Withdraw additional ETH required from their available FETH balance.\n\n      unchecked {\n        // The if above ensures delta will not underflow\n        uint256 delta = amount - msg.value;\n        feth.marketWithdrawFrom(msg.sender, delta);\n      }\n    } else if (amount < msg.value) {\n      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.\n      revert NFTMarketPrivateSale_Too_Much_Value_Provided();\n    }\n\n    // The seller must have the NFT in their wallet when this function is called,\n    // otherwise the signature verification below will fail.\n    address payable seller = payable(nftContract.ownerOf(tokenId));\n\n    // Scoping this block to avoid a stack too deep error\n    {\n      bytes32 digest = keccak256(\n        abi.encodePacked(\n          \"\\x19\\x01\",\n          DOMAIN_SEPARATOR,\n          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))\n        )\n      );\n\n      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.\n      if (ecrecover(digest, v, r, s) != seller) {\n        revert NFTMarketPrivateSale_Signature_Verification_Failed();\n      }\n    }\n\n    // This should revert if the seller has not given the market contract approval.\n    nftContract.transferFrom(seller, msg.sender, tokenId);\n\n    // Distribute revenue for this sale.\n    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(\n      address(nftContract),\n      tokenId,\n      seller,\n      amount\n    );\n\n    emit PrivateSaleFinalized(\n      address(nftContract),\n      tokenId,\n      seller,\n      msg.sender,\n      f8nFee,\n      creatorFee,\n      ownerRev,\n      deadline\n    );\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}"
    }
  ]
}