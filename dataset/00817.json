{
  "Title": "M-1: Inability to Re-add `oldToken` After Execution of `D3MakerFreeSlot.setNewTokenAndReplace()`",
  "Content": "# Issue M-1: Inability to Re-add `oldToken` After Execution of `D3MakerFreeSlot.setNewTokenAndReplace()` \n\nSource: https://github.com/sherlock-audit/2023-12-dodo-judging/issues/41 \n\n## Found by \n404Notfound, alexzoid, dirk\\_y\n## Summary\nThe `D3MakerFreeSlot` contract's `setNewTokenAndReplace()` function, when executed, permanently removes the `oldToken` information without clearing its index from `state.priceListInfo.tokenIndexMap`. This oversight prevents the re-addition of the `oldToken` using either `setNewTokenAndReplace()` or `setNewToken()` methods.\n \n## Vulnerability Detail\nThe `setNewTokenAndReplace()` function is designed to replace an existing token with a new token in a slot, thereby saving gas. However, this function only removes the `oldToken`'s information from `state.tokenMMInfoMap` and does not clear its index from `state.priceListInfo.tokenIndexMap`. Consequently, the system behaves as if the `oldToken` is still present, preventing its re-addition.\n\n## Impact\nOnce an `oldToken` is replaced, it cannot be re-introduced into the system using standard methods, potentially leading to operational inefficiencies or the need for workaround solutions.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-dodo/blob/main/dodo-v3/contracts/DODOV3MM/D3PoolNoBorrow/D3MakerFreeSlot.sol#L30\n\n## Proof Of Concept\nThe test validates that after executing `setNewTokenAndReplace()`, the `oldToken` cannot be re-added due to its retained index in `state.priceListInfo.tokenIndexMap`. \n\nAdd the function below into `new-dodo-v3/test/DODOV3MM/D3MM/D3MMNoBorrow.t.sol`.\n```solidity\nfunction testAuditReSetToken() public {\n\n    // Setup Phase\n    // Here we initialize the necessary variables and define a common error message for later use.\n\n    bytes memory HAVE_SET_TOKEN_INFO = \"D3MAKER_HAVE_SET_TOKEN_INFO\";\n\n    Types.TokenMMInfo memory tokenMMInfo;\n    uint256 tokenIndex;\n\n    // Creating a new token (token6) for testing purposes.\n    MockERC20 token6 = new MockERC20(\"Token 6\", \"TK6\", 18);\n\n    // Verifying that token2 currently exists at index 2 in the token mapping.\n    (tokenMMInfo, tokenIndex) = d3MakerFreeSlotWithPool.getTokenMMInfoForPool(address(token2));\n    assertEq(tokenIndex, 2);\n\n    // Confirming that the new token (token6) does not yet exist in the mapping.\n    (tokenMMInfo, tokenIndex) = d3MakerFreeSlotWithPool.getTokenMMInfoForPool(address(token6));\n    assertEq(tokenIndex, 0);\n\n    // Replacing token2 with token6\n    MakerTypes.TokenMMInfoWithoutCum memory token6Info = contructToken1MMInfo();\n    vm.prank(maker);\n    d3MakerFreeSlotWithPool.setNewTokenAndReplace(\n        address(token6),\n        true,\n        token6Info.priceInfo,\n        token6Info.amountInfo,\n        token6Info.kAsk,\n        token6Info.kBid,\n        address(token2)\n    );\n\n    // Checking that token6 has taken over the index position of token2.\n    (tokenMMInfo, tokenIndex) = d3MakerFreeSlotWithPool.getTokenMMInfoForPool(address(token6));\n    assertEq(tokenIndex, 2);\n\n    // Ensuring that token2 is no longer present in the pool.\n    (tokenMMInfo, tokenIndex) = d3MakerFreeSlotWithPool.getTokenMMInfoForPool(address(token2));\n    assertEq(tokenIndex, 0);\n\n    // Confirming that token2's original index in the mapping was not cleared during the replacement.\n    assertEq(d3MakerFreeSlotWithPool.getOneTokenOriginIndex(address(token2)), 2);\n\n    // Validation Phase\n    // In this section, we attempt to re-add token2 back to the pool in place of token6, expecting it to fail.\n\n    // Attempt to replace token6 with token2 again, expecting a revert due to token2's index still being present.\n    MakerTypes.TokenMMInfoWithoutCum memory token2Info = contructToken2MMInfo();\n    vm.prank(maker);\n    vm.expectRevert(HAVE_SET_TOKEN_INFO);\n    d3MakerFreeSlotWithPool.setNewTokenAndReplace(\n        address(token2),\n        true,\n        token2Info.priceInfo,\n        token2Info.amountInfo,\n        token2Info.kAsk,\n        token2Info.kBid,\n        address(token6)\n    );\n\n    // Attempt to add token2 as a completely new token, still expecting a revert due to its lingering index.\n    vm.startPrank(maker);\n    vm.expectRevert(HAVE_SET_TOKEN_INFO);\n    d3MakerFreeSlotWithPool.setNewToken(\n        address(token2), \n        true, \n        token2Info.priceInfo, \n        token2Info.amountInfo, \n        token2Info.kAsk, \n        token2Info.kBid\n    );\n}\n```\n\nRun test with `forge test --match-test testAuditReSetToken`. Output example:\n```bash\nRunning 1 test for test/DODOV3MM/D3MM/D3MMNoBorrow.t.sol:D3MMNoBorrowTest\n[PASS] testAuditReSetToken() (gas: 691465)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 12.81ms\n \nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n## Tool used\nVSCode, Foundry\n\n## Recommendation\nThe suggested fix involves modifying the `setNewTokenAndReplace()` function to remove the `oldToken` from `state.priceListInfo.tokenIndexMap`:\n```diff\ndiff --git a/new-dodo-v3/contracts/DODOV3MM/D3PoolNoBorrow/D3MakerFreeSlot.sol b/new-dodo-v3/contracts/DODOV3MM/D3PoolNoBorrow/D3MakerFreeSlot.sol\nindex 43d028d..a11b348 100644\n--- a/new-dodo-v3/contracts/DODOV3MM/D3PoolNoBorrow/D3MakerFreeSlot.sol\n+++ b/new-dodo-v3/contracts/DODOV3MM/D3PoolNoBorrow/D3MakerFreeSlot.sol\n@@ -79,6 +79,9 @@ contract D3MakerFreeSlot is D3Maker {\n         state.priceListInfo.tokenIndexMap[token] = tokenIndex + 1;\n         state.tokenMMInfoMap[token].tokenIndex = uint16(tokenIndex);\n \n+        // Remove oldToken from list\n+        state.priceListInfo.tokenIndexMap[oldToken] = 0;\n+\n         emit SetNewToken(token);\n         emit ReplaceToken(oldToken, token);\n     }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**karanctf** commented:\n>  low \n\n\n\n**nevillehuang**\n\nSee also #19 for alternative described impact\n\n**nevillehuang**\n\nAs confirmed by sponsor, watsons highlighted a valid scenario where re-addition of a removed token is not possible, so this would constitute breaking core contract functionality of readding tokens, so medium severity is appropriate.\n\n**traceurl**\n\nWe have fixed the bug in this PR: \nhttps://github.com/DODOEX/dodo-v3/pull/8\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/130",
  "Code": [
    {
      "filename": "dodo-v3/contracts/DODOV3MM/D3PoolNoBorrow/D3MakerFreeSlot.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"../lib/MakerTypes.sol\";\nimport \"../lib/Errors.sol\";\nimport {D3Maker} from \"D3Pool/D3Maker.sol\";\n\n/// @notice D3MakerFreeSlot is a special type of D3Maker, in which the market maker can set a new token info in an exsiting token slot, which can save gas\ncontract D3MakerFreeSlot is D3Maker {\n\n    event ReplaceToken(address indexed oldToken, address indexed newToken);\n\n    /// @notice maker set a new token info into an occupied slot, replacing old token info\n    /// @param token token's address\n    /// @param priceSet packed price, [mid price(16) | mid price decimal(8) | fee rate(16) | ask up rate (16) | bid down rate(16)]\n    /// @param amountSet describe ask and bid amount and K, [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ] = one slot could contains 4 token info\n    /// @param stableOrNot describe this token is stable or not, true = stable coin\n    /// @param kAsk k of ask curve\n    /// @param kBid k of bid curve\n    /// @param oldToken old token address\n    function setNewTokenAndReplace(\n        address token,\n        bool stableOrNot,\n        uint80 priceSet,\n        uint64 amountSet,\n        uint16 kAsk,\n        uint16 kBid,\n        address oldToken\n    ) external onlyOwner {\n        require(state.priceListInfo.tokenIndexMap[token] == 0, Errors.HAVE_SET_TOKEN_INFO);\n        require(state.priceListInfo.tokenIndexMap[oldToken] != 0, Errors.OLD_TOKEN_NOT_FOUND);\n        // check amount\n        require(kAsk >= 0 && kAsk <= 10000, Errors.K_LIMIT);\n        require(kBid >= 0 && kBid <= 10000, Errors.K_LIMIT);\n\n        for (uint256 i = 0; i < poolTokenlist.length; i++) {\n            if (poolTokenlist[i] == oldToken) {\n                poolTokenlist[i] = token;\n                break;\n            }\n        }\n\n        uint256 tokenIndex = uint256(getOneTokenOriginIndex(oldToken));\n        bool isStable = (tokenIndex % 2 == 0);\n        require(isStable == stableOrNot, Errors.STABLE_TYPE_NOT_MATCH);\n\n        // remove old token info\n        state.tokenMMInfoMap[oldToken].priceInfo = 0;\n        state.tokenMMInfoMap[oldToken].amountInfo = 0;\n        state.tokenMMInfoMap[oldToken].kAsk = 0;\n        state.tokenMMInfoMap[oldToken].kBid = 0;\n        state.tokenMMInfoMap[oldToken].tokenIndex = 0;\n\n        // set new token info\n        state.tokenMMInfoMap[token].priceInfo = priceSet;\n        state.tokenMMInfoMap[token].amountInfo = amountSet;\n        state.tokenMMInfoMap[token].kAsk = kAsk;\n        state.tokenMMInfoMap[token].kBid = kBid;\n        state.heartBeat.lastHeartBeat = block.timestamp;\n\n        // set token price index\n        if (stableOrNot) {\n            // is stable\n            uint256 indexInStable = tokenIndex / 2;\n            uint256 innerSlotIndex = indexInStable % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\n            uint256 slotIndex = indexInStable / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\n            uint256 oldPriceSlot = state.priceListInfo.tokenPriceStable[slotIndex];\n            uint256 newPriceSlot = stickPrice(oldPriceSlot, innerSlotIndex, priceSet);\n            state.priceListInfo.tokenPriceStable[slotIndex] = newPriceSlot;\n        } else {\n            uint256 indexInNStable = (tokenIndex - 1) / 2;\n            uint256 innerSlotIndex = indexInNStable % MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\n            uint256 slotIndex = indexInNStable / MakerTypes.PRICE_QUANTITY_IN_ONE_SLOT;\n            uint256 oldPriceSlot = state.priceListInfo.tokenPriceNS[slotIndex];\n            uint256 newPriceSlot = stickPrice(oldPriceSlot, innerSlotIndex, priceSet);\n            state.priceListInfo.tokenPriceNS[slotIndex] = newPriceSlot;\n        }\n        // to avoid reset the same token, tokenIndexMap record index from 1, but actualIndex = tokenIndex[address] - 1\n        state.priceListInfo.tokenIndexMap[token] = tokenIndex + 1;\n        state.tokenMMInfoMap[token].tokenIndex = uint16(tokenIndex);\n\n        emit SetNewToken(token);\n        emit ReplaceToken(oldToken, token);\n    }\n}"
    }
  ]
}