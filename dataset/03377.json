{
  "Title": "`priceFeeds` can't be changed",
  "Content": "##### Description\n`priceFeeds` can't be changed:\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/oracles/PriceOracle.sol#L56\n##### Recommendation\nWe recommend adding a function for changing `priceFeeds`.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracles/PriceOracle.sol",
      "content": "// SPDX-License-Identifier: BSL-1.1\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\n\nimport {\n    AggregatorV3Interface\n} from \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\n\nimport {AddressProvider} from \"../core/AddressProvider.sol\";\n\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport \"hardhat/console.sol\";\nimport {ACLTrait} from \"../core/ACLTrait.sol\";\n\n /// @title Price Oracle based on Chainlink's price feeds\n /// @notice Works as router and provide cross rates using converting via ETH\n ///\n /// More: https://dev.gearbox.fi/developers/priceoracle\ncontract PriceOracle is ACLTrait, IPriceOracle {\n    using SafeMath for uint256;\n\n    // Address of WETH token\n    address public wethAddress;\n\n    // token => priceFeed\n    mapping(address => address) public priceFeeds;\n\n    // token => decimals multiplier\n    mapping(address => uint256) public decimalsMultipliers;\n    mapping(address => uint256) public decimalsDividers;\n\n    constructor(address addressProvider) ACLTrait(addressProvider) {\n        wethAddress = AddressProvider(addressProvider).getWethToken();\n        decimalsMultipliers[wethAddress] = 1;\n        decimalsDividers[wethAddress] = Constants.WAD;\n    }\n\n    /// @dev Sets price feed if it doesn't exist. If price feed is already set, it changes nothing\n    /// This logic is done to protect Gearbox from priceOracle attack\n    /// when potential attacker can get access to price oracle, change them to fraud ones\n    /// and then liquidate all funds\n    /// @param token Address of token\n    /// @param priceFeed Address of chainlink price feed token => Eth\n    function addPriceFeed(address token, address priceFeed)\n        external\n        override\n        configuratorOnly\n    {\n        // T:[PO-5]\n        if (priceFeeds[token] == address(0)) {\n            priceFeeds[token] = priceFeed;\n            uint256 decimals = ERC20(token).decimals();\n\n            require(\n                decimals <= 18,\n                Errors.PO_TOKENS_WITH_DECIMALS_MORE_18_ISNT_ALLOWED\n            ); // T:[PO-3]\n\n            decimalsMultipliers[token] = 10**(18 - decimals);\n            decimalsDividers[token] = 10**(36 - decimals);\n            emit NewPriceFeed(token, priceFeed); // T:[PO-4]\n        }\n    }\n\n    /// @dev Converts one asset into another using price feed rate. Reverts if price feed doesn't exist\n    /// @param amount Amount to convert\n    /// @param tokenFrom Token address converts from\n    /// @param tokenTo Token address - converts to\n    /// @return Amount converted to tokenTo asset\n    function convert(\n        uint256 amount,\n        address tokenFrom,\n        address tokenTo\n    ) external view override returns (uint256) {\n        return\n            amount\n                .mul(decimalsMultipliers[tokenFrom])\n                .mul(getLastPrice(tokenFrom, tokenTo))\n                .div(decimalsDividers[tokenTo]); // T:[PO-8]\n    }\n\n    /// @dev Gets token rate with 18 decimals. Reverts if priceFeed doesn't exist\n    /// @param tokenFrom Converts from token address\n    /// @param tokenTo Converts to token address\n    /// @return Rate in WAD format\n    function getLastPrice(address tokenFrom, address tokenTo)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (tokenFrom == tokenTo) return Constants.WAD; // T:[PO-1]\n\n        // price = wad * price[ETH] / price[token_to] = wad^2 / price[token_to]\n        if (tokenFrom == wethAddress) {\n            return Constants.WAD.mul(Constants.WAD).div(_getPrice(tokenTo)); // T:[PO-6]\n        }\n\n        // price = wad * price[token_from] / price[ETH] = wad * price[token_from] / wad = price[token_from]\n        if (tokenTo == wethAddress) {\n            return _getPrice(tokenFrom); // T:[PO-6]\n        }\n\n        return Constants.WAD.mul(_getPrice(tokenFrom)).div(_getPrice(tokenTo)); // T:[PO-7]\n    }\n\n    /// @dev Returns rate to ETH in WAD format\n    /// @param token Token converts from\n    function _getPrice(address token) internal view returns (uint256) {\n        require(\n            priceFeeds[token] != address(0),\n            Errors.PO_PRICE_FEED_DOESNT_EXIST\n        ); // T:[PO-9]\n\n        (\n            ,\n            //uint80 roundID,\n            int256 price, //uint startedAt, //uint timeStamp,\n            ,\n            ,\n\n        ) =\n            //uint80 answeredInRound\n            AggregatorV3Interface(priceFeeds[token]).latestRoundData(); // T:[PO-6]\n        return uint256(price);\n    }\n}"
    }
  ]
}