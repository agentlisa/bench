{
  "Title": "[H-05] Exchange rates from Compound are assumed with 18 decimals",
  "Content": "_Submitted by shw_\n\nThe `CTokenMultiOracle` contract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to the [Compound documentation](https://compound.finance/docs/ctokens#exchange-rate), the exchange rate returned from the `exchangeRateCurrent` function is scaled by `1 * 10^(18 - 8 + Underlying Token Decimals)` (and so does `exchangeRateStored`). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens. See [`CTokenMultiOracle.sol` #L110](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/compound/CTokenMultiOracle.sol#L110).\n\nRecommend following the documentation and getting the decimals of the underlying tokens to set the correct decimal of a `Source`.\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/38#issuecomment-899063337):**\n > Thanks a lot for coming up with this. I had looked into how Compound defined the decimals and couldn't find it.\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/38#issuecomment-901201555):**\n > [Fix](https://github.com/yieldprotocol/vault-v2/commit/e9c1ee5532c946e9ab2fc8912039829e190fbb64)\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2021-08-yield-micro-contest-1",
  "Code": [
    {
      "filename": "contracts/oracles/compound/CTokenMultiOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.1;\n\nimport \"../../utils/access/AccessControl.sol\";\nimport \"../../interfaces/vault/IOracle.sol\";\nimport \"../../constants/Constants.sol\";\nimport \"../../math/CastBytes32Bytes6.sol\";\nimport \"./CTokenInterface.sol\";\n\n\ncontract CTokenMultiOracle is IOracle, AccessControl, Constants {\n    using CastBytes32Bytes6 for bytes32;\n\n    uint8 public constant override decimals = 18;   // All prices are converted to 18 decimals\n\n    event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);\n\n    struct Source {\n        address source;\n        uint8 decimals;\n        bool inverse;\n    }\n\n    mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n\n    /**\n     * @notice Set or reset an oracle source and its inverse\n     */\n    function setSource(bytes6 cTokenId, bytes6 underlying, address cToken) external auth {\n        _setSource(cTokenId, underlying, cToken);\n    }\n\n    /**\n     * @notice Set or reset a number of oracle sources and their inverses\n     */\n    function setSources(bytes6[] memory cTokenIds, bytes6[] memory underlyings, address[] memory cTokens) external auth {\n        require(\n            cTokenIds.length == underlyings.length && \n            cTokenIds.length == cTokens.length,\n            \"Mismatched inputs\"\n        );\n        for (uint256 i = 0; i < cTokenIds.length; i++) {\n            _setSource(cTokenIds[i], underlyings[i], cTokens[i]);\n        }\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function peek(bytes32 base, bytes32 quote, uint256 amount)\n        external view virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price;\n        (price, updateTime) = _peek(base.b6(), quote.b6());\n        value = price * amount / 1e18;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function get(bytes32 base, bytes32 quote, uint256 amount)\n        external virtual override\n        returns (uint256 value, uint256 updateTime)\n    {\n        uint256 price;\n        (price, updateTime) = _get(base.b6(), quote.b6());\n        value = price * amount / 1e18;\n    }\n\n    function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {\n        uint256 rawPrice;\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n\n        rawPrice = CTokenInterface(source.source).exchangeRateStored();\n\n        require(rawPrice > 0, \"Compound price is zero\");\n\n        if (source.inverse == true) {\n            price = 10 ** (source.decimals + 18) / uint(rawPrice);\n        } else {\n            price = uint(rawPrice) * 10 ** (18 - source.decimals);\n        }\n\n        updateTime = block.timestamp; // We should get the timestamp\n    }\n\n    function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {\n        uint256 rawPrice;\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n\n        rawPrice = CTokenInterface(source.source).exchangeRateCurrent();\n\n        require(rawPrice > 0, \"Compound price is zero\");\n\n        if (source.inverse == true) {\n            price = 10 ** (source.decimals + 18) / uint(rawPrice);\n        } else {\n            price = uint(rawPrice) * 10 ** (18 - source.decimals);\n        }\n\n        updateTime = block.timestamp; // We should get the timestamp\n    }\n\n    function _setSource(bytes6 cTokenId, bytes6 underlying, address source) internal {\n        uint8 decimals_ = 18; // Does the borrowing rate have 18 decimals?\n        require (decimals_ <= 18, \"Unsupported decimals\");\n        sources[cTokenId][underlying] = Source({\n            source: source,\n            decimals: decimals_,\n            inverse: false\n        });\n        sources[underlying][cTokenId] = Source({\n            source: source,\n            decimals: decimals_,\n            inverse: true\n        });\n        emit SourceSet(cTokenId, underlying, source);\n        emit SourceSet(underlying, cTokenId, source);\n    }\n}"
    }
  ]
}