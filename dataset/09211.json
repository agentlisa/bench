{
  "Title": "[M-01] Alchemist can mint `AlTokens` above their assigned ceiling by calling `lowerHasMinted()`",
  "Content": "_Submitted by tintin, also found by 0xsomeone, AuditsAreUS, and hyh_\n\n[AlchemicTokenV2Base.sol#L111-L124](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L111-L124)<br>\n[AlchemicTokenV2Base.sol#L189-L191](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L189-L191)<br>\n\nAn alchemist / user can mint more than their alloted amount of AlTokens by calling `lowerHasMinted()` before they reach their minting cap.\n\n### Proof of Concept\n\nFunction `mint()` in `AlchemicTokenV2Base.sol`\n\n```solidity\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total > mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n```\n\nNote the require conditional check that `total > mintCeiling[msg.sender]`.\n\nIn the same contract, there is the function `lowerHasMinted()` with the same permission level as mint and is thus callable by the same user as well.\n\n```solidity\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] - amount;\n  }\n```\n\nIt is clear that a user can accumulate an infinite (within supply) amount of AlTokens by calling `lowerHasMinted()` before any action that would make them exceed their minting cap.\n\n### Tools Used\n\nManual review, VScode\n\n### Recommended Mitigation Steps\n\nChange the permissioning on `lowerHasMinted()` to be restricted to a higher permissioned role like `onlySentinel()` , or deprecate this function as I could not find any uses of it throughout the codebase or in tests.\n\n\n**[0xfoobar (Alchemix) confirmed](https://github.com/code-423n4/2022-05-alchemix-findings/issues/166#issuecomment-1140762092)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/166#issuecomment-1145217432):**\n > Great find! This would allow whitelisted account to mint any number of tokens. However, as this pertains to only whitelisted accounts, I think `medium` severity is justified and correct.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-full/AlchemicTokenV2Base.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\n/// @notice Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine\n///         tokens, transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After\n///         this is done, the deployer must revoke their admin role and minter role.\ncontract AlchemicTokenV2Base is ERC20Upgradeable, AccessControlUpgradeable, IERC3156FlashLender, ReentrancyGuardUpgradeable {\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping(address => uint256) public mintCeiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping(address => uint256) public totalMinted;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  function __AlchemicTokenV2Base_init() internal {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total > mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    mintCeiling[minter] = maximum;\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] - amount;\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}"
    },
    {
      "filename": "contracts-full/AlchemicTokenV2Base.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\n/// @notice Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine\n///         tokens, transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After\n///         this is done, the deployer must revoke their admin role and minter role.\ncontract AlchemicTokenV2Base is ERC20Upgradeable, AccessControlUpgradeable, IERC3156FlashLender, ReentrancyGuardUpgradeable {\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping(address => uint256) public mintCeiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping(address => uint256) public totalMinted;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  function __AlchemicTokenV2Base_init() internal {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total > mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    mintCeiling[minter] = maximum;\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] - amount;\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}"
    }
  ]
}