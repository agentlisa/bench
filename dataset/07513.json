{
  "Title": "[M-04] Editions should be checked if they are actually deployed from the legitimate Escher721Factory",
  "Content": "\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/FixedPriceFactory.sol#L29>\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/LPDAFactory.sol#L29>\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/OpenEditionFactory.sol#L29>\n\n### Impact\n\nFor all kinds of sales, the creators create new sales contracts with arbitrary sale data, and the edition is not properly checked.\n\nMalicious creators can create fake contracts that implemented `IEscher721` and fake buyers to get free earnings.\n\n### Proof of Concept\n\nSales contracts can be created by any creator and the sale data is filled with the one provided by the creator.\n\nThe protocol does not validate the `sale.edition` provided by the creator and malicious creators can effectively use their fake contract address that implemented `IEscher721`.\n\nIn the worst case, buyers will not get anything after their payments.\n\n```solidity\n// FixedPriceFactory.sol#L29\nfunction createFixedSale(FixedPrice.Sale calldata _sale) external returns (address clone) {\n  require(IEscher721(_sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\"); //@audit need to check edition is actually from the legimate escher721 factory\n  require(_sale.startTime >= block.timestamp, \"START TIME IN PAST\");\n  require(_sale.finalId > _sale.currentId, \"FINAL ID BEFORE CURRENT\");\n\n  clone = implementation.clone();\n  FixedPrice(clone).initialize(_sale);\n\n  emit NewFixedPriceContract(msg.sender, _sale.edition, clone, _sale);\n}\n\n```\n\nMalicious creators can use a fake contract as an edition to steal funds from users.\n\n### Recommended Mitigation Steps\n\nTrack all the deployed `Escher721` contracts in the `Escher721Factory.sol` and validate the `sale.edition` before creating sales contracts.\n\n**[stevennevins (Escher) disagreed with severity and commented](https://github.com/code-423n4/2022-12-escher-findings/issues/176#issuecomment-1363259855):**\n > Marking as Medium, because funds are not directly at risk but this is a good point for us to keep in mind.\n\n**[berndartmueller (judge) decreased severity to Medium](https://github.com/code-423n4/2022-12-escher-findings/issues/176)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-escher-contest",
  "Code": [
    {
      "filename": "src/minters/FixedPriceFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {FixedPrice} from \"./FixedPrice.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {Clones} from \"openzeppelin/proxy/Clones.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\n\ncontract FixedPriceFactory is Ownable {\n    using Clones for address;\n\n    address payable public feeReceiver;\n    address public immutable implementation;\n\n    event NewFixedPriceContract(\n        address indexed creator,\n        address indexed edition,\n        address indexed saleContract,\n        FixedPrice.Sale saleInfo\n    );\n\n    constructor() Ownable() {\n        implementation = address(new FixedPrice());\n        feeReceiver = payable(msg.sender);\n    }\n\n    /// @notice create a fixed sale proxy contract\n    /// @param _sale the sale info\n    function createFixedSale(FixedPrice.Sale calldata _sale) external returns (address clone) {\n        require(IEscher721(_sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");\n        require(_sale.startTime >= block.timestamp, \"START TIME IN PAST\");\n        require(_sale.finalId > _sale.currentId, \"FINAL ID BEFORE CURRENT\");\n\n        clone = implementation.clone();\n        FixedPrice(clone).initialize(_sale);\n\n        emit NewFixedPriceContract(msg.sender, _sale.edition, clone, _sale);\n    }\n\n    /// @notice set the fee receiver for fixed price editions\n    /// @param fees the address to receive fees\n    function setFeeReceiver(address payable fees) public onlyOwner {\n        feeReceiver = fees;\n    }\n}"
    },
    {
      "filename": "src/minters/LPDAFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {LPDA} from \"./LPDA.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {Clones} from \"openzeppelin/proxy/Clones.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\n\ncontract LPDAFactory is Ownable {\n    using Clones for address;\n\n    address payable public feeReceiver;\n    address public immutable implementation;\n\n    event NewLPDAContract(\n        address indexed _creator,\n        address indexed _edition,\n        address indexed _saleContract,\n        LPDA.Sale _saleInfo\n    );\n\n    constructor() Ownable() {\n        implementation = address(new LPDA());\n        feeReceiver = payable(msg.sender);\n    }\n\n    /// @notice create a fixed sale proxy contract\n    /// @param sale the sale info\n    function createLPDASale(LPDA.Sale calldata sale) external returns (address clone) {\n        require(IEscher721(sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");\n        require(sale.saleReceiver != address(0), \"INVALID SALE RECEIVER\");\n        require(sale.startTime >= block.timestamp, \"INVALID START TIME\");\n        require(sale.endTime > sale.startTime, \"INVALID END TIME\");\n        require(sale.finalId > sale.currentId, \"INVALID FINAL ID\");\n        require(sale.startPrice > 0, \"INVALID START PRICE\");\n        require(sale.dropPerSecond > 0, \"INVALID DROP PER SECOND\");\n\n        clone = implementation.clone();\n        LPDA(clone).initialize(sale);\n\n        emit NewLPDAContract(msg.sender, sale.edition, clone, sale);\n    }\n\n    /// @notice set the fee receiver for fixed price editions\n    /// @param fees the address to receive fees\n    function setFeeReceiver(address payable fees) public onlyOwner {\n        feeReceiver = fees;\n    }\n}"
    },
    {
      "filename": "src/minters/OpenEditionFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {OpenEdition} from \"./OpenEdition.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {Clones} from \"openzeppelin/proxy/Clones.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\n\ncontract OpenEditionFactory is Ownable {\n    using Clones for address;\n\n    address payable public feeReceiver;\n    address public immutable implementation;\n\n    event NewOpenEditionContract(\n        address indexed creator,\n        address indexed edition,\n        address indexed saleContract,\n        OpenEdition.Sale saleInfo\n    );\n\n    constructor() Ownable() {\n        implementation = address(new OpenEdition());\n        feeReceiver = payable(msg.sender);\n    }\n\n    /// @notice create a fixed sale proxy contract\n    /// @param sale the sale info\n    function createOpenEdition(OpenEdition.Sale calldata sale) external returns (address clone) {\n        require(IEscher721(sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");\n        require(sale.startTime >= block.timestamp, \"START TIME IN PAST\");\n        require(sale.endTime > sale.startTime, \"END TIME BEFORE START\");\n\n        clone = implementation.clone();\n        OpenEdition(clone).initialize(sale);\n\n        emit NewOpenEditionContract(msg.sender, sale.edition, clone, sale);\n    }\n\n    /// @notice set the fee receiver for fixed price editions\n    /// @param fees the address to receive fees\n    function setFeeReceiver(address payable fees) public onlyOwner {\n        feeReceiver = fees;\n    }\n}"
    }
  ]
}