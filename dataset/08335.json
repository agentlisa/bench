{
  "Title": "[Gâ€‘06]  `keccak256()` should only need to be called on a specific string literal once",
  "Content": "\nIt should be saved to an immutable variable, and the variable used instead. If the hash is being used as a part of a function selector, the cast to `bytes4` should also only be done once\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/deposit-service/AxelarDepositServiceProxy.sol\n\n9:            return keccak256('axelar-deposit-service');\n\n```\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/AxelarDepositServiceProxy.sol#L9>\n\n```solidity\nFile: contracts/deposit-service/AxelarDepositService.sol\n\n242:          return keccak256('axelar-deposit-service');\n\n```\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/deposit-service/AxelarDepositService.sol#L242>\n\n```solidity\nFile: contracts/gas-service/AxelarGasServiceProxy.sol\n\n10:           return keccak256('axelar-gas-service');\n\n```\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasServiceProxy.sol#L10>\n\n```solidity\nFile: contracts/gas-service/AxelarGasService.sol\n\n181:          return keccak256('axelar-gas-service');\n\n```\n\n<https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/contracts/gas-service/AxelarGasService.sol#L181>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-07-axelar",
  "Code": [
    {
      "filename": "contracts/deposit-service/AxelarDepositServiceProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { Proxy } from '../util/Proxy.sol';\n\ncontract AxelarDepositServiceProxy is Proxy {\n    function contractId() internal pure override returns (bytes32) {\n        return keccak256('axelar-deposit-service');\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable override {}\n}"
    },
    {
      "filename": "contracts/deposit-service/AxelarDepositService.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarDepositService } from '../interfaces/IAxelarDepositService.sol';\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\nimport { IERC20 } from '../interfaces/IERC20.sol';\nimport { IWETH9 } from '../interfaces/IWETH9.sol';\nimport { Upgradable } from '../util/Upgradable.sol';\nimport { DepositBase } from './DepositBase.sol';\nimport { DepositReceiver } from './DepositReceiver.sol';\nimport { ReceiverImplementation } from './ReceiverImplementation.sol';\n\n// This should be owned by the microservice that is paying for gas.\ncontract AxelarDepositService is Upgradable, DepositBase, IAxelarDepositService {\n    address public immutable receiverImplementation;\n\n    constructor(address gateway, string memory wrappedSymbol) DepositBase(gateway, wrappedSymbol) {\n        receiverImplementation = address(new ReceiverImplementation(gateway, wrappedSymbol));\n    }\n\n    // @dev This method is meant to called directly by user to send native token cross-chain\n    function sendNative(string calldata destinationChain, string calldata destinationAddress) external payable {\n        address wrappedTokenAddress = wrappedToken();\n        uint256 amount = msg.value;\n\n        if (amount == 0) revert NothingDeposited();\n\n        IWETH9(wrappedTokenAddress).deposit{ value: amount }();\n        IERC20(wrappedTokenAddress).approve(gateway, amount);\n        IAxelarGateway(gateway).sendToken(destinationChain, destinationAddress, wrappedSymbol(), amount);\n    }\n\n    // @dev Generates a deposit address for sending an ERC20 token cross-chain\n    function addressForTokenDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata tokenSymbol\n    ) external view returns (address) {\n        return\n            _depositAddress(\n                salt,\n                abi.encodeWithSelector(\n                    ReceiverImplementation.receiveAndSendToken.selector,\n                    refundAddress,\n                    destinationChain,\n                    destinationAddress,\n                    tokenSymbol\n                )\n            );\n    }\n\n    // @dev Generates a deposit address for sending native currency cross-chain\n    function addressForNativeDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress\n    ) public view returns (address) {\n        return\n            _depositAddress(\n                salt,\n                abi.encodeWithSelector(\n                    ReceiverImplementation.receiveAndSendNative.selector,\n                    refundAddress,\n                    destinationChain,\n                    destinationAddress\n                )\n            );\n    }\n\n    // @dev Generates a deposit address for unwrapping WETH-like token into native currency\n    function addressForNativeUnwrap(\n        bytes32 salt,\n        address refundAddress,\n        address recipient\n    ) external view returns (address) {\n        return\n            _depositAddress(salt, abi.encodeWithSelector(ReceiverImplementation.receiveAndUnwrapNative.selector, refundAddress, recipient));\n    }\n\n    // @dev Receives ERC20 token from the deposit address and sends it cross-chain\n    function sendTokenDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata tokenSymbol\n    ) external {\n        // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n        new DepositReceiver{ salt: salt }(\n            abi.encodeWithSelector(\n                ReceiverImplementation.receiveAndSendToken.selector,\n                refundAddress,\n                destinationChain,\n                destinationAddress,\n                tokenSymbol\n            )\n        );\n    }\n\n    // @dev Refunds ERC20 tokens from the deposit address if they don't match the intended token\n    // Only refundAddress can refund the token that was intended to go cross-chain (if not sent yet)\n    function refundTokenDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata tokenSymbol,\n        address[] calldata refundTokens\n    ) external {\n        for (uint256 i; i < refundTokens.length; i++) {\n            address gatewayToken = IAxelarGateway(gateway).tokenAddresses(tokenSymbol);\n\n            // Allowing only the refundAddress to refund the intended token\n            if (refundTokens[i] == gatewayToken && msg.sender != refundAddress) continue;\n\n            // Saving to public storage to be accessed by the DepositReceiver\n            refundToken = refundTokens[i];\n            // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n            new DepositReceiver{ salt: salt }(\n                abi.encodeWithSelector(\n                    ReceiverImplementation.receiveAndSendToken.selector,\n                    refundAddress,\n                    destinationChain,\n                    destinationAddress,\n                    tokenSymbol\n                )\n            );\n        }\n\n        refundToken = address(0);\n    }\n\n    // @dev Receives native currency, wraps it into WETH-like token and sends cross-chain\n    function sendNativeDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress\n    ) external {\n        // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n        new DepositReceiver{ salt: salt }(\n            abi.encodeWithSelector(\n                ReceiverImplementation.receiveAndSendNative.selector,\n                refundAddress,\n                destinationChain,\n                destinationAddress\n            )\n        );\n    }\n\n    // @dev Refunds ERC20 tokens from the deposit address after the native deposit was sent\n    // Only refundAddress can refund the native currency intended to go cross-chain (if not sent yet)\n    function refundNativeDeposit(\n        bytes32 salt,\n        address refundAddress,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        address[] calldata refundTokens\n    ) external {\n        // Allowing only the refundAddress to refund the native currency\n        if (addressForNativeDeposit(salt, refundAddress, destinationChain, destinationAddress).balance > 0 && msg.sender != refundAddress)\n            return;\n\n        for (uint256 i; i < refundTokens.length; i++) {\n            refundToken = refundTokens[i];\n            // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n            new DepositReceiver{ salt: salt }(\n                abi.encodeWithSelector(\n                    ReceiverImplementation.receiveAndSendNative.selector,\n                    refundAddress,\n                    destinationChain,\n                    destinationAddress\n                )\n            );\n        }\n\n        refundToken = address(0);\n    }\n\n    // @dev Receives WETH-like token, unwraps and send native currency to the recipient\n    function nativeUnwrap(\n        bytes32 salt,\n        address refundAddress,\n        address payable recipient\n    ) external {\n        // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n        new DepositReceiver{ salt: salt }(\n            abi.encodeWithSelector(ReceiverImplementation.receiveAndUnwrapNative.selector, refundAddress, recipient)\n        );\n    }\n\n    // @dev Refunds ERC20 tokens from the deposit address except WETH-like token\n    // Only refundAddress can refund the WETH-like token intended to be unwrapped (if not yet)\n    function refundNativeUnwrap(\n        bytes32 salt,\n        address refundAddress,\n        address payable recipient,\n        address[] calldata refundTokens\n    ) external {\n        for (uint256 i; i < refundTokens.length; i++) {\n            address wrappedTokenAddress = wrappedToken();\n\n            // Allowing only the refundAddress to refund the WETH-like token\n            if (refundTokens[i] == wrappedTokenAddress && msg.sender != refundAddress) continue;\n\n            refundToken = refundTokens[i];\n            // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\n            new DepositReceiver{ salt: salt }(\n                abi.encodeWithSelector(ReceiverImplementation.receiveAndUnwrapNative.selector, refundAddress, recipient)\n            );\n        }\n\n        refundToken = address(0);\n    }\n\n    function _depositAddress(bytes32 create2Salt, bytes memory delegateData) internal view returns (address) {\n        /* Convert a hash which is bytes32 to an address which is 20-byte long\n        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                bytes1(0xff),\n                                address(this),\n                                create2Salt,\n                                // Encoding delegateData as a constructor param\n                                keccak256(abi.encodePacked(type(DepositReceiver).creationCode, abi.encode(delegateData)))\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function contractId() public pure returns (bytes32) {\n        return keccak256('axelar-deposit-service');\n    }\n}"
    },
    {
      "filename": "contracts/gas-service/AxelarGasServiceProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { Proxy } from '../util/Proxy.sol';\nimport { IUpgradable } from '../interfaces/IUpgradable.sol';\n\ncontract AxelarGasServiceProxy is Proxy {\n    function contractId() internal pure override returns (bytes32) {\n        return keccak256('axelar-gas-service');\n    }\n}"
    },
    {
      "filename": "contracts/gas-service/AxelarGasService.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGasService } from '../interfaces/IAxelarGasService.sol';\nimport { IERC20 } from '../interfaces/IERC20.sol';\nimport '../util/Upgradable.sol';\n\n// This should be owned by the microservice that is paying for gas.\ncontract AxelarGasService is Upgradable, IAxelarGasService {\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external override {\n        _safeTransferFrom(gasToken, msg.sender, gasFeeAmount);\n\n        emit GasPaidForContractCall(\n            sender,\n            destinationChain,\n            destinationAddress,\n            keccak256(payload),\n            gasToken,\n            gasFeeAmount,\n            refundAddress\n        );\n    }\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string memory symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external override {\n        _safeTransferFrom(gasToken, msg.sender, gasFeeAmount);\n\n        emit GasPaidForContractCallWithToken(\n            sender,\n            destinationChain,\n            destinationAddress,\n            keccak256(payload),\n            symbol,\n            amount,\n            gasToken,\n            gasFeeAmount,\n            refundAddress\n        );\n    }\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable override {\n        if (msg.value == 0) revert NothingReceived();\n\n        emit NativeGasPaidForContractCall(sender, destinationChain, destinationAddress, keccak256(payload), msg.value, refundAddress);\n    }\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable override {\n        if (msg.value == 0) revert NothingReceived();\n\n        emit NativeGasPaidForContractCallWithToken(\n            sender,\n            destinationChain,\n            destinationAddress,\n            keccak256(payload),\n            symbol,\n            amount,\n            msg.value,\n            refundAddress\n        );\n    }\n\n    function addGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external override {\n        _safeTransferFrom(gasToken, msg.sender, gasFeeAmount);\n\n        emit GasAdded(txHash, logIndex, gasToken, gasFeeAmount, refundAddress);\n    }\n\n    function addNativeGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable override {\n        if (msg.value == 0) revert NothingReceived();\n\n        emit NativeGasAdded(txHash, logIndex, msg.value, refundAddress);\n    }\n\n    function collectFees(address payable receiver, address[] calldata tokens) external onlyOwner {\n        if (receiver == address(0)) revert InvalidAddress();\n\n        for (uint256 i; i < tokens.length; i++) {\n            address token = tokens[i];\n\n            if (token == address(0)) {\n                uint256 amount = address(this).balance;\n                if (amount > 0) receiver.transfer(amount);\n            } else {\n                uint256 amount = IERC20(token).balanceOf(address(this));\n                if (amount > 0) _safeTransfer(token, receiver, amount);\n            }\n        }\n    }\n\n    function refund(\n        address payable receiver,\n        address token,\n        uint256 amount\n    ) external onlyOwner {\n        if (receiver == address(0)) revert InvalidAddress();\n\n        if (token == address(0)) {\n            receiver.transfer(amount);\n        } else {\n            _safeTransfer(token, receiver, amount);\n        }\n    }\n\n    function _safeTransfer(\n        address tokenAddress,\n        address receiver,\n        uint256 amount\n    ) internal {\n        if (amount == 0) revert NothingReceived();\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert TransferFailed();\n    }\n\n    function _safeTransferFrom(\n        address tokenAddress,\n        address from,\n        uint256 amount\n    ) internal {\n        if (amount == 0) revert NothingReceived();\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = tokenAddress.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert TransferFailed();\n    }\n\n    function contractId() external pure returns (bytes32) {\n        return keccak256('axelar-gas-service');\n    }\n}"
    }
  ]
}