{
  "Title": "USDC is not valued correctly in case of a depeg, which causes a loss of funds",
  "Content": "# USDC is not valued correctly in case of a depeg, which causes a loss of funds\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L170-L214\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L170-L214</a>\n\n\n## Summary\nUSDC is not valued correctly in case of a depeg, which causes a loss of funds.\n## Vulnerability Details\nThe protocol uses a chainlink feed to get prices of a specific token. In this case the token of interest is USDC which is a stable coin. Let us get some context for this issue, from the GMX V2 documentation we can read the following:\n> In case the price of a stablecoin depegs from 1 USD:\nTo ensure that profits for all short positions can always be fully paid out, the contracts will pay out profits in the stablecoin based on a price of 1 USD or the current Chainlink price for the stablecoin, whichever is higher.\nFor swaps using the depegged stablecoin, a spread from 1 USD to the Chainlink price of the stablecoin will apply. If Chainlink Data Stream prices are used then the spread would be from the data stream and may not be to 1 USD.\n\nhttps://gmx-docs.io/docs/trading/v2\n\nFrom the above snippet we now know that gmx will never value USDC below 1$ when closing a short or withdrawing from a position, and that gmx uses the spread from 1 usd to the chainlink price is used. The problem here is that Steadefi does not account for this and will continue to use the chainlink price of usdc in a withdraw and swap when calculating the appropriate slippage amount. Let me demonstrate.\n\n```solidity\nfunction consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);\n\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) revert Errors.FrozenTokenPriceFeed();\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) revert Errors.BrokenTokenPriceFeed();\n\n    return (chainlinkResponse.answer, chainlinkResponse.decimals);\n  }\n``` \nHere consult calls `_getChainlinkResponse(_feed)` which gets the current value of a token, for our purpose this token is USDC. The problem begins because consult is called by `consultIn18Decimals` and this is called by `convertToUsdValue`, this is then called by `calcMinTokensSlippageAmt`. This function decides how much slippage is appropriate given the value of the asset being withdrawn. The problems is, as i showed, it will use chainlink value of USDC and in case of a depeg, it will use the depegged value. But as i have shown from gmx docs, when withdrawing, the value of USDC will always be valued at 1 or higher. So now we are calculating slippage for a usdc value that is depegged when we are withdrawing on gmx with the pegged assets normal value.\n\nFor example\n1. there is a depeg of usdc\n2. usdc chainlink value is $ 0.4\n3. gmx withdraw value is always $1\n\nbecause we use the chainlink value to calc slippage tolerance, we will be using the slippage tolerance for a USDC price of 0.4 when in fact we are valuing USDC at $1 in gmx. The amount of slippage allowed will be very incorrect and in some cases extreme. In case of total depeg, slippage will be almost 99% and users may lose almost all of their funds when trying to withdraw.\n\n## Impact\nIn case of total depeg, slippage will be almost 99% and users may lose almost all of their funds when trying to withdraw.\n## Tools Used\nmanual review\n## Recommendations\nimplement logic specific to stablecoins to handle depegs events. Such would be to always value stable coins at the maximum of the stablecoing proposed value and the chainlink response value. Currently we are only using the chainlink response answer to valuate stable coins like usdc, and as i have explained this is a problem.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXWorker } from \"./GMXWorker.sol\";\n\n/**\n  * @title GMXManager\n  * @author Steadefi\n  * @notice Re-usable library functions for calculations and operations of borrows, repays, swaps\n  * adding and removal of liquidity to yield source\n*/\nlibrary GMXManager {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Calculate if token swap is needed to ensure enough repayment for both tokenA and tokenB\n    * @notice Assume that after swapping one token for the other, there is still enough to repay both tokens\n    * @param self GMXTypes.Store\n    * @param rp GMXTypes.RepayParams\n    * @return swapNeeded boolean if swap is needed\n    * @return tokenFrom address of token to swap from\n    * @return tokenTo address of token to swap to\n    * @return tokenToAmt amount of tokenFrom to swap in token decimals\n  */\n  function calcSwapForRepay(\n    GMXTypes.Store storage self,\n    GMXTypes.RepayParams memory rp\n  ) external view returns (bool, address, address, uint256) {\n    address _tokenFrom;\n    address _tokenTo;\n    uint256 _tokenToAmt;\n\n    if (rp.repayTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      // If more tokenA is needed for repayment\n      _tokenToAmt = rp.repayTokenAAmt - self.tokenA.balanceOf(address(this));\n      _tokenFrom = address(self.tokenB);\n      _tokenTo = address(self.tokenA);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else if (rp.repayTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      // If more tokenB is needed for repayment\n      _tokenToAmt = rp.repayTokenBAmt - self.tokenB.balanceOf(address(this));\n      _tokenFrom = address(self.tokenA);\n      _tokenTo = address(self.tokenB);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else {\n      // If more there is enough to repay both tokens\n      return (false, address(0), address(0), 0);\n    }\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to borrow\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function calcBorrow(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view returns (uint256, uint256) {\n    // Calculate final position value based on deposit value\n    uint256 _positionValue = depositValue * self.leverage / SAFE_MULTIPLIER;\n\n    // Obtain the value to borrow\n    uint256 _borrowValue = _positionValue - depositValue;\n\n    uint256 _tokenADecimals = IERC20Metadata(address(self.tokenA)).decimals();\n    uint256 _tokenBDecimals = IERC20Metadata(address(self.tokenB)).decimals();\n    uint256 _borrowLongTokenAmt;\n    uint256 _borrowShortTokenAmt;\n\n    // If delta is long, borrow all in short token\n    if (self.delta == GMXTypes.Delta.Long) {\n      _borrowShortTokenAmt = _borrowValue * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    // If delta is neutral, borrow appropriate amount in long token to hedge, and the rest in short token\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      // Get token weights in LP, e.g. 50% = 5e17\n      (uint256 _tokenAWeight,) = GMXReader.tokenWeights(self);\n\n      // Get value of long token (typically tokenA)\n      uint256 _longTokenWeightedValue = _tokenAWeight * _positionValue / SAFE_MULTIPLIER;\n\n      // Borrow appropriate amount in long token to hedge\n      _borrowLongTokenAmt = _longTokenWeightedValue * SAFE_MULTIPLIER\n                            / GMXReader.convertToUsdValue(self, address(self.tokenA), 10**(_tokenADecimals))\n                            / (10 ** (18 - _tokenADecimals));\n\n      // Borrow the shortfall value in short token\n      _borrowShortTokenAmt = (_borrowValue - _longTokenWeightedValue) * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    return (_borrowLongTokenAmt, _borrowShortTokenAmt);\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to repay based on token shares ratio being withdrawn\n    * @param self GMXTypes.Store\n    * @param shareRatio Amount of vault token shares relative to total supply in 1e18\n  */\n  function calcRepay(\n    GMXTypes.Store storage self,\n    uint256 shareRatio\n  ) external view returns (uint256, uint256) {\n    (uint256 tokenADebtAmt, uint256 tokenBDebtAmt) = GMXReader.debtAmt(self);\n\n    uint256 _repayTokenAAmt = shareRatio * tokenADebtAmt / SAFE_MULTIPLIER;\n    uint256 _repayTokenBAmt = shareRatio * tokenBDebtAmt / SAFE_MULTIPLIER;\n\n    return (_repayTokenAAmt, _repayTokenBAmt);\n  }\n\n  /**\n    * @notice Calculate minimum market (GM LP) tokens to receive when adding liquidity\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n    * @param slippage Slippage value in 1e4\n    * @return minMarketTokenAmt in 1e18\n  */\n  function calcMinMarketSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 depositValue,\n    uint256 slippage\n  ) external view returns (uint256) {\n    uint256 _lpTokenValue = self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    );\n\n    return depositValue\n      * SAFE_MULTIPLIER\n      / _lpTokenValue\n      * (10000 - slippage) / 10000;\n  }\n\n  /**\n    * @notice Calculate minimum tokens to receive when removing liquidity\n    * @dev minLongToken and minShortToken should be the token which we want to receive\n    * after liquidity withdrawal and swap\n    * @param self GMXTypes.Store\n    * @param lpAmt Amt of lp tokens to remove liquidity in 1e18\n    * @param minLongToken Address of token to receive longToken in\n    * @param minShortToken Address of token to receive shortToken in\n    * @param slippage Slippage value in 1e4\n    * @return minTokenAAmt in 1e18\n    * @return minTokenBAmt in 1e18\n  */\n  function calcMinTokensSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 lpAmt,\n    address minLongToken,\n    address minShortToken,\n    uint256 slippage\n  ) external view returns (uint256, uint256) {\n    uint256 _withdrawValue = lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    (uint256 _tokenAWeight, uint256 _tokenBWeight) = GMXReader.tokenWeights(self);\n\n    uint256 _minLongTokenAmt = _withdrawValue\n      * _tokenAWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minLongToken,\n        10**(IERC20Metadata(minLongToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minLongToken).decimals()));\n\n    uint256 _minShortTokenAmt = _withdrawValue\n      * _tokenBWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minShortToken,\n        10**(IERC20Metadata(minShortToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minShortToken).decimals()));\n\n    return (\n      _minLongTokenAmt * (10000 - slippage) / 10000,\n      _minShortTokenAmt * (10000 - slippage) / 10000\n    );\n  }\n\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice Borrow tokens from lending vaults\n    * @param self GMXTypes.Store\n    * @param borrowTokenAAmt Amount of tokenA to borrow in token decimals\n    * @param borrowTokenBAmt Amount of tokenB to borrow in token decimals\n  */\n  function borrow(\n    GMXTypes.Store storage self,\n    uint256 borrowTokenAAmt,\n    uint256 borrowTokenBAmt\n  ) public {\n    if (borrowTokenAAmt > 0) {\n      self.tokenALendingVault.borrow(borrowTokenAAmt);\n    }\n    if (borrowTokenBAmt > 0) {\n      self.tokenBLendingVault.borrow(borrowTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Repay tokens to lending vaults\n    * @param self GMXTypes.Store\n    * @param repayTokenAAmt Amount of tokenA to repay in token decimals\n    * @param repayTokenBAmt Amount of tokenB to repay in token decimals\n  */\n  function repay(\n    GMXTypes.Store storage self,\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  ) public {\n    if (repayTokenAAmt > 0) {\n      self.tokenALendingVault.repay(repayTokenAAmt);\n    }\n    if (repayTokenBAmt > 0) {\n      self.tokenBLendingVault.repay(repayTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Add liquidity to yield source\n    * @param self GMXTypes.Store\n    * @param alp GMXTypes.AddLiquidityParams\n    * @return depositKey\n  */\n  function addLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.AddLiquidityParams memory alp\n  ) public returns (bytes32) {\n    return GMXWorker.addLiquidity(self, alp);\n  }\n\n  /**\n    * @notice Remove liquidity from yield source\n    * @param self GMXTypes.Store\n    * @param rlp GMXTypes.RemoveLiquidityParams\n    * @return withdrawKey\n  */\n  function removeLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.RemoveLiquidityParams memory rlp\n  ) public returns (bytes32) {\n    return GMXWorker.removeLiquidity(self, rlp);\n  }\n\n  /**\n    * @notice Swap exact amount of tokenIn for as many possible amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountOut in token decimals\n  */\n  function swapExactTokensForTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapExactTokensForTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    * @notice Swap as little posible tokenIn for exact amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountIn in token decimals\n  */\n  function swapTokensForExactTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapTokensForExactTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n}"
    }
  ]
}