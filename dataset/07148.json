{
  "Title": "[G-09] Miscellaneous",
  "Content": "\n### Don't call a function when initializing an immutable variable\nSaves a little bit of deployment gas\n```diff\n-   bytes32 private immutable _counterSlot = _erc1967Slot(\"eip1967.immutableSplitsDriver.storage\");\n+   bytes32 private immutable _counterSlot = bytes32(uint256(keccak256(bytes(\"eip1967.immutableSplitsDriver.storage\"))) - 1);\n```\n### Use a mapping type of a struct directly instead of assigning it to another storage variable\n- [Drips.sol#L246-L254](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L246-L254)\n```diff\n-   mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;\n    for (uint32 cycle = fromCycle; cycle < toCycle; cycle++) {\n-       delete amtDeltas[cycle];\n+       delete state.amtDeltas[cycle];\n    }\n    // The next cycle delta must be relative to the last received cycle, which got zeroed.\n    // In other words the next cycle delta must be an absolute value.\n    if (finalAmtPerCycle != 0) {\n-       amtDeltas[toCycle].thisCycle += finalAmtPerCycle;\n+       state.amtDeltas[toCycle].thisCycle += finalAmtPerCycle;\n    }\n```\n### If statement can be adjusted\nIn the `_receiveDrips()` function you can change the check to `receivedAmt != 0`. Because when fromCycle and toCycle are the same. ReceivedAmt will be 0.\n\n[Drips.sol#L243](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L243) `receiveDrips()` gas saved: 75\n```diff\n        (receivedAmt, receivableCycles, fromCycle, toCycle, finalAmtPerCycle) =\n            _receiveDripsResult(userId, assetId, maxCycles);\n-       if (fromCycle != toCycle) {\n+       if (receivedAmt != 0) {\n```\n\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/81#issuecomment-1431565422):**\n> Best because the savings are high impact and tangible.\n>\n> [G-01]\tMake for loop unchecked\t644\t13\n>\n> Let's say 260 gas (13 * 20)\n> \n> [G-02]\tUse an unchecked block when operands can't underflow/overflow\t688\t7\n>\n> 20 * 7 = 140\n> \n> [G-03]\tWrite element of storage struct to memory when used more than once\t10\t1\n>\n> 100 gas\n> \n> [G-04]\tCall block.timestamp direclty instead of function\t22\t1\n>\n> 16\n> \n> [G-06]\tTransfer erc20 immediately to Dripshub\t57824\t1\n>\n> 5k\n> \n> [G-07]\tTransfer ERC20 immediately to the user\t22112\t1\n>\n> 5k\n> \n> Rest is marginal\n> \n> 10k+\n>\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-drips-protocol-contest",
  "Code": [
    {
      "filename": "src/Drips.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\n/// @notice A drips receiver\nstruct DripsReceiver {\n    /// @notice The user ID.\n    uint256 userId;\n    /// @notice The drips configuration.\n    DripsConfig config;\n}\n\n/// @notice The sender drips history entry, used when squeezing drips.\nstruct DripsHistory {\n    /// @notice Drips receivers list hash, see `_hashDrips`.\n    /// If it's non-zero, `receivers` must be empty.\n    bytes32 dripsHash;\n    /// @notice The drips receivers. If it's non-empty, `dripsHash` must be `0`.\n    /// If it's empty, this history entry will be skipped when squeezing drips\n    /// and `dripsHash` will be used when verifying the drips history validity.\n    /// Skipping a history entry allows cutting gas usage on analysis\n    /// of parts of the drips history which are not worth squeezing.\n    /// The hash of an empty receivers list is `0`, so when the sender updates\n    /// their receivers list to be empty, the new `DripsHistory` entry will have\n    /// both the `dripsHash` equal to `0` and the `receivers` empty making it always skipped.\n    /// This is fine, because there can't be any funds to squeeze from that entry anyway.\n    DripsReceiver[] receivers;\n    /// @notice The time when drips have been configured\n    uint32 updateTime;\n    /// @notice The maximum end time of drips\n    uint32 maxEnd;\n}\n\n/// @notice Describes a drips configuration.\n/// It's constructed from `dripId`, `amtPerSec`, `start` and `duration` as\n/// `dripId << 224 | amtPerSec << 64 | start << 32 | duration`.\n/// `dripId` is an arbitrary number used to identify a drip.\n/// It's a part of the configuration but the protocol doesn't use it.\n/// `amtPerSec` is the amount per second being dripped. Must never be zero.\n/// It must have additional `Drips._AMT_PER_SEC_EXTRA_DECIMALS` decimals and can have fractions.\n/// To achieve that its value must be multiplied by `Drips._AMT_PER_SEC_MULTIPLIER`.\n/// `start` is the timestamp when dripping should start.\n/// If zero, use the timestamp when drips are configured.\n/// `duration` is the duration of dripping.\n/// If zero, drip until balance runs out.\ntype DripsConfig is uint256;\n\nusing DripsConfigImpl for DripsConfig global;\n\nlibrary DripsConfigImpl {\n    /// @notice Create a new DripsConfig.\n    /// @param dripId_ An arbitrary number used to identify a drip.\n    /// It's a part of the configuration but the protocol doesn't use it.\n    /// @param amtPerSec_ The amount per second being dripped. Must never be zero.\n    /// It must have additional `Drips._AMT_PER_SEC_EXTRA_DECIMALS` decimals and can have fractions.\n    /// To achieve that the passed value must be multiplied by `Drips._AMT_PER_SEC_MULTIPLIER`.\n    /// @param start_ The timestamp when dripping should start.\n    /// If zero, use the timestamp when drips are configured.\n    /// @param duration_ The duration of dripping.\n    /// If zero, drip until balance runs out.\n    function create(uint32 dripId_, uint160 amtPerSec_, uint32 start_, uint32 duration_)\n        internal\n        pure\n        returns (DripsConfig)\n    {\n        uint256 config = dripId_;\n        config = (config << 160) | amtPerSec_;\n        config = (config << 32) | start_;\n        config = (config << 32) | duration_;\n        return DripsConfig.wrap(config);\n    }\n\n    /// @notice Extracts dripId from a `DripsConfig`\n    function dripId(DripsConfig config) internal pure returns (uint32) {\n        return uint32(DripsConfig.unwrap(config) >> 224);\n    }\n\n    /// @notice Extracts amtPerSec from a `DripsConfig`\n    function amtPerSec(DripsConfig config) internal pure returns (uint160) {\n        return uint160(DripsConfig.unwrap(config) >> 64);\n    }\n\n    /// @notice Extracts start from a `DripsConfig`\n    function start(DripsConfig config) internal pure returns (uint32) {\n        return uint32(DripsConfig.unwrap(config) >> 32);\n    }\n\n    /// @notice Extracts duration from a `DripsConfig`\n    function duration(DripsConfig config) internal pure returns (uint32) {\n        return uint32(DripsConfig.unwrap(config));\n    }\n\n    /// @notice Compares two `DripsConfig`s.\n    /// First compares their `amtPerSec`s, then their `start`s and then their `duration`s.\n    function lt(DripsConfig config, DripsConfig otherConfig) internal pure returns (bool) {\n        return DripsConfig.unwrap(config) < DripsConfig.unwrap(otherConfig);\n    }\n}\n\n/// @notice Drips can keep track of at most `type(int128).max`\n/// which is `2 ^ 127 - 1` units of each asset.\n/// It's up to the caller to guarantee that this limit is never exceeded,\n/// failing to do so may result in a total protocol collapse.\nabstract contract Drips {\n    /// @notice Maximum number of drips receivers of a single user.\n    /// Limits cost of changes in drips configuration.\n    uint256 internal constant _MAX_DRIPS_RECEIVERS = 100;\n    /// @notice The additional decimals for all amtPerSec values.\n    uint8 internal constant _AMT_PER_SEC_EXTRA_DECIMALS = 9;\n    /// @notice The multiplier for all amtPerSec values. It's `10 ** _AMT_PER_SEC_EXTRA_DECIMALS`.\n    uint256 internal constant _AMT_PER_SEC_MULTIPLIER = 1_000_000_000;\n    /// @notice The total amount the contract can keep track of each asset.\n    uint256 internal constant _MAX_TOTAL_DRIPS_BALANCE = uint128(type(int128).max);\n    /// @notice On every timestamp `T`, which is a multiple of `cycleSecs`, the receivers\n    /// gain access to drips received during `T - cycleSecs` to `T - 1`.\n    /// Always higher than 1.\n    // slither-disable-next-line naming-convention\n    uint32 internal immutable _cycleSecs;\n    /// @notice The storage slot holding a single `DripsStorage` structure.\n    bytes32 private immutable _dripsStorageSlot;\n\n    /// @notice Emitted when the drips configuration of a user is updated.\n    /// @param userId The user ID.\n    /// @param assetId The used asset ID\n    /// @param receiversHash The drips receivers list hash\n    /// @param dripsHistoryHash The drips history hash which was valid right before the update.\n    /// @param balance The new drips balance. These funds will be dripped to the receivers.\n    /// @param maxEnd The maximum end time of drips, when funds run out.\n    /// If funds run out after the timestamp `type(uint32).max`, it's set to `type(uint32).max`.\n    /// If the balance is 0 or there are no receivers, it's set to the current timestamp.\n    event DripsSet(\n        uint256 indexed userId,\n        uint256 indexed assetId,\n        bytes32 indexed receiversHash,\n        bytes32 dripsHistoryHash,\n        uint128 balance,\n        uint32 maxEnd\n    );\n\n    /// @notice Emitted when a user is seen in a drips receivers list.\n    /// @param receiversHash The drips receivers list hash\n    /// @param userId The user ID.\n    /// @param config The drips configuration.\n    event DripsReceiverSeen(\n        bytes32 indexed receiversHash, uint256 indexed userId, DripsConfig config\n    );\n\n    /// @notice Emitted when drips are received.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @param amt The received amount.\n    /// @param receivableCycles The number of cycles which still can be received.\n    event ReceivedDrips(\n        uint256 indexed userId, uint256 indexed assetId, uint128 amt, uint32 receivableCycles\n    );\n\n    /// @notice Emitted when drips are squeezed.\n    /// @param userId The squeezing user ID.\n    /// @param assetId The used asset ID.\n    /// @param senderId The ID of the user sending drips which are squeezed.\n    /// @param amt The squeezed amount.\n    /// @param dripsHistoryHashes The history hashes of all squeezed drips history entries.\n    /// Each history hash matches `dripsHistoryHash` emitted in its `DripsSet`\n    /// when the squeezed drips configuration was set.\n    /// Sorted in the oldest drips configuration to the newest.\n    event SqueezedDrips(\n        uint256 indexed userId,\n        uint256 indexed assetId,\n        uint256 indexed senderId,\n        uint128 amt,\n        bytes32[] dripsHistoryHashes\n    );\n\n    struct DripsStorage {\n        /// @notice User drips states.\n        /// The keys are the asset ID and the user ID.\n        mapping(uint256 => mapping(uint256 => DripsState)) states;\n    }\n\n    struct DripsState {\n        /// @notice The drips history hash, see `_hashDripsHistory`.\n        bytes32 dripsHistoryHash;\n        /// @notice The next squeezable timestamps. The key is the sender's user ID.\n        /// Each `N`th element of the array is the next squeezable timestamp\n        /// of the `N`th sender's drips configuration in effect in the current cycle.\n        mapping(uint256 => uint32[2 ** 32]) nextSqueezed;\n        /// @notice The drips receivers list hash, see `_hashDrips`.\n        bytes32 dripsHash;\n        /// @notice The next cycle to be received\n        uint32 nextReceivableCycle;\n        /// @notice The time when drips have been configured for the last time\n        uint32 updateTime;\n        /// @notice The maximum end time of drips\n        uint32 maxEnd;\n        /// @notice The balance when drips have been configured for the last time\n        uint128 balance;\n        /// @notice The number of drips configurations seen in the current cycle\n        uint32 currCycleConfigs;\n        /// @notice The changes of received amounts on specific cycle.\n        /// The keys are cycles, each cycle `C` becomes receivable on timestamp `C * cycleSecs`.\n        /// Values for cycles before `nextReceivableCycle` are guaranteed to be zeroed.\n        /// This means that the value of `amtDeltas[nextReceivableCycle].thisCycle` is always\n        /// relative to 0 or in other words it's an absolute value independent from other cycles.\n        mapping(uint32 => AmtDelta) amtDeltas;\n    }\n\n    struct AmtDelta {\n        /// @notice Amount delta applied on this cycle\n        int128 thisCycle;\n        /// @notice Amount delta applied on the next cycle\n        int128 nextCycle;\n    }\n\n    /// @param cycleSecs The length of cycleSecs to be used in the contract instance.\n    /// Low value makes funds more available by shortening the average time of funds being frozen\n    /// between being taken from the users' drips balances and being receivable by their receivers.\n    /// High value makes receiving cheaper by making it process less cycles for a given time range.\n    /// Must be higher than 1.\n    /// @param dripsStorageSlot The storage slot to holding a single `DripsStorage` structure.\n    constructor(uint32 cycleSecs, bytes32 dripsStorageSlot) {\n        require(cycleSecs > 1, \"Cycle length too low\");\n        _cycleSecs = cycleSecs;\n        _dripsStorageSlot = dripsStorageSlot;\n    }\n\n    /// @notice Receive drips from unreceived cycles of the user.\n    /// Received drips cycles won't need to be analyzed ever again.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @param maxCycles The maximum number of received drips cycles.\n    /// If too low, receiving will be cheap, but may not cover many cycles.\n    /// If too high, receiving may become too expensive to fit in a single transaction.\n    /// @return receivedAmt The received amount\n    function _receiveDrips(uint256 userId, uint256 assetId, uint32 maxCycles)\n        internal\n        returns (uint128 receivedAmt)\n    {\n        uint32 receivableCycles;\n        uint32 fromCycle;\n        uint32 toCycle;\n        int128 finalAmtPerCycle;\n        (receivedAmt, receivableCycles, fromCycle, toCycle, finalAmtPerCycle) =\n            _receiveDripsResult(userId, assetId, maxCycles);\n        if (fromCycle != toCycle) {\n            DripsState storage state = _dripsStorage().states[assetId][userId];\n            state.nextReceivableCycle = toCycle;\n            mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;\n            for (uint32 cycle = fromCycle; cycle < toCycle; cycle++) {\n                delete amtDeltas[cycle];\n            }\n            // The next cycle delta must be relative to the last received cycle, which got zeroed.\n            // In other words the next cycle delta must be an absolute value.\n            if (finalAmtPerCycle != 0) {\n                amtDeltas[toCycle].thisCycle += finalAmtPerCycle;\n            }\n        }\n        emit ReceivedDrips(userId, assetId, receivedAmt, receivableCycles);\n    }\n\n    /// @notice Calculate effects of calling `_receiveDrips` with the given parameters.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @param maxCycles The maximum number of received drips cycles.\n    /// If too low, receiving will be cheap, but may not cover many cycles.\n    /// If too high, receiving may become too expensive to fit in a single transaction.\n    /// @return receivedAmt The amount which would be received\n    /// @return receivableCycles The number of cycles which would still be receivable after the call\n    /// @return fromCycle The cycle from which funds would be received\n    /// @return toCycle The cycle to which funds would be received\n    /// @return amtPerCycle The amount per cycle when `toCycle` starts.\n    function _receiveDripsResult(uint256 userId, uint256 assetId, uint32 maxCycles)\n        internal\n        view\n        returns (\n            uint128 receivedAmt,\n            uint32 receivableCycles,\n            uint32 fromCycle,\n            uint32 toCycle,\n            int128 amtPerCycle\n        )\n    {\n        (fromCycle, toCycle) = _receivableDripsCyclesRange(userId, assetId);\n        if (toCycle - fromCycle > maxCycles) {\n            receivableCycles = toCycle - fromCycle - maxCycles;\n            toCycle -= receivableCycles;\n        }\n        DripsState storage state = _dripsStorage().states[assetId][userId];\n        for (uint32 cycle = fromCycle; cycle < toCycle; cycle++) {\n            amtPerCycle += state.amtDeltas[cycle].thisCycle;\n            receivedAmt += uint128(amtPerCycle);\n            amtPerCycle += state.amtDeltas[cycle].nextCycle;\n        }\n    }\n\n    /// @notice Counts cycles from which drips can be received.\n    /// This function can be used to detect that there are\n    /// too many cycles to analyze in a single transaction.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @return cycles The number of cycles which can be flushed\n    function _receivableDripsCycles(uint256 userId, uint256 assetId)\n        internal\n        view\n        returns (uint32 cycles)\n    {\n        (uint32 fromCycle, uint32 toCycle) = _receivableDripsCyclesRange(userId, assetId);\n        return toCycle - fromCycle;\n    }\n\n    /// @notice Calculates the cycles range from which drips can be received.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @return fromCycle The cycle from which funds can be received\n    /// @return toCycle The cycle to which funds can be received\n    function _receivableDripsCyclesRange(uint256 userId, uint256 assetId)\n        private\n        view\n        returns (uint32 fromCycle, uint32 toCycle)\n    {\n        fromCycle = _dripsStorage().states[assetId][userId].nextReceivableCycle;\n        toCycle = _cycleOf(_currTimestamp());\n        // slither-disable-next-line timestamp\n        if (fromCycle == 0 || toCycle < fromCycle) {\n            toCycle = fromCycle;\n        }\n    }\n\n    /// @notice Receive drips from the currently running cycle from a single sender.\n    /// It doesn't receive drips from the previous, finished cycles, to do that use `_receiveDrips`.\n    /// Squeezed funds won't be received in the next calls to `_squeezeDrips` or `_receiveDrips`.\n    /// Only funds dripped before `block.timestamp` can be squeezed.\n    /// @param userId The ID of the user receiving drips to squeeze funds for.\n    /// @param assetId The used asset ID.\n    /// @param senderId The ID of the user sending drips to squeeze funds from.\n    /// @param historyHash The sender's history hash which was valid right before\n    /// they set up the sequence of configurations described by `dripsHistory`.\n    /// @param dripsHistory The sequence of the sender's drips configurations.\n    /// It can start at an arbitrary past configuration, but must describe all the configurations\n    /// which have been used since then including the current one, in the chronological order.\n    /// Only drips described by `dripsHistory` will be squeezed.\n    /// If `dripsHistory` entries have no receivers, they won't be squeezed.\n    /// @return amt The squeezed amount.\n    function _squeezeDrips(\n        uint256 userId,\n        uint256 assetId,\n        uint256 senderId,\n        bytes32 historyHash,\n        DripsHistory[] memory dripsHistory\n    ) internal returns (uint128 amt) {\n        uint256 squeezedNum;\n        uint256[] memory squeezedRevIdxs;\n        bytes32[] memory historyHashes;\n        uint256 currCycleConfigs;\n        (amt, squeezedNum, squeezedRevIdxs, historyHashes, currCycleConfigs) =\n            _squeezeDripsResult(userId, assetId, senderId, historyHash, dripsHistory);\n        bytes32[] memory squeezedHistoryHashes = new bytes32[](squeezedNum);\n        DripsState storage state = _dripsStorage().states[assetId][userId];\n        uint32[2 ** 32] storage nextSqueezed = state.nextSqueezed[senderId];\n        for (uint256 i = 0; i < squeezedNum; i++) {\n            // `squeezedRevIdxs` are sorted from the newest configuration to the oldest,\n            // but we need to consume them from the oldest to the newest.\n            uint256 revIdx = squeezedRevIdxs[squeezedNum - i - 1];\n            squeezedHistoryHashes[i] = historyHashes[historyHashes.length - revIdx];\n            nextSqueezed[currCycleConfigs - revIdx] = _currTimestamp();\n        }\n        uint32 cycleStart = _currCycleStart();\n        _addDeltaRange(state, cycleStart, cycleStart + 1, -int256(amt * _AMT_PER_SEC_MULTIPLIER));\n        emit SqueezedDrips(userId, assetId, senderId, amt, squeezedHistoryHashes);\n    }\n\n    /// @notice Calculate effects of calling `_squeezeDrips` with the given parameters.\n    /// See its documentation for more details.\n    /// @param userId The ID of the user receiving drips to squeeze funds for.\n    /// @param assetId The used asset ID.\n    /// @param senderId The ID of the user sending drips to squeeze funds from.\n    /// @param historyHash The sender's history hash which was valid right before `dripsHistory`.\n    /// @param dripsHistory The sequence of the sender's drips configurations.\n    /// @return amt The squeezed amount.\n    /// @return squeezedNum The number of squeezed history entries.\n    /// @return squeezedRevIdxs The indexes of the squeezed history entries.\n    /// The indexes are reversed, meaning that to get the actual index in an array,\n    /// they must counted from the end of arrays, as in `arrayLength - squeezedRevIdxs[i]`.\n    /// These indexes can be safely used to access `dripsHistory`, `historyHashes`\n    /// and `nextSqueezed` regardless of their lengths.\n    /// `squeezeRevIdxs` is sorted ascending, from pointing at the most recent entry to the oldest.\n    /// @return historyHashes The history hashes valid for squeezing each of `dripsHistory` entries.\n    /// In other words history hashes which had been valid right before each drips\n    /// configuration was set, matching `dripsHistoryHash` emitted in its `DripsSet`.\n    /// The first item is always equal to `historyHash`.\n    /// @return currCycleConfigs The number of the sender's\n    /// drips configurations which have been seen in the current cycle.\n    /// This is also the number of used entries in each of the sender's `nextSqueezed` arrays.\n    function _squeezeDripsResult(\n        uint256 userId,\n        uint256 assetId,\n        uint256 senderId,\n        bytes32 historyHash,\n        DripsHistory[] memory dripsHistory\n    )\n        internal\n        view\n        returns (\n            uint128 amt,\n            uint256 squeezedNum,\n            uint256[] memory squeezedRevIdxs,\n            bytes32[] memory historyHashes,\n            uint256 currCycleConfigs\n        )\n    {\n        {\n            DripsState storage sender = _dripsStorage().states[assetId][senderId];\n            historyHashes = _verifyDripsHistory(historyHash, dripsHistory, sender.dripsHistoryHash);\n            // If the last update was not in the current cycle,\n            // there's only the single latest history entry to squeeze in the current cycle.\n            currCycleConfigs = 1;\n            // slither-disable-next-line timestamp\n            if (sender.updateTime >= _currCycleStart()) currCycleConfigs = sender.currCycleConfigs;\n        }\n        squeezedRevIdxs = new uint256[](dripsHistory.length);\n        uint32[2 ** 32] storage nextSqueezed =\n            _dripsStorage().states[assetId][userId].nextSqueezed[senderId];\n        uint32 squeezeEndCap = _currTimestamp();\n        for (uint256 i = 1; i <= dripsHistory.length && i <= currCycleConfigs; i++) {\n            DripsHistory memory drips = dripsHistory[dripsHistory.length - i];\n            if (drips.receivers.length != 0) {\n                uint32 squeezeStartCap = nextSqueezed[currCycleConfigs - i];\n                if (squeezeStartCap < _currCycleStart()) squeezeStartCap = _currCycleStart();\n                if (squeezeStartCap < squeezeEndCap) {\n                    squeezedRevIdxs[squeezedNum++] = i;\n                    amt += _squeezedAmt(userId, drips, squeezeStartCap, squeezeEndCap);\n                }\n            }\n            squeezeEndCap = drips.updateTime;\n        }\n    }\n\n    /// @notice Verify a drips history and revert if it's invalid.\n    /// @param historyHash The user's history hash which was valid right before `dripsHistory`.\n    /// @param dripsHistory The sequence of the user's drips configurations.\n    /// @param finalHistoryHash The history hash at the end of `dripsHistory`.\n    /// @return historyHashes The history hashes valid for squeezing each of `dripsHistory` entries.\n    /// In other words history hashes which had been valid right before each drips\n    /// configuration was set, matching `dripsHistoryHash`es emitted in `DripsSet`.\n    /// The first item is always equal to `historyHash` and `finalHistoryHash` is never included.\n    function _verifyDripsHistory(\n        bytes32 historyHash,\n        DripsHistory[] memory dripsHistory,\n        bytes32 finalHistoryHash\n    ) private pure returns (bytes32[] memory historyHashes) {\n        historyHashes = new bytes32[](dripsHistory.length);\n        for (uint256 i = 0; i < dripsHistory.length; i++) {\n            DripsHistory memory drips = dripsHistory[i];\n            bytes32 dripsHash = drips.dripsHash;\n            if (drips.receivers.length != 0) {\n                require(dripsHash == 0, \"Drips history entry with hash and receivers\");\n                dripsHash = _hashDrips(drips.receivers);\n            }\n            historyHashes[i] = historyHash;\n            historyHash = _hashDripsHistory(historyHash, dripsHash, drips.updateTime, drips.maxEnd);\n        }\n        // slither-disable-next-line incorrect-equality,timestamp\n        require(historyHash == finalHistoryHash, \"Invalid drips history\");\n    }\n\n    /// @notice Calculate the amount squeezable by a user from a single drips history entry.\n    /// @param userId The ID of the user to squeeze drips for.\n    /// @param dripsHistory The squeezed history entry.\n    /// @param squeezeStartCap The squeezed time range start.\n    /// @param squeezeEndCap The squeezed time range end.\n    /// @return squeezedAmt The squeezed amount.\n    function _squeezedAmt(\n        uint256 userId,\n        DripsHistory memory dripsHistory,\n        uint32 squeezeStartCap,\n        uint32 squeezeEndCap\n    ) private view returns (uint128 squeezedAmt) {\n        DripsReceiver[] memory receivers = dripsHistory.receivers;\n        // Binary search for the `idx` of the first occurrence of `userId`\n        uint256 idx = 0;\n        for (uint256 idxCap = receivers.length; idx < idxCap;) {\n            uint256 idxMid = (idx + idxCap) / 2;\n            if (receivers[idxMid].userId < userId) {\n                idx = idxMid + 1;\n            } else {\n                idxCap = idxMid;\n            }\n        }\n        uint32 updateTime = dripsHistory.updateTime;\n        uint32 maxEnd = dripsHistory.maxEnd;\n        uint256 amt = 0;\n        for (; idx < receivers.length; idx++) {\n            DripsReceiver memory receiver = receivers[idx];\n            if (receiver.userId != userId) break;\n            (uint32 start, uint32 end) =\n                _dripsRange(receiver, updateTime, maxEnd, squeezeStartCap, squeezeEndCap);\n            amt += _drippedAmt(receiver.config.amtPerSec(), start, end);\n        }\n        return uint128(amt);\n    }\n\n    /// @notice Current user drips state.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @return dripsHash The current drips receivers list hash, see `_hashDrips`\n    /// @return dripsHistoryHash The current drips history hash, see `_hashDripsHistory`.\n    /// @return updateTime The time when drips have been configured for the last time\n    /// @return balance The balance when drips have been configured for the last time\n    /// @return maxEnd The current maximum end time of drips\n    function _dripsState(uint256 userId, uint256 assetId)\n        internal\n        view\n        returns (\n            bytes32 dripsHash,\n            bytes32 dripsHistoryHash,\n            uint32 updateTime,\n            uint128 balance,\n            uint32 maxEnd\n        )\n    {\n        DripsState storage state = _dripsStorage().states[assetId][userId];\n        return\n            (state.dripsHash, state.dripsHistoryHash, state.updateTime, state.balance, state.maxEnd);\n    }\n\n    /// @notice User drips balance at a given timestamp\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @param receivers The current drips receivers list\n    /// @param timestamp The timestamps for which balance should be calculated.\n    /// It can't be lower than the timestamp of the last call to `setDrips`.\n    /// If it's bigger than `block.timestamp`, then it's a prediction assuming\n    /// that `setDrips` won't be called before `timestamp`.\n    /// @return balance The user balance on `timestamp`\n    function _balanceAt(\n        uint256 userId,\n        uint256 assetId,\n        DripsReceiver[] memory receivers,\n        uint32 timestamp\n    ) internal view returns (uint128 balance) {\n        DripsState storage state = _dripsStorage().states[assetId][userId];\n        require(timestamp >= state.updateTime, \"Timestamp before last drips update\");\n        require(_hashDrips(receivers) == state.dripsHash, \"Invalid current drips list\");\n        return _balanceAt(state.balance, state.updateTime, state.maxEnd, receivers, timestamp);\n    }\n\n    /// @notice Calculates the drips balance at a given timestamp.\n    /// @param lastBalance The balance when drips have started\n    /// @param lastUpdate The timestamp when drips have started.\n    /// @param maxEnd The maximum end time of drips\n    /// @param receivers The list of drips receivers.\n    /// @param timestamp The timestamps for which balance should be calculated.\n    /// It can't be lower than `lastUpdate`.\n    /// If it's bigger than `block.timestamp`, then it's a prediction assuming\n    /// that `setDrips` won't be called before `timestamp`.\n    /// @return balance The user balance on `timestamp`\n    function _balanceAt(\n        uint128 lastBalance,\n        uint32 lastUpdate,\n        uint32 maxEnd,\n        DripsReceiver[] memory receivers,\n        uint32 timestamp\n    ) private view returns (uint128 balance) {\n        balance = lastBalance;\n        for (uint256 i = 0; i < receivers.length; i++) {\n            DripsReceiver memory receiver = receivers[i];\n            (uint32 start, uint32 end) = _dripsRange({\n                receiver: receiver,\n                updateTime: lastUpdate,\n                maxEnd: maxEnd,\n                startCap: lastUpdate,\n                endCap: timestamp\n            });\n            balance -= uint128(_drippedAmt(receiver.config.amtPerSec(), start, end));\n        }\n    }\n\n    /// @notice Sets the user's drips configuration.\n    /// @param userId The user ID\n    /// @param assetId The used asset ID\n    /// @param currReceivers The list of the drips receivers set in the last drips update\n    /// of the user.\n    /// If this is the first update, pass an empty array.\n    /// @param balanceDelta The drips balance change being applied.\n    /// Positive when adding funds to the drips balance, negative to removing them.\n    /// @param newReceivers The list of the drips receivers of the user to be set.\n    /// Must be sorted, deduplicated and without 0 amtPerSecs.\n    /// @param maxEndHint1 An optional parameter allowing gas optimization, pass `0` to ignore it.\n    /// The first hint for finding the maximum end time when all drips stop due to funds\n    /// running out after the balance is updated and the new receivers list is applied.\n    /// Hints have no effect on the results of calling this function, except potentially saving gas.\n    /// Hints are Unix timestamps used as the starting points for binary search for the time\n    /// when funds run out in the range of timestamps from the current block's to `2^32`.\n    /// Hints lower than the current timestamp are ignored.\n    /// You can provide zero, one or two hints. The order of hints doesn't matter.\n    /// Hints are the most effective when one of them is lower than or equal to\n    /// the last timestamp when funds are still dripping, and the other one is strictly larger\n    /// than that timestamp,the smaller the difference between such hints, the higher gas savings.\n    /// The savings are the highest possible when one of the hints is equal to\n    /// the last timestamp when funds are still dripping, and the other one is larger by 1.\n    /// It's worth noting that the exact timestamp of the block in which this function is executed\n    /// may affect correctness of the hints, especially if they're precise.\n    /// Hints don't provide any benefits when balance is not enough to cover\n    /// a single second of dripping or is enough to cover all drips until timestamp `2^32`.\n    /// Even inaccurate hints can be useful, and providing a single hint\n    /// or two hints that don't enclose the time when funds run out can still save some gas.\n    /// Providing poor hints that don't reduce the number of binary search steps\n    /// may cause slightly higher gas usage than not providing any hints.\n    /// @param maxEndHint2 An optional parameter allowing gas optimization, pass `0` to ignore it.\n    /// The second hint for finding the maximum end time, see `maxEndHint1` docs for more details.\n    /// @return realBalanceDelta The actually applied drips balance change.\n    function _setDrips(\n        uint256 userId,\n        uint256 assetId,\n        DripsReceiver[] memory currReceivers,\n        int128 balanceDelta,\n        DripsReceiver[] memory newReceivers,\n        // slither-disable-next-line similar-names\n        uint32 maxEndHint1,\n        uint32 maxEndHint2\n    ) internal returns (int128 realBalanceDelta) {\n        DripsState storage state = _dripsStorage().states[assetId][userId];\n        // slither-disable-next-line timestamp\n        require(_hashDrips(currReceivers) == state.dripsHash, \"Invalid current drips list\");\n        uint32 lastUpdate = state.updateTime;\n        uint128 newBalance;\n        uint32 newMaxEnd;\n        {\n            uint32 currMaxEnd = state.maxEnd;\n            int128 currBalance = int128(\n                _balanceAt(state.balance, lastUpdate, currMaxEnd, currReceivers, _currTimestamp())\n            );\n            realBalanceDelta = balanceDelta;\n            // Cap `realBalanceDelta` at withdrawal of the entire `currBalance`\n            if (realBalanceDelta < -currBalance) {\n                realBalanceDelta = -currBalance;\n            }\n            newBalance = uint128(currBalance + realBalanceDelta);\n            newMaxEnd = _calcMaxEnd(newBalance, newReceivers, maxEndHint1, maxEndHint2);\n            _updateReceiverStates(\n                _dripsStorage().states[assetId],\n                currReceivers,\n                lastUpdate,\n                currMaxEnd,\n                newReceivers,\n                newMaxEnd\n            );\n        }\n        state.updateTime = _currTimestamp();\n        state.maxEnd = newMaxEnd;\n        state.balance = newBalance;\n        bytes32 dripsHistory = state.dripsHistoryHash;\n        // slither-disable-next-line timestamp\n        if (dripsHistory != 0 && _cycleOf(lastUpdate) != _cycleOf(_currTimestamp())) {\n            state.currCycleConfigs = 2;\n        } else {\n            state.currCycleConfigs++;\n        }\n        bytes32 newDripsHash = _hashDrips(newReceivers);\n        state.dripsHistoryHash =\n            _hash"
    }
  ]
}