{
  "Title": "Incorrect Error Message",
  "Content": "In the [`validateTx` function of `light/txpool.go`](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/light/txpool.go#L350), if the sponsor does not contain sufficient funds in order to [pay for the `sponsorAmount`](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/light/txpool.go#L394-L396), the error returned is `core.ErrInsufficientFunds`. However, for clarity and [consistency with `txpool/txpool.go`](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/txpool/txpool.go#L709-L711), consider returning the [`types.ErrSponsorBalanceNotEnough`](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/types/meta_transaction.go#L26) error instead.\n\n\n***Update:** Resolved in [pull request #50](https://github.com/mantlenetworkio/op-geth/pull/50) at commit [65ab3a1](https://github.com/mantlenetworkio/op-geth/pull/50/commits/65ab3a1f3f309cd297b4cb23283e688d5cf5048f).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "light/txpool.go",
      "content": "// Copyright 2016 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage light\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\t\"github.com/ethereum/go-ethereum/core/rawdb\"\n\t\"github.com/ethereum/go-ethereum/core/state\"\n\t\"github.com/ethereum/go-ethereum/core/txpool\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/ethdb\"\n\t\"github.com/ethereum/go-ethereum/event\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n)\n\nconst (\n\t// chainHeadChanSize is the size of channel listening to ChainHeadEvent.\n\tchainHeadChanSize = 10\n)\n\n// txPermanent is the number of mined blocks after a mined transaction is\n// considered permanent and no rollback is expected\nvar txPermanent = uint64(500)\n\n// TxPool implements the transaction pool for light clients, which keeps track\n// of the status of locally created transactions, detecting if they are included\n// in a block (mined) or rolled back. There are no queued transactions since we\n// always receive all locally signed transactions in the same order as they are\n// created.\ntype TxPool struct {\n\tconfig       *params.ChainConfig\n\tsigner       types.Signer\n\tquit         chan bool\n\ttxFeed       event.Feed\n\tscope        event.SubscriptionScope\n\tchainHeadCh  chan core.ChainHeadEvent\n\tchainHeadSub event.Subscription\n\tmu           sync.RWMutex\n\tchain        *LightChain\n\todr          OdrBackend\n\tchainDb      ethdb.Database\n\trelay        TxRelayBackend\n\thead         common.Hash\n\tnonce        map[common.Address]uint64            // \"pending\" nonce\n\tpending      map[common.Hash]*types.Transaction   // pending transactions by tx hash\n\tmined        map[common.Hash][]*types.Transaction // mined transactions by block hash\n\tclearIdx     uint64                               // earliest block nr that can contain mined tx info\n\n\tistanbul bool // Fork indicator whether we are in the istanbul stage.\n\teip2718  bool // Fork indicator whether we are in the eip2718 stage.\n\tshanghai bool // Fork indicator whether we are in the shanghai stage.\n}\n\n// TxRelayBackend provides an interface to the mechanism that forwards transactions to the\n// ETH network. The implementations of the functions should be non-blocking.\n//\n// Send instructs backend to forward new transactions NewHead notifies backend about a new\n// head after processed by the tx pool, including mined and rolled back transactions since\n// the last event.\n//\n// Discard notifies backend about transactions that should be discarded either because\n// they have been replaced by a re-send or because they have been mined long ago and no\n// rollback is expected.\ntype TxRelayBackend interface {\n\tSend(txs types.Transactions)\n\tNewHead(head common.Hash, mined []common.Hash, rollback []common.Hash)\n\tDiscard(hashes []common.Hash)\n}\n\n// NewTxPool creates a new light transaction pool\nfunc NewTxPool(config *params.ChainConfig, chain *LightChain, relay TxRelayBackend) *TxPool {\n\tpool := &TxPool{\n\t\tconfig:      config,\n\t\tsigner:      types.LatestSigner(config),\n\t\tnonce:       make(map[common.Address]uint64),\n\t\tpending:     make(map[common.Hash]*types.Transaction),\n\t\tmined:       make(map[common.Hash][]*types.Transaction),\n\t\tquit:        make(chan bool),\n\t\tchainHeadCh: make(chan core.ChainHeadEvent, chainHeadChanSize),\n\t\tchain:       chain,\n\t\trelay:       relay,\n\t\todr:         chain.Odr(),\n\t\tchainDb:     chain.Odr().Database(),\n\t\thead:        chain.CurrentHeader().Hash(),\n\t\tclearIdx:    chain.CurrentHeader().Number.Uint64(),\n\t}\n\t// Subscribe events from blockchain\n\tpool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)\n\tgo pool.eventLoop()\n\n\treturn pool\n}\n\n// currentState returns the light state of the current head header\nfunc (pool *TxPool) currentState(ctx context.Context) *state.StateDB {\n\treturn NewState(ctx, pool.chain.CurrentHeader(), pool.odr)\n}\n\n// GetNonce returns the \"pending\" nonce of a given address. It always queries\n// the nonce belonging to the latest header too in order to detect if another\n// client using the same key sent a transaction.\nfunc (pool *TxPool) GetNonce(ctx context.Context, addr common.Address) (uint64, error) {\n\tstate := pool.currentState(ctx)\n\tnonce := state.GetNonce(addr)\n\tif state.Error() != nil {\n\t\treturn 0, state.Error()\n\t}\n\tsn, ok := pool.nonce[addr]\n\tif ok && sn > nonce {\n\t\tnonce = sn\n\t}\n\tif !ok || sn < nonce {\n\t\tpool.nonce[addr] = nonce\n\t}\n\treturn nonce, nil\n}\n\n// txStateChanges stores the recent changes between pending/mined states of\n// transactions. True means mined, false means rolled back, no entry means no change\ntype txStateChanges map[common.Hash]bool\n\n// setState sets the status of a tx to either recently mined or recently rolled back\nfunc (txc txStateChanges) setState(txHash common.Hash, mined bool) {\n\tval, ent := txc[txHash]\n\tif ent && (val != mined) {\n\t\tdelete(txc, txHash)\n\t} else {\n\t\ttxc[txHash] = mined\n\t}\n}\n\n// getLists creates lists of mined and rolled back tx hashes\nfunc (txc txStateChanges) getLists() (mined []common.Hash, rollback []common.Hash) {\n\tfor hash, val := range txc {\n\t\tif val {\n\t\t\tmined = append(mined, hash)\n\t\t} else {\n\t\t\trollback = append(rollback, hash)\n\t\t}\n\t}\n\treturn\n}\n\n// checkMinedTxs checks newly added blocks for the currently pending transactions\n// and marks them as mined if necessary. It also stores block position in the db\n// and adds them to the received txStateChanges map.\nfunc (pool *TxPool) checkMinedTxs(ctx context.Context, hash common.Hash, number uint64, txc txStateChanges) error {\n\t// If no transactions are pending, we don't care about anything\n\tif len(pool.pending) == 0 {\n\t\treturn nil\n\t}\n\tblock, err := GetBlock(ctx, pool.odr, hash, number)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Gather all the local transaction mined in this block\n\tlist := pool.mined[hash]\n\tfor _, tx := range block.Transactions() {\n\t\tif _, ok := pool.pending[tx.Hash()]; ok {\n\t\t\tlist = append(list, tx)\n\t\t}\n\t}\n\t// If some transactions have been mined, write the needed data to disk and update\n\tif list != nil {\n\t\t// Retrieve all the receipts belonging to this block and write the lookup table\n\t\tif _, err := GetBlockReceipts(ctx, pool.odr, hash, number); err != nil { // ODR caches, ignore results\n\t\t\treturn err\n\t\t}\n\t\trawdb.WriteTxLookupEntriesByBlock(pool.chainDb, block)\n\n\t\t// Update the transaction pool's state\n\t\tfor _, tx := range list {\n\t\t\tdelete(pool.pending, tx.Hash())\n\t\t\ttxc.setState(tx.Hash(), true)\n\t\t}\n\t\tpool.mined[hash] = list\n\t}\n\treturn nil\n}\n\n// rollbackTxs marks the transactions contained in recently rolled back blocks\n// as rolled back. It also removes any positional lookup entries.\nfunc (pool *TxPool) rollbackTxs(hash common.Hash, txc txStateChanges) {\n\tbatch := pool.chainDb.NewBatch()\n\tif list, ok := pool.mined[hash]; ok {\n\t\tfor _, tx := range list {\n\t\t\ttxHash := tx.Hash()\n\t\t\trawdb.DeleteTxLookupEntry(batch, txHash)\n\t\t\tpool.pending[txHash] = tx\n\t\t\ttxc.setState(txHash, false)\n\t\t}\n\t\tdelete(pool.mined, hash)\n\t}\n\tbatch.Write()\n}\n\n// reorgOnNewHead sets a new head header, processing (and rolling back if necessary)\n// the blocks since the last known head and returns a txStateChanges map containing\n// the recently mined and rolled back transaction hashes. If an error (context\n// timeout) occurs during checking new blocks, it leaves the locally known head\n// at the latest checked block and still returns a valid txStateChanges, making it\n// possible to continue checking the missing blocks at the next chain head event\nfunc (pool *TxPool) reorgOnNewHead(ctx context.Context, newHeader *types.Header) (txStateChanges, error) {\n\ttxc := make(txStateChanges)\n\toldh := pool.chain.GetHeaderByHash(pool.head)\n\tnewh := newHeader\n\t// find common ancestor, create list of rolled back and new block hashes\n\tvar oldHashes, newHashes []common.Hash\n\tfor oldh.Hash() != newh.Hash() {\n\t\tif oldh.Number.Uint64() >= newh.Number.Uint64() {\n\t\t\toldHashes = append(oldHashes, oldh.Hash())\n\t\t\toldh = pool.chain.GetHeader(oldh.ParentHash, oldh.Number.Uint64()-1)\n\t\t}\n\t\tif oldh.Number.Uint64() < newh.Number.Uint64() {\n\t\t\tnewHashes = append(newHashes, newh.Hash())\n\t\t\tnewh = pool.chain.GetHeader(newh.ParentHash, newh.Number.Uint64()-1)\n\t\t\tif newh == nil {\n\t\t\t\t// happens when CHT syncing, nothing to do\n\t\t\t\tnewh = oldh\n\t\t\t}\n\t\t}\n\t}\n\tif oldh.Number.Uint64() < pool.clearIdx {\n\t\tpool.clearIdx = oldh.Number.Uint64()\n\t}\n\t// roll back old blocks\n\tfor _, hash := range oldHashes {\n\t\tpool.rollbackTxs(hash, txc)\n\t}\n\tpool.head = oldh.Hash()\n\t// check mined txs of new blocks (array is in reversed order)\n\tfor i := len(newHashes) - 1; i >= 0; i-- {\n\t\thash := newHashes[i]\n\t\tif err := pool.checkMinedTxs(ctx, hash, newHeader.Number.Uint64()-uint64(i), txc); err != nil {\n\t\t\treturn txc, err\n\t\t}\n\t\tpool.head = hash\n\t}\n\n\t// clear old mined tx entries of old blocks\n\tif idx := newHeader.Number.Uint64(); idx > pool.clearIdx+txPermanent {\n\t\tidx2 := idx - txPermanent\n\t\tif len(pool.mined) > 0 {\n\t\t\tfor i := pool.clearIdx; i < idx2; i++ {\n\t\t\t\thash := rawdb.ReadCanonicalHash(pool.chainDb, i)\n\t\t\t\tif list, ok := pool.mined[hash]; ok {\n\t\t\t\t\thashes := make([]common.Hash, len(list))\n\t\t\t\t\tfor i, tx := range list {\n\t\t\t\t\t\thashes[i] = tx.Hash()\n\t\t\t\t\t}\n\t\t\t\t\tpool.relay.Discard(hashes)\n\t\t\t\t\tdelete(pool.mined, hash)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpool.clearIdx = idx2\n\t}\n\n\treturn txc, nil\n}\n\n// blockCheckTimeout is the time limit for checking new blocks for mined\n// transactions. Checking resumes at the next chain head event if timed out.\nconst blockCheckTimeout = time.Second * 3\n\n// eventLoop processes chain head events and also notifies the tx relay backend\n// about the new head hash and tx state changes\nfunc (pool *TxPool) eventLoop() {\n\tfor {\n\t\tselect {\n\t\tcase ev := <-pool.chainHeadCh:\n\t\t\tpool.setNewHead(ev.Block.Header())\n\t\t\t// hack in order to avoid hogging the lock; this part will\n\t\t\t// be replaced by a subsequent PR.\n\t\t\ttime.Sleep(time.Millisecond)\n\n\t\t// System stopped\n\t\tcase <-pool.chainHeadSub.Err():\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (pool *TxPool) setNewHead(head *types.Header) {\n\tpool.mu.Lock()\n\tdefer pool.mu.Unlock()\n\n\tctx, cancel := context.WithTimeout(context.Background(), blockCheckTimeout)\n\tdefer cancel()\n\n\ttxc, _ := pool.reorgOnNewHead(ctx, head)\n\tm, r := txc.getLists()\n\tpool.relay.NewHead(pool.head, m, r)\n\n\t// Update fork indicator by next pending block number\n\tnext := new(big.Int).Add(head.Number, big.NewInt(1))\n\tpool.istanbul = pool.config.IsIstanbul(next)\n\tpool.eip2718 = pool.config.IsBerlin(next)\n\tpool.shanghai = pool.config.IsShanghai(uint64(time.Now().Unix()))\n}\n\n// Stop stops the light transaction pool\nfunc (pool *TxPool) Stop() {\n\t// Unsubscribe all subscriptions registered from txpool\n\tpool.scope.Close()\n\t// Unsubscribe subscriptions registered from blockchain\n\tpool.chainHeadSub.Unsubscribe()\n\tclose(pool.quit)\n\tlog.Info(\"Transaction pool stopped\")\n}\n\n// SubscribeNewTxsEvent registers a subscription of core.NewTxsEvent and\n// starts sending event to the given channel.\nfunc (pool *TxPool) SubscribeNewTxsEvent(ch chan<- core.NewTxsEvent) event.Subscription {\n\treturn pool.scope.Track(pool.txFeed.Subscribe(ch))\n}\n\n// Stats returns the number of currently pending (locally created) transactions\nfunc (pool *TxPool) Stats() (pending int) {\n\tpool.mu.RLock()\n\tdefer pool.mu.RUnlock()\n\n\tpending = len(pool.pending)\n\treturn\n}\n\n// validateTx checks whether a transaction is valid according to the consensus rules.\nfunc (pool *TxPool) validateTx(ctx context.Context, tx *types.Transaction) error {\n\t// Validate sender\n\tvar (\n\t\tfrom common.Address\n\t\terr  error\n\t)\n\n\t// Validate the transaction sender and it's sig. Throw\n\t// if the from fields is invalid.\n\tif from, err = types.Sender(pool.signer, tx); err != nil {\n\t\treturn txpool.ErrInvalidSender\n\t}\n\t// Last but not least check for nonce errors\n\tcurrentState := pool.currentState(ctx)\n\tif n := currentState.GetNonce(from); n > tx.Nonce() {\n\t\treturn core.ErrNonceTooLow\n\t}\n\n\t// Check the transaction doesn't exceed the current\n\t// block limit gas.\n\theader := pool.chain.GetHeaderByHash(pool.head)\n\tif header.GasLimit < tx.Gas() {\n\t\treturn txpool.ErrGasLimit\n\t}\n\n\t// Transactions can't be negative. This may never happen\n\t// using RLP decoded transactions but may occur if you create\n\t// a transaction using the RPC for example.\n\tif tx.Value().Sign() < 0 {\n\t\treturn txpool.ErrNegativeValue\n\t}\n\n\tmetaTxParams, err := types.DecodeAndVerifyMetaTxParams(tx, pool.config.IsMetaTxV2(header.Time))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif metaTxParams != nil {\n\t\tif metaTxParams.ExpireHeight < header.Number.Uint64() {\n\t\t\treturn types.ErrExpiredMetaTx\n\t\t}\n\t\ttxGasCost := new(big.Int).Mul(tx.GasPrice(), new(big.Int).SetUint64(tx.Gas()))\n\t\tsponsorAmount, selfPayAmount := types.CalculateSponsorPercentAmount(metaTxParams, txGasCost)\n\t\tselfPayAmount = new(big.Int).Add(selfPayAmount, tx.Value())\n\t\tsponsorBalance := currentState.GetBalance(metaTxParams.GasFeeSponsor)\n\t\tif sponsorBalance.Cmp(sponsorAmount) < 0 {\n\t\t\treturn core.ErrInsufficientFunds\n\t\t}\n\t\tuserBalance := currentState.GetBalance(from)\n\t\tif userBalance.Cmp(selfPayAmount) < 0 {\n\t\t\treturn core.ErrInsufficientFunds\n\t\t}\n\t} else {\n\t\t// Transactor should have enough funds to cover the costs\n\t\t// cost == V + GP * GL\n\t\tif b := currentState.GetBalance(from); b.Cmp(tx.Cost()) < 0 {\n\t\t\treturn core.ErrInsufficientFunds\n\t\t}\n\t}\n\n\t// Should supply enough intrinsic gas\n\tgas, err := core.IntrinsicGas(tx.Data(), tx.AccessList(), tx.To() == nil, true, pool.istanbul, pool.shanghai)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif tx.Gas() < gas {\n\t\treturn core.ErrIntrinsicGas\n\t}\n\treturn currentState.Error()\n}\n\n// add validates a new transaction and sets its state pending if processable.\n// It also updates the locally stored nonce if necessary.\nfunc (pool *TxPool) add(ctx context.Context, tx *types.Transaction) error {\n\thash := tx.Hash()\n\n\tif pool.pending[hash] != nil {\n\t\treturn fmt.Errorf(\"known transaction (%x)\", hash[:4])\n\t}\n\terr := pool.validateTx(ctx, tx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, ok := pool.pending[hash]; !ok {\n\t\tpool.pending[hash] = tx\n\n\t\tnonce := tx.Nonce() + 1\n\n\t\taddr, _ := types.Sender(pool.signer, tx)\n\t\tif nonce > pool.nonce[addr] {\n\t\t\tpool.nonce[addr] = nonce\n\t\t}\n\n\t\t// Notify the subscribers. This event is posted in a goroutine\n\t\t// because it's possible that somewhere during the post \"Remove transaction\"\n\t\t// gets called which will then wait for the global tx pool lock and deadlock.\n\t\tgo pool.txFeed.Send(core.NewTxsEvent{Txs: types.Transactions{tx}})\n\t}\n\n\t// Print a log message if low enough level is set\n\tlog.Debug(\"Pooled new transaction\", \"hash\", hash, \"from\", log.Lazy{Fn: func() common.Address { from, _ := types.Sender(pool.signer, tx); return from }}, \"to\", tx.To())\n\treturn nil\n}\n\n// Add adds a transaction to the pool if valid and passes it to the tx relay\n// backend\nfunc (pool *TxPool) Add(ctx context.Context, tx *types.Transaction) error {\n\tpool.mu.Lock()\n\tdefer pool.mu.Unlock()\n\tdata, err := tx.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := pool.add(ctx, tx); err != nil {\n\t\treturn err\n\t}\n\t//fmt.Println(\"Send\", tx.Hash())\n\tpool.relay.Send(types.Transactions{tx})\n\n\tpool.chainDb.Put(tx.Hash().Bytes(), data)\n\treturn nil\n}\n\n// AddBatch adds all valid transactions to the pool and passes them to\n// the tx relay backend\nfunc (pool *TxPool) AddBatch(ctx context.Context, txs []*types.Transaction) {\n\tpool.mu.Lock()\n\tdefer pool.mu.Unlock()\n\tvar sendTx types.Transactions\n\n\tfor _, tx := range txs {\n\t\tif err := pool.add(ctx, tx); err == nil {\n\t\t\tsendTx = append(sendTx, tx)\n\t\t}\n\t}\n\tif len(sendTx) > 0 {\n\t\tpool.relay.Send(sendTx)\n\t}\n}\n\n// GetTransaction returns a transaction if it is contained in the pool\n// and nil otherwise.\nfunc (pool *TxPool) GetTransaction(hash common.Hash) *types.Transaction {\n\t// check the txs first\n\tif tx, ok := pool.pending[hash]; ok {\n\t\treturn tx\n\t}\n\treturn nil\n}\n\n// GetTransactions returns all currently processable transactions.\n// The returned slice may be modified by the caller.\nfunc (pool *TxPool) GetTransactions() (txs types.Transactions, err error) {\n\tpool.mu.RLock()\n\tdefer pool.mu.RUnlock()\n\n\ttxs = make(types.Transactions, len(pool.pending))\n\ti := 0\n\tfor _, tx := range pool.pending {\n\t\ttxs[i] = tx\n\t\ti++\n\t}\n\treturn txs, nil\n}\n\n// Content retrieves the data content of the transaction pool, returning all the\n// pending as well as queued transactions, grouped by account and nonce.\nfunc (pool *TxPool) Content() (map[common.Address]types.Transactions, map[common.Address]types.Transactions) {\n\tpool.mu.RLock()\n\tdefer pool.mu.RUnlock()\n\n\t// Retrieve all the pending transactions and sort by account and by nonce\n\tpending := make(map[common.Address]types.Transactions)\n\tfor _, tx := range pool.pending {\n\t\taccount, _ := types.Sender(pool.signer, tx)\n\t\tpending[account] = append(pending[account], tx)\n\t}\n\t// There are no queued transactions in a light pool, just return an empty map\n\tqueued := make(map[common.Address]types.Transactions)\n\treturn pending, queued\n}\n\n// ContentFrom retrieves the data content of the transaction pool, returning the\n// pending as well as queued transactions of this address, grouped by nonce.\nfunc (pool *TxPool) ContentFrom(addr common.Address) (types.Transactions, types.Transactions) {\n\tpool.mu.RLock()\n\tdefer pool.mu.RUnlock()\n\n\t// Retrieve the pending transactions and sort by nonce\n\tvar pending types.Transactions\n\tfor _, tx := range pool.pending {\n\t\taccount, _ := types.Sender(pool.signer, tx)\n\t\tif account != addr {\n\t\t\tcontinue\n\t\t}\n\t\tpending = append(pending, tx)\n\t}\n\t// There are no queued transactions in a light pool, just return an empty map\n\treturn pending, types.Transactions{}\n}\n\n// RemoveTransactions removes all given transactions from the pool.\nfunc (pool *TxPool) RemoveTransactions(txs types.Transactions) {\n\tpool.mu.Lock()\n\tdefer pool.mu.Unlock()\n\n\tvar hashes []common.Hash\n\tbatch := pool.chainDb.NewBatch()\n\tfor _, tx := range txs {\n\t\thash := tx.Hash()\n\t\tdelete(pool.pending, hash)\n\t\tbatch.Delete(hash.Bytes())\n\t\thashes = append(hashes, hash)\n\t}\n\tbatch.Write()\n\tpool.relay.Discard(hashes)\n}\n\n// RemoveTx removes the transaction with the given hash from the pool.\nfunc (pool *TxPool) RemoveTx(hash common.Hash) {\n\tpool.mu.Lock()\n\tdefer pool.mu.Unlock()\n\t// delete from pending pool\n\tdelete(pool.pending, hash)\n\tpool.chainDb.Delete(hash[:])\n\tpool.relay.Discard([]common.Hash{hash})\n}"
    }
  ]
}