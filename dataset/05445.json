{
  "Title": "[05] `CoreRef::emergencyAction` is susceptible to returnbomb attack",
  "Content": "\nEmergency action defined in `CoreRef.sol` which is inherited from all the contracts is a good addition which can be used for various purposes (rescuing tokens, executing certain functions, etc.) but it does not use assembly for consuming the returned data which makes it vulnerable to [returnbomb](https://gist.github.com/pcaversaccio/3b487a24922c839df22f925babd3c809) attack. Since this action can be used for various purposes, including calling untrusted external contracts this is a real possibility for griefing attack: \n\n[CoreRef.sol#L87-L107](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/core/CoreRef.sol#L87-L107)\n\n```solidity\n/// @notice due to inflexibility of current smart contracts,\n/// add this ability to be able to execute arbitrary calldata\n/// against arbitrary addresses.\n/// callable only by governor\nfunction emergencyAction(Call[] calldata calls)\n    external\n    payable\n    onlyCoreRole(CoreRoles.GOVERNOR)\n    returns (bytes[] memory returnData)\n{\n    returnData = new bytes[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n        address payable target = payable(calls[i].target);\n        uint256 value = calls[i].value;\n        bytes calldata callData = calls[i].callData;\n\n        (bool success, bytes memory returned) = target.call{value: value}(callData);\n        require(success, \"CoreRef: underlying call reverted\");\n        returnData[i] = returned;\n    }\n}\n```\n\n### Recommendation\n\nConsider using [ExcessivelySafeCall](https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol) library or assembly to remove the potential vulnerability.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/core/CoreRef.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {Core} from \"@src/core/Core.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\n\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n/// @title A Reference to Core\n/// @author eswak\n/// @notice defines some modifiers and utilities around interacting with Core\nabstract contract CoreRef is Pausable {\n    /// @notice emitted when the reference to core is updated\n    event CoreUpdate(address indexed oldCore, address indexed newCore);\n\n    /// @notice reference to Core\n    Core private _core;\n\n    constructor(address coreAddress) {\n        _core = Core(coreAddress);\n    }\n\n    /// @notice named onlyCoreRole to prevent collision with OZ onlyRole modifier\n    modifier onlyCoreRole(bytes32 role) {\n        require(_core.hasRole(role, msg.sender), \"UNAUTHORIZED\");\n        _;\n    }\n\n    /// @notice address of the Core contract referenced\n    function core() public view returns (Core) {\n        return _core;\n    }\n\n    /// @notice WARNING CALLING THIS FUNCTION CAN POTENTIALLY\n    /// BRICK A CONTRACT IF CORE IS SET INCORRECTLY\n    /// @notice set new reference to core\n    /// only callable by governor\n    /// @param newCore to reference\n    function setCore(\n        address newCore\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        _setCore(newCore);\n    }\n\n    /// @notice WARNING CALLING THIS FUNCTION CAN POTENTIALLY\n    /// BRICK A CONTRACT IF CORE IS SET INCORRECTLY\n    /// @notice set new reference to core\n    /// @param newCore to reference\n    function _setCore(address newCore) internal {\n        address oldCore = address(_core);\n        _core = Core(newCore);\n\n        emit CoreUpdate(oldCore, newCore);\n    }\n\n    /// @notice set pausable methods to paused\n    function pause() public onlyCoreRole(CoreRoles.GUARDIAN) {\n        _pause();\n    }\n\n    /// @notice set pausable methods to unpaused\n    function unpause() public onlyCoreRole(CoreRoles.GUARDIAN) {\n        _unpause();\n    }\n\n    /// ------------------------------------------\n    /// ------------ Emergency Action ------------\n    /// ------------------------------------------\n\n    /// inspired by MakerDAO Multicall:\n    /// https://github.com/makerdao/multicall/blob/master/src/Multicall.sol\n\n    /// @notice struct to pack calldata and targets for an emergency action\n    struct Call {\n        /// @notice target address to call\n        address target;\n        /// @notice amount of eth to send with the call\n        uint256 value;\n        /// @notice payload to send to target\n        bytes callData;\n    }\n\n    /// @notice due to inflexibility of current smart contracts,\n    /// add this ability to be able to execute arbitrary calldata\n    /// against arbitrary addresses.\n    /// callable only by governor\n    function emergencyAction(\n        Call[] calldata calls\n    )\n        external\n        payable\n        onlyCoreRole(CoreRoles.GOVERNOR)\n        returns (bytes[] memory returnData)\n    {\n        returnData = new bytes[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            address payable target = payable(calls[i].target);\n            uint256 value = calls[i].value;\n            bytes calldata callData = calls[i].callData;\n\n            (bool success, bytes memory returned) = target.call{value: value}(\n                callData\n            );\n            require(success, \"CoreRef: underlying call reverted\");\n            returnData[i] = returned;\n        }\n    }\n}"
    }
  ]
}