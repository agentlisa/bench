{
  "Title": "Silent overflow in `TrimmedAmount::shift` could result in rate limiter being bypassed",
  "Content": "**Description:** Within [`TrimmedAmount::trim`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/TrimmedAmount.sol#L136-L158), there is an explicit check that ensures the scaled amount does not exceed the maximum `uint64`:\n```solidity\n// NOTE: amt after trimming must fit into uint64 (that's the point of\n// trimming, as Solana only supports uint64 for token amts)\nif (amountScaled > type(uint64).max) {\n    revert AmountTooLarge(amt);\n}\n```\nHowever, no such check exists within [`TrimmedAmount::shift`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/TrimmedAmount.sol#L121-L129) which means there is potential for silent overflow when casting to `uint64` here:\n```solidity\nfunction shift(\n    TrimmedAmount memory amount,\n    uint8 toDecimals\n) internal pure returns (TrimmedAmount memory) {\n    uint8 actualToDecimals = minUint8(TRIMMED_DECIMALS, toDecimals);\n    return TrimmedAmount(\n        uint64(scale(amount.amount, amount.decimals, actualToDecimals)), actualToDecimals\n    );\n}\n```\n\n**Impact:** A silent overflow in `TrimmedAmount::shift` could result in the rate limiter being bypassed, considering its usage in [`NttManager::_transferEntryPoint`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManager.sol#L300). Given the high impact and reasonable likelihood of this issue occurring, it is classified a **MEDIUM** severity finding.\n\n**Recommended Mitigation:** Explicitly check the scaled amount in `TrimmedAmount::shift` does not exceed the maximum `uint64`.\n\n**Wormhole Foundation:** Fixed in [PR \\#262](https://github.com/wormhole-foundation/example-native-token-transfers/pull/262).\n\n**Cyfrin:** Verified. OpenZeppelin `SafeCast` library is now used when casting to `uint64`.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/libraries/TrimmedAmount.sol",
      "content": "// SPDX-License-Identifier: Apache 2\n/// @dev TrimmedAmount is a utility library to handle token amounts with different decimals\npragma solidity >=0.8.8 <0.9.0;\n\nstruct TrimmedAmount {\n    uint64 amount;\n    uint8 decimals;\n}\n\nfunction minUint8(uint8 a, uint8 b) pure returns (uint8) {\n    return a < b ? a : b;\n}\n\nlibrary TrimmedAmountLib {\n    uint8 constant TRIMMED_DECIMALS = 8;\n\n    error AmountTooLarge(uint256 amount);\n    error NumberOfDecimalsNotEqual(uint8 decimals, uint8 decimalsOther);\n\n    function unwrap(TrimmedAmount memory a) internal pure returns (uint64, uint8) {\n        return (a.amount, a.decimals);\n    }\n\n    function getAmount(TrimmedAmount memory a) internal pure returns (uint64) {\n        return a.amount;\n    }\n\n    function getDecimals(TrimmedAmount memory a) internal pure returns (uint8) {\n        return a.decimals;\n    }\n\n    function eq(TrimmedAmount memory a, TrimmedAmount memory b) internal pure returns (bool) {\n        return a.amount == b.amount && a.decimals == b.decimals;\n    }\n\n    function gt(TrimmedAmount memory a, TrimmedAmount memory b) internal pure returns (bool) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return a.amount > b.amount;\n    }\n\n    function lt(TrimmedAmount memory a, TrimmedAmount memory b) internal pure returns (bool) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return a.amount < b.amount;\n    }\n\n    function isNull(TrimmedAmount memory a) internal pure returns (bool) {\n        return (a.amount == 0 && a.decimals == 0);\n    }\n\n    function sub(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) internal pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return TrimmedAmount(a.amount - b.amount, a.decimals);\n    }\n\n    function add(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) internal pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n        return TrimmedAmount(a.amount + b.amount, a.decimals);\n    }\n\n    function saturatingAdd(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) internal pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        uint256 saturatedSum;\n        unchecked {\n            saturatedSum = uint256(a.amount) + uint256(b.amount);\n            saturatedSum = saturatedSum > type(uint64).max ? type(uint64).max : saturatedSum;\n        }\n        return TrimmedAmount(uint64(saturatedSum), a.decimals);\n    }\n\n    function min(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) public pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return a.amount < b.amount ? a : b;\n    }\n\n    /// @dev scale the amount from original decimals to target decimals (base 10)\n    function scale(\n        uint256 amount,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) {\n            return amount;\n        }\n\n        if (fromDecimals > toDecimals) {\n            return amount / (10 ** (fromDecimals - toDecimals));\n        } else {\n            return amount * (10 ** (toDecimals - fromDecimals));\n        }\n    }\n\n    function shift(\n        TrimmedAmount memory amount,\n        uint8 toDecimals\n    ) internal pure returns (TrimmedAmount memory) {\n        uint8 actualToDecimals = minUint8(TRIMMED_DECIMALS, toDecimals);\n        return TrimmedAmount(\n            uint64(scale(amount.amount, amount.decimals, actualToDecimals)), actualToDecimals\n        );\n    }\n\n    function max(uint8 decimals) internal pure returns (TrimmedAmount memory) {\n        uint8 actualDecimals = minUint8(TRIMMED_DECIMALS, decimals);\n        return TrimmedAmount(type(uint64).max, actualDecimals);\n    }\n\n    /// @dev trim the amount to target decimals.\n    ///      The actual resulting decimals is the minimum of TRIMMED_DECIMALS,\n    ///      fromDecimals, and toDecimals. This ensures that no dust is\n    ///      destroyed on either side of the transfer.\n    /// @param amt the amount to be trimmed\n    /// @param fromDecimals the original decimals of the amount\n    /// @param toDecimals the target decimals of the amount\n    ///\n    function trim(\n        uint256 amt,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (TrimmedAmount memory) {\n        uint8 actualToDecimals = minUint8(minUint8(TRIMMED_DECIMALS, fromDecimals), toDecimals);\n        uint256 amountScaled = scale(amt, fromDecimals, actualToDecimals);\n\n        // NOTE: amt after trimming must fit into uint64 (that's the point of\n        // trimming, as Solana only supports uint64 for token amts)\n        if (amountScaled > type(uint64).max) {\n            revert AmountTooLarge(amt);\n        }\n        return TrimmedAmount(uint64(amountScaled), actualToDecimals);\n    }\n\n    function untrim(TrimmedAmount memory amt, uint8 toDecimals) internal pure returns (uint256) {\n        (uint256 deNorm, uint8 fromDecimals) = unwrap(amt);\n        uint256 amountScaled = scale(deNorm, fromDecimals, toDecimals);\n\n        return amountScaled;\n    }\n}"
    },
    {
      "filename": "evm/src/libraries/TrimmedAmount.sol",
      "content": "// SPDX-License-Identifier: Apache 2\n/// @dev TrimmedAmount is a utility library to handle token amounts with different decimals\npragma solidity >=0.8.8 <0.9.0;\n\nstruct TrimmedAmount {\n    uint64 amount;\n    uint8 decimals;\n}\n\nfunction minUint8(uint8 a, uint8 b) pure returns (uint8) {\n    return a < b ? a : b;\n}\n\nlibrary TrimmedAmountLib {\n    uint8 constant TRIMMED_DECIMALS = 8;\n\n    error AmountTooLarge(uint256 amount);\n    error NumberOfDecimalsNotEqual(uint8 decimals, uint8 decimalsOther);\n\n    function unwrap(TrimmedAmount memory a) internal pure returns (uint64, uint8) {\n        return (a.amount, a.decimals);\n    }\n\n    function getAmount(TrimmedAmount memory a) internal pure returns (uint64) {\n        return a.amount;\n    }\n\n    function getDecimals(TrimmedAmount memory a) internal pure returns (uint8) {\n        return a.decimals;\n    }\n\n    function eq(TrimmedAmount memory a, TrimmedAmount memory b) internal pure returns (bool) {\n        return a.amount == b.amount && a.decimals == b.decimals;\n    }\n\n    function gt(TrimmedAmount memory a, TrimmedAmount memory b) internal pure returns (bool) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return a.amount > b.amount;\n    }\n\n    function lt(TrimmedAmount memory a, TrimmedAmount memory b) internal pure returns (bool) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return a.amount < b.amount;\n    }\n\n    function isNull(TrimmedAmount memory a) internal pure returns (bool) {\n        return (a.amount == 0 && a.decimals == 0);\n    }\n\n    function sub(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) internal pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return TrimmedAmount(a.amount - b.amount, a.decimals);\n    }\n\n    function add(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) internal pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n        return TrimmedAmount(a.amount + b.amount, a.decimals);\n    }\n\n    function saturatingAdd(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) internal pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        uint256 saturatedSum;\n        unchecked {\n            saturatedSum = uint256(a.amount) + uint256(b.amount);\n            saturatedSum = saturatedSum > type(uint64).max ? type(uint64).max : saturatedSum;\n        }\n        return TrimmedAmount(uint64(saturatedSum), a.decimals);\n    }\n\n    function min(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) public pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return a.amount < b.amount ? a : b;\n    }\n\n    /// @dev scale the amount from original decimals to target decimals (base 10)\n    function scale(\n        uint256 amount,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) {\n            return amount;\n        }\n\n        if (fromDecimals > toDecimals) {\n            return amount / (10 ** (fromDecimals - toDecimals));\n        } else {\n            return amount * (10 ** (toDecimals - fromDecimals));\n        }\n    }\n\n    function shift(\n        TrimmedAmount memory amount,\n        uint8 toDecimals\n    ) internal pure returns (TrimmedAmount memory) {\n        uint8 actualToDecimals = minUint8(TRIMMED_DECIMALS, toDecimals);\n        return TrimmedAmount(\n            uint64(scale(amount.amount, amount.decimals, actualToDecimals)), actualToDecimals\n        );\n    }\n\n    function max(uint8 decimals) internal pure returns (TrimmedAmount memory) {\n        uint8 actualDecimals = minUint8(TRIMMED_DECIMALS, decimals);\n        return TrimmedAmount(type(uint64).max, actualDecimals);\n    }\n\n    /// @dev trim the amount to target decimals.\n    ///      The actual resulting decimals is the minimum of TRIMMED_DECIMALS,\n    ///      fromDecimals, and toDecimals. This ensures that no dust is\n    ///      destroyed on either side of the transfer.\n    /// @param amt the amount to be trimmed\n    /// @param fromDecimals the original decimals of the amount\n    /// @param toDecimals the target decimals of the amount\n    ///\n    function trim(\n        uint256 amt,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (TrimmedAmount memory) {\n        uint8 actualToDecimals = minUint8(minUint8(TRIMMED_DECIMALS, fromDecimals), toDecimals);\n        uint256 amountScaled = scale(amt, fromDecimals, actualToDecimals);\n\n        // NOTE: amt after trimming must fit into uint64 (that's the point of\n        // trimming, as Solana only supports uint64 for token amts)\n        if (amountScaled > type(uint64).max) {\n            revert AmountTooLarge(amt);\n        }\n        return TrimmedAmount(uint64(amountScaled), actualToDecimals);\n    }\n\n    function untrim(TrimmedAmount memory amt, uint8 toDecimals) internal pure returns (uint256) {\n        (uint256 deNorm, uint8 fromDecimals) = unwrap(amt);\n        uint256 amountScaled = scale(deNorm, fromDecimals, toDecimals);\n\n        return amountScaled;\n    }\n}"
    },
    {
      "filename": "evm/src/NttManager/NttManager.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\nimport \"wormhole-solidity-sdk/Utils.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\n\nimport \"../libraries/RateLimiter.sol\";\n\nimport \"../interfaces/INttManager.sol\";\nimport \"../interfaces/INttManagerEvents.sol\";\nimport \"../interfaces/INTTToken.sol\";\nimport \"../interfaces/ITransceiver.sol\";\n\nimport {NttManagerState} from \"./NttManagerState.sol\";\n\ncontract NttManager is INttManager, NttManagerState {\n    using BytesParsing for bytes;\n    using SafeERC20 for IERC20;\n    using TrimmedAmountLib for uint256;\n    using TrimmedAmountLib for TrimmedAmount;\n\n    constructor(\n        address _token,\n        Mode _mode,\n        uint16 _chainId,\n        uint64 _rateLimitDuration,\n        bool _skipRateLimiting\n    ) NttManagerState(_token, _mode, _chainId, _rateLimitDuration, _skipRateLimiting) {}\n\n    // ==================== External Interface ===============================================\n\n    /// @inheritdoc INttManager\n    function transfer(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient\n    ) external payable nonReentrant whenNotPaused returns (uint64) {\n        return _transferEntryPoint(amount, recipientChain, recipient, false, new bytes(1));\n    }\n\n    /// @inheritdoc INttManager\n    function transfer(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        bool shouldQueue,\n        bytes memory transceiverInstructions\n    ) external payable nonReentrant whenNotPaused returns (uint64) {\n        return _transferEntryPoint(\n            amount, recipientChain, recipient, shouldQueue, transceiverInstructions\n        );\n    }\n\n    /// @inheritdoc INttManager\n    function quoteDeliveryPrice(\n        uint16 recipientChain,\n        TransceiverStructs.TransceiverInstruction[] memory transceiverInstructions,\n        address[] memory enabledTransceivers\n    ) public view returns (uint256[] memory, uint256) {\n        uint256 numEnabledTransceivers = enabledTransceivers.length;\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n\n        uint256[] memory priceQuotes = new uint256[](numEnabledTransceivers);\n        uint256 totalPriceQuote = 0;\n        for (uint256 i = 0; i < numEnabledTransceivers; i++) {\n            address transceiverAddr = enabledTransceivers[i];\n            uint8 registeredTransceiverIndex = transceiverInfos[transceiverAddr].index;\n            uint256 transceiverPriceQuote = ITransceiver(transceiverAddr).quoteDeliveryPrice(\n                recipientChain, transceiverInstructions[registeredTransceiverIndex]\n            );\n            priceQuotes[i] = transceiverPriceQuote;\n            totalPriceQuote += transceiverPriceQuote;\n        }\n        return (priceQuotes, totalPriceQuote);\n    }\n\n    /// @inheritdoc INttManager\n    function attestationReceived(\n        uint16 sourceChainId,\n        bytes32 sourceNttManagerAddress,\n        TransceiverStructs.NttManagerMessage memory payload\n    ) external onlyTransceiver {\n        _verifyPeer(sourceChainId, sourceNttManagerAddress);\n\n        bytes32 nttManagerMessageHash =\n            TransceiverStructs.nttManagerMessageDigest(sourceChainId, payload);\n\n        // set the attested flag for this transceiver.\n        // NOTE: Attestation is idempotent (bitwise or 1), but we revert\n        // anyway to ensure that the client does not continue to initiate calls\n        // to receive the same message through the same transceiver.\n        if (\n            transceiverAttestedToMessage(\n                nttManagerMessageHash, _getTransceiverInfosStorage()[msg.sender].index\n            )\n        ) {\n            revert TransceiverAlreadyAttestedToMessage(nttManagerMessageHash);\n        }\n        _setTransceiverAttestedToMessage(nttManagerMessageHash, msg.sender);\n\n        if (isMessageApproved(nttManagerMessageHash)) {\n            executeMsg(sourceChainId, sourceNttManagerAddress, payload);\n        }\n    }\n\n    /// @inheritdoc INttManager\n    function executeMsg(\n        uint16 sourceChainId,\n        bytes32 sourceNttManagerAddress,\n        TransceiverStructs.NttManagerMessage memory message\n    ) public {\n        // verify chain has not forked\n        checkFork(evmChainId);\n\n        bytes32 digest = TransceiverStructs.nttManagerMessageDigest(sourceChainId, message);\n\n        if (!isMessageApproved(digest)) {\n            revert MessageNotApproved(digest);\n        }\n\n        bool msgAlreadyExecuted = _replayProtect(digest);\n        if (msgAlreadyExecuted) {\n            // end execution early to mitigate the possibility of race conditions from transceivers\n            // attempting to deliver the same message when (threshold < number of transceiver messages)\n            // notify client (off-chain process) so they don't attempt redundant msg delivery\n            emit MessageAlreadyExecuted(sourceNttManagerAddress, digest);\n            return;\n        }\n\n        TransceiverStructs.NativeTokenTransfer memory nativeTokenTransfer =\n            TransceiverStructs.parseNativeTokenTransfer(message.payload);\n\n        // verify that the destination chain is valid\n        if (nativeTokenTransfer.toChain != chainId) {\n            revert InvalidTargetChain(nativeTokenTransfer.toChain, chainId);\n        }\n        TrimmedAmount memory nativeTransferAmount =\n            (nativeTokenTransfer.amount.untrim(tokenDecimals_)).trim(tokenDecimals_, tokenDecimals_);\n\n        address transferRecipient = fromWormholeFormat(nativeTokenTransfer.to);\n\n        {\n            // Check inbound rate limits\n            bool isRateLimited = _isInboundAmountRateLimited(nativeTransferAmount, sourceChainId);\n            if (isRateLimited) {\n                // queue up the transfer\n                _enqueueInboundTransfer(digest, nativeTransferAmount, transferRecipient);\n\n                // end execution early\n                return;\n            }\n        }\n\n        // consume the amount for the inbound rate limit\n        _consumeInboundAmount(nativeTransferAmount, sourceChainId);\n        // When receiving a transfer, we refill the outbound rate limit\n        // by the same amount (we call this \"backflow\")\n        _backfillOutboundAmount(nativeTransferAmount);\n\n        _mintOrUnlockToRecipient(digest, transferRecipient, nativeTransferAmount);\n    }\n\n    /// @inheritdoc INttManager\n    function completeInboundQueuedTransfer(bytes32 digest) external nonReentrant whenNotPaused {\n        // find the message in the queue\n        InboundQueuedTransfer memory queuedTransfer = getInboundQueuedTransfer(digest);\n        if (queuedTransfer.txTimestamp == 0) {\n            revert InboundQueuedTransferNotFound(digest);\n        }\n\n        // check that > RATE_LIMIT_DURATION has elapsed\n        if (block.timestamp - queuedTransfer.txTimestamp < rateLimitDuration) {\n            revert InboundQueuedTransferStillQueued(digest, queuedTransfer.txTimestamp);\n        }\n\n        // remove transfer from the queue\n        delete _getInboundQueueStorage()[digest];\n\n        // run it through the mint/unlock logic\n        _mintOrUnlockToRecipient(digest, queuedTransfer.recipient, queuedTransfer.amount);\n    }\n\n    /// @inheritdoc INttManager\n    function completeOutboundQueuedTransfer(uint64 messageSequence)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        returns (uint64)\n    {\n        // find the message in the queue\n        OutboundQueuedTransfer memory queuedTransfer = _getOutboundQueueStorage()[messageSequence];\n        if (queuedTransfer.txTimestamp == 0) {\n            revert OutboundQueuedTransferNotFound(messageSequence);\n        }\n\n        // check that > RATE_LIMIT_DURATION has elapsed\n        if (block.timestamp - queuedTransfer.txTimestamp < rateLimitDuration) {\n            revert OutboundQueuedTransferStillQueued(messageSequence, queuedTransfer.txTimestamp);\n        }\n\n        // remove transfer from the queue\n        delete _getOutboundQueueStorage()[messageSequence];\n\n        // run it through the transfer logic and skip the rate limit\n        return _transfer(\n            messageSequence,\n            queuedTransfer.amount,\n            queuedTransfer.recipientChain,\n            queuedTransfer.recipient,\n            queuedTransfer.sender,\n            queuedTransfer.transceiverInstructions\n        );\n    }\n\n    // ==================== Internal Business Logic =========================================\n\n    function _sendMessageToTransceivers(\n        uint16 recipientChain,\n        uint256[] memory priceQuotes,\n        TransceiverStructs.TransceiverInstruction[] memory transceiverInstructions,\n        address[] memory enabledTransceivers,\n        bytes memory nttManagerMessage\n    ) internal {\n        uint256 numEnabledTransceivers = enabledTransceivers.length;\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n        bytes32 peerAddress = _getPeersStorage()[recipientChain].peerAddress;\n        // call into transceiver contracts to send the message\n        for (uint256 i = 0; i < numEnabledTransceivers; i++) {\n            address transceiverAddr = enabledTransceivers[i];\n            // send it to the recipient nttManager based on the chain\n            ITransceiver(transceiverAddr).sendMessage{value: priceQuotes[i]}(\n                recipientChain,\n                transceiverInstructions[transceiverInfos[transceiverAddr].index],\n                nttManagerMessage,\n                peerAddress\n            );\n        }\n    }\n\n    function _transferEntryPoint(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        bool shouldQueue,\n        bytes memory transceiverInstructions\n    ) internal returns (uint64) {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n\n        if (recipient == bytes32(0)) {\n            revert InvalidRecipient();\n        }\n\n        {\n            // Lock/burn tokens before checking rate limits\n            // use transferFrom to pull tokens from the user and lock them\n            // query own token balance before transfer\n            uint256 balanceBefore = _getTokenBalanceOf(token, address(this));\n\n            // transfer tokens\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n            // query own token balance after transfer\n            uint256 balanceAfter = _getTokenBalanceOf(token, address(this));\n\n            // correct amount for potential transfer fees\n            amount = balanceAfter - balanceBefore;\n            if (mode == Mode.BURNING) {\n                {\n                    // NOTE: We don't account for burn fees in this code path.\n                    // We verify that the user's change in balance is equal to the amount that's burned.\n                    // Accounting for burn fees can be non-trivial, since there\n                    // is no standard way to account for the fee if the fee amount\n                    // is taken out of the burn amount.\n                    // For example, if there's a fee of 1 which is taken out of the\n                    // amount, then burning 20 tokens would result in a transfer of only 19 tokens.\n                    // However, the difference in the user's balance would only show 20.\n                    // Since there is no standard way to query for burn fee amounts with burnable tokens,\n                    // and NTT would be used on a per-token basis, implementing this functionality\n                    // is left to integrating projects who may need to account for burn fees on their tokens.\n                    ERC20Burnable(token).burn(amount);\n\n                    // tokens held by the contract after the operation should be the same as before\n                    uint256 balanceAfterBurn = _getTokenBalanceOf(token, address(this));\n                    if (balanceBefore != balanceAfterBurn) {\n                        revert BurnAmountDifferentThanBalanceDiff(balanceBefore, balanceAfterBurn);\n                    }\n                }\n            }\n        }\n\n        // trim amount after burning to ensure transfer amount matches (amount - fee)\n        TrimmedAmount memory trimmedAmount = _trimTransferAmount(amount, recipientChain);\n        TrimmedAmount memory internalAmount = trimmedAmount.shift(tokenDecimals_);\n\n        // get the sequence for this transfer\n        uint64 sequence = _useMessageSequence();\n\n        {\n            // now check rate limits\n            bool isAmountRateLimited = _isOutboundAmountRateLimited(internalAmount);\n            if (!shouldQueue && isAmountRateLimited) {\n                revert NotEnoughCapacity(getCurrentOutboundCapacity(), amount);\n            }\n            if (shouldQueue && isAmountRateLimited) {\n                // emit an event to notify the user that the transfer is rate limited\n                emit OutboundTransferRateLimited(\n                    msg.sender, sequence, amount, getCurrentOutboundCapacity()\n                );\n\n                // queue up and return\n                _enqueueOutboundTransfer(\n                    sequence,\n                    trimmedAmount,\n                    recipientChain,\n                    recipient,\n                    msg.sender,\n                    transceiverInstructions\n                );\n\n                // refund price quote back to sender\n                _refundToSender(msg.value);\n\n                // return the sequence in the queue\n                return sequence;\n            }\n        }\n\n        // otherwise, consume the outbound amount\n        _consumeOutboundAmount(internalAmount);\n        // When sending a transfer, we refill the inbound rate limit for\n        // that chain by the same amount (we call this \"backflow\")\n        _backfillInboundAmount(internalAmount, recipientChain);\n\n        return _transfer(\n            sequence, trimmedAmount, recipientChain, recipient, msg.sender, transceiverInstructions\n        );\n    }\n\n    function _transfer(\n        uint64 sequence,\n        TrimmedAmount memory amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        address sender,\n        bytes memory transceiverInstructions\n    ) internal returns (uint64 msgSequence) {\n        // cache enabled transceivers to avoid multiple storage reads\n        address[] memory enabledTransceivers = _getEnabledTransceiversStorage();\n\n        TransceiverStructs.TransceiverInstruction[] memory instructions = TransceiverStructs\n            .parseTransceiverInstructions(transceiverInstructions, enabledTransceivers.length);\n\n        (uint256[] memory priceQuotes, uint256 totalPriceQuote) =\n            quoteDeliveryPrice(recipientChain, instructions, enabledTransceivers);\n        {\n            // check up front that msg.value will cover the delivery price\n            if (msg.value < totalPriceQuote) {\n                revert DeliveryPaymentTooLow(totalPriceQuote, msg.value);\n            }\n\n            // refund user extra excess value from msg.value\n            uint256 excessValue = msg.value - totalPriceQuote;\n            if (excessValue > 0) {\n                _refundToSender(excessValue);\n            }\n        }\n\n        // push it on the stack again to avoid a stack too deep error\n        uint64 seq = sequence;\n\n        TransceiverStructs.NativeTokenTransfer memory ntt = TransceiverStructs.NativeTokenTransfer(\n            amount, toWormholeFormat(token), recipient, recipientChain\n        );\n\n        // construct the NttManagerMessage payload\n        bytes memory encodedNttManagerPayload = TransceiverStructs.encodeNttManagerMessage(\n            TransceiverStructs.NttManagerMessage(\n                seq, toWormholeFormat(sender), TransceiverStructs.encodeNativeTokenTransfer(ntt)\n            )\n        );\n\n        // send the message\n        _sendMessageToTransceivers(\n            recipientChain, priceQuotes, instructions, enabledTransceivers, encodedNttManagerPayload\n        );\n\n        // push it on the stack again to avoid a stack too deep error\n        TrimmedAmount memory amt = amount;\n        uint16 destinationChain = recipientChain;\n\n        emit TransferSent(\n            recipient, amt.untrim(tokenDecimals_), totalPriceQuote, destinationChain, seq\n        );\n\n        // return the sequence number\n        return sequence;\n    }\n\n    function _mintOrUnlockToRecipient(\n        bytes32 digest,\n        address recipient,\n        TrimmedAmount memory amount\n    ) internal {\n        // calculate proper amount of tokens to unlock/mint to recipient\n        // untrim the amount\n        uint256 untrimmedAmount = amount.untrim(tokenDecimals_);\n\n        emit TransferRedeemed(digest);\n\n        if (mode == Mode.LOCKING) {\n            // unlock tokens to the specified recipient\n            IERC20(token).safeTransfer(recipient, untrimmedAmount);\n        } else if (mode == Mode.BURNING) {\n            // mint tokens to the specified recipient\n            INTTToken(token).mint(recipient, untrimmedAmount);\n        } else {\n            revert InvalidMode(uint8(mode));\n        }\n    }\n\n    /// @inheritdoc INttManager\n    function tokenDecimals() public view override(INttManager, RateLimiter) returns (uint8) {\n        return tokenDecimals_;\n    }\n\n    // ==================== Internal Helpers ===============================================\n\n    function _refundToSender(uint256 refundAmount) internal {\n        // refund the price quote back to sender\n        (bool refundSuccessful,) = payable(msg.sender).call{value: refundAmount}(\"\");\n\n        // check success\n        if (!refundSuccessful) {\n            revert RefundFailed(refundAmount);\n        }\n    }\n\n    function _trimTransferAmount(\n        uint256 amount,\n        uint16 toChain\n    ) internal view returns (TrimmedAmount memory) {\n        uint8 toDecimals = _getPeersStorage()[toChain].tokenDecimals;\n\n        if (toDecimals == 0) {\n            revert InvalidPeerDecimals();\n        }\n\n        TrimmedAmount memory trimmedAmount;\n        {\n            trimmedAmount = amount.trim(tokenDecimals_, toDecimals);\n            // don't deposit dust that can not be bridged due to the decimal shift\n            uint256 newAmount = trimmedAmount.untrim(tokenDecimals_);\n            if (amount != newAmount) {\n                revert TransferAmountHasDust(amount, amount - newAmount);\n            }\n        }\n\n        return trimmedAmount;\n    }\n\n    function _getTokenBalanceOf(\n        address tokenAddr,\n        address accountAddr\n    ) internal view returns (uint256) {\n        (, bytes memory queriedBalance) =\n            tokenAddr.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, accountAddr));\n        return abi.decode(queriedBalance, (uint256));\n    }\n}"
    }
  ]
}