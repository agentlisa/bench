{
  "Title": "```LibUnripe::getTotalRecapitalizedPercent``` returns wrong ```recapitalizedPercent``` if ```totalUsdNeeded``` is 0",
  "Content": "# ```LibUnripe::getTotalRecapitalizedPercent``` returns wrong ```recapitalizedPercent``` if ```totalUsdNeeded``` is 0\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/libraries/LibUnripe.sol#L181\">https://github.com/Cyfrin/2024-05-Beanstalk-3/blob/662d26f12ee219ee92dc485c06e01a4cb5ee8dfb/protocol/contracts/libraries/LibUnripe.sol#L181</a>\n\n\n## Summary\nThe ```LibUnripe::getTotalRecapitalizedPercent``` is designed to returns the total percentage that beanstalk has recapitalized (```recapitalizedPercent```). This calculation is based on the ratio of the amount recapitalized (```s.recapitalized```) to the total dollar amount needed to recapitalize Beanstalk (```totalUsdNeeded```). The function contains a conditional statement for handling the scenario where if ```totalUsdNeeded``` is equal to 0 returns 0. \n\nIn the case of ```totalUsdNeeded``` is equal to 0, meaning the recapitalization is completed, the ```recapitalizedPercent``` should be 100% but the function returns 0. \n\nAs indicated in the natspec comment \"@dev this is calculated by the ratio of s.recapitalized and the total dollars the barnraise needs to raise returns the same precision as `getRecapPaidPercentAmount` (100% recapitalized = 1e6)\". So the ```if``` statement in the function should return ```1e6``` (100% recapitalized).\n\n## Vulnerability Details\n```solidity\n function getTotalRecapitalizedPercent() internal view returns (uint256 recapitalizedPercent) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 totalUsdNeeded = LibFertilizer.getTotalRecapDollarsNeeded();\n@>        if(totalUsdNeeded == 0) return 0;\n        return s.recapitalized.mul(DECIMALS).div(totalUsdNeeded);\n    }\n```\n\n## Impact\nThe ```LibUnripe::getTotalRecapitalizedPercent``` is designed to returns the total percentage that beanstalk has recapitalized (```recapitalizedPercent```). In the case of the total dollar amount needed to recapitalize Beanstalk is 0 (```totalUsdNeeded==0```), the ```recapitalizedPercent``` should be 100% (all recapitalized) and not 0 as returned by the ```if``` statement into the function. This function is called in several get functions (```UnripeFacet::getLockedBeansUnderlyingUnripeBean```, ```UnripeFacet::getPercentPenalty```, etc), returning a wrong result in the case of ```totalUsdNeeded==0```).\n\n\n## Tools Used\nManual review\n\n## Recommendations\n```diff\n function getTotalRecapitalizedPercent() internal view returns (uint256 recapitalizedPercent) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 totalUsdNeeded = LibFertilizer.getTotalRecapDollarsNeeded();\n-        if(totalUsdNeeded == 0) return 0;\n+       if(totalUsdNeeded == 0) return 1e6;\n        return s.recapitalized.mul(DECIMALS).div(totalUsdNeeded);\n    }\n```\n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clvo5kwin00078k6jhhjobn22",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/LibUnripe.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IBean} from \"../interfaces/IBean.sol\";\nimport {AppStorage, LibAppStorage} from \"./LibAppStorage.sol\";\nimport {C} from \"../C.sol\";\nimport {LibWell} from \"./Well/LibWell.sol\";\nimport {Call, IWell} from \"contracts/interfaces/basin/IWell.sol\";\nimport {IWellFunction} from \"contracts/interfaces/basin/IWellFunction.sol\";\nimport {LibLockedUnderlying} from \"./LibLockedUnderlying.sol\";\nimport {LibFertilizer} from \"./LibFertilizer.sol\";\n\n/**\n * @title LibUnripe\n * @author Publius\n * @notice Library for handling functionality related to Unripe Tokens and their Ripe Tokens.\n */\nlibrary LibUnripe {\n    using SafeMath for uint256;\n\n    event ChangeUnderlying(address indexed token, int256 underlying);\n    event SwitchUnderlyingToken(address indexed token, address indexed underlyingToken);\n\n    uint256 constant DECIMALS = 1e6;\n\n    /**\n     * @notice Returns the percentage that Unripe Beans have been recapitalized.\n     */\n    function percentBeansRecapped() internal view returns (uint256 percent) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return\n            s.u[C.UNRIPE_BEAN].balanceOfUnderlying.mul(DECIMALS).div(C.unripeBean().totalSupply());\n    }\n\n    /**\n     * @notice Returns the percentage that Unripe LP have been recapitalized.\n     */\n    function percentLPRecapped() internal view returns (uint256 percent) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return C.unripeLPPerDollar().mul(s.recapitalized).div(C.unripeLP().totalSupply());\n    }\n\n    /**\n     * @notice Increments the underlying balance of an Unripe Token.\n     * @param token The address of the unripe token.\n     * @param amount The amount of the of the unripe token to be added to the storage reserves\n     */\n    function incrementUnderlying(address token, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.u[token].balanceOfUnderlying = s.u[token].balanceOfUnderlying.add(amount);\n        emit ChangeUnderlying(token, int256(amount));\n    }\n\n    /**\n     * @notice Decrements the underlying balance of an Unripe Token.\n     * @param token The address of the Unripe Token.\n     * @param amount The amount of the of the Unripe Token to be removed from storage reserves\n     */\n    function decrementUnderlying(address token, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.u[token].balanceOfUnderlying = s.u[token].balanceOfUnderlying.sub(amount);\n        emit ChangeUnderlying(token, -int256(amount));\n    }\n\n    /**\n     * @notice Calculates the amount of Ripe Tokens that underly a given amount of Unripe Tokens.\n     * @param unripeToken The address of the Unripe Token\n     * @param unripe The amount of Unripe Tokens.\n     * @return underlying The amount of Ripe Tokens that underly the Unripe Tokens.\n     */\n    function unripeToUnderlying(\n        address unripeToken,\n        uint256 unripe,\n        uint256 supply\n    ) internal view returns (uint256 underlying) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        underlying = s.u[unripeToken].balanceOfUnderlying.mul(unripe).div(supply);\n    }\n\n    /**\n     * @notice Calculates the amount of Unripe Tokens that are underlaid by a given amount of Ripe Tokens.\n     * @param unripeToken The address of the Unripe Tokens.\n     * @param underlying The amount of Ripe Tokens.\n     * @return unripe The amount of the of the Unripe Tokens that are underlaid by the Ripe Tokens.\n     */\n    function underlyingToUnripe(\n        address unripeToken,\n        uint256 underlying\n    ) internal view returns (uint256 unripe) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        unripe = IBean(unripeToken).totalSupply().mul(underlying).div(\n            s.u[unripeToken].balanceOfUnderlying\n        );\n    }\n\n    /**\n     * @notice Adds Ripe Tokens to an Unripe Token. Also, increments the recapitalized\n     * amount proportionally if the Unripe Token is Unripe LP.\n     * @param token The address of the Unripe Token to add Ripe Tokens to.\n     * @param underlying The amount of the of the underlying token to be taken as input.\n     */\n    function addUnderlying(address token, uint256 underlying) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (token == C.UNRIPE_LP) {\n            uint256 recapped = underlying.mul(s.recapitalized).div(\n                s.u[C.UNRIPE_LP].balanceOfUnderlying\n            );\n            s.recapitalized = s.recapitalized.add(recapped);\n        }\n        incrementUnderlying(token, underlying);\n    }\n\n    /**\n     * @notice Removes Ripe Tokens from an Unripe Token. Also, decrements the recapitalized\n     * amount proportionally if the Unripe Token is Unripe LP.\n     * @param token The address of the unripe token to be removed.\n     * @param underlying The amount of the of the underlying token to be removed.\n     */\n    function removeUnderlying(address token, uint256 underlying) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (token == C.UNRIPE_LP) {\n            uint256 recapped = underlying.mul(s.recapitalized).div(\n                s.u[C.UNRIPE_LP].balanceOfUnderlying\n            );\n            s.recapitalized = s.recapitalized.sub(recapped);\n        }\n        decrementUnderlying(token, underlying);\n    }\n\n    /**\n     * @dev Switches the underlying token of an unripe token.\n     * Should only be called if `s.u[unripeToken].balanceOfUnderlying == 0`.\n     */\n    function switchUnderlyingToken(address unripeToken, address newUnderlyingToken) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.u[unripeToken].underlyingToken = newUnderlyingToken;\n        emit SwitchUnderlyingToken(unripeToken, newUnderlyingToken);\n    }\n\n    /**\n     * @notice Calculates the the penalized amount of Ripe Tokens corresponding to \n     * the amount of Unripe Tokens that are Chopped according to the current Chop Rate.\n     * The new chop rate is %Recapitalized^2.\n     */\n    function getPenalizedUnderlying(\n        address unripeToken,\n        uint256 amount,\n        uint256 supply\n    ) internal view returns (uint256 redeem) {\n        require(isUnripe(unripeToken), \"not vesting\");\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // getTotalRecapDollarsNeeded() queries for the total urLP supply which is burned upon a chop\n        // If the token being chopped is unripeLP, getting the current supply here is inaccurate due to the burn\n        // Instead, we use the supply passed in as an argument to getTotalRecapDollarsNeeded since the supply variable\n        // here is the total urToken supply queried before burnning the unripe token\n\t    uint256 totalUsdNeeded = unripeToken == C.UNRIPE_LP ? LibFertilizer.getTotalRecapDollarsNeeded(supply) \n            : LibFertilizer.getTotalRecapDollarsNeeded();\n        // chop rate = total redeemable * (%DollarRecapitalized)^2 * share of unripe tokens\n        // redeem = totalRipeUnderlying * (usdValueRaised/totalUsdNeeded)^2 * UnripeAmountIn/UnripeSupply;\n        // But totalRipeUnderlying = CurrentUnderlying * totalUsdNeeded/usdValueRaised to get the total underlying\n        // redeem = currentRipeUnderlying * (usdValueRaised/totalUsdNeeded) * UnripeAmountIn/UnripeSupply\n        uint256 underlyingAmount = s.u[unripeToken].balanceOfUnderlying;\n        redeem = underlyingAmount.mul(s.recapitalized).div(totalUsdNeeded).mul(amount).div(supply);\n        // cap `redeem to `balanceOfUnderlying in the case that `s.recapitalized` exceeds `totalUsdNeeded`.\n        // this can occur due to unripe LP chops.\n        if(redeem > underlyingAmount) redeem = underlyingAmount;\n    }\n\n    /**\n     * @notice returns the total percentage that beanstalk has recapitalized.\n     * @dev this is calculated by the ratio of s.recapitalized and the total dollars the barnraise needs to raise.\n     * returns the same precision as `getRecapPaidPercentAmount` (100% recapitalized = 1e6).\n     */\n    function getTotalRecapitalizedPercent() internal view returns (uint256 recapitalizedPercent) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 totalUsdNeeded = LibFertilizer.getTotalRecapDollarsNeeded();\n        if(totalUsdNeeded == 0) return 0;\n        return s.recapitalized.mul(DECIMALS).div(totalUsdNeeded);\n    }\n\n    /**\n     * @notice Returns the amount of beans that are locked in the unripe token.\n     * @dev Locked beans are the beans that are forfeited if the unripe token is chopped.\n     * @param reserves the reserves of the LP that underly the unripe token.\n     * @dev reserves are used as a parameter for gas effiency purposes (see LibEvaluate.calcLPToSupplyRatio}.\n     */\n    function getLockedBeans(\n        uint256[] memory reserves\n    ) internal view returns (uint256 lockedAmount) {\n        lockedAmount = LibLockedUnderlying\n            .getLockedUnderlying(C.UNRIPE_BEAN, getTotalRecapitalizedPercent())\n            .add(getLockedBeansFromLP(reserves));\n    }\n\n    /**\n     * @notice Returns the amount of beans that are locked in the unripeLP token.\n     * @param reserves the reserves of the LP that underly the unripe token.\n     */\n    function getLockedBeansFromLP(\n        uint256[] memory reserves\n    ) internal view returns (uint256 lockedBeanAmount) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        // if reserves return 0, then skip calculations.\n        if (reserves[0] == 0) return 0;\n        uint256 lockedLpAmount = LibLockedUnderlying.getLockedUnderlying(\n            C.UNRIPE_LP,\n            getTotalRecapitalizedPercent()\n        );\n        address underlying = s.u[C.UNRIPE_LP].underlyingToken;\n        uint256 beanIndex = LibWell.getBeanIndexFromWell(underlying);\n\n        // lpTokenSupply is calculated rather than calling totalSupply(),\n        // because the Well's lpTokenSupply is not MEV resistant.\n        Call memory wellFunction = IWell(underlying).wellFunction();\n        uint lpTokenSupply = IWellFunction(wellFunction.target).calcLpTokenSupply(\n            reserves,\n            wellFunction.data\n        );\n        lockedBeanAmount = lockedLpAmount.mul(reserves[beanIndex]).div(lpTokenSupply);\n    }\n\n    /**\n     * @notice Calculates the penalized amount based the amount of Sprouts that are Rinsable\n     * or Rinsed (Fertilized).\n     * @param amount The amount of the Unripe Tokens.\n     * @return penalizedAmount The penalized amount of the Ripe Tokens received from Chopping.\n     */\n    function getRecapPaidPercentAmount(\n        uint256 amount\n    ) internal view returns (uint256 penalizedAmount) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.fertilizedIndex.mul(amount).div(s.unfertilizedIndex);\n    }\n\n    /**\n     * @notice Returns true if the token is unripe.\n     */\n    function isUnripe(address unripeToken) internal view returns (bool unripe) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        unripe = s.u[unripeToken].underlyingToken != address(0);\n    }\n\n    function getTotalRecapDollarsNeeded() internal view returns (uint256 totalUsdNeeded) {\n        return LibFertilizer.getTotalRecapDollarsNeeded();\n    }\n}"
    }
  ]
}