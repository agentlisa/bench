{
  "Title": "[H-02] denial of service",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53\n\n\n# Vulnerability details\n\nprocessWithdrawals can process limited amount in each call.\nan attacker can push to withdrawals enormous amount of withdrawals with amount = 0.\nin order to stop the dos attack and process the withdrawal, the governance needs to spend as much gas as the attacker.\nif the governance doesn't have enough money to pay for the gas, the withdrawals can't be processed.\n\n## Proof of Concept\nAlice wants to attack vusd, she spend 1millions dollars for gas to push as many withdrawals of amount = 0 as she can.\nif the governance wants to process the deposits after alices empty deposits, they also need to spend at least 1 million dollars for gas in order to process alice's withdrawals first.\nbut the governance doesn't have 1 million dollar so the funds will be locked.\n\n## Recommended Mitigation Steps\nset  a minimum amount of withdrawal. e.g. 1 dollar\n\n```\n    function withdraw(uint amount) external {\n        require(amount >= 10 ** 6);\n        burn(amount);\n        withdrawals.push(Withdrawal(msg.sender, amount));\n    }\n```\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\n\ncontract VUSD is VanillaGovernable, ERC20PresetMinterPauserUpgradeable {\n    using SafeERC20 for IERC20;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n\n    /// @notice vUSD is backed 1:1 with reserveToken (USDC)\n    IERC20 public immutable reserveToken;\n\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    constructor(address _reserveToken) {\n        require(_reserveToken != address(0), \"vUSD: null _reserveToken\");\n        reserveToken = IERC20(_reserveToken);\n    }\n\n    function init(address _governance) external {\n        super.initialize(\"Hubble USD\", \"hUSD\"); // has initializer modifier\n        _setGovernace(_governance);\n        maxWithdrawalProcesses = 100;\n    }\n\n    function mintWithReserve(address to, uint amount) external {\n        reserveToken.safeTransferFrom(msg.sender, address(this), amount);\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external {\n        burn(amount);\n        withdrawals.push(Withdrawal(msg.sender, amount));\n    }\n\n    function processWithdrawals() external {\n        uint reserve = reserveToken.balanceOf(address(this));\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) <= maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n            reserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\n            reserve -= withdrawal.amount;\n            i += 1;\n        }\n        start = i;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external onlyGovernance {\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n}"
    }
  ]
}