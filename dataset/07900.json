{
  "Title": "[G-15]  ",
  "Content": "<h2 id=\"g-15--require-or-revert-statements-that-check-input-arguments-should-be-at-the-top-of-the-function\" style=\"position:relative;\"><a href=\"#g-15--require-or-revert-statements-that-check-input-arguments-should-be-at-the-top-of-the-function\" aria-label=\"g 15  require or revert statements that check input arguments should be at the top of the function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-15]  <code>require()</code> or <code>revert()</code> statements that check input arguments should be at the top of the function</h2>\n<p>Checks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (<strong>2100 gas*</strong>) in a function that may ultimately revert in the unhappy case.</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"84\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">gateway</span><span class=\"mtk1\">/</span><span class=\"mtk12\">L1GraphTokenGateway</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">/// @audit expensive op on line 199</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">201</span><span class=\"mtk1\">:          </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_amount</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">\"INVALID_ZERO_AMOUNT\"</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L201\">https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L201</a></p>\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-the-graph-l2-bridge-contest",
  "Code": [
    {
      "filename": "contracts/gateway/L1GraphTokenGateway.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../arbitrum/L1ArbitrumMessenger.sol\";\nimport \"./GraphTokenGateway.sol\";\n\n/**\n * @title L1 Graph Token Gateway Contract\n * @dev Provides the L1 side of the Ethereum-Arbitrum GRT bridge. Sends GRT to the L2 chain\n * by escrowing them and sending a message to the L2 gateway, and receives tokens from L2 by\n * releasing them from escrow.\n * Based on Offchain Labs' reference implementation and Livepeer's arbitrum-lpt-bridge\n * (See: https://github.com/OffchainLabs/arbitrum/tree/master/packages/arb-bridge-peripherals/contracts/tokenbridge\n * and https://github.com/livepeer/arbitrum-lpt-bridge)\n */\ncontract L1GraphTokenGateway is GraphTokenGateway, L1ArbitrumMessenger {\n    using SafeMath for uint256;\n\n    // Address of the Graph Token contract on L2\n    address public l2GRT;\n    // Address of the Arbitrum Inbox\n    address public inbox;\n    // Address of the Arbitrum Gateway Router on L1\n    address public l1Router;\n    // Address of the L2GraphTokenGateway on L2 that is the counterpart of this gateway\n    address public l2Counterpart;\n    // Address of the BridgeEscrow contract that holds the GRT in the bridge\n    address public escrow;\n    // Addresses for which this mapping is true are allowed to send callhooks in outbound transfers\n    mapping(address => bool) public callhookWhitelist;\n\n    // Emitted when an outbound transfer is initiated, i.e. tokens are deposited from L1 to L2\n    event DepositInitiated(\n        address l1Token,\n        address indexed from,\n        address indexed to,\n        uint256 indexed sequenceNumber,\n        uint256 amount\n    );\n\n    // Emitted when an incoming transfer is finalized, i.e tokens are withdrawn from L2 to L1\n    event WithdrawalFinalized(\n        address l1Token,\n        address indexed from,\n        address indexed to,\n        uint256 indexed exitNum,\n        uint256 amount\n    );\n\n    // Emitted when the Arbitrum Inbox and Gateway Router addresses have been updated\n    event ArbitrumAddressesSet(address inbox, address l1Router);\n    // Emitted when the L2 GRT address has been updated\n    event L2TokenAddressSet(address l2GRT);\n    // Emitted when the counterpart L2GraphTokenGateway address has been updated\n    event L2CounterpartAddressSet(address l2Counterpart);\n    // Emitted when the escrow address has been updated\n    event EscrowAddressSet(address escrow);\n    // Emitted when an address is added to the callhook whitelist\n    event AddedToCallhookWhitelist(address newWhitelisted);\n    // Emitted when an address is removed from the callhook whitelist\n    event RemovedFromCallhookWhitelist(address notWhitelisted);\n\n    /**\n     * @dev Allows a function to be called only by the gateway's L2 counterpart.\n     * The message will actually come from the Arbitrum Bridge, but the Outbox\n     * can tell us who the sender from L2 is.\n     */\n    modifier onlyL2Counterpart() {\n        require(inbox != address(0), \"INBOX_NOT_SET\");\n\n        // a message coming from the counterpart gateway was executed by the bridge\n        IBridge bridge = IInbox(inbox).bridge();\n        require(msg.sender == address(bridge), \"NOT_FROM_BRIDGE\");\n\n        // and the outbox reports that the L2 address of the sender is the counterpart gateway\n        address l2ToL1Sender = IOutbox(bridge.activeOutbox()).l2ToL1Sender();\n        require(l2ToL1Sender == l2Counterpart, \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    /**\n     * @dev Initialize this contract.\n     * The contract will be paused.\n     * Note some parameters have to be set separately as they are generally\n     * not expected to be available at initialization time:\n     * - inbox  and l1Router using setArbitrumAddresses\n     * - l2GRT using setL2TokenAddress\n     * - l2Counterpart using setL2CounterpartAddress\n     * - escrow using setEscrowAddress\n     * - whitelisted callhook callers using addToCallhookWhitelist\n     * - pauseGuardian using setPauseGuardian\n     * @param _controller Address of the Controller that manages this contract\n     */\n    function initialize(address _controller) external onlyImpl {\n        Managed._initialize(_controller);\n        _paused = true;\n    }\n\n    /**\n     * @dev Sets the addresses for L1 contracts provided by Arbitrum\n     * @param _inbox Address of the Inbox that is part of the Arbitrum Bridge\n     * @param _l1Router Address of the Gateway Router\n     */\n    function setArbitrumAddresses(address _inbox, address _l1Router) external onlyGovernor {\n        require(_inbox != address(0), \"INVALID_INBOX\");\n        require(_l1Router != address(0), \"INVALID_L1_ROUTER\");\n        inbox = _inbox;\n        l1Router = _l1Router;\n        emit ArbitrumAddressesSet(_inbox, _l1Router);\n    }\n\n    /**\n     * @dev Sets the address of the L2 Graph Token\n     * @param _l2GRT Address of the GRT contract on L2\n     */\n    function setL2TokenAddress(address _l2GRT) external onlyGovernor {\n        require(_l2GRT != address(0), \"INVALID_L2_GRT\");\n        l2GRT = _l2GRT;\n        emit L2TokenAddressSet(_l2GRT);\n    }\n\n    /**\n     * @dev Sets the address of the counterpart gateway on L2\n     * @param _l2Counterpart Address of the corresponding L2GraphTokenGateway on Arbitrum\n     */\n    function setL2CounterpartAddress(address _l2Counterpart) external onlyGovernor {\n        require(_l2Counterpart != address(0), \"INVALID_L2_COUNTERPART\");\n        l2Counterpart = _l2Counterpart;\n        emit L2CounterpartAddressSet(_l2Counterpart);\n    }\n\n    /**\n     * @dev Sets the address of the escrow contract on L1\n     * @param _escrow Address of the BridgeEscrow\n     */\n    function setEscrowAddress(address _escrow) external onlyGovernor {\n        require(_escrow != address(0) && Address.isContract(_escrow), \"INVALID_ESCROW\");\n        escrow = _escrow;\n        emit EscrowAddressSet(_escrow);\n    }\n\n    /**\n     * @dev Adds an address to the callhook whitelist.\n     * This address will be allowed to include callhooks when transferring tokens.\n     * @param _newWhitelisted Address to add to the whitelist\n     */\n    function addToCallhookWhitelist(address _newWhitelisted) external onlyGovernor {\n        require(_newWhitelisted != address(0), \"INVALID_ADDRESS\");\n        require(!callhookWhitelist[_newWhitelisted], \"ALREADY_WHITELISTED\");\n        callhookWhitelist[_newWhitelisted] = true;\n        emit AddedToCallhookWhitelist(_newWhitelisted);\n    }\n\n    /**\n     * @dev Removes an address from the callhook whitelist.\n     * This address will no longer be allowed to include callhooks when transferring tokens.\n     * @param _notWhitelisted Address to remove from the whitelist\n     */\n    function removeFromCallhookWhitelist(address _notWhitelisted) external onlyGovernor {\n        require(_notWhitelisted != address(0), \"INVALID_ADDRESS\");\n        require(callhookWhitelist[_notWhitelisted], \"NOT_WHITELISTED\");\n        callhookWhitelist[_notWhitelisted] = false;\n        emit RemovedFromCallhookWhitelist(_notWhitelisted);\n    }\n\n    /**\n     * @notice Creates and sends a retryable ticket to transfer GRT to L2 using the Arbitrum Inbox.\n     * The tokens are escrowed by the gateway until they are withdrawn back to L1.\n     * The ticket must be redeemed on L2 to receive tokens at the specified address.\n     * Note that the caller must previously allow the gateway to spend the specified amount of GRT.\n     * @dev maxGas and gasPriceBid must be set using Arbitrum's NodeInterface.estimateRetryableTicket method.\n     * Also note that whitelisted senders (some protocol contracts) can include additional calldata\n     * for a callhook to be executed on the L2 side when the tokens are received. In this case, the L2 transaction\n     * can revert if the callhook reverts, potentially locking the tokens on the bridge if the callhook\n     * never succeeds. This requires extra care when adding contracts to the whitelist, but is necessary to ensure that\n     * the tickets can be retried in the case of a temporary failure, and to ensure the atomicity of callhooks\n     * with token transfers.\n     * @param _l1Token L1 Address of the GRT contract (needed for compatibility with Arbitrum Gateway Router)\n     * @param _to Recipient address on L2\n     * @param _amount Amount of tokens to tranfer\n     * @param _maxGas Gas limit for L2 execution of the ticket\n     * @param _gasPriceBid Price per gas on L2\n     * @param _data Encoded maxSubmissionCost and sender address along with additional calldata\n     * @return Sequence number of the retryable ticket created by Inbox\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable override notPaused returns (bytes memory) {\n        IGraphToken token = graphToken();\n        require(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n        require(_amount > 0, \"INVALID_ZERO_AMOUNT\");\n        require(_to != address(0), \"INVALID_DESTINATION\");\n\n        // nested scopes to avoid stack too deep errors\n        address from;\n        uint256 seqNum;\n        {\n            uint256 maxSubmissionCost;\n            bytes memory outboundCalldata;\n            {\n                bytes memory extraData;\n                (from, maxSubmissionCost, extraData) = parseOutboundData(_data);\n                require(\n                    extraData.length == 0 || callhookWhitelist[msg.sender] == true,\n                    \"CALL_HOOK_DATA_NOT_ALLOWED\"\n                );\n                require(maxSubmissionCost > 0, \"NO_SUBMISSION_COST\");\n\n                {\n                    // makes sure only sufficient ETH is supplied as required for successful redemption on L2\n                    // if a user does not desire immediate redemption they should provide\n                    // a msg.value of AT LEAST maxSubmissionCost\n                    uint256 expectedEth = maxSubmissionCost.add(_maxGas.mul(_gasPriceBid));\n                    require(msg.value >= expectedEth, \"WRONG_ETH_VALUE\");\n                }\n                outboundCalldata = getOutboundCalldata(_l1Token, from, _to, _amount, extraData);\n            }\n            {\n                L2GasParams memory gasParams = L2GasParams(\n                    maxSubmissionCost,\n                    _maxGas,\n                    _gasPriceBid\n                );\n                // transfer tokens to escrow\n                token.transferFrom(from, escrow, _amount);\n                seqNum = sendTxToL2(\n                    inbox,\n                    l2Counterpart,\n                    from,\n                    msg.value,\n                    0,\n                    gasParams,\n                    outboundCalldata\n                );\n            }\n        }\n        emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);\n\n        return abi.encode(seqNum);\n    }\n\n    /**\n     * @notice Receives withdrawn tokens from L2\n     * The equivalent tokens are released from escrow and sent to the destination.\n     * @dev can only accept transactions coming from the L2 GRT Gateway.\n     * The last parameter is unused but kept for compatibility with Arbitrum gateways,\n     * and the encoded exitNum is assumed to be 0.\n     * @param _l1Token L1 Address of the GRT contract (needed for compatibility with Arbitrum Gateway Router)\n     * @param _from Address of the sender\n     * @param _to Recepient address on L1\n     * @param _amount Amount of tokens transferred\n     */\n    function finalizeInboundTransfer(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata // _data, contains exitNum, unused by this contract\n    ) external payable override notPaused onlyL2Counterpart {\n        IGraphToken token = graphToken();\n        require(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n\n        uint256 escrowBalance = token.balanceOf(escrow);\n        // If the bridge doesn't have enough tokens, something's very wrong!\n        require(_amount <= escrowBalance, \"BRIDGE_OUT_OF_FUNDS\");\n        token.transferFrom(escrow, _to, _amount);\n\n        emit WithdrawalFinalized(_l1Token, _from, _to, 0, _amount);\n    }\n\n    /**\n     * @notice Decodes calldata required for migration of tokens\n     * @dev Data must include maxSubmissionCost, extraData can be left empty. When the router\n     * sends an outbound message, data also contains the from address.\n     * @param _data encoded callhook data\n     * @return Sender of the tx\n     * @return Base ether value required to keep retryable ticket alive\n     * @return Additional data sent to L2\n     */\n    function parseOutboundData(bytes memory _data)\n        private\n        view\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address from;\n        uint256 maxSubmissionCost;\n        bytes memory extraData;\n        if (msg.sender == l1Router) {\n            // Data encoded by the Gateway Router includes the sender address\n            (from, extraData) = abi.decode(_data, (address, bytes));\n        } else {\n            from = msg.sender;\n            extraData = _data;\n        }\n        // User-encoded data contains the max retryable ticket submission cost\n        // and additional L2 calldata\n        (maxSubmissionCost, extraData) = abi.decode(extraData, (uint256, bytes));\n        return (from, maxSubmissionCost, extraData);\n    }\n\n    /**\n     * @notice Creates calldata required to create a retryable ticket\n     * @dev encodes the target function with its params which\n     * will be called on L2 when the retryable ticket is redeemed\n     * @param _l1Token Address of the Graph token contract on L1\n     * @param _from Address on L1 from which we're transferring tokens\n     * @param _to Address on L2 to which we're transferring tokens\n     * @param _amount Amount of GRT to transfer\n     * @param _data Additional call data for the L2 transaction, which must be empty unless the caller is whitelisted\n     * @return Encoded calldata (including function selector) for the L2 transaction\n     */\n    function getOutboundCalldata(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public pure returns (bytes memory) {\n        bytes memory emptyBytes;\n\n        return\n            abi.encodeWithSelector(\n                ITokenGateway.finalizeInboundTransfer.selector,\n                _l1Token,\n                _from,\n                _to,\n                _amount,\n                abi.encode(emptyBytes, _data)\n            );\n    }\n\n    /**\n     * @notice Calculate the L2 address of a bridged token\n     * @dev In our case, this would only work for GRT.\n     * @param _l1ERC20 address of L1 GRT contract\n     * @return L2 address of the bridged GRT token\n     */\n    function calculateL2TokenAddress(address _l1ERC20) external view override returns (address) {\n        IGraphToken token = graphToken();\n        if (_l1ERC20 != address(token)) {\n            return address(0);\n        }\n        return l2GRT;\n    }\n}"
    }
  ]
}