{
  "Title": "M-6: Freezing roles in ERC721NFTProduct and ERC1155NFTProduct is moot",
  "Content": "# Issue M-6: Freezing roles in ERC721NFTProduct and ERC1155NFTProduct is moot \n\nSource: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/81 \n\n## Found by \n0x52\n\n## Summary\n\nIn ERC721NFTProduct and ERC1155NFTProduct roles can be frozen which is supposed to lock role to current addresses and not allow any changes. The problem is that admin can still use AccessControlUpgradable#grantRole and revokeRole to grant and remove roles to addresses because hasRole allows \"ADMIN_ROLE\" to bypass all role restrictions even \"DEFAULT_ADMIN_ROLE\".\n\n## Vulnerability Detail\n\n    function hasRole(bytes32 role, address account)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            super.hasRole(ADMIN_ROLE, account) || super.hasRole(role, account);\n    }\n\nIn GranularRoles.sol and AccessControlUpgradable.sol, developers are careful to never grant the \"DEFAULT_ADMIN_ROLE\" to any user. Additionally they never set the admin role of any role so that it's admin will remain \"DEFAULT_ADMIN_ROLE\". In theory this should make so that there is no way to grant or revoke roles outside of GranularRoles#_initRoles and updateRoles. The issue is that the override by GranularRoles#hasRole allows \"ADMIN_ROLE\" to bypass any role restriction including \"DEFAULT_ADMIN_ROLE\". This allows \"ADMIN_ROLE\" to directly call AccessControlUpgradable#grantRole and revokeRole, which makes the entire freezing system useless as it doesn't actually stop any role modification.\n\n## Impact\n\nFreezing roles doesn't actually prevent \"ADMIN_ROLE\" from modifying roles as intended. Submitting as high due to gross over-extension of admin authority clearly violating intended guardrails.\n\n## Code Snippet\n\n[GranularRoles.sol#L87-L96](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/lib/GranularRoles.sol#L87-L96)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOverride AccessControlUpgradable#grantRole and revokeRole in GranularRoles.sol to revert when called:\n\n     GranularRoles.sol\n\n    +   function grantRole(bytes32 role, address account) public virtual override {\n    +       revert();\n    +   }\n\n    +   function revokeRole(bytes32 role, address account) public virtual override {\n    +       revert();\n    +   }\n\n## Discussion\n\n**Evert0x**\n\nAdmin role having more power than intended is not a med/high issue for the protocol team.\n\n**hyperspacebunny**\n\n@Evert0x This actually is valid and pretty high priority for us since it's a workaround for some pretty explicit rules in our permissions system. Can you reopen it?\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/15\n\n**rayn731**\n\nThe fix will disable `DEFAULT_ADMIN_ROLE` to grant/revoke roles, but `_owner` still has the ability to grant/revoke roles even if all roles are frozen?\n\n**hyperspacebunny**\n\nYup, our current intent is that the owner should always have control over the roles if they want to self-manage, freezing is just to remove the delegation to `ADMIN_ROLE`\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/14",
  "Code": [
    {
      "filename": "evm-minting-master/contracts/lib/GranularRoles.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\n/*\n * Custom roles handling abstract contract.\n * Used for fine-grained access controls to contracts.\n * Supported roles are:\n * - `ADMIN_ROLE`, is granted to the initializer and one other account specified during intialization\n * - `MINT_ROLE`, is used for minting tokens\n * - `UPDATE_CONTRACT_ROLE`, is used for updating the contract\n * - `BURN_ROLE`, is used for burning tokens\n * - `TRANSFER_ROLE`, is used for transferring tokens\n * `ADMIN_ROLE` has all the access rights for all the roles.\n *\n * Each role besides the `ADMIN_ROLE` can have any amount of addresses and can be made immutable.\n */\nabstract contract GranularRoles is AccessControlUpgradeable {\n    // Roles list\n    // Admin role can have 2 addresses:\n    // one address same as (_owner) which can be changed\n    // one for NFTPort API access which can only be revoked\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    // Following roles can have multiple addresses, can be changed by admin or update contract role\n    bytes32 public constant MINT_ROLE = keccak256(\"MINT_ROLE\");\n    bytes32 public constant UPDATE_CONTRACT_ROLE =\n        keccak256(\"UPDATE_CONTRACT_ROLE\");\n    bytes32 public constant UPDATE_TOKEN_ROLE = keccak256(\"UPDATE_TOKEN_ROLE\");\n    bytes32 public constant BURN_ROLE = keccak256(\"BURN_ROLE\");\n    bytes32 public constant TRANSFER_ROLE = keccak256(\"TRANSFER_ROLE\");\n\n    /*\n     * Used for intializing and updating roles\n     * Each role can have any number of addresses attached to it and can be frozen separately,\n     * meaning any further updates to it are disabled.\n     * Cannot be used to update or initialize `ADMIN_ROLE`.\n     */\n    struct RolesAddresses {\n        bytes32 role;\n        address[] addresses;\n        bool frozen;\n    }\n\n    // Contract owner address, this address can edit the contract on OpenSea and has `ADMIN_ROLE`\n    address internal _owner;\n    // Initialized as the address that initializes the contract.\n    address internal _nftPort;\n\n    // Used to get roles enumeration\n    mapping(bytes32 => address[]) internal _rolesAddressesIndexed;\n    // Mapping from role to boolean that shows if role can be updated\n    mapping(bytes32 => bool) internal _rolesFrozen;\n\n    // Event emitted when `transferOwnership` called by current owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /*\n     * Contract owner address\n     * @dev Required for easy integration with OpenSea, the owner address can edit the collection there\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    // Transfer contract ownership, only callable by the current owner\n    function transferOwnership(address newOwner) public {\n        require(newOwner != _owner, \"GranularRoles: already the owner\");\n        require(msg.sender == _owner, \"GranularRoles: not the owner\");\n        _revokeRole(ADMIN_ROLE, _owner);\n        address previousOwner = _owner;\n        _owner = newOwner;\n        _grantRole(ADMIN_ROLE, _owner);\n        emit OwnershipTransferred(previousOwner, newOwner);\n    }\n\n    // Removes `ADMIN_ROLE` from the account that initialized the contract\n    function revokeNFTPortPermissions() public onlyRole(ADMIN_ROLE) {\n        _revokeRole(ADMIN_ROLE, _nftPort);\n        _nftPort = address(0);\n    }\n\n    // Admin role has all access granted by default\n    function hasRole(bytes32 role, address account)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            super.hasRole(ADMIN_ROLE, account) || super.hasRole(role, account);\n    }\n\n    /**\n     * Initialize roles, should only be called once, for updating `_updateRoles` is used.\n     * Can only be used to set the `_owner` and `_nftport` addresses,\n     * or any amount of accounts for any supported role.\n     */\n    function _initRoles(address owner_, RolesAddresses[] memory rolesAddresses)\n        internal\n    {\n        _owner = owner_;\n        _nftPort = msg.sender;\n        _grantRole(ADMIN_ROLE, _owner);\n        _grantRole(ADMIN_ROLE, _nftPort);\n\n        // Loop through all roles from the input\n        for (\n            uint256 roleIndex = 0;\n            roleIndex < rolesAddresses.length;\n            roleIndex++\n        ) {\n            bytes32 role = rolesAddresses[roleIndex].role;\n            // Check if the role is supported and is not `ADMIN_ROLE`\n            require(\n                _regularRoleValid(role),\n                string(\n                    abi.encodePacked(\n                        \"GranularRoles: invalid role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n            // Loop through all the addresses for the role being processed\n            // Grant the given role to all the specified addresses\n            // and add them to the roles enumaration `_rolesAddressesIndexed`\n            for (\n                uint256 addressIndex = 0;\n                addressIndex < rolesAddresses[roleIndex].addresses.length;\n                addressIndex++\n            ) {\n                _grantRole(\n                    role,\n                    rolesAddresses[roleIndex].addresses[addressIndex]\n                );\n                _rolesAddressesIndexed[role].push(\n                    rolesAddresses[roleIndex].addresses[addressIndex]\n                );\n            }\n            // If the given role is frozen then further updates to it are disabled\n            if (rolesAddresses[roleIndex].frozen) {\n                _rolesFrozen[role] = true;\n            }\n        }\n    }\n\n    /**\n     * Used for updating and/or freezing roles.\n     * Only callable by accounts with the `ADMIN_ROLE`\n     * and cannot be used to update `ADMIN_ROLE`\n     */\n    function _updateRoles(RolesAddresses[] memory rolesAddresses) internal {\n        if (rolesAddresses.length > 0) {\n            require(\n                hasRole(ADMIN_ROLE, msg.sender),\n                \"GranularRoles: not an admin\"\n            );\n\n            // Loop through all roles from the input\n            for (\n                uint256 roleIndex = 0;\n                roleIndex < rolesAddresses.length;\n                roleIndex++\n            ) {\n                bytes32 role = rolesAddresses[roleIndex].role;\n                // Check if the role is supported and is not `ADMIN_ROLE`\n                require(\n                    _regularRoleValid(role),\n                    string(\n                        abi.encodePacked(\n                            \"GranularRoles: invalid role \",\n                            StringsUpgradeable.toHexString(uint256(role), 32)\n                        )\n                    )\n                );\n                // If given role is frozen then it cannot be updated\n                require(\n                    !_rolesFrozen[role],\n                    string(\n                        abi.encodePacked(\n                            \"GranularRoles: role \",\n                            StringsUpgradeable.toHexString(uint256(role), 32),\n                            \" is frozen\"\n                        )\n                    )\n                );\n                // Loop through all the addresses for the given role\n                // Remove all accounts from the role being processed to add new ones from the input\n                for (\n                    uint256 addressIndex = 0;\n                    addressIndex < _rolesAddressesIndexed[role].length;\n                    addressIndex++\n                ) {\n                    _revokeRole(\n                        role,\n                        _rolesAddressesIndexed[role][addressIndex]\n                    );\n                }\n                delete _rolesAddressesIndexed[role];\n                // Loop through all the addresses for the given role from the input.\n                // Grant roles to given addresses for the role being processed\n                // and add the accounts to the role enumeration.\n                for (\n                    uint256 addressIndex = 0;\n                    addressIndex < rolesAddresses[roleIndex].addresses.length;\n                    addressIndex++\n                ) {\n                    _grantRole(\n                        role,\n                        rolesAddresses[roleIndex].addresses[addressIndex]\n                    );\n                    _rolesAddressesIndexed[role].push(\n                        rolesAddresses[roleIndex].addresses[addressIndex]\n                    );\n                }\n                if (rolesAddresses[roleIndex].frozen) {\n                    _rolesFrozen[role] = true;\n                }\n            }\n        }\n    }\n\n    // Checks if role is valid, does not contain the `ADMIN_ROLE`\n    function _regularRoleValid(bytes32 role) internal pure returns (bool) {\n        return\n            role == MINT_ROLE ||\n            role == UPDATE_CONTRACT_ROLE ||\n            role == UPDATE_TOKEN_ROLE ||\n            role == BURN_ROLE ||\n            role == TRANSFER_ROLE;\n    }\n}"
    }
  ]
}