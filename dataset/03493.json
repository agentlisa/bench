{
  "Title": "[L05] Misleading and / or erroneous docstrings and comments",
  "Content": "In the `OVM_CanonicalTransactionChain` contract:\n\n\n* The comment in line [320](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L320) should say “the real queue index” instead of “the real queue length”.\n* The [`@return` tag](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L576) of the `verifyTransaction` function states that the function returns `false` if the transaction does not exist in the Canonical Transaction Chain. However, the function will revert in such scenario.\n* The `@return` tags of the [`_verifySequencerTransaction`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L1107) and [`_verifyQueueTransaction`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L1154) functions state that they return `false`upon failure. Yet in such scenario they revert.\n\n\nIn the `OVM_ExecutionManager` contract:\n\n\n* The [`@return` tag](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L328) of the `ovmL1QUEUEORIGIN` function states that an address is returned, yet the actual [returned value](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L335) is the element of an `enum`.\n* The inline comment in [line 857](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L857) states that the nonce is updated even if contract creation fails, yet that is incorrect. When the contract creation fails with a revert due to the deployer not being allowed, the account’s nonce is not updated (see note **“[N10] Contract creation can revert upon failure”** for additional details).\n* An inline comment in [line 1039](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1039) states that the revert flag *“`EXCEEDS_NUISANCE_GAS` explicitly reduces the remaining nuisance gas for this message to zero”*. However, as can be observed in the related [`_useNuisanceGas` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1589) where the flag is raised, the remaining nuisance gas of the message is not set to zero (as described in issue **“[M05] Nuisance gas left is not reduced to zero when operation exceeds budget”**)\n* An inline comment in [line 1358](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1358) mentions “loading” an account but is referring to changing an account.\n\n\nIn the `Lib_Bytes32Utils` library:\n\n\n* [The `@return` tag](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_Bytes32Utils.sol#L84) of the `removeLeadingZeros` function specifies that the returned value is `bytes32`, while it actually returns a [`bytes`type](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_Bytes32Utils.sol#L92).\n\n\nIn the `OVM_L1ERC20Gateway` contract:\n\n\n* lines [63 and 64](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/OVM_L1ERC20Gateway.sol#L63-L64) imply that ETH is being deposited, when actually an ERC20 token is being deposited.\n\n\nIn the `Abs_L1TokenGateway` contract:\n\n\n* The comment on line [77](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol#L77) describes a withdrawal operation instead of a deposit.\n* The comment on line [129](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol#L129) says “withdrawal” instead of “deposit”.\n* The comment on line [188](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol#L188) says the function will fail if the L2 withdrawal was not finalized, but that logic is not included within the function.\n\n\nIn the `Abs_L2DepositedToken` contract:\n\n\n* [Docstrings](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L42-L44) for the contract’s constructor should say “L2 Messenger address” instead of “L1 Messenger address”.\n* [Documented parameters](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L215-L216) `_to` and `_amount` of the `finalizeDeposit` function refer to withdrawals, when they should be referring to deposits.\n\n\nIn the `OVM_L2ToL1MessagePasser` contract:\n\n\n* [Docstrings](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_L2ToL1MessagePasser.sol#L15) state that the contract’s runtime target is the EVM, while it should say OVM.\n\n\nIn the `OVM_StateManager` contract:\n\n\n* Docstrings in lines [274](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_StateManager.sol#L274) and [292](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_StateManager.sol#L292) state that the related functions are only called during `ovmCREATE` or `ovmCREATE2` operations, failing to account that they are also called during `ovmCREATEEOA`.\n\n\nIn the `OVM_StateTransitioner` contract:\n\n\n* Docstrings for the [`getPostStateRoot` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L144-L148) state that the value returned corresponds to the *“state root after execution”*. However, if it is called prior to the transaction being applied, the function will return the state root before execution.\n\n\nIn the `Lib_MerkleTrie` library:\n\n\n* Docstrings for the [`_getNodeValue` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L634-L638) should say “Gets the value for a node” instead of “Gets the path for a node”.\n\n\nIn the `OVM_ECDSAContractAccount` contract:\n\n\n* The comment on line [17](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L17) indicates that `eth_sign` messages can be parsed, but this functionality has been removed.\n* The comment on line [73](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L73) appears to be removable as it is similar to the comment on line [79](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L79).\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_MerkleTree } from \"../../libraries/utils/Lib_MerkleTree.sol\";\nimport { Lib_Math } from \"../../libraries/utils/Lib_Math.sol\";\n\n/* Interface Imports */\nimport { iOVM_CanonicalTransactionChain } from \"../../iOVM/chain/iOVM_CanonicalTransactionChain.sol\";\nimport { iOVM_ChainStorageContainer } from \"../../iOVM/chain/iOVM_ChainStorageContainer.sol\";\n\n/* Contract Imports */\nimport { OVM_ExecutionManager } from \"../execution/OVM_ExecutionManager.sol\";\n\n\n/**\n * @title OVM_CanonicalTransactionChain\n * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions\n * which must be applied to the rollup state. It defines the ordering of rollup transactions by\n * writing them to the 'CTC:batches' instance of the Chain Storage Container.\n * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the Sequencer\n * will eventually append it to the rollup state.\n * If the Sequencer does not include an enqueued transaction within the 'force inclusion period',\n * then any account may force it to be included by calling appendQueueBatch().\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_CanonicalTransactionChain is iOVM_CanonicalTransactionChain, Lib_AddressResolver {\n\n    /*************\n     * Constants *\n     *************/\n\n    // L2 tx gas-related\n    uint256 constant public MIN_ROLLUP_TX_GAS = 100000;\n    uint256 constant public MAX_ROLLUP_TX_SIZE = 50000;\n    uint256 constant public L2_GAS_DISCOUNT_DIVISOR = 32;\n\n    // Encoding-related (all in bytes)\n    uint256 constant internal BATCH_CONTEXT_SIZE = 16;\n    uint256 constant internal BATCH_CONTEXT_LENGTH_POS = 12;\n    uint256 constant internal BATCH_CONTEXT_START_POS = 15;\n    uint256 constant internal TX_DATA_HEADER_SIZE = 3;\n    uint256 constant internal BYTES_TILL_TX_DATA = 65;\n\n\n    /*************\n     * Variables *\n     *************/\n\n    uint256 public forceInclusionPeriodSeconds;\n    uint256 public forceInclusionPeriodBlocks;\n    uint256 public maxTransactionGasLimit;\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _libAddressManager,\n        uint256 _forceInclusionPeriodSeconds,\n        uint256 _forceInclusionPeriodBlocks,\n        uint256 _maxTransactionGasLimit\n    )\n        Lib_AddressResolver(_libAddressManager)\n    {\n        forceInclusionPeriodSeconds = _forceInclusionPeriodSeconds;\n        forceInclusionPeriodBlocks = _forceInclusionPeriodBlocks;\n        maxTransactionGasLimit = _maxTransactionGasLimit;\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Accesses the batch storage container.\n     * @return Reference to the batch storage container.\n     */\n    function batches()\n        override\n        public\n        view\n        returns (\n            iOVM_ChainStorageContainer\n        )\n    {\n        return iOVM_ChainStorageContainer(\n            resolve(\"OVM_ChainStorageContainer:CTC:batches\")\n        );\n    }\n\n    /**\n     * Accesses the queue storage container.\n     * @return Reference to the queue storage container.\n     */\n    function queue()\n        override\n        public\n        view\n        returns (\n            iOVM_ChainStorageContainer\n        )\n    {\n        return iOVM_ChainStorageContainer(\n            resolve(\"OVM_ChainStorageContainer:CTC:queue\")\n        );\n    }\n\n    /**\n     * Retrieves the total number of elements submitted.\n     * @return _totalElements Total submitted elements.\n     */\n    function getTotalElements()\n        override\n        public\n        view\n        returns (\n            uint256 _totalElements\n        )\n    {\n        (uint40 totalElements,,,) = _getBatchExtraData();\n        return uint256(totalElements);\n    }\n\n    /**\n     * Retrieves the total number of batches submitted.\n     * @return _totalBatches Total submitted batches.\n     */\n    function getTotalBatches()\n        override\n        public\n        view\n        returns (\n            uint256 _totalBatches\n        )\n    {\n        return batches().length();\n    }\n\n    /**\n     * Returns the index of the next element to be enqueued.\n     * @return Index for the next queue element.\n     */\n    function getNextQueueIndex()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        (,uint40 nextQueueIndex,,) = _getBatchExtraData();\n        return nextQueueIndex;\n    }\n\n    /**\n     * Returns the timestamp of the last transaction.\n     * @return Timestamp for the last transaction.\n     */\n    function getLastTimestamp()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        (,,uint40 lastTimestamp,) = _getBatchExtraData();\n        return lastTimestamp;\n    }\n\n    /**\n     * Returns the blocknumber of the last transaction.\n     * @return Blocknumber for the last transaction.\n     */\n    function getLastBlockNumber()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        (,,,uint40 lastBlockNumber) = _getBatchExtraData();\n        return lastBlockNumber;\n    }\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    function getQueueElement(\n        uint256 _index\n    )\n        override\n        public\n        view\n        returns (\n            Lib_OVMCodec.QueueElement memory _element\n        )\n    {\n        return _getQueueElement(\n            _index,\n            queue()\n        );\n    }\n\n    /**\n     * Get the number of queue elements which have not yet been included.\n     * @return Number of pending queue elements.\n     */\n    function getNumPendingQueueElements()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        return getQueueLength() - getNextQueueIndex();\n    }\n\n   /**\n     * Retrieves the length of the queue, including\n     * both pending and canonical transactions.\n     * @return Length of the queue.\n     */\n    function getQueueLength()\n        override\n        public\n        view\n        returns (\n            uint40\n        )\n    {\n        return _getQueueLength(\n            queue()\n        );\n    }\n\n    /**\n     * Adds a transaction to the queue.\n     * @param _target Target L2 contract to send the transaction to.\n     * @param _gasLimit Gas limit for the enqueued L2 transaction.\n     * @param _data Transaction data.\n     */\n    function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    )\n        override\n        public\n    {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\n            \"Transaction gas limit too low to enqueue.\"\n        );\n\n        // We need to consume some amount of L1 gas in order to rate limit transactions going into\n        // L2. However, L2 is cheaper than L1 so we only need to burn some small proportion of the\n        // provided L1 gas.\n        uint256 gasToConsume = _gasLimit/L2_GAS_DISCOUNT_DIVISOR;\n        uint256 startingGas = gasleft();\n\n        // Although this check is not necessary (burn below will run out of gas if not true), it\n        // gives the user an explicit reason as to why the enqueue attempt failed.\n        require(\n            startingGas > gasToConsume,\n            \"Insufficient gas for L2 rate limiting burn.\"\n        );\n\n        // Here we do some \"dumb\" work in order to burn gas, although we should probably replace\n        // this with something like minting gas token later on.\n        uint256 i;\n        while(startingGas - gasleft() < gasToConsume) {\n            i++;\n        }\n\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                msg.sender,\n                _target,\n                _gasLimit,\n                _data\n            )\n        );\n\n        bytes32 timestampAndBlockNumber;\n        assembly {\n            timestampAndBlockNumber := timestamp()\n            timestampAndBlockNumber := or(timestampAndBlockNumber, shl(40, number()))\n        }\n\n        iOVM_ChainStorageContainer queueRef = queue();\n\n        queueRef.push(transactionHash);\n        queueRef.push(timestampAndBlockNumber);\n\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the real queue length we need\n        // to divide by 2 and subtract 1.\n        uint256 queueIndex = queueRef.length() / 2 - 1;\n        emit TransactionEnqueued(\n            msg.sender,\n            _target,\n            _gasLimit,\n            _data,\n            queueIndex,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Appends a given number of queued transactions as a single batch.\n     * param _numQueuedTransactions Number of transactions to append.\n     */\n    function appendQueueBatch(\n        uint256 // _numQueuedTransactions\n    )\n        override\n        public\n        pure\n    {\n        // TEMPORARY: Disable `appendQueueBatch` for minnet\n        revert(\"appendQueueBatch is currently disabled.\");\n\n        // _numQueuedTransactions = Lib_Math.min(_numQueuedTransactions, getNumPendingQueueElements());\n        // require(\n        //     _numQueuedTransactions > 0,\n        //     \"Must append more than zero transactions.\"\n        // );\n\n        // bytes32[] memory leaves = new bytes32[](_numQueuedTransactions);\n        // uint40 nextQueueIndex = getNextQueueIndex();\n\n        // for (uint256 i = 0; i < _numQueuedTransactions; i++) {\n        //     if (msg.sender != resolve(\"OVM_Sequencer\")) {\n        //         Lib_OVMCodec.QueueElement memory el = getQueueElement(nextQueueIndex);\n        //         require(\n        //             el.timestamp + forceInclusionPeriodSeconds < block.timestamp,\n        //             \"Queue transactions cannot be submitted during the sequencer inclusion period.\"\n        //         );\n        //     }\n        //     leaves[i] = _getQueueLeafHash(nextQueueIndex);\n        //     nextQueueIndex++;\n        // }\n\n        // Lib_OVMCodec.QueueElement memory lastElement = getQueueElement(nextQueueIndex - 1);\n\n        // _appendBatch(\n        //     Lib_MerkleTree.getMerkleRoot(leaves),\n        //     _numQueuedTransactions,\n        //     _numQueuedTransactions,\n        //     lastElement.timestamp,\n        //     lastElement.blockNumber\n        // );\n\n        // emit QueueBatchAppended(\n        //     nextQueueIndex - _numQueuedTransactions,\n        //     _numQueuedTransactions,\n        //     getTotalElements()\n        // );\n    }\n\n    /**\n     * Allows the sequencer to append a batch of transactions.\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\n     * .param _contexts Array of batch contexts.\n     * .param _transactionDataFields Array of raw transaction data.\n     */\n    function appendSequencerBatch()\n        override\n        public\n    {\n        uint40 shouldStartAtElement;\n        uint24 totalElementsToAppend;\n        uint24 numContexts;\n        assembly {\n            shouldStartAtElement  := shr(216, calldataload(4))\n            totalElementsToAppend := shr(232, calldataload(9))\n            numContexts           := shr(232, calldataload(12))\n        }\n\n        require(\n            shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        require(\n            msg.sender == resolve(\"OVM_Sequencer\"),\n            \"Function can only be called by the Sequencer.\"\n        );\n\n        require(\n            numContexts > 0,\n            \"Must provide at least one batch context.\"\n        );\n\n        require(\n            totalElementsToAppend > 0,\n            \"Must append at least one element.\"\n        );\n\n        uint40 nextTransactionPtr = uint40(BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts);\n\n        require(\n            msg.data.length >= nextTransactionPtr,\n            \"Not enough BatchContexts provided.\"\n        );\n\n        // Take a reference to the queue and its length so we don't have to keep resolving it.\n        // Length isn't going to change during the course of execution, so it's fine to simply\n        // resolve this once at the start. Saves gas.\n        iOVM_ChainStorageContainer queueRef = queue();\n        uint40 queueLength = _getQueueLength(queueRef);\n\n        // Reserve some memory to save gas on hashing later on. This is a relatively safe estimate\n        // for the average transaction size that will prevent having to resize this chunk of memory\n        // later on. Saves gas.\n        bytes memory hashMemory = new bytes((msg.data.length / totalElementsToAppend) * 2);\n\n        // Initialize the array of canonical chain leaves that we will append.\n        bytes32[] memory leaves = new bytes32[](totalElementsToAppend);\n\n        // Each leaf index corresponds to a tx, either sequenced or enqueued.\n        uint32 leafIndex = 0;\n\n        // Counter for number of sequencer transactions appended so far.\n        uint32 numSequencerTransactions = 0;\n\n        // We will sequentially append leaves which are pointers to the queue.\n        // The initial queue index is what is currently in storage.\n        uint40 nextQueueIndex = getNextQueueIndex();\n\n        BatchContext memory curContext;\n        for (uint32 i = 0; i < numContexts; i++) {\n            BatchContext memory nextContext = _getBatchContext(i);\n\n            if (i == 0) {\n                // Execute a special check for the first batch.\n                _validateFirstBatchContext(nextContext);\n            }\n\n            // Execute this check on every single batch, including the first one.\n            _validateNextBatchContext(\n                curContext,\n                nextContext,\n                nextQueueIndex,\n                queueRef\n            );\n\n            // Now we can update our current context.\n            curContext = nextContext;\n\n            // Process sequencer transactions first.\n            for (uint32 j = 0; j < curContext.numSequencedTransactions; j++) {\n                uint256 txDataLength;\n                assembly {\n                    txDataLength := shr(232, calldataload(nextTransactionPtr))\n                }\n                require(\n                    txDataLength <= MAX_ROLLUP_TX_SIZE,\n                    \"Transaction data size exceeds maximum for rollup transaction.\"\n                );\n\n                leaves[leafIndex] = _getSequencerLeafHash(\n                    curContext,\n                    nextTransactionPtr,\n                    txDataLength,\n                    hashMemory\n                );\n\n                nextTransactionPtr += uint40(TX_DATA_HEADER_SIZE + txDataLength);\n                numSequencerTransactions++;\n                leafIndex++;\n            }\n\n            // Now process any subsequent queue transactions.\n            for (uint32 j = 0; j < curContext.numSubsequentQueueTransactions; j++) {\n                require(\n                    nextQueueIndex < queueLength,\n                    \"Not enough queued transactions to append.\"\n                );\n\n                leaves[leafIndex] = _getQueueLeafHash(nextQueueIndex);\n                nextQueueIndex++;\n                leafIndex++;\n            }\n        }\n\n        _validateFinalBatchContext(\n            curContext,\n            nextQueueIndex,\n            queueLength,\n            queueRef\n        );\n\n        require(\n            msg.data.length == nextTransactionPtr,\n            \"Not all sequencer transactions were processed.\"\n        );\n\n        require(\n            leafIndex == totalElementsToAppend,\n            \"Actual transaction index does not match expected total elements to append.\"\n        );\n\n        // Generate the required metadata that we need to append this batch\n        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;\n        uint40 blockTimestamp;\n        uint40 blockNumber;\n        if (curContext.numSubsequentQueueTransactions == 0) {\n            // The last element is a sequencer tx, therefore pull timestamp and block number from the last context.\n            blockTimestamp = uint40(curContext.timestamp);\n            blockNumber = uint40(curContext.blockNumber);\n        } else {\n            // The last element is a queue tx, therefore pull timestamp and block number from the queue element.\n            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at least one queue element.\n            // We increment nextQueueIndex after processing each queue element,\n            // so the index of the last element we processed is nextQueueIndex - 1.\n            Lib_OVMCodec.QueueElement memory lastElement = _getQueueElement(\n                nextQueueIndex - 1,\n                queueRef\n            );\n\n            blockTimestamp = lastElement.timestamp;\n            blockNumber = lastElement.blockNumber;\n        }\n\n        // For efficiency reasons getMerkleRoot modifies the `leaves` argument in place\n        // while calculating the root hash therefore any arguments passed to it must not\n        // be used again afterwards\n        _appendBatch(\n            Lib_MerkleTree.getMerkleRoot(leaves),\n            totalElementsToAppend,\n            numQueuedTransactions,\n            blockTimestamp,\n            blockNumber\n        );\n\n        emit SequencerBatchAppended(\n            nextQueueIndex - numQueuedTransactions,\n            numQueuedTransactions,\n            getTotalElements()\n        );\n    }\n\n    /**\n     * Verifies whether a transaction is included in the chain.\n     * @param _transaction Transaction to verify.\n     * @param _txChainElement Transaction chain element corresponding to the transaction.\n     * @param _batchHeader Header of the batch the transaction was included in.\n     * @param _inclusionProof Inclusion proof for the provided transaction chain element.\n     * @return True if the transaction exists in the CTC, false if not.\n     */\n    function verifyTransaction(\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof\n    )\n        override\n        public\n        view\n        returns (\n            bool\n        )\n    {\n        if (_txChainElement.isSequenced == true) {\n            return _verifySequencerTransaction(\n                _transaction,\n                _txChainElement,\n                _batchHeader,\n                _inclusionProof\n            );\n        } else {\n            return _verifyQueueTransaction(\n                _transaction,\n                _txChainElement.queueIndex,\n                _batchHeader,\n                _inclusionProof\n            );\n        }\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Returns the BatchContext located at a particular index.\n     * @param _index The index of the BatchContext\n     * @return The BatchContext at the specified index.\n     */\n    function _getBatchContext(\n        uint256 _index\n    )\n        internal\n        pure\n        returns (\n            BatchContext memory\n        )\n    {\n        uint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;\n        uint256 numSequencedTransactions;\n        uint256 numSubsequentQueueTransactions;\n        uint256 ctxTimestamp;\n        uint256 ctxBlockNumber;\n\n        assembly {\n            numSequencedTransactions       := shr(232, calldataload(contextPtr))\n            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))\n            ctxTimestamp                   := shr(216, calldataload(add(contextPtr, 6)))\n            ctxBlockNumber                 := shr(216, calldataload(add(contextPtr, 11)))\n        }\n\n        return BatchContext({\n            numSequencedTransactions: numSequencedTransactions,\n            numSubsequentQueueTransactions: numSubsequentQueueTransactions,\n            timestamp: ctxTimestamp,\n            blockNumber: ctxBlockNumber\n        });\n    }\n\n    /**\n     * Parses the batch context from the extra data.\n     * @return Total number of elements submitted.\n     * @return Index of the next queue element.\n     */\n    function _getBatchExtraData()\n        internal\n        view\n        returns (\n            uint40,\n            uint40,\n            uint40,\n            uint40\n        )\n    {\n        bytes27 extraData = batches().getGlobalMetadata();\n\n        uint40 totalElements;\n        uint40 nextQueueIndex;\n        uint40 lastTimestamp;\n        uint40 lastBlockNumber;\n        assembly {\n            extraData       :=  shr(40, extraData)\n            totalElements   :=  and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\n            nextQueueIndex  :=  shr(40, and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000))\n            lastTimestamp   :=  shr(80, and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000))\n            lastBlockNumber :=  shr(120, and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000))\n        }\n\n        return (\n            totalElements,\n            nextQueueIndex,\n            lastTimestamp,\n            lastBlockNumber\n        );\n    }\n\n    /**\n     * Encodes the batch context for the extra data.\n     * @param _totalElements Total number of elements submitted.\n     * @param _nextQueueIndex Index of the next queue element.\n     * @param _timestamp Timestamp for the last batch.\n     * @param _blockNumber Block number of the last batch.\n     * @return Encoded batch context.\n     */\n    function _makeBatchExtraData(\n        uint40 _totalElements,\n        uint40 _nextQueueIndex,\n        uint40 _timestamp,\n        uint40 _blockNumber\n    )\n        internal\n        pure\n        returns (\n            bytes27\n        )\n    {\n        bytes27 extraData;\n        assembly {\n            extraData := _totalElements\n            extraData := or(extraData, shl(40, _nextQueueIndex))\n            extraData := or(extraData, shl(80, _timestamp))\n            extraData := or(extraData, shl(120, _blockNumber))\n            extraData := shl(40, extraData)\n        }\n\n        return extraData;\n    }\n\n    /**\n     * Retrieves the hash of a queue element.\n     * @param _index Index of the queue element to retrieve a hash for.\n     * @return Hash of the queue element.\n     */\n    function _getQueueLeafHash(\n        uint256 _index\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return _hashTransactionChainElement(\n            Lib_OVMCodec.TransactionChainElement({\n                isSequenced: false,\n                queueIndex: _index,\n                timestamp: 0,\n                blockNumber: 0,\n                txData: hex\"\"\n            })\n        );\n    }\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    function _getQueueElement(\n        uint256 _index,\n        iOVM_ChainStorageContainer _queueRef\n    )\n        internal\n        view\n        returns (\n            Lib_OVMCodec.QueueElement memory _element\n        )\n    {\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the actual desired queue index\n        // we need to multiply by 2.\n        uint40 trueIndex = uint40(_index * 2);\n        bytes32 transactionHash = _queueRef.get(trueIndex);\n        bytes32 timestampAndBlockNumber = _queueRef.get(trueIndex + 1);\n\n        uint40 elementTimestamp;\n        uint40 elementBlockNumber;\n        assembly {\n            elementTimestamp   :=         and(timestampAndBlockNumber, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\n            elementBlockNumber := shr(40, and(timestampAndBlockNumber, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000))\n        }\n\n        return Lib_OVMCodec.QueueElement({\n            transactionHash: transactionHash,\n            timestamp: elementTimestamp,\n            blockNumber: elementBlockNumber\n        });\n    }\n\n    /**\n     * Retrieves the length of the queue.\n     * @return Length of the queue.\n     */\n    function _getQueueLength(\n        iOVM_ChainStorageContainer _queueRef\n    )\n        internal\n        view\n        returns (\n            uint40\n        )\n    {\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the real queue length we need\n        // to divide by 2.\n        return uint40(_queueRef.length() / 2);\n    }\n\n    /**\n     * Retrieves the hash of a sequencer element.\n     * @param _context Batch context for the given element.\n     * @param _nextTransactionPtr Pointer to the next transaction in the calldata.\n     * @param _txDataLength Length of the transaction item.\n     * @return Hash of the sequencer element.\n     */\n    function _getSequencerLeafHash(\n        BatchContext memory _context,\n        uint256 _nextTransactionPtr,\n        uint256 _txDataLength,\n        bytes memory _hashMemory\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        // Only allocate more memory if we didn't reserve enough to begin with.\n        if (BYTES_TILL_TX_DATA + _txDataLength > _hashMemory.length) {\n            _hashMemory = new bytes(BYTES_TILL_TX_DATA + _txDataLength);\n        }\n\n        uint256 ctxTimestamp = _context.timestamp;\n        uint256 ctxBlockNumber = _context.blockNumber;\n\n        bytes32 leafHash;\n        assembly {\n            let chainElementStart := add(_hashMemory, 0x20)\n\n            // Set the first byte equal to `1` to indicate this is a sequencer chain element.\n            // This distinguishes sequencer ChainElements from queue ChainElements because\n            // all queue ChainElements are ABI encoded and the first byte of ABI encoded\n            // elements is always zero\n            mstore8(chainElementStart, 1)\n\n            mstore(add(chainElementStart, 1), ctxTimestamp)\n            mstore(add(chainElementStart, 33), ctxBlockNumber)\n\n            calldatacopy(add(chainElementStart, BYTES_TILL_TX_DATA), add(_nextTransactionPtr, 3), _txDataLength)\n\n            leafHash := keccak256(chainElementStart, add(BYTES_TILL_TX_DATA, _txDataLength))\n        }\n\n        return leafHash;\n    }\n\n    /**\n     * Retrieves the hash of a sequencer element.\n     * @param _txChainElement The chain element which is hashed to calculate the leaf.\n     * @return Hash of the sequencer element.\n     */\n    function _getSequencerLeafHash(\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement\n    )\n        internal\n        view\n        returns(\n            bytes32\n        )\n    {\n        bytes memory txData = _txChainElement.txData;\n        uint256 txDataLength = _txChainElement.txData.length;\n\n        bytes memory chainElement = new bytes(BYTES_TILL_TX_DATA + txDataLength);\n        uint256 ctxTimestamp = _txChainElement.timestamp;\n        uint256 ctxBlockNumber = _txChainElement.blockNumber;\n\n        bytes32 leafHash;\n        assembly {\n            let chainElementStart := add(chainElement, 0x20)\n\n            // Set the first byte equal to `1` to indicate this is a sequencer chain element.\n            // This distinguishes sequencer ChainElements from queue ChainElements because\n            // all queue ChainElements are ABI encoded and the first byte of ABI encoded\n            // elements is always zero\n            mstore8(chainElementStart, 1)\n\n            mstore(add(chainElementStart, 1), ctxTimestamp)\n            mstore(add(chainElementStart, 33), ctxBlockNumber)\n\n            pop(staticcall(gas(), 0x04, add(txData, 0x20), txDataLength, add(chainElementStart, BYTES_TILL_TX_DATA), txDataLength))\n\n            leafHash := keccak256(chainElementStart, add(BYTES_TILL_TX_DATA, txDataLength))\n        }\n\n        return leafHash;\n    }\n\n    /**\n     * Inserts a batch into the chain of batches.\n     * @param _transactionRoot Root of the transaction tree for this batch.\n     * @param _batchSize Number of elements in the batch.\n     * @param _numQueuedTransactions Number of queue transactions in the batch.\n     * @param _timestamp The latest batch timestamp.\n     * @param _blockNumber The latest batch blockNumber.\n     */\n    function _appendBatch(\n        bytes32 _transactionRoot,\n        uint256 _batchSize,\n        uint256 _numQueuedTransactions,\n        uint40 _timestamp,\n        uint40 _blockNumber\n    )\n        internal\n    {\n        iOVM_ChainStorageContainer batchesRef = batches();\n        (uint40 totalElements, uint40 nextQueueIndex,,) = _getBatchExtraData();\n\n        Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({\n            batchIndex: batchesRef.length(),\n            batchRoot: _transactionRoot,\n            batchSize: _batchSize,\n            prevTotalElements: totalElements,\n            extraData: hex\"\"\n        });\n\n        emit TransactionBatchAppended(\n            header.batchIndex,\n            header.batchRoot,\n            header.batchSize,\n            header.prevTotalElements,\n            header.extraData\n        );\n\n        bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);\n        bytes27 latestBatchContext = _makeBatchExtraData(\n            totalElements + uint40(header.batchSize),\n            nextQueueIndex + uint40(_numQueuedTransactions),\n            _timestamp,\n            _blockNumber\n        );\n\n        batchesRef.push(batchHeaderHash, latestBatchContext);\n    }\n\n    /**\n     * Checks that the first batch context in a sequencer submission is valid\n     * @param _firstContext The batch context to validate.\n     */\n    function _validateFirstBatchContext(\n        BatchContext memory _firstContext\n    )\n        internal\n        view\n    {\n        // If there are existing elements, this batch must have the same context\n        // or a later timestamp and block number.\n        if (getTotalElements() > 0) {\n            (,, uint40 lastTimestamp, uint40 lastBlockNumber) = _getBatchExtraData();\n\n            require(\n                _firstContext.blockNumber >= lastBlockNumber,\n                \"Context block number is lower than last submitted.\"\n            );\n\n            require(\n                _firstContext.timestamp >= lastTimestamp,\n                \"Context timestamp is lower than last submitted.\"\n            );\n        }\n\n        // Sequencer cannot submit contexts which are more than the force inclusion period old.\n        require(\n            _firstContext.timestamp + forceInclusionPeriodSeconds >= block.timestamp,\n            \"Context timestamp too far in the past.\"\n        );\n\n        require(\n            _firstContext.blockNumber + forceInclusionPeriodBlocks >= block.number,\n            \"Context block number too far in the past.\"\n        );\n    }\n\n    /**\n     * Checks that a given batch context has a time context which is below a given que element\n     * @param _context The batch context to validate has values lower.\n     * @param _queueIndex Index of the queue element we are validating came later than the context.\n     * @param _queueRef The storage container for the queue.\n     */\n    function _validateContextBeforeEnqueue(\n        BatchContext memory _context,\n        uint40 _queueIndex,\n        iOVM_ChainStorageContainer _queueRef\n    )\n        internal\n        view\n    {\n            Lib_OVMCodec.QueueElement memory nextQueueElement = _getQueueElement(\n                _queueIndex,\n                _queueRef\n            );\n\n            // If the force inclusion period has passed for an enqueued transaction, it MUST be the next chain element.\n            require(\n                block.timestamp < nextQueueElement.timestamp + forceInclusionPeriodSeconds,"
    }
  ]
}