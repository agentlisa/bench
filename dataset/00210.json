{
  "Title": "Full Deleverage Functionality Can Be Permanently Bricked",
  "Content": "In the [`seaportCallback4878572495` function](https://github.com/Ion-Protocol/ion-seaport/blob/54110bbfbe56d18390d4e9c9f8fc9fb973500da6/src/SeaportDeleverage.sol#L266) within the [`SeaportDeleverage`](https://github.com/Ion-Protocol/ion-seaport/blob/54110bbfbe56d18390d4e9c9f8fc9fb973500da6/src/SeaportDeleverage.sol#L82) contract, there is [a requirement](https://github.com/Ion-Protocol/ion-seaport/blob/54110bbfbe56d18390d4e9c9f8fc9fb973500da6/src/SeaportDeleverage.sol#L290) that the `BASE` token balance of the contract is `0` after a full deleverage.\n\n\nHowever, this will always revert if a user has independently transferred any amount of `BASE` tokens into the [`SeaportDeleverage`](https://github.com/Ion-Protocol/ion-seaport/blob/54110bbfbe56d18390d4e9c9f8fc9fb973500da6/src/SeaportDeleverage.sol#L82) contract. Since there is no way to transfer the tokens out of the contract, a single transfer will permanently brick the contract.\n\n\nConsider removing this check, or modifying it to instead check that the token balance of the contract has not changed since the beginning of the execution flow. Alternatively, consider either modifying the logic to transfer all unneeded `BASE` tokens to the user, or implementing a \"rescue\" function to remove stranded `BASE` tokens.\n\n\n***Update:** Resolved in [pull request #3](https://github.com/Ion-Protocol/ion-seaport/pull/3). The sanity check was removed to prevent bricking of the contract.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/SeaportDeleverage.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport { SeaportBase } from \"./SeaportBase.sol\";\nimport { IIonPool } from \"./interfaces/IIonPool.sol\";\nimport { IGemJoin } from \"./interfaces/IGemJoin.sol\";\nimport { IWhitelist } from \"./interfaces/IWhitelist.sol\";\nimport { WadRayMath } from \"@ionprotocol/libraries/math/WadRayMath.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { SeaportInterface } from \"seaport-types/src/interfaces/SeaportInterface.sol\";\nimport { Order, OrderParameters, OfferItem, ConsiderationItem } from \"seaport-types/src/lib/ConsiderationStructs.sol\";\nimport { ItemType, OrderType } from \"seaport-types/src/lib/ConsiderationEnums.sol\";\n\nusing WadRayMath for uint256;\n\n/**\n * @title Seaport Deleverage\n * @notice A contract to deleverage a position on Ion Protocol using RFQ swaps\n * facilitated by Seaport.\n *\n * @dev The standard Seaport flow would go as follows:\n *\n *      1. An `offerrer` creates an `Order` and signs it. The `fulfiller` will\n *      be given both the `Order` payload and the `signature`. The `fulfiller`'s\n *      role is to execute the transaction.\n *\n *      Inside an `Order`, there is\n *       - an `offerer`: the signature that will be `ecrecover()`ed to verify\n *       the integrity of the signature.\n *       - an array of `Offer`s: Each `Offer` will have a token and an amount.\n *       - an array of `Consideration`s: Each `Consideration` will have a token,\n *       an amount and a recipient.\n *\n *      2. Seaport will verify the signature was signed by the `offerer`.\n *\n *      3. Seaport will iterate through all the `Offer`s and transfer the\n *      specified amount of each token to the fulfiller from the offerer.\n *\n *      4. Seaport will iterate through all the `Consideration`s and transfer\n *      the specified amount of each token from the fulfiller to the recipient.\n *\n * For the (de)leverage use-case, it is unideal that steps 3 and 4 must happen\n * in order because it means `Offer` items cannot be used before satisfying\n * `Consideration` constraints. Consider the deleverage case where debt must\n * first be repaid in the IonPool, before the collateral can be removed. If the\n * debt must be repaid before retrieving collateral from IonPool AND, on the\n * Seaport side, collateral must be paid before receiving the counterparty, then\n * a flashloan must be used. Ideally, Seaport would allow use of the\n * counterparty's collateral before checking the Consideration `constraints`.\n *\n * While this would not be possible in the standard Seaport flow, we engage in a\n * non-standard flow that hijacks the ERC20 `transferFrom()` to gain control\n * flow in between steps 3 and 4. Normally, if the `offerer` wanted to sign for\n * a trade between 100 Token A and 90 Token B, the `Order` payload would contain\n * an `Offer` of 100 Token A and a `Consideration` of 90 Token B to the\n * `offerer`'s address.\n *\n * However, to sign for the same trade to be executed through this contract, the\n * `Order` payload would still contain an `Offer` of 100 Token A. However, the\n * first `Consideration` would pass this contract address as the token address\n * (and the amount would be used to pass some other data) and the second\n * `Consideration` would pass the aforementioned 90 Token B to the `offerer`'s\n * address.\n *\n * This allows this contract to gain control flow in between steps 3 and 4\n * through the `transferFrom()` function and Seaport still enforces the\n * `constraints` of the other `Consideration`s ensuring counterparty's terms.\n *\n *\n *\n * The case of a full deleverage presents a special problem where the exact\n * amount of debt to repay will not be known until tx execution since the debt\n * is accrued every block. This is problematic because the market maker won't be\n * able to sign for the exact amount of base token to be traded for offchain\n * (also, Seaport's support for partial fills is quite limited). In the case of\n * a full deleverage, the market maker can overestimate the amount of base token\n * to be sold and this contract will refund the excess to the user.\n *\n */\ncontract SeaportDeleverage is SeaportBase {\n    error NotEnoughCollateral(uint256 collateralToRemove, uint256 currentCollateral);\n\n    // Offer item validation\n    error OTokenMustBeBase(address token);\n    error OStartMustBeDebtToRepay(uint256 startAmount, uint256 debtToRepay);\n    error OEndMustBeDebtToRepay(uint256 endAmount, uint256 debtToRepay);\n\n    // Consideration item 1 validation\n    error C1StartAmountMustBeDebtToRepay(uint256 startAmount, uint256 debtToRepay);\n    error C1EndAmountMustBeDebtToRepay(uint256 endAmount, uint256 debtToRepay);\n\n    // Consideration item 2 validation;\n    error C2TokenMustBeCollateral(address token);\n    error C2StartMustBeCollateralToRemove(uint256 startAmount, uint256 collateralToRemove);\n    error C2EndMustBeCollateralToRemove(uint256 endAmount, uint256 collateralToRemove);\n\n    constructor(IIonPool pool, IGemJoin gemJoin, uint8 ilkIndex) SeaportBase(pool, gemJoin, ilkIndex) {\n        COLLATERAL.approve(address(SEAPORT), type(uint256).max);\n        BASE.approve(address(POOL), type(uint256).max);\n    }\n\n    /**\n     * @notice Deleverage a position on `IonPool` through Seaport.\n     *\n     * @dev\n     * ```solidity\n     * struct Order {\n     *      OrderParameters parameters;\n     *      bytes signature;\n     * }\n     *\n     * struct OrderParameters {\n     *      address offerer; // 0x00\n     *      address zone; // 0x20\n     *      OfferItem[] offer; // 0x40\n     *      ConsiderationItem[] consideration; // 0x60\n     *      OrderType orderType; // 0x80\n     *      uint256 startTime; // 0xa0\n     *      uint256 endTime; // 0xc0\n     *      bytes32 zoneHash; // 0xe0\n     *      uint256 salt; // 0x100\n     *      bytes32 conduitKey; // 0x120\n     *      uint256 totalOriginalConsiderationItems; // 0x140\n     * }\n     *\n     * struct OfferItem {\n     *      ItemType itemType;\n     *      address token;\n     *      uint256 identifierOrCriteria;\n     *      uint256 startAmount;\n     *      uint256 endAmount;\n     * }\n     *\n     * struct ConsiderationItem {\n     *      ItemType itemType;\n     *      address token;\n     *      uint256 identifierOrCriteria;\n     *      uint256 startAmount;\n     *      uint256 endAmount;\n     *      address payable recipient;\n     * }\n     * ```\n     *\n     * REQUIRES:\n     * - There should only be one token for the `Offer`.\n     * - There should be two items in the `Consideration`.\n     * - The `zone` must be this contract's address.\n     * - The `orderType` must be `FULL_RESTRICTED`. This means only the `zone`,\n     * or the offerer, can fulfill the order.\n     * - The `conduitKey` must be zero. No conduit should be used.\n     * - The `totalOriginalConsiderationItems` must be 2.\n     *\n     * - The `Offer` item must be of type `ERC20`.\n     * - For the case of deleverage, `token` of the `Offer` item must be the\n     * `BASE` token.\n     * - The `startAmount` and `endAmount` of the `Offer` item must be equal to\n     * `debtToRepay`. Start and end should be equal because the amount is fixed.\n     *\n     * - The first `Consideration` item must be of type `ERC20`.\n     * - The `token` of the first `Consideration` item must be this contract's\n     * address. This is to allow this contract to gain control flow. We also\n     * want to use the `transferFrom()` args to communicate data to the\n     * `transferFrom()` callback. Any data that can't be fit into the\n     * `transferFrom()` args will be communicated through transient storage.\n     * - The `startAmount` and `endAmount` of the first `Consideration` item\n     * communicate the amount of debt to repay to the callback.\n     * - The `recipient` of the first `Consideration` item must be `msg.sender`.\n     * This will be user's vault that will be deleveraged. This contract assumes\n     * that caller is the owner of the vault.\n     *\n     * - The second `Consideration` item must be of type `ERC20`.\n     * - The `token` of the second `Consideration` item must be the `COLLATERAL`\n     * - The second `Consideration` item must have the `startAmount` and `endAmount`\n     * equal to `collateralToRemove`.\n     *\n     * We don't constrain the `recipient` of the second `Consideration` item.\n     *\n     * It is technically possible for two distinct orders to have the same\n     * parameters. The `salt` should be used to distinguish between two orders\n     * with the same parameters. Otherwise, they will map to the same order hash\n     * and only one of them will be able to be fulfilled.\n     *\n     * @param order Seaport order.\n     * @param collateralToRemove Amount of collateral to remove. [WAD]\n     * @param debtToRepay Amount of debt to repay. [WAD]\n     */\n    function deleverage(Order calldata order, uint256 collateralToRemove, uint256 debtToRepay) external {\n        uint256 currentCollateral = POOL.collateral(0, msg.sender);\n        if (collateralToRemove > currentCollateral) revert NotEnoughCollateral(collateralToRemove, currentCollateral);\n\n        OrderParameters calldata params = order.parameters;\n\n        _validateOrderParams(params);\n\n        OfferItem calldata offer1 = params.offer[0];\n\n        if (offer1.itemType != ItemType.ERC20) revert OItemTypeMustBeERC20(offer1.itemType);\n        if (offer1.token != address(BASE)) revert OTokenMustBeBase(offer1.token);\n        if (offer1.startAmount != debtToRepay) revert OStartMustBeDebtToRepay(offer1.startAmount, debtToRepay);\n        if (offer1.endAmount != debtToRepay) revert OEndMustBeDebtToRepay(offer1.endAmount, debtToRepay);\n\n        ConsiderationItem calldata consideration1 = params.consideration[0];\n\n        // forgefmt: disable-start\n        if (consideration1.itemType != ItemType.ERC20) \n            revert C1TypeMustBeERC20(consideration1.itemType);\n        if (consideration1.token != address(this)) \n            revert C1TokenMustBeThis(consideration1.token);\n        if (consideration1.startAmount != debtToRepay) \n            revert C1StartAmountMustBeDebtToRepay(consideration1.startAmount, debtToRepay);\n        if (consideration1.endAmount != debtToRepay) \n            revert C1EndAmountMustBeDebtToRepay(consideration1.endAmount, debtToRepay);\n        if (consideration1.recipient != msg.sender) \n            revert C1RecipientMustBeSender(consideration1.recipient);\n\n        ConsiderationItem calldata consideration2 = params.consideration[1];\n        \n        if (consideration2.itemType != ItemType.ERC20) \n            revert C2TypeMustBeERC20(consideration2.itemType);\n        if (consideration2.token != address(COLLATERAL)) \n            revert C2TokenMustBeCollateral(consideration2.token);\n        if (consideration2.startAmount != collateralToRemove) \n            revert C2StartMustBeCollateralToRemove(consideration2.startAmount, collateralToRemove);\n        if (consideration2.endAmount != collateralToRemove) \n            revert C2EndMustBeCollateralToRemove(consideration2.endAmount, collateralToRemove);\n        // forgefmt: disable-end\n\n        assembly {\n            tstore(TSLOT_AWAIT_CALLBACK, 1)\n            tstore(TSLOT_COLLATERAL_DELTA, collateralToRemove)\n        }\n\n        SEAPORT.fulfillOrder(order, bytes32(0));\n\n        // Maintain composability\n        assembly {\n            tstore(TSLOT_AWAIT_CALLBACK, 0)\n            tstore(TSLOT_COLLATERAL_DELTA, 0)\n        }\n    }\n\n    /**\n     * @notice This callback is not meant to be called directly.\n     *\n     * @dev This function selector has been mined to match the `transferFrom()`\n     * selector (`0x23b872dd`). We hijack the `transferFrom()` selector to be\n     * able to use the default Seaport flow. This is a callback from Seaport to\n     * give this contract control flow between the `Offer` being transferred and\n     * the `Consideration` being transferred.\n     *\n     * In order to enforce that this function is only called through a\n     * transaction initiated by this contract, we use the `onlyReentrant`\n     * modifier.\n     *\n     * This function can only be called by the Seaport contract.\n     *\n     * The second and the third arguments are used to communicate data necessary\n     * for the callback context. Transient storage is used to communicate any\n     * extra data that could not be fit into the `transferFrom()` args.\n     *\n     * @param user whose position to modify on `IonPool`\n     * @param debtToRepay amount of debt to repay on the `user`'s position\n     */\n    function seaportCallback4878572495(address, address user, uint256 debtToRepay) external onlySeaport onlyReentrant {\n        uint256 collateralToRemove;\n        assembly {\n            collateralToRemove := tload(TSLOT_COLLATERAL_DELTA)\n        }\n\n        uint256 currentRate = POOL.rate(0);\n        uint256 currentNormalizedDebt = POOL.normalizedDebt(0, user);\n\n        uint256 repayAmountNormalized = debtToRepay.rayDivDown(currentRate);\n\n        // In the case of a full deleverage, the Seaport order will not be able\n        // to predict the exact amount of debt to repay since this will change\n        // at execution time when debt is accrued. The order will have to to\n        // overestimate the amount of base token to be traded for through\n        // seaport. Excess base token will be refunded to the user.\n        if (repayAmountNormalized > currentNormalizedDebt) {\n            // Emulates IonPool calculation\n            uint256 neccesaryBase = currentNormalizedDebt.rayMulUp(currentRate);\n\n            BASE.transfer(user, debtToRepay - neccesaryBase);\n            POOL.repay(0, user, address(this), currentNormalizedDebt);\n\n            // Sanity check\n            assert(BASE.balanceOf(address(this)) == 0);\n        } else {\n            POOL.repay(0, user, address(this), repayAmountNormalized);\n        }\n\n        POOL.withdrawCollateral(0, user, address(this), collateralToRemove);\n        JOIN.exit(address(this), collateralToRemove);\n    }\n}"
    },
    {
      "filename": "src/SeaportDeleverage.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport { SeaportBase } from \"./SeaportBase.sol\";\nimport { IIonPool } from \"./interfaces/IIonPool.sol\";\nimport { IGemJoin } from \"./interfaces/IGemJoin.sol\";\nimport { IWhitelist } from \"./interfaces/IWhitelist.sol\";\nimport { WadRayMath } from \"@ionprotocol/libraries/math/WadRayMath.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { SeaportInterface } from \"seaport-types/src/interfaces/SeaportInterface.sol\";\nimport { Order, OrderParameters, OfferItem, ConsiderationItem } from \"seaport-types/src/lib/ConsiderationStructs.sol\";\nimport { ItemType, OrderType } from \"seaport-types/src/lib/ConsiderationEnums.sol\";\n\nusing WadRayMath for uint256;\n\n/**\n * @title Seaport Deleverage\n * @notice A contract to deleverage a position on Ion Protocol using RFQ swaps\n * facilitated by Seaport.\n *\n * @dev The standard Seaport flow would go as follows:\n *\n *      1. An `offerrer` creates an `Order` and signs it. The `fulfiller` will\n *      be given both the `Order` payload and the `signature`. The `fulfiller`'s\n *      role is to execute the transaction.\n *\n *      Inside an `Order`, there is\n *       - an `offerer`: the signature that will be `ecrecover()`ed to verify\n *       the integrity of the signature.\n *       - an array of `Offer`s: Each `Offer` will have a token and an amount.\n *       - an array of `Consideration`s: Each `Consideration` will have a token,\n *       an amount and a recipient.\n *\n *      2. Seaport will verify the signature was signed by the `offerer`.\n *\n *      3. Seaport will iterate through all the `Offer`s and transfer the\n *      specified amount of each token to the fulfiller from the offerer.\n *\n *      4. Seaport will iterate through all the `Consideration`s and transfer\n *      the specified amount of each token from the fulfiller to the recipient.\n *\n * For the (de)leverage use-case, it is unideal that steps 3 and 4 must happen\n * in order because it means `Offer` items cannot be used before satisfying\n * `Consideration` constraints. Consider the deleverage case where debt must\n * first be repaid in the IonPool, before the collateral can be removed. If the\n * debt must be repaid before retrieving collateral from IonPool AND, on the\n * Seaport side, collateral must be paid before receiving the counterparty, then\n * a flashloan must be used. Ideally, Seaport would allow use of the\n * counterparty's collateral before checking the Consideration `constraints`.\n *\n * While this would not be possible in the standard Seaport flow, we engage in a\n * non-standard flow that hijacks the ERC20 `transferFrom()` to gain control\n * flow in between steps 3 and 4. Normally, if the `offerer` wanted to sign for\n * a trade between 100 Token A and 90 Token B, the `Order` payload would contain\n * an `Offer` of 100 Token A and a `Consideration` of 90 Token B to the\n * `offerer`'s address.\n *\n * However, to sign for the same trade to be executed through this contract, the\n * `Order` payload would still contain an `Offer` of 100 Token A. However, the\n * first `Consideration` would pass this contract address as the token address\n * (and the amount would be used to pass some other data) and the second\n * `Consideration` would pass the aforementioned 90 Token B to the `offerer`'s\n * address.\n *\n * This allows this contract to gain control flow in between steps 3 and 4\n * through the `transferFrom()` function and Seaport still enforces the\n * `constraints` of the other `Consideration`s ensuring counterparty's terms.\n *\n *\n *\n * The case of a full deleverage presents a special problem where the exact\n * amount of debt to repay will not be known until tx execution since the debt\n * is accrued every block. This is problematic because the market maker won't be\n * able to sign for the exact amount of base token to be traded for offchain\n * (also, Seaport's support for partial fills is quite limited). In the case of\n * a full deleverage, the market maker can overestimate the amount of base token\n * to be sold and this contract will refund the excess to the user.\n *\n */\ncontract SeaportDeleverage is SeaportBase {\n    error NotEnoughCollateral(uint256 collateralToRemove, uint256 currentCollateral);\n\n    // Offer item validation\n    error OTokenMustBeBase(address token);\n    error OStartMustBeDebtToRepay(uint256 startAmount, uint256 debtToRepay);\n    error OEndMustBeDebtToRepay(uint256 endAmount, uint256 debtToRepay);\n\n    // Consideration item 1 validation\n    error C1StartAmountMustBeDebtToRepay(uint256 startAmount, uint256 debtToRepay);\n    error C1EndAmountMustBeDebtToRepay(uint256 endAmount, uint256 debtToRepay);\n\n    // Consideration item 2 validation;\n    error C2TokenMustBeCollateral(address token);\n    error C2StartMustBeCollateralToRemove(uint256 startAmount, uint256 collateralToRemove);\n    error C2EndMustBeCollateralToRemove(uint256 endAmount, uint256 collateralToRemove);\n\n    constructor(IIonPool pool, IGemJoin gemJoin, uint8 ilkIndex) SeaportBase(pool, gemJoin, ilkIndex) {\n        COLLATERAL.approve(address(SEAPORT), type(uint256).max);\n        BASE.approve(address(POOL), type(uint256).max);\n    }\n\n    /**\n     * @notice Deleverage a position on `IonPool` through Seaport.\n     *\n     * @dev\n     * ```solidity\n     * struct Order {\n     *      OrderParameters parameters;\n     *      bytes signature;\n     * }\n     *\n     * struct OrderParameters {\n     *      address offerer; // 0x00\n     *      address zone; // 0x20\n     *      OfferItem[] offer; // 0x40\n     *      ConsiderationItem[] consideration; // 0x60\n     *      OrderType orderType; // 0x80\n     *      uint256 startTime; // 0xa0\n     *      uint256 endTime; // 0xc0\n     *      bytes32 zoneHash; // 0xe0\n     *      uint256 salt; // 0x100\n     *      bytes32 conduitKey; // 0x120\n     *      uint256 totalOriginalConsiderationItems; // 0x140\n     * }\n     *\n     * struct OfferItem {\n     *      ItemType itemType;\n     *      address token;\n     *      uint256 identifierOrCriteria;\n     *      uint256 startAmount;\n     *      uint256 endAmount;\n     * }\n     *\n     * struct ConsiderationItem {\n     *      ItemType itemType;\n     *      address token;\n     *      uint256 identifierOrCriteria;\n     *      uint256 startAmount;\n     *      uint256 endAmount;\n     *      address payable recipient;\n     * }\n     * ```\n     *\n     * REQUIRES:\n     * - There should only be one token for the `Offer`.\n     * - There should be two items in the `Consideration`.\n     * - The `zone` must be this contract's address.\n     * - The `orderType` must be `FULL_RESTRICTED`. This means only the `zone`,\n     * or the offerer, can fulfill the order.\n     * - The `conduitKey` must be zero. No conduit should be used.\n     * - The `totalOriginalConsiderationItems` must be 2.\n     *\n     * - The `Offer` item must be of type `ERC20`.\n     * - For the case of deleverage, `token` of the `Offer` item must be the\n     * `BASE` token.\n     * - The `startAmount` and `endAmount` of the `Offer` item must be equal to\n     * `debtToRepay`. Start and end should be equal because the amount is fixed.\n     *\n     * - The first `Consideration` item must be of type `ERC20`.\n     * - The `token` of the first `Consideration` item must be this contract's\n     * address. This is to allow this contract to gain control flow. We also\n     * want to use the `transferFrom()` args to communicate data to the\n     * `transferFrom()` callback. Any data that can't be fit into the\n     * `transferFrom()` args will be communicated through transient storage.\n     * - The `startAmount` and `endAmount` of the first `Consideration` item\n     * communicate the amount of debt to repay to the callback.\n     * - The `recipient` of the first `Consideration` item must be `msg.sender`.\n     * This will be user's vault that will be deleveraged. This contract assumes\n     * that caller is the owner of the vault.\n     *\n     * - The second `Consideration` item must be of type `ERC20`.\n     * - The `token` of the second `Consideration` item must be the `COLLATERAL`\n     * - The second `Consideration` item must have the `startAmount` and `endAmount`\n     * equal to `collateralToRemove`.\n     *\n     * We don't constrain the `recipient` of the second `Consideration` item.\n     *\n     * It is technically possible for two distinct orders to have the same\n     * parameters. The `salt` should be used to distinguish between two orders\n     * with the same parameters. Otherwise, they will map to the same order hash\n     * and only one of them will be able to be fulfilled.\n     *\n     * @param order Seaport order.\n     * @param collateralToRemove Amount of collateral to remove. [WAD]\n     * @param debtToRepay Amount of debt to repay. [WAD]\n     */\n    function deleverage(Order calldata order, uint256 collateralToRemove, uint256 debtToRepay) external {\n        uint256 currentCollateral = POOL.collateral(0, msg.sender);\n        if (collateralToRemove > currentCollateral) revert NotEnoughCollateral(collateralToRemove, currentCollateral);\n\n        OrderParameters calldata params = order.parameters;\n\n        _validateOrderParams(params);\n\n        OfferItem calldata offer1 = params.offer[0];\n\n        if (offer1.itemType != ItemType.ERC20) revert OItemTypeMustBeERC20(offer1.itemType);\n        if (offer1.token != address(BASE)) revert OTokenMustBeBase(offer1.token);\n        if (offer1.startAmount != debtToRepay) revert OStartMustBeDebtToRepay(offer1.startAmount, debtToRepay);\n        if (offer1.endAmount != debtToRepay) revert OEndMustBeDebtToRepay(offer1.endAmount, debtToRepay);\n\n        ConsiderationItem calldata consideration1 = params.consideration[0];\n\n        // forgefmt: disable-start\n        if (consideration1.itemType != ItemType.ERC20) \n            revert C1TypeMustBeERC20(consideration1.itemType);\n        if (consideration1.token != address(this)) \n            revert C1TokenMustBeThis(consideration1.token);\n        if (consideration1.startAmount != debtToRepay) \n            revert C1StartAmountMustBeDebtToRepay(consideration1.startAmount, debtToRepay);\n        if (consideration1.endAmount != debtToRepay) \n            revert C1EndAmountMustBeDebtToRepay(consideration1.endAmount, debtToRepay);\n        if (consideration1.recipient != msg.sender) \n            revert C1RecipientMustBeSender(consideration1.recipient);\n\n        ConsiderationItem calldata consideration2 = params.consideration[1];\n        \n        if (consideration2.itemType != ItemType.ERC20) \n            revert C2TypeMustBeERC20(consideration2.itemType);\n        if (consideration2.token != address(COLLATERAL)) \n            revert C2TokenMustBeCollateral(consideration2.token);\n        if (consideration2.startAmount != collateralToRemove) \n            revert C2StartMustBeCollateralToRemove(consideration2.startAmount, collateralToRemove);\n        if (consideration2.endAmount != collateralToRemove) \n            revert C2EndMustBeCollateralToRemove(consideration2.endAmount, collateralToRemove);\n        // forgefmt: disable-end\n\n        assembly {\n            tstore(TSLOT_AWAIT_CALLBACK, 1)\n            tstore(TSLOT_COLLATERAL_DELTA, collateralToRemove)\n        }\n\n        SEAPORT.fulfillOrder(order, bytes32(0));\n\n        // Maintain composability\n        assembly {\n            tstore(TSLOT_AWAIT_CALLBACK, 0)\n            tstore(TSLOT_COLLATERAL_DELTA, 0)\n        }\n    }\n\n    /**\n     * @notice This callback is not meant to be called directly.\n     *\n     * @dev This function selector has been mined to match the `transferFrom()`\n     * selector (`0x23b872dd`). We hijack the `transferFrom()` selector to be\n     * able to use the default Seaport flow. This is a callback from Seaport to\n     * give this contract control flow between the `Offer` being transferred and\n     * the `Consideration` being transferred.\n     *\n     * In order to enforce that this function is only called through a\n     * transaction initiated by this contract, we use the `onlyReentrant`\n     * modifier.\n     *\n     * This function can only be called by the Seaport contract.\n     *\n     * The second and the third arguments are used to communicate data necessary\n     * for the callback context. Transient storage is used to communicate any\n     * extra data that could not be fit into the `transferFrom()` args.\n     *\n     * @param user whose position to modify on `IonPool`\n     * @param debtToRepay amount of debt to repay on the `user`'s position\n     */\n    function seaportCallback4878572495(address, address user, uint256 debtToRepay) external onlySeaport onlyReentrant {\n        uint256 collateralToRemove;\n        assembly {\n            collateralToRemove := tload(TSLOT_COLLATERAL_DELTA)\n        }\n\n        uint256 currentRate = POOL.rate(0);\n        uint256 currentNormalizedDebt = POOL.normalizedDebt(0, user);\n\n        uint256 repayAmountNormalized = debtToRepay.rayDivDown(currentRate);\n\n        // In the case of a full deleverage, the Seaport order will not be able\n        // to predict the exact amount of debt to repay since this will change\n        // at execution time when debt is accrued. The order will have to to\n        // overestimate the amount of base token to be traded for through\n        // seaport. Excess base token will be refunded to the user.\n        if (repayAmountNormalized > currentNormalizedDebt) {\n            // Emulates IonPool calculation\n            uint256 neccesaryBase = currentNormalizedDebt.rayMulUp(currentRate);\n\n            BASE.transfer(user, debtToRepay - neccesaryBase);\n            POOL.repay(0, user, address(this), currentNormalizedDebt);\n\n            // Sanity check\n            assert(BASE.balanceOf(address(this)) == 0);\n        } else {\n            POOL.repay(0, user, address(this), repayAmountNormalized);\n        }\n\n        POOL.withdrawCollateral(0, user, address(this), collateralToRemove);\n        JOIN.exit(address(this), collateralToRemove);\n    }\n}"
    }
  ]
}