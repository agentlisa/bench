{
  "Title": "[G-17] Use assembly for math (add, sub, mul, div)",
  "Content": "\nUse assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow.\n\n```solidity\nfile: /src/pumps/MultiFlowPump.sol\n\n343        return ((numberOfReserves - 1) / 2 + 1) << 5;\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/pumps/MultiFlowPump.sol#L343\n\n```solidity\nfile: /src/functions/ConstantProduct2.sol\n\n65        reserve = lpTokenSupply ** 2;\n\n99        reserve = reserves[i] * ratios[j] / ratios[i];\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/functions/ConstantProduct2.sol#L65\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/functions/ConstantProduct2.sol#L99\n\n\n```solidity\nfile: /src/functions/ProportionalLPToken2.sol\n\n22        underlyingAmounts[0] = lpTokenAmount * reserves[0] / lpTokenSupply;\n23        underlyingAmounts[1] = lpTokenAmount * reserves[1] / lpTokenSupply;\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/functions/ProportionalLPToken2.sol#L22\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/functions/ProportionalLPToken2.sol#L23\n\n\n```solidity\nfile: /src/Well.sol\n\n90        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD;\n\n98        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD + wellFunctionDataLength();\n\n176        uint256 pumpDataLength = _getArgUint256(dataLoc + PACKED_ADDRESS);\n\n232        amountOut = reserveJBefore - reserves[j];\n\n282        amountIn = reserves[i] - reserveIBefore;\n\n\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Well.sol#L90\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Well.sol#L98\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Well.sol#L176\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Well.sol#L232\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Well.sol#L282\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/pumps/MultiFlowPump.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IMultiFlowPumpErrors} from \"src/interfaces/pumps/IMultiFlowPumpErrors.sol\";\nimport {IWell} from \"src/interfaces/IWell.sol\";\nimport {IInstantaneousPump} from \"src/interfaces/pumps/IInstantaneousPump.sol\";\nimport {ICumulativePump} from \"src/interfaces/pumps/ICumulativePump.sol\";\nimport {ABDKMathQuad} from \"src/libraries/ABDKMathQuad.sol\";\nimport {LibBytes16} from \"src/libraries/LibBytes16.sol\";\nimport {LibLastReserveBytes} from \"src/libraries/LibLastReserveBytes.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\n/**\n * @title MultiFlowPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\n * This Pump has 3 main features:\n *  1. Multi-block MEV resistence reserves\n *  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n *  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n *\n * Note: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\n * Each Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n */\ncontract MultiFlowPump is IPump, IMultiFlowPumpErrors, IInstantaneousPump, ICumulativePump {\n    using SafeCast for uint256;\n    using LibLastReserveBytes for bytes32;\n    using LibBytes16 for bytes32;\n    using ABDKMathQuad for bytes16;\n    using ABDKMathQuad for uint256;\n\n    bytes16 immutable LOG_MAX_INCREASE;\n    bytes16 immutable LOG_MAX_DECREASE;\n    bytes16 immutable ALPHA;\n    uint256 immutable BLOCK_TIME;\n\n    struct PumpState {\n        uint40 lastTimestamp;\n        bytes16[] lastReserves;\n        bytes16[] emaReserves;\n        bytes16[] cumulativeReserves;\n    }\n\n    /**\n     * @param _maxPercentIncrease The maximum percent increase allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _maxPercentDecrease The maximum percent decrease allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _blockTime The block time in the current EVM in seconds.\n     * @param _alpha The geometric EMA constant. Must be in quadruple precision format (See {ABDKMathQuad}).\n     */\n    constructor(bytes16 _maxPercentIncrease, bytes16 _maxPercentDecrease, uint256 _blockTime, bytes16 _alpha) {\n        LOG_MAX_INCREASE = ABDKMathQuad.ONE.add(_maxPercentIncrease).log_2();\n        // _maxPercentDecrease <= 100%\n        if (_maxPercentDecrease > ABDKMathQuad.ONE) {\n            revert InvalidMaxPercentDecreaseArgument(_maxPercentDecrease);\n        }\n        LOG_MAX_DECREASE = ABDKMathQuad.ONE.sub(_maxPercentDecrease).log_2();\n        BLOCK_TIME = _blockTime;\n\n        // ALPHA <= 1\n        if (_alpha > ABDKMathQuad.ONE) {\n            revert InvalidAArgument(_alpha);\n        }\n        ALPHA = _alpha;\n    }\n\n    //////////////////// PUMP ////////////////////\n\n    function update(uint256[] calldata reserves, bytes calldata) external {\n        uint256 numberOfReserves = reserves.length;\n        PumpState memory pumpState;\n\n        // All reserves are stored starting at the msg.sender address slot in storage.\n        bytes32 slot = _getSlotForAddress(msg.sender);\n\n        // Read: Last Timestamp & Last Reserves\n        (, pumpState.lastTimestamp, pumpState.lastReserves) = slot.readLastReserves();\n\n        // If the last timestamp is 0, then the pump has never been used before.\n        if (pumpState.lastTimestamp == 0) {\n            for (uint256 i; i < numberOfReserves; ++i) {\n                // If a reserve is 0, then the pump cannot be initialized.\n                if (reserves[i] == 0) return;\n            }\n            _init(slot, uint40(block.timestamp), reserves);\n            return;\n        }\n\n        // Read: Cumulative & EMA Reserves\n        // Start at the slot after `pumpState.lastReserves`\n        uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.emaReserves = slot.readBytes16(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.cumulativeReserves = slot.readBytes16(numberOfReserves);\n\n        bytes16 alphaN;\n        bytes16 deltaTimestampBytes;\n        bytes16 blocksPassed;\n        // Isolate in brackets to prevent stack too deep errors\n        {\n            uint256 deltaTimestamp = _getDeltaTimestamp(pumpState.lastTimestamp);\n            alphaN = ALPHA.powu(deltaTimestamp);\n            deltaTimestampBytes = deltaTimestamp.fromUInt();\n            // Relies on the assumption that a block can only occur every `BLOCK_TIME` seconds.\n            blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        }\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            // Use a minimum of 1 for reserve. Geometric means will be set to 0 if a reserve is 0.\n            pumpState.lastReserves[i] = _capReserve(\n                pumpState.lastReserves[i], (reserves[i] > 0 ? reserves[i] : 1).fromUIntToLog2(), blocksPassed\n            );\n            pumpState.emaReserves[i] =\n                pumpState.lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(pumpState.emaReserves[i].mul(alphaN));\n            pumpState.cumulativeReserves[i] =\n                pumpState.cumulativeReserves[i].add(pumpState.lastReserves[i].mul(deltaTimestampBytes));\n        }\n\n        // Write: Cumulative & EMA Reserves\n        // Order matters: work backwards to avoid using a new memory var to count up\n        slot.storeBytes16(pumpState.cumulativeReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n        slot.storeBytes16(pumpState.emaReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(uint40(block.timestamp), pumpState.lastReserves);\n    }\n\n    /**\n     * @dev On first update for a particular Well, initialize oracle with\n     * reserves data.\n     */\n    function _init(bytes32 slot, uint40 lastTimestamp, uint256[] memory reserves) internal {\n        uint256 numberOfReserves = reserves.length;\n        bytes16[] memory byteReserves = new bytes16[](numberOfReserves);\n\n        // Skip {_capReserve} since we have no prior reference\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            if (reserves[i] == 0) return;\n            byteReserves[i] = reserves[i].fromUIntToLog2();\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(lastTimestamp, byteReserves);\n\n        // Write: EMA Reserves\n        // Start at the slot after `byteReserves`\n        uint256 numSlots = _getSlotsOffset(byteReserves.length);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        slot.storeBytes16(byteReserves); // EMA Reserves\n    }\n\n    //////////////////// LAST RESERVES ////////////////////\n\n    function readLastReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        (uint8 numberOfReserves,, bytes16[] memory bytesReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = bytesReserves[i].pow_2ToUInt();\n        }\n    }\n\n    /**\n     * @dev Adds a cap to the reserve value to prevent extreme changes.\n     *\n     *  Linear space:\n     *     max reserve = (last reserve) * ((1 + MAX_PERCENT_CHANGE_PER_BLOCK) ^ blocks)\n     *\n     *  Log space:\n     *     log2(max reserve) = log2(last reserve) + blocks*log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     `bytes16 lastReserve`      <- log2(last reserve)\n     *     `bytes16 blocksPassed`     <- log2(blocks)\n     *     `bytes16 LOG_MAX_INCREASE` <- log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     ∴ `maxReserve = lastReserve + blocks*LOG_MAX_INCREASE`\n     *\n     */\n    function _capReserve(\n        bytes16 lastReserve,\n        bytes16 reserve,\n        bytes16 blocksPassed\n    ) internal view returns (bytes16 cappedReserve) {\n        // Reserve decreasing (lastReserve > reserve)\n        if (lastReserve.cmp(reserve) == 1) {\n            bytes16 minReserve = lastReserve.add(blocksPassed.mul(LOG_MAX_DECREASE));\n            // if reserve < minimum reserve, set reserve to minimum reserve\n            if (minReserve.cmp(reserve) == 1) reserve = minReserve;\n        }\n        // Rerserve Increasing or staying the same.\n        else {\n            bytes16 maxReserve = blocksPassed.mul(LOG_MAX_INCREASE);\n            maxReserve = lastReserve.add(maxReserve);\n            // If reserve > maximum reserve, set reserve to maximum reserve\n            if (reserve.cmp(maxReserve) == 1) reserve = maxReserve;\n        }\n        cappedReserve = reserve;\n    }\n\n    //////////////////// EMA RESERVES ////////////////////\n\n    function readLastInstantaneousReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory byteReserves = slot.readBytes16(numberOfReserves);\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = byteReserves[i].pow_2ToUInt();\n        }\n    }\n\n    function readInstantaneousReserves(address well, bytes memory) public view returns (uint256[] memory emaReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory lastEmaReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        bytes16 alphaN = ALPHA.powu(deltaTimestamp);\n        emaReserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            emaReserves[i] =\n                lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(lastEmaReserves[i].mul(alphaN)).pow_2ToUInt();\n        }\n    }\n\n    //////////////////// CUMULATIVE RESERVES ////////////////////\n\n    /**\n     * @notice Read the latest cumulative reserves of `well`.\n     */\n    function readLastCumulativeReserves(address well) public view returns (bytes16[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        reserves = slot.readBytes16(numberOfReserves);\n    }\n\n    function readCumulativeReserves(address well, bytes memory) public view returns (bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    function _readCumulativeReserves(address well) internal view returns (bytes16[] memory cumulativeReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        cumulativeReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 deltaTimestampBytes = deltaTimestamp.fromUInt();\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        // Currently, there is so support for overflow.\n        for (uint256 i; i < cumulativeReserves.length; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            cumulativeReserves[i] = cumulativeReserves[i].add(lastReserves[i].mul(deltaTimestampBytes));\n        }\n    }\n\n    function readTwaReserves(\n        address well,\n        bytes calldata startCumulativeReserves,\n        uint256 startTimestamp,\n        bytes memory\n    ) public view returns (uint256[] memory twaReserves, bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        bytes16[] memory byteStartCumulativeReserves = abi.decode(startCumulativeReserves, (bytes16[]));\n        twaReserves = new uint256[](byteCumulativeReserves.length);\n\n        // Overflow is desired on `startTimestamp`, so SafeCast is not used.\n        bytes16 deltaTimestamp = _getDeltaTimestamp(uint40(startTimestamp)).fromUInt();\n        if (deltaTimestamp == bytes16(0)) {\n            revert NoTimePassed();\n        }\n        for (uint256 i; i < byteCumulativeReserves.length; ++i) {\n            // Currently, there is no support for overflow.\n            twaReserves[i] =\n                (byteCumulativeReserves[i].sub(byteStartCumulativeReserves[i])).div(deltaTimestamp).pow_2ToUInt();\n        }\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    //////////////////// HELPERS ////////////////////\n\n    /**\n     * @dev Convert an `address` into a `bytes32` by zero padding the right 12 bytes.\n     */\n    function _getSlotForAddress(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue)); // Because right padded, no collision on adjacent\n    }\n\n    /**\n     * @dev Get the starting byte of the slot that contains the `n`th element of an array.\n     */\n    function _getSlotsOffset(uint256 numberOfReserves) internal pure returns (uint256) {\n        return ((numberOfReserves - 1) / 2 + 1) << 5;\n    }\n\n    /**\n     * @dev Get the delta between the current and provided timestamp as a `uint256`.\n     */\n    function _getDeltaTimestamp(uint40 lastTimestamp) internal view returns (uint256) {\n        return uint256(uint40(block.timestamp) - lastTimestamp);\n    }\n}"
    },
    {
      "filename": "src/functions/ConstantProduct2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IBeanstalkWellFunction} from \"src/interfaces/IBeanstalkWellFunction.sol\";\nimport {ProportionalLPToken2} from \"src/functions/ProportionalLPToken2.sol\";\nimport {LibMath} from \"src/libraries/LibMath.sol\";\n\n/**\n * @title ConstantProduct2\n * @author Publius\n * @notice Gas efficient Constant Product pricing function for Wells with 2 tokens.\n * @dev Constant Product Wells with 2 tokens use the formula:\n *  `b_0 * b_1 = s^2`\n *\n * Where:\n *  `s` is the supply of LP tokens\n *  `b_i` is the reserve at index `i`\n */\ncontract ConstantProduct2 is ProportionalLPToken2, IBeanstalkWellFunction {\n    using LibMath for uint256;\n\n    uint256 constant EXP_PRECISION = 1e12;\n\n    /**\n     * @dev `s = (b_0 * b_1)^(1/2)`\n     *\n     * When does this function overflow?\n     * ---------------------------------\n     *\n     * Let N be the length of the reserves array, and P be the precision multiplier\n     * defined in `EXP_PRECISION`.\n     *\n     * Assuming all tokens in reserves are at their maximum value simultaneously,\n     * this function will overflow when:\n     *\n     *  (10^X)^N * P >= MAX_UINT256 (~10^77)\n     *  10^(X*N) >= 10^77/P\n     *  (X*N)*ln(10) >= 77*ln(10) - ln(P)\n     *\n     *  ∴ X >= (1/N) * (77 - ln(P)/ln(10))\n     *\n     * ConstantProduct2 sets the constraints `N = 2` and `EXP_PRECISION = 1e12`,\n     * resulting in an upper bound of X = 32.5.\n     *\n     * In other words, {calcLpTokenSupply} overflows if all reserves are simultaneously\n     * >= 10^32.5, or about 100 trillion if tokens are measured to 18 decimal precision.\n     */\n    function calcLpTokenSupply(\n        uint256[] calldata reserves,\n        bytes calldata\n    ) external pure override returns (uint256 lpTokenSupply) {\n        lpTokenSupply = (reserves[0] * reserves[1] * EXP_PRECISION).sqrt();\n    }\n\n    /// @dev `b_j = s^2 / b_{i | i != j}`\n    /// @dev rounds up\n    function calcReserve(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256 lpTokenSupply,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        // Note: potential optimization is to use unchecked math here\n        reserve = lpTokenSupply ** 2;\n        reserve = LibMath.roundUpDiv(reserve, reserves[j == 1 ? 0 : 1] * EXP_PRECISION);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Constant Product 2\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"CP2\";\n    }\n\n    /// @dev `b_j = (b_0 * b_1 * r_j / r_i)^(1/2)`\n    /// Note: Always rounds down\n    function calcReserveAtRatioSwap(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256[] calldata ratios,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        uint256 i = j == 1 ? 0 : 1;\n        // use 512 muldiv for last mul to avoid overflow\n        reserve = (reserves[i] * reserves[j]).mulDiv(ratios[j], ratios[i]).sqrt();\n    }\n\n    /// @dev `b_j = b_i * r_j / r_i`\n    /// Note: Always rounds down\n    function calcReserveAtRatioLiquidity(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256[] calldata ratios,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        uint256 i = j == 1 ? 0 : 1;\n        reserve = reserves[i] * ratios[j] / ratios[i];\n    }\n}"
    },
    {
      "filename": "src/functions/ConstantProduct2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IBeanstalkWellFunction} from \"src/interfaces/IBeanstalkWellFunction.sol\";\nimport {ProportionalLPToken2} from \"src/functions/ProportionalLPToken2.sol\";\nimport {LibMath} from \"src/libraries/LibMath.sol\";\n\n/**\n * @title ConstantProduct2\n * @author Publius\n * @notice Gas efficient Constant Product pricing function for Wells with 2 tokens.\n * @dev Constant Product Wells with 2 tokens use the formula:\n *  `b_0 * b_1 = s^2`\n *\n * Where:\n *  `s` is the supply of LP tokens\n *  `b_i` is the reserve at index `i`\n */\ncontract ConstantProduct2 is ProportionalLPToken2, IBeanstalkWellFunction {\n    using LibMath for uint256;\n\n    uint256 constant EXP_PRECISION = 1e12;\n\n    /**\n     * @dev `s = (b_0 * b_1)^(1/2)`\n     *\n     * When does this function overflow?\n     * ---------------------------------\n     *\n     * Let N be the length of the reserves array, and P be the precision multiplier\n     * defined in `EXP_PRECISION`.\n     *\n     * Assuming all tokens in reserves are at their maximum value simultaneously,\n     * this function will overflow when:\n     *\n     *  (10^X)^N * P >= MAX_UINT256 (~10^77)\n     *  10^(X*N) >= 10^77/P\n     *  (X*N)*ln(10) >= 77*ln(10) - ln(P)\n     *\n     *  ∴ X >= (1/N) * (77 - ln(P)/ln(10))\n     *\n     * ConstantProduct2 sets the constraints `N = 2` and `EXP_PRECISION = 1e12`,\n     * resulting in an upper bound of X = 32.5.\n     *\n     * In other words, {calcLpTokenSupply} overflows if all reserves are simultaneously\n     * >= 10^32.5, or about 100 trillion if tokens are measured to 18 decimal precision.\n     */\n    function calcLpTokenSupply(\n        uint256[] calldata reserves,\n        bytes calldata\n    ) external pure override returns (uint256 lpTokenSupply) {\n        lpTokenSupply = (reserves[0] * reserves[1] * EXP_PRECISION).sqrt();\n    }\n\n    /// @dev `b_j = s^2 / b_{i | i != j}`\n    /// @dev rounds up\n    function calcReserve(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256 lpTokenSupply,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        // Note: potential optimization is to use unchecked math here\n        reserve = lpTokenSupply ** 2;\n        reserve = LibMath.roundUpDiv(reserve, reserves[j == 1 ? 0 : 1] * EXP_PRECISION);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Constant Product 2\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"CP2\";\n    }\n\n    /// @dev `b_j = (b_0 * b_1 * r_j / r_i)^(1/2)`\n    /// Note: Always rounds down\n    function calcReserveAtRatioSwap(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256[] calldata ratios,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        uint256 i = j == 1 ? 0 : 1;\n        // use 512 muldiv for last mul to avoid overflow\n        reserve = (reserves[i] * reserves[j]).mulDiv(ratios[j], ratios[i]).sqrt();\n    }\n\n    /// @dev `b_j = b_i * r_j / r_i`\n    /// Note: Always rounds down\n    function calcReserveAtRatioLiquidity(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256[] calldata ratios,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        uint256 i = j == 1 ? 0 : 1;\n        reserve = reserves[i] * ratios[j] / ratios[i];\n    }\n}"
    },
    {
      "filename": "src/functions/ProportionalLPToken2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\n\n/**\n * @title ProportionalLPToken2\n * @notice Defines a proportional relationship between the supply of LP tokens\n * and the amount of each underlying token for a two-token Well.\n * @dev When removing `s` LP tokens with a Well with `S` LP token supply, the user\n * recieves `s * b_i / S` of each underlying token.\n */\nabstract contract ProportionalLPToken2 is IWellFunction {\n    function calcLPTokenUnderlying(\n        uint256 lpTokenAmount,\n        uint256[] calldata reserves,\n        uint256 lpTokenSupply,\n        bytes calldata\n    ) external pure returns (uint256[] memory underlyingAmounts) {\n        underlyingAmounts = new uint256[](2);\n        underlyingAmounts[0] = lpTokenAmount * reserves[0] / lpTokenSupply;\n        underlyingAmounts[1] = lpTokenAmount * reserves[1] / lpTokenSupply;\n    }\n}"
    },
    {
      "filename": "src/functions/ProportionalLPToken2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\n\n/**\n * @title ProportionalLPToken2\n * @notice Defines a proportional relationship between the supply of LP tokens\n * and the amount of each underlying token for a two-token Well.\n * @dev When removing `s` LP tokens with a Well with `S` LP token supply, the user\n * recieves `s * b_i / S` of each underlying token.\n */\nabstract contract ProportionalLPToken2 is IWellFunction {\n    function calcLPTokenUnderlying(\n        uint256 lpTokenAmount,\n        uint256[] calldata reserves,\n        uint256 lpTokenSupply,\n        bytes calldata\n    ) external pure returns (uint256[] memory underlyingAmounts) {\n        underlyingAmounts = new uint256[](2);\n        underlyingAmounts[0] = lpTokenAmount * reserves[0] / lpTokenSupply;\n        underlyingAmounts[1] = lpTokenAmount * reserves[1] / lpTokenSupply;\n    }\n}"
    },
    {
      "filename": "src/Well.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {ReentrancyGuardUpgradeable} from \"ozu/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC20Upgradeable, ERC20PermitUpgradeable} from \"ozu/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {IERC20, SafeERC20} from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\nimport {IWell, Call} from \"src/interfaces/IWell.sol\";\nimport {IWellErrors} from \"src/interfaces/IWellErrors.sol\";\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\nimport {LibBytes} from \"src/libraries/LibBytes.sol\";\nimport {ClonePlus} from \"src/utils/ClonePlus.sol\";\n\n/**\n * @title Well\n * @author Publius, Silo Chad, Brean\n * @dev A Well is a constant function AMM allowing the provisioning of liquidity\n * into a single pooled on-chain liquidity position.\n */\ncontract Well is ERC20PermitUpgradeable, IWell, IWellErrors, ReentrancyGuardUpgradeable, ClonePlus {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    uint256 constant ONE_WORD = 32;\n    uint256 constant PACKED_ADDRESS = 20;\n    uint256 constant ONE_WORD_PLUS_PACKED_ADDRESS = 52; // For gas efficiency purposes\n    bytes32 constant RESERVES_STORAGE_SLOT = bytes32(uint256(keccak256(\"reserves.storage.slot\")) - 1);\n\n    function init(string memory name, string memory symbol) public initializer {\n        __ERC20Permit_init(name);\n        __ERC20_init(name, symbol);\n\n        IERC20[] memory _tokens = tokens();\n        for (uint256 i; i < _tokens.length - 1; ++i) {\n            for (uint256 j = i + 1; j < _tokens.length; ++j) {\n                if (_tokens[i] == _tokens[j]) {\n                    revert DuplicateTokens(_tokens[i]);\n                }\n            }\n        }\n    }\n\n    //////////////////// WELL DEFINITION ////////////////////\n\n    /// This Well uses a dynamic immutable storage layout. Immutable storage is\n    /// used for gas-efficient reads during Well operation. The Well must be\n    /// created by cloning with a pre-encoded byte string containing immutable\n    /// data.\n    ///\n    /// Let n = number of tokens\n    ///     m = length of well function data (bytes)\n    ///\n    /// TYPE        NAME                       LOCATION (CONSTANT)\n    /// ==============================================================\n    /// address     aquifer()                  0        (LOC_AQUIFER_ADDR)\n    /// uint256     numberOfTokens()           20       (LOC_TOKENS_COUNT)\n    /// address     wellFunctionAddress()      52       (LOC_WELL_FUNCTION_ADDR)\n    /// uint256     wellFunctionDataLength()   72       (LOC_WELL_FUNCTION_DATA_LENGTH)\n    /// uint256     numberOfPumps()            104      (LOC_PUMPS_COUNT)\n    /// --------------------------------------------------------------\n    /// address     token0                     136      (LOC_VARIABLE)\n    /// ...\n    /// address     tokenN                     136 + (n-1) * 32\n    /// --------------------------------------------------------------\n    /// byte        wellFunctionData0          136 + n * 32\n    /// ...\n    /// byte        wellFunctionDataM          136 + n * 32 + m\n    /// --------------------------------------------------------------\n    /// address     pump1Address               136 + n * 32 + m\n    /// uint256     pump1DataLength            136 + n * 32 + m + 20\n    /// byte        pump1Data                  136 + n * 32 + m + 52\n    /// ...\n    /// ==============================================================\n\n    uint256 constant LOC_AQUIFER_ADDR = 0;\n    uint256 constant LOC_TOKENS_COUNT = LOC_AQUIFER_ADDR + PACKED_ADDRESS;\n    uint256 constant LOC_WELL_FUNCTION_ADDR = LOC_TOKENS_COUNT + ONE_WORD;\n    uint256 constant LOC_WELL_FUNCTION_DATA_LENGTH = LOC_WELL_FUNCTION_ADDR + PACKED_ADDRESS;\n    uint256 constant LOC_PUMPS_COUNT = LOC_WELL_FUNCTION_DATA_LENGTH + ONE_WORD;\n    uint256 constant LOC_VARIABLE = LOC_PUMPS_COUNT + ONE_WORD;\n\n    function tokens() public pure returns (IERC20[] memory ts) {\n        ts = _getArgIERC20Array(LOC_VARIABLE, numberOfTokens());\n    }\n\n    function wellFunction() public pure returns (Call memory _wellFunction) {\n        _wellFunction.target = wellFunctionAddress();\n        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD;\n        _wellFunction.data = _getArgBytes(dataLoc, wellFunctionDataLength());\n    }\n\n    function pumps() public pure returns (Call[] memory _pumps) {\n        if (numberOfPumps() == 0) return _pumps;\n\n        _pumps = new Call[](numberOfPumps());\n        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD + wellFunctionDataLength();\n\n        uint256 pumpDataLength;\n        for (uint256 i; i < _pumps.length; i++) {\n            _pumps[i].target = _getArgAddress(dataLoc);\n            dataLoc += PACKED_ADDRESS;\n            pumpDataLength = _getArgUint256(dataLoc);\n            dataLoc += ONE_WORD;\n            _pumps[i].data = _getArgBytes(dataLoc, pumpDataLength);\n            dataLoc += pumpDataLength;\n        }\n    }\n\n    /**\n     * @dev {wellData} is unused in this implementation.\n     */\n    function wellData() public pure returns (bytes memory) {}\n\n    function aquifer() public pure override returns (address) {\n        return _getArgAddress(LOC_AQUIFER_ADDR);\n    }\n\n    function well()\n        external\n        pure\n        returns (\n            IERC20[] memory _tokens,\n            Call memory _wellFunction,\n            Call[] memory _pumps,\n            bytes memory _wellData,\n            address _aquifer\n        )\n    {\n        _tokens = tokens();\n        _wellFunction = wellFunction();\n        _pumps = pumps();\n        _wellData = wellData();\n        _aquifer = aquifer();\n    }\n\n    //////////////////// WELL DEFINITION: HELPERS ////////////////////\n\n    /**\n     * @notice Returns the number of tokens that are tradable in this Well.\n     * @dev Length of the `tokens()` array.\n     */\n    function numberOfTokens() public pure returns (uint256) {\n        return _getArgUint256(LOC_TOKENS_COUNT);\n    }\n\n    /**\n     * @notice Returns the address of the Well Function.\n     */\n    function wellFunctionAddress() public pure returns (address) {\n        return _getArgAddress(LOC_WELL_FUNCTION_ADDR);\n    }\n\n    /**\n     * @notice Returns the length of the configurable `data` parameter passed during calls to the Well Function.\n     */\n    function wellFunctionDataLength() public pure returns (uint256) {\n        return _getArgUint256(LOC_WELL_FUNCTION_DATA_LENGTH);\n    }\n\n    /**\n     * @notice Returns the number of Pumps which this Well was initialized with.\n     */\n    function numberOfPumps() public pure returns (uint256) {\n        return _getArgUint256(LOC_PUMPS_COUNT);\n    }\n\n    /**\n     * @notice Returns address & data used to call the first Pump.\n     * @dev Provided as an optimization in the case where {numberOfPumps} returns 1.\n     */\n    function firstPump() public pure returns (Call memory _pump) {\n        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD + wellFunctionDataLength();\n        _pump.target = _getArgAddress(dataLoc);\n        uint256 pumpDataLength = _getArgUint256(dataLoc + PACKED_ADDRESS);\n        _pump.data = _getArgBytes(dataLoc + ONE_WORD_PLUS_PACKED_ADDRESS, pumpDataLength);\n    }\n\n    //////////////////// SWAP: FROM ////////////////////\n\n    /**\n     * @dev MUST revert if a fee on transfer token is used. The requisite check\n     * is performed in {_setReserves}.\n     */\n    function swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 amountOut) {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    /**\n     * @dev Note that `amountOut` is the amount *transferred* by the Well; if a fee\n     * is charged on transfers of `toToken`, the amount received by `recipient`\n     * will be less than `amountOut`.\n     */\n    function swapFromFeeOnTransfer(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 amountOut) {\n        amountIn = _safeTransferFromFeeOnTransfer(fromToken, msg.sender, amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    function _swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient\n    ) internal returns (uint256 amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory re"
    }
  ]
}