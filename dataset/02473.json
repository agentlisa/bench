{
  "Title": "M-2: Censorship resistance is undermined and bridging of assets can be DOSed at low cost",
  "Content": "# Issue M-2: Censorship resistance is undermined and bridging of assets can be DOSed at low cost \n\nSource: https://github.com/sherlock-audit/2023-01-optimism-judging/issues/277 \n\n## Found by \nobront, Robert, cergyk\n\n## Summary\n\nAll L1->L2 transactions go through OptimismPortal's `depositTransaction` function. It is wrapped through the `metered` modifier. The goal is to create a gas market for L1->L2 transactions and not allow L1 TXs to fill up L2 batches (as the gas for deposit TX in L2 is payed for by the system), but the mechanism used makes it too inexpensive for a malicious user to DOS and censor deposits.\n\n## Vulnerability Detail\n\nIt is possible for a malicious actor to snipe arbitrary L1->L2 transactions in the mempool for far too cheaply. This introduces two impacts:\n1. Undermines censorship resistance guarantees by Optimism\n2. Griefs users who simply want to bridge assets to L2\n\nThe core issue is the check in ResourceMetering.sol:\n```solidity\n// Make sure we can actually buy the resource amount requested by the user.\nparams.prevBoughtGas += _amount;\nrequire(\n    int256(uint256(params.prevBoughtGas)) <= MAX_RESOURCE_LIMIT,\n    \"ResourceMetering: cannot buy more gas than available gas limit\"\n);\n```\nNote that `params.prevBoughtGas` is reset per block. This means attacker can view a TX in the mempool and wrap up the following flashbot bundle:\n1. Attacker TX to `depositTransaction`, with gasLimit = 8M (MAX_RESOURCE_LIMIT)\n2. Victim TX to `depositTransaction`\n\nThe result is that attacker's transaction will execute and victim's TX would revert. It is unknown how this affects the UI and whether victim would be able to resubmit this TX again easily, but regardless it's clearly griefing user's attempt to bridge an asset. Note that a reverted TX is different from an uncompleted TX from a UX point of view.\n\nFrom a censorship resistance perspective, there is nothing inherently preventing attack to continually use this technique to block out all TXs, albert gas metering price will rise as will be discussed.\n\nNow we can demonstrate the cost of the attack to be low. Gas burned by the modifier is calculated as:\n```solidity\n// Determine the amount of ETH to be paid.\nuint256 resourceCost = _amount * params.prevBaseFee;\n...\nuint256 gasCost = resourceCost / Math.max(block.basefee, 1000000000);\n```\n`params.prevBaseFee` is initialized at 1e9 and goes up per block by a factor of 1.375 when gas market is drained, while going down by 0.875 when gas market wasn't used at all. \n\nIf we take the initial value, `resourceCost = 8e6 * 1e9 = 8e15`. If we assume tip is negligible to `block.basefee`, L1 gas cost in ETH equals `resourceCost` (divide by basefee and multiply by basefee). Therefore, cost of this snipe TX is:\n\n`8e15 / 1e18 (ETH decimals) * 1600 (curr ETH price) = $12.80`\n\nThe result is an extremely low price to pay, and even taking into account extra tips for frontrunning, is easily achievable. \n\nIn practice `prevBaseFee` will represent the market price for L2 gas. If it goes lower than initial value, DOSing will become cheaper, while if it goes higher it will become more expensive. The key problem is that the attacker's cost is too similar to the victim's cost. If victim is trying to pass a 400k TX, attacker needs to buy a 7.6M of gas. This gap is too small and the resulting situation is that for DOS to be too expensive for attacker, TX would have to be far too expensive for the average user. \n\n## Impact\n\nCensorship resistance is undermined and bridging of assets can be DOSed at low cost.\n\n## Code Snippet\n\nhttps://github.com/ethereum-optimism/optimism/blob/407f97b9d13448b766624995ec824d3059d4d4f6/packages/contracts-bedrock/contracts/L1/ResourceMetering.sol#L133\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is admittedly difficult to balance the need for censorship resistance with the prevention of L2 flooding via L1 TXs. However, the current solution which will make a victim's TX revert at hacker's will is inadequate and will lead to severe UX issues for users. \n\nRecommendation would be to not require gas spending to be under `MAX_RESOURCE_LIMIT` and solve it in L2 sequencing. It's already close enough to the L1 gas limit so that it can't be really abused. \n\n## Discussion\n\n**rcstanciu**\n\nComment from Optimism\n\n---\n\n **Description:** Deposit griefing by front running and filling up the MAX_RESOURCE_LIMIT\n\n\n **Reason:** DOS\n\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/38",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/L1/ResourceMetering.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { Burn } from \"../libraries/Burn.sol\";\nimport { Arithmetic } from \"../libraries/Arithmetic.sol\";\n\n/**\n * @custom:upgradeable\n * @title ResourceMetering\n * @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\n *         updates automatically based on current demand.\n */\nabstract contract ResourceMetering is Initializable {\n    /**\n     * @notice Represents the various parameters that control the way in which resources are\n     *         metered. Corresponds to the EIP-1559 resource metering system.\n     *\n     * @custom:field prevBaseFee   Base fee from the previous block(s).\n     * @custom:field prevBoughtGas Amount of gas bought so far in the current block.\n     * @custom:field prevBlockNum  Last block number that the base fee was updated.\n     */\n    struct ResourceParams {\n        uint128 prevBaseFee;\n        uint64 prevBoughtGas;\n        uint64 prevBlockNum;\n    }\n\n    /**\n     * @notice Maximum amount of the resource that can be used within this block.\n     */\n    int256 public constant MAX_RESOURCE_LIMIT = 8_000_000;\n\n    /**\n     * @notice Along with the resource limit, determines the target resource limit.\n     */\n    int256 public constant ELASTICITY_MULTIPLIER = 4;\n\n    /**\n     * @notice Target amount of the resource that should be used within this block.\n     */\n    int256 public constant TARGET_RESOURCE_LIMIT = MAX_RESOURCE_LIMIT / ELASTICITY_MULTIPLIER;\n\n    /**\n     * @notice Denominator that determines max change on fee per block.\n     */\n    int256 public constant BASE_FEE_MAX_CHANGE_DENOMINATOR = 8;\n\n    /**\n     * @notice Minimum base fee value, cannot go lower than this.\n     */\n    int256 public constant MINIMUM_BASE_FEE = 10_000;\n\n    /**\n     * @notice Maximum base fee value, cannot go higher than this.\n     */\n    int256 public constant MAXIMUM_BASE_FEE = int256(uint256(type(uint128).max));\n\n    /**\n     * @notice Initial base fee value.\n     */\n    uint128 public constant INITIAL_BASE_FEE = 1_000_000_000;\n\n    /**\n     * @notice EIP-1559 style gas parameters.\n     */\n    ResourceParams public params;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[48] private __gap;\n\n    /**\n     * @notice Meters access to a function based an amount of a requested resource.\n     *\n     * @param _amount Amount of the resource requested.\n     */\n    modifier metered(uint64 _amount) {\n        // Record initial gas amount so we can refund for it later.\n        uint256 initialGas = gasleft();\n\n        // Run the underlying function.\n        _;\n\n        // Update block number and base fee if necessary.\n        uint256 blockDiff = block.number - params.prevBlockNum;\n        if (blockDiff > 0) {\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\n            // at which deposits can be created and therefore limit the potential for deposits to\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - TARGET_RESOURCE_LIMIT;\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta) /\n                TARGET_RESOURCE_LIMIT /\n                BASE_FEE_MAX_CHANGE_DENOMINATOR;\n\n            // Update base fee by adding the base fee delta and clamp the resulting value between\n            // min and max.\n            int256 newBaseFee = Arithmetic.clamp(\n                int256(uint256(params.prevBaseFee)) + baseFeeDelta,\n                MINIMUM_BASE_FEE,\n                MAXIMUM_BASE_FEE\n            );\n\n            // If we skipped more than one block, we also need to account for every empty block.\n            // Empty block means there was no demand for deposits in that block, so we should\n            // reflect this lack of demand in the fee.\n            if (blockDiff > 1) {\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\n                // between min and max.\n                newBaseFee = Arithmetic.clamp(\n                    Arithmetic.cdexp(\n                        newBaseFee,\n                        BASE_FEE_MAX_CHANGE_DENOMINATOR,\n                        int256(blockDiff - 1)\n                    ),\n                    MINIMUM_BASE_FEE,\n                    MAXIMUM_BASE_FEE\n                );\n            }\n\n            // Update new base fee, reset bought gas, and update block number.\n            params.prevBaseFee = uint128(uint256(newBaseFee));\n            params.prevBoughtGas = 0;\n            params.prevBlockNum = uint64(block.number);\n        }\n\n        // Make sure we can actually buy the resource amount requested by the user.\n        params.prevBoughtGas += _amount;\n        require(\n            int256(uint256(params.prevBoughtGas)) <= MAX_RESOURCE_LIMIT,\n            \"ResourceMetering: cannot buy more gas than available gas limit\"\n        );\n\n        // Determine the amount of ETH to be paid.\n        uint256 resourceCost = _amount * params.prevBaseFee;\n\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\n        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\n        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\n        // during any 1 day period in the last 5 years, so should be fine.\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1000000000);\n\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\n        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\n        // effectively like a dynamic stipend (with a minimum value).\n        uint256 usedGas = initialGas - gasleft();\n        if (gasCost > usedGas) {\n            Burn.gas(gasCost - usedGas);\n        }\n    }\n\n    /**\n     * @notice Sets initial resource parameter values. This function must either be called by the\n     *         initializer function of an upgradeable child contract.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __ResourceMetering_init() internal onlyInitializing {\n        params = ResourceParams({\n            prevBaseFee: INITIAL_BASE_FEE,\n            prevBoughtGas: 0,\n            prevBlockNum: uint64(block.number)\n        });\n    }\n}"
    }
  ]
}