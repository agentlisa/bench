{
  "Title": "[N-01] Lack of address existence check",
  "Content": "There are 3 instances of this\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/UTBExecutor.sol#L52\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/UTBExecutor.sol#L65\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/UTBExecutor.sol#L70\n\nThe `target` address in the `execute(...)` function was not checked for address existence before making a `.call(...)` to it.\n\nAccording to Solidity docs: \n\n> The low-level functions call, delegatecall and staticcall return true as their >first return value if the account called is non-existent, as part of the design of >the EVM. Account existence must be checked prior to calling if needed.\n\nSource: https://docs.soliditylang.org/en/latest/control-structures.html#error-handling-assert-require-revert-and-exceptions\n\n### Impact\n\nIf `target` address does not exist, the boolean return value from `.call(...)` will return true when infact the asset was not transferred.\n\n### Recommendation: \n\nImplement contract existence check before `address.call()`.\n```\nfunction doesContractExist(address contractAddress) external view returns (bool) {\n        // Check if the contract's code size is greater than zero\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(contractAddress)\n        }\n        return codeSize > 0;\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "src/UTBExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\n\ncontract UTBExecutor is Owned {\n    constructor() Owned(msg.sender) {}\n\n    /**\n     * @dev Executes a payment transaction with native OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund\n    ) public payable onlyOwner {\n        return\n            execute(target, paymentOperator, payload, token, amount, refund, 0);\n    }\n\n    /**\n     * @dev Executes a payment transaction with native AND/OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     * @param extraNative Forwards additional gas or native fees required to executing the payment transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund,\n        uint extraNative\n    ) public onlyOwner {\n        bool success;\n        if (token == address(0)) {\n            (success, ) = target.call{value: amount}(payload);\n            if (!success) {\n                (refund.call{value: amount}(\"\"));\n            }\n            return;\n        }\n\n        uint initBalance = IERC20(token).balanceOf(address(this));\n\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        IERC20(token).approve(paymentOperator, amount);\n\n        if (extraNative > 0) {\n            (success, ) = target.call{value: extraNative}(payload);\n            if (!success) {\n                (refund.call{value: extraNative}(\"\"));\n            }\n        } else {\n            (success, ) = target.call(payload);\n        }\n\n        uint remainingBalance = IERC20(token).balanceOf(address(this)) -\n            initBalance;\n\n        if (remainingBalance == 0) {\n            return;\n        }\n\n        IERC20(token).transfer(refund, remainingBalance);\n    }\n}"
    },
    {
      "filename": "src/UTBExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\n\ncontract UTBExecutor is Owned {\n    constructor() Owned(msg.sender) {}\n\n    /**\n     * @dev Executes a payment transaction with native OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund\n    ) public payable onlyOwner {\n        return\n            execute(target, paymentOperator, payload, token, amount, refund, 0);\n    }\n\n    /**\n     * @dev Executes a payment transaction with native AND/OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     * @param extraNative Forwards additional gas or native fees required to executing the payment transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund,\n        uint extraNative\n    ) public onlyOwner {\n        bool success;\n        if (token == address(0)) {\n            (success, ) = target.call{value: amount}(payload);\n            if (!success) {\n                (refund.call{value: amount}(\"\"));\n            }\n            return;\n        }\n\n        uint initBalance = IERC20(token).balanceOf(address(this));\n\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        IERC20(token).approve(paymentOperator, amount);\n\n        if (extraNative > 0) {\n            (success, ) = target.call{value: extraNative}(payload);\n            if (!success) {\n                (refund.call{value: extraNative}(\"\"));\n            }\n        } else {\n            (success, ) = target.call(payload);\n        }\n\n        uint remainingBalance = IERC20(token).balanceOf(address(this)) -\n            initBalance;\n\n        if (remainingBalance == 0) {\n            return;\n        }\n\n        IERC20(token).transfer(refund, remainingBalance);\n    }\n}"
    },
    {
      "filename": "src/UTBExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\n\ncontract UTBExecutor is Owned {\n    constructor() Owned(msg.sender) {}\n\n    /**\n     * @dev Executes a payment transaction with native OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund\n    ) public payable onlyOwner {\n        return\n            execute(target, paymentOperator, payload, token, amount, refund, 0);\n    }\n\n    /**\n     * @dev Executes a payment transaction with native AND/OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     * @param extraNative Forwards additional gas or native fees required to executing the payment transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund,\n        uint extraNative\n    ) public onlyOwner {\n        bool success;\n        if (token == address(0)) {\n            (success, ) = target.call{value: amount}(payload);\n            if (!success) {\n                (refund.call{value: amount}(\"\"));\n            }\n            return;\n        }\n\n        uint initBalance = IERC20(token).balanceOf(address(this));\n\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        IERC20(token).approve(paymentOperator, amount);\n\n        if (extraNative > 0) {\n            (success, ) = target.call{value: extraNative}(payload);\n            if (!success) {\n                (refund.call{value: extraNative}(\"\"));\n            }\n        } else {\n            (success, ) = target.call(payload);\n        }\n\n        uint remainingBalance = IERC20(token).balanceOf(address(this)) -\n            initBalance;\n\n        if (remainingBalance == 0) {\n            return;\n        }\n\n        IERC20(token).transfer(refund, remainingBalance);\n    }\n}"
    }
  ]
}