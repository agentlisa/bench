{
  "Title": "Unused Variable",
  "Content": "In the Comet contract's [`absorb` function, the `gasUsed` variable is instantiated but never used](https://github.com/compound-finance/comet/blob/149284098ee0c59654d09b005ce8cae6f6cc9bf0/contracts/Comet.sol#L1115).\n\n\nIn order to maintain cohesive, easily understood code, consider removing the unused variable entirely.\n\n\n***Update:** Acknowledged, not resolved. The Scroll team stated:*\n\n\n\n> *Leaving gasUsed in the code to minimize code changes from the original Comet contracts*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Comet.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\nimport \"./CometMainInterface.sol\";\nimport \"./ERC20.sol\";\nimport \"./IPriceFeed.sol\";\n\n/**\n * @title Compound's Comet Contract\n * @notice An efficient monolithic money market protocol\n * @author Compound\n */\ncontract Comet is CometMainInterface {\n    /** General configuration constants **/\n\n    /// @notice The admin of the protocol\n    address public override immutable governor;\n\n    /// @notice The account which may trigger pauses\n    address public override immutable pauseGuardian;\n\n    /// @notice The address of the base token contract\n    address public override immutable baseToken;\n\n    /// @notice The address of the price feed for the base token\n    address public override immutable baseTokenPriceFeed;\n\n    /// @notice The address of the extension contract delegate\n    address public override immutable extensionDelegate;\n\n    /// @notice The point in the supply rates separating the low interest rate slope and the high interest rate slope (factor)\n    /// @dev uint64\n    uint public override immutable supplyKink;\n\n    /// @notice Per second supply interest rate slope applied when utilization is below kink (factor)\n    /// @dev uint64\n    uint public override immutable supplyPerSecondInterestRateSlopeLow;\n\n    /// @notice Per second supply interest rate slope applied when utilization is above kink (factor)\n    /// @dev uint64\n    uint public override immutable supplyPerSecondInterestRateSlopeHigh;\n\n    /// @notice Per second supply base interest rate (factor)\n    /// @dev uint64\n    uint public override immutable supplyPerSecondInterestRateBase;\n\n    /// @notice The point in the borrow rate separating the low interest rate slope and the high interest rate slope (factor)\n    /// @dev uint64\n    uint public override immutable borrowKink;\n\n    /// @notice Per second borrow interest rate slope applied when utilization is below kink (factor)\n    /// @dev uint64\n    uint public override immutable borrowPerSecondInterestRateSlopeLow;\n\n    /// @notice Per second borrow interest rate slope applied when utilization is above kink (factor)\n    /// @dev uint64\n    uint public override immutable borrowPerSecondInterestRateSlopeHigh;\n\n    /// @notice Per second borrow base interest rate (factor)\n    /// @dev uint64\n    uint public override immutable borrowPerSecondInterestRateBase;\n\n    /// @notice The fraction of the liquidation penalty that goes to buyers of collateral instead of the protocol\n    /// @dev uint64\n    uint public override immutable storeFrontPriceFactor;\n\n    /// @notice The scale for base token (must be less than 18 decimals)\n    /// @dev uint64\n    uint public override immutable baseScale;\n\n    /// @notice The scale for reward tracking\n    /// @dev uint64\n    uint public override immutable trackingIndexScale;\n\n    /// @notice The speed at which supply rewards are tracked (in trackingIndexScale)\n    /// @dev uint64\n    uint public override immutable baseTrackingSupplySpeed;\n\n    /// @notice The speed at which borrow rewards are tracked (in trackingIndexScale)\n    /// @dev uint64\n    uint public override immutable baseTrackingBorrowSpeed;\n\n    /// @notice The minimum amount of base principal wei for rewards to accrue\n    /// @dev This must be large enough so as to prevent division by base wei from overflowing the 64 bit indices\n    /// @dev uint104\n    uint public override immutable baseMinForRewards;\n\n    /// @notice The minimum base amount required to initiate a borrow\n    uint public override immutable baseBorrowMin;\n\n    /// @notice The minimum base token reserves which must be held before collateral is hodled\n    uint public override immutable targetReserves;\n\n    /// @notice The number of decimals for wrapped base token\n    uint8 public override immutable decimals;\n\n    /// @notice The number of assets this contract actually supports\n    uint8 public override immutable numAssets;\n\n    /// @notice Factor to divide by when accruing rewards in order to preserve 6 decimals (i.e. baseScale / 1e6)\n    uint internal immutable accrualDescaleFactor;\n\n    /** Collateral asset configuration (packed) **/\n\n    uint256 internal immutable asset00_a;\n    uint256 internal immutable asset00_b;\n    uint256 internal immutable asset01_a;\n    uint256 internal immutable asset01_b;\n    uint256 internal immutable asset02_a;\n    uint256 internal immutable asset02_b;\n    uint256 internal immutable asset03_a;\n    uint256 internal immutable asset03_b;\n    uint256 internal immutable asset04_a;\n    uint256 internal immutable asset04_b;\n    uint256 internal immutable asset05_a;\n    uint256 internal immutable asset05_b;\n    uint256 internal immutable asset06_a;\n    uint256 internal immutable asset06_b;\n    uint256 internal immutable asset07_a;\n    uint256 internal immutable asset07_b;\n    uint256 internal immutable asset08_a;\n    uint256 internal immutable asset08_b;\n    uint256 internal immutable asset09_a;\n    uint256 internal immutable asset09_b;\n    uint256 internal immutable asset10_a;\n    uint256 internal immutable asset10_b;\n    uint256 internal immutable asset11_a;\n    uint256 internal immutable asset11_b;\n    uint256 internal immutable asset12_a;\n    uint256 internal immutable asset12_b;\n    uint256 internal immutable asset13_a;\n    uint256 internal immutable asset13_b;\n    uint256 internal immutable asset14_a;\n    uint256 internal immutable asset14_b;\n\n    /**\n     * @notice Construct a new protocol instance\n     * @param config The mapping of initial/constant parameters\n     **/\n    constructor(Configuration memory config) {\n        // Sanity checks\n        uint8 decimals_ = ERC20(config.baseToken).decimals();\n        if (decimals_ > MAX_BASE_DECIMALS) revert BadDecimals();\n        if (config.storeFrontPriceFactor > FACTOR_SCALE) revert BadDiscount();\n        if (config.assetConfigs.length > MAX_ASSETS) revert TooManyAssets();\n        if (config.baseMinForRewards == 0) revert BadMinimum();\n        if (IPriceFeed(config.baseTokenPriceFeed).decimals() != PRICE_FEED_DECIMALS) revert BadDecimals();\n\n        // Copy configuration\n        unchecked {\n            governor = config.governor;\n            pauseGuardian = config.pauseGuardian;\n            baseToken = config.baseToken;\n            baseTokenPriceFeed = config.baseTokenPriceFeed;\n            extensionDelegate = config.extensionDelegate;\n            storeFrontPriceFactor = config.storeFrontPriceFactor;\n\n            decimals = decimals_;\n            baseScale = uint64(10 ** decimals_);\n            trackingIndexScale = config.trackingIndexScale;\n            if (baseScale < BASE_ACCRUAL_SCALE) revert BadDecimals();\n            accrualDescaleFactor = baseScale / BASE_ACCRUAL_SCALE;\n\n            baseMinForRewards = config.baseMinForRewards;\n            baseTrackingSupplySpeed = config.baseTrackingSupplySpeed;\n            baseTrackingBorrowSpeed = config.baseTrackingBorrowSpeed;\n\n            baseBorrowMin = config.baseBorrowMin;\n            targetReserves = config.targetReserves;\n        }\n\n        // Set interest rate model configs\n        unchecked {\n            supplyKink = config.supplyKink;\n            supplyPerSecondInterestRateSlopeLow = config.supplyPerYearInterestRateSlopeLow / SECONDS_PER_YEAR;\n            supplyPerSecondInterestRateSlopeHigh = config.supplyPerYearInterestRateSlopeHigh / SECONDS_PER_YEAR;\n            supplyPerSecondInterestRateBase = config.supplyPerYearInterestRateBase / SECONDS_PER_YEAR;\n            borrowKink = config.borrowKink;\n            borrowPerSecondInterestRateSlopeLow = config.borrowPerYearInterestRateSlopeLow / SECONDS_PER_YEAR;\n            borrowPerSecondInterestRateSlopeHigh = config.borrowPerYearInterestRateSlopeHigh / SECONDS_PER_YEAR;\n            borrowPerSecondInterestRateBase = config.borrowPerYearInterestRateBase / SECONDS_PER_YEAR;\n        }\n\n        // Set asset info\n        numAssets = uint8(config.assetConfigs.length);\n\n        (asset00_a, asset00_b) = getPackedAssetInternal(config.assetConfigs, 0);\n        (asset01_a, asset01_b) = getPackedAssetInternal(config.assetConfigs, 1);\n        (asset02_a, asset02_b) = getPackedAssetInternal(config.assetConfigs, 2);\n        (asset03_a, asset03_b) = getPackedAssetInternal(config.assetConfigs, 3);\n        (asset04_a, asset04_b) = getPackedAssetInternal(config.assetConfigs, 4);\n        (asset05_a, asset05_b) = getPackedAssetInternal(config.assetConfigs, 5);\n        (asset06_a, asset06_b) = getPackedAssetInternal(config.assetConfigs, 6);\n        (asset07_a, asset07_b) = getPackedAssetInternal(config.assetConfigs, 7);\n        (asset08_a, asset08_b) = getPackedAssetInternal(config.assetConfigs, 8);\n        (asset09_a, asset09_b) = getPackedAssetInternal(config.assetConfigs, 9);\n        (asset10_a, asset10_b) = getPackedAssetInternal(config.assetConfigs, 10);\n        (asset11_a, asset11_b) = getPackedAssetInternal(config.assetConfigs, 11);\n        (asset12_a, asset12_b) = getPackedAssetInternal(config.assetConfigs, 12);\n        (asset13_a, asset13_b) = getPackedAssetInternal(config.assetConfigs, 13);\n        (asset14_a, asset14_b) = getPackedAssetInternal(config.assetConfigs, 14);\n    }\n\n    /**\n     * @notice Initialize storage for the contract\n     * @dev Can be used from constructor or proxy\n     */\n    function initializeStorage() override external {\n        if (lastAccrualTime != 0) revert AlreadyInitialized();\n\n        // Initialize aggregates\n        lastAccrualTime = getNowInternal();\n        baseSupplyIndex = BASE_INDEX_SCALE;\n        baseBorrowIndex = BASE_INDEX_SCALE;\n\n        // Implicit initialization (not worth increasing contract size)\n        // trackingSupplyIndex = 0;\n        // trackingBorrowIndex = 0;\n    }\n\n    /**\n     * @dev Checks and gets the packed asset info for storage\n     */\n    function getPackedAssetInternal(AssetConfig[] memory assetConfigs, uint i) internal view returns (uint256, uint256) {\n        AssetConfig memory assetConfig;\n        if (i < assetConfigs.length) {\n            assembly {\n                assetConfig := mload(add(add(assetConfigs, 0x20), mul(i, 0x20)))\n            }\n        } else {\n            return (0, 0);\n        }\n        address asset = assetConfig.asset;\n        address priceFeed = assetConfig.priceFeed;\n        uint8 decimals_ = assetConfig.decimals;\n\n        // Short-circuit if asset is nil\n        if (asset == address(0)) {\n            return (0, 0);\n        }\n\n        // Sanity check price feed and asset decimals\n        if (IPriceFeed(priceFeed).decimals() != PRICE_FEED_DECIMALS) revert BadDecimals();\n        if (ERC20(asset).decimals() != decimals_) revert BadDecimals();\n\n        // Ensure collateral factors are within range\n        if (assetConfig.borrowCollateralFactor >= assetConfig.liquidateCollateralFactor) revert BorrowCFTooLarge();\n        if (assetConfig.liquidateCollateralFactor > MAX_COLLATERAL_FACTOR) revert LiquidateCFTooLarge();\n\n        unchecked {\n            // Keep 4 decimals for each factor\n            uint64 descale = FACTOR_SCALE / 1e4;\n            uint16 borrowCollateralFactor = uint16(assetConfig.borrowCollateralFactor / descale);\n            uint16 liquidateCollateralFactor = uint16(assetConfig.liquidateCollateralFactor / descale);\n            uint16 liquidationFactor = uint16(assetConfig.liquidationFactor / descale);\n\n            // Be nice and check descaled values are still within range\n            if (borrowCollateralFactor >= liquidateCollateralFactor) revert BorrowCFTooLarge();\n\n            // Keep whole units of asset for supply cap\n            uint64 supplyCap = uint64(assetConfig.supplyCap / (10 ** decimals_));\n\n            uint256 word_a = (uint160(asset) << 0 |\n                              uint256(borrowCollateralFactor) << 160 |\n                              uint256(liquidateCollateralFactor) << 176 |\n                              uint256(liquidationFactor) << 192);\n            uint256 word_b = (uint160(priceFeed) << 0 |\n                              uint256(decimals_) << 160 |\n                              uint256(supplyCap) << 168);\n\n            return (word_a, word_b);\n        }\n    }\n\n    /**\n     * @notice Get the i-th asset info, according to the order they were passed in originally\n     * @param i The index of the asset info to get\n     * @return The asset info object\n     */\n    function getAssetInfo(uint8 i) override public view returns (AssetInfo memory) {\n        if (i >= numAssets) revert BadAsset();\n\n        uint256 word_a;\n        uint256 word_b;\n\n        if (i == 0) {\n            word_a = asset00_a;\n            word_b = asset00_b;\n        } else if (i == 1) {\n            word_a = asset01_a;\n            word_b = asset01_b;\n        } else if (i == 2) {\n            word_a = asset02_a;\n            word_b = asset02_b;\n        } else if (i == 3) {\n            word_a = asset03_a;\n            word_b = asset03_b;\n        } else if (i == 4) {\n            word_a = asset04_a;\n            word_b = asset04_b;\n        } else if (i == 5) {\n            word_a = asset05_a;\n            word_b = asset05_b;\n        } else if (i == 6) {\n            word_a = asset06_a;\n            word_b = asset06_b;\n        } else if (i == 7) {\n            word_a = asset07_a;\n            word_b = asset07_b;\n        } else if (i == 8) {\n            word_a = asset08_a;\n            word_b = asset08_b;\n        } else if (i == 9) {\n            word_a = asset09_a;\n            word_b = asset09_b;\n        } else if (i == 10) {\n            word_a = asset10_a;\n            word_b = asset10_b;\n        } else if (i == 11) {\n            word_a = asset11_a;\n            word_b = asset11_b;\n        } else if (i == 12) {\n            word_a = asset12_a;\n            word_b = asset12_b;\n        } else if (i == 13) {\n            word_a = asset13_a;\n            word_b = asset13_b;\n        } else if (i == 14) {\n            word_a = asset14_a;\n            word_b = asset14_b;\n        } else {\n            revert Absurd();\n        }\n\n        address asset = address(uint160(word_a & type(uint160).max));\n        uint64 rescale = FACTOR_SCALE / 1e4;\n        uint64 borrowCollateralFactor = uint64(((word_a >> 160) & type(uint16).max) * rescale);\n        uint64 liquidateCollateralFactor = uint64(((word_a >> 176) & type(uint16).max) * rescale);\n        uint64 liquidationFactor = uint64(((word_a >> 192) & type(uint16).max) * rescale);\n\n        address priceFeed = address(uint160(word_b & type(uint160).max));\n        uint8 decimals_ = uint8(((word_b >> 160) & type(uint8).max));\n        uint64 scale = uint64(10 ** decimals_);\n        uint128 supplyCap = uint128(((word_b >> 168) & type(uint64).max) * scale);\n\n        return AssetInfo({\n            offset: i,\n            asset: asset,\n            priceFeed: priceFeed,\n            scale: scale,\n            borrowCollateralFactor: borrowCollateralFactor,\n            liquidateCollateralFactor: liquidateCollateralFactor,\n            liquidationFactor: liquidationFactor,\n            supplyCap: supplyCap\n         });\n    }\n\n    /**\n     * @dev Determine index of asset that matches given address\n     */\n    function getAssetInfoByAddress(address asset) override public view returns (AssetInfo memory) {\n        for (uint8 i = 0; i < numAssets; ) {\n            AssetInfo memory assetInfo = getAssetInfo(i);\n            if (assetInfo.asset == asset) {\n                return assetInfo;\n            }\n            unchecked { i++; }\n        }\n        revert BadAsset();\n    }\n\n    /**\n     * @return The current timestamp\n     **/\n    function getNowInternal() virtual internal view returns (uint40) {\n        if (block.timestamp >= 2**40) revert TimestampTooLarge();\n        return uint40(block.timestamp);\n    }\n\n    /**\n     * @dev Calculate accrued interest indices for base token supply and borrows\n     **/\n    function accruedInterestIndices(uint timeElapsed) internal view returns (uint64, uint64) {\n        uint64 baseSupplyIndex_ = baseSupplyIndex;\n        uint64 baseBorrowIndex_ = baseBorrowIndex;\n        if (timeElapsed > 0) {\n            uint utilization = getUtilization();\n            uint supplyRate = getSupplyRate(utilization);\n            uint borrowRate = getBorrowRate(utilization);\n            baseSupplyIndex_ += safe64(mulFactor(baseSupplyIndex_, supplyRate * timeElapsed));\n            baseBorrowIndex_ += safe64(mulFactor(baseBorrowIndex_, borrowRate * timeElapsed));\n        }\n        return (baseSupplyIndex_, baseBorrowIndex_);\n    }\n\n    /**\n     * @dev Accrue interest (and rewards) in base token supply and borrows\n     **/\n    function accrueInternal() internal {\n        uint40 now_ = getNowInternal();\n        uint timeElapsed = uint256(now_ - lastAccrualTime);\n        if (timeElapsed > 0) {\n            (baseSupplyIndex, baseBorrowIndex) = accruedInterestIndices(timeElapsed);\n            if (totalSupplyBase >= baseMinForRewards) {\n                trackingSupplyIndex += safe64(divBaseWei(baseTrackingSupplySpeed * timeElapsed, totalSupplyBase));\n            }\n            if (totalBorrowBase >= baseMinForRewards) {\n                trackingBorrowIndex += safe64(divBaseWei(baseTrackingBorrowSpeed * timeElapsed, totalBorrowBase));\n            }\n            lastAccrualTime = now_;\n        }\n    }\n\n    /**\n     * @notice Accrue interest and rewards for an account\n     **/\n    function accrueAccount(address account) override external {\n        accrueInternal();\n\n        UserBasic memory basic = userBasic[account];\n        updateBasePrincipal(account, basic, basic.principal);\n    }\n\n    /**\n     * @dev Note: Does not accrue interest first\n     * @param utilization The utilization to check the supply rate for\n     * @return The per second supply rate at `utilization`\n     */\n    function getSupplyRate(uint utilization) override public view returns (uint64) {\n        if (utilization <= supplyKink) {\n            // interestRateBase + interestRateSlopeLow * utilization\n            return safe64(supplyPerSecondInterestRateBase + mulFactor(supplyPerSecondInterestRateSlopeLow, utilization));\n        } else {\n            // interestRateBase + interestRateSlopeLow * kink + interestRateSlopeHigh * (utilization - kink)\n            return safe64(supplyPerSecondInterestRateBase + mulFactor(supplyPerSecondInterestRateSlopeLow, supplyKink) + mulFactor(supplyPerSecondInterestRateSlopeHigh, (utilization - supplyKink)));\n        }\n    }\n\n    /**\n     * @dev Note: Does not accrue interest first\n     * @param utilization The utilization to check the borrow rate for\n     * @return The per second borrow rate at `utilization`\n     */\n    function getBorrowRate(uint utilization) override public view returns (uint64) {\n        if (utilization <= borrowKink) {\n            // interestRateBase + interestRateSlopeLow * utilization\n            return safe64(borrowPerSecondInterestRateBase + mulFactor(borrowPerSecondInterestRateSlopeLow, utilization));\n        } else {\n            // interestRateBase + interestRateSlopeLow * kink + interestRateSlopeHigh * (utilization - kink)\n            return safe64(borrowPerSecondInterestRateBase + mulFactor(borrowPerSecondInterestRateSlopeLow, borrowKink) + mulFactor(borrowPerSecondInterestRateSlopeHigh, (utilization - borrowKink)));\n        }\n    }\n\n    /**\n     * @dev Note: Does not accrue interest first\n     * @return The utilization rate of the base asset\n     */\n    function getUtilization() override public view returns (uint) {\n        uint totalSupply_ = presentValueSupply(baseSupplyIndex, totalSupplyBase);\n        uint totalBorrow_ = presentValueBorrow(baseBorrowIndex, totalBorrowBase);\n        if (totalSupply_ == 0) {\n            return 0;\n        } else {\n            return totalBorrow_ * FACTOR_SCALE / totalSupply_;\n        }\n    }\n\n    /**\n     * @notice Get the current price from a feed\n     * @param priceFeed The address of a price feed\n     * @return The price, scaled by `PRICE_SCALE`\n     */\n    function getPrice(address priceFeed) override public view returns (uint256) {\n        (, int price, , , ) = IPriceFeed(priceFeed).latestRoundData();\n        if (price <= 0) revert BadPrice();\n        return uint256(price);\n    }\n\n    /**\n     * @notice Gets the total balance of protocol collateral reserves for an asset\n     * @dev Note: Reverts if collateral reserves are somehow negative, which should not be possible\n     * @param asset The collateral asset\n     */\n    function getCollateralReserves(address asset) override public view returns (uint) {\n        return ERC20(asset).balanceOf(address(this)) - totalsCollateral[asset].totalSupplyAsset;\n    }\n\n    /**\n     * @notice Gets the total amount of protocol reserves of the base asset\n     */\n    function getReserves() override public view returns (int) {\n        (uint64 baseSupplyIndex_, uint64 baseBorrowIndex_) = accruedInterestIndices(getNowInternal() - lastAccrualTime);\n        uint balance = ERC20(baseToken).balanceOf(address(this));\n        uint totalSupply_ = presentValueSupply(baseSupplyIndex_, totalSupplyBase);\n        uint totalBorrow_ = presentValueBorrow(baseBorrowIndex_, totalBorrowBase);\n        return signed256(balance) - signed256(totalSupply_) + signed256(totalBorrow_);\n    }\n\n    /**\n     * @notice Check whether an account has enough collateral to borrow\n     * @param account The address to check\n     * @return Whether the account is minimally collateralized enough to borrow\n     */\n    function isBorrowCollateralized(address account) override public view returns (bool) {\n        int104 principal = userBasic[account].principal;\n\n        if (principal >= 0) {\n            return true;\n        }\n\n        uint16 assetsIn = userBasic[account].assetsIn;\n        int liquidity = signedMulPrice(\n            presentValue(principal),\n            getPrice(baseTokenPriceFeed),\n            uint64(baseScale)\n        );\n\n        for (uint8 i = 0; i < numAssets; ) {\n            if (isInAsset(assetsIn, i)) {\n                if (liquidity >= 0) {\n                    return true;\n                }\n\n                AssetInfo memory asset = getAssetInfo(i);\n                uint newAmount = mulPrice(\n                    userCollateral[account][asset.asset].balance,\n                    getPrice(asset.priceFeed),\n                    asset.scale\n                );\n                liquidity += signed256(mulFactor(\n                    newAmount,\n                    asset.borrowCollateralFactor\n                ));\n            }\n            unchecked { i++; }\n        }\n\n        return liquidity >= 0;\n    }\n\n    /**\n     * @notice Check whether an account has enough collateral to not be liquidated\n     * @param account The address to check\n     * @return Whether the account is minimally collateralized enough to not be liquidated\n     */\n    function isLiquidatable(address account) override public view returns (bool) {\n        int104 principal = userBasic[account].principal;\n\n        if (principal >= 0) {\n            return false;\n        }\n\n        uint16 assetsIn = userBasic[account].assetsIn;\n        int liquidity = signedMulPrice(\n            presentValue(principal),\n            getPrice(baseTokenPriceFeed),\n            uint64(baseScale)\n        );\n\n        for (uint8 i = 0; i < numAssets; ) {\n            if (isInAsset(assetsIn, i)) {\n                if (liquidity >= 0) {\n                    return false;\n                }\n\n                AssetInfo memory asset = getAssetInfo(i);\n                uint newAmount = mulPrice(\n                    userCollateral[account][asset.asset].balance,\n                    getPrice(asset.priceFeed),\n                    asset.scale\n                );\n                liquidity += signed256(mulFactor(\n                    newAmount,\n                    asset.liquidateCollateralFactor\n                ));\n            }\n            unchecked { i++; }\n        }\n\n        return liquidity < 0;\n    }\n\n    /**\n     * @dev The change in principal broken into repay and supply amounts\n     */\n    function repayAndSupplyAmount(int104 oldPrincipal, int104 newPrincipal) internal pure returns (uint104, uint104) {\n        // If the new principal is less than the old principal, then no amount has been repaid or supplied\n        if (newPrincipal < oldPrincipal) return (0, 0);\n\n        if (newPrincipal <= 0) {\n            return (uint104(newPrincipal - oldPrincipal), 0);\n        } else if (oldPrincipal >= 0) {\n            return (0, uint104(newPrincipal - oldPrincipal));\n        } else {\n            return (uint104(-oldPrincipal), uint104(newPrincipal));\n        }\n    }\n\n    /**\n     * @dev The change in principal broken into withdraw and borrow amounts\n     */\n    function withdrawAndBorrowAmount(int104 oldPrincipal, int104 newPrincipal) internal pure returns (uint104, uint104) {\n        // If the new principal is greater than the old principal, then no amount has been withdrawn or borrowed\n        if (newPrincipal > oldPrincipal) return (0, 0);\n\n        if (newPrincipal >= 0) {\n            return (uint104(oldPrincipal - newPrincipal), 0);\n        } else if (oldPrincipal <= 0) {\n            return (0, uint104(oldPrincipal - newPrincipal));\n        } else {\n            return (uint104(oldPrincipal), uint104(-newPrincipal));\n        }\n    }\n\n    /**\n     * @notice Pauses different actions within Comet\n     * @param supplyPaused Boolean for pausing supply actions\n     * @param transferPaused Boolean for pausing transfer actions\n     * @param withdrawPaused Boolean for pausing withdraw actions\n     * @param absorbPaused Boolean for pausing absorb actions\n     * @param buyPaused Boolean for pausing buy actions\n     */\n    function pause(\n        bool supplyPaused,\n        bool transferPaused,\n        bool withdrawPaused,\n        bool absorbPaused,\n        bool buyPaused\n    ) override external {\n        if (msg.sender != governor && msg.sender != pauseGuardian) revert Unauthorized();\n\n        pauseFlags =\n            uint8(0) |\n            (toUInt8(supplyPaused) << PAUSE_SUPPLY_OFFSET) |\n            (toUInt8(transferPaused) << PAUSE_TRANSFER_OFFSET) |\n            (toUInt8(withdrawPaused) << PAUSE_WITHDRAW_OFFSET) |\n            (toUInt8(absorbPaused) << PAUSE_ABSORB_OFFSET) |\n            (toUInt8(buyPaused) << PAUSE_BUY_OFFSET);\n\n        emit PauseAction(supplyPaused, transferPaused, withdrawPaused, absorbPaused, buyPaused);\n    }\n\n    /**\n     * @return Whether or not supply actions are paused\n     */\n    function isSupplyPaused() override public view returns (bool) {\n        return toBool(pauseFlags & (uint8(1) << PAUSE_SUPPLY_OFFSET));\n    }\n\n    /**\n     * @return Whether or not transfer actions are paused\n     */\n    function isTransferPaused() override public view returns (bool) {\n        return toBool(pauseFlags & (uint8(1) << PAUSE_TRANSFER_OFFSET));\n    }\n\n    /**\n     * @return Whether or not withdraw actions are paused\n     */\n    function isWithdrawPaused() override public view returns (bool) {\n        return toBool(pauseFlags & (uint8(1) << PAUSE_WITHDRAW_OFFSET));\n    }\n\n    /**\n     * @return Whether or not absorb actions are paused\n     */\n    function isAbsorbPaused() override public view returns (bool) {\n        return toBool(pauseFlags & (uint8(1) << PAUSE_ABSORB_OFFSET));\n    }\n\n    /**\n     * @return Whether or not buy actions are paused\n     */\n    function isBuyPaused() override public view returns (bool) {\n        return toBool(pauseFlags & (uint8(1) << PAUSE_BUY_OFFSET));\n    }\n\n    /**\n     * @dev Multiply a number by a factor\n     */\n    function mulFactor(uint n, uint factor) internal pure returns (uint) {\n        return n * factor / FACTOR_SCALE;\n    }\n\n    /**\n     * @dev Divide a number by an amount of base\n     */\n    function divBaseWei(uint n, uint baseWei) internal view returns (uint) {\n        return n * baseScale / baseWei;\n    }\n\n    /**\n     * @dev Multiply a `fromScale` quantity by a price, returning a common price quantity\n     */\n    function mulPrice(uint n, uint price, uint64 fromScale) internal pure returns (uint) {\n        return n * price / fromScale;\n    }\n\n    /**\n     * @dev Multiply a signed `fromScale` quantity by a price, returning a common price quantity\n     */\n    function signedMulPrice(int n, uint price, uint64 fromScale) internal pure returns (int) {\n        return n * signed256(price) / int256(uint256(fromScale));\n    }\n\n    /**\n     * @dev Divide a common price quantity by a price, returning a `toScale` quantity\n     */\n    function divPrice(uint n, uint price, uint64 toScale) internal pure returns (uint) {\n        return n * toScale / price;\n    }\n\n    /**\n     * @dev Whether user has a non-zero balance of an asset, given assetsIn flags\n     */\n    function isInAsset(uint16 assetsIn, uint8 assetOffset) internal pure returns (bool) {\n        return (assetsIn & (uint16(1) << assetOffset) != 0);\n    }\n\n    /**\n     * @dev Update assetsIn bit vector if user has entered or exited an asset\n     */\n    function updateAssetsIn(\n        address account,\n        AssetInfo memory assetInfo,\n        uint128 initialUserBalance,\n        uint128 finalUserBalance\n    ) internal {\n        if (initialUserBalance == 0 && finalUserBalance != 0) {\n            // set bit for asset\n            userBasic[account].assetsIn |= (uint16(1) << assetInfo.offset);\n        } else if (initialUserBalance != 0 && finalUserBalance == 0) {\n            // clear bit for asset\n            userBasic[account].assetsIn &= ~(uint16(1) << assetInfo.offset);\n        }\n    }\n\n    /**\n     * @dev Write updated principal to store and tracking participation\n     */\n    function updateBasePrincipal(address account, UserBasic memory basic, int104 principalNew) internal {\n        int104 principal = basic.principal;\n        basic.principal = principalNew;\n\n        if (principal >= 0) {\n            uint indexDelta = uint256(trackingSupplyIndex - basic.baseTrackingIndex);\n            basic.baseTrackingAccrued += safe64(uint104(principal) * indexDelta / trackingIndexScale / accrualDescaleFactor);\n        } else {\n            uint indexDelta = uint256(trackingBorrowIndex - basic.baseTrackingIndex);\n            basic.baseTrackingAccrued += safe64(uint104(-principal) * indexDelta / trackingIndexScale / accrualDescaleFactor);\n        }\n\n        if (principalNew >= 0) {\n            basic.baseTrackingIndex = trackingSupplyIndex;\n        } else {\n            basic.baseTrackingIndex = trackingBorrowIndex;\n        }\n\n        userBasic[account] = basic;\n    }\n\n    /**\n     * @dev Safe ERC20 transfer in, assumes no fee is charged and amount is transferred\n     */\n    function doTransferIn(address asset, address from, uint amount) internal {\n        bool success = ERC20(asset).transferFrom(from, address(this), amount);\n        if (!success) revert TransferInFailed();\n    }\n\n    /**\n     * @dev Safe ERC20 transfer out\n     */\n    function doTransferOut(address asset, address to, uint amount) internal {\n        bool success = ERC20(asset).transfer(to, amount);\n        if (!success) revert TransferOutFailed();\n    }\n\n    /**\n     * @notice Supply an amount of asset to the protocol\n     * @param asset The asset to supply\n     * @param amount The quantity to supply\n     */\n    function supply(address asset, uint amount) override external {\n        return supplyInternal(msg.sender, msg.sender, msg.sender, asset, amount);\n    }\n\n    /**\n     * @notice Supply an amount of asset to dst\n     * @param dst The address which will hold the balance\n     * @param asset The asset to supply\n     * @param amount The quantity to supply\n     */\n    function supplyTo(address dst, address asset, uint amount) override external {\n        return supplyInternal(msg.sender, msg.sender, dst, asset, amount);\n    }\n\n    /**\n     * @notice Supply an amount of asset from `from` to dst, if allowed\n     * @param from The supplier address\n     * @param dst The address which will hold the balance\n     * @param asset The asset to supply\n     * @param amount The quantity to supply\n     */\n    function supplyFrom(address from, address dst, address asset, uint amount) override external {\n        return supplyInternal(msg.sender, from, dst, asset, amount);\n    }\n\n    /**\n     * @dev Supply either collateral or base asset, depending on the asset, if operator is allowed\n     * @dev Note: Specifying an `amount` of uint256.max will repay all of `dst`'s accrued base borrow balance\n     */\n    function supplyInternal(address operator, address from, address dst, address asset, uint amount) internal {\n        if (isSupplyPaused()) revert Paused();\n        if (!hasPermission(from, operator)) revert Unauthorized();\n\n        if (asset == baseToken) {\n            if (amount == type(uint256).max) {\n                amount = borrowBalanceOf(dst);\n            }\n            return supplyBase(from, dst, amount);\n        } else {\n            return suppl"
    }
  ]
}