{
  "Title": "Undisclosed Functionality Mismatch in L1 and L2 Token Functions Post-Bridging",
  "Content": "When bridging tokens from L1 to L2, by default, the [`L2StandardERC20` contract](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/zksync/contracts/bridge/L2StandardERC20.sol) will be deployed initially. However, this default implementation can introduce a gap in functionalities when compared to their L1 counterparts, such as rebase methods or voting capabilities. This discrepancy can cause confusion for users or developers trying to interact with these tokens like they would on L1.\n\n\nTo enhance transparency, consider adding a disclaimer to the existing note [in the documentation](https://era.zksync.io/docs/reference/concepts/bridging-asset.html) as well as to the ERC-20 bridge contracts documentation [[1](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/bridge/L1ERC20Bridge.sol#L23-L25), [2](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/zksync/contracts/bridge/L2ERC20Bridge.sol#L19)]. In addition, the user interface of the bridge, which is controlled by Matter Labs, should inform users of the potential limitations in token functionality post-bridging.\n\n\n***Update:** Resolved in [pull request #140](https://github.com/matter-labs/era-contracts/pull/140) at commit [5cbf05b](https://github.com/matter-labs/era-contracts/pull/140/commits/5cbf05ba8cdfc4c74646299088559b75de3c94c4), and in [pull request #845](https://github.com/matter-labs/zksync-web-era-docs/pull/845) at commit [82232bc](https://github.com/matter-labs/zksync-web-era-docs/pull/845/commits/82232bc136f27adea62a173448390ea3adeeffbf).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "ethereum/contracts/bridge/L1ERC20Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IL1BridgeLegacy.sol\";\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\nimport \"./interfaces/IL2ERC20Bridge.sol\";\n\nimport \"./libraries/BridgeInitializationHelper.sol\";\n\nimport \"../zksync/interfaces/IZkSync.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/libraries/L2ContractHelper.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../vendor/AddressAliasHelper.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Smart contract that allows depositing ERC20 tokens from Ethereum to zkSync Era\n/// @dev It is standard implementation of ERC20 Bridge that can be used as a reference\n/// for any other custom token bridges.\ncontract L1ERC20Bridge is IL1Bridge, IL1BridgeLegacy, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IZkSync internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address => mapping(address => mapping(bytes32 => uint256))) internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) public __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) public __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) public totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IZkSync _zkSync) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), \"nf\");\n        require(_governor != address(0), \"nh\");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, \"mk\");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, \"fee\");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[2]);\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            \"\", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        require(_amount != 0, \"2T\"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, \"1T\"); // The token has non-standard transfer logic\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n\n        emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n        );\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, \"yn\");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, \"y1\");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"pw\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, \"nq\");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, \"kk\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, \"nt\");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}"
    }
  ]
}