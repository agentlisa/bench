{
  "Title": "[G-11] `>=` costs less gas than `>`",
  "Content": "\nThe compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/token/InfinityToken.sol   #1\n\n67        epochsPassedSinceLastAdvance = epochsPassedSinceLastAdvance > epochsLeft\n68          ? epochsLeft\n69:         : epochsPassedSinceLastAdvance;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L67-L69>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
  "Code": [
    {
      "filename": "contracts/token/InfinityToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {ERC20Permit} from '@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol';\nimport {ERC20Burnable} from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';\nimport {ERC20Snapshot} from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol';\nimport {ERC20Votes} from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\n\nimport {TimelockConfig} from './TimelockConfig.sol';\n\n/**\n * @title InfinityTokens\n * @author nneverlander. Twitter @nneverlander\n * @notice The Infinity Token ($NFT). Implements timelock config to control token release schedule.\n */\ncontract InfinityToken is\n  ERC20('Infinity', 'NFT'),\n  ERC20Permit('Infinity'),\n  ERC20Burnable,\n  ERC20Snapshot,\n  ERC20Votes,\n  TimelockConfig\n{\n  bytes32 public constant EPOCH_INFLATION = keccak256('Inflation');\n  bytes32 public constant EPOCH_DURATION = keccak256('EpochDuration');\n  bytes32 public constant EPOCH_CLIFF = keccak256('Cliff');\n  bytes32 public constant MAX_EPOCHS = keccak256('MaxEpochs');\n\n  /* storage */\n  uint256 public currentEpochTimestamp;\n  uint256 public currentEpoch;\n  uint256 public previousEpochTimestamp;\n\n  event EpochAdvanced(uint256 currentEpoch, uint256 supplyMinted);\n\n  constructor(\n    address admin,\n    uint256 epochInflation,\n    uint256 epochDuration,\n    uint256 epochCliff,\n    uint256 maxEpochs,\n    uint256 timelock,\n    uint256 supply\n  ) TimelockConfig(admin, timelock) {\n    TimelockConfig._setRawConfig(EPOCH_INFLATION, epochInflation);\n    TimelockConfig._setRawConfig(EPOCH_DURATION, epochDuration);\n    TimelockConfig._setRawConfig(EPOCH_CLIFF, epochCliff);\n    TimelockConfig._setRawConfig(MAX_EPOCHS, maxEpochs);\n\n    previousEpochTimestamp = block.timestamp;\n    currentEpochTimestamp = block.timestamp;\n\n    // mint initial supply\n    _mint(admin, supply);\n  }\n\n  // =============================================== USER FUNCTIONS =========================================================\n\n  function advanceEpoch() external {\n    require(currentEpoch < getMaxEpochs(), 'no epochs left');\n    require(block.timestamp >= currentEpochTimestamp + getCliff(), 'cliff not passed');\n    require(block.timestamp >= previousEpochTimestamp + getEpochDuration(), 'not ready to advance');\n\n    uint256 epochsPassedSinceLastAdvance = (block.timestamp - previousEpochTimestamp) / getEpochDuration();\n    uint256 epochsLeft = getMaxEpochs() - currentEpoch;\n    epochsPassedSinceLastAdvance = epochsPassedSinceLastAdvance > epochsLeft\n      ? epochsLeft\n      : epochsPassedSinceLastAdvance;\n\n    // update epochs\n    currentEpoch += epochsPassedSinceLastAdvance;\n    previousEpochTimestamp = block.timestamp;\n\n    // inflation amount\n    uint256 supplyToMint = getInflation() * epochsPassedSinceLastAdvance;\n\n    // mint supply\n    _mint(getAdmin(), supplyToMint);\n\n    emit EpochAdvanced(currentEpoch, supplyToMint);\n  }\n\n  // =============================================== HOOKS =========================================================\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override(ERC20, ERC20Snapshot) {\n    ERC20Snapshot._beforeTokenTransfer(from, to, amount);\n  }\n\n  // =============================================== REQUIRED OVERRIDES =========================================================\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override(ERC20, ERC20Votes) {\n    super._afterTokenTransfer(from, to, amount);\n  }\n\n  function _mint(address to, uint256 amount) internal override(ERC20, ERC20Votes) {\n    super._mint(to, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal override(ERC20, ERC20Votes) {\n    super._burn(account, amount);\n  }\n\n  // =============================================== VIEW FUNCTIONS =========================================================\n\n  function getAdmin() public view returns (address admin) {\n    return address(uint160(TimelockConfig.getConfig(TimelockConfig.ADMIN).value));\n  }\n\n  function getTimelock() public view returns (uint256 timelock) {\n    return TimelockConfig.getConfig(TimelockConfig.TIMELOCK).value;\n  }\n\n  function getInflation() public view returns (uint256 inflation) {\n    return TimelockConfig.getConfig(EPOCH_INFLATION).value;\n  }\n\n  function getCliff() public view returns (uint256 cliff) {\n    return TimelockConfig.getConfig(EPOCH_CLIFF).value;\n  }\n\n  function getMaxEpochs() public view returns (uint256 totalEpochs) {\n    return TimelockConfig.getConfig(MAX_EPOCHS).value;\n  }\n\n  function getEpochDuration() public view returns (uint256 epochDuration) {\n    return TimelockConfig.getConfig(EPOCH_DURATION).value;\n  }\n}"
    }
  ]
}