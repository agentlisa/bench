{
  "Title": "[M-16] If `totalShares` for a token falls to zero while there is `pendingCredit` the contract will become stuck",
  "Content": "_Submitted by AuditsAreUS_\n\n[AlchemistV2.sol#L1290-L1300](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1290-L1300)<br>\n[AlchemistV2.sol#L1268](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1268)<br>\n[AlchemistV2.sol#L1532](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1532)<br>\n[AlchemistV2.sol#L899](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L899)<br>\n[AlchemistV2.sol#L1625](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1625)<br>\n\nIt is possible for the contract to become stuck and unable to perform any actions if the `totalShares` of a yield token fall to zero while there is some `pendingCredit` still to be paid.\n\nIt will then be impossible to call deposit or withdraw functions, mints, burns, repay, liquidate, donate or harvest due to division by zero reverts in:\n\n*   `_distributeCredit()`\n*   `_distributeUnlockedCredit()`\n*   `_calculateUnrealizedDebt()`\n*   `_convertSharesToYieldTokens()`\n*   `donate()`\n\nFurthermore, any `pendingCredit` amount of tokens are still in the contract will become permanently stuck.\n\n### Proof of Concept\n\nThis case may arise under the follow steps\na) `deposit()` is called by a user then time passes to earn some yield\nb) `harvest()` is called by the keeper which calls `_distributeCredit()` and increases `pendingCredit`\nc) `withdraw()` is called by the user to withdraw all funds\n\nSince there is `pendingCredit` the following will have a non-zero balance for `unlockedCredit` however `yieldTokenParams.totalShares` is zero and thus we get a division by zero which reverts the entire transaction.\n\n```solidity\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n```\n\nEach of the other listed functions will reach the same issue by attempting to divide some numerator by the `totalShares` which is zero.\n\n### Recommended Mitigation Steps\n\nConsider preventing `totalShares` from over becoming zero once it is set. That is enforce a user to leave at least 1 unit if they are the last user to withdraw.\n\nAnother option is to transfer the first 1000 shares to a \"burn\" account (e.g. 0x000...01), when the first user deposits.\n\nAlternatively, when the last user withdraws, transfer all pending credit to this user and set the required variables to zero to replicate the state before any users have deposited.\n\n**[0xfoobar (Alchemix) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/104#issuecomment-1133988067):**\n > Disagree with severity because given the depth of distinct users using Alchemix, it is unlikely this scenario would occur.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/104#issuecomment-1146196263):**\n > This is an interesting issue. At the moment, it sits somewhere between medium and high risk, so I will need to think about this more before coming to a decision.\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/104#issuecomment-1150102500):**\n > After further thought, I think this does not fit the criteria of high severity for the following reasons:\n>  - The protocol can be DoS'd on new deployments via front-running, but it does not lead to lost funds by users. It'd only require a new deployment by the Alchemist team.\n>  - If the protocol was to migrate to a new version of the protocol, a mass withdrawal event could lead to locked `pendingCredit`. However, because rewards are harvested by a keeper, I believe this to be unlikely as migrations will most certainly be coordinated by the protocol and its keepers. As such, users will be aware that they would miss out on rewards if the keeper does not harvest rewards prior to the migration.\n>  - Rewards are regularly harvested by the keeper, and as such, the value at risk is somewhat negligible.\n> \n> For these reasons, I believe medium severity to be justified.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-full/AlchemistV2.sol",
      "content": "pragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {Unauthorized, IllegalState, IllegalArgument} from \"./base/Errors.sol\";\n\nimport \"./base/Multicall.sol\";\nimport \"./base/Mutex.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IAlchemicToken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Sets.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./libraries/Limiters.sol\";\n\n/// @title  AlchemistV2\n/// @author Alchemix Finance\ncontract AlchemistV2 is IAlchemistV2, Initializable, Multicall, Mutex {\n    using Limiters for Limiters.LinearGrowthLimiter;\n    using Sets for Sets.AddressSet;\n\n    /// @notice A user account.\n    struct Account {\n        // A signed value which represents the current amount of debt or credit that the account has accrued.\n        // Positive values indicate debt, negative values indicate credit.\n        int256 debt;\n        // The share balances for each yield token.\n        mapping(address => uint256) balances;\n        // The last values recorded for accrued weights for each yield token.\n        mapping(address => uint256) lastAccruedWeights;\n        // The set of yield tokens that the account has deposited into the system.\n        Sets.AddressSet depositedTokens;\n        // The allowances for mints.\n        mapping(address => uint256) mintAllowances;\n        // The allowances for withdrawals.\n        mapping(address => mapping(address => uint256)) withdrawAllowances;\n    }\n\n    /// @notice The number of basis points there are to represent exactly 100%.\n    uint256 public constant BPS = 10000;\n\n    /// @notice The scalar used for conversion of integral numbers to fixed point numbers. Fixed point numbers in this\n    ///         implementation have 18 decimals of resolution, meaning that 1 is represented as 1e18, 0.5 is\n    ///         represented as 5e17, and 2 is represented as 2e18.\n    uint256 public constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @inheritdoc IAlchemistV2Immutables\n    string public constant override version = \"2.2.6\";\n\n    /// @inheritdoc IAlchemistV2Immutables\n    address public override debtToken;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override admin;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override pendingAdmin;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override sentinels;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override keepers;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override transmuter;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override minimumCollateralization;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override protocolFee;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override protocolFeeReceiver;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override whitelist;\n\n    /// @dev A linear growth function that limits the amount of debt-token minted.\n    Limiters.LinearGrowthLimiter private _mintingLimiter;\n\n    // @dev The repay limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _repayLimiters;\n\n    // @dev The liquidation limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _liquidationLimiters;\n\n    /// @dev Accounts mapped by the address that owns them.\n    mapping(address => Account) private _accounts;\n\n    /// @dev Underlying token parameters mapped by token address.\n    mapping(address => UnderlyingTokenParams) private _underlyingTokens;\n\n    /// @dev Yield token parameters mapped by token address.\n    mapping(address => YieldTokenParams) private _yieldTokens;\n\n    /// @dev An iterable set of the underlying tokens that are supported by the system.\n    Sets.AddressSet private _supportedUnderlyingTokens;\n\n    /// @dev An iterable set of the yield tokens that are supported by the system.\n    Sets.AddressSet private _supportedYieldTokens;\n\n    constructor() initializer {}\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToYieldTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToUnderlyingTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedUnderlyingTokens() external view override returns (address[] memory) {\n        return _supportedUnderlyingTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedYieldTokens() external view override returns (address[] memory) {\n        return _supportedYieldTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedUnderlyingToken(address underlyingToken) external view override returns (bool) {\n        return _supportedUnderlyingTokens.contains(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedYieldToken(address yieldToken) external view override returns (bool) {\n        return _supportedYieldTokens.contains(yieldToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function accounts(address owner)\n        external view override\n        returns (\n            int256 debt,\n            address[] memory depositedTokens\n        )\n    {\n        Account storage account = _accounts[owner];\n\n        return (\n            _calculateUnrealizedDebt(owner),\n            account.depositedTokens.values\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function positions(address owner, address yieldToken)\n        external view override\n        returns (\n            uint256 shares,\n            uint256 lastAccruedWeight\n        )\n    {\n        Account storage account = _accounts[owner];\n        return (account.balances[yieldToken], account.lastAccruedWeights[yieldToken]);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function mintAllowance(address owner, address spender)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.mintAllowances[spender];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function withdrawAllowance(address owner, address spender, address yieldToken)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.withdrawAllowances[spender][yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokenParameters(address underlyingToken)\n        external view override\n        returns (UnderlyingTokenParams memory)\n    {\n        return _underlyingTokens[underlyingToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokenParameters(address yieldToken)\n        external view override\n        returns (YieldTokenParams memory)\n    {\n        return _yieldTokens[yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getMintLimitInfo()\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        return (\n            _mintingLimiter.get(),\n            _mintingLimiter.rate,\n            _mintingLimiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getRepayLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getLiquidationLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function initialize(InitializationParams memory params) external initializer {\n        _checkArgument(params.protocolFee <= BPS);\n\n        debtToken                = params.debtToken;\n        admin                    = params.admin;\n        transmuter               = params.transmuter;\n        minimumCollateralization = params.minimumCollateralization;\n        protocolFee              = params.protocolFee;\n        protocolFeeReceiver      = params.protocolFeeReceiver;\n        whitelist                = params.whitelist;\n\n        _mintingLimiter = Limiters.createLinearGrowthLimiter(\n            params.mintingLimitMaximum,\n            params.mintingLimitBlocks,\n            params.mintingLimitMinimum\n        );\n\n        emit AdminUpdated(admin);\n        emit TransmuterUpdated(transmuter);\n        emit MinimumCollateralizationUpdated(minimumCollateralization);\n        emit ProtocolFeeUpdated(protocolFee);\n        emit ProtocolFeeReceiverUpdated(protocolFeeReceiver);\n        emit MintingLimitUpdated(params.mintingLimitMaximum, params.mintingLimitBlocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setPendingAdmin(address value) external override {\n        _onlyAdmin();\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function acceptAdmin() external override {\n        _checkState(pendingAdmin != address(0));\n\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized();\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setSentinel(address sentinel, bool flag) external override {\n        _onlyAdmin();\n        sentinels[sentinel] = flag;\n        emit SentinelSet(sentinel, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setKeeper(address keeper, bool flag) external override {\n        _onlyAdmin();\n        keepers[keeper] = flag;\n        emit KeeperSet(keeper, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkState(!_supportedUnderlyingTokens.contains(underlyingToken));\n\n        uint8 tokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n        uint8 debtTokenDecimals = TokenUtils.expectDecimals(debtToken);\n\n        _checkArgument(tokenDecimals <= debtTokenDecimals);\n\n        _underlyingTokens[underlyingToken] = UnderlyingTokenParams({\n            decimals:         tokenDecimals,\n            conversionFactor: 10**(debtTokenDecimals - tokenDecimals),\n            enabled:          false\n        });\n\n        _repayLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.repayLimitMaximum,\n            config.repayLimitBlocks,\n            config.repayLimitMinimum\n        );\n\n        _liquidationLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.liquidationLimitMaximum,\n            config.liquidationLimitBlocks,\n            config.liquidationLimitMinimum\n        );\n\n        _supportedUnderlyingTokens.add(underlyingToken);\n\n        emit AddUnderlyingToken(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkArgument(config.maximumLoss <= BPS);\n        _checkArgument(config.creditUnlockBlocks > 0);\n\n        _checkState(!_supportedYieldTokens.contains(yieldToken));\n\n        ITokenAdapter adapter = ITokenAdapter(config.adapter);\n\n        _checkState(yieldToken == adapter.token());\n        _checkSupportedUnderlyingToken(adapter.underlyingToken());\n\n        _yieldTokens[yieldToken] = YieldTokenParams({\n            decimals:              TokenUtils.expectDecimals(yieldToken),\n            underlyingToken:       adapter.underlyingToken(),\n            adapter:               config.adapter,\n            maximumLoss:           config.maximumLoss,\n            maximumExpectedValue:  config.maximumExpectedValue,\n            creditUnlockRate:      FIXED_POINT_SCALAR / config.creditUnlockBlocks,\n            activeBalance:         0,\n            harvestableBalance:    0,\n            totalShares:           0,\n            expectedValue:         0,\n            accruedWeight:         0,\n            pendingCredit:         0,\n            distributedCredit:     0,\n            lastDistributionBlock: 0,\n            enabled:               false\n        });\n\n        _supportedYieldTokens.add(yieldToken);\n\n        TokenUtils.safeApprove(yieldToken, config.adapter, type(uint256).max);\n        TokenUtils.safeApprove(adapter.underlyingToken(), config.adapter, type(uint256).max);\n\n        emit AddYieldToken(yieldToken);\n        emit TokenAdapterUpdated(yieldToken, config.adapter);\n        emit MaximumLossUpdated(yieldToken, config.maximumLoss);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _underlyingTokens[underlyingToken].enabled = enabled;\n        emit UnderlyingTokenEnabled(underlyingToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].enabled = enabled;\n        emit YieldTokenEnabled(yieldToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _repayLimiters[underlyingToken].update();\n        _repayLimiters[underlyingToken].configure(maximum, blocks);\n        emit RepayLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _liquidationLimiters[underlyingToken].update();\n        _liquidationLimiters[underlyingToken].configure(maximum, blocks);\n        emit LiquidationLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTransmuter(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        transmuter = value;\n        emit TransmuterUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMinimumCollateralization(uint256 value) external override {\n        _onlyAdmin();\n        minimumCollateralization = value;\n        emit MinimumCollateralizationUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFee(uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        protocolFee = value;\n        emit ProtocolFeeUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFeeReceiver(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        protocolFeeReceiver = value;\n        emit ProtocolFeeReceiverUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureMintingLimit(uint256 maximum, uint256 rate) external override {\n        _onlyAdmin();\n        _mintingLimiter.update();\n        _mintingLimiter.configure(maximum, rate);\n        emit MintingLimitUpdated(maximum, rate);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkArgument(blocks > 0);\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].creditUnlockRate = FIXED_POINT_SCALAR / blocks;\n        emit CreditUnlockRateUpdated(yieldToken, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTokenAdapter(address yieldToken, address adapter) external override {\n        _onlyAdmin();\n        _checkState(yieldToken == ITokenAdapter(adapter).token());\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].adapter = adapter;\n        TokenUtils.safeApprove(yieldToken, adapter, type(uint256).max);\n        TokenUtils.safeApprove(ITokenAdapter(adapter).underlyingToken(), adapter, type(uint256).max);\n        emit TokenAdapterUpdated(yieldToken, adapter);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].maximumExpectedValue = value;\n        emit MaximumExpectedValueUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumLoss(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        _checkSupportedYieldToken(yieldToken);\n\n        _yieldTokens[yieldToken].maximumLoss = value;\n\n        emit MaximumLossUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function snap(address yieldToken) external override lock {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n\n        uint256 expectedValue = _convertYieldTokensToUnderlying(yieldToken, _yieldTokens[yieldToken].activeBalance);\n\n        _yieldTokens[yieldToken].expectedValue = expectedValue;\n\n        emit Snap(yieldToken, expectedValue);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function sweepTokens(address rewardToken, uint256 amount) external override lock {\n        _onlyAdmin();\n\n        if (_supportedYieldTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        if (_supportedUnderlyingTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        TokenUtils.safeTransfer(rewardToken, admin, amount);\n\n        emit SweepTokens(rewardToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveMint(address spender, uint256 amount) external override {\n        _onlyWhitelisted();\n        _approveMint(msg.sender, spender, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external override {\n        _onlyWhitelisted();\n        _checkSupportedYieldToken(yieldToken);\n        _approveWithdraw(msg.sender, spender, yieldToken, shares);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function poke(address owner) external override lock {\n        _onlyWhitelisted();\n        _preemptivelyHarvestDeposited(owner);\n        _distributeUnlockedCreditDeposited(owner);\n        _poke(owner);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Deposit the yield tokens to the recipient.\n        uint256 shares = _deposit(yieldToken, amount, recipient);\n\n        // Transfer tokens from the message sender now that the internal storage updates have been committed.\n        TokenUtils.safeTransferFrom(yieldToken, msg.sender, address(this), amount);\n\n        return shares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function depositUnderlying(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Before depositing, the underlying tokens must be wrapped into yield tokens.\n        uint256 amountYieldTokens = _wrap(yieldToken, amount, minimumAmountOut);\n\n        // Deposit the yield-tokens to the recipient.\n        return _deposit(yieldToken, amountYieldTokens, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdraw(\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Preemptively try and decrease the withdrawal allowance. This will save gas when the allowance is not\n        // sufficient for the withdrawal.\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlying(\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlyingFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mint(uint256 amount, address recipient) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Mint tokens from the message sender's account to the recipient.\n        _mint(msg.sender, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mintFrom(\n        address owner,\n        uint256 amount,\n        address recipient\n    ) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Preemptively try and decrease the minting allowance. This will save gas when the allowance is not sufficient\n        // for the mint.\n        _decreaseMintAllowance(owner, msg.sender, amount);\n\n        // Mint tokens from the owner's account to the recipient.\n        _mint(owner, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function burn(uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents\n        // situations where the user may be trying to repay their entire debt, but it decreases since they send the\n        // transaction and causes a revert because burning can never decrease the debt below zero.\n        //\n        // Casts here are safe because it is asserted that debt is greater than zero.\n        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Burn the tokens from the message sender.\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);\n\n        emit Burn(msg.sender, credit, recipient);\n\n        return credit;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account and decrease the amount of debt incurred.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the amount of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Determine the maximum amount of underlying tokens that can be repaid.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero so a noop is not possible\n        // beyond this point. Casting the debt to an unsigned integer is also safe because `debt` is greater than zero.\n        uint256 maximumAmount = _normalizeDebtTokensToUnderlying(underlyingToken, uint256(debt));\n\n        // Limit the number of underlying tokens to repay up to the maximum allowed.\n        uint256 actualAmount = amount > maximumAmount ? maximumAmount : amount;\n\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token repay limit has not been breached.\n        uint256 currentRepayLimit = limiter.get();\n        if (actualAmount > currentRepayLimit) {\n          revert RepayLimitExceeded(underlyingToken, actualAmount, currentRepayLimit);\n        }\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Decrease the amount of the underlying token which is globally available to be repaid.\n        limiter.decrease(actualAmount);\n\n        // Transfer the repaid tokens to the transmuter.\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, transmuter, actualAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, actualAmount);\n\n        emit Repay(msg.sender, underlyingToken, actualAmount, recipient);\n\n        return actualAmount;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function liquidate(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(shares > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        _checkSupportedYieldToken(yieldToken);\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n        _checkLoss(yieldToken);\n\n        // Calculate the unrealized debt.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 unrealizedDebt;\n        _checkState((unrealizedDebt = _calculateUnrealizedDebt(msg.sender)) > 0);\n\n        // Determine the maximum amount of shares that can be liquidated from the unrealized debt.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero. Casting the debt to an\n        // unsigned integer is also safe for this reason.\n        uint256 maximumShares = _convertUnderlyingTokensToShares(\n          yieldToken,\n          _normalizeDebtTokensToUnderlying(underlyingToken, uint256(unrealizedDebt))\n        );\n\n        // Limit the number of shares to liquidate up to the maximum allowed.\n        uint256 actualShares = shares > maximumShares ? maximumShares : shares;\n\n        // Unwrap the yield tokens that the shares are worth.\n        uint256 amountYieldTokens      = _convertSharesToYieldTokens(yieldToken, actualShares);\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, amountYieldTokens, address(this), minimumAmountOut);\n\n        // Again, perform another noop check. It is possible that the amount of underlying tokens that were received by\n        // unwrapping the yield tokens was zero because the amount of yield tokens to unwrap was too small.\n        _checkState(amountUnderlyingTokens > 0);\n\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token liquidation limit has not been breached.\n        uint256 liquidationLimit = limiter.get();\n        if (amountUnderlyingTokens > liquidationLimit) {\n          revert LiquidationLimitExceeded(underlyingToken, amountUnderlyingTokens, liquidationLimit);\n        }\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system. This is required for `_sync` to function correctly.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(msg.sender);\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n\n        // Update the message sender's account, proactively burn shares, decrease the amount of debt incurred, and then\n        // decrease the value of the token that the system is exp"
    }
  ]
}