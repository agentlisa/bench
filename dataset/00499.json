{
  "Title": "M-3: JalaPair potential permanent DoS due to overflow",
  "Content": "# Issue M-3: JalaPair potential permanent DoS due to overflow \n\nSource: https://github.com/sherlock-audit/2024-02-jala-swap-judging/issues/186 \n\nThe protocol has acknowledged this issue.\n\n## Found by \n0k, 0xMojito, 0xRstStn, 0xloscar01, Stoicov, ZanyBonzy, den\\_sosnovskyi, deth, fibonacci, giraffe, mahmud, n1punp, santiellena, sunill\\_eth, tank\n## Summary\n\nIn the `JalaPair::_update` function, overflow is intentionally desired in the calculations for `timeElapsed` and `priceCumulative`. This is forked from the UniswapV2 source code, and it’s meant and known to overflow. UniswapV2 was developed using Solidity 0.6.6, where arithmetic operations overflow and underflow by default. However, Jala utilizes Solidity >=0.8.0, where such operations will automatically revert.\n\n## Vulnerability Detail\n\n```solidity\nuint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\nif (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n    // * never overflows, and + overflow is desired\n    price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n    price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n}\n```\n\n## Impact\n\nThis issue could potentially lead to permanent denial of service for a pool. All the core functionalities such as `mint`, `burn`, or `swap` would be broken. Consequently, all funds would be locked within the contract.\n\nI think issue with High impact and a Low probability (merely due to the extended timeframe for the event's occurrence, it's important to note that this event will occur with 100% probability if the protocol exists at that time), should be considered at least as Medium.\n\n## References\n\nThere are cases where the same issue is considered High.\n\nhttps://solodit.xyz/issues/h-02-uniswapv2priceoraclesol-currentcumulativeprices-will-revert-when-pricecumulative-addition-overflow-code4rena-phuture-finance-phuture-finance-contest-git\nhttps://solodit.xyz/issues/m-02-twavsol_gettwav-will-revert-when-timestamp-4294967296-code4rena-nibbl-nibbl-contest-git\nhttps://solodit.xyz/issues/trst-m-3-basev1pair-could-break-because-of-overflow-trust-security-none-satinexchange-markdown_\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-jala-swap/blob/main/jalaswap-dex-contract/contracts/JalaPair.sol#L97-L102\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the `unchecked` block to ensure everything overflows as expected\n\n\n\n## Discussion\n\n**nevillehuang**\n\nRequest poc\n\nWould like the watson/watsons to present a scenario where a reasonable overflow can be achieved, because based on my discussion with LSW this is likely not reasonable considering frequency of liquidity addition and ratio of reserves required\n\n> #186 - let's put it this way. Ratio is scaled up by 2^112.  Having a ` (ratio * timeElapsed1) + (ratio * timeElapsed2)` is the same as having `(ratio * (timeElapsed1 + timeElapsed2)`. So if we have a token1 max reserve of uint112 and token0 reserve is 1, `uint112.max * uint112.max * totalTimeElapsed`. In order for this to overflow, we need totalTimeElapsed to be > uint32.max, which is approx 132 years. So for this to overflow, we'd need to have the pool running for 132 years with one of the reserve being the max and the other one being just 1 wei for the entirety of the 132 years.\n\n\n**sherlock-admin3**\n\nPoC requested from @0xf1b0\n\nRequests remaining: **10**\n\n**0xf1b0**\n\nEven if we do not take reserves into account, the timestamp is converted into a 32-bit value.\n\n`uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);`\n\nWhen the timestamp gets >4294967296 (in 82 years), the `_update` function will always revert.\n\n\n**nevillehuang**\n\n@Czar102 what do you think? I don’t think its severe enough to warrant medium severity. I remember you rejected one of a similar finding in dodo as seen [here](https://github.com/sherlock-audit/2023-12-dodo-gsp-judging/issues/155)\n\n**Czar102**\n\nThe linked issue presented a way to DoS functionality. Is this also the case here? Or are funds locked here as well?\nIt seems to me that the funds are locked, so I'd accept this as a valid Medium (High impact in far future – a limitation).\n\n**nevillehuang**\n\n@Czar102 Agree, if long enough, all core functionalities `burn()` (Remove liquidity), `mint()` (add liquidity) and `swap()` that depends on this low level functions have the potential to be DoSed due to `_update()` reverting, will leave as medium severity\n\n**deadrosesxyz**\n\nEscalate \n\n`block.timestamp` stored in a uint32 will overflow in year 2102. This is way too far in the future and likely even beyond our lifetime. Even in the unlikely scenario where the protocol will be used in 80 years from now, users will know years in advance that they'll have to withdraw their funds as the protocol is about to shut down. Issue should be considered low/info\n\n**sherlock-admin2**\n\n> Escalate \n> \n> `block.timestamp` stored in a uint32 will overflow in year 2102. This is way too far in the future and likely even beyond our lifetime. Even in the unlikely scenario where the protocol will be used in 80 years from now, users will know years in advance that they'll have to withdraw their funds as the protocol is about to shut down. Issue should be considered low/info\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nI will invite any watsons to prove if accumulated actions (swap, burn and mint) can cause overflow in price variables (whether maliciously or accidentally)\n\n**giraffe0x**\n\nTimestamp overflow is less of a concern here, cumulative value is. \n\n1) As with uniswap, pools can be created with all sorts of exotic pairs. So ratio between reserve0/1 may be arbitrarily large. \n2) Code comments clearly state that \"overflow is desired\" when overflow cannot happen in current format. \n\nIt's a clear mistake on the devs, which has an easy fix to wrap with unchecked block. Not sure why they won't fix it. \n\n**deadrosesxyz**\n\n@giraffe0x hey, please check the initial message by @nevillehuang on why cumulatives cannot actually overflow.\nReserves are uint112s, so ratio can be max uint112.max : 1. \nAlso, the comment is not made by the devs, but actually left out from the copying of original univ2 contracts\n\n**nevillehuang**\n\n@deadrosesxyz, Could a malicious user(s) (despite requiring alot of funds) be able to brick the pool permanently by constantly performing actions (burn, swap, mint) and incrementing price variables?\n\n**deadrosesxyz**\n\n@nevillehuang No, constantly performing actions will not help for an overflow to occur in any way (as the cumulative increases based on seconds passed). Even in the most extreme scenario where one of the reserves has max value and the other one has simply 1 wei, it would take 132 years for an overflow to occur.  Quoting my comments from earlier:\n> let's put it this way. Ratio is scaled up by 2^112. Having a  (ratio * timeElapsed1) + (ratio * timeElapsed2) is the same as having (ratio * (timeElapsed1 + timeElapsed2). So if we have a token1 max reserve of uint112 and token0 reserve is 1, uint112.max * uint112.max * totalTimeElapsed. In order for this to overflow, we need totalTimeElapsed to be > uint32.max, which is approx 132 years. So for this to overflow, we'd need to have the pool running for 132 years with one of the reserve being the max and the other one being just 1 wei for the entirety of the 132 years.\n\n**nevillehuang**\n\nThis would depend on how @Czar102 interprets the following rule given he agreed initially that this should remain as a valid medium severity as seen [here](https://github.com/sherlock-audit/2024-02-jala-swap-judging/issues/186#issuecomment-1994188532)\n\n> Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n\n**mahmudoloyede**\n\n> @giraffe0x hey, please check the initial message by @nevillehuang on why cumulatives cannot actually overflow. Reserves are uint112s, so ratio can be max uint112.max : 1. Also, the comment is not made by the devs, but actually left out from the copying of original univ2 contracts\n\nIt really doesn't matter if it was left out from the copying of original univ2 contracts. The intent is for it to overflow but it won't in this case. Also if the pairs are tokens with decimals greater than 18, the DOS will occur sooner.\n\n**santiellena**\n\n> @nevillehuang No, constantly performing actions will not help for an overflow to occur in any way (as the cumulative increases based on seconds passed). Even in the most extreme scenario where one of the reserves has max value and the other one has simply 1 wei, it would take 132 years for an overflow to occur. Quoting my comments from earlier:\n> \n> > let's put it this way. Ratio is scaled up by 2^112. Having a  (ratio * timeElapsed1) + (ratio * timeElapsed2) is the same as having (ratio * (timeElapsed1 + timeElapsed2). So if we have a token1 max reserve of uint112 and token0 reserve is 1, uint112.max * uint112.max * totalTimeElapsed. In order for this to overflow, we need totalTimeElapsed to be > uint32.max, which is approx 132 years. So for this to overflow, we'd need to have the pool running for 132 years with one of the reserve being the max and the other one being just 1 wei for the entirety of the 132 years.\n\n@deadrosesxyz  It will actually take less than 132 years because the pair could have a token1 max reserve of uint112 and token0 reserve of 1 wei on the first block. This means that timeElapsed will be the block.timestamp of the first block (something like 1710940084 now). This means that 52.25 years of those 132 years have already passed. It is still a big number, however, it is easy to fix and a clear mistake on the devs.\n\n**Czar102**\n\nI maintain my judgment from preliminary judging – I think it should be Medium especially because of the \"overflow is desired\" comment, which means that sponsors care about the behavior in far future. Without these comments, the judgment on this issue would be disputable.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [deadrosesxyz](https://github.com/sherlock-audit/2024-02-jala-swap-judging/issues/186/#issuecomment-2003590158): rejected\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/233",
  "Code": [
    {
      "filename": "jalaswap-dex-contract/contracts/JalaPair.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./tokens/JalaERC20.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/UQ112x112.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IJalaFactory.sol\";\n\ninterface IMigrator {\n    // Return the desired amount of liquidity token that the migrator wants.\n    function desiredLiquidity() external view returns (uint256);\n}\n\ninterface IJalaCallee {\n    function JalaCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external;\n}\n\ncontract JalaPair is JalaERC20 {\n    error Locked();\n    error TransferFailed();\n    error Forbidden();\n    error Overflow();\n    error BadDesiredLiquidity();\n    error InsufficientLiquidityMinted();\n    error InsufficientLiquidityBurned();\n    error InsufficientLiquidity();\n    error InsufficientOutputAmount();\n    error InvalidTo();\n    error InsufficientInputAmount();\n    error InvalidK();\n\n    using UQ112x112 for uint224;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 private unlocked = 1;\n    modifier lock() {\n        if (unlocked != 1) revert Locked();\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) revert TransferFailed();\n    }\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        if (msg.sender != factory) revert Forbidden();\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint256 balance0, uint256 balance1, uint112 _reserve0, uint112 _reserve1) private {\n        if (balance0 > type(uint112).max || balance1 > type(uint112).max) revert Overflow();\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/2th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IJalaFactory(factory).feeTo(); // get feeTo address\n        feeOn = feeTo != address(0);\n        uint256 _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint256 rootK = Math.sqrt(uint256(_reserve0) * _reserve1);\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply * (rootK - rootKLast);\n                    uint256 denominator = rootK + rootKLast;\n                    uint256 liquidity = numerator / denominator;\n                    // distribute LP fee\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            if (IJalaFactory(factory).migrators(msg.sender)) {\n                liquidity = IMigrator(msg.sender).desiredLiquidity();\n                if (liquidity == 0 || liquidity == type(uint).max) revert BadDesiredLiquidity();\n            } else {\n                liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n            }\n        } else {\n            liquidity = Math.min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);\n        }\n        if (liquidity == 0) revert InsufficientLiquidityMinted();\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // // this low-level function should be called from a contract which performs important safety checks\n    // function mint(address to) external lock returns (uint liquidity) {\n    //     (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n    //     uint balance0 = IERC20(token0).balanceOf(address(this));\n    //     uint balance1 = IERC20(token1).balanceOf(address(this));\n    //     uint amount0 = balance0 - _reserve0;\n    //     uint amount1 = balance1 - _reserve1;\n\n    //     bool feeOn = _mintFee(_reserve0, _reserve1);\n    //     uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n    //     if (_totalSupply == 0) {\n    //         liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n    //        _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n    //     } else {\n    //         liquidity = Math.min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);\n    //     }\n    //     if (liquidity == 0) revert InsufficientLiquidityMinted();\n    //     _mint(to, liquidity);\n\n    //     _update(balance0, balance1, _reserve0, _reserve1);\n    //     if (feeOn) kLast = uint(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\n    //     emit Mint(msg.sender, amount0, amount1);\n    // }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = (liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = (liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        if (amount0 == 0 || amount1 == 0) revert InsufficientLiquidityBurned();\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external lock {\n        if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputAmount();\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        if (amount0Out > _reserve0 || amount1Out > _reserve1) revert InsufficientLiquidity();\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            if (to == _token0 || to == _token1) revert InvalidTo();\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (IJalaFactory(factory).flashOn() && data.length > 0) {\n                if (amount0Out > 0) {\n                    _safeTransfer(\n                        _token0,\n                        IJalaFactory(factory).feeTo(),\n                        (amount0Out * IJalaFactory(factory).flashFee()) / 10000\n                    );\n                    amount0Out = (amount0Out * (10000 + IJalaFactory(factory).flashFee())) / 10000;\n                }\n                if (amount1Out > 0) {\n                    _safeTransfer(\n                        _token1,\n                        IJalaFactory(factory).feeTo(),\n                        (amount1Out * IJalaFactory(factory).flashFee()) / 10000\n                    );\n                    amount1Out = (amount1Out * (10000 + IJalaFactory(factory).flashFee())) / 10000;\n                }\n                IJalaCallee(to).JalaCall(msg.sender, amount0Out, amount1Out, data);\n            }\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        if (amount0In == 0 && amount1In == 0) revert InsufficientInputAmount();\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = (balance0 * 1000) - (amount0In * 3);\n            uint256 balance1Adjusted = (balance1 * 1000) - (amount1In * 3);\n            if (balance0Adjusted * balance1Adjusted < uint256(_reserve0) * uint256(_reserve1) * (1000 ** 2))\n                revert InvalidK();\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)) - reserve0);\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)) - reserve1);\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}"
    }
  ]
}