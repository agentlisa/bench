{
  "Title": "[M-09] Message channels can be blocked resulting in DoS",
  "Content": "\nThe communication channel between a branch chain and a destination chain can be blocked by exploiting the ability to specify arbitrary gas parameters for the destination chain function calls. As Ulysses implements a non-blocking pattern, forcing the destination chain calls to revert creates an undesirable \"in blocking\" state.\n\nIn addition, as the requisite functions to clear the blocked channel were not implemented, the channel will remain blocked until a successful manual call to the blocked endpoint's `retryPayload` (with appropriate gas parameters).\n\nAs this vulnerability is created by the confluence of multiple underlying issues these have been split into three Root Causes for clarity:\n\n- Issue A: User can specify any gas params [against best-practice guidelines](https://layerzero.gitbook.io/docs/evm-guides/best-practice#gas-for-message-types).\n\n- Issue B: The protocol implements a non-blocking implementation pattern for `lzReceive` and doesn't handle the \"in-blocking scenario\".\n\n- Issue C: The protocol doesn't implement the `ILayerZeroUserApplicationConfig` functions as recommended.\n\nIt should also be noted that this can be exploited to cause economic damage to the protocol. In it's current state the [manual call](https://github.com/LayerZero-Labs/LayerZero/blob/48c21c3921931798184367fc02d3a8132b041942/contracts/Endpoint.sol#L127-L142) to `Endpoint::retryPayload()` is the only way to clear the channel. If the griefer were to initiate a high payload size call on a low-cost branch like Polygon zkEVM or Optimism, then the team will need to pay the gas fees to process the griefing payload at the higher gas cost on Arbitrum.\n\nDue to the ability to consistently (and at a low cost) block communication between the root chain and branch chain (which can only be unblocked through a manual intervention) the issue has been evaluated to high.\n\n### Proof of Concept\n\nBob deploys an ERC20 to the local chain, for example, Polygon. Bob now adds the token via the `CoreBranchRouter` by calling `addLocalToken`. Importantly, Bob sets the `gasParams` as `gasLimit: 1` (Issue A). This should not be allowed, as Layer Zero explicitly [advises](https://layerzero.gitbook.io/docs/evm-guides/best-practice#gas-for-message-types):\n\n> And the UA should enforce the gas estimate on-chain at the source chain to prevent users from inputting too low the value for gas.\n\nThe branch hToken is created and these \"poisoned\" gas parameters are now encoded and sent to the local `BridgeAgent` for a system callout.\n\n```\n        //Send Cross-Chain request (System Response/Request)\n        IBridgeAgent(localBridgeAgentAddress).callOutSystem{value: msg.value}(payable(msg.sender), payload, _gParams);\n    \n```\n\nIn the local `BaseBridgeAgent` the `callOutSystem` function is called at Lines 180-193. This passes on the poisoned `_gParams` to `_performCall` at Lines 766-779.\n\nIn `_performCall` the poisoned params are passed through to the local chain `LayerZeroEndpoint` via `send`:\n\n            ILayerZeroEndpoint(lzEndpointAddress).send{value: msg.value}(\n                rootChainId,\n                rootBridgeAgentPath,\n                _payload,\n                payable(_refundee),\n                address(0),\n                abi.encodePacked(uint16(2), _gParams.gasLimit, _gParams.remoteBranchExecutionGas, rootBridgeAgentAddress)\n            );\n\nIn the `Endpoint` contract the `outboundNonce` is incremented, and the `_getSendLibrary(uaConfig).send()` is called.\n\nThe call now passes through to the nodes and relayers and this finally passes the call through to the `try/catch` block in the `receivePayload()` function of the `Endpoint` contract on Arbitrum.\n\nHere, the `Endpoint` contract must make a call to the destination address via a`lzReceve` call. Such calls to `lzReceive` is should not fail in the Ulysses protocol (i.e. it is supposed to be non-blocking). We can see this in the `lzReceive` code implemented in the `RootBridgeAgent.sol` contract at Lines 424-433. It should never revert a call which originates from the `Endpoint` contract (Issue B).\n\nCrucially, the `_gasLimit` used here for the `lzReceive` call is the `_gasLimit` that was provided by Bob. But because Bob has specified a `gasLimit` of `1`, they force the call from the `Endpoint` contract to `RootBridgeAgent::lzReceive()` to revert due to an out-of-gas error. This causes the `Endpoint` contract to store the payload. This blocks any subsequent cross-chain messages for that chain which will revert with `LayerZero: in message blocking`.\n\nThe message channel is now blocked. The channel can only be unblocked through a manual call to `Endpoint::retryPayload()`; crucially, the Maia protocol team will need to bear the costs of this transaction.\n\nLayer Zero provides a \"get-out-of-jail-card\" for these cases through its `forceResumeReceive` functionality. Unfortunately, because of Issue C, the protocol doesn't implement `forceResumeReceive` and thus, has no other way to clear the channel without bearing the execution cost. This results in blocking the channel and communication loss.\n\n### Coded PoC\n\nTo accurately demonstrate the proof of concept we will use the below code, `testProofOfConcept`, and paste it into the file `RootForkTest.t.sol` in the audit repo. This provides us with a fork test environment which uses the actual `Endpoint` contract from Layer Zero.\n\nThe test uses the example of using `CoreBranchRouter::addLocalToken()` to demonstrate Issue A, where a user-supplied `gasParams` can lead to an \"OutOfGas\" revert on the destination chain call to `RootBridgeAgent:lzReceive`. It then demonstrates Issue B by showing how subsequent messages to the same chain fail (even when done with valid gas parameters) due to the blocking nature of `Endpoint`. This, combined with issue C, where there is no implementation of `forceResumeReceive()`, creates a situation where a channel between the source chain and the root chain can be blocked permanently.\n\nInstructions:\n\n1. Setup the audit repo as described in the audit readme (note that an Infura key and setting up the `.env` file is required).\n\n2. Copy the below code block into the `RootForktest.t.sol` in the `test/ulysses-omnichain` directory.\n\n3. Run the test with: `forge test --match-test testProofOfConcept -vvv`.\n    - (`-vvv` is necessary to show the errors for `OutOfGas` and `LayerZero: in message blocking`):\n\n```\nfunction testProofOfConcept() public {\n            \n            //Switch Chain and Execute Incoming Packets\n            switchToLzChain(avaxChainId);\n\n            vm.deal(address(this), 10 ether);\n\n            avaxCoreRouter.addLocalToken{value: 10 ether}(address(avaxMockAssetToken), GasParams(1, 0));\n\n            //Switch Chain and Execute Incoming Packets\n\n            /*  We expect the call to `RootBridgeAgent` to fail with an out of gas error,\n                but this won't be caught here due to the `switchToLzChain` abstraction.\n            */\n            switchToLzChain(rootChainId);\n\n            console2.log(\"RootBridgeAgent: \", address(arbitrumCoreBranchBridgeAgent).balance);\n            avaxMockAssethToken = rootPort.getLocalTokenFromUnderlying(address(avaxMockAssetToken), avaxChainId);\n\n            newAvaxAssetGlobalAddress = rootPort.getGlobalTokenFromLocal(avaxMockAssethToken, avaxChainId);\n\n            // We can now assert that it failed in the root chain\n            require(\n                rootPort.getGlobalTokenFromLocal(avaxMockAssethToken, avaxChainId) == address(0),\n                \"Token should be added\"\n            );\n            require(\n                rootPort.getLocalTokenFromGlobal(newAvaxAssetGlobalAddress, avaxChainId) == address(0),\n                \"Token should be added\"\n            );\n            require(\n                rootPort.getUnderlyingTokenFromLocal(avaxMockAssethToken, avaxChainId) == address(0),\n                \"Token should be added\"\n            );\n            switchToLzChain(avaxChainId);\n\n            vm.deal(address(this), 10 ether);\n\n            MockERC20 validToken = new MockERC20(\"Valid Token\", \"VALID\", 18);\n\n            avaxCoreRouter.addLocalToken{value: 10 ether}(address(validToken), GasParams(2_000_000, 0));\n\n            /*  Here we confirm that we the channel is blocked\n                We can see in the stack trace in the console that the call on the Root chain\n                was reverted with \"LayerZero: in message blocking\"\n            */\n            switchToLzChain(rootChainId);\n\n        }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nAs this submission demonstrates a high severity impact stemming from multiple root causes, the recommendations will be provided for each.\n\n**Issue A:**\n\nLayer Zero acknowledges that a cross-chain call can use more or less gas than the standard 200k. For this reason it allows the passing of [custom gas parameters](https://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters). This overrides the default amount of gas used. By allowing users to directly set these custom gas parameters (without validation) it opens the Ulysses implementation up to vulnerabilities related to cross-chain gas inequalities.\n\nConsider adding input validation within the `BridgeAgents` before a cross-chain call is commenced that ensures the `gasLimit` supplied is sufficient for the `lzReceive` call on the root chain. This can be expanded by calculating sufficient minimums for the various functions which are implemented (e.g. adding a token, bridging). An alternative would be to deny the user the ability to modify these params downward. The `BranchBridgeAgent::getFeeEstimate()` is [already implemented](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L161-L173), but never used in the contracts - this would be perfect for input validation.\n\n**Issue B:**\n\nThe current implementation is designed to never allow failures from the Layer Zero `Endpoint`, as it implements a non-blocking pattern. Due to Issue A, the `lzReceive` call from `Endpoint` can be forced to fail. This blocks the message channel, violating the intended non-blocking pattern (and giving rise to this issue).\n\nConsider inheriting from the Layer Zero non-blocking app [example](https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/lzApp/NonblockingLzApp.sol).\n\n**Issue C:**\n\nIt is highly recommended to implement the `ILayerZeroApplicationConfig`, as it provides access to `forceResumeReceive` in the case of a channel blockage and allows the protocol to resume communication between these two chains. Most importantly, it will allow the team to resume messaging at a fraction of what it might cost to call `retryPayload`.\n\n### Assessed type\n\nDoS\n\n**[alcueca (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-maia-findings/issues/399#issuecomment-1773994494):**\n > This is DoS attack. No funds are lost except gas, and as soon as the attacker stops, the application can resume operations.\n\n\n**[lokithe5th (warden) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/399#issuecomment-1786900600):**\n > @alcueca - I am in agreement that this is a DOS type attack, but I would respectfully raise the following as aggravating factors in support of my submission's original severity level:\n> \n> 1. The issue describes an attack that can be executed cheaply from a low gas-cost L2.\n>\n> 2. The effect of the attack is that the entire ecosystem's cross-chain accounting (and communication) system is brought to a halt (this source chain cannot communicate with the Root chain).\n>\n> 3. The DoS can be reversed through a call to `retryPayload` - but this call will have to be done manually, and the caller will have to pay the appropriate fees at their own cost. Cross-chain communication in the interim will silently fail.\n> \n> The twist here, is that an attacker can simply wait until the channel has been unblocked through the call to `retryPayload` and then initiate another DoS attack call at a very low cost. \n> \n> As a consequence an attacker effectively has the ability to interrupt `src->root` cross-chain communication for as long as they like, whenever they like. Effectively making Ulysses unusable from that source-chain.\n> \n> In further support, there is precedent for a High severity classification of this effect, as established in this [case](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1207 ) which also involved this class of vulnerability.\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-09-maia-findings/issues/399#issuecomment-1787993332)**\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/399#issuecomment-1792736032):**\n > > As a consequence an attacker effectively has the ability to interrupt src->root cross-chain communication for as long as they like, whenever they like. Effectively making Ulysses unusable from that source-chain.\n> \n> You are describing a DoS attack. Funds have not changed wallets. Note - that the attacker needs to **keep doing something** for the situation to persist. \n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/399#issuecomment-1807198452):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/4d2825cd4e73a69ad33bccaf2ceb07443f127beb).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "contracts/Endpoint.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroMessagingLibrary.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Endpoint is Ownable, ILayerZeroEndpoint {\n    uint16 public immutable chainId;\n\n    // installed libraries and reserved versions\n    uint16 public constant BLOCK_VERSION = 65535;\n    uint16 public constant DEFAULT_VERSION = 0;\n    uint16 public latestVersion;\n    mapping(uint16 => ILayerZeroMessagingLibrary) public libraryLookup; // version -> ILayerZeroEndpointLibrary\n\n    // default send/receive libraries\n    uint16 public defaultSendVersion;\n    uint16 public defaultReceiveVersion;\n    ILayerZeroMessagingLibrary public defaultSendLibrary;\n    address public defaultReceiveLibraryAddress;\n\n    struct LibraryConfig {\n        uint16 sendVersion;\n        uint16 receiveVersion;\n        address receiveLibraryAddress;\n        ILayerZeroMessagingLibrary sendLibrary;\n    }\n\n    struct StoredPayload {\n        uint64 payloadLength;\n        address dstAddress;\n        bytes32 payloadHash;\n    }\n\n    // user app config = [uaAddress]\n    mapping(address => LibraryConfig) public uaConfigLookup;\n    // inboundNonce = [srcChainId][srcAddress].\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n    // outboundNonce = [dstChainId][srcAddress].\n    mapping(uint16 => mapping(address => uint64)) public outboundNonce;\n    // storedPayload = [srcChainId][srcAddress]\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n\n    // library versioning events\n    event NewLibraryVersionAdded(uint16 version);\n    event DefaultSendVersionSet(uint16 version);\n    event DefaultReceiveVersionSet(uint16 version);\n    event UaSendVersionSet(address ua, uint16 version);\n    event UaReceiveVersionSet(address ua, uint16 version);\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n    // payload events\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n    event PayloadStored(uint16 srcChainId, bytes srcAddress, address dstAddress, uint64 nonce, bytes payload, bytes reason);\n\n    constructor(uint16 _chainId) {\n        chainId = _chainId;\n    }\n\n    //---------------------------------------------------------------------------\n    // send and receive nonreentrant lock\n    uint8 internal constant _NOT_ENTERED = 1;\n    uint8 internal constant _ENTERED = 2;\n    uint8 internal _send_entered_state = 1;\n    uint8 internal _receive_entered_state = 1;\n\n    modifier sendNonReentrant() {\n        require(_send_entered_state == _NOT_ENTERED, \"LayerZero: no send reentrancy\");\n        _send_entered_state = _ENTERED;\n        _;\n        _send_entered_state = _NOT_ENTERED;\n    }\n    modifier receiveNonReentrant() {\n        require(_receive_entered_state == _NOT_ENTERED, \"LayerZero: no receive reentrancy\");\n        _receive_entered_state = _ENTERED;\n        _;\n        _receive_entered_state = _NOT_ENTERED;\n    }\n\n    // BLOCK_VERSION is also a valid version\n    modifier validVersion(uint16 _version) {\n        require(_version <= latestVersion || _version == BLOCK_VERSION, \"LayerZero: invalid messaging library version\");\n        _;\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - Endpoint Interface\n\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable override sendNonReentrant {\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uint64 nonce = ++outboundNonce[_dstChainId][msg.sender];\n        _getSendLibrary(uaConfig).send{value: msg.value}(msg.sender, nonce, _dstChainId, _destination, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    //---------------------------------------------------------------------------\n    // authenticated Library (msg.sender) Calls to pass through Endpoint to UA (dstAddress)\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external override receiveNonReentrant {\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n        LibraryConfig storage uaConfig = uaConfigLookup[_dstAddress];\n\n        // authentication to prevent cross-version message validation\n        // protects against a malicious library from passing arbitrary data\n        if (uaConfig.receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveLibraryAddress == msg.sender, \"LayerZero: invalid default library\");\n        } else {\n            require(uaConfig.receiveLibraryAddress == msg.sender, \"LayerZero: invalid library\");\n        }\n\n        // block if any message blocking\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash == bytes32(0), \"LayerZero: in message blocking\");\n\n        try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload) {\n            // success, do nothing, end of the message delivery\n        } catch (bytes memory reason) {\n            // revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external override receiveNonReentrant {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash, \"LayerZero: invalid payload\");\n\n        address dstAddress = sp.dstAddress;\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n        emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner Calls, only new library version upgrade (3 steps)\n\n    // note libraryLookup[0] = 0x0, no library implementation\n    // LIBRARY UPGRADE step 1: set _newLayerZeroLibraryAddress be the new version\n    function newVersion(address _newLayerZeroLibraryAddress) external onlyOwner {\n        require(_newLayerZeroLibraryAddress != address(0x0), \"LayerZero: new version cannot be zero address\");\n        require(latestVersion < 65535, \"LayerZero: can not add new messaging library\");\n        latestVersion++;\n        libraryLookup[latestVersion] = ILayerZeroMessagingLibrary(_newLayerZeroLibraryAddress);\n        emit NewLibraryVersionAdded(latestVersion);\n    }\n\n    // LIBRARY UPGRADE step 2: stop sending messages from the old version\n    function setDefaultSendVersion(uint16 _newDefaultSendVersion) external onlyOwner validVersion(_newDefaultSendVersion) {\n        require(_newDefaultSendVersion != DEFAULT_VERSION, \"LayerZero: default send version must > 0\");\n        defaultSendVersion = _newDefaultSendVersion;\n        defaultSendLibrary = libraryLookup[defaultSendVersion];\n        emit DefaultSendVersionSet(_newDefaultSendVersion);\n    }\n\n    // LIBRARY UPGRADE step 3: stop receiving messages from the old version\n    function setDefaultReceiveVersion(uint16 _newDefaultReceiveVersion) external onlyOwner validVersion(_newDefaultReceiveVersion) {\n        require(_newDefaultReceiveVersion != DEFAULT_VERSION, \"LayerZero: default receive version must > 0\");\n        defaultReceiveVersion = _newDefaultReceiveVersion;\n        defaultReceiveLibraryAddress = address(libraryLookup[defaultReceiveVersion]);\n        emit DefaultReceiveVersionSet(_newDefaultReceiveVersion);\n    }\n\n    //---------------------------------------------------------------------------\n    // User Application Calls - UA set/get Interface\n\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override validVersion(_version) {\n        if (_version == DEFAULT_VERSION) {\n            require(defaultSendVersion == defaultReceiveVersion, \"LayerZero: can not set Config during DEFAULT migration\");\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not set config for BLOCK_VERSION\");\n        libraryLookup[_version].setConfig(_chainId, msg.sender, _configType, _config);\n    }\n\n    // Migration step 1: set the send version\n    // Define what library the UA points too\n    function setSendVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.sendVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.sendLibrary = libraryLookup[_newVersion];\n        emit UaSendVersionSet(msg.sender, _newVersion);\n    }\n\n    // Migration step 2: set the receive version\n    // after all messages sent from the old version are received\n    // the UA can now safely switch to the new receive version\n    // it is the UA's responsibility make sure all messages from the old version are processed\n    function setReceiveVersion(uint16 _newVersion) external override validVersion(_newVersion) {\n        // write into config\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uaConfig.receiveVersion = _newVersion;\n        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0\n        uaConfig.receiveLibraryAddress = address(libraryLookup[_newVersion]);\n        emit UaReceiveVersionSet(msg.sender, _newVersion);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        // revert if no messages are cached. safeguard malicious UA behaviour\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n        require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        // emit the event with the new nonce\n        emit UaForceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // view helper function\n\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParams) external view override returns (uint nativeFee, uint zroFee) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        ILayerZeroMessagingLibrary lib = uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendLibrary : uaConfig.sendLibrary;\n        return lib.estimateFees(_dstChainId, _userApplication, _payload, _payInZRO, _adapterParams);\n    }\n\n    function _getSendLibrary(LibraryConfig storage uaConfig) internal view returns (ILayerZeroMessagingLibrary) {\n        if (uaConfig.sendVersion == DEFAULT_VERSION) {\n            // check if the in send-blocking upgrade\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: default in BLOCK_VERSION\");\n            return defaultSendLibrary;\n        } else {\n            // check if the in send-blocking upgrade\n            require(uaConfig.sendVersion != BLOCK_VERSION, \"LayerZero: in BLOCK_VERSION\");\n            return uaConfig.sendLibrary;\n        }\n    }\n\n    function getSendLibraryAddress(address _userApplication) external view override returns (address sendLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 sendVersion = uaConfig.sendVersion;\n        require(sendVersion != BLOCK_VERSION, \"LayerZero: send version is BLOCK_VERSION\");\n        if (sendVersion == DEFAULT_VERSION) {\n            require(defaultSendVersion != BLOCK_VERSION, \"LayerZero: send version (default) is BLOCK_VERSION\");\n            sendLibraryAddress = address(defaultSendLibrary);\n        } else {\n            sendLibraryAddress = address(uaConfig.sendLibrary);\n        }\n    }\n\n    function getReceiveLibraryAddress(address _userApplication) external view override returns (address receiveLibraryAddress) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        uint16 receiveVersion = uaConfig.receiveVersion;\n        require(receiveVersion != BLOCK_VERSION, \"LayerZero: receive version is BLOCK_VERSION\");\n        if (receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveVersion != BLOCK_VERSION, \"LayerZero: receive version (default) is BLOCK_VERSION\");\n            receiveLibraryAddress = defaultReceiveLibraryAddress;\n        } else {\n            receiveLibraryAddress = uaConfig.receiveLibraryAddress;\n        }\n    }\n\n    function isSendingPayload() external view override returns (bool) {\n        return _send_entered_state == _ENTERED;\n    }\n\n    function isReceivingPayload() external view override returns (bool) {\n        return _receive_entered_state == _ENTERED;\n    }\n\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (uint64) {\n        return inboundNonce[_srcChainId][_srcAddress];\n    }\n\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view override returns (uint64) {\n        return outboundNonce[_dstChainId][_srcAddress];\n    }\n\n    function getChainId() external view override returns (uint16) {\n        return chainId;\n    }\n\n    function getSendVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendVersion : uaConfig.sendVersion;\n    }\n\n    function getReceiveVersion(address _userApplication) external view override returns (uint16) {\n        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];\n        return uaConfig.receiveVersion == DEFAULT_VERSION ? defaultReceiveVersion : uaConfig.receiveVersion;\n    }\n\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view override validVersion(_version) returns (bytes memory) {\n        if (_version == DEFAULT_VERSION) {\n            require(defaultSendVersion == defaultReceiveVersion, \"LayerZero: no DEFAULT config while migration\");\n            _version = defaultSendVersion;\n        }\n        require(_version != BLOCK_VERSION, \"LayerZero: can not get config for BLOCK_VERSION\");\n        return libraryLookup[_version].getConfig(_chainId, _userApplication, _configType);\n    }\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        return sp.payloadHash != bytes32(0);\n    }\n}"
    },
    {
      "filename": "src/BranchBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ExcessivelySafeCall} from \"lib/ExcessivelySafeCall.sol\";\n\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {BridgeAgentConstants} from \"./interfaces/BridgeAgentConstants.sol\";\nimport {\n    Deposit,\n    DepositInput,\n    DepositMultipleInput,\n    GasParams,\n    IBranchBridgeAgent,\n    ILayerZeroReceiver,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {ILayerZeroEndpoint} from \"./interfaces/ILayerZeroEndpoint.sol\";\n\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \"./BranchBridgeAgentExecutor.sol\";\n\n/// @title Library for Branch Bridge Agent Deployment\nlibrary DeployBranchBridgeAgent {\n    function deploy(\n        uint16 _rootChainId,\n        uint16 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _lzEndpointAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) external returns (BranchBridgeAgent) {\n        return new BranchBridgeAgent(\n            _rootChainId,\n            _localChainId,\n            _rootBridgeAgentAddress,\n            _lzEndpointAddress,\n            _localRouterAddress,\n            _localPortAddress\n        );\n    }\n}\n\n/// @title Branch Bridge Agent Contract\n/// @author MaiaDAO\ncontract BranchBridgeAgent is IBranchBridgeAgent, BridgeAgentConstants {\n    using ExcessivelySafeCall for address;\n\n    /*///////////////////////////////////////////////////////////////\n                         BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain Id for Root Chain where liquidity is virtualized(e.g. 4).\n    uint16 public immutable rootChainId;\n\n    /// @notice Chain Id for Local Chain.\n    uint16 public immutable localChainId;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address\n    ///         where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n\n    /// @notice Layer Zero messaging layer path for Root Bridge Agent Address where cross-chain requests\n    ///         are sent to the Root Chain Router.\n    bytes private rootBridgeAgentPath;\n\n    /// @notice Local Layerzero Endpoint Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable lzEndpointAddress;\n\n    /// @notice Address for Local Router used for custom actions for different hApps.\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address\n    ///         where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    address public immutable localPortAddress;\n\n    /// @notice Address for Bridge Agent Executor used for executing cross-chain requests.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                            DEPOSITS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying the transaction.\n    uint32 public depositNonce;\n\n    /// @notice Mapping from Pending deposits hash to Deposit Struct.\n    mapping(uint256 depositNonce => Deposit depositInfo) public getDeposit;\n\n    /*///////////////////////////////////////////////////////////////\n                        SETTLEMENT EXECUTION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, the bridge agent has already served a request with this nonce from a given chain.\n    mapping(uint256 settlementNonce => uint256 state) public executionState;\n\n    /*///////////////////////////////////////////////////////////////\n                           REENTRANCY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                             CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Branch Bridge Agent.\n     * @param _rootChainId Chain Id for Root Chain where liquidity is virtualized and assets are managed.\n     * @param _localChainId Chain Id for Local Chain.\n     * @param _rootBridgeAgentAddress Address for Bridge Agent who processes requests sent to and from the Root Chain.\n     * @param _lzEndpointAddress Local Layerzero Endpoint Address where cross-chain requests are sent to the Root Chain Router.\n     * @param _localRouterAddress Address for Local Router used for custom actions for different Omnichain dApps.\n     * @param _localPortAddress Address for Local Port Address where funds deposited from this chain are kept, managed\n     *                          and supplied to different Port Strategies.\n     */\n    constructor(\n        uint16 _rootChainId,\n        uint16 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _lzEndpointAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) {\n        require(_rootBridgeAgentAddress != address(0), \"Root Bridge Agent Address cannot be the zero address.\");\n        require(\n            _lzEndpointAddress != address(0) || _rootChainId == _localChainId,\n            \"Layerzero Endpoint Address cannot be the zero address.\"\n        );\n        require(_localRouterAddress != address(0), \"Local Router Address cannot be the zero address.\");\n        require(_localPortAddress != address(0), \"Local Port Address cannot be the zero address.\");\n\n        localChainId = _localChainId;\n        rootChainId = _rootChainId;\n        rootBridgeAgentAddress = _rootBridgeAgentAddress;\n        lzEndpointAddress = _lzEndpointAddress;\n        localRouterAddress = _localRouterAddress;\n        localPortAddress = _localPortAddress;\n        bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy();\n        depositNonce = 1;\n\n        rootBridgeAgentPath = abi.encodePacked(_rootBridgeAgentAddress, address(this));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getDepositEntry(uint32 _depositNonce) external view override returns (Deposit memory) {\n        return getDeposit[_depositNonce];\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getFeeEstimate(uint256 _gasLimit, uint256 _remoteBranchExecutionGas, bytes calldata _payload)\n        external\n        view\n        returns (uint256 _fee)\n    {\n        (_fee,) = ILayerZeroEndpoint(lzEndpointAddress).estimateFees(\n            rootChainId,\n            address(this),\n            _payload,\n            false,\n            abi.encodePacked(uint16(2), _gasLimit, _remoteBranchExecutionGas, rootBridgeAgentAddress)\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    USER / BRANCH ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSystem(address payable _refundee, bytes calldata _params, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n        requiresRouter\n    {\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x00), depositNonce++, _params);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOut(address payable _refundee, bytes calldata _params, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n    {\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x01), depositNonce++, _params);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridge(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        GasParams calldata _gParams\n    ) external payable override lock {\n        //Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            bytes1(0x02), _depositNonce, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit, _params\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _createDeposit(_depositNonce, _refundee, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridgeMultiple(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        GasParams calldata _gParams\n    ) external payable override lock {\n        //Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            bytes1(0x03),\n            uint8(_dParams.hTokens.length),\n            _depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _params\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _createDepositMultiple(\n            _depositNonce, _refundee, _dParams.hTokens, _dParams.tokens, _dParams.amounts, _dParams.deposits\n        );\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSigned(address payable _refundee, bytes calldata _params, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n    {\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x04), msg.sender, depositNonce++, _params);\n\n        //Perform Signed Call without deposit\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridge(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        //Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            _hasFallbackToggled ? bytes1(0x85) : bytes1(0x05),\n            msg.sender,\n            _depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _dParams.deposit,\n            _params\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _createDeposit(_depositNonce, _refundee, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridgeMultiple(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        // Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        // Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            _hasFallbackToggled ? bytes1(0x86) : bytes1(0x06),\n            msg.sender,\n            uint8(_dParams.hTokens.length),\n            _depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _params\n        );\n\n        // Create a Deposit and Send Cross-Chain request\n        _createDepositMultiple(\n            _depositNonce, _refundee, _dParams.hTokens, _dParams.tokens, _dParams.amounts, _dParams.deposits\n        );\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    DEPOSIT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retryDeposit(\n        bool _isSigned,\n        uint32 _depositNonce,\n        bytes calldata _params,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        // Get Settlement Reference\n        Deposit storage deposit = getDeposit[_depositNonce];\n\n        //Check if deposit belongs to message sender\n        if (deposit.owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory payload;\n\n        if (uint8(deposit.hTokens.length) == 1) {\n            if (_isSigned) {\n                //Pack new Data\n                payload = abi.encodePacked(\n                    _hasFallbackToggled ? bytes1(0x85) : bytes1(0x05),\n                    msg.sender,\n                    _depositNonce,\n                    deposit.hTokens[0],\n                    deposit.tokens[0],\n                    deposit.amounts[0],\n                    deposit.deposits[0],\n                    _params\n                );\n            } else {\n                payload = abi.encodePacked(\n                    bytes1(0x02),\n                    _depositNonce,\n                    deposit.hTokens[0],\n                    deposit.tokens[0],\n                    deposit.amounts[0],\n                    deposit.deposits[0],\n                    _params\n                );\n            }\n        } else if (uint8(deposit.hTokens.length) > 1) {\n            if (_isSigned) {\n                //Pack new Data\n                payload = abi.encodePacked(\n                    _hasFallbackToggled ? bytes1(0x86) : bytes1(0x06),\n                    msg.sender,\n                    uint8(deposit.hTokens.length),\n                    _depositNonce,\n                    deposit.hTokens,\n                    deposit.tokens,\n                    deposit.amounts,\n                    deposit.deposits,\n                    _params\n                );\n            } else {\n                payload = abi.encodePacked(\n                    bytes1(0x03),\n                    uint8(deposit.hTokens.length),\n                    _depositNonce,\n                    deposit.hTokens,\n                    deposit.tokens,\n                    deposit.amounts,\n                    deposit.deposits,\n                    _params\n                );\n            }\n        }\n\n        // Check if payload is empty\n        if (payload.length == 0) revert DepositRetryUnavailableUseCallout();\n\n        // Ensure success Status\n        deposit.status = STATUS_SUCCESS;\n\n        // Perform Call\n        _performCall(payable(msg.sender), payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrieveDeposit(uint32 _depositNonce, GasParams calldata _gParams) external payable override lock {\n        // Check if the deposit belongs to the message sender\n        if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x08), msg.sender, _depositNonce);\n\n        //Update State and Perform Call\n        _performCall(payable(msg.sender), payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function redeemDeposit(uint32 _depositNonce) external override lock {\n        // Get storage reference\n        Deposit storage deposit = getDeposit[_depositNonce];\n\n        // Check Deposit\n        if (deposit.status == STATUS_SUCCESS) revert DepositRedeemUnavailable();\n        if (deposit.owner == address(0)) revert DepositRedeemUnavailable();\n        if (deposit.owner != msg.sender) revert NotDepositOwner();\n\n        // Zero out owner\n        deposit.owner = address(0);\n\n        // Transfer token to depositor / user\n        for (uint256 i = 0; i < deposit.tokens.length;) {\n            _clearToken(msg.sender, deposit.hTokens[i], deposit.tokens[i], deposit.amounts[i], deposit.deposits[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Failed Deposit Token Info\n        delete getDeposit[_depositNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    SETTLEMENT EXTERNAL FUNCTIONS\n    ////////////////////////////////////////////////////////////"
    }
  ]
}