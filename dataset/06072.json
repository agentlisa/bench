{
  "Title": "[M-10] Initial deploy won't succeed because of too high `initialMintAmount` for USDC market",
  "Content": "\nAt the time of deploy, deployer initializes token markets with initial amount to prevent exploit. At least USDC and WETH markets will be initialized during deploy.\nBut `initialMintAmount` is hardcoded to `1e18` which is of for WETH (1,876 USD), but unrealistic for USDC (1,000,000,000,000 USD). Therefore deploy will fail.\n\n### Proof of Concept\n\nHere `initialMintAmount = 1 ether`: <br><https://github.com/code-423n4/2023-07-moonwell/blob/fced18035107a345c31c9a9497d0da09105df4df/test/proposals/Configs.sol#L55>\n\n```solidity\n    /// @notice initial mToken mint amount\n    uint256 public constant initialMintAmount = 1 ether;\n```\n\nHere this amount is approved to MToken contract and supplied to mint MToken: <br><https://github.com/code-423n4/2023-07-moonwell/blob/fced18035107a345c31c9a9497d0da09105df4df/test/proposals/mips/mip00.sol#L334-L379>\n\n```solidity\n            for (uint256 i = 0; i < cTokenConfigs.length; i++) {\n                Configs.CTokenConfiguration memory config = cTokenConfigs[i];\n\n                address cTokenAddress = addresses.getAddress(\n                    config.addressesString\n                );\n\n               ...\n\n                /// Approvals\n                _pushCrossChainAction(\n                    config.tokenAddress,\n                    abi.encodeWithSignature(\n                        \"approve(address,uint256)\",\n                        cTokenAddress,\n                        initialMintAmount\n                    ),\n                    \"Approve underlying token to be spent by market\"\n                );\n\n                /// Initialize markets\n                _pushCrossChainAction(\n                    cTokenAddress,\n                    abi.encodeWithSignature(\"mint(uint256)\", initialMintAmount),\n                    \"Initialize token market to prevent exploit\"\n                );\n\n                ...\n            }\n```\n\n### Recommended Mitigation Steps\n\nSpecify `initialMintAmount` for every token separately in config\n\n**[ElliotFriedman (Moonwell) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/143#issuecomment-1664684681):**\n > Valid issue, but we have already fixed this. Probably a low severity issue as this deploy script was only configured to work on local testnets where we control the ERC20 tokens.\n\n**[alcueca (Judge) commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/143#issuecomment-1676098751):**\n > The issue is still valid as Medium with the code and knowledge available to the wardens.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-moonwell",
  "Code": [
    {
      "filename": "test/proposals/Configs.sol",
      "content": "pragma solidity ^0.8.0;\n\nimport \"@forge-std/Test.sol\";\n\nimport {MockWeth} from \"@test/mock/MockWeth.sol\";\nimport {Addresses} from \"@test/proposals/Addresses.sol\";\nimport {MockWormholeCore} from \"@test/mock/MockWormholeCore.sol\";\nimport {MockChainlinkOracle} from \"@test/mock/MockChainlinkOracle.sol\";\nimport {FaucetTokenWithPermit} from \"@test/helper/FaucetToken.sol\";\n\ncontract Configs {\n    /// ----------------------------------------------------\n    /// TODO add in interest rate model to this struct later\n    /// once we get numbers around rates for each market\n    /// ----------------------------------------------------\n    struct CTokenConfiguration {\n        uint256 collateralFactor; /// collateral factor of the asset\n        uint256 reserveFactor; /// reserve factor of the asset\n        uint256 seizeShare; /// fee gotten from liquidation\n        uint256 supplyCap; /// supply cap\n        uint256 borrowCap; /// borrow cap\n        address priceFeed; /// chainlink price oracle\n        address tokenAddress; /// underlying token address\n        string addressesString; /// string used to set address in Addresses.sol\n        string symbol; /// symbol of the mToken\n        string name; /// name of the mToken\n        JumpRateModelConfiguration jrm; /// jump rate model configuration information\n    }\n\n    struct JumpRateModelConfiguration {\n        uint256 baseRatePerYear;\n        uint256 multiplierPerYear;\n        uint256 jumpMultiplierPerYear;\n        uint256 kink;\n    }\n\n    mapping(uint256 => CTokenConfiguration[]) public cTokenConfigurations;\n\n    struct EmissionConfig {\n        address mToken;\n        address owner;\n        address emissionToken;\n        uint256 supplyEmissionPerSec;\n        uint256 borrowEmissionsPerSec;\n        uint256 endTime;\n    }\n\n    /// mapping of all emission configs per chainid\n    mapping(uint256 => EmissionConfig[]) public emissions;\n\n    uint256 public constant _baseGoerliChainId = 84531;\n    uint256 public constant localChainId = 31337;\n\n    /// @notice initial mToken mint amount\n    uint256 public constant initialMintAmount = 1 ether;\n\n    function localInit(Addresses addresses) public {\n        if (block.chainid == localChainId) {\n            /// create mock wormhole core for local testing\n            MockWormholeCore wormholeCore = new MockWormholeCore();\n\n            addresses.addAddress(\"WORMHOLE_CORE\", address(wormholeCore));\n            addresses.addAddress(\"GUARDIAN\", address(this));\n        }\n    }\n\n    function deployAndMint(Addresses addresses) public {\n        if (block.chainid == _baseGoerliChainId) {\n            console.log(\"\\n----- deploy and mint on base goerli -----\\n\");\n            {\n                FaucetTokenWithPermit token = new FaucetTokenWithPermit(\n                    1e18,\n                    \"USD Coin\",\n                    6, /// 6 decimals\n                    \"USDC\"\n                );\n\n                addresses.addAddress(\"USDC\", address(token));\n\n                token.allocateTo(\n                    addresses.getAddress(\"TEMPORAL_GOVERNOR\"),\n                    initialMintAmount\n                );\n            }\n\n            {\n                MockWeth token = new MockWeth();\n                token.mint(\n                    addresses.getAddress(\"TEMPORAL_GOVERNOR\"),\n                    initialMintAmount\n                );\n                addresses.addAddress(\"WETH\", address(token));\n            }\n\n            {\n                FaucetTokenWithPermit token = new FaucetTokenWithPermit(\n                    1e18,\n                    \"Wrapped Bitcoin\",\n                    18, /// 6 decimals\n                    \"WBTC\"\n                );\n                token.allocateTo(\n                    addresses.getAddress(\"TEMPORAL_GOVERNOR\"),\n                    initialMintAmount\n                );\n\n                addresses.addAddress(\"WBTC\", address(token));\n            }\n        }\n    }\n\n    function init(Addresses addresses) public {\n        if (block.chainid == localChainId) {\n            console.log(\"\\n----- deploying locally -----\\n\");\n\n            /// cToken config for WETH, WBTC and USDC on base goerli testnet\n\n            {\n                MockChainlinkOracle usdcOracle = new MockChainlinkOracle(\n                    1e18,\n                    6\n                );\n                MockChainlinkOracle ethOracle = new MockChainlinkOracle(\n                    2_000e18,\n                    18\n                );\n                FaucetTokenWithPermit token = new FaucetTokenWithPermit(\n                    1e18,\n                    \"USD Coin\",\n                    6, /// 6 decimals\n                    \"USDC\"\n                );\n\n                token.allocateTo(\n                    addresses.getAddress(\"TEMPORAL_GOVERNOR\"),\n                    initialMintAmount\n                );\n\n                addresses.addAddress(\"USDC\", address(token));\n                addresses.addAddress(\"USDC_ORACLE\", address(usdcOracle));\n                addresses.addAddress(\"ETH_ORACLE\", address(ethOracle));\n\n                JumpRateModelConfiguration\n                    memory jrmConfig = JumpRateModelConfiguration(\n                        0.04e18,\n                        0.45e18,\n                        0.8e18,\n                        0.8e18\n                    );\n\n                CTokenConfiguration memory config = CTokenConfiguration({\n                    collateralFactor: 0.9e18,\n                    reserveFactor: 0.1e18,\n                    seizeShare: 2.8e16, //2.8%,\n                    supplyCap: 100e18,\n                    borrowCap: 100e18,\n                    priceFeed: address(usdcOracle),\n                    tokenAddress: address(token),\n                    name: \"Moonwell USDC\",\n                    symbol: \"mUSDC\",\n                    addressesString: \"MOONWELL_USDC\",\n                    jrm: jrmConfig\n                });\n\n                cTokenConfigurations[localChainId].push(config);\n            }\n\n            {\n                MockWeth token = new MockWeth();\n                token.mint(\n                    addresses.getAddress(\"TEMPORAL_GOVERNOR\"),\n                    initialMintAmount\n                );\n                addresses.addAddress(\"WETH\", address(token));\n\n                JumpRateModelConfiguration\n                    memory jrmConfig = JumpRateModelConfiguration(\n                        0.04e18,\n                        0.45e18,\n                        0.8e18,\n                        0.8e18\n                    );\n\n                CTokenConfiguration memory config = CTokenConfiguration({\n                    collateralFactor: 0.6e18,\n                    reserveFactor: 0.1e18,\n                    seizeShare: 2.8e16, //2.8%,\n                    supplyCap: 100e18,\n                    borrowCap: 100e18,\n                    priceFeed: addresses.getAddress(\"ETH_ORACLE\"),\n                    tokenAddress: address(token),\n                    addressesString: \"MOONWELL_ETH\",\n                    name: \"Moonwell ETH\",\n                    symbol: \"mETH\",\n                    jrm: jrmConfig\n                });\n\n                cTokenConfigurations[localChainId].push(config);\n            }\n\n            return;\n        }\n\n        if (block.chainid == _baseGoerliChainId) {\n            console.log(\"\\n----- deploying on base goerli -----\\n\");\n\n            /// cToken config for WETH, WBTC and USDC on base goerli testnet\n            {\n\n                address token = addresses.getAddress(\"USDC\");\n\n                JumpRateModelConfiguration\n                    memory jrmConfig = JumpRateModelConfiguration(\n                        0.04e18,\n                        0.45e18,\n                        0.8e18,\n                        0.8e18\n                    );\n\n                CTokenConfiguration memory config = CTokenConfiguration({\n                    collateralFactor: 0.9e18,\n                    reserveFactor: 0.1e18,\n                    seizeShare: 2.8e16, //2.8%,\n                    supplyCap: 100e18,\n                    borrowCap: 100e18,\n                    priceFeed: addresses.getAddress(\"USDC_ORACLE\"),\n                    tokenAddress: token,\n                    name: \"Moonwell USDC\",\n                    symbol: \"mUSDC\",\n                    addressesString: \"MOONWELL_USDC\",\n                    jrm: jrmConfig\n                });\n\n                cTokenConfigurations[_baseGoerliChainId].push(config);\n            }\n\n            {\n                address token = addresses.getAddress(\"WETH\");\n\n                JumpRateModelConfiguration\n                    memory jrmConfig = JumpRateModelConfiguration(\n                        0.04e18,\n                        0.45e18,\n                        0.8e18,\n                        0.8e18\n                    );\n\n                CTokenConfiguration memory config = CTokenConfiguration({\n                    collateralFactor: 0.6e18,\n                    reserveFactor: 0.1e18,\n                    seizeShare: 2.8e16, //2.8%,\n                    supplyCap: 100e18,\n                    borrowCap: 100e18,\n                    priceFeed: addresses.getAddress(\"ETH_ORACLE\"),\n                    tokenAddress: token,\n                    addressesString: \"MOONWELL_ETH\",\n                    name: \"Moonwell ETH\",\n                    symbol: \"mETH\",\n                    jrm: jrmConfig\n                });\n\n                cTokenConfigurations[_baseGoerliChainId].push(config);\n            }\n\n            {\n                address token = addresses.getAddress(\"WBTC\");\n\n                JumpRateModelConfiguration\n                    memory jrmConfig = JumpRateModelConfiguration(\n                        0.04e18,\n                        0.45e18,\n                        0.8e18,\n                        0.8e18\n                    );\n\n                CTokenConfiguration memory config = CTokenConfiguration({\n                    collateralFactor: 0.4e18,\n                    reserveFactor: 0.1e18,\n                    seizeShare: 2.8e16, //2.8%,\n                    supplyCap: 100e18,\n                    borrowCap: 100e18,\n                    priceFeed: addresses.getAddress(\"BTC_ORACLE\"),\n                    tokenAddress: token,\n                    addressesString: \"MOONWELL_BTC\",\n                    name: \"Moonwell BTC\",\n                    symbol: \"mBTC\",\n                    jrm: jrmConfig\n                });\n\n                cTokenConfigurations[_baseGoerliChainId].push(config);\n            }\n\n            return;\n        }\n    }\n\n    function initEmissions(Addresses addresses) public {\n        if (block.chainid == localChainId) {\n            {\n                /// pay USDC Emissions for depositing ETH locally\n                EmissionConfig memory emissionConfig = EmissionConfig({\n                    mToken: addresses.getAddress(\"MOONWELL_ETH\"),\n                    owner: addresses.getAddress(\"GUARDIAN\"),\n                    emissionToken: addresses.getAddress(\"USDC\"),\n                    supplyEmissionPerSec: 1e18,\n                    borrowEmissionsPerSec: 0,\n                    endTime: block.timestamp + 365 days\n                });\n\n                emissions[localChainId].push(emissionConfig);\n            }\n        }\n    }\n\n    function getCTokenConfigurations(\n        uint256 chainId\n    ) public view returns (CTokenConfiguration[] memory) {\n        CTokenConfiguration[] memory configs = new CTokenConfiguration[](\n            cTokenConfigurations[chainId].length\n        );\n\n        unchecked {\n            uint256 configLength = configs.length;\n            for (uint256 i = 0; i < configLength; i++) {\n                configs[i] = CTokenConfiguration({\n                    collateralFactor: cTokenConfigurations[chainId][i]\n                        .collateralFactor,\n                    reserveFactor: cTokenConfigurations[chainId][i]\n                        .reserveFactor,\n                    seizeShare: cTokenConfigurations[chainId][i].seizeShare,\n                    supplyCap: cTokenConfigurations[chainId][i].supplyCap,\n                    borrowCap: cTokenConfigurations[chainId][i].borrowCap,\n                    addressesString: cTokenConfigurations[chainId][i]\n                        .addressesString,\n                    priceFeed: cTokenConfigurations[chainId][i].priceFeed,\n                    tokenAddress: cTokenConfigurations[chainId][i].tokenAddress,\n                    symbol: cTokenConfigurations[chainId][i].symbol,\n                    name: cTokenConfigurations[chainId][i].name,\n                    jrm: cTokenConfigurations[chainId][i].jrm\n                });\n            }\n        }\n\n        return configs;\n    }\n\n    function getEmissionConfigurations(\n        uint256 chainId\n    ) public view returns (EmissionConfig[] memory) {\n        EmissionConfig[] memory configs = new EmissionConfig[](\n            emissions[chainId].length\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < configs.length; i++) {\n                configs[i] = EmissionConfig({\n                    mToken: emissions[chainId][i].mToken,\n                    owner: emissions[chainId][i].owner,\n                    emissionToken: emissions[chainId][i].emissionToken,\n                    supplyEmissionPerSec: emissions[chainId][i]\n                        .supplyEmissionPerSec,\n                    borrowEmissionsPerSec: emissions[chainId][i]\n                        .borrowEmissionsPerSec,\n                    endTime: emissions[chainId][i].endTime\n                });\n            }\n        }\n\n        return configs;\n    }\n}"
    },
    {
      "filename": "test/proposals/mips/mip00.sol",
      "content": "//SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@forge-std/Test.sol\";\n\nimport {TransparentUpgradeableProxy, ITransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {TimelockController} from \"@openzeppelin/contracts/governance/TimelockController.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport {Proposal} from \"@test/proposals/proposalTypes/Proposal.sol\";\nimport {Addresses} from \"@test/proposals/Addresses.sol\";\nimport {TimelockProposal} from \"@test/proposals/proposalTypes/TimelockProposal.sol\";\n\nimport {Comptroller, ComptrollerInterface} from \"@protocol/core/Comptroller.sol\";\nimport {MErc20Delegate} from \"@protocol/core/MErc20Delegate.sol\";\nimport {MErc20Delegator} from \"@protocol/core/MErc20Delegator.sol\";\n\nimport {PriceOracle} from \"@protocol/core/Oracles/PriceOracle.sol\";\nimport {ChainlinkOracle} from \"@protocol/core/Oracles/ChainlinkOracle.sol\";\nimport {JumpRateModel, InterestRateModel} from \"@protocol/core/IRModels/JumpRateModel.sol\";\nimport {TemporalGovernor} from \"@protocol/core/Governance/TemporalGovernor.sol\";\nimport {IWormhole} from \"@protocol/core/Governance/IWormhole.sol\";\nimport {Unitroller} from \"@protocol/core/Unitroller.sol\";\nimport {MErc20} from \"@protocol/core/MErc20.sol\";\n\nimport {MultiRewardDistributor} from \"@protocol/core/MultiRewardDistributor/MultiRewardDistributor.sol\";\nimport {MultiRewardDistributorCommon} from \"@protocol/core/MultiRewardDistributor/MultiRewardDistributorCommon.sol\";\nimport {WETH9} from \"@protocol/core/router/IWETH.sol\";\n\nimport {FaucetTokenWithPermit} from \"@test/helper/FaucetToken.sol\";\nimport {MockWeth} from \"@test/mock/MockWeth.sol\";\nimport {WETHRouter} from \"@protocol/core/router/WETHRouter.sol\";\nimport {MToken} from \"@protocol/core/MToken.sol\";\nimport {ChainIds} from \"@test/utils/ChainIds.sol\";\n\nimport {Configs} from \"@test/proposals/Configs.sol\";\n\nimport {CrossChainProposal} from \"@test/proposals/proposalTypes/CrossChainProposal.sol\";\n\ncontract mip00 is Proposal, CrossChainProposal, ChainIds, Configs {\n    string public constant name = \"MIP00\";\n    uint256 public constant liquidationIncentive = 1.1e18; /// liquidation incentive is 110%\n    uint256 public constant closeFactor = 5e17; /// close factor is 50%, i.e. seize share\n    uint8 public constant mTokenDecimals = 8; /// all mTokens have 8 decimals\n\n    /// @notice proposal delay time\n    uint256 public constant proposalDelay = 5 minutes;\n\n    /// @notice time before anyone can unpause the contract after a guardian pause\n    uint256 public constant permissionlessUnpauseTime = 30 days;\n\n    /// --------------------------------------------------------------------------------------------------///\n    /// Chain Name\t       Wormhole Chain ID   Network ID\tAddress                                      |///\n    ///  Ethereum (Goerli)   \t  2\t                5\t    0x706abc4E45D419950511e474C7B9Ed348A4a716c   |///\n    ///  Ethereum (Sepolia)\t  10002          11155111\t    0x4a8bc80Ed5a4067f1CCf107057b8270E0cC11A78   |///\n    ///  Base\t                 30    \t        84531\t    0xA31aa3FDb7aF7Db93d18DDA4e19F811342EDF780   |///\n    ///  Moonbeam\t             16\t             1284 \t    0xC8e2b0cD52Cf01b0Ce87d389Daa3d414d4cE29f3   |///\n    /// --------------------------------------------------------------------------------------------------///\n\n    constructor() {\n        _setNonce(2);\n    }\n\n    struct CTokenAddresses {\n        address mTokenImpl;\n        address irModel;\n        address temporalGov;\n        address unitroller;\n    }\n\n    /// @notice the deployer should have both USDC, WETH and any other assets that will be started as\n    /// listed to be able to deploy on base. This allows the deployer to be able to initialize the\n    /// markets with a balance to avoid exploits\n    function deploy(Addresses addresses, address) public {\n        /// ------- TemporalGovernor -------\n\n        console.log(\n            \"deploying governor with wormhole chain id: \",\n            chainIdToWormHoleId[block.chainid],\n            \" as owner\"\n        );\n        console.log(\n            \"governor owner: \",\n            addresses.getAddress(\"MOONBEAM_TIMELOCK\")\n        );\n\n        localInit(addresses);\n\n        {\n            TemporalGovernor.TrustedSender[]\n                memory trustedSenders = new TemporalGovernor.TrustedSender[](1);\n            trustedSenders[0].chainId = chainIdToWormHoleId[block.chainid];\n            trustedSenders[0].addr = addresses.getAddress(\"MOONBEAM_TIMELOCK\");\n\n            require(\n                addresses.getAddress(\"WORMHOLE_CORE\") != address(0),\n                \"MIP00: WORMHOLE_CORE not set\"\n            );\n\n            /// this will be the governor for all the contracts\n            TemporalGovernor governor = new TemporalGovernor(\n                addresses.getAddress(\"WORMHOLE_CORE\"),\n                proposalDelay,\n                permissionlessUnpauseTime,\n                trustedSenders\n            );\n\n            addresses.addAddress(\"TEMPORAL_GOVERNOR\", address(governor));\n        }\n\n        deployAndMint(addresses);\n        init(addresses);\n\n        /// ------- Reward Distributor -------\n\n        {\n            MultiRewardDistributor distributor = new MultiRewardDistributor();\n            addresses.addAddress(\n                \"MULTI_REWARD_DISTRIBUTOR\",\n                address(distributor)\n            );\n        }\n\n        {\n            /// ------- Unitroller/Comptroller -------\n\n            Unitroller unitroller = new Unitroller();\n            Comptroller comptroller = new Comptroller();\n\n            unitroller._setPendingImplementation(address(comptroller));\n            comptroller._become(unitroller);\n\n            addresses.addAddress(\"COMPTROLLER\", address(comptroller));\n            addresses.addAddress(\"UNITROLLER\", address(unitroller));\n\n            ProxyAdmin proxyAdmin = new ProxyAdmin();\n\n            bytes memory initData = abi.encodeWithSignature(\n                \"initialize(address,address)\",\n                address(unitroller),\n                addresses.getAddress(\"GUARDIAN\") /// TODO figure out what the pause guardian is on Base, then replace it\n            );\n\n            TransparentUpgradeableProxy mrdProxy = new TransparentUpgradeableProxy(\n                    addresses.getAddress(\"MULTI_REWARD_DISTRIBUTOR\"),\n                    address(proxyAdmin),\n                    initData\n                );\n\n            addresses.addAddress(\"MRD_PROXY\", address(mrdProxy));\n            addresses.addAddress(\"MRD_PROXY_ADMIN\", address(proxyAdmin));\n        }\n\n        /// ------ MTOKENS -------\n\n        {\n            MErc20Delegate mTokenLogic = new MErc20Delegate();\n            addresses.addAddress(\"MTOKEN_IMPLEMENTATION\", address(mTokenLogic));\n        }\n\n        Configs.CTokenConfiguration[]\n            memory cTokenConfigs = getCTokenConfigurations(block.chainid);\n\n        uint256 cTokenConfigsLength = cTokenConfigs.length;\n        //// create all of the CTokens according to the configuration in Config.sol\n        unchecked {\n            for (uint256 i = 0; i < cTokenConfigsLength; i++) {\n                Configs.CTokenConfiguration memory config = cTokenConfigs[i];\n\n                /// ----- Jump Rate IRM -------\n                {\n                    address irModel = address(\n                        new JumpRateModel(\n                            config.jrm.baseRatePerYear,\n                            config.jrm.multiplierPerYear,\n                            config.jrm.jumpMultiplierPerYear,\n                            config.jrm.kink\n                        )\n                    );\n\n                    addresses.addAddress(\n                        string(\n                            abi.encodePacked(\n                                \"JUMP_RATE_IRM_\",\n                                config.addressesString\n                            )\n                        ),\n                        address(irModel)\n                    );\n                }\n\n                /// stack isn't too deep\n                CTokenAddresses memory addr = CTokenAddresses({\n                    mTokenImpl: addresses.getAddress(\"MTOKEN_IMPLEMENTATION\"),\n                    irModel: addresses.getAddress(\n                        string(\n                            abi.encodePacked(\n                                \"JUMP_RATE_IRM_\",\n                                config.addressesString\n                            )\n                        )\n                    ),\n                    temporalGov: addresses.getAddress(\"TEMPORAL_GOVERNOR\"),\n                    unitroller: addresses.getAddress(\"UNITROLLER\")\n                });\n\n                /// TODO calculate initial exchange rate\n                /// BigNumber.from(\"10\").pow(token.decimals + 8).mul(\"2\");\n                /// (10 ** (18 + 8)) * 2 // 18 decimals example\n                ///    = 2e26\n                /// (10 ** (6 + 8)) * 2 // 6 decimals example\n                ///    = 2e14\n                uint256 initialExchangeRate = (10 **\n                    (ERC20(config.tokenAddress).decimals() + 8)) * 2;\n\n                MErc20Delegator mToken = new MErc20Delegator(\n                    config.tokenAddress,\n                    ComptrollerInterface(addr.unitroller),\n                    InterestRateModel(addr.irModel),\n                    initialExchangeRate,\n                    config.name,\n                    config.symbol,\n                    mTokenDecimals,\n                    payable(addr.temporalGov),\n                    addr.mTokenImpl,\n                    \"\"\n                );\n\n                addresses.addAddress(config.addressesString, address(mToken));\n            }\n        }\n\n        initEmissions(addresses);\n\n        WETHRouter router = new WETHRouter(\n            WETH9(addresses.getAddress(\"WETH\")),\n            MErc20(addresses.getAddress(\"MOONWELL_ETH\"))\n        );\n        addresses.addAddress(\"WETH_ROUTER\", address(router));\n\n        /// deploy oracle, set price oracle\n        ChainlinkOracle oracle = new ChainlinkOracle(\"null_asset\");\n        addresses.addAddress(\"CHAINLINK_ORACLE\", address(oracle));\n    }\n\n    function afterDeploy(Addresses addresses, address) public {\n        ProxyAdmin proxyAdmin = ProxyAdmin(\n            addresses.getAddress(\"MRD_PROXY_ADMIN\")\n        );\n        Unitroller unitroller = Unitroller(addresses.getAddress(\"UNITROLLER\"));\n        address governor = addresses.getAddress(\"TEMPORAL_GOVERNOR\");\n        ChainlinkOracle oracle = ChainlinkOracle(\n            addresses.getAddress(\"CHAINLINK_ORACLE\")\n        );\n\n        /// set proxy admin as the owner of the temporal governor\n        proxyAdmin.transferOwnership(governor);\n\n        Comptroller(address(unitroller))._setPriceOracle(\n            PriceOracle(address(oracle))\n        );\n\n        /// set chainlink oracle on the comptroller implementation contract\n\n        Configs.CTokenConfiguration[]\n            memory cTokenConfigs = getCTokenConfigurations(block.chainid);\n        MToken[] memory mTokens = new MToken[](cTokenConfigs.length);\n        uint256[] memory supplyCaps = new uint256[](cTokenConfigs.length);\n        uint256[] memory borrowCaps = new uint256[](cTokenConfigs.length);\n        //// set mint paused for all of the deployed MTokens\n        unchecked {\n            for (uint256 i = 0; i < cTokenConfigs.length; i++) {\n                Configs.CTokenConfiguration memory config = cTokenConfigs[i];\n                supplyCaps[i] = config.supplyCap;\n                borrowCaps[i] = config.borrowCap;\n\n                oracle.setFeed(\n                    ERC20(config.tokenAddress).symbol(),\n                    config.priceFeed\n                );\n\n                /// list both mUSDC and mETH in the comptroller\n                Comptroller(address(unitroller))._supportMarket(\n                    MToken(addresses.getAddress(config.addressesString))\n                );\n\n                /// set mint paused for all MTokens\n                Comptroller(address(unitroller))._setMintPaused(\n                    MToken(addresses.getAddress(config.addressesString)),\n                    true\n                );\n\n                /// get the mToken\n                mTokens[i] = MToken(\n                    addresses.getAddress(config.addressesString)\n                );\n            }\n        }\n\n        Comptroller(address(unitroller))._setMarketSupplyCaps(\n            mTokens,\n            supplyCaps\n        );\n        Comptroller(address(unitroller))._setMarketBorrowCaps(\n            mTokens,\n            borrowCaps\n        );\n\n        /// set temporal governor as the pending admin\n        unitroller._setPendingAdmin(governor);\n\n        /// set temporal governor as the admin of the chainlink feed\n        oracle.setAdmin(governor);\n    }\n\n    function build(Addresses addresses) public {\n        /// Unitroller configuration\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\"_acceptAdmin()\"),\n            \"Temporal governor accepts admin on Unitroller\"\n        );\n\n        Configs.CTokenConfiguration[]\n            memory cTokenConfigs = getCTokenConfigurations(block.chainid);\n\n        address unitrollerAddress = addresses.getAddress(\"UNITROLLER\");\n\n        /// set mint unpaused for all of the deployed MTokens\n        unchecked {\n            for (uint256 i = 0; i < cTokenConfigs.length; i++) {\n                Configs.CTokenConfiguration memory config = cTokenConfigs[i];\n\n                address cTokenAddress = addresses.getAddress(\n                    config.addressesString\n                );\n\n                _pushCrossChainAction(\n                    unitrollerAddress,\n                    abi.encodeWithSignature(\n                        \"_setMintPaused(address,bool)\",\n                        cTokenAddress,\n                        false\n                    ),\n                    \"Unpause MToken market\"\n                );\n\n                /// Approvals\n                _pushCrossChainAction(\n                    config.tokenAddress,\n                    abi.encodeWithSignature(\n                        \"approve(address,uint256)\",\n                        cTokenAddress,\n                        initialMintAmount\n                    ),\n                    \"Approve underlying token to be spent by market\"\n                );\n\n                /// Initialize markets\n                _pushCrossChainAction(\n                    cTokenAddress,\n                    abi.encodeWithSignature(\"mint(uint256)\", initialMintAmount),\n                    \"Initialize token market to prevent exploit\"\n                );\n\n                /// _setCollateralFactor\n                _pushCrossChainAction(\n                    unitrollerAddress,\n                    abi.encodeWithSignature(\n                        \"_setCollateralFactor(address,uint256)\",\n                        cTokenAddress,\n                        config.collateralFactor\n                    ),\n                    \"Set CF on CToken\"\n                );\n            }\n        }\n\n        _pushCrossChainAction(\n            unitrollerAddress,\n            abi.encodeWithSignature(\n                \"_setLiquidationIncentive(uint256)\",\n                liquidationIncentive\n            ),\n            \"Set CF on CToken\"\n        );\n\n        _pushCrossChainAction(\n            unitrollerAddress,\n            abi.encodeWithSignature(\n                \"_setCloseFactor(uint256)\",\n                closeFactor\n            ),\n            \"Set Close Factor on CToken\"\n        );\n\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\n                \"_setRewardDistributor(address)\",\n                addresses.getAddress(\"MRD_PROXY\")\n            ),\n            \"Set reward distributor on comptroller\"\n        );\n\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\n                \"_setSupplyCapGuardian(address)\",\n                addresses.getAddress(\"GUARDIAN\")\n            ),\n            \"Set supply cap guardian\"\n        );\n\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\n                \"_setBorrowCapGuardian(address)\",\n                addresses.getAddress(\"GUARDIAN\")\n            ),\n            \"Set borrow cap guardian\"\n        );\n\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\n                \"_setPauseGuardian(address)\",\n                addresses.getAddress(\"GUARDIAN\")\n            ),\n            \"Set pause guardian\"\n        );\n\n        /// -------------- EMISSION CONFIGURATION --------------\n\n        EmissionConfig[] memory emissionConfig = getEmissionConfigurations(\n            block.chainid\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < emissionConfig.length; i++) {\n                EmissionConfig memory config = emissionConfig[i];\n                _pushCrossChainAction(\n                    addresses.getAddress(\"MRD_PROXY\"),\n                    abi.encodeWithSignature(\n                        \"_addEmissionConfig(address,address,address,uint256,uint256,uint256)\",\n                        config.mToken,\n                        config.owner,\n                        config.emissionToken,\n                        config.supplyEmissionPerSec,\n                        config.borrowEmissionsPerSec,\n                        config.endTime\n                    ),\n                    \"Add emission configuration\"\n                );\n            }\n        }\n    }\n\n    function run(Addresses addresses, address) public {\n        _simulateCrossChainActions(addresses.getAddress(\"TEMPORAL_GOVERNOR\"));\n    }\n\n    function printCalldata(Addresses addresses) public {\n        printActions(\n            addresses.getAddress(\"TEMPORAL_GOVERNOR\"),\n            addresses.getAddress(\"WORMHOLE_CORE\")\n        );\n    }\n\n    function teardown(Addresses addresses, address) public pure {}\n\n    function validate(Addresses addresses, address deployer) public {\n        TemporalGovernor governor = TemporalGovernor(\n            addresses.getAddress(\"TEMPORAL_GOVERNOR\")\n        );\n\n        /// assert comptroller and unitroller are wired together properly\n        {\n            Unitroller unitroller = Unitroller(\n                addresses.getAddress(\"UNITROLLER\")\n            );\n            Comptroller comptroller = Comptroller(\n                addresses.getAddress(\"COMPTROLLER\")\n            );\n\n            assertEq(comptroller.admin(), deployer);\n            assertEq(comptroller.pendingAdmin(), address(0));\n            assertEq(comptroller.pauseGuardian(), address(0));\n            assertEq(comptroller.borrowCapGuardian(), address(0));\n            assertEq(comptroller.supplyCapGuardian(), address(0));\n            assertEq(address(comptroller.rewardDistributor()), address(0));\n\n            assertEq("
    }
  ]
}