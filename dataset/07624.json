{
  "Title": "[H-07] GiantLP with a transferHookProcessor cant be burned, users’ funds will be stuck in the Giant Pool",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantLP.sol#L39-L47\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L73-L78\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L57\n\n\n# Vulnerability details\n\n## Impact\nThe GiantLP with a transferHookProcessor will call `transferHookProcessor.beforeTokenTransfer(_from, _to, _amount)` when it's transferred / minted / burned. \n\nBut the `to` address is address(0x00) in the erc20 `_burn` function. The GiantMevAndFeesPool.beforeTokenTransfer will call the function `SyndicateRewardsProcessor._distributeETHRewardsToUserForToken` will a zero address check in the first line:\n```\nfunction _distributeETHRewardsToUserForToken(...) internal {\n    require(_recipient != address(0), \"Zero address\");\n```\n\nSo any withdraw function with a operation of burning the GiantLP token with a transferHookProcessor will revert because of the zero address check. The users' funds will be stuck in the Giant Pool contracts.\n\n## Proof of Concept\nI wrote a test about `GiantMevAndFeesPool.withdrawETH` function which is used to withdraw eth from the Giant Pool. It will be reverted.\n\ntest/foundry/LpBurn.t.sol\n```\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\nimport {GiantPoolTests} from \"./GiantPools.t.sol\";\n\ncontract LpBurnTests is GiantPoolTests {\n    function testburn() public{\n        address feesAndMevUserOne = accountOne; vm.deal(feesAndMevUserOne, 4 ether);\n        vm.startPrank(feesAndMevUserOne);\n        giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);\n        giantFeesAndMevPool.withdrawETH(4 ether);\n        vm.stopPrank();\n    }\n}\n```\n\nrun test\n```\nforge test --match-test testburn -vvv\n```\n\ntest log:\n```\n...\n...\n    ├─ [115584] GiantMevAndFeesPool::withdrawETH(4000000000000000000) \n    │   ├─ [585] GiantLP::balanceOf(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) [staticcall]\n    │   │   └─ ← 4000000000000000000\n    │   ├─ [128081] GiantLP::burn(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 4000000000000000000) \n    │   │   ├─ [126775] GiantMevAndFeesPool::beforeTokenTransfer(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 0x0000000000000000000000000000000000000000, 4000000000000000000) \n    │   │   │   ├─ [371] GiantLP::totalSupply() [staticcall]\n    │   │   │   │   └─ ← 4000000000000000000\n    │   │   │   ├─ emit ETHReceived(amount: 4000000000000000000)\n    │   │   │   ├─ [585] GiantLP::balanceOf(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) [staticcall]\n    │   │   │   │   └─ ← 4000000000000000000\n    │   │   │   ├─ [0] 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266::fallback{value: 4000000000000000000}() \n    │   │   │   │   └─ ← ()\n    │   │   │   ├─ emit ETHDistributed(user: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, recipient: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, amount: 4000000000000000000)\n    │   │   │   ├─ [2585] GiantLP::balanceOf(0x0000000000000000000000000000000000000000) [staticcall]\n    │   │   │   │   └─ ← 0\n    │   │   │   └─ ← \"Zero address\"\n    │   │   └─ ← \"Zero address\"\n    │   └─ ← \"Zero address\"\n    └─ ← \"Zero address\"\n```\n\n## Tools Used\nfoundry\n\n## Recommended Mitigation Steps\nskip update rewards for zero address.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/GiantLP.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\ncontract GiantLP is ERC20 {\n\n    /// @notice Address of giant pool that deployed the giant LP token\n    address public pool;\n\n    /// @notice Optional address of contract that will process transfers of giant LP\n    ITransferHookProcessor public transferHookProcessor;\n\n    /// @notice Last interacted timestamp for a given address\n    mapping(address => uint256) public lastInteractedTimestamp;\n\n    constructor(\n        address _pool,\n        address _transferHookProcessor,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        pool = _pool;\n        transferHookProcessor = ITransferHookProcessor(_transferHookProcessor);\n    }\n\n    function mint(address _recipient, uint256 _amount) external {\n        require(msg.sender == pool, \"Only pool\");\n        _mint(_recipient, _amount);\n    }\n\n    function burn(address _recipient, uint256 _amount) external {\n        require(msg.sender == pool, \"Only pool\");\n        _burn(_recipient, _amount);\n    }\n\n    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        lastInteractedTimestamp[_from] = block.timestamp;\n        lastInteractedTimestamp[_to] = block.timestamp;\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).afterTokenTransfer(_from, _to, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/liquid-staking/GiantMevAndFeesPool.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}"
    },
    {
      "filename": "contracts/liquid-staking/SyndicateRewardsProcessor.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/// @notice Allows a contract to receive rewards from a syndicate and distribute it amongst LP holders\nabstract contract SyndicateRewardsProcessor {\n\n    /// @notice Emitted when ETH is received by the contract and processed\n    event ETHReceived(uint256 amount);\n\n    /// @notice Emitted when ETH from syndicate is distributed to a user\n    event ETHDistributed(address indexed user, address indexed recipient, uint256 amount);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accumulated ETH per share of LP<>KNOT that has minted derivatives scaled to 'PRECISION'\n    uint256 public accumulatedETHPerLPShare;\n\n    /// @notice Total ETH claimed by all users of the contract\n    uint256 public totalClaimed;\n\n    /// @notice Last total rewards seen by the contract\n    uint256 public totalETHSeen;\n\n    /// @notice Total ETH claimed by a given address for a given token\n    mapping(address => mapping(address => uint256)) public claimed;\n\n    /// @dev Internal logic for previewing accumulated ETH for an LP user\n    function _previewAccumulatedETH(\n        address _sender,\n        address _token,\n        uint256 _balanceOfSender,\n        uint256 _numOfShares,\n        uint256 _unclaimedETHFromSyndicate\n    ) internal view returns (uint256) {\n        if (_balanceOfSender > 0) {\n            uint256 claim = claimed[_sender][_token];\n\n            uint256 received = totalRewardsReceived() + _unclaimedETHFromSyndicate;\n            uint256 unprocessed = received - totalETHSeen;\n\n            uint256 newAccumulatedETH = accumulatedETHPerLPShare + ((unprocessed * PRECISION) / _numOfShares);\n\n            return ((newAccumulatedETH * _balanceOfSender) / PRECISION) - claim;\n        }\n        return 0;\n    }\n\n    /// @dev Any due rewards from node running can be distributed to msg.sender if they have an LP balance\n    function _distributeETHRewardsToUserForToken(\n        address _user,\n        address _token,\n        uint256 _balance,\n        address _recipient\n    ) internal {\n        require(_recipient != address(0), \"Zero address\");\n        uint256 balance = _balance;\n        if (balance > 0) {\n            // Calculate how much ETH rewards the address is owed / due \n            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n            if (due > 0) {\n                claimed[_user][_token] = due;\n\n                totalClaimed += due;\n\n                (bool success, ) = _recipient.call{value: due}(\"\");\n                require(success, \"Failed to transfer\");\n\n                emit ETHDistributed(_user, _recipient, due);\n            }\n        }\n    }\n\n    /// @dev Internal logic for tracking accumulated ETH per share\n    function _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {\n        if (_numOfShares > 0) {\n            uint256 received = totalRewardsReceived();\n            uint256 unprocessed = received - totalETHSeen;\n\n            if (unprocessed > 0) {\n                emit ETHReceived(unprocessed);\n\n                // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later\n                accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;\n\n                totalETHSeen = received;\n            }\n        }\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate\n    function totalRewardsReceived() public virtual view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @notice Allow the contract to receive ETH\n    receive() external payable {}\n}"
    }
  ]
}