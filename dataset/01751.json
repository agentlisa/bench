{
  "Title": "Outdated Chainlink Interface",
  "Content": "In [line 201 of `ChainlinkOracle`](https://github.com/VenusProtocol/oracle/blob/78b1a411c42e5c103e688e4e76bc69c476206833/contracts/oracles/ChainlinkOracle.sol#L201), the interface `AggregatorV2V3Interface` is used, which inherits from both the `AggregatorInterface` and the `AggregatorV3Interface`. Chainlink recommends using the `AggregatorV3Interface`, as shown in [its documentation](https://docs.chain.link/data-feeds/api-reference). This prevents the usage of deprecated functions in the `AggregatorInterface`, which do not throw errors if no answer has been reached, but instead return 0. The dependence on this unexpected behavior increases the attack surface for the calling contract.\n\n\nConsider updating the interface used in the `ChainlinkOracle` from `AggregatorV2V3Interface` to `AggregatorV3Interface`.\n\n\n***Update:** Resolved in [pull request #84](https://github.com/VenusProtocol/oracle/pull/84) at commit [ddd4b02](https://github.com/VenusProtocol/oracle/pull/84/commits/ddd4b0222e40f1b6accf4f003face5206e947489).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracles/ChainlinkOracle.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"../interfaces/VBep20Interface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\n\nstruct TokenConfig {\n    /// @notice Underlying token address, which can't be a null address and can be used to check if a token is supported\n    /// @notice 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB for BNB\n    address asset;\n    /// @notice Chainlink feed address\n    address feed;\n    /// @notice Price expiration period of this asset\n    uint256 maxStalePeriod;\n}\n\ncontract ChainlinkOracle is AccessControlledV8, OracleInterface {\n    /// @notice vBNB address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vBnb;\n\n    /// @notice VAI address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vai;\n\n    /// @notice Set this as asset address for BNB. This is the underlying address for vBNB\n    address public constant BNB_ADDR = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n    /// @notice Manually set an override price, useful under extenuating conditions such as price feed failure\n    mapping(address => uint256) public prices;\n\n    /// @notice Token config by assets\n    mapping(address => TokenConfig) public tokenConfigs;\n\n    /// @notice Emit when a price is manually set\n    event PricePosted(\n        address indexed asset,\n        uint256 previousPriceMantissa,\n        uint256 requestedPriceMantissa,\n        uint256 newPriceMantissa\n    );\n\n    /// @notice Emit when a token config is added\n    event TokenConfigAdded(address indexed asset, address feed, uint256 maxStalePeriod);\n\n    modifier notNullAddress(address someone) {\n        if (someone == address(0)) revert(\"can't be zero address\");\n        _;\n    }\n\n    /// @notice Constructor for the implementation contract. Sets immutable variables.\n    /// @param vBnbAddress The address of the vBNB\n    /// @param vaiAddress The address of the VAI\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address vBnbAddress, address vaiAddress) notNullAddress(vBnbAddress) notNullAddress(vaiAddress) {\n        vBnb = vBnbAddress;\n        vai = vaiAddress;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Set the forced prices of the underlying token of input vToken\n     * @param vToken vToken address\n     * @param underlyingPriceMantissa price in 18 decimals\n     * @custom:access Only Governance\n     * @custom:error NotNullAddress thrown if address of vToken is null\n     * @custom:event Emits PricePosted event on succesfully setup of underlying price\n     */\n    function setUnderlyingPrice(\n        VBep20Interface vToken,\n        uint256 underlyingPriceMantissa\n    ) external notNullAddress(address(vToken)) {\n        _checkAccessAllowed(\"setUnderlyingPrice(address,uint256)\");\n\n        address asset = address(vToken) == vBnb ? BNB_ADDR : address(vToken.underlying());\n        uint256 previousPriceMantissa = prices[asset];\n        prices[asset] = underlyingPriceMantissa;\n        emit PricePosted(asset, previousPriceMantissa, prices[asset], prices[asset]);\n    }\n\n    /**\n     * @notice Manually set the price of a given asset\n     * @param asset Asset address\n     * @param price Underlying price in 18 decimals\n     * @custom:access Only Governance\n     * @custom:event Emits PricePosted event on succesfully setup of underlying price\n     */\n    function setDirectPrice(address asset, uint256 price) external notNullAddress(asset) {\n        _checkAccessAllowed(\"setDirectPrice(address,uint256)\");\n\n        uint256 previousPriceMantissa = prices[asset];\n        prices[asset] = price;\n        emit PricePosted(asset, previousPriceMantissa, price, price);\n    }\n\n    /**\n     * @notice Add multiple token configs at the same time\n     * @param tokenConfigs_ config array\n     * @custom:access Only Governance\n     * @custom:error Zero length error thrown, if length of the array in parameter is 0\n     */\n    function setTokenConfigs(TokenConfig[] memory tokenConfigs_) external {\n        if (tokenConfigs_.length == 0) revert(\"length can't be 0\");\n        uint256 numTokenConfigs = tokenConfigs_.length;\n        for (uint256 i; i < numTokenConfigs; ) {\n            setTokenConfig(tokenConfigs_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Initializes the owner of the contract\n     * @param accessControlManager_ Address of the access control manager contract\n     */\n    function initialize(address accessControlManager_) public initializer {\n        __AccessControlled_init(accessControlManager_);\n    }\n\n    /**\n     * @notice Add single token config. vToken & feed cannot be null addresses and maxStalePeriod must be positive\n     * @param tokenConfig Token config struct\n     * @custom:access Only Governance\n     * @custom:error NotNullAddress error is thrown if asset address is null\n     * @custom:error NotNullAddress error is thrown if token feed address is null\n     * @custom:error Range error is thrown if maxStale period of token is not greater than zero\n     * @custom:event Emits TokenConfigAdded event on succesfully setting of the token config\n     */\n    function setTokenConfig(\n        TokenConfig memory tokenConfig\n    ) public notNullAddress(tokenConfig.asset) notNullAddress(tokenConfig.feed) {\n        _checkAccessAllowed(\"setTokenConfig(TokenConfig)\");\n\n        if (tokenConfig.maxStalePeriod == 0) revert(\"stale period can't be zero\");\n        tokenConfigs[tokenConfig.asset] = tokenConfig;\n        emit TokenConfigAdded(tokenConfig.asset, tokenConfig.feed, tokenConfig.maxStalePeriod);\n    }\n\n    /**\n     * @notice Gets the Chainlink price for the underlying asset of a given vToken, revert when vToken is a null address\n     * @param vToken vToken address\n     * @return price Underlying price in USD\n     */\n    function getUnderlyingPrice(address vToken) public view override returns (uint256) {\n        return _getUnderlyingPriceInternal(VBep20Interface(vToken));\n    }\n\n    /**\n     * @notice Gets the Chainlink price for the underlying asset of a given vToken\n     * or the manually set price if it's been set\n     * @dev The decimals of the underlying token are considered to ensure the returned price\n     * has 18 decimals of precision\n     * @param vToken vToken address\n     * @return price Underlying price in USD\n     */\n    function _getUnderlyingPriceInternal(VBep20Interface vToken) internal view returns (uint256 price) {\n        address token;\n        uint256 decimals;\n\n        // vBNB token doesn't have `underlying` method\n        if (address(vToken) == vBnb) {\n            token = BNB_ADDR;\n            decimals = 18;\n        } else if (address(vToken) == vai) {\n            token = vai;\n            decimals = 18;\n        } else {\n            token = vToken.underlying();\n            decimals = VBep20Interface(token).decimals();\n        }\n\n        uint256 tokenPrice = prices[token];\n        if (tokenPrice != 0) {\n            price = tokenPrice;\n        } else {\n            price = _getChainlinkPrice(token);\n        }\n\n        uint256 decimalDelta = uint256(18) - uint256(decimals);\n        return price * (10 ** decimalDelta);\n    }\n\n    /**\n     * @notice Get the Chainlink price for the underlying asset of a given vToken, revert if token config doesn't exist\n     * @dev The precision of the price feed is used to ensure the returned price has 18 decimals of precision\n     * @param asset Underlying asset address\n     * @return price Underlying price in USD, with 18 decimals of precision\n     * @custom:error NotNullAddress error is thrown if the asset address is null\n     * @custom:error Price error is thrown if the Chainlink price of asset is not greater than zero\n     * @custom:error Timing error is thrown if current timestamp is less than the last updatedAt timestamp\n     * @custom:error Timing error is thrown if time difference between current time and last updated time\n     * is greater than maxStalePeriod\n     */\n    function _getChainlinkPrice(\n        address asset\n    ) internal view notNullAddress(tokenConfigs[asset].asset) returns (uint256) {\n        TokenConfig memory tokenConfig = tokenConfigs[asset];\n        AggregatorV2V3Interface feed = AggregatorV2V3Interface(tokenConfig.feed);\n\n        // note: maxStalePeriod cannot be 0\n        uint256 maxStalePeriod = tokenConfig.maxStalePeriod;\n\n        // Chainlink USD-denominated feeds store answers at 8 decimals, mostly\n        uint256 decimalDelta = uint256(18) - feed.decimals();\n\n        (, int256 answer, , uint256 updatedAt, ) = feed.latestRoundData();\n        if (answer <= 0) revert(\"chainlink price must be positive\");\n        if (block.timestamp < updatedAt) revert(\"updatedAt exceeds block time\");\n\n        uint256 deltaTime;\n        unchecked {\n            deltaTime = block.timestamp - updatedAt;\n        }\n\n        if (deltaTime > maxStalePeriod) revert(\"chainlink price expired\");\n\n        return uint256(answer) * (10 ** decimalDelta);\n    }\n}"
    }
  ]
}