{
  "Title": "[M-04] `estimatedAPR()` might return the wrong APR",
  "Content": "\n`estimatedAPR()` might return the wrong APR and it will make users confused.\n\n### Proof of Concept\n\n`SavingsVest.estimatedAPR()` returns the APR using the current `vestingProfit` and `vestingPeriod`.\n\n```solidity\n    function estimatedAPR() external view returns (uint256 apr) {\n        uint256 currentlyVestingProfit = vestingProfit;\n        uint256 weightedAssets = vestingPeriod * totalAssets();\n        if (currentlyVestingProfit != 0 && weightedAssets != 0)\n            apr = (currentlyVestingProfit * 3600 * 24 * 365 * BASE_18) / weightedAssets;\n    }\n```\n\nFirst of all, it uses the current `vestingRatio = vestingProfit / vestingPeriod` for 1 year even if `vestingPeriod < 1 year`. I think it might be an intended behavior to estimate the APR with the current vesting ratio.\n\nBut it's wrong to use the same vesting ratio after the vesting period is finished already.\n\nIn [accrue()](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L110), it updates the `vestingProfit` and `lastUpdate` only when it's overcollateralized/undercollateralized more than 0.1%.\n\nSo `lastUpdate` wouldn't be changed for a certain time while [collatRatio](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L110) is in range (99.9%, 100.1%).\n\n1.  At the first time, `vestingProfit = 100, vestingPeriod = 10 days` and `estimatedAPR()` returns the correct value.\n2.  After 10 days, all vestings are unlocked and there is no locked profit. But `accrue()` has never been called due to the stable collateral ratio.\n3.  In `estimatedAPR()`, `vestingProfit` will be 100 and it will return the same APR as 10 days before.\n4.  But the APR should be 0 as there is no locked profit now.\n\n### Recommended Mitigation Steps\n\n`estimatedAPR()` should return 0 when `lockedProfit() == 0`.\n\n```solidity\n    function estimatedAPR() external view returns (uint256 apr) {\n        if (lockedProfit() == 0) return 0; //check locked profit first\n\n        uint256 currentlyVestingProfit = vestingProfit;\n        uint256 weightedAssets = vestingPeriod * totalAssets();\n        if (currentlyVestingProfit != 0 && weightedAssets != 0)\n            apr = (currentlyVestingProfit * 3600 * 24 * 365 * BASE_18) / weightedAssets;\n    }\n```\n\n**[Picodes (Angle) confirmed and commented](https://github.com/code-423n4/2023-06-angle-findings/issues/28#issuecomment-1628642869):**\n > Valid, although this function isn't really useful as what matters in the end is how much a call to `accrue` would give. `estimatedAPR` should return an approximation of the current APR but is an approximation on the long run\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-06-angle-findings/issues/28#issuecomment-1628803223):**\n > @Picodes - It looks like a middle of Medium and Low as it's a view function. Will keep as Medium because it will be used to estimate the profit rate for users.\n\n**[Angle mitigated](https://github.com/code-423n4/2023-07-angle-mitigation/blob/main/README.md#mitigations-to-be-reviewed):**\n> PR: https://github.com/AngleProtocol/angle-transmuter/commit/337c65d005bbd8ed6dfa76929d2cae475066756a<br>\n> Applies the suggested fix.\n\n**Status:** Mitigation confirmed. Full details in reports from [auditor0517](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/28) and [Jeiwan](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/19).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/savings/SavingsVest.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { ITransmuter } from \"interfaces/ITransmuter.sol\";\n\nimport \"./BaseSavings.sol\";\n\n/// @title SavingsVest\n/// @author Angle Labs, Inc.\n/// @notice In this implementation, yield is distributed to stablecoin holders whenever the Transmuter starts to\n/// get over-collateralized\n/// @dev This implementation is typically applicable to an ETH stablecoin backed by liquid staking tokens and\n/// where the yield of the LST is distributed to stablecoin holders\ncontract SavingsVest is BaseSavings {\n    using SafeERC20 for IERC20;\n    using MathUpgradeable for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                PARAMETERS / REFERENCES                                             \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Address handling protocol surplus\n    address public surplusManager;\n\n    /// @notice Amount of profit that needs to be vested\n    uint256 public vestingProfit;\n\n    /// @notice Reference to the Transmuter contract\n    ITransmuter public transmuter;\n\n    /// @notice Last time rewards were accrued\n    uint64 public lastUpdate;\n\n    /// @notice Share of the surplus going to the protocol\n    uint64 public protocolSafetyFee;\n\n    /// @notice The period in seconds over which locked profit is unlocked\n    /// @dev Cannot be 0 as it opens the system to sandwich attacks\n    uint32 public vestingPeriod;\n\n    /// @notice Minimum time between two calls to the `accrue` function\n    uint32 public updateDelay;\n\n    /// @notice Whether the contract is paused or not\n    uint8 public paused;\n\n    uint256[46] private __gap;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        EVENTS                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    event FiledUint64(uint64 param, bytes32 what);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    INITIALIZATION                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Initializes the contract\n    /// @param _accessControlManager Reference to the `AccessControlManager` contract\n    /// @param name_ Name of the savings contract\n    /// @param symbol_ Symbol of the savings contract\n    /// @param divizer Quantifies the first initial deposit (should be typically 1 for tokens like agEUR)\n    /// @dev A first deposit is done at initialization to protect for the classical issue of ERC4626 contracts\n    /// where the the first user of the contract tries to steal everyone else's tokens\n    function initialize(\n        IAccessControlManager _accessControlManager,\n        IERC20MetadataUpgradeable asset_,\n        ITransmuter _transmuter,\n        string memory name_,\n        string memory symbol_,\n        uint256 divizer\n    ) public initializer {\n        if (address(_accessControlManager) == address(0) || address(_transmuter) == address(0)) revert ZeroAddress();\n        __ERC4626_init(asset_);\n        __ERC20_init(name_, symbol_);\n        transmuter = _transmuter;\n        accessControlManager = _accessControlManager;\n        uint8 numDecimals = asset_.decimals();\n        _deposit(msg.sender, address(this), 10 ** numDecimals / divizer, BASE_18 / divizer);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                       MODIFIER                                                     \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ERC20Upgradeable\n    function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // Lets transfer freely even when paused but no mint or burn\n        if ((from == address(0) || to == address(0)) && paused > 0) revert Paused();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    CONTRACT LOGIC                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Accrues interest to this contract by minting agTokens if the protocol is over-collateralized\n    /// or burning some if it is not collateralized\n    function accrue() external returns (uint256 minted) {\n        if (block.timestamp - lastUpdate < updateDelay && !accessControlManager.isGovernorOrGuardian(msg.sender))\n            revert NotAllowed();\n        ITransmuter _transmuter = transmuter;\n        IAgToken _agToken = IAgToken(asset());\n        (uint64 collatRatio, uint256 stablecoinsIssued) = _transmuter.getCollateralRatio();\n        // It needs to deviate significantly (>0.1%) from the target in order to accrue\n        if (collatRatio > BASE_9 + BASE_6) {\n            // The surplus of profit minus a fee is distributed through this contract\n            minted = (collatRatio * stablecoinsIssued) / BASE_9 - stablecoinsIssued;\n            // Updating normalizer in order not to double count profits\n            _transmuter.updateNormalizer(minted, true);\n            uint256 surplusForProtocol = (minted * protocolSafetyFee) / BASE_9;\n            address _surplusManager = surplusManager;\n            _surplusManager = _surplusManager == address(0) ? address(_transmuter) : _surplusManager;\n            _agToken.mint(_surplusManager, surplusForProtocol);\n            uint256 surplus = minted - surplusForProtocol;\n            if (surplus != 0) {\n                // Adding new profits relaunches to zero the vesting period for the profits that were\n                // previously being vested\n                vestingProfit = (lockedProfit() + surplus);\n                lastUpdate = uint64(block.timestamp);\n                _agToken.mint(address(this), surplus);\n            }\n        } else if (collatRatio < BASE_9 - BASE_6) {\n            // If the protocol is under-collateralized, slashing the profits that are still being vested\n            uint256 missing = stablecoinsIssued - (collatRatio * stablecoinsIssued) / BASE_9;\n            uint256 currentLockedProfit = lockedProfit();\n            if (missing > currentLockedProfit) {\n                vestingProfit = 0;\n                missing = currentLockedProfit;\n            } else {\n                vestingProfit = currentLockedProfit - missing;\n                lastUpdate = uint64(block.timestamp);\n            }\n            if (missing > 0) {\n                _agToken.burnSelf(missing, address(this));\n                _transmuter.updateNormalizer(missing, false);\n            }\n        }\n    }\n\n    /// @notice Amount of profit that are still vesting\n    function lockedProfit() public view virtual returns (uint256) {\n        // Get the last update and vesting delay.\n        uint256 _lastUpdate = lastUpdate;\n        uint256 _vestingPeriod = vestingPeriod;\n\n        unchecked {\n            // If the vesting period has passed, there is no locked profit.\n            // This cannot overflow on human timescales\n            if (block.timestamp >= _lastUpdate + _vestingPeriod) return 0;\n\n            // Get the maximum amount we could return.\n            uint256 currentlyVestingProfit = vestingProfit;\n\n            // Compute how much profit remains locked based on the last time a profit was acknowledged\n            // and the vesting period. It's impossible for an update to be in the future, so this will never underflow.\n            return currentlyVestingProfit - (currentlyVestingProfit * (block.timestamp - _lastUpdate)) / _vestingPeriod;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                ERC4626 VIEW FUNCTIONS                                              \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ERC4626Upgradeable\n    function totalAssets() public view override returns (uint256) {\n        return super.totalAssets() - lockedProfit();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        HELPER                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Provides an estimated Annual Percentage Rate for base depositors on this contract\n    function estimatedAPR() external view returns (uint256 apr) {\n        uint256 currentlyVestingProfit = vestingProfit;\n        uint256 weightedAssets = vestingPeriod * totalAssets();\n        if (currentlyVestingProfit != 0 && weightedAssets != 0)\n            apr = (currentlyVestingProfit * 3600 * 24 * 365 * BASE_18) / weightedAssets;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                      GOVERNANCE                                                    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the `surplusManager` address which handles protocol fees\n    function setSurplusManager(address _surplusManager) external onlyGuardian {\n        surplusManager = _surplusManager;\n    }\n\n    /// @notice Changes the contract parameters\n    function setParams(bytes32 what, uint64 param) external onlyGuardian {\n        if (param > BASE_9) revert InvalidParam();\n        else if (what == \"PF\") protocolSafetyFee = param;\n        else if (what == \"VP\") vestingPeriod = uint32(param);\n        else if (what == \"UD\") updateDelay = uint32(param);\n        else if (what == \"P\") paused = uint8(param);\n        else revert InvalidParam();\n        emit FiledUint64(param, what);\n    }\n}"
    },
    {
      "filename": "contracts/savings/SavingsVest.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { ITransmuter } from \"interfaces/ITransmuter.sol\";\n\nimport \"./BaseSavings.sol\";\n\n/// @title SavingsVest\n/// @author Angle Labs, Inc.\n/// @notice In this implementation, yield is distributed to stablecoin holders whenever the Transmuter starts to\n/// get over-collateralized\n/// @dev This implementation is typically applicable to an ETH stablecoin backed by liquid staking tokens and\n/// where the yield of the LST is distributed to stablecoin holders\ncontract SavingsVest is BaseSavings {\n    using SafeERC20 for IERC20;\n    using MathUpgradeable for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                PARAMETERS / REFERENCES                                             \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Address handling protocol surplus\n    address public surplusManager;\n\n    /// @notice Amount of profit that needs to be vested\n    uint256 public vestingProfit;\n\n    /// @notice Reference to the Transmuter contract\n    ITransmuter public transmuter;\n\n    /// @notice Last time rewards were accrued\n    uint64 public lastUpdate;\n\n    /// @notice Share of the surplus going to the protocol\n    uint64 public protocolSafetyFee;\n\n    /// @notice The period in seconds over which locked profit is unlocked\n    /// @dev Cannot be 0 as it opens the system to sandwich attacks\n    uint32 public vestingPeriod;\n\n    /// @notice Minimum time between two calls to the `accrue` function\n    uint32 public updateDelay;\n\n    /// @notice Whether the contract is paused or not\n    uint8 public paused;\n\n    uint256[46] private __gap;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        EVENTS                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    event FiledUint64(uint64 param, bytes32 what);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    INITIALIZATION                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Initializes the contract\n    /// @param _accessControlManager Reference to the `AccessControlManager` contract\n    /// @param name_ Name of the savings contract\n    /// @param symbol_ Symbol of the savings contract\n    /// @param divizer Quantifies the first initial deposit (should be typically 1 for tokens like agEUR)\n    /// @dev A first deposit is done at initialization to protect for the classical issue of ERC4626 contracts\n    /// where the the first user of the contract tries to steal everyone else's tokens\n    function initialize(\n        IAccessControlManager _accessControlManager,\n        IERC20MetadataUpgradeable asset_,\n        ITransmuter _transmuter,\n        string memory name_,\n        string memory symbol_,\n        uint256 divizer\n    ) public initializer {\n        if (address(_accessControlManager) == address(0) || address(_transmuter) == address(0)) revert ZeroAddress();\n        __ERC4626_init(asset_);\n        __ERC20_init(name_, symbol_);\n        transmuter = _transmuter;\n        accessControlManager = _accessControlManager;\n        uint8 numDecimals = asset_.decimals();\n        _deposit(msg.sender, address(this), 10 ** numDecimals / divizer, BASE_18 / divizer);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                       MODIFIER                                                     \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ERC20Upgradeable\n    function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // Lets transfer freely even when paused but no mint or burn\n        if ((from == address(0) || to == address(0)) && paused > 0) revert Paused();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    CONTRACT LOGIC                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Accrues interest to this contract by minting agTokens if the protocol is over-collateralized\n    /// or burning some if it is not collateralized\n    function accrue() external returns (uint256 minted) {\n        if (block.timestamp - lastUpdate < updateDelay && !accessControlManager.isGovernorOrGuardian(msg.sender))\n            revert NotAllowed();\n        ITransmuter _transmuter = transmuter;\n        IAgToken _agToken = IAgToken(asset());\n        (uint64 collatRatio, uint256 stablecoinsIssued) = _transmuter.getCollateralRatio();\n        // It needs to deviate significantly (>0.1%) from the target in order to accrue\n        if (collatRatio > BASE_9 + BASE_6) {\n            // The surplus of profit minus a fee is distributed through this contract\n            minted = (collatRatio * stablecoinsIssued) / BASE_9 - stablecoinsIssued;\n            // Updating normalizer in order not to double count profits\n            _transmuter.updateNormalizer(minted, true);\n            uint256 surplusForProtocol = (minted * protocolSafetyFee) / BASE_9;\n            address _surplusManager = surplusManager;\n            _surplusManager = _surplusManager == address(0) ? address(_transmuter) : _surplusManager;\n            _agToken.mint(_surplusManager, surplusForProtocol);\n            uint256 surplus = minted - surplusForProtocol;\n            if (surplus != 0) {\n                // Adding new profits relaunches to zero the vesting period for the profits that were\n                // previously being vested\n                vestingProfit = (lockedProfit() + surplus);\n                lastUpdate = uint64(block.timestamp);\n                _agToken.mint(address(this), surplus);\n            }\n        } else if (collatRatio < BASE_9 - BASE_6) {\n            // If the protocol is under-collateralized, slashing the profits that are still being vested\n            uint256 missing = stablecoinsIssued - (collatRatio * stablecoinsIssued) / BASE_9;\n            uint256 currentLockedProfit = lockedProfit();\n            if (missing > currentLockedProfit) {\n                vestingProfit = 0;\n                missing = currentLockedProfit;\n            } else {\n                vestingProfit = currentLockedProfit - missing;\n                lastUpdate = uint64(block.timestamp);\n            }\n            if (missing > 0) {\n                _agToken.burnSelf(missing, address(this));\n                _transmuter.updateNormalizer(missing, false);\n            }\n        }\n    }\n\n    /// @notice Amount of profit that are still vesting\n    function lockedProfit() public view virtual returns (uint256) {\n        // Get the last update and vesting delay.\n        uint256 _lastUpdate = lastUpdate;\n        uint256 _vestingPeriod = vestingPeriod;\n\n        unchecked {\n            // If the vesting period has passed, there is no locked profit.\n            // This cannot overflow on human timescales\n            if (block.timestamp >= _lastUpdate + _vestingPeriod) return 0;\n\n            // Get the maximum amount we could return.\n            uint256 currentlyVestingProfit = vestingProfit;\n\n            // Compute how much profit remains locked based on the last time a profit was acknowledged\n            // and the vesting period. It's impossible for an update to be in the future, so this will never underflow.\n            return currentlyVestingProfit - (currentlyVestingProfit * (block.timestamp - _lastUpdate)) / _vestingPeriod;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                ERC4626 VIEW FUNCTIONS                                              \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ERC4626Upgradeable\n    function totalAssets() public view override returns (uint256) {\n        return super.totalAssets() - lockedProfit();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        HELPER                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Provides an estimated Annual Percentage Rate for base depositors on this contract\n    function estimatedAPR() external view returns (uint256 apr) {\n        uint256 currentlyVestingProfit = vestingProfit;\n        uint256 weightedAssets = vestingPeriod * totalAssets();\n        if (currentlyVestingProfit != 0 && weightedAssets != 0)\n            apr = (currentlyVestingProfit * 3600 * 24 * 365 * BASE_18) / weightedAssets;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                      GOVERNANCE                                                    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the `surplusManager` address which handles protocol fees\n    function setSurplusManager(address _surplusManager) external onlyGuardian {\n        surplusManager = _surplusManager;\n    }\n\n    /// @notice Changes the contract parameters\n    function setParams(bytes32 what, uint64 param) external onlyGuardian {\n        if (param > BASE_9) revert InvalidParam();\n        else if (what == \"PF\") protocolSafetyFee = param;\n        else if (what == \"VP\") vestingPeriod = uint32(param);\n        else if (what == \"UD\") updateDelay = uint32(param);\n        else if (what == \"P\") paused = uint8(param);\n        else revert InvalidParam();\n        emit FiledUint64(param, what);\n    }\n}"
    },
    {
      "filename": "README.md",
      "content": "# Angle Protocol - Mitigation Review details\n\n- Total Prize Pool: $14,000 USDC\n- [Warden guidelines for C4 mitigation reviews](https://code4rena.notion.site/Guidelines-for-C4-mitigation-reviews-ed10fc5cfbf640bd8dcec66f38b343c4)\n- Submit findings [using the C4 form](https://code4rena.com/contests/2023-07-angle-protocol-mitigation-review/submit)\n- Starts July 17, 2023 20:00 UTC\n- Ends July 21, 2023 20:00 UTC \n\n## Important note\n\nEach warden must submit a mitigation review for:\n\n- Every High and Medium finding listed as in-scope below, and\n- one report each for the Gas and QA fixes.\n\nFor the Gas and QA mitigation reports:\n- Submit any new High or Medium issues introduced by the QA and GAS fixes as a newly-introduced High and Medium risk issue.\n\n**Incomplete mitigation reviews will not be eligible for awards.**\n\n## Findings being mitigated\n\nMitigations of all High and Medium issues will be considered in-scope and listed here.\n\n- [H-01: Possible reentrancy during redemption/swap](https://github.com/code-423n4/2023-06-angle-findings/issues/24)\n- [H-02: The first disputer might lose funds although his dispute is valid.](https://github.com/code-423n4/2023-06-angle-findings/issues/23)\n- [H-03: Poor detection of disputed trees allows claiming tokens from a disputed tre](https://github.com/code-423n4/2023-06-angle-findings/issues/10)\n- [M-01: LibHelpers.piecewiseLinear will revert when the value is less than the first element of the array](https://github.com/code-423n4/2023-06-angle-findings/issues/40)\n- [M-02: Unsafe cast in getCollateralRatio()](https://github.com/code-423n4/2023-06-angle-findings/issues/31)\n- [M-03: Read-only reentrancy is possible](https://github.com/code-423n4/2023-06-angle-findings/issues/30)\n- [M-04: estimatedAPR() might return the wrong APR.](https://github.com/code-423n4/2023-06-angle-findings/issues/28)\n- [M-06: Interest is not accrued before parameters are updated in SavingsVest](https://github.com/code-423n4/2023-06-angle-findings/issues/13)\n- [M-07: User may get less tokens than expected when collateral list order changes](https://github.com/code-423n4/2023-06-angle-findings/issues/8)\n\n## Overview of changes\n\nChanges related to High and Medium issues on Merkl can be found [here](https://github.com/AngleProtocol/merkl-contracts/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-mitigation).\nChanges that we intend to make on Merkl prior to final deployment, so including QA and GAS can be found [here](https://github.com/AngleProtocol/merkl-contracts/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-full-mitigation). Updated tests and scripts are on the `main` branch.\n\nChanges related to High and Medium issues on Transmuter can be found [here](https://github.com/AngleProtocol/angle-transmuter/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-mitigation).\nChanges that we intend to make on Transmuter prior to final deployment, so including QA and GAS can be found can be found [here](https://github.com/AngleProtocol/angle-transmuter/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-full-mitigation). Updated tests and scripts are on the `main` branch.\n\n## Mitigations to be reviewed\n\n### Individual PRs\n\n| URL                                                                                               | Mitigation of | Purpose                                             |\n| ------------------------------------------------------------------------------------------------- | ------------- | --------------------------------------------------- |\n| https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671 | H-01          | Adds a reentrancy guard to several functions        |\n| https://github.com/AngleProtocol/merkl-contracts/commit/7402ee6b84789391479c5876b27be23fd579f7b2  | H-02          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/merkl-contracts/commit/82d8c0ff37b4a9ad8277cac4aef85f3ca0ad5c7c  | H-03          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/angle-transmuter/commit/5f7635cdab52b75416309d45f8cd253609c705ff | M-01          | Add an handler for this edge case                   |\n| https://github.com/AngleProtocol/angle-transmuter/commit/6f2ffcb1e89e3bba05c9aa2133ef94347aa42c28 | M-02          | Adds safeCast                                       |\n| https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671 | M-03          | Adds a reentrancy guard to several functions        |\n| https://github.com/AngleProtocol/angle-transmuter/commit/337c65d005bbd8ed6dfa76929d2cae475066756a | M-04          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/angle-transmuter/commit/94c4e51ae3400a63532e85f04f4081152adc97db | M-06          | Calls `accrues` before updating sensible parameters |\n| https://github.com/AngleProtocol/angle-transmuter/commit/f8d0bf7c4009586f7022d5929359041db3990175 | M-07          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/merkl-contracts/commit/3c2fe3a956cdd29b632e8d7a20e1fc2ce5e8ac37  | QA & GAS      |                                                     |\n| https://github.com/AngleProtocol/angle-transmuter/commit/66bba3f5dba4ab6307c997e350dfadb13d2a2119 | QA & GAS      |                                                     |\n\n## Out of Scope\n\n- [M-05: uint128 changeAmount might overflow](https://github.com/code-423n4/2023-06-angle-findings/issues/16): we consider that there is no risk here as swaps will be reverting, and that the chances that this happen are infinitesimals"
    }
  ]
}