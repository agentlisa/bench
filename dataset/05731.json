{
  "Title": "[G-05] Unnecessary variable in `AllowList.sol`",
  "Content": "\n**Function `_setPermissionToCall`:**\n\nVariable `currentPermission` is used only once, which means it doesn't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/common/AllowList.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/AllowList.sol#L117-L119)\n\n```\n bool currentPermission = hasSpecialAccessToCall[_caller][_target][_functionSig];\n\n        if (currentPermission != _enable) {\n```\n\nTo:\n\n```\n        if (hasSpecialAccessToCall[_caller][_target][_functionSig] != _enable) {\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/common/AllowList.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport \"./interfaces/IAllowList.sol\";\nimport \"./libraries/UncheckedMath.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The smart contract that stores the permissions to call the function on different contracts.\n/// @dev The contract is fully controlled by the owner, that can grant and revoke any permissions at any time.\n/// @dev The permission list has three different modes:\n/// - Closed. The contract cannot be called by anyone.\n/// - SpecialAccessOnly. Only some contract functions can be called by specifically granted addresses.\n/// - Public. Access list to call any function from the target contract by any caller\ncontract AllowList is IAllowList, Ownable2Step {\n    using UncheckedMath for uint256;\n\n    /// @notice The Access mode by which it is decided whether the caller has access\n    mapping(address => AccessMode) public getAccessMode;\n\n    /// @notice The mapping that stores permissions to call the function on the target address by the caller\n    /// @dev caller => target => function signature => permission to call target function for the given caller address\n    mapping(address => mapping(address => mapping(bytes4 => bool))) public hasSpecialAccessToCall;\n\n    /// @dev The mapping L1 token address => struct Deposit\n    mapping(address => Deposit) public tokenDeposit;\n\n    constructor(address _initialOwner) {\n        _transferOwnership(_initialOwner);\n    }\n\n    /// @return Whether the caller can call the specific function on the target contract\n    /// @param _caller The caller address, who is granted access\n    /// @param _target The address of the smart contract which is called\n    /// @param _functionSig The function signature (selector), access to which need to check\n    function canCall(address _caller, address _target, bytes4 _functionSig) external view returns (bool) {\n        AccessMode accessMode = getAccessMode[_target];\n        return\n            accessMode == AccessMode.Public ||\n            (accessMode == AccessMode.SpecialAccessOnly && hasSpecialAccessToCall[_caller][_target][_functionSig]);\n    }\n\n    /// @notice Set the permission mode to call the target contract\n    /// @param _target The address of the smart contract, of which access to the call is to be changed\n    /// @param _accessMode Whether no one, any or only some addresses can call the target contract\n    function setAccessMode(address _target, AccessMode _accessMode) external onlyOwner {\n        _setAccessMode(_target, _accessMode);\n    }\n\n    /// @notice Set many permission modes to call the target contracts\n    /// @dev Analogous to function `setAccessMode` but performs a batch of changes\n    /// @param _targets The array of smart contract addresses, of which access to the call is to be changed\n    /// @param _accessModes The array of new permission modes, whether no one, any or only some addresses can call the\n    /// target contract\n    function setBatchAccessMode(address[] calldata _targets, AccessMode[] calldata _accessModes) external onlyOwner {\n        uint256 targetsLength = _targets.length;\n        require(targetsLength == _accessModes.length, \"yg\"); // The size of arrays should be equal\n\n        for (uint256 i = 0; i < targetsLength; i = i.uncheckedInc()) {\n            _setAccessMode(_targets[i], _accessModes[i]);\n        }\n    }\n\n    /// @dev Changes access mode and emit the event if the access was changed\n    function _setAccessMode(address _target, AccessMode _accessMode) internal {\n        AccessMode accessMode = getAccessMode[_target];\n\n        if (accessMode != _accessMode) {\n            getAccessMode[_target] = _accessMode;\n            emit UpdateAccessMode(_target, accessMode, _accessMode);\n        }\n    }\n\n    /// @notice Set many permissions to call the function on the contract to the specified caller address\n    /// @param _callers The array of caller addresses, who are granted access\n    /// @param _targets The array of smart contract addresses, of which access to the call are to be changed\n    /// @param _functionSigs The array of function signatures (selectors), access to which need to be changed\n    /// @param _enables The array of boolean flags, whether enable or disable the function access to the corresponding\n    /// target address\n    function setBatchPermissionToCall(\n        address[] calldata _callers,\n        address[] calldata _targets,\n        bytes4[] calldata _functionSigs,\n        bool[] calldata _enables\n    ) external onlyOwner {\n        uint256 callersLength = _callers.length;\n\n        // The size of arrays should be equal\n        require(callersLength == _targets.length, \"yw\");\n        require(callersLength == _functionSigs.length, \"yx\");\n        require(callersLength == _enables.length, \"yy\");\n\n        for (uint256 i = 0; i < callersLength; i = i.uncheckedInc()) {\n            _setPermissionToCall(_callers[i], _targets[i], _functionSigs[i], _enables[i]);\n        }\n    }\n\n    /// @notice Set the permission to call the function on the contract to the specified caller address\n    /// @param _caller The caller address, who is granted access\n    /// @param _target The address of the smart contract, of which access to the call is to be changed\n    /// @param _functionSig The function signature (selector), access to which need to be changed\n    /// @param _enable Whether enable or disable the permission\n    function setPermissionToCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig,\n        bool _enable\n    ) external onlyOwner {\n        _setPermissionToCall(_caller, _target, _functionSig, _enable);\n    }\n\n    /// @dev Changes permission to call and emits the event if the permission was changed\n    function _setPermissionToCall(address _caller, address _target, bytes4 _functionSig, bool _enable) internal {\n        bool currentPermission = hasSpecialAccessToCall[_caller][_target][_functionSig];\n\n        if (currentPermission != _enable) {\n            hasSpecialAccessToCall[_caller][_target][_functionSig] = _enable;\n            emit UpdateCallPermission(_caller, _target, _functionSig, _enable);\n        }\n    }\n\n    /// @dev Set deposit limit data for a token\n    /// @param _l1Token The address of L1 token\n    /// @param _depositLimitation deposit limitation is active or not\n    /// @param _depositCap The maximum amount that can be deposited.\n    function setDepositLimit(address _l1Token, bool _depositLimitation, uint256 _depositCap) external onlyOwner {\n        tokenDeposit[_l1Token].depositLimitation = _depositLimitation;\n        tokenDeposit[_l1Token].depositCap = _depositCap;\n    }\n\n    /// @dev Get deposit limit data of a token\n    /// @param _l1Token The address of L1 token\n    function getTokenDepositLimitData(address _l1Token) external view returns (Deposit memory) {\n        return tokenDeposit[_l1Token];\n    }\n}"
    }
  ]
}