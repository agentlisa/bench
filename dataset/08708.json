{
  "Title": "[G-03] Multiple accesses of a mapping/array should use a local variable cache",
  "Content": "\nThe instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local **storage** variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), **saves ~42 gas** per access due to not having to recalculate the key's keccak256 hash (**Gkeccak256 - 30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory.\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/operators/Yearn/YearnVaultStorage.sol   #1\n\n/// @audit vaults[vault] on line 33\n34:           require(vaults[vault].lpToken == address(0), \"YVS: VAULT_ALREADY_HAS_LP\");\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L34\n\n```solidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #2\n\n/// @audit operators[i] on line 68\n69:               operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector);\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L69\n\n```solidity\nFile: contracts/OperatorResolver.sol   #3\n\n/// @audit operators[<etc>] on line 42\n43:                   operators[names[i]].selector != destinations[i].selector\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L43\n\n```solidity\nFile: contracts/OperatorResolver.sol   #4\n\n/// @audit destinations[i] on line 42\n43:                   operators[names[i]].selector != destinations[i].selector\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L43\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-06-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/operators/Yearn/YearnVaultStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nstruct CurvePool {\n    address poolAddress;\n    uint96 poolCoinAmount;\n    address lpToken;\n}\n\n/// @title YearnVaultStorage storage contract\ncontract YearnVaultStorage is Ownable {\n    /// @dev Emitted when a vault is added\n    /// @param vault The vault address\n    /// @param pool The underlying CurvePool\n    event VaultAdded(address vault, CurvePool pool);\n\n    /// @dev Emitted when a vault is removed\n    /// @param vault The removed vault address\n    event VaultRemoved(address vault);\n\n    /// @dev Map of vault address with underlying CurvePool\n    mapping(address => CurvePool) public vaults;\n\n    /// @notice Add a Yearn Curve vault\n    /// @param vault The vault address\n    /// @param curvePool The underlying CurvePool (used to add liquidity)\n    function addVault(address vault, CurvePool calldata curvePool) external onlyOwner {\n        require(vault != address(0), \"YVS: INVALID_VAULT_ADDRESS\");\n        require(curvePool.poolAddress != address(0), \"YVS: INVALID_POOL_ADDRESS\");\n        require(curvePool.lpToken != address(0), \"YVS: INVALID_TOKEN_ADDRESS\");\n        require(vaults[vault].poolAddress == address(0), \"YVS: VAULT_ALREADY_HAS_POOL\");\n        require(vaults[vault].lpToken == address(0), \"YVS: VAULT_ALREADY_HAS_LP\");\n        vaults[vault] = curvePool;\n        emit VaultAdded(vault, curvePool);\n    }\n\n    /// @notice Remove a Yearn vault\n    /// @param vault The vault address to remove\n    function removeVault(address vault) external onlyOwner {\n        require(vaults[vault].poolAddress != address(0), \"YVS: NON_EXISTENT_VAULT\");\n        delete vaults[vault];\n        emit VaultRemoved(vault);\n    }\n}"
    },
    {
      "filename": "contracts/governance/scripts/OperatorScripts.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../../interfaces/INestedFactory.sol\";\nimport \"../../interfaces/IOperatorResolver.sol\";\nimport \"../../abstracts/MixinOperatorResolver.sol\";\nimport \"../../interfaces/external/ITransparentUpgradeableProxy.sol\";\n\ncontract OperatorScripts {\n    struct tupleOperator {\n        bytes32 name;\n        bytes4 selector;\n    }\n\n    address public immutable nestedFactory;\n    address public immutable resolver;\n\n    constructor(address _nestedFactory, address _resolver) {\n        require(_nestedFactory != address(0), \"AO-SCRIPT: INVALID_FACTORY_ADDR\");\n        require(_resolver != address(0), \"AO-SCRIPT: INVALID_RESOLVER_ADDR\");\n        nestedFactory = _nestedFactory;\n        resolver = _resolver;\n    }\n\n    /// @notice Call NestedFactory and OperatorResolver to add an operator.\n    /// @param operator The operator to add\n    /// @param name The operator bytes32 name\n    function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external {\n        require(operator.implementation != address(0), \"AO-SCRIPT: INVALID_IMPL_ADDRESS\");\n\n        // Init arrays with length 1 (only one operator to import)\n        bytes32[] memory names = new bytes32[](1);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](1);\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n\n        names[0] = name;\n        operatorsToImport[0] = operator;\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n\n        ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n            ITransparentUpgradeableProxy(nestedFactory).implementation(),\n            abi.encodeWithSelector(INestedFactory.addOperator.selector, name)\n        );\n    }\n\n    /// @notice Deploy and add operators\n    /// @dev One address and multiple selectors/names\n    /// @param bytecode Operator implementation bytecode\n    /// @param operators Array of tuples => bytes32/bytes4 (name and selector)\n    function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\n        uint256 operatorLength = operators.length;\n        require(operatorLength != 0, \"DAO-SCRIPT: INVALID_OPERATOR_LEN\");\n        require(bytecode.length != 0, \"DAO-SCRIPT: BYTECODE_ZERO\");\n\n        address deployedAddress;\n        assembly {\n            deployedAddress := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n        require(deployedAddress != address(0), \"DAO-SCRIPT: FAILED_DEPLOY\");\n\n        // Init arrays\n        bytes32[] memory names = new bytes32[](operatorLength);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](operatorLength);\n\n        for (uint256 i; i < operatorLength; i++) {\n            names[i] = operators[i].name;\n            operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector);\n        }\n\n        // Only the NestedFactory as destination\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        // Start importing operators\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n\n        // Add all the operators to the factory\n        for (uint256 i; i < operatorLength; i++) {\n            ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n                ITransparentUpgradeableProxy(nestedFactory).implementation(),\n                abi.encodeWithSelector(INestedFactory.addOperator.selector, operators[i].name)\n            );\n        }\n    }\n\n    /// @notice Call NestedFactory and OperatorResolver to remove an operator.\n    /// @param name The operator bytes32 name\n    function removeOperator(bytes32 name) external {\n        ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n            ITransparentUpgradeableProxy(nestedFactory).implementation(),\n            abi.encodeWithSelector(INestedFactory.removeOperator.selector, name)\n        );\n\n        // Init arrays with length 1 (only one operator to remove)\n        bytes32[] memory names = new bytes32[](1);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](1);\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n\n        names[0] = name;\n        operatorsToImport[0] = IOperatorResolver.Operator({ implementation: address(0), selector: bytes4(0) });\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n    }\n}"
    },
    {
      "filename": "contracts/OperatorResolver.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./interfaces/IOperatorResolver.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Operator Resolver implementation\n/// @notice Resolve the operators address\ncontract OperatorResolver is IOperatorResolver, Ownable {\n    /// @dev Operators map of the name and address\n    mapping(bytes32 => Operator) public operators;\n\n    /// @inheritdoc IOperatorResolver\n    function getOperator(bytes32 name) external view override returns (Operator memory) {\n        return operators[name];\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function requireAndGetOperator(bytes32 name, string calldata reason)\n        external\n        view\n        override\n        returns (Operator memory)\n    {\n        Operator memory _foundOperator = operators[name];\n        require(_foundOperator.implementation != address(0), reason);\n        return _foundOperator;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n        external\n        view\n        override\n        returns (bool)\n    {\n        uint256 namesLength = names.length;\n        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        for (uint256 i = 0; i < namesLength; i++) {\n            if (\n                operators[names[i]].implementation != destinations[i].implementation ||\n                operators[names[i]].selector != destinations[i].selector\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function importOperators(\n        bytes32[] calldata names,\n        Operator[] calldata operatorsToImport,\n        MixinOperatorResolver[] calldata destinations\n    ) external override onlyOwner {\n        require(names.length == operatorsToImport.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        bytes32 name;\n        Operator calldata destination;\n        for (uint256 i = 0; i < names.length; i++) {\n            name = names[i];\n            destination = operatorsToImport[i];\n            operators[name] = destination;\n            emit OperatorImported(name, destination);\n        }\n\n        // rebuild caches atomically\n        // see. https://github.com/code-423n4/2021-11-nested-findings/issues/217\n        rebuildCaches(destinations);\n    }\n\n    /// @notice rebuild the caches of mixin smart contracts\n    /// @param destinations The list of mixinOperatorResolver to rebuild\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/OperatorResolver.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./interfaces/IOperatorResolver.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Operator Resolver implementation\n/// @notice Resolve the operators address\ncontract OperatorResolver is IOperatorResolver, Ownable {\n    /// @dev Operators map of the name and address\n    mapping(bytes32 => Operator) public operators;\n\n    /// @inheritdoc IOperatorResolver\n    function getOperator(bytes32 name) external view override returns (Operator memory) {\n        return operators[name];\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function requireAndGetOperator(bytes32 name, string calldata reason)\n        external\n        view\n        override\n        returns (Operator memory)\n    {\n        Operator memory _foundOperator = operators[name];\n        require(_foundOperator.implementation != address(0), reason);\n        return _foundOperator;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n        external\n        view\n        override\n        returns (bool)\n    {\n        uint256 namesLength = names.length;\n        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        for (uint256 i = 0; i < namesLength; i++) {\n            if (\n                operators[names[i]].implementation != destinations[i].implementation ||\n                operators[names[i]].selector != destinations[i].selector\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function importOperators(\n        bytes32[] calldata names,\n        Operator[] calldata operatorsToImport,\n        MixinOperatorResolver[] calldata destinations\n    ) external override onlyOwner {\n        require(names.length == operatorsToImport.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        bytes32 name;\n        Operator calldata destination;\n        for (uint256 i = 0; i < names.length; i++) {\n            name = names[i];\n            destination = operatorsToImport[i];\n            operators[name] = destination;\n            emit OperatorImported(name, destination);\n        }\n\n        // rebuild caches atomically\n        // see. https://github.com/code-423n4/2021-11-nested-findings/issues/217\n        rebuildCaches(destinations);\n    }\n\n    /// @notice rebuild the caches of mixin smart contracts\n    /// @param destinations The list of mixinOperatorResolver to rebuild\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n}"
    }
  ]
}