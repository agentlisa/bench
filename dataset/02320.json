{
  "Title": "M-17: attacker can perform malicious transactions in the safe because reentrancy is not implemented correctly in the checkTransaction() and checkAfterExecution() function in HSG",
  "Content": "# Issue M-17: attacker can perform malicious transactions in the safe because reentrancy is not implemented correctly in the checkTransaction() and checkAfterExecution() function in HSG \n\nSource: https://github.com/sherlock-audit/2023-02-hats-judging/issues/124 \n\n## Found by \nunforgiven, cducrest-brainbot\n\n## Summary\nto prevent reentrancy during the safe's `execTransaction()` function call code use `_guardEntries` and increase it in the `checkTransaction()` and decrease it in the `checkAfterExecution()`. but the logic is wrong and code won't underflow in the `checkAfterExecution()` if attacker perform reentrancy during the `execTransaction()`\n\n## Vulnerability Detail\nThis is some part of the `checkTransaction()` and `checkAfterExecution()` code:\n```solidity\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address // msgSender\n    ) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        uint256 safeOwnerCount = safe.getOwners().length;\n        // uint256 validSignerCount = _countValidSigners(safe.getOwners());\n\n        // ensure that safe threshold is correct\n        reconcileSignerCount();\n\n        if (safeOwnerCount < minThreshold) {\n            revert BelowMinThreshold(minThreshold, safeOwnerCount);\n        }\n\n        // get the tx hash; view function\n        bytes32 txHash = safe.getTransactionHash(\n            // Transaction info\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            // Payment info\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            // Signature info\n            // We subtract 1 since nonce was just incremented in the parent function call\n            safe.nonce() - 1 // view function\n        );\n\n        uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n\n        unchecked {\n            ++_guardEntries;\n        }\n    }\n\n    /// @notice Post-flight check to prevent `safe` signers from removing this contract guard, changing any modules, or changing the threshold\n    /// @dev Modified from https://github.com/gnosis/zodiac-guard-mod/blob/988ebc7b71e352f121a0be5f6ae37e79e47a4541/contracts/ModGuard.sol#L86\n    function checkAfterExecution(bytes32, bool) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        // leave checked to catch underflows triggered by re-erntry attempts\n        --_guardEntries;\n    }\n```\nas you can see code increase the value of the `_guardEntries` in the `checkTransaction()` which is called before the transaction execution and decrease its value in the `checkAfterExecution` which is called after transaction execution. this won't protect against reentrancy during the safe's `execTransaction()` call. attacker can perform this actions:\n1. Transaction1 which has valid number of signers and set the value of the guard to 0x0. and call `safe.execTransaction(Transaction2)`.\n2.  Transaction2 which reset the value of the guard to the HSG address.\n3. now by calling `Tsafe.execTransaction(Transaction1)` code would first call `checkTransaction()` and would see the number of the signers is correct and then increase the value of the `_guardEntiries` to 1 and then code in safe would execute the Transaction1 which would set the guard to 0x0 and execute the Transaction2 in safe.\n4. because guard is 0x0 code would execute the Transaction2 and then during that code would re-set the value of the guard to the HSG address.\n5. now `checkAfterExecution()` would get exeucted and would see that guard value is correct and would decrease the `_guardEntiries`\n\nthe attack is possible by changing the value of the `threshhold` in the safe. because code would perform two increase and one decrease during the reentrancy so the underflow won't happen.\n\n\n## Impact\nit's possible to set guard or threshold during the execTransaction() and execute another malicious transaction which resets guard and threshold\n\n## Code Snippet\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L507-L540\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L500-L503\n\nhttps://github.com/safe-global/safe-contracts/blob/cb22537c89ea4187f4ad141ab2e1abf15b27416b/contracts/Safe.sol#L172-L174\n\n\n## Tool used\nManual Review\n\n## Recommendation\nset the value of the guard to 1 and decrease in the `checkTransaction()` and increase in the `checkAfterExecution()`.\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/48",
  "Code": [
    {
      "filename": "contracts/ModGuard.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.6;\n\nimport \"@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol\";\nimport \"@gnosis.pm/zodiac/contracts/guard/BaseGuard.sol\";\nimport \"@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol\";\n\ncontract ModGuard is FactoryFriendly, BaseGuard {\n    event ModGuardSetup(\n        address indexed initiator,\n        address indexed owner,\n        address indexed avatar,\n        address[] modules\n    );\n    event ProtectedModulesSet(address[] protectedModules);\n    event AvatarSet(address avatar);\n\n    // Cannot disable this guard\n    error CannotDisableThisGuard(address guard);\n\n    // Cannot disable protected modules\n    error CannotDisableProtecedModules(address module);\n\n    address public avatar;\n    address[] public protectedModules;\n\n    // keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT =\n        0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    constructor(\n        address _owner,\n        address _avatar,\n        address[] memory _modules\n    ) {\n        bytes memory initializeParams = abi.encode(_owner, _avatar, _modules);\n        setUp(initializeParams);\n    }\n\n    /// @dev Initialize function, will be triggered when a new proxy is deployed\n    /// @param initializeParams Parameters of initialization encoded\n    function setUp(bytes memory initializeParams) public override {\n        __Ownable_init();\n        (address _owner, address _avatar, address[] memory _modules) = abi\n            .decode(initializeParams, (address, address, address[]));\n\n        avatar = _avatar;\n        setProtectedModules(_modules);\n        transferOwnership(_owner);\n\n        emit ModGuardSetup(msg.sender, _owner, _avatar, _modules);\n    }\n\n    function setProtectedModules(address[] memory _modules) public onlyOwner {\n        protectedModules = _modules;\n        emit ProtectedModulesSet(protectedModules);\n    }\n\n    function setAvatar(address _avatar) public onlyOwner {\n        avatar = _avatar;\n        emit AvatarSet(avatar);\n    }\n\n    // solhint-disallow-next-line payable-fallback\n    fallback() external {\n        // We don't revert on fallback to avoid issues in case of a Safe upgrade\n        // E.g. The expected check method might change and then the Safe would be locked.\n    }\n\n    function checkTransaction(\n        address,\n        uint256,\n        bytes memory,\n        Enum.Operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        // solhint-disallow-next-line no-unused-vars\n        address payable,\n        bytes memory,\n        address\n    ) external view override {}\n\n    function checkAfterExecution(bytes32, bool) external view override {\n        if (\n            abi.decode(\n                StorageAccessible(avatar).getStorageAt(\n                    uint256(GUARD_STORAGE_SLOT),\n                    2\n                ),\n                (address)\n            ) != address(this)\n        ) {\n            revert CannotDisableThisGuard(address(this));\n        }\n        for (uint256 i = 0; i < protectedModules.length; i++) {\n            if (!IAvatar(avatar).isModuleEnabled(protectedModules[i])) {\n                revert CannotDisableProtecedModules(protectedModules[i]);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/HatsSignerGateBase.sol",
      "content": "// SPDX-License-Identifier: CC0\npragma solidity >=0.8.13;\n\nimport { Test, console2 } from \"forge-std/Test.sol\"; // remove after testing\nimport \"./HSGLib.sol\";\nimport { HatsOwnedInitializable } from \"hats-auth/HatsOwnedInitializable.sol\";\nimport { BaseGuard } from \"zodiac/guard/BaseGuard.sol\";\nimport { IAvatar } from \"zodiac/interfaces/IAvatar.sol\";\nimport { StorageAccessible } from \"@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol\";\nimport { IGnosisSafe, Enum } from \"./Interfaces/IGnosisSafe.sol\";\nimport { SignatureDecoder } from \"@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol\";\n\nabstract contract HatsSignerGateBase is BaseGuard, SignatureDecoder, HatsOwnedInitializable {\n    /// @notice The multisig to which this contract is attached\n    IGnosisSafe public safe;\n\n    /// @notice The minimum signature threshold for the `safe`\n    uint256 public minThreshold;\n\n    /// @notice The highest level signature threshold for the `safe`\n    uint256 public targetThreshold;\n\n    /// @notice The maximum number of signers allowed for the `safe`\n    uint256 public maxSigners;\n\n    /// @notice The current number of signers on the `safe`\n    uint256 public signerCount;\n\n    /// @notice The version of HatsSignerGate used in this contract\n    string public version;\n\n    /// @notice The number of modules enabled on the `safe`, as enabled via this contract\n    uint256 public enabledModuleCount;\n\n    /// @dev Temporary record of the existing modules on the `safe` when a transaction is submitted\n    bytes32 internal _existingModulesHash;\n    \n    /// @dev A simple re-entrency guard\n    uint256 internal _guardEntries;\n\n    /// @dev The head pointer used in the GnosisSafe owners linked list, as well as the module linked list\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    /// @dev The storage slot used by GnosisSafe to store the guard address\n    ///      keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Makes the singleton unusable by setting its owner to the 1-address\n    constructor() payable initializer {\n        _HatsOwned_init(1, address(0x1));\n    }\n\n    /// @notice Initializes a new instance\n    /// @dev Can only be called once\n    /// @param initializeParams ABI-encoded bytes with initialization parameters\n    function setUp(bytes calldata initializeParams) public payable virtual initializer { }\n\n    /// @notice Internal function to initialize a new instance\n    /// @param _ownerHatId The hat id of the hat that owns this instance of HatsSignerGate\n    /// @param _safe The multisig to which this instance of HatsSignerGate is attached\n    /// @param _hats The Hats Protocol address\n    /// @param _minThreshold The minimum threshold for the `_safe`\n    /// @param _targetThreshold The maxium threshold for the `_safe`\n    /// @param _maxSigners The maximum number of signers allowed on the `_safe`\n    /// @param _version The current version of HatsSignerGate\n    function _setUp(\n        uint256 _ownerHatId,\n        address _safe,\n        address _hats,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        string memory _version,\n        uint256 _existingModuleCount\n    ) internal {\n        _HatsOwned_init(_ownerHatId, _hats);\n        maxSigners = _maxSigners;\n        safe = IGnosisSafe(_safe);\n\n        _setTargetThreshold(_targetThreshold);\n        _setMinThreshold(_minThreshold);\n        version = _version;\n        enabledModuleCount = _existingModuleCount + 1; // this contract is enabled as well\n    }\n\n    /// @notice Checks if `_account` is a valid signer\n    /// @dev Must be implemented by all flavors of HatsSignerGate\n    /// @param _account The address to check\n    /// @return valid Whether `_account` is a valid signer\n    function isValidSigner(address _account) public view virtual returns (bool valid) { }\n\n    /// @notice Sets a new target threshold, and changes `safe`'s threshold if appropriate\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_targetThreshold` is greater than `maxSigners`.\n    /// @param _targetThreshold The new target threshold to set\n    function setTargetThreshold(uint256 _targetThreshold) public onlyOwner {\n        if (_targetThreshold != targetThreshold) {\n            _setTargetThreshold(_targetThreshold);\n\n            if (signerCount > 1) _setSafeThreshold(_targetThreshold);\n\n            emit HSGLib.TargetThresholdSet(_targetThreshold);\n        }\n    }\n\n    /// @notice Internal function to set the target threshold\n    /// @dev Reverts if `_targetThreshold` is greater than `maxSigners`\n    /// @param _targetThreshold The new target threshold to set\n    function _setTargetThreshold(uint256 _targetThreshold) internal {\n        if (_targetThreshold > maxSigners) {\n            revert InvalidTargetThreshold();\n        }\n\n        targetThreshold = _targetThreshold;\n    }\n\n    /// @notice Internal function to set the threshold for the `safe`\n    /// @dev Forwards the threshold-setting call to `safe.ExecTransactionFromModule`\n    /// @param _threshold The threshold to set on the `safe`\n    function _setSafeThreshold(uint256 _threshold) internal {\n        uint256 newThreshold = _threshold;\n        uint256 signerCount_ = signerCount; // save an SLOAD\n\n        // ensure that txs can't execute if fewer signers than target threshold\n        if (signerCount_ <= _threshold) {\n            newThreshold = signerCount_;\n        }\n        if (newThreshold != safe.getThreshold()) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", newThreshold);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Sets a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function setMinThreshold(uint256 _minThreshold) public onlyOwner {\n        _setMinThreshold(_minThreshold);\n        emit HSGLib.MinThresholdSet(_minThreshold);\n    }\n\n    /// @notice Internal function to set a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function _setMinThreshold(uint256 _minThreshold) internal {\n        if (_minThreshold > maxSigners || _minThreshold > targetThreshold) {\n            revert InvalidMinThreshold();\n        }\n\n        minThreshold = _minThreshold;\n    }\n\n    /// @notice Allows the owner to enable a new module on the `safe`\n    /// @dev Increments the `enabledModuleCount` to include the new module in the allowed list (see `checkTransaction` and `checkAfterExecution`)\n    /// @param _module The address of the module to enable\n    function enableNewModule(address _module) external onlyOwner {\n        ++enabledModuleCount;\n\n        bytes memory data = abi.encodeWithSignature(\"enableModule(address)\", _module);\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            data, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecEnableModule();\n        }\n    }\n\n    /// @notice Tallies the number of existing `safe` owners that wear a signer hat, sets `signerCount` to that value, and updates the `safe` threshold if necessary\n    /// @dev Does NOT remove invalid `safe` owners\n    function reconcileSignerCount() public {\n        address[] memory owners = safe.getOwners();\n        uint256 validSignerCount = _countValidSigners(owners);\n\n        if (validSignerCount > maxSigners) {\n            revert MaxSignersReached();\n        }\n\n        // update the signer count accordingly\n        signerCount = validSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold();\n        uint256 newThreshold;\n        uint256 target = targetThreshold; // save SLOADs\n\n        if (validSignerCount <= target && validSignerCount != currentThreshold) {\n            newThreshold = validSignerCount;\n        } else if (validSignerCount > target && currentThreshold < target) {\n            newThreshold = target;\n        }\n        if (newThreshold > 0) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", validSignerCount);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Internal function to count the number of valid signers in an array of addresses\n    /// @param owners The addresses to check for validity\n    /// @return validSignerCount The number of valid signers in `owners`\n    function _countValidSigners(address[] memory owners) internal view returns (uint256 validSignerCount) {\n        uint256 length = owners.length;\n        // count the existing safe owners that wear the signer hat\n        for (uint256 i; i < length;) {\n            if (isValidSigner(owners[i])) {\n                // shouldn't overflow given reasonable owners array length\n                unchecked {\n                    ++validSignerCount;\n                }\n            }\n            // shouldn't overflow given reasonable owners array length\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Internal function that adds `_signer` as an owner on `safe`, updating the threshold if appropriate\n    /// @dev Unsafe. Does not check if `_signer` is a valid signer\n    /// @param _owners Array of owners on the `safe`\n    /// @param _currentSignerCount The current number of signers\n    /// @param _signer The address to add as a new `safe` owner\n    function _grantSigner(address[] memory _owners, uint256 _currentSignerCount, address _signer) internal {\n        uint256 newSignerCount = _currentSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold(); // view function\n        uint256 newThreshold = currentThreshold;\n\n        bytes memory addOwnerData;\n\n        // if the only owner is a non-signer (ie this module set as an owner on initialization), replace it with _signer\n        if (_owners.length == 1 && _owners[0] == address(this)) {\n            // prevOwner will always be the sentinel when owners.length == 1\n\n            // set up the swapOwner call\n            addOwnerData = abi.encodeWithSignature(\n                \"swapOwner(address,address,address)\",\n                SENTINEL_OWNERS, // prevOwner\n                address(this), // oldOwner\n                _signer // newOwner\n            );\n            unchecked {\n                // shouldn't overflow given MaxSignersReached check higher in call stack\n                ++newSignerCount;\n            }\n        } else {\n            // otherwise, add the claimer as a new owner\n\n            unchecked {\n                // shouldn't overflow given MaxSignersReached check higher in call stack\n                ++newSignerCount;\n            }\n\n            // ensure that txs can't execute if fewer signers than target threshold\n            if (newSignerCount <= targetThreshold) {\n                newThreshold = newSignerCount;\n            }\n\n            // set up the addOwner call\n            addOwnerData = abi.encodeWithSignature(\"addOwnerWithThreshold(address,uint256)\", _signer, newThreshold);\n        }\n\n        // increment signer count\n        signerCount = newSignerCount;\n\n        // execute the call\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            addOwnerData, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecAddSigner();\n        }\n    }\n\n    /// @notice Internal function that adds `_signer` as an owner on `safe` by swapping with an existing (invalid) owner\n    /// @dev Unsafe. Does not check if `_signer` is a valid signer.\n    /// @param _owners Array of owners on the `safe`\n    /// @param _ownerCount The number of owners on the `safe` (length of `_owners` array)\n    /// @param _maxSigners The maximum number of signers allowed\n    /// @param _currentSignerCount The current number of signers\n    /// @param _signer The address to add as a new `safe` owner\n    /// @return success Whether an invalid signer was found and successfully replaced with `_signer`\n    function _swapSigner(\n        address[] memory _owners,\n        uint256 _ownerCount,\n        uint256 _maxSigners,\n        uint256 _currentSignerCount,\n        address _signer\n    ) internal returns (bool success) {\n        address ownerToCheck;\n        bytes memory data;\n\n        for (uint256 i; i < _ownerCount - 1;) {\n            ownerToCheck = _owners[i];\n\n            if (!isValidSigner(ownerToCheck)) {\n                // prep the swap\n                data = abi.encodeWithSignature(\n                    \"swapOwner(address,address,address)\",\n                    _findPrevOwner(_owners, ownerToCheck), // prevOwner\n                    ownerToCheck, // oldOwner\n                    _signer // newOwner\n                );\n\n                // execute the swap, reverting if it fails for some reason\n                success = safe.execTransactionFromModule(\n                    address(safe), // to\n                    0, // value\n                    data, // data\n                    Enum.Operation.Call // operation\n                );\n\n                if (!success) {\n                    revert FailedExecRemoveSigner();\n                }\n\n                // increment the signer count if signerCount was correct, ie `reconcileSignerCount` was called prior\n                if (_currentSignerCount < _maxSigners) ++signerCount;\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Removes an invalid signer from the `safe`, updating the threshold if appropriate\n    /// @param _signer The address to remove if not a valid signer\n    function removeSigner(address _signer) public virtual {\n        if (isValidSigner(_signer)) {\n            revert StillWearsSignerHat(_signer);\n        }\n\n        _removeSigner(_signer);\n    }\n\n    /// @notice Internal function to remove a signer from the `safe`, updating the threshold if appropriate\n    /// @dev Unsafe. Does not check for signer validity before removal\n    /// @param _signer The address to remove\n    function _removeSigner(address _signer) internal {\n        bytes memory removeOwnerData;\n        address[] memory owners = safe.getOwners();\n        uint256 currentSignerCount = signerCount; // save an SLOAD\n        uint256 newSignerCount;\n\n        if (currentSignerCount < 2 && owners.length == 1) {\n            // signerCount could be 0 after reconcileSignerCount\n            // make address(this) the only owner\n            removeOwnerData = abi.encodeWithSignature(\n                \"swapOwner(address,address,address)\",\n                SENTINEL_OWNERS, // prevOwner\n                _signer, // oldOwner\n                address(this) // newOwner\n            );\n\n            // newSignerCount is already 0\n        } else {\n            uint256 currentThreshold = safe.getThreshold();\n            uint256 newThreshold = currentThreshold;\n            uint256 validSignerCount = _countValidSigners(owners);\n\n            if (validSignerCount == currentSignerCount) {\n                newSignerCount = currentSignerCount;\n            } else {\n                newSignerCount = currentSignerCount - 1;\n            }\n\n            // ensure that txs can't execute if fewer signers than target threshold\n            if (newSignerCount <= targetThreshold) {\n                newThreshold = newSignerCount;\n            }\n\n            removeOwnerData = abi.encodeWithSignature(\n                \"removeOwner(address,address,uint256)\", _findPrevOwner(owners, _signer), _signer, newThreshold\n            );\n        }\n\n        // update signerCount\n        signerCount = newSignerCount;\n\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            removeOwnerData, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecRemoveSigner();\n        }\n    }\n\n    /// @notice Internal function to find the previous owner of an `_owner` in an array of `_owners`, ie the pointer to the owner to remove from the `safe` owners linked list\n    /// @param _owners An array of addresses\n    /// @param _owner The address after the one to find\n    /// @return prevOwner The owner previous to `_owner` in the `safe` linked list\n    function _findPrevOwner(address[] memory _owners, address _owner) internal pure returns (address prevOwner) {\n        prevOwner = SENTINEL_OWNERS;\n\n        for (uint256 i; i < _owners.length;) {\n            if (_owners[i] == _owner) {\n                if (i == 0) break;\n                prevOwner = _owners[i - 1];\n            }\n            // shouldn't overflow given reasonable _owners array length\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // solhint-disallow-next-line payable-fallback\n    fallback() external {\n        // We don't revert on fallback to avoid issues in case of a Safe upgrade\n        // E.g. The expected check method might change and then the Safe would be locked.\n    }\n\n    /// @notice Pre-flight check on a `safe` transaction to ensure that it s signers are valid, called from within `safe.execTransactionFromModule()`\n    /// @dev Overrides All params mirror params for `safe.execTransactionFromModule()`\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address // msgSender\n    ) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        uint256 safeOwnerCount = safe.getOwners().length;\n        // uint256 validSignerCount = _countValidSigners(safe.getOwners());\n\n        // ensure that safe threshold is correct\n        reconcileSignerCount();\n\n        if (safeOwnerCount < minThreshold) {\n            revert BelowMinThreshold(minThreshold, safeOwnerCount);\n        }\n\n        // get the tx hash; view function\n        bytes32 txHash = safe.getTransactionHash(\n            // Transaction info\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            // Payment info\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            // Signature info\n            // We subtract 1 since nonce was just incremented in the parent function call\n            safe.nonce() - 1 // view function\n        );\n\n        uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n\n        // revert if there aren't enough valid signatures\n        if (validSigCount < safe.getThreshold() || validSigCount < minThreshold) {\n            revert InvalidSigners();\n        }\n\n        // record existing modules for post-flight check\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n        _existingModulesHash = keccak256(abi.encode(modules));\n\n        unchecked {\n            ++_guardEntries;\n        }\n    }\n\n    /// @notice Post-flight check to prevent `safe` signers from removing this contract guard, changing any modules, or changing the threshold\n    /// @dev Modified from https://github.com/gnosis/zodiac-guard-mod/blob/988ebc7b71e352f121a0be5f6ae37e79e47a4541/contracts/ModGuard.sol#L86\n    function checkAfterExecution(bytes32, bool) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        if (\n            abi.decode(StorageAccessible(address(safe)).getStorageAt(uint256(GUARD_STORAGE_SLOT), 1), (address))\n                != address(this)\n        ) {\n            revert CannotDisableThisGuard(address(this));\n        }\n\n        if (safe.getThreshold() != _getCorrectThreshold()) {\n            revert SignersCannotChangeThreshold();\n        }\n\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n        if (keccak256(abi.encode(modules)) != _existingModulesHash) {\n            revert SignersCannotChangeModules();\n        }\n\n        // leave checked to catch underflows triggered by re-erntry attempts\n        --_guardEntries;\n    }\n\n    /// @notice Internal function to calculate the threshold that `safe` should have, given the correct `signerCount`, `minThreshold`, and `targetThreshold`\n    /// @return _threshold The correct threshold\n    function _getCorrectThreshold() internal view returns (uint256 _threshold) {\n        uint256 count = _countValidSigners(safe.getOwners());\n        uint256 min = minThreshold;\n        uint256 max = targetThreshold;\n        if (count < min) _threshold = min;\n        else if (count > max) _threshold = max;\n        else _threshold = count;\n    }\n\n    /// @notice Counts the number of hats-valid signatures within a set of `signatures`\n    /// @dev modified from https://github.com/safe-global/safe-contracts/blob/c36bcab46578a442862d043e12a83fec41143dec/contracts/GnosisSafe.sol#L240\n    /// @param dataHash The signed data\n    /// @param signatures The set of signatures to check\n    /// @return validSigCount The number of hats-valid signatures\n    function countValidSignatures(bytes32 dataHash, bytes memory signatures, uint256 sigCount)\n        public\n        view\n        returns (uint256 validSigCount)\n    {\n        // There cannot be an owner with address 0.\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n\n        for (i; i < sigCount;) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner =\n                    ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n\n            if (isValidSigner(currentOwner)) {\n                // shouldn't overflow given reasonable sigCount\n                unchecked {\n                    ++validSigCount;\n                }\n            }\n            // shouldn't overflow given reasonable sigCount\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/HatsSignerGateBase.sol",
      "content": "// SPDX-License-Identifier: CC0\npragma solidity >=0.8.13;\n\nimport { Test, console2 } from \"forge-std/Test.sol\"; // remove after testing\nimport \"./HSGLib.sol\";\nimport { HatsOwnedInitializable } from \"hats-auth/HatsOwnedInitializable.sol\";\nimport { BaseGuard } from \"zodiac/guard/BaseGuard.sol\";\nimport { IAvatar } from \"zodiac/interfaces/IAvatar.sol\";\nimport { StorageAccessible } from \"@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol\";\nimport { IGnosisSafe, Enum } from \"./Interfaces/IGnosisSafe.sol\";\nimport { SignatureDecoder } from \"@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol\";\n\nabstract contract HatsSignerGateBase is BaseGuard, SignatureDecoder, HatsOwnedInitializable {\n    /// @notice The multisig to which this contract is attached\n    IGnosisSafe public safe;\n\n    /// @notice The minimum signature threshold for the `safe`\n    uint256 public minThreshold;\n\n    /// @notice The highest level signature threshold for the `safe`\n    uint256 public targetThreshold;\n\n    /// @notice The maximum number of signers allowed for the `safe`\n    uint256 public maxSigners;\n\n    /// @notice The current number of signers on the `safe`\n    uint256 public signerCount;\n\n    /// @notice The version of HatsSignerGate used in this contract\n    string public version;\n\n    /// @notice The number of modules enabled on the `safe`, as enabled via this contract\n    uint256 public enabledModuleCount;\n\n    /// @dev Temporary record of the existing modules on the `safe` when a transaction is submitted\n    bytes32 internal _existingModulesHash;\n    \n    /// @dev A simple re-entrency guard\n    uint256 internal _guardEntries;\n\n    /// @dev The head pointer used in the GnosisSafe owners linked list, as well as the module linked list\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    /// @dev The storage slot used by GnosisSafe to store the guard address\n    ///      keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Makes the singleton unusable by setting its owner to the 1-address\n    constructor() payable initializer {\n        _HatsOwned_init(1, address(0x1));\n    }\n\n    /// @notice Initializes a new instance\n    /// @dev Can only be called once\n    /// @param initializeParams ABI-encoded bytes with initialization parameters\n    function setUp(bytes calldata initializeParams) public payable virtual initializer { }\n\n    /// @notice Internal function to initialize a new instance\n    /// @param _ownerHatId The hat id of the hat that owns this instance of HatsSignerGate\n    /// @param _safe The multisig to which this instance of HatsSignerGate is attached\n    /// @param _hats The Hats Protocol address\n    /// @param _minThreshold The minimum threshold for the `_safe`\n    /// @param _targetThreshold The maxium threshold for the `_safe`\n    /// @param _maxSigners The maximum number of signers allowed on the `_safe`\n    /// @param _version The current version of HatsSignerGate\n    function _setUp(\n        uint256 _ownerHatId,\n        address _safe,\n        address _hats,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        string memory _version,\n        uint256 _existingModuleCount\n    ) internal {\n        _HatsOwned_init(_ownerHatId, _hats);\n        maxSigners = _maxSigners;\n        safe = IGnosisSafe(_safe);\n\n        _setTargetThreshold(_targetThreshold);\n        _setMinThreshold(_minThreshold);\n        version = _version;\n        enabledModuleCount = _existingModuleCount + 1; // this contract is enabled as well\n    }\n\n    /// @notice Checks if `_account` is a valid signer\n    /// @dev Must be implemented by all flavors of HatsSignerGate\n    /// @param _account The address to check\n    /// @return valid Whether `_account` is a valid signer\n    function isValidSigner(address _account) public view virtual returns (bool valid) { }\n\n    /// @notice Sets a new target threshold, and changes `safe`'s threshold if appropriate\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_targetThreshold` is greater than `maxSigners`.\n    /// @param _targetThreshold The new target threshold to set\n    function setTargetThreshold(uint256 _targetThreshold) public onlyOwner {\n        if (_targetThreshold != targetThreshold) {\n            _setTargetThreshold(_targetThreshold);\n\n            if (signerCount > 1) _setSafeThreshold(_targetThreshold);\n\n            emit HSGLib.TargetThresholdSet(_targetThreshold);\n        }\n    }\n\n    /// @notice Internal function to set the target threshold\n    /// @dev Reverts if `_targetThreshold` is greater than `maxSigners`\n    /// @param _targetThreshold The new target threshold to set\n    function _setTargetThreshold(uint256 _targetThreshold) internal {\n        if (_targetThreshold > maxSigners) {\n            revert InvalidTargetThreshold();\n        }\n\n        targetThreshold = _targetThreshold;\n    }\n\n    /// @notice Internal function to set the threshold for the `safe`\n    /"
    }
  ]
}