{
  "Title": "H-1: Liquidations are impossible for some Curve pools",
  "Content": "# Issue H-1: Liquidations are impossible for some Curve pools \n\nSource: https://github.com/sherlock-audit/2023-02-notional-judging/issues/21 \n\n## Found by \nusmannk\n\n## Summary\n\nSome curve pools have implementations such that Notional liquidations always revert.\n\n## Vulnerability Detail\n\nLiquidations are done, directly or indirectly, via the `deleverageAccount` function. This function calls `_checkReentrancyContext` to protect against read-only reentrancy.\n\nThe Curve vault's `_checkReentrancyContext` function uses the Curve `remove_liquidity` function to check the reentrancy context. However, for certain Curve pools like the CRV/ETH pool (0x8301ae4fc9c624d1d396cbdaa1ed877821d7c511, https://curve.fi/#/ethereum/pools/crveth/) calling `remove_liquidity(0, [0,0])` always reverts due to an underflow.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/mixins/Curve2TokenVaultMixin.sol#L13-L16\n\n## Impact\n\nLiquidations are not possible, users can go into bad debt and there is no way to recover the lost funds.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the `claim_admin_fees` function to check Curve's reentrancy state instead of `remove_liquidity`.\n\n## Discussion\n\n**jeffywu**\n\nValid, appears that removing 1 token will be sufficient to pass the underflow check. We need to make a note of this and ensure that we either pass in a parameter of 1 or 0 based on the target pool.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/52",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/mixins/Curve2TokenVaultMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {ConvexVaultDeploymentParams, Curve2TokenConvexStrategyContext} from \"../CurveVaultTypes.sol\";\nimport {Curve2TokenPoolMixin} from \"./Curve2TokenPoolMixin.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {ICurve2TokenPool} from \"../../../../interfaces/curve/ICurvePool.sol\";\n\nabstract contract Curve2TokenVaultMixin is Curve2TokenPoolMixin {\n    constructor(NotionalProxy notional_, ConvexVaultDeploymentParams memory params)\n        Curve2TokenPoolMixin(notional_, params) { }\n\n    function _checkReentrancyContext() internal override {\n        uint256[2] memory minAmounts;\n        ICurve2TokenPool(address(CURVE_POOL)).remove_liquidity(0, minAmounts);\n    }\n\n    function _strategyContext() internal view returns (Curve2TokenConvexStrategyContext memory) {\n        return Curve2TokenConvexStrategyContext({\n            baseStrategy: _baseStrategyContext(),\n            poolContext: _twoTokenPoolContext(),\n            stakingContext: _convexStakingContext()\n        });\n    }\n\n    uint256[40] private __gap; // Storage gap for future potential upgrades\n}"
    }
  ]
}