{
  "Title": "M-4: Users may not be able to fully redeem USD1 into USDT even when reserve ratio is above 100%",
  "Content": "# Issue M-4: Users may not be able to fully redeem USD1 into USDT even when reserve ratio is above 100% \n\nSource: https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/95 \n\n## Found by \n0x00ffDa, 0xyPhilic, Jiamin, Juntao, PokemonAuditSimulator, Ruhum, sashik\\_eth\n## Summary\n\nUsers may not be able to fully redeem USDT even when reserve ratio is above 100%, because of portfolio being taken into the account for calculation.\n\n## Vulnerability Detail\n\nReserve ratio shows how many liabilities is covered by reserves, a reserve ratio above 100% guarantees protocol has enough USDT to redeem, the way of calculating reserve ratio is `Reserve Ratio = allReserves / liabilities` and is implemented in [Unitas#_getReserveStatus(...)](https://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/Unitas.sol#L476-L495) function:\n```solidity\n            reserveRatio = ScalingUtils.scaleByBases(\n                allReserves * valueBase / liabilities,\n                valueBase,\n                tokenManager.RESERVE_RATIO_BASE()\n            );\n```\n\n`allReserves` is the sum of the [balance](https://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/PoolBalances.sol#L22) of Unitas and InsurancePool,  calculated in [Unitas#_getTotalReservesAndCollaterals()](https://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/Unitas.sol#L500-L535) function:\n```solidity\n        for (uint256 i; i < tokenCount; i++) {\n            address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n            uint256 tokenReserve = _getBalance(token);\n            uint256 tokenCollateral = IInsurancePool(insurancePool).getCollateral(token);\n\n\n            if (tokenReserve > 0 || tokenCollateral > 0) {\n                uint256 price = oracle.getLatestPrice(token);\n\n\n                reserves += _convert(\n                    token,\n                    baseToken,\n                    tokenReserve,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n\n\n                collaterals += _convert(\n                    token,\n                    baseToken,\n                    tokenCollateral,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n            }\n        }\n```\n\n`liabilities` is the total value of USD1 and USDEMC tokens, calculated in [Unitas#_getTotalLiabilities()](https://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/Unitas.sol#L540-L567) function:\n```solidity\n        for (uint256 i; i < tokenCount; i++) {\n            address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n            uint256 tokenSupply = IERC20Token(token).totalSupply();\n\n\n            if (token == baseToken) {\n                // Adds up directly when the token is USD1\n                liabilities += tokenSupply;\n            } else if (tokenSupply > 0) {\n                uint256 price = oracle.getLatestPrice(token);\n\n\n                liabilities += _convert(\n                    token,\n                    baseToken,\n                    tokenSupply,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n            }\n        }\n```\n\nSome amount of USDT in both Unitas and InsurancePool is [portfolio](https://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/PoolBalances.sol#L26), which represents the current amount of assets used for strategic investments, it is worth noting that after [sending portfolio](https://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/PoolBalances.sol#L83-L99), `balance` remains the same, which means `portfolio` is taken into account in the calculation of reserve ratio.\n\nThis is problematic because `portfolio` is not available when user redeems, and user may not be able to fully redeem for USDT even when protocols says there is sufficient reserve ratio. \n\nLet's assume :\n\n> Unitas's balance is 10000 USD and its portfolio is 2000 USD, avaliable balance is 8000 USD\n> InsurancePool's balance is 3000 USD and its portfolio is 600 USD, available balance is 2400 USD\n> AllReserves value is 13000 USD\n> Liabilities (USDEMC) value is 10000 USD\n> Reserve Ratio is (10000 + 3000) /  10000 = 130%.\n\nLater on, USDEMC appreciates upto 10% and we can get:\n> AllReserves value is still 13000 USD\n> Liabilities (USDEMC) value is 11000 USD\n> Reserve Ratio is (10000 + 3000) /  11000 = 118%.\n\nThe available balance in Unitas is 8000 USD so there is 3000 USD in short, it needs to be obtain from InsurancePool, however,  the available balance in InsurancePool is 2400 USD, transaction will be reverted and users cannot redeem.\n\nThere would also be an extreme situation when reserve ratio is above 100% but there is no available balance in protocol because all the `balance` is `portfolio` (this is possible when InsurancePool is drained out), users cannot redeem any USDT in this case.\n\n## Impact\n\nUsers may not be able to fully redeem USD1 into USDT even when reserve ratio is above 100%, this defeats the purpose of reserve ratio and breaks the promise of the protocol, users may be mislead and lose funds.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-unitasprotocol/blob/main/Unitas-Protocol/src/Unitas.sol#L500-L535\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPortfolio should not be taken into account for the calculation of reserve ratio.\n```diff\n    function _getTotalReservesAndCollaterals() internal view returns (uint256 reserves, uint256 collaterals) {\n        ...\n-           uint256 tokenReserve = _getBalance(token);\n+           uint256 tokenReserve = _getBalance(token) - _getPortfolio(token);\n-           uint256 tokenCollateral = IInsurancePool(insurancePool).getCollateral(token);\n+           uint256 tokenCollateral = IInsurancePool(insurancePool).getCollateral(token) - IInsurancePool(insurancePool).getPortfolio(token);\n        ...\n    }\n```\n\n\n\n## Discussion\n\n**SunXrex**\n\nWe think it's invalid. it's design decision.\n\nAditya: The purpose of insurance pool is to support additional USDT requirements in the scenario the reserve pool does not have required amount. To simplify this, we keep only a small portion of assets for yield generation. Priorities : User redemption above yield generation. Ie: Only when there is enough capital in reserve and insurance pool, we take a small portion to invest in delta nuetral defi pools.\n\n**ctf-sec**\n\nProtocol's design choice, not a issue\n\n**0xruhum**\n\nEscalate for 10 USDC\nThis is not just a design choice. There are no specifics on what a \"small portion\" or \"enough capital in reserve and insurance pool\" means. Allowing the protocol team to remove collateral from the system to earn yield is a security risk. In the current version, USDT is the collateral for USD1. Without USDT, USD1 is worth nothing. The reserve ratio is used to keep the protocol healthy at all times. By including the funds inside the portfolio in the calculation you allow the protocol to become under-collateralized under certain circumstances.\n\nConsidering that #16 describes the risk of the portfolio incurring a loss which is deemed a valid issue, it's reckless to account for the funds inside the portfolio when calculating the reserve ratio. From a protocol perspective, these funds are not part of the system anymore. They were moved into a different protocol to earn yield. That is fine as long as you keep the reserve ratio of Unitas above 130%. For that to be the case, the funds inside the portfolio have to be **excluded** from the reserve ratio calculation.\n\nTo sum up, any funds inside the portfolio should not be used to calculate the reserve ratio. They can be gone at any moment due to the risks described in #16.\n\nEDIT:\n- #14 is not a valid duplicate. If portfolio > collateral the subtraction would revert so there's no underflow there.\n- #43 is not a valid duplicate. Warden argues that `_getPortfolio()` is not called although it clearly is in the code snipped they provide. The submission makes no sense\n- #90 is not a valid duplicate. Warden argues that a swap will fail if there are not enough funds in the insurance pool. That's desired behavior. You don't want to execute the swap if there are not enough funds for it.\n- #127 is not a valid duplicate. Warden argues that the portfolio amount is accounted for multiple times. But, the insurance pool is a separate contract. The portfolio amount would be 0 for the insurance pool. Thus you don't account for it twice.\n- #129 is not a valid duplicate. The issue itself is valid. The admin is able to leave the protocol under-collateralized by sending to many funds to the portfolio. That's a duplicate of #40 \n- #142 is not a valid duplicate. Tokens that are not registered in the TokenManager are not used as collateral. Even if the insurance pool holds these tokens they shouldn't be accounted for since they are not registered collateral tokens. Also, the admin has to make a mistake and send these tokens to the insurance pool since they are the only ones that are allowed to deposit.\n\nI checked the docs on whether each of these duplication issues had to be escalated separately. I didn't find any rules for that. So I decided to bring them up in a single comment. Otherwise, I'd had to create 6 additional escalations without even knowing whether this original issue here is deemed valid. If that's not the case you don't care about the wrong duplication anyways. \n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is not just a design choice. There are no specifics on what a \"small portion\" or \"enough capital in reserve and insurance pool\" means. Allowing the protocol team to remove collateral from the system to earn yield is a security risk. In the current version, USDT is the collateral for USD1. Without USDT, USD1 is worth nothing. The reserve ratio is used to keep the protocol healthy at all times. By including the funds inside the portfolio in the calculation you allow the protocol to become under-collateralized under certain circumstances.\n> \n> Considering that #16 describes the risk of the portfolio incurring a loss which is deemed a valid issue, it's reckless to account for the funds inside the portfolio when calculating the reserve ratio. From a protocol perspective, these funds are not part of the system anymore. They were moved into a different protocol to earn yield. That is fine as long as you keep the reserve ratio of Unitas above 130%. For that to be the case, the funds inside the portfolio have to be **excluded** from the reserve ratio calculation.\n> \n> To sum up, any funds inside the portfolio should not be used to calculate the reserve ratio. They can be gone at any moment due to the risks described in #16.\n> \n> EDIT:\n> - #14 is not a valid duplicate. If portfolio > collateral the subtraction would revert so there's no underflow there.\n> - #43 is not a valid duplicate. Warden argues that `_getPortfolio()` is not called although it clearly is in the code snipped they provide. The submission makes no sense\n> - #90 is not a valid duplicate. Warden argues that a swap will fail if there are not enough funds in the insurance pool. That's desired behavior. You don't want to execute the swap if there are not enough funds for it.\n> - #127 is not a valid duplicate. Warden argues that the portfolio amount is accounted for multiple times. But, the insurance pool is a separate contract. The portfolio amount would be 0 for the insurance pool. Thus you don't account for it twice.\n> - #129 is not a valid duplicate. The issue itself is valid. The admin is able to leave the protocol under-collateralized by sending to many funds to the portfolio. That's a duplicate of #40 \n> - #142 is not a valid duplicate. Tokens that are not registered in the TokenManager are not used as collateral. Even if the insurance pool holds these tokens they shouldn't be accounted for since they are not registered collateral tokens. Also, the admin has to make a mistake and send these tokens to the insurance pool since they are the only ones that are allowed to deposit.\n> \n> I checked the docs on whether each of these duplication issues had to be escalated separately. I didn't find any rules for that. So I decided to bring them up in a single comment. Otherwise, I'd had to create 6 additional escalations without even knowing whether this original issue here is deemed valid. If that's not the case you don't care about the wrong duplication anyways. \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nWill bring for sponsor review, I think this can be a valid medium\n\n**thangtranth**\n\nEscalate for 10 USDC\n\nReading the original report, I see no mentioning of the potential path or risk that leads to the issue. However in the escalation, the arguments are built upon the insights and finding of another report after submission. If the original report stands alone, I am not sure that it is convincing enough.\n\nThis escalation also aims to clarify the rules for other Watsons who may do the same in the future.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Reading the original report, I see no mentioning of the potential path or risk that leads to the issue. However in the escalation, the arguments are built upon the insights and finding of another report after submission. If the original report stands alone, I am not sure that it is convincing enough.\n> \n> This escalation also aims to clarify the rules for other Watsons who may do the same in the future.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**jacksanford1**\n\n@0xruhum I see what you're getting at. But the only way this can be a valid issue is if the protocol has intended for users to always be able to redeem USD1 into USDT when the reserve ratio is 100% or greater. I don't think Unitas has made that claim anywhere? If you see a claim like this (in comments or in code), please show me.\n\n**jacksanford1**\n\nUpdate @0xruhum: Based on the following sentence in the README, the broader point of this issue should be true:\n\n> The Unitas protocol guarantees unrestricted and unconditional conversion of its unitized stablecoins “back” to USD-pegged stablecoins.\n\nThe issue correct gets that \"users may not be able to fully redeem USD1 into USDT even when the reserve ratio is above 100%\" so this issue should be a valid Medium (maybe even High). But the portfolio aspect is not super unique, so it should be duplicated with any other issues that get the general idea of this vulnerability. \n\n**jacksanford1**\n\nEscalation accepted\n\nDuplicate of #13 \n\n**0xruhum**\n\n> But the portfolio aspect is not super unique, so it should be duplicated with any other issues that get the general idea of this vulnerability.\n\nYep. Just wanted to mention again that the issues I've linked in the original escalation comment aren't valid duplicates tho. That should be taken into account.\n\n**jacksanford1**\n\nOk @0xruhum, as far as I'm aware none of them are considered to be duplicates right now. \n\n**Jiamincoin**\n\n> Ok @0xruhum, as far as I'm aware none of them are considered to be duplicates right now.\n\nHey I think #114 should be taken into account too. \nI didn't create escalation because it was considered duplicate of the main report in the first place.\n\n\n\n\n**jacksanford1**\n\nOk @Jiamincoin, I agree that #114 is a duplicate of this issue. \n\n**0x00ffDa**\n\nI do not see any discussion of duplicate [#118](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/118).  Please consider it before ending the escalation evaluations.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xruhum](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/95/#issuecomment-1603137490): accepted\n- [thangtranth](https://github.com/sherlock-audit/2023-04-unitasprotocol-judging/issues/95/#issuecomment-1605657584): rejected\n\n**jacksanford1**\n\nAcknowledged by protocol team (won't fix). \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/73",
  "Code": [
    {
      "filename": "Unitas-Protocol/src/Unitas.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interfaces/IERC20Token.sol\";\nimport \"./interfaces/IInsurancePool.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IUnitas.sol\";\nimport \"./utils/AddressUtils.sol\";\nimport \"./utils/Errors.sol\";\nimport \"./utils/ScalingUtils.sol\";\nimport \"./SwapFunctions.sol\";\nimport \"./PoolBalances.sol\";\n\n/**\n * @title Unitas\n * @notice This contract is primarily used for exchanging tokens and managing reserve assets\n */\ncontract Unitas is\n    Initializable,\n    PausableUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IUnitas,\n    PoolBalances,\n    SwapFunctions\n{\n    using MathUpgradeable for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n    bytes32 public constant PORTFOLIO_ROLE = keccak256(\"PORTFOLIO_ROLE\");\n\n    IOracle public oracle;\n    address public surplusPool;\n    address public insurancePool;\n    ITokenManager public tokenManager;\n\n    /**\n     * @notice Emitted when `oracle` is updated\n     */\n    event SetOracle(address indexed newOracle);\n    /**\n     * @notice Emitted when `surplusPool` is updated\n     */\n    event SetSurplusPool(address indexed newSurplusPool);\n    /**\n     * @notice Emitted when `insurancePool` is updated\n     */\n    event SetInsurancePool(address indexed newInsurancePool);\n    /**\n     * @notice Emitted when `tokenManager` is updated\n     */\n    event SetTokenManager(ITokenManager indexed newTokenManager);\n    /**\n     * @notice Emitted when `sender` swap tokens\n     */\n    event Swapped(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        address indexed sender,\n        uint256 amountIn,\n        uint256 amountOut,\n        address feeToken,\n        uint256 fee,\n        uint24 feeNumerator,\n        uint256 price\n    );\n    /**\n     * @notice Emitted when swapping `fee` is sent to `receiver`\n     */\n    event SwapFeeSent(address indexed feeToken, address indexed receiver, uint256 fee);\n\n    // ============================== ERRORS ==============================\n\n    error NotTimelock(address caller);\n    error NotGuardian(address caller);\n    error NotPortfolio(address caller);\n\n    // ============================== MODIFIERS ==============================\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `TIMELOCK_ROLE`\n     */\n    modifier onlyTimelock() {\n        if (!hasRole(TIMELOCK_ROLE, msg.sender))\n            revert NotTimelock(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `GUARDIAN_ROLE`\n     */\n    modifier onlyGuardian() {\n        if (!hasRole(GUARDIAN_ROLE, msg.sender))\n            revert NotGuardian(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `account` does not have `PORTFOLIO_ROLE`\n     */\n    modifier onlyPortfolio(address account) {\n        if (!hasRole(PORTFOLIO_ROLE, account)) {\n            revert NotPortfolio(account);\n        }\n        _;\n    }\n\n\n    // ============================== CONSTRUCTOR ==============================\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract\n     * @param config_ `InitializeConfig` to init states\n     */\n    function initialize(InitializeConfig calldata config_) public initializer {\n        __Pausable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);\n        _setRoleAdmin(TIMELOCK_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(PORTFOLIO_ROLE, GUARDIAN_ROLE);\n\n        _grantRole(GOVERNOR_ROLE, config_.governor);\n        _grantRole(GUARDIAN_ROLE, config_.guardian);\n        _grantRole(TIMELOCK_ROLE, config_.timelock);\n        _grantRole(PORTFOLIO_ROLE, config_.guardian);\n\n        _setOracle(config_.oracle);\n        _setSurplusPool(config_.surplusPool);\n        _setInsurancePool(config_.insurancePool);\n        _setTokenManager(config_.tokenManager);\n    }\n\n    // ============================== Timelock FUNCTIONS ===========================\n\n    /**\n     * @notice Updates the address of `oracle` by `newOracle`\n     */\n    function setOracle(address newOracle) external onlyTimelock {\n        _setOracle(newOracle);\n    }\n\n    /**\n     * @notice Updates the address of `surplusPool` by `newSurplusPool`\n     */\n    function setSurplusPool(address newSurplusPool) external onlyTimelock {\n        _setSurplusPool(newSurplusPool);\n    }\n\n    /**\n     * @notice Updates the address of `insurancePool` by `newInsurancePool`\n     */\n    function setInsurancePool(address newInsurancePool) external onlyTimelock {\n        _setInsurancePool(newInsurancePool);\n    }\n\n    /**\n     * @notice Updates the address of `tokenManager`\n     */\n    function setTokenManager(ITokenManager newTokenManager) external onlyTimelock {\n        _setTokenManager(newTokenManager);\n    }\n\n    // ============================== GUARDIAN FUNCTIONS ===========================\n\n    /**\n     * @notice Pause token swapping\n     */\n    function pause() public onlyGuardian {\n        _pause();\n    }\n\n    /**\n     * @notice Resume token swapping\n     */\n    function unpause() public onlyGuardian {\n        _unpause();\n    }\n\n    // ============================== EXTERNAL FUNCTIONS ===========================\n\n    /**\n     * @notice Swaps tokens\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` spent\n     * @return amountOut The amount of `tokenOut` obtained\n     */\n    function swap(address tokenIn, address tokenOut, AmountType amountType, uint256 amount)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (uint256 amountIn, uint256 amountOut)\n    {\n        IERC20Token feeToken;\n        uint256 fee;\n        uint24 feeNumerator;\n        uint256 price;\n        ITokenManager.PairConfig memory pair = tokenManager.getPair(tokenIn, tokenOut);\n\n        (amountIn, amountOut, feeToken, fee, feeNumerator, price) = _getSwapResult(pair, tokenIn, tokenOut, amountType, amount);\n\n        _require(IERC20(tokenIn).balanceOf(msg.sender) >= amountIn, Errors.BALANCE_INSUFFICIENT);\n\n        _swapIn(tokenIn, msg.sender, amountIn);\n\n        _swapOut(tokenOut, msg.sender, amountOut);\n\n        if (fee > 0) {\n            address feeReceiver = surplusPool;\n            feeToken.mint(feeReceiver, fee);\n            emit SwapFeeSent(address(feeToken), feeReceiver, fee);\n        }\n\n        _checkReserveRatio(tokenOut == pair.baseToken ? pair.buyReserveRatioThreshold : pair.sellReserveRatioThreshold);\n\n        emit Swapped(tokenIn, tokenOut, msg.sender, amountIn, amountOut, address(feeToken), fee, feeNumerator, price);\n    }\n\n    /**\n     * @notice Receives the portfolio from caller\n     * @param token Address of the token\n     * @param amount Amount of the portfolio\n     */\n    function receivePortfolio(address token, uint256 amount)\n        external\n        onlyPortfolio(msg.sender)\n        nonReentrant\n    {\n        _receivePortfolio(token, msg.sender, amount);\n    }\n\n    /**\n     * @notice Sends the portfolio to the receiver\n     * @param token Address of the token\n     * @param receiver Account to receive the portfolio\n     * @param amount Amount of the portfolio\n     */\n    function sendPortfolio(address token, address receiver, uint256 amount)\n        external\n        onlyTimelock\n        onlyPortfolio(receiver)\n        nonReentrant\n    {\n        _sendPortfolio(token, receiver, amount);\n    }\n\n    /**\n     * @notice Estimates swapping result for quoting\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return feeToken The fee token\n     * @return fee Swapping fee calculated in `feeToken`\n     * @return feeNumerator The numerator of the fee fraction\n     * @return price The price of `tokenIn`/`tokenOut`\n     */\n    function estimateSwapResult(address tokenIn, address tokenOut, AmountType amountType, uint256 amount)\n        external\n        view\n        returns (uint256 amountIn, uint256 amountOut, IERC20Token feeToken, uint256 fee, uint24 feeNumerator, uint256 price)\n    {\n        ITokenManager.PairConfig memory pair = tokenManager.getPair(tokenIn, tokenOut);\n\n        (amountIn, amountOut, feeToken, fee, feeNumerator, price) = _getSwapResult(pair, tokenIn, tokenOut, amountType, amount);\n    }\n\n    // ============================== PUBLIC FUNCTIONS ==============================\n\n    /**\n     * @notice Gets the reserve of `token`\n     */\n    function getReserve(address token) public view returns (uint256) {\n        return _getBalance(token);\n    }\n\n    /**\n     * @notice Gets the portfolio of `token`\n     */\n    function getPortfolio(address token) public view returns (uint256) {\n        return _getPortfolio(token);\n    }\n\n    /**\n     * @notice Gets the reserve status\n     * @return reserveStatus `Undefined` when `reserves`, `collaterals` and `liabilities` are zero.\n                              `Infinite` when `liabilities` is zero.\n                              Otherwise `Finite`.\n     * @return reserves Total reserves denominated in USD1\n     * @return collaterals Total collaterals denominated in USD1\n     * @return liabilities Total liabilities denominated in USD1\n     * @return reserveRatio The numerator of the reserve ratio is expressed in 18 decimal places\n     */\n    function getReserveStatus()\n        public\n        view\n        returns (ReserveStatus reserveStatus, uint256 reserves, uint256 collaterals, uint256 liabilities, uint256 reserveRatio)\n    {\n        (reserves, collaterals) = _getTotalReservesAndCollaterals();\n        liabilities = _getTotalLiabilities();\n\n        (reserveStatus, reserveRatio) = _getReserveStatus(reserves + collaterals, liabilities);\n    }\n\n    // ============================== INTERNAL FUNCTIONS ==============================\n\n    function _setOracle(address newOracle) internal {\n        AddressUtils.checkContract(newOracle);\n        oracle = IOracle(newOracle);\n        emit SetOracle(newOracle);\n    }\n\n    function _setSurplusPool(address newSurplusPool) internal {\n        _require(newSurplusPool != address(0), Errors.ADDRESS_ZERO);\n        surplusPool = newSurplusPool;\n        emit SetSurplusPool(newSurplusPool);\n    }\n\n    function _setInsurancePool(address newInsurancePool) internal {\n        AddressUtils.checkContract(newInsurancePool);\n        insurancePool = newInsurancePool;\n        emit SetInsurancePool(newInsurancePool);\n    }\n\n    function _setTokenManager(ITokenManager newTokenManager) internal {\n        AddressUtils.checkContract(address(newTokenManager));\n        tokenManager = newTokenManager;\n        emit SetTokenManager(newTokenManager);\n    }\n\n    /**\n     * @notice Spends tokens for swapping\n     * @param token The address of the token\n     * @param spender The account to spend tokens\n     * @param amount The amount to be consumed\n     */\n    function _swapIn(address token, address spender, uint256 amount) internal {\n        ITokenManager.TokenType tokenType = tokenManager.getTokenType(token);\n\n        require(tokenType != ITokenManager.TokenType.Undefined);\n\n        if (tokenType == ITokenManager.TokenType.Asset) {\n            _setBalance(token, _getBalance(token) + amount);\n            IERC20(token).safeTransferFrom(spender, address(this), amount);\n        } else {\n            IERC20Token(token).burn(spender, amount);\n        }\n    }\n\n    /**\n     * @notice Receives tokens for swapping\n     * @param token The address of the token\n     * @param receiver The account to receive tokens\n     * @param amount The amount to be obtained\n     */\n    function _swapOut(address token, address receiver, uint256 amount) internal {\n        ITokenManager.TokenType tokenType = tokenManager.getTokenType(token);\n\n        require(tokenType != ITokenManager.TokenType.Undefined);\n\n        if (tokenType == ITokenManager.TokenType.Asset) {\n            uint256 tokenReserve = _getBalance(token);\n            uint256 reserveAmount = amount.min(tokenReserve - _getPortfolio(token));\n\n            if (amount > reserveAmount) {\n                uint256 collateralAmount = amount - reserveAmount;\n\n                // Pull the collateral from insurance pool\n                IInsurancePool(insurancePool).withdrawCollateral(token, collateralAmount);\n            }\n\n            _setBalance(token, tokenReserve - reserveAmount);\n            IERC20(token).safeTransfer(receiver, amount);\n        } else {\n            IERC20Token(token).mint(receiver, amount);\n        }\n    }\n\n    /**\n     * @notice Gets the swapping result\n     * @param pair The setting of the pair\n     * @param tokenIn The address of the token to be spent\n     * @param tokenOut The address of the token to be obtained\n     * @param amountType The type of the amount\n     * @param amount When `amountType` is `In`, it's the number of `tokenIn` that the user wants to spend.\n     *               When `amountType` is `Out`, it's the number of `tokenOut` that the user wants to obtain.\n     * @return amountIn The amount of `tokenIn` to be spent\n     * @return amountOut The amount of `tokenOut` to be obtained\n     * @return feeToken The fee token is always USD1\n     * @return fee Swapping fee calculated in USD1\n     * @return feeNumerator The numerator of the fee fraction\n     * @return price The price of `tokenIn`/`tokenOut`\n     */\n    function _getSwapResult(\n        ITokenManager.PairConfig memory pair,\n        address tokenIn,\n        address tokenOut,\n        AmountType amountType,\n        uint256 amount\n    )\n        internal\n        view\n        returns (uint256 amountIn, uint256 amountOut, IERC20Token feeToken, uint256 fee, uint24 feeNumerator, uint256 price)\n    {\n        _checkAmountPositive(amount);\n\n        // Checks the tokens of the pair config are valid\n        bool isBuy = tokenOut == pair.baseToken;\n        _require(\n            (isBuy && tokenIn == pair.quoteToken) ||\n                (tokenOut == pair.quoteToken && tokenIn == pair.baseToken),\n            Errors.PAIR_INVALID\n        );\n\n        address priceQuoteToken = _getPriceQuoteToken(tokenIn, tokenOut);\n        price = oracle.getLatestPrice(priceQuoteToken);\n        _checkPrice(priceQuoteToken, price);\n\n        feeNumerator = isBuy ? pair.buyFee : pair.sellFee;\n        feeToken = IERC20Token(priceQuoteToken == tokenIn ? tokenOut : tokenIn);\n\n        SwapRequest memory request;\n        request.tokenIn = tokenIn;\n        request.tokenOut = tokenOut;\n        request.amountType = amountType;\n        request.amount = amount;\n        request.feeNumerator = feeNumerator;\n        request.feeBase = tokenManager.SWAP_FEE_BASE();\n        request.feeToken = address(feeToken);\n        request.price = price;\n        request.priceBase = 10 ** oracle.decimals();\n        request.quoteToken = priceQuoteToken;\n\n        (amountIn, amountOut, fee) = _calculateSwapResult(request);\n\n        _require(amountIn > 0 && amountOut > 0, Errors.SWAP_RESULT_INVALID);\n\n        if (tokenIn == priceQuoteToken) {\n            // The base currency of oracle price is USD1, inverts the price when buying USD1\n            price = request.priceBase * request.priceBase / price;\n        }\n    }\n\n    /**\n     * @notice Gets the reserve status and reserve ratio.\n     * @param allReserves Sum of the reserves and the collaterals denominated in USD1\n     * @param liabilities Total liabilities denominated in USD1\n     * @return reserveStatus `Undefined` when `allReserves` and `liabilities` are zero.\n                              `Infinite` when `liabilities` is zero.\n                              Otherwise `Finite`.\n     * @return reserveRatio The numerator of the reserve ratio is expressed in 18 decimal places\n     */\n    function _getReserveStatus(uint256 allReserves, uint256 liabilities)\n        internal\n        view\n        returns (ReserveStatus reserveStatus, uint256 reserveRatio)\n    {\n        if (liabilities == 0) {\n            reserveStatus = allReserves == 0 ? ReserveStatus.Undefined : ReserveStatus.Infinite;\n        } else {\n            reserveStatus = ReserveStatus.Finite;\n\n            // All decimals of parameters are the same as USD1\n            uint256 valueBase = 10 ** tokenManager.usd1().decimals();\n\n            reserveRatio = ScalingUtils.scaleByBases(\n                allReserves * valueBase / liabilities,\n                valueBase,\n                tokenManager.RESERVE_RATIO_BASE()\n            );\n        }\n    }\n\n    /**\n     * @notice Gets total reserves and total collaterals in USD1\n     */\n    function _getTotalReservesAndCollaterals() internal view returns (uint256 reserves, uint256 collaterals) {\n        address baseToken = address(tokenManager.usd1());\n        uint8 tokenTypeValue = uint8(ITokenManager.TokenType.Asset);\n        uint256 tokenCount = tokenManager.tokenLength(tokenTypeValue);\n        uint256 priceBase = 10 ** oracle.decimals();\n\n        for (uint256 i; i < tokenCount; i++) {\n            address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n            uint256 tokenReserve = _getBalance(token);\n            uint256 tokenCollateral = IInsurancePool(insurancePool).getCollateral(token);\n\n            if (tokenReserve > 0 || tokenCollateral > 0) {\n                uint256 price = oracle.getLatestPrice(token);\n\n                reserves += _convert(\n                    token,\n                    baseToken,\n                    tokenReserve,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n\n                collaterals += _convert(\n                    token,\n                    baseToken,\n                    tokenCollateral,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Gets total liabilities in USD1\n     */\n    function _getTotalLiabilities() internal view returns (uint256 liabilities) {\n        address baseToken = address(tokenManager.usd1());\n        uint8 tokenTypeValue = uint8(ITokenManager.TokenType.Stable);\n        uint256 tokenCount = tokenManager.tokenLength(tokenTypeValue);\n        uint256 priceBase = 10 ** oracle.decimals();\n\n        for (uint256 i; i < tokenCount; i++) {\n            address token = tokenManager.tokenByIndex(tokenTypeValue, i);\n            uint256 tokenSupply = IERC20Token(token).totalSupply();\n\n            if (token == baseToken) {\n                // Adds up directly when the token is USD1\n                liabilities += tokenSupply;\n            } else if (tokenSupply > 0) {\n                uint256 price = oracle.getLatestPrice(token);\n\n                liabilities += _convert(\n                    token,\n                    baseToken,\n                    tokenSupply,\n                    MathUpgradeable.Rounding.Down,\n                    price,\n                    priceBase,\n                    token\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Gets the quote token of oracle price by two token addresses.\n     *          Because of the base currencies of all oracle prices are always USD1 (e.g., USD1/USDT and USD1/USD91),\n     *          one of `tokenX` or `tokenY` must be USD1, and the other must not be USD1.\n     * @dev The caller must ensure that both tokens are in the pool\n     * @param tokenX Address of base currency or quote currency\n     * @param tokenY Address of base currency or quote currency\n     * @return quoteToken The quote currency of oracle price\n     */\n    function _getPriceQuoteToken(address tokenX, address tokenY) internal view returns (address quoteToken) {\n        _require(tokenX != tokenY, Errors.PAIR_INVALID);\n\n        address baseToken = address(tokenManager.usd1());\n        _require(baseToken != address(0), Errors.USD1_NOT_SET);\n\n        bool isXBase = tokenX == baseToken;\n        _require(isXBase || tokenY == baseToken, Errors.PAIR_INVALID);\n\n        quoteToken = isXBase ? tokenY : tokenX;\n    }\n\n    /**\n     * @notice Reverts if the price or the tolerance range is invalid\n     * @param quoteToken Address of quote token to get the tolerance range\n     * @param price The price of USD1/`quoteToken`\n     */\n    function _checkPrice(address quoteToken, uint256 price) internal view {\n        (uint256 minPrice, uint256 maxPrice) = tokenManager.getPriceTolerance(quoteToken);\n\n        _require(minPrice > 0 && maxPrice > 0, Errors.PRICE_TOLERANCE_INVALID);\n        _require(minPrice <= price && price <= maxPrice, Errors.PRICE_INVALID);\n    }\n\n    /**\n     * @notice Checks the reserve ratio is sufficient when `reserveRatioThreshold` is greater than zero\n     */\n    function _checkReserveRatio(uint232 reserveRatioThreshold) internal view {\n        if (reserveRatioThreshold == 0) {\n            return;\n        } else {\n            (uint256 reserves, uint256 collaterals) = _getTotalReservesAndCollaterals();\n            uint256 allReserves = reserves + collaterals;\n            uint256 liabilities = _getTotalLiabilities();\n\n            (ReserveStatus reserveStatus, uint256 reserveRatio) = _getReserveStatus(allReserves, liabilities);\n\n            if (reserveStatus != ReserveStatus.Infinite) {\n                _require(reserveRatio > reserveRatioThreshold, Errors.RESERVE_RATIO_NOT_GREATER_THAN_THRESHOLD);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "Unitas-Protocol/src/PoolBalances.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./utils/AddressUtils.sol\";\nimport \"./utils/Errors.sol\";\n\n/**\n * @title PoolBalances\n * @notice The abstract contract includes some generic functions and states that are used to manage pool assets\n *\n * @custom:storage-size 50\n */\nabstract contract PoolBalances {\n    using MathUpgradeable for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Maps the address to the balance of the token\n     */\n    mapping(address => uint256) internal _balance;\n    /**\n     * @notice Maps the address to the portfolio of the token\n     */\n    mapping(address => uint256) internal _portfolio;\n\n    /**\n     * @notice Emitted when the balance of `token` is updated to `newBalance`\n     */\n    event BalanceUpdated(address indexed token, uint256 newBalance);\n    /**\n     * @notice Emitted when portfolio `amount` of `token` is received from `sender`\n     */\n    event PortfolioReceived(address indexed token, address indexed sender, uint256 amount);\n    /**\n     * @notice Emitted when portfolio `amount` of `token` is sent to `receiver`\n     */\n    event PortfolioSent(address indexed token, address indexed receiver, uint256 amount);\n    /**\n     * @notice Emitted when the portfolio of `token` is updated to `newPortfolio`\n     */\n    event PortfolioUpdated(address indexed token, uint256 newPortfolio);\n\n    /**\n     * @notice Updates the balance of `token` to `newBalance`\n     */\n    function _setBalance(address token, uint256 newBalance) internal virtual {\n        _balance[token] = newBalance;\n        emit BalanceUpdated(token, newBalance);\n    }\n\n    /**\n     * @notice Updates the portfolio of `token` to `newPortfolio`\n     */\n    function _setPortfolio(address token, uint256 newPortfolio) internal virtual {\n        _portfolio[token] = newPortfolio;\n        emit PortfolioUpdated(token, newPortfolio);\n    }\n\n    /**\n     * @notice Receives portfolio `amount` of `token` from `sender`\n     */\n    function _receivePortfolio(address token, address sender, uint256 amount) internal virtual {\n        AddressUtils.checkNotZero(token);\n        AddressUtils.checkNotZero(sender);\n        _checkAmountPositive(amount);\n        _require(sender != address(this), Errors.SENDER_INVALID);\n\n        uint256 portfolio = _getPortfolio(token);\n        _require(amount <= portfolio, Errors.AMOUNT_INVALID);\n\n        _setPortfolio(token, portfolio - amount);\n\n        IERC20(token).safeTransferFrom(sender, address(this), amount);\n\n        emit PortfolioReceived(token, sender, amount);\n    }\n\n    /**\n     * @notice Sends portfolio `amount` of `token` to `receiver`\n     */\n    function _sendPortfolio(address token, address receiver, uint256 amount) internal virtual {\n        AddressUtils.checkNotZero(token);\n        AddressUtils.checkNotZero(receiver);\n        _checkAmountPositive(amount);\n        _require(receiver != address(this), Errors.RECEIVER_INVALID);\n\n        uint256 portfolio = _getPortfolio(token);\n        amount = amount.min(_getBalance(token) - portfolio);\n\n        _require(amount > 0, Errors.POOL_BALANCE_INSUFFICIENT);\n\n        _setPortfolio(token, portfolio + amount);\n\n        IERC20(token).safeTransfer(receiver, amount);\n\n        emit PortfolioSent(token, receiver, amount);\n    }\n\n    /**\n     * @notice Gets the current balance of `token`\n     */\n    function _getBalance(address token) internal view virtual returns (uint256) {\n        return _balance[token];\n    }\n\n    /**\n     * @notice Gets the current portfolio of `token`\n     */\n    function _getPortfolio(address token) internal view virtual returns (uint256) {\n        return _portfolio[token];\n    }\n\n    /**\n     * @notice Reverts if `amount` is zero or negative\n     */\n    function _checkAmountPositive(uint256 amount) internal pure {\n        _require(amount > 0, Errors.AMOUNT_INVALID);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "Unitas-Protocol/src/Unitas.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./interfaces/IERC20Token.sol\";\nimport \"./interfaces/IInsurancePool.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IUnitas.sol\";\nimport \"./utils/AddressUtils.sol\";\nimport \"./utils/Errors.sol\";\nimport \"./utils/ScalingUtils.sol\";\nimport \"./SwapFunctions.sol\";\nimport \"./PoolBalances.sol\";\n\n/**\n * @title Unitas\n * @notice This contract is primarily used for exchanging tokens and managing reserve assets\n */\ncontract Unitas is\n    Initializable,\n    PausableUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IUnitas,\n    PoolBalances,\n    SwapFunctions\n{\n    using MathUpgradeable for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n    bytes32 public constant PORTFOLIO_ROLE = keccak256(\"PORTFOLIO_ROLE\");\n\n    IOracle public oracle;\n    address public surplusPool;\n    address public insurancePool;\n    ITokenManager public tokenManager;\n\n    /**\n     * @notice Emitted when `oracle` is updated\n     */\n    event SetOracle(address indexed newOracle);\n    /**\n     * @notice Emitted when `surplusPool` is updated\n     */\n    event SetSurplusPool(address indexed newSurplusPool);\n    /**\n     * @notice Emitted when `insurancePool` is updated\n     */\n    event SetInsurancePool(address indexed newInsurancePool);\n    /**\n     * @notice Emitted when `tokenManager` is updated\n     */\n    event SetTokenManager(ITokenManager indexed newTokenManager);\n    /**\n     * @notice Emitted when `sender` swap tokens\n     */\n    event Swapped(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        address indexed sender,\n        uint256 amountIn,\n        uint256 amountOut,\n        address feeToken,\n        uint256 fee,\n        uint24 feeNumerator,\n        uint256 price\n    );\n    /**\n     * @notice Emitted when swapping `fee` is sent to `receiver`\n     */\n    event SwapFeeSent(address indexed feeToken, address indexed receiver, uint256 fee);\n\n    // ============================== ERRORS ==============================\n\n    error NotTimelock(address caller);\n    error NotGuardian(address caller);\n    error NotPortfolio(address caller);\n\n    // ============================== MODIFIERS ==============================\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `TIMELOCK_ROLE`\n     */\n    modifier onlyTimelock() {\n        if (!hasRole(TIMELOCK_ROLE, msg.sender))\n            revert NotTimelock(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `msg.sender` does not have `GUARDIAN_ROLE`\n     */\n    modifier onlyGuardian() {\n        if (!hasRole(GUARDIAN_ROLE, msg.sender))\n            revert NotGuardian(msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Reverts if `account` does not have `PORTFOLIO_ROLE`\n     */\n    modifier onlyPortfolio(address account) {\n        if (!hasRole(PORTFOLIO_ROLE, account)) {\n            revert NotPortfolio(account);\n        }\n        _;\n    }\n\n\n    // ============================== CONSTRUCTOR ==============================\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the contract\n     * @param config_ `InitializeConfig` to init states\n     */\n    function initialize(InitializeConfig calldata config_) public initializer {\n        __Pausable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);\n        _setRoleAdmin(TIMELOCK_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(PORTFOLIO_ROLE, GUARDIAN_ROLE);\n\n        _grantRole(GOVERNOR_ROLE, config_.governor);\n        _grantRole(GUARDIAN_ROLE, config_.guardian);\n        _grantRole(TIMELOCK_ROLE, config_.timelock);\n        _grantRole(PORTFOLIO_ROLE, config_.guardian);\n\n        _setOracle(config_.oracle);\n        _setSurplusPool(config_.surplusPool);\n        _setInsurancePool(config_.insurancePool);\n        _setTokenManager(config_.tokenManager);\n    }\n\n    // ============================== Timelock FUNCTIONS ===========================\n\n    /**\n     * @notice Updates the address of `oracle` by `newOracle`\n     */\n    function setOracle(address newOracle) external onlyTimelock {\n        _setOracle(newOracle);\n    }\n\n    /**\n     * @notice Updates the address of `surplusPool` by `newSurplusPool`\n     */\n    function setSurplusPool(address newSurplusPool) external onlyTimelock {\n        _setSurplusPool(newSurplusPool);\n    }\n\n    /**\n     * @notice Updates the address of `insurancePool` by `newInsurancePool`\n     */\n    function setInsurancePool(address newInsur"
    }
  ]
}