{
  "Title": "H-2: Possible DOS in RollerPeriphery `approve()` function",
  "Content": "# Issue H-2: Possible DOS in RollerPeriphery `approve()` function \n\nSource: https://github.com/sherlock-audit/2022-11-sense-judging/issues/46 \n\n## Found by \nminhquanym\n\n## Summary\nhttps://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/RollerPeriphery.sol#L100-L102\n\n## Vulnerability Detail\nFunction `approve(...)` is public and can be called by anyone, so attacker can simply call this function with `amount = 0`. This will effectively prevent depositing/minting in vault.\n\n## Impact\nDOS minting and depositing functionalities in RollerPeriphery\n\n## Code Snippet\n```solidity\nfunction approve(ERC20 token, address to, uint256 amount) public payable {\n    token.safeApprove(to, amount); // @audit front-run DOS  \n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider only allowing authorized actors to call `approve()` function. \nOr only allowing approve to `type(uint).max` value.\n\n\n\n\n## Discussion\n\n**aktech297**\n\nFix is done such that the approve function can be called by trusted caller. \nI see changes like importing the Trust from sense-v1 and setting the trusted address during contract creation.\n\n**jparklev**\n\nFix: https://github.com/sense-finance/auto-roller/pull/15\n\n**aktech297**\n\nFixes are confirmed...\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/19",
  "Code": [
    {
      "filename": "contracts/src/RollerPeriphery.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.13;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\n\nimport { AutoRoller } from \"./AutoRoller.sol\";\n\n// Inspired by https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626Router.sol\ncontract RollerPeriphery {\n    using SafeTransferLib for ERC20;\n\n    /// @notice thrown when amount of assets received is below the min set by caller.\n    error MinAssetError();\n\n    /// @notice thrown when amount of shares received is below the min set by caller.\n    error MinSharesError();\n\n    /// @notice thrown when amount of assets received is above the max set by caller.\n    error MaxAssetError();\n\n    /// @notice thrown when amount of shares received is above the max set by caller.\n    error MaxSharesError();\n\n    /// @notice thrown when amount of assets or excess received is below the max set by caller.\n    error MinAssetsOrExcessError();\n\n    /// @notice Redeem vault shares with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param shares Number of shares to redeem\n    /// @param receiver Destination address for the returned assets\n    /// @param minAmountOut Minimum amount of assets returned\n    /// @return assets Amount of asset redeemable by the given number of shares\n    function redeem(ERC4626 vault, uint256 shares, address receiver, uint256 minAmountOut) external returns (uint256 assets) {\n        if ((assets = vault.redeem(shares, receiver, msg.sender)) < minAmountOut) {\n            revert MinAssetError();\n        }\n    }\n\n    /// @notice Withdraw underlying asset from vault with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param assets Amount of asset requested for withdrawal\n    /// @param receiver Destination address for the returned assets\n    /// @param maxSharesOut Maximum amount of shares burned\n    /// @return shares Number of shares to redeem\n    function withdraw(ERC4626 vault, uint256 assets, address receiver, uint256 maxSharesOut) external returns (uint256 shares) {\n        if ((shares = vault.withdraw(assets, receiver, msg.sender)) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n    }\n\n    /// @notice Mint vault shares with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of assets pulled from msg.sender\n    /// @return assets Amount of asset pulled from msg.sender and used to mint vault shares\n    function mint(ERC4626 vault, uint256 shares, address receiver, uint256 maxAmountIn) external returns (uint256 assets) {\n        ERC20(vault.asset()).safeTransferFrom(msg.sender, address(this), vault.previewMint(shares));\n\n        if ((assets = vault.mint(shares, receiver)) > maxAmountIn) {\n            revert MaxAssetError();\n        }\n    }\n\n    /// @notice Deposit underlying asset into vault with slippage protection \n    /// @param vault ERC4626 vault\n    /// @param assets Amount of asset pulled from msg.sender and used to mint vault shares\n    /// @param receiver Destination address for the returned shares\n    /// @param minSharesOut Minimum amount of returned shares\n    /// @return shares Number of shares minted by the vault and returned to msg.sender\n    function deposit(ERC4626 vault, uint256 assets, address receiver, uint256 minSharesOut) external returns (uint256 shares) {\n        ERC20(vault.asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n        if ((shares = vault.deposit(assets, receiver)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @notice Quick exit into the constituent assets with slippage protection\n    /// @param vault ERC4626 vault.\n    /// @param shares Number of shares to eject with.\n    /// @param receiver Destination address for the constituent assets.\n    /// @param minAssetsOut Minimum amount of assets returned\n    /// @param minExcessOut Minimum excess PT/YT returned \n    /// @return assets Amount of asset redeemable by the given number of shares.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function eject(ERC4626 vault, uint256 shares, address receiver, uint256 minAssetsOut, uint256 minExcessOut)\n        external returns (uint256 assets, uint256 excessBal, bool isExcessPTs)\n    {\n        (assets, excessBal, isExcessPTs) = AutoRoller(address(vault)).eject(shares, receiver, msg.sender);\n\n        if (assets < minAssetsOut || excessBal < minExcessOut) {\n            revert MinAssetsOrExcessError();\n        }\n    }\n\n    function approve(ERC20 token, address to, uint256 amount) public payable {\n        token.safeApprove(to, amount);\n    }\n}"
    }
  ]
}