{
  "Title": "Input parameters in `notify()` not checked",
  "Content": "##### Description\n`notify()` can be called with `amount` equal to zero:\nhttps://github.com/keep3r-network/StakingRewardsV3/blob/13ecc6966ae1a413f62224382bfd4d64b1a22351/contracts/StakingRewardsV3-1.sol#L299\n##### Recommendation\nIt is recommended to add `require(amount > 0, \"Incorrect input data\")` in function `notify()`.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/StakingRewardsV3-1.sol",
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-09-13\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nlibrary Math {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                )\n            )\n        ));\n    }\n}\n\ninterface erc20 {\n    function transfer(address recipient, uint amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface PositionManagerV3 {\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function safeTransferFrom(address from, address to, uint tokenId) external;\n\n    function ownerOf(uint tokenId) external view returns (address);\n    function transferFrom(address from, address to, uint tokenId) external;\n     function collect(CollectParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n}\n\ninterface UniV3 {\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n    function liquidity() external view returns (uint128);\n    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, uint8, bool);\n}\n\ncontract StakingRewardsV3 {\n\n    address immutable public reward;\n    address immutable public pool;\n\n    address constant factory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n    PositionManagerV3 constant nftManager = PositionManagerV3(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n    uint constant DURATION = 7 days;\n    uint constant PRECISION = 10 ** 18;\n\n    uint rewardRate;\n    uint periodFinish;\n    uint lastUpdateTime;\n    uint rewardPerLiquidityStored;\n    uint public forfeit;\n\n    mapping(uint => uint) public tokenRewardPerLiquidityPaid;\n    mapping(uint => uint) public rewards;\n\n    address immutable owner;\n\n    struct time {\n        uint32 timestamp;\n        uint32 secondsInside;\n    }\n\n    mapping(uint => time) public elapsed;\n    mapping(uint => address) public owners;\n    mapping(address => uint[]) public tokenIds;\n    mapping(uint => uint) public liquidityOf;\n    uint public totalLiquidity;\n\n    uint public earned0;\n    uint public earned1;\n\n    event RewardPaid(address indexed sender, uint tokenId, uint reward);\n    event RewardAdded(address indexed sender, uint reward);\n    event Deposit(address indexed sender, uint tokenId, uint liquidity);\n    event Withdraw(address indexed sender, uint tokenId, uint liquidity);\n    event Collect(address indexed sender, uint tokenId, uint amount0, uint amount1);\n\n    constructor(address _reward, address _pool) {\n        reward = _reward;\n        pool = _pool;\n        owner = msg.sender;\n    }\n\n    function getTokenIds(address _owner) external view returns (uint[] memory) {\n        return tokenIds[_owner];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerLiquidity() public view returns (uint) {\n        if (totalLiquidity == 0) {\n            return rewardPerLiquidityStored;\n        }\n        return rewardPerLiquidityStored + ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * PRECISION / totalLiquidity);\n    }\n\n    function collect(uint tokenId) external {\n        _collect(tokenId);\n    }\n\n    function _collect(uint tokenId) internal {\n        if (owners[tokenId] != address(0)) {\n            PositionManagerV3.CollectParams memory _claim = PositionManagerV3.CollectParams(tokenId, owner, type(uint128).max, type(uint128).max);\n            (uint amount0, uint amount1) = nftManager.collect(_claim);\n            earned0 += amount0;\n            earned1 += amount1;\n            emit Collect(msg.sender, tokenId, amount0, amount1);\n        }\n    }\n\n    function earned(uint tokenId) public view returns (uint claimable, uint32 secondsInside, uint128 liquidity, uint forfeited) {\n        (int24 _tickLower, int24 _tickUpper) = (0,0);\n        (,,,,,_tickLower,_tickUpper,liquidity,,,,) = nftManager.positions(tokenId);\n        (,,secondsInside) = UniV3(pool).snapshotCumulativesInside(_tickLower, _tickUpper);\n        (,int24 _tick,,,,,) = UniV3(pool).slot0();\n\n\n        uint _liquidity = liquidityOf[tokenId];\n        if (_liquidity > 0) {\n            time memory _elapsed = elapsed[tokenId];\n\n            uint _maxSecondsElapsed = lastTimeRewardApplicable() - Math.min(_elapsed.timestamp, periodFinish);\n            if (_maxSecondsElapsed > 0) {\n                uint _secondsInside = Math.min(_maxSecondsElapsed, (secondsInside - _elapsed.secondsInside));\n\n                uint _reward = (_liquidity * (rewardPerLiquidity() - tokenRewardPerLiquidityPaid[tokenId]) / PRECISION);\n                uint _earned = _reward * _secondsInside / _maxSecondsElapsed;\n                forfeited = _reward - _earned;\n                claimable = _earned;\n            }\n\n            if (_tickLower > _tick || _tick > _tickUpper) {\n                forfeited = claimable;\n                claimable = 0;\n                liquidity = 0;\n            }\n        }\n        claimable += rewards[tokenId];\n    }\n\n    function getRewardForDuration() external view returns (uint) {\n        return rewardRate * DURATION;\n    }\n\n    function deposit(uint tokenId) external update(tokenId) {\n        (,,address token0,address token1,uint24 fee,int24 tickLower,int24 tickUpper,uint128 _liquidity,,,,) = nftManager.positions(tokenId);\n        address _pool = PoolAddress.computeAddress(factory,PoolAddress.PoolKey({token0: token0, token1: token1, fee: fee}));\n\n        require(pool == _pool);\n        require(_liquidity > 0);\n\n        (,int24 _tick,,,,,) = UniV3(_pool).slot0();\n        require(tickLower < _tick && _tick < tickUpper);\n\n        owners[tokenId] = msg.sender;\n        tokenIds[msg.sender].push(tokenId);\n\n        nftManager.transferFrom(msg.sender, address(this), tokenId);\n\n        emit Deposit(msg.sender, tokenId, _liquidity);\n    }\n\n    function _findIndex(uint[] memory array, uint element) internal pure returns (uint i) {\n        for (i = 0; i < array.length; i++) {\n            if (array[i] == element) {\n                break;\n            }\n        }\n    }\n\n    function _remove(uint[] storage array, uint element) internal {\n        uint _index = _findIndex(array, element);\n        uint _length = array.length;\n        if (_index >= _length) return;\n        if (_index < _length-1) {\n            array[_index] = array[_length-1];\n        }\n\n        array.pop();\n    }\n\n    function withdraw(uint tokenId) public update(tokenId) {\n        _collect(tokenId);\n        _withdraw(tokenId);\n    }\n\n    function _withdraw(uint tokenId) internal {\n        require(owners[tokenId] == msg.sender);\n        uint _liquidity = liquidityOf[tokenId];\n        liquidityOf[tokenId] = 0;\n        totalLiquidity -= _liquidity;\n        owners[tokenId] = address(0);\n        _remove(tokenIds[msg.sender], tokenId);\n        nftManager.safeTransferFrom(address(this), msg.sender, tokenId);\n\n        emit Withdraw(msg.sender, tokenId, _liquidity);\n    }\n\n    function getRewards() external {\n        uint[] memory _tokens = tokenIds[msg.sender];\n        for (uint i = 0; i < _tokens.length; i++) {\n            getReward(_tokens[i]);\n        }\n    }\n\n    function getReward(uint tokenId) public update(tokenId) {\n        _collect(tokenId);\n        uint _reward = rewards[tokenId];\n        if (_reward > 0) {\n            rewards[tokenId] = 0;\n            _safeTransfer(reward, _getRecipient(tokenId), _reward);\n\n            emit RewardPaid(msg.sender, tokenId, _reward);\n        }\n    }\n\n    function _getRecipient(uint tokenId) internal view returns (address) {\n        if (owners[tokenId] != address(0)) {\n            return owners[tokenId];\n        } else {\n            return nftManager.ownerOf(tokenId);\n        }\n    }\n\n    function withdraw() external {\n        uint[] memory _tokens = tokenIds[msg.sender];\n        for (uint i = 0; i < _tokens.length; i++) {\n            withdraw(_tokens[i]);\n        }\n    }\n\n    function deposit_reward_token(address token, uint _reward) external {\n        require(token == reward);\n        notify(_reward);\n    }\n\n    function notify(uint amount) public update(0) {\n        require(msg.sender == owner);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish - block.timestamp;\n            uint _leftover = _remaining * rewardRate;\n\n            rewardRate = (amount + _leftover) / DURATION;\n        }\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + DURATION;\n\n        _safeTransferFrom(reward, msg.sender, address(this), amount);\n        emit RewardAdded(msg.sender, amount);\n    }\n\n    function refund() external {\n        require(msg.sender == owner);\n        uint _forfeit = forfeit;\n        forfeit = 0;\n\n        _safeTransfer(reward, owner, _forfeit);\n    }\n\n    modifier update(uint tokenId) {\n        uint _rewardPerLiquidityStored = rewardPerLiquidity();\n        uint _lastUpdateTime = lastTimeRewardApplicable();\n        rewardPerLiquidityStored = _rewardPerLiquidityStored;\n        lastUpdateTime = _lastUpdateTime;\n        if (tokenId != 0) {\n            (uint _reward, uint32 _secondsInside, uint _liquidity, uint _forfeited) = earned(tokenId);\n            tokenRewardPerLiquidityPaid[tokenId] = _rewardPerLiquidityStored;\n            rewards[tokenId] = _reward;\n            forfeit += _forfeited;\n\n            if (elapsed[tokenId].timestamp < _lastUpdateTime) {\n                elapsed[tokenId] = time(uint32(_lastUpdateTime), _secondsInside);\n            }\n\n            uint _currentLiquidityOf = liquidityOf[tokenId];\n            if (_currentLiquidityOf != _liquidity) {\n                totalLiquidity -= _currentLiquidityOf;\n                liquidityOf[tokenId] = _liquidity;\n                totalLiquidity += _liquidity;\n            }\n        }\n        _;\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}"
    }
  ]
}