{
  "Title": "[M-04] Sandwich attack on astroport sweep",
  "Content": "\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts%2Fanchor-token-contracts%2Fcontracts%2Fcollector%2Fsrc%2Fcontract.rs#L130-L137>\n\nThe collector contract allows anyone to `sweep`, swapping an asset token to ANC through astro port.<br>\nNote that `belief_price` is not set and `config.max_spread` might not be set as well or misconfigured.\n\nThis allows an attacker to create a contract to perform a sandwich attack to make a profit on this trade.\n\n> A common attack in DeFi is the sandwich attack. Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone’s going to buy an asset, and that this trade will increase its price, to make a profit. The attacker’s plan is to buy this asset cheap, let the victim buy at an increased price, and then sell the received amount again at a higher price afterwards.\n\nTrades can happen at a bad price and lead to receiving fewer tokens than at a fair market price.<br>\nThe attacker's profit is the protocol's loss.\n\n### Proof of Concept\n\nAttacker creates a contract that triggers 3 messages for the sandwich attack:\n\n*   Astroport: buy ANC with asset\n*   Call `sweep` which trades at bad price\n*   Astroport: sell assets from the first message for profit\n\n### Recommended Mitigation Steps\n\nConsider setting a ANC/asset `belief_price` from an oracle.\n\n**[bitn8 (Anchor) disagreed with severity and commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/33#issuecomment-1103023318):**\n > While it might certainly be possible to sandwich an attack like this, there is no risk to users' funds outside a possible bad fill price. There are many other issues at work here too such as UNI v2 that Astro is built on and volatility. This assumes very illiquid markets or huge wallets to move prices like this. \n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/33#issuecomment-1207282229):**\n > - Anyone can call = can set up a price imbalance\n> - Is a sweep (prob dust amount)\n> \n> Looks valid but impact seems reduced.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts%2Fanchor-token-contracts%2Fcontracts%2Fcollector%2Fsrc%2Fcontract.rs",
      "content": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse cosmwasm_std::{\n    attr, to_binary, Addr, Binary, Coin, CosmosMsg, Decimal, Deps, DepsMut, Env, MessageInfo,\n    Reply, Response, StdError, StdResult, SubMsg, WasmMsg,\n};\n\nuse crate::state::{read_config, store_config, Config};\n\nuse crate::migration::migrate_config;\nuse anchor_token::collector::{ConfigResponse, ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\nuse astroport::asset::{Asset, AssetInfo, PairInfo};\nuse astroport::pair::ExecuteMsg as AstroportExecuteMsg;\nuse astroport::querier::{query_balance, query_pair_info, query_token_balance};\nuse cw20::Cw20ExecuteMsg;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    store_config(\n        deps.storage,\n        &Config {\n            gov_contract: deps.api.addr_canonicalize(&msg.gov_contract)?,\n            astroport_factory: deps.api.addr_canonicalize(&msg.astroport_factory)?,\n            anchor_token: deps.api.addr_canonicalize(&msg.anchor_token)?,\n            reward_factor: msg.reward_factor,\n            max_spread: msg.max_spread,\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> StdResult<Response> {\n    match msg {\n        ExecuteMsg::UpdateConfig {\n            reward_factor,\n            gov_contract,\n            astroport_factory,\n            max_spread,\n        } => update_config(\n            deps,\n            info,\n            reward_factor,\n            gov_contract,\n            astroport_factory,\n            max_spread,\n        ),\n        ExecuteMsg::Sweep { denom } => sweep(deps, env, denom),\n    }\n}\n\npub fn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    reward_factor: Option<Decimal>,\n    gov_contract: Option<String>,\n    astroport_factory: Option<String>,\n    max_spread: (bool, Option<Decimal>),\n) -> StdResult<Response> {\n    let mut config: Config = read_config(deps.storage)?;\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.gov_contract {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if let Some(reward_factor) = reward_factor {\n        config.reward_factor = reward_factor;\n    }\n\n    if let Some(gov_contract) = gov_contract {\n        config.gov_contract = deps.api.addr_canonicalize(gov_contract.as_str())?;\n    }\n    if let Some(astroport_factory) = astroport_factory {\n        config.astroport_factory = deps.api.addr_canonicalize(astroport_factory.as_str())?;\n    }\n\n    if max_spread.0 {\n        config.max_spread = max_spread.1\n    }\n\n    store_config(deps.storage, &config)?;\n    Ok(Response::default())\n}\n\nconst SWEEP_REPLY_ID: u64 = 1;\n\n/// Sweep\n/// Anyone can execute sweep function to swap\n/// asset token => ANC token and distribute\n/// result ANC token to gov contract\npub fn sweep(deps: DepsMut, env: Env, denom: String) -> StdResult<Response> {\n    let config: Config = read_config(deps.storage)?;\n    let anchor_token = deps.api.addr_humanize(&config.anchor_token)?;\n    let astroport_factory_addr = deps.api.addr_humanize(&config.astroport_factory)?;\n\n    let pair_info: PairInfo = query_pair_info(\n        &deps.querier,\n        astroport_factory_addr,\n        &[\n            AssetInfo::NativeToken {\n                denom: denom.to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: Addr::unchecked(anchor_token),\n            },\n        ],\n    )?;\n\n    let amount = query_balance(&deps.querier, env.contract.address, denom.to_string())?;\n\n    let swap_asset = Asset {\n        info: AssetInfo::NativeToken {\n            denom: denom.to_string(),\n        },\n        amount,\n    };\n\n    // deduct tax first\n    let amount = (swap_asset.deduct_tax(&deps.querier)?).amount;\n    Ok(Response::new()\n        .add_submessage(SubMsg::reply_on_success(\n            CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: pair_info.contract_addr.into_string(),\n                msg: to_binary(&AstroportExecuteMsg::Swap {\n                    offer_asset: Asset {\n                        amount,\n                        ..swap_asset\n                    },\n                    max_spread: config.max_spread,\n                    belief_price: None,\n                    to: None,\n                })?,\n                funds: vec![Coin {\n                    denom: denom.to_string(),\n                    amount,\n                }],\n            }),\n            SWEEP_REPLY_ID,\n        ))\n        .add_attributes(vec![\n            attr(\"action\", \"sweep\"),\n            attr(\n                \"collected_rewards\",\n                format!(\"{:?}{:?}\", amount.to_string(), denom),\n            ),\n        ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, env: Env, msg: Reply) -> StdResult<Response> {\n    if msg.id == SWEEP_REPLY_ID {\n        // send tokens on successful callback\n        return distribute(deps, env);\n    }\n\n    Err(StdError::generic_err(\"not supported reply\"))\n}\n\n// Only contract itself can execute distribute function\npub fn distribute(deps: DepsMut, env: Env) -> StdResult<Response> {\n    let config: Config = read_config(deps.storage)?;\n    let amount = query_token_balance(\n        &deps.querier,\n        deps.api.addr_humanize(&config.anchor_token)?,\n        env.contract.address,\n    )?;\n\n    let distribute_amount = amount * config.reward_factor;\n    let left_amount = amount.checked_sub(distribute_amount)?;\n\n    let mut messages: Vec<CosmosMsg> = vec![];\n\n    if !distribute_amount.is_zero() {\n        messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: deps.api.addr_humanize(&config.anchor_token)?.to_string(),\n            msg: to_binary(&Cw20ExecuteMsg::Transfer {\n                recipient: deps.api.addr_humanize(&config.gov_contract)?.to_string(),\n                amount: distribute_amount,\n            })?,\n            funds: vec![],\n        }));\n    }\n\n    // burn the left amount\n    if !left_amount.is_zero() {\n        messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: deps.api.addr_humanize(&config.anchor_token)?.to_string(),\n            msg: to_binary(&Cw20ExecuteMsg::Burn {\n                amount: left_amount,\n            })?,\n            funds: vec![],\n        }));\n    }\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        (\"action\", \"distribute\"),\n        (\"distribute_amount\", &distribute_amount.to_string()),\n        (\"distributor_payback_amount\", &left_amount.to_string()),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n    }\n}\n\npub fn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let state = read_config(deps.storage)?;\n    let resp = ConfigResponse {\n        gov_contract: deps.api.addr_humanize(&state.gov_contract)?.to_string(),\n        astroport_factory: deps\n            .api\n            .addr_humanize(&state.astroport_factory)?\n            .to_string(),\n        anchor_token: deps.api.addr_humanize(&state.anchor_token)?.to_string(),\n        reward_factor: state.reward_factor,\n        max_spread: state.max_spread,\n    };\n\n    Ok(resp)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, msg: MigrateMsg) -> StdResult<Response> {\n    //migrate config\n    migrate_config(\n        deps.storage,\n        deps.api.addr_canonicalize(&msg.astroport_factory)?,\n        msg.max_spread,\n    )?;\n\n    Ok(Response::default())\n}"
    }
  ]
}