{
  "Title": "Incorrect formatting of `MetadataFacet::uri` JSON results in broken metadata which cannot be displayed by external clients",
  "Content": "**Description:** For fully on-chain metadata, external clients expect the URI of a token to contain a base64 encoded JSON object that contains the metadata and base64 encoded SVG image. Currently, [`MetadataFacet::uri`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/metadata/MetadataFacet.sol#L30-L51) is missing multiple quotations and commas within the encoded string which breaks its JSON formatting.\n\n**Impact:** External clients such as OpenSea are currently unable to display Beanstalk token metadata due to broken JSON formatting.\n\n**Recommended Mitigation:** Add missing quotation marks and commas. Ensure the resulting encoded bytes are that of valid JSON.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/metadata/MetadataFacet.sol",
      "content": "/*\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibLegacyTokenSilo} from \"contracts/libraries/Silo/LibLegacyTokenSilo.sol\";\nimport \"./MetadataImage.sol\";\n\n\n/**\n * @title MetadataFacet\n * @author Brean\n * @notice MetadataFacet is a contract that provides metadata for beanstalk ERC1155 deposits, \n * as well as other auxiliary functions related to ERC1155 deposits.\n * \n * @dev Deposits are represented by a uint256, which is the concatination of the token address and the stem.\n */\ncontract MetadataFacet is MetadataImage {\n    using LibStrings for uint256;\n\n    /**\n     * @notice Returns the URI for a given depositId.\n     * @param depositId - the id of the deposit\n     * @dev the URI is a base64 encoded JSON object that contains the metadata and base64 encoded svg.\n     * Deposits are stored as a mapping of a uint256 to a Deposit struct.\n     * ERC20 deposits are represented by the concatination of the token address and the stem. (20 + 12 bytes).\n     */\n    function uri(uint256 depositId) external view returns (string memory) {\n        (address token, int96 stem) = LibBytes.unpackAddressAndStem(depositId);\n        require(token != address(0), \"Silo: metadata does not exist\");\n        bytes memory attributes = abi.encodePacked(\n            '\\n\\nToken Symbol: ', getTokenName(token),\n            '\\nToken Address: ', LibStrings.toHexString(uint256(token), 20),\n            '\\nId: ', depositId.toHexString(32),\n            '\\nDeposit stem: ', uint256(stem).toString(),\n            '\\nDeposit inital stalk per BDV: ', uint256(LibTokenSilo.stalkIssuedPerBdv(token)).toString(),\n            '\\nDeposit grown stalk per BDV\": ', uint256(LibTokenSilo.stemTipForToken(token) - stem).toString(),\n            '\\nDeposit seeds per BDV\": ', uint256(LibLegacyTokenSilo.getSeedsPerToken(token)).toString(),\n            '\\n\\nDISCLAIMER: Due diligence is imperative when assessing this NFT. Opensea and other NFT marketplaces cache the svg output and thus, may require the user to refresh the metadata to properly show the correct values.\"'\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\",LibBytes64.encode(abi.encodePacked(\n                '{',\n                    '\"name\": \"Beanstalk Deposit\", \"description\": \"A Beanstalk Deposit.',\n                    attributes,\n                    string(abi.encodePacked(', \"image\": \"', imageURI(depositId), '\"')),\n                '}'\n            ))\n        ));\n    }\n}"
    }
  ]
}