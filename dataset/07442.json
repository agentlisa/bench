{
  "Title": "[G-01] Pack structs by putting data types in ascending size (We can save up to ~6k gas)",
  "Content": "\nAs the solidity EVM works with 32 bytes, variables less than 32 bytes should be packed inside a struct so that they can be stored in the same slot, this saves gas when writing to storage ~20000 gas.\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/interfaces/IVRFNFTRandomDraw.sol#L59-L68\n\n### We can use a smaller type for uint256 drawTimelock as it's simply a timestamp. Using uint64 should be safe for 532 years. We save 1 Storage SLOT from 4 SLOTS to 3 SLOTS (~2K gas)\n\n```solidity\nFile: /src/interfaces/IVRFNFTRandomDraw.sol\n59:    struct CurrentRequest {\n60:        /// @notice current chainlink request id\n61:        uint256 currentChainlinkRequestId;\n62:        /// @notice current chosen random number\n63:        uint256 currentChosenTokenId;\n64:        /// @notice has chosen a random number (in case random number = 0(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0))\n65:        bool hasChosenRandomNumber;\n66:        /// @notice time lock (block.timestamp) that a re-draw can be issued\n67:        uint256 drawTimelock;\n68:    }\n```\n\n\n```diff\ndiff --git a/src/interfaces/IVRFNFTRandomDraw.sol b/src/interfaces/IVRFNFTRandomDraw.sol\nindex 4775288..af1d928 100644\n--- a/src/interfaces/IVRFNFTRandomDraw.sol\n+++ b/src/interfaces/IVRFNFTRandomDraw.sol\n@@ -64,7 +64,7 @@ interface IVRFNFTRandomDraw {\n         /// @notice has chosen a random number (in case random number = 0(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0))\n         bool hasChosenRandomNumber;\n         /// @notice time lock (block.timestamp) that a re-draw can be issued\n-        uint256 drawTimelock;\n+        uint64 drawTimelock;\n     }\n```\n\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/interfaces/IVRFNFTRandomDraw.sol#L71-L90\n\n### We can save 2 SLOTs here by packing address token with uint64 subscriptionId and also changing the type of  uint256 recoverTimelock which is a timestamp to uint64 which should be safe for more than 500 years (Saves ~4k gas)\n\n```solidity\nFile: /src/interfaces/IVRFNFTRandomDraw.sol\n71:    struct Settings {\n72:        /// @notice Token Contract to put up for raffle\n73:        address token;\n74:        /// @notice Token ID to put up for raffle\n75:        uint256 tokenId;\n76:        /// @notice Token that each (sequential) ID has a entry in the raffle.\n77:        address drawingToken;\n78:        /// @notice Start token ID for the drawing (if totalSupply = 20 but the first token is 5 (5-25), setting this to 5 would fix the ordering)\n79:        uint256 drawingTokenStartId;\n80:        /// @notice End token ID for the drawing (exclusive) (token ids 0 - 9 would be 10 in this field)\n81:        uint256 drawingTokenEndId;\n82:        /// @notice Draw buffer time – time until a re-drawing can occur if the selected user cannot or does not claim the NFT.\n83:        uint256 drawBufferTime;\n84:        /// @notice block.timestamp that the admin can recover the NFT (as a safety fallback)\n85:        uint256 recoverTimelock;\n86:        /// @notice Chainlink gas keyhash\n87:        bytes32 keyHash;\n88:        /// @notice Chainlink subscription id\n89:        uint64 subscriptionId;\n90:    }\n```\n\n```diff\ndiff --git a/src/interfaces/IVRFNFTRandomDraw.sol b/src/interfaces/IVRFNFTRandomDraw.sol\nindex 4775288..7923c29 100644\n--- a/src/interfaces/IVRFNFTRandomDraw.sol\n+++ b/src/interfaces/IVRFNFTRandomDraw.sol\n@@ -69,24 +69,24 @@ interface IVRFNFTRandomDraw {\n\n     /// @notice Struct to organize user settings\n     struct Settings {\n+        /// @notice Chainlink subscription id\n+        uint64 subscriptionId;\n         /// @notice Token Contract to put up for raffle\n         address token;\n         /// @notice Token ID to put up for raffle\n         uint256 tokenId;\n         /// @notice Token that each (sequential) ID has a entry in the raffle.\n         address drawingToken;\n+        /// @notice block.timestamp that the admin can recover the NFT (as a safety fallback)\n+        uint64 recoverTimelock;\n         /// @notice Start token ID for the drawing (if totalSupply = 20 but the first token is 5 (5-25), setting this to 5 would fix the ordering)\n         uint256 drawingTokenStartId;\n         /// @notice End token ID for the drawing (exclusive) (token ids 0 - 9 would be 10 in this field)\n         uint256 drawingTokenEndId;\n         /// @notice Draw buffer time – time until a re-drawing can occur if the selected user cannot or does not claim the NFT.\n         uint256 drawBufferTime;\n-        /// @notice block.timestamp that the admin can recover the NFT (as a safety fallback)\n-        uint256 recoverTimelock;\n         /// @notice Chainlink gas keyhash\n         bytes32 keyHash;\n-        /// @notice Chainlink subscription id\n-        uint64 subscriptionId;\n     }\n```\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-12-forgeries-contest",
  "Code": [
    {
      "filename": "src/interfaces/IVRFNFTRandomDraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IVRFNFTRandomDraw {\n    /// @notice Cannot redraw during waiting period\n    error STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n    /// @notice Admin emergency withdraw can only happen once unlocked\n    error RECOVERY_IS_NOT_YET_POSSIBLE();\n    /// @notice Token that is offered does not exist with ownerOf\n    error TOKEN_BEING_OFFERED_NEEDS_TO_EXIST();\n    /// @notice Token needs to be a contract when initializing\n    error TOKEN_NEEDS_TO_BE_A_CONTRACT(address potentialTokenAddress);\n    /// @notice Token needs to be approved to raffle contract\n    error TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT();\n    /// @notice Waiting on a response from chainlink\n    error REQUEST_IN_FLIGHT();\n    /// @notice Chainlink VRF response doesn't match current ID\n    error REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n    /// @notice The tokens' totalSupply doesn't match one claimed on contract\n    error SUPPLY_TOKENS_COUNT_WRONG();\n    /// @notice Cannot attempt to claim winnings if request is not started or in flight\n    error NEEDS_TO_HAVE_CHOSEN_A_NUMBER();\n\n    /// @notice When the range is [20,0] (from 20 to 0, that doesn't make sense)\n    error DRAWING_TOKEN_RANGE_INVALID();\n    /// @notice Withdraw timelock min is 1 hour\n    error REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR();\n    error REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n    /// @notice Admin NFT recovery timelock min is 1 week\n    error RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK();\n    /// @notice Admin NFT recovery timelock max is 1 year\n    error RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();\n    /// @notice The given user has not won\n    error USER_HAS_NOT_WON();\n    /// @notice Cannot re-draw yet\n    error TOO_SOON_TO_REDRAW();\n    /// @notice NFT for raffle is not owned by the admin\n    error DOES_NOT_OWN_NFT();\n    /// @notice Too many / few random words are sent back from chainlink\n    error WRONG_LENGTH_FOR_RANDOM_WORDS();\n\n    /// @notice When the draw is initialized\n    event InitializedDraw(address indexed sender, Settings settings);\n    /// @notice When the draw is setup\n    event SetupDraw(address indexed sender, Settings settings);\n    /// @notice When the owner reclaims nft aftr recovery time delay\n    event OwnerReclaimedNFT(address indexed owner);\n    /// @notice Dice roll is complete from callback\n    event DiceRollComplete(address indexed sender, CurrentRequest request);\n    /// @notice Sent when the winner sends/claims an NFT\n    event WinnerSentNFT(\n        address indexed winner,\n        address indexed nft,\n        uint256 indexed tokenId,\n        Settings settings\n    );\n\n    /// @notice Struct to organize current request\n    struct CurrentRequest {\n        /// @notice current chainlink request id\n        uint256 currentChainlinkRequestId;\n        /// @notice current chosen random number\n        uint256 currentChosenTokenId;\n        /// @notice has chosen a random number (in case random number = 0(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0))\n        bool hasChosenRandomNumber;\n        /// @notice time lock (block.timestamp) that a re-draw can be issued\n        uint256 drawTimelock;\n    }\n\n    /// @notice Struct to organize user settings\n    struct Settings {\n        /// @notice Token Contract to put up for raffle\n        address token;\n        /// @notice Token ID to put up for raffle\n        uint256 tokenId;\n        /// @notice Token that each (sequential) ID has a entry in the raffle.\n        address drawingToken;\n        /// @notice Start token ID for the drawing (if totalSupply = 20 but the first token is 5 (5-25), setting this to 5 would fix the ordering)\n        uint256 drawingTokenStartId;\n        /// @notice End token ID for the drawing (exclusive) (token ids 0 - 9 would be 10 in this field)\n        uint256 drawingTokenEndId;\n        /// @notice Draw buffer time – time until a re-drawing can occur if the selected user cannot or does not claim the NFT.\n        uint256 drawBufferTime;\n        /// @notice block.timestamp that the admin can recover the NFT (as a safety fallback)\n        uint256 recoverTimelock;\n        /// @notice Chainlink gas keyhash\n        bytes32 keyHash;\n        /// @notice Chainlink subscription id\n        uint64 subscriptionId;\n    }\n\n    /// @notice Initialize the contract with settings and an admin\n    /// @param admin initial admin user\n    /// @param _settings initial settings for draw\n    function initialize(address admin, Settings memory _settings) external;\n\n    /// @notice Call this to start the raffle drawing\n    /// @return chainlink request id\n    function startDraw() external returns (uint256);\n\n    /// @notice Call this to re-draw the raffle\n    /// @return chainlink request ID\n    /// @dev Only callable by the owner\n    function redraw() external returns (uint256);\n\n    /// @notice Function to determine if the user has won in the current drawing\n    /// @param user address for the user to check if they have won in the current drawing\n    function hasUserWon(address user) external view returns (bool);\n\n    /// @notice Function for the winner to call to retrieve their NFT\n    function winnerClaimNFT() external;\n\n    /// @notice Optional last resort admin reclaim nft function\n    /// @dev Only callable by the owner\n    function lastResortTimelockOwnerClaimNFT() external;\n\n    /// @notice Getter for request details, does not include picked tokenID\n    /// @return currentChainlinkRequestId Current Chainlink Request ID\n    /// @return hasChosenRandomNumber If the random number for the drawing has been chosen\n    /// @return drawTimelock block.timestamp when a redraw can be issued\n    function getRequestDetails()\n        external\n        view\n        returns (\n            uint256 currentChainlinkRequestId,\n            bool hasChosenRandomNumber,\n            uint256 drawTimelock\n        );\n}"
    },
    {
      "filename": "src/interfaces/IVRFNFTRandomDraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IVRFNFTRandomDraw {\n    /// @notice Cannot redraw during waiting period\n    error STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n    /// @notice Admin emergency withdraw can only happen once unlocked\n    error RECOVERY_IS_NOT_YET_POSSIBLE();\n    /// @notice Token that is offered does not exist with ownerOf\n    error TOKEN_BEING_OFFERED_NEEDS_TO_EXIST();\n    /// @notice Token needs to be a contract when initializing\n    error TOKEN_NEEDS_TO_BE_A_CONTRACT(address potentialTokenAddress);\n    /// @notice Token needs to be approved to raffle contract\n    error TOKEN_NEEDS_TO_BE_APPROVED_TO_CONTRACT();\n    /// @notice Waiting on a response from chainlink\n    error REQUEST_IN_FLIGHT();\n    /// @notice Chainlink VRF response doesn't match current ID\n    error REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n    /// @notice The tokens' totalSupply doesn't match one claimed on contract\n    error SUPPLY_TOKENS_COUNT_WRONG();\n    /// @notice Cannot attempt to claim winnings if request is not started or in flight\n    error NEEDS_TO_HAVE_CHOSEN_A_NUMBER();\n\n    /// @notice When the range is [20,0] (from 20 to 0, that doesn't make sense)\n    error DRAWING_TOKEN_RANGE_INVALID();\n    /// @notice Withdraw timelock min is 1 hour\n    error REDRAW_TIMELOCK_NEEDS_TO_BE_MORE_THAN_AN_HOUR();\n    error REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n    /// @notice Admin NFT recovery timelock min is 1 week\n    error RECOVER_TIMELOCK_NEEDS_TO_BE_AT_LEAST_A_WEEK();\n    /// @notice Admin NFT recovery timelock max is 1 year\n    error RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();\n    /// @notice The given user has not won\n    error USER_HAS_NOT_WON();\n    /// @notice Cannot re-draw yet\n    error TOO_SOON_TO_REDRAW();\n    /// @notice NFT for raffle is not owned by the admin\n    error DOES_NOT_OWN_NFT();\n    /// @notice Too many / few random words are sent back from chainlink\n    error WRONG_LENGTH_FOR_RANDOM_WORDS();\n\n    /// @notice When the draw is initialized\n    event InitializedDraw(address indexed sender, Settings settings);\n    /// @notice When the draw is setup\n    event SetupDraw(address indexed sender, Settings settings);\n    /// @notice When the owner reclaims nft aftr recovery time delay\n    event OwnerReclaimedNFT(address indexed owner);\n    /// @notice Dice roll is complete from callback\n    event DiceRollComplete(address indexed sender, CurrentRequest request);\n    /// @notice Sent when the winner sends/claims an NFT\n    event WinnerSentNFT(\n        address indexed winner,\n        address indexed nft,\n        uint256 indexed tokenId,\n        Settings settings\n    );\n\n    /// @notice Struct to organize current request\n    struct CurrentRequest {\n        /// @notice current chainlink request id\n        uint256 currentChainlinkRequestId;\n        /// @notice current chosen random number\n        uint256 currentChosenTokenId;\n        /// @notice has chosen a random number (in case random number = 0(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0))\n        bool hasChosenRandomNumber;\n        /// @notice time lock (block.timestamp) that a re-draw can be issued\n        uint256 drawTimelock;\n    }\n\n    /// @notice Struct to organize user settings\n    struct Settings {\n        /// @notice Token Contract to put up for raffle\n        address token;\n        /// @notice Token ID to put up for raffle\n        uint256 tokenId;\n        /// @notice Token that each (sequential) ID has a entry in the raffle.\n        address drawingToken;\n        /// @notice Start token ID for the drawing (if totalSupply = 20 but the first token is 5 (5-25), setting this to 5 would fix the ordering)\n        uint256 drawingTokenStartId;\n        /// @notice End token ID for the drawing (exclusive) (token ids 0 - 9 would be 10 in this field)\n        uint256 drawingTokenEndId;\n        /// @notice Draw buffer time – time until a re-drawing can occur if the selected user cannot or does not claim the NFT.\n        uint256 drawBufferTime;\n        /// @notice block.timestamp that the admin can recover the NFT (as a safety fallback)\n        uint256 recoverTimelock;\n        /// @notice Chainlink gas keyhash\n        bytes32 keyHash;\n        /// @notice Chainlink subscription id\n        uint64 subscriptionId;\n    }\n\n    /// @notice Initialize the contract with settings and an admin\n    /// @param admin initial admin user\n    /// @param _settings initial settings for draw\n    function initialize(address admin, Settings memory _settings) external;\n\n    /// @notice Call this to start the raffle drawing\n    /// @return chainlink request id\n    function startDraw() external returns (uint256);\n\n    /// @notice Call this to re-draw the raffle\n    /// @return chainlink request ID\n    /// @dev Only callable by the owner\n    function redraw() external returns (uint256);\n\n    /// @notice Function to determine if the user has won in the current drawing\n    /// @param user address for the user to check if they have won in the current drawing\n    function hasUserWon(address user) external view returns (bool);\n\n    /// @notice Function for the winner to call to retrieve their NFT\n    function winnerClaimNFT() external;\n\n    /// @notice Optional last resort admin reclaim nft function\n    /// @dev Only callable by the owner\n    function lastResortTimelockOwnerClaimNFT() external;\n\n    /// @notice Getter for request details, does not include picked tokenID\n    /// @return currentChainlinkRequestId Current Chainlink Request ID\n    /// @return hasChosenRandomNumber If the random number for the drawing has been chosen\n    /// @return drawTimelock block.timestamp when a redraw can be issued\n    function getRequestDetails()\n        external\n        view\n        returns (\n            uint256 currentChainlinkRequestId,\n            bool hasChosenRandomNumber,\n            uint256 drawTimelock\n        );\n}"
    }
  ]
}