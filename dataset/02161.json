{
  "Title": "H-6: Cross-chain message authentication can be bypassed, allowing an attacker to disrupt the state of vaults",
  "Content": "# Issue H-6: Cross-chain message authentication can be bypassed, allowing an attacker to disrupt the state of vaults \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/309 \n\n## Found by \nJeiwan\n\n## Summary\nA malicious actor may send a cross-chain message to an `XProvider` contract and bypass the `onlySource` authentication check. As a result, they'll be able to call any function in the `XProvider` contract that has the `onlySource` modifier and disrupt the state of `XChainController` and all vaults.\n## Vulnerability Detail\nThe protocol integrates with Connext to handle cross-chain interactions. [XProvider](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L14) is a contract that manages interactions between vaults deployed on all supported networks and `XChainController`. `XProvider` is deployed on each of the network where a vault is deployed and is used to send and receive cross-chain messages via Connext. `XProvider` is a core contract that handles vault rebalancing, transferring of allocations from Game to `XChainController` and to vaults, transferring of tokens deposited to vaults between vault on different networks. Thus, it's critical that the functions of this contract are only called by authorized actors.\n\nTo ensure that cross-chain messages are sent from authorized actors, there's [onlySource](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L85) modifier that's applied to the [xReceive](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L170) function. The modifier checks that the sender of a message is trusted:\n```solidity\nmodifier onlySource(address _originSender, uint32 _origin) {\n  require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n  _;\n}\n```\n\nHowever, it doesn't check that `trustedRemoteConnext[_origin]` is set (i.e. it's not the zero address), and `_originSender` can in fact be the zero address.\n\nIn Connext, a message can be [delivered via one of the two paths](https://docs.connext.network/concepts/how-it-works/transaction-flow): the fast path or the slow path. The fast path is taken when, on the destination, **message receiving is not authentication**, i.e. when destination allows receiving of messages from all senders. The slow path is taken when message receiving on the destination is authenticated, i.e. destination allows any sender (it doesn't check a sender).\n\nSince, `XProvider` always checks the sender of a message, only the slow path will be used by Connext to deliver messages to it. However, Connext always [tries the slow path](https://docs.connext.network/concepts/how-it-works/transaction-flow):\n> Routers observing the origin chain with funds on the destination chain will:\n> Simulate the transaction (if this fails, the assumption is that this is a more \"expressive\" crosschain message that requires authentication and so must go through the AMB: the slow path).\n\nI.e. it'll always send a message and see if it reverts on the destination or not: if it does, Connext will switch to the slow path.\n\nWhen Connext executes a message on the destination chain in the fast path, it [sets the sender address to the zero address](https://github.com/connext/monorepo/blob/87b75b346664271522e2f2acfd10bebcfeb93993/packages/deployments/contracts/contracts/core/connext/facets/BridgeFacet.sol#L878):\n```solidity\n(bool success, bytes memory returnData) = ExcessivelySafeCall.excessivelySafeCall(\n  _params.to,\n  gasleft() - Constants.EXECUTE_CALLDATA_RESERVE_GAS,\n  0, // native asset value (always 0)\n  Constants.DEFAULT_COPY_BYTES, // only copy 256 bytes back as calldata\n  abi.encodeWithSelector(\n    IXReceiver.xReceive.selector,\n    _transferId,\n    _amount,\n    _asset,\n    _reconciled ? _params.originSender : address(0), // use passed in value iff authenticated\n    _params.originDomain,\n    _params.callData\n  )\n);\n```\n\nThus, Connext will try to call the `XProvider.xReceive` function with the `_originSender` argument set to the zero address. And there are situations when the `onlySource` modifier will pass such calls: when the origin network (as specified by the `_origin` argument) is not in the `trustedRemoteConnext` mapping.\n\nAccording to the description of the project, it'll be deployed on the following networks:\n> Mainnet, Arbitrum, Optimism, Polygon, Binance Smart Chain\n\nAnd this is the [list of networks supported by Connext](https://docs.connext.network/resources/supported-chains):\n> Ethereum Mainnet\n> Polygon\n> Optimism\n> Arbitrum One\n> Gnosis Chain\n> BNB Chain\n\nThus, a malicious actor can send a message from Gnosis Chain (it's not supported by Derby), and the `onlySource` modifier will pass the message. The same is true for any new network supported by Connext in the future and not supported by Derby.\n## Impact\nA malicious actor can call `XProvider.xReceive` and any functions of `XProvider` with the `onlySelf` modifier:\n1. [xReceive](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L170) allow the caller to call any public function of `XProvider`, but only the ones with the `onlySelf` modifier are authorized;\n1. [receiveAllocations](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L204) can be used to corrupt allocations in the `XChainController` (i.e. allocate all tokens only to the protocol the attacker will benefit the most from);\n1. [receiveTotalUnderlying](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L254) can be used to set wrong \"total underlying\" value in the `XChainController` and block rebalancing of vaults (due to an underflow or another arithmetical error);\n1. [receiveSetXChainAllocation](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L305) can be used to set an exchange rate that will allow an attacker to drain a vault by redeeming their LP tokens at a higher rate;\n1. [receiveFeedbackToXController](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L351) can be used to trick the `XChainController` into skipping receiving of funds from a vault;\n1. [receiveProtocolAllocationsToVault](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L420) can be used by an attacker to unilaterally set allocations in a vault, directing funds only to protocol the attacker will benefit from;\n1. [receiveRewardsToGame](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L452) can be used by an attacker to increase the reward per LP token in a protocol the attacker deposited to;\n1. finally, [receiveStateFeedbackToVault](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L482) can allow an attacker to switch off a vault and exclude it from rebalancing.\n## Code Snippet\n1. `onlySource` modifier validates the message sender:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L85-L88\n1. `xReceive` is protected by the `onlySource` modifier:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XProvider.sol#L170-L180\n1. Connext always tries the fast path and sets the sender address to the zero address:\nhttps://github.com/connext/monorepo/blob/87b75b346664271522e2f2acfd10bebcfeb93993/packages/deployments/contracts/contracts/core/connext/facets/BridgeFacet.sol#L878\n## Tool used\nManual Review\n## Recommendation\nIn the `onlySource` modifier, consider checking that `trustedRemoteConnext[_origin]` doesn't return the zero address:\n```diff\ndiff --git a/derby-yield-optimiser/contracts/XProvider.sol b/derby-yield-optimiser/contracts/XProvider.sol\nindex 6074fa0..f508a7c 100644\n--- a/derby-yield-optimiser/contracts/XProvider.sol\n+++ b/derby-yield-optimiser/contracts/XProvider.sol\n@@ -83,7 +83,7 @@ contract XProvider is IXReceiver {\n    *    3) The call to this contract comes from Connext.\n    */\n   modifier onlySource(address _originSender, uint32 _origin) {\n-    require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n+    require(trustedRemoteConnext[_origin] != address(0) && _originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n     _;\n   }\n```\n\n\n\n## Discussion\n\n**Jeiwan**\n\nEscalate for 10 USDC\n\nThis was mistakenly marked as a duplicate.\n\nThis report points at the weak cross-chain messages authentication, which allows an attacker to send fake cross-chain messages and pass the authentication check. This basically disrupts the rebalancing and allows the attacker to manipulate token allocations for their profit (and for the loss of everyone else) or even lock rebalancing indefinitely.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This was mistakenly marked as a duplicate.\n> \n> This report points at the weak cross-chain messages authentication, which allows an attacker to send fake cross-chain messages and pass the authentication check. This basically disrupts the rebalancing and allows the attacker to manipulate token allocations for their profit (and for the loss of everyone else) or even lock rebalancing indefinitely.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Theezr**\n\nValid high issue\n\n\n**hrishibhat**\n\nEscalation accepted\n\nThis is a valid high issue\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This is a valid high issue\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/XProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IVault.sol\";\nimport \"./Interfaces/IXChainController.sol\";\nimport \"./Interfaces/IGame.sol\";\nimport \"./Interfaces/ExternalInterfaces/IConnext.sol\";\nimport \"./Interfaces/ExternalInterfaces/IXReceiver.sol\";\n\ncontract XProvider is IXReceiver {\n  using SafeERC20 for IERC20;\n\n  address public immutable connext;\n\n  address private dao;\n  address private guardian;\n  address public xController;\n  address public xControllerProvider;\n  address public game;\n\n  uint32 public homeChain;\n  uint32 public xControllerChain;\n  uint32 public gameChain;\n\n  // (domainID => contract address) mapping domainIDs to trusted remote xProvider on that specific domain\n  mapping(uint32 => address) public trustedRemoteConnext;\n  // (vaultAddress => bool): used for whitelisting vaults\n  mapping(address => bool) public vaultWhitelist;\n  // (vaultNumber => vaultAddress): used for guardian when xCall fails\n  mapping(uint256 => address) public vaults;\n\n  event SetTrustedRemote(uint32 _srcChainId, bytes _srcAddress);\n  event SetTrustedRemoteConnext(uint32 _srcChainId, address _srcAddress);\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"xProvider: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  modifier onlyController() {\n    require(msg.sender == xController, \"xProvider: only Controller\");\n    _;\n  }\n\n  modifier onlyVaults() {\n    require(vaultWhitelist[msg.sender], \"xProvider: only vault\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"xProvider: only Game\");\n    _;\n  }\n\n  /// @notice Solution for the low-level call in xReceive that is seen as an external call\n  modifier onlySelf() {\n    require(msg.sender == address(this), \"xProvider: only Self\");\n    _;\n  }\n\n  modifier onlySelfOrVault() {\n    require(\n      msg.sender == address(this) || vaultWhitelist[msg.sender],\n      \"xProvider: only Self or Vault\"\n    );\n    _;\n  }\n\n  /** @notice A modifier for authenticated calls.\n   * This is an important security consideration. If the target contract\n   * function should be authenticated, it must check three things:\n   *    1) The originating call comes from the expected origin domain.\n   *    2) The originating call comes from the expected source contract.\n   *    3) The call to this contract comes from Connext.\n   */\n  modifier onlySource(address _originSender, uint32 _origin) {\n    require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n    _;\n  }\n\n  constructor(\n    address _connext,\n    address _dao,\n    address _guardian,\n    address _game,\n    address _xController,\n    uint32 _homeChain\n  ) {\n    connext = _connext;\n    dao = _dao;\n    guardian = _guardian;\n    game = _game;\n    xController = _xController;\n    homeChain = _homeChain;\n  }\n\n  /// @notice Function to send function selectors crossChain\n  /// @param _destinationDomain chain Id of destination chain\n  /// @param _callData Function selector to call on receiving chain with params\n  /// @param _relayerFee The fee offered to the relayers, if 0 use the complete msg.value\n  function xSend(uint32 _destinationDomain, bytes memory _callData, uint256 _relayerFee) internal {\n    address target = trustedRemoteConnext[_destinationDomain];\n    require(target != address(0), \"XProvider: destination chain not trusted\");\n    uint256 relayerFee = _relayerFee != 0 ? _relayerFee : msg.value;\n\n    IConnext(connext).xcall{value: relayerFee}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      target, // _to: address of the target contract\n      address(0), // _asset: use address zero for 0-value transfers\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      0, // _amount: 0 because no funds are being transferred\n      0, // _slippage: can be anything between 0-10000 because no funds are being transferred\n      _callData // _callData: the encoded calldata to send\n    );\n  }\n\n  /// @notice Transfers funds from one chain to another.\n  /// @param _token Address of the token on this domain.\n  /// @param _amount The amount to transfer.\n  /// @param _recipient The destination address (e.g. a wallet).\n  /// @param _destinationDomain The destination domain ID.\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers for confirmation message, msg.value - _relayerFee is what goes to the routers\n  function xTransfer(\n    address _token,\n    uint256 _amount,\n    address _recipient,\n    uint32 _destinationDomain,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) internal {\n    require(\n      IERC20(_token).allowance(msg.sender, address(this)) >= _amount,\n      \"User must approve amount\"\n    );\n\n    // User sends funds to this contract\n    IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n\n    // This contract approves transfer to Connext\n    IERC20(_token).approve(address(connext), _amount);\n\n    IConnext(connext).xcall{value: (msg.value - _relayerFee)}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      _recipient, // _to: address receiving the funds on the destination\n      _token, // _asset: address of the token contract\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      _amount, // _amount: amount of tokens to transfer\n      _slippage, // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\n      bytes(\"\") // _callData: empty bytes because we're only sending funds\n    );\n  }\n\n  /// @notice function implemented from IXReceive from connext, standard way to receive messages with connext.\n  /// @param _transferId not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _amount not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _asset not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _originSender sender contract.\n  /// @param _origin sender domain id.\n  /// @param _callData calldata, contains function signature which has to be called in this contract as well as the values, hashed and encoded.\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external onlySource(_originSender, _origin) returns (bytes memory) {\n    (bool success, ) = address(this).call(_callData);\n    require(success, \"xReceive: No success\");\n  }\n\n  /// @notice Step 1 push; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Pushes the delta allocations from the game to the xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function pushAllocations(\n    uint256 _vaultNumber,\n    int256[] memory _deltas\n  ) external payable onlyGame {\n    if (homeChain == xControllerChain) {\n      return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n    }\n    bytes4 selector = bytes4(keccak256(\"receiveAllocations(uint256,int256[])\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _deltas);\n\n    xSend(xControllerChain, callData, 0);\n  }\n\n  /// @notice Step 1 receive; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Receives the delta allocations from the game and routes to xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function receiveAllocations(uint256 _vaultNumber, int256[] memory _deltas) external onlySelf {\n    return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n  }\n\n  /// @notice Step 2 push; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Pushes cross chain requests for the totalUnderlying for a vaultNumber on a chainId\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _underlying TotalUnderling plus vault balance in vaultcurrency e.g USDC\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\n  function pushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  ) external payable onlyVaults {\n    if (_chainId == xControllerChain) {\n      return\n        IXChainController(xController).setTotalUnderlying(\n          _vaultNumber,\n          _chainId,\n          _underlying,\n          _totalSupply,\n          _withdrawalRequests\n        );\n    } else {\n      bytes4 selector = bytes4(\n        keccak256(\"receiveTotalUnderlying(uint256,uint32,uint256,uint256,uint256)\")\n      );\n      bytes memory callData = abi.encodeWithSelector(\n        selector,\n        _vaultNumber,\n        _chainId,\n        _underlying,\n        _totalSupply,\n        _withdrawalRequests\n      );\n\n      xSend(xControllerChain, callData, 0);\n    }\n  }\n\n  /// @notice Step 2 receive; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Receive and set totalUnderlyings from the vaults for every chainId\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _underlying TotalUnderling plus vault balance in vaultcurrency e.g USDC\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\n  function receiveTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  ) external onlySelf {\n    return\n      IXChainController(xController).setTotalUnderlying(\n        _vaultNumber,\n        _chainId,\n        _underlying,\n        _totalSupply,\n        _withdrawalRequests\n      );\n  }\n\n  /// @notice Step 3 push; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\n  /// @param _vault Address of the Derby Vault on given chainId\n  /// @param _chainId Number of chain used\n  /// @param _amountToSendBack Amount the vault has to send back\n  /// @param _exchangeRate New exchangerate for vaults\n  function pushSetXChainAllocation(\n    address _vault,\n    uint32 _chainId,\n    uint256 _amountToSendBack,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external payable onlyController {\n    if (_chainId == homeChain) {\n      return IVault(_vault).setXChainAllocation(_amountToSendBack, _exchangeRate, _receivingFunds);\n    } else {\n      bytes4 selector = bytes4(\n        keccak256(\"receiveSetXChainAllocation(address,uint256,uint256,bool)\")\n      );\n      bytes memory callData = abi.encodeWithSelector(\n        selector,\n        _vault,\n        _amountToSendBack,\n        _exchangeRate,\n        _receivingFunds\n      );\n\n      xSend(_chainId, callData, 0);\n    }\n  }\n\n  /// @notice Step 3 receive; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\n  /// @param _vault Address of the Derby Vault on given chainId\n  /// @param _amountToSendBack Amount the vault has to send back\n  /// @param _exchangeRate New exchangerate for vaults\n  function receiveSetXChainAllocation(\n    address _vault,\n    uint256 _amountToSendBack,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external onlySelf {\n    return IVault(_vault).setXChainAllocation(_amountToSendBack, _exchangeRate, _receivingFunds);\n  }\n\n  /// @notice Step 4 push; Push funds from vaults to xChainController\n  /// @notice Transfers funds from vault to xController for crosschain rebalance\n  /// @param _vaultNumber Address of the Derby Vault on given chainId\n  /// @param _amount Number of the vault\n  /// @param _asset Address of the token to send e.g USDC\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers\n  function xTransferToController(\n    uint256 _vaultNumber,\n    uint256 _amount,\n    address _asset,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) external payable onlyVaults {\n    if (homeChain == xControllerChain) {\n      IERC20(_asset).transferFrom(msg.sender, xController, _amount);\n      IXChainController(xController).upFundsReceived(_vaultNumber);\n    } else {\n      xTransfer(_asset, _amount, xController, xControllerChain, _slippage, _relayerFee);\n      pushFeedbackToXController(_vaultNumber, _relayerFee);\n    }\n  }\n\n  /// @notice Step 4 push; Push funds from vaults to xChainController\n  /// @notice Push crosschain feedback to xController to know when the vaultNumber has sent funds\n  /// @param _vaultNumber Number of the vault\n  /// @param _relayerFee The fee offered to the relayers\n  function pushFeedbackToXController(uint256 _vaultNumber, uint256 _relayerFee) internal {\n    bytes4 selector = bytes4(keccak256(\"receiveFeedbackToXController(uint256)\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber);\n\n    xSend(xControllerChain, callData, _relayerFee);\n  }\n\n  /// @notice Step 4 receive; Push funds from vaults to xChainController\n  /// @notice Receive crosschain feedback to xController to know when the vaultNumber has sent funds\n  /// @param _vaultNumber Number of the vault\n  function receiveFeedbackToXController(uint256 _vaultNumber) external onlySelf {\n    return IXChainController(xController).upFundsReceived(_vaultNumber);\n  }\n\n  /// @notice Step 5 push; Push funds from xChainController to vaults\n  /// @notice Transfers funds from xController to vault for crosschain rebalance\n  /// @param _chainId Number of chainId\n  /// @param _amount Amount to send to vault in vaultcurrency\n  /// @param _asset Addres of underlying e.g USDC\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers\n  function xTransferToVaults(\n    address _vault,\n    uint32 _chainId,\n    uint256 _amount,\n    address _asset,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) external payable onlyController {\n    if (_chainId == homeChain) {\n      IVault(_vault).receiveFunds();\n      IERC20(_asset).transferFrom(msg.sender, _vault, _amount);\n    } else {\n      pushFeedbackToVault(_chainId, _vault, _relayerFee);\n      xTransfer(_asset, _amount, _vault, _chainId, _slippage, _relayerFee);\n    }\n  }\n\n  /// @notice Step 5 push; Push funds from xChainController to vaults\n  /// @notice Push feedback message so the vault knows it has received funds and is ready to rebalance\n  /// @param _chainId Number of chainId\n  /// @param _vault Address of the vault on given chainId\n  /// @param _relayerFee The fee offered to the relayers\n  function pushFeedbackToVault(uint32 _chainId, address _vault, uint256 _relayerFee) internal {\n    bytes4 selector = bytes4(keccak256(\"receiveFeedbackToVault(address)\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vault);\n\n    xSend(_chainId, callData, _relayerFee);\n  }\n\n  /// @notice Step 5 receive; Push funds from xChainController to vaults\n  /// @notice Receive feedback message so the vault knows it has received funds and is ready to rebalance\n  /// @param _vault Address of the vault on given chainId\n  function receiveFeedbackToVault(address _vault) external onlySelfOrVault {\n    return IVault(_vault).receiveFunds();\n  }\n\n  /// @notice Step 6 push; Game pushes deltaAllocations to vaults\n  /// @notice Push protocol allocation array from the game to all vaults/chains\n  /// @param _vault Address of the vault on given chainId\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\n  function pushProtocolAllocationsToVault(\n    uint32 _chainId,\n    address _vault,\n    int256[] memory _deltas\n  ) external payable onlyGame {\n    if (_chainId == homeChain) return IVault(_vault).receiveProtocolAllocations(_deltas);\n    else {\n      bytes4 selector = bytes4(keccak256(\"receiveProtocolAllocationsToVault(address,int256[])\"));\n      bytes memory callData = abi.encodeWithSelector(selector, _vault, _deltas);\n\n      xSend(_chainId, callData, 0);\n    }\n  }\n\n  /// @notice Step 6 receive; Game pushes deltaAllocations to vaults\n  /// @notice Receives protocol allocation array from the game to all vaults/chains\n  /// @param _vault Address of the vault on given chainId\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\n  function receiveProtocolAllocationsToVault(\n    address _vault,\n    int256[] memory _deltas\n  ) external onlySelf {\n    return IVault(_vault).receiveProtocolAllocations(_deltas);\n  }\n\n  /// @notice Step 8 push; Vaults push rewardsPerLockedToken to game\n  /// @notice Push price and rewards array from vaults to the game\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function pushRewardsToGame(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external payable onlyVaults {\n    if (_chainId == gameChain) {\n      return IGame(game).settleRewards(_vaultNumber, _chainId, _rewards);\n    } else {\n      bytes4 selector = bytes4(keccak256(\"receiveRewardsToGame(uint256,uint32,int256[])\"));\n      bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _chainId, _rewards);\n\n      xSend(gameChain, callData, 0);\n    }\n  }\n\n  /// @notice Step 8 receive; Vaults push rewardsPerLockedToken to game\n  /// @notice Receives price and rewards array from vaults to the game\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function receiveRewardsToGame(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external onlySelf {\n    return IGame(game).settleRewards(_vaultNumber, _chainId, _rewards);\n  }\n\n  /// @notice Push feedback to the vault if the vault is set to on or off\n  /// @param _vault Address of the Derby Vault on given chainId\n  /// @param _chainId Number of chain used\n  /// @param _state bool for chainId on or off\n  function pushStateFeedbackToVault(\n    address _vault,\n    uint32 _chainId,\n    bool _state\n  ) external payable onlyController {\n    if (_chainId == homeChain) {\n      return IVault(_vault).toggleVaultOnOff(_state);\n    } else {\n      bytes4 selector = bytes4(keccak256(\"receiveStateFeedbackToVault(address,bool)\"));\n      bytes memory callData = abi.encodeWithSelector(selector, _vault, _state);\n\n      xSend(_chainId, callData, 0);\n    }\n  }\n\n  /// @notice Receive feedback for the vault if the vault is set to on or off\n  /// @param _vault Address of the Derby Vault on given chainId\n  /// @param _state bool for chainId on or off\n  function receiveStateFeedbackToVault(address _vault, bool _state) external onlySelf {\n    return IVault(_vault).toggleVaultOnOff(_state);\n  }\n\n  /// @notice returns number of decimals for the vault\n  function getDecimals(address _vault) external view returns (uint256) {\n    return IVault(_vault).decimals();\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /*\n  Only Dao functions\n  */\n  /// @notice set trusted provider on remote chains, allow owner to set it multiple times.\n  /// @param _srcChainId Chain is for remote xprovider, some as the remote receiving contract chain id (xReceive)\n  /// @param _srcAddress Address of remote xprovider\n  function setTrustedRemoteConnext(uint32 _srcChainId, address _srcAddress) external onlyDao {\n    trustedRemoteConnext[_srcChainId] = _srcAddress;\n    emit SetTrustedRemoteConnext(_srcChainId, _srcAddress);\n  }\n\n  /// @notice Setter for xControlleraddress\n  /// @param _xController New address of _xController\n  function setXController(address _xController) external onlyDao {\n    xController = _xController;\n  }\n\n  /// @notice Setter for xControllerProvider address\n  /// @param _xControllerProvider New address of xProvider for xController chain\n  function setXControllerProvider(address _xControllerProvider) external onlyDao {\n    xControllerProvider = _xControllerProvider;\n  }\n\n  /// @notice Setter for xController chain id\n  /// @param _xControllerChain new xController chainId\n  function setXControllerChainId(uint32 _xControllerChain) external onlyDao {\n    xControllerChain = _xControllerChain;\n  }\n\n  /// @notice Setter for homeChain Id\n  /// @param _homeChain New home chainId\n  function setHomeChain(uint32 _homeChain) external onlyDao {\n    homeChain = _homeChain;\n  }\n\n  /// @notice Setter for gameChain Id\n  /// @param _gameChain New chainId for game contract\n  function setGameChainId(uint32 _gameChain) external onlyDao {\n    gameChain = _gameChain;\n  }\n\n  /// @notice Whitelists vault address for onlyVault modifier\n  function toggleVaultWhitelist(address _vault) external onlyDao {\n    vaultWhitelist[_vault] = !vaultWhitelist[_vault];\n  }\n\n  /// @notice Setter for dao address\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /// @notice Setter for new game address\n  /// @param _game New address of the game\n  function setGame(address _game) external onlyDao {\n    game = _game;\n  }\n\n  /// @notice Setter for vault address to vaultNumber for guardian\n  function setVaultAddress(uint256 _vaultNumber, address _vault) external onlyDao {\n    vaults[_vaultNumber] = _vault;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Guardian function to send funds back to xController when xCall fails\n  function sendFundsToXController(address _token) external onlyGuardian {\n    require(xControllerChain == homeChain, \"No xController on this chain\");\n    require(xController != address(0), \"Zero address\");\n\n    uint256 balance = IERC20(_token).balanceOf(address(this));\n    IERC20(_token).transfer(xController, balance);\n  }\n\n  /// @notice Guardian function to send funds back to vault when xCall fails\n  function sendFundsToVault(uint256 _vaultNumber, address _token) external onlyGuardian {\n    address vault = vaults[_vaultNumber];\n    require(vault != address(0), \"Zero address\");\n\n    uint256 balance = IERC20(_token).balanceOf(address(this));\n    IERC20(_token).transfer(vault, balance);\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/XProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IVault.sol\";\nimport \"./Interfaces/IXChainController.sol\";\nimport \"./Interfaces/IGame.sol\";\nimport \"./Interfaces/ExternalInterfaces/IConnext.sol\";\nimport \"./Interfaces/ExternalInterfaces/IXReceiver.sol\";\n\ncontract XProvider is IXReceiver {\n  using SafeERC20 for IERC20;\n\n  address public immutable connext;\n\n  address private dao;\n  address private guardian;\n  address public xController;\n  address public xControllerProvider;\n  address public game;\n\n  uint32 public homeChain;\n  uint32 public xControllerChain;\n  uint32 public gameChain;\n\n  // (domainID => contract address) mapping domainIDs to trusted remote xProvider on that specific domain\n  mapping(uint32 => address) public trustedRemoteConnext;\n  // (vaultAddress => bool): used for whitelisting vaults\n  mapping(address => bool) public vaultWhitelist;\n  // (vaultNumber => vaultAddress): used for guardian when xCall fails\n  mapping(uint256 => address) public vaults;\n\n  event SetTrustedRemote(uint32 _srcChainId, bytes _srcAddress);\n  event SetTrustedRemoteConnext(uint32 _srcChainId, address _srcAddress);\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"xProvider: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  modifier onlyController() {\n    require(msg.sender == xController, \"xProvider: only Controller\");\n    _;\n  }\n\n  modifier onlyVaults() {\n    require(vaultWhitelist[msg.sender], \"xProvider: only vault\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"xProvider: only Game\");\n    _;\n  }\n\n  /// @notice Solution for the low-level call in xReceive that is seen as an external call\n  modifier onlySelf() {\n    require(msg.sender == address(this), \"xProvider: only Self\");\n    _;\n  }\n\n  modifier onlySelfOrVault() {\n    require(\n      msg.sender == address(this) || vaultWhitelist[msg.sender],\n      \"xProvider: only Self or Vault\"\n    );\n    _;\n  }\n\n  /** @notice A modifier for authenticated calls.\n   * This is an important security consideration. If the target contract\n   * function should be authenticated, it must check three things:\n   *    1) The originating call comes from the expected origin domain.\n   *    2) The originating call comes from the expected source contract.\n   *    3) The call to this contract comes from Connext.\n   */\n  modifier onlySource(address _originSender, uint32 _origin) {\n    require(_originSender == trustedRemoteConnext[_origin] && msg.sender == connext, \"Not trusted\");\n    _;\n  }\n\n  constructor(\n    address _connext,\n    address _dao,\n    address _guardian,\n    address _game,\n    address _xController,\n    uint32 _homeChain\n  ) {\n    connext = _connext;\n    dao = _dao;\n    guardian = _guardian;\n    game = _game;\n    xController = _xController;\n    homeChain = _homeChain;\n  }\n\n  /// @notice Function to send function selectors crossChain\n  /// @param _destinationDomain chain Id of destination chain\n  /// @param _callData Function selector to call on receiving chain with params\n  /// @param _relayerFee The fee offered to the relayers, if 0 use the complete msg.value\n  function xSend(uint32 _destinationDomain, bytes memory _callData, uint256 _relayerFee) internal {\n    address target = trustedRemoteConnext[_destinationDomain];\n    require(target != address(0), \"XProvider: destination chain not trusted\");\n    uint256 relayerFee = _relayerFee != 0 ? _relayerFee : msg.value;\n\n    IConnext(connext).xcall{value: relayerFee}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      target, // _to: address of the target contract\n      address(0), // _asset: use address zero for 0-value transfers\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      0, // _amount: 0 because no funds are being transferred\n      0, // _slippage: can be anything between 0-10000 because no funds are being transferred\n      _callData // _callData: the encoded calldata to send\n    );\n  }\n\n  /// @notice Transfers funds from one chain to another.\n  /// @param _token Address of the token on this domain.\n  /// @param _amount The amount to transfer.\n  /// @param _recipient The destination address (e.g. a wallet).\n  /// @param _destinationDomain The destination domain ID.\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers for confirmation message, msg.value - _relayerFee is what goes to the routers\n  function xTransfer(\n    address _token,\n    uint256 _amount,\n    address _recipient,\n    uint32 _destinationDomain,\n    uint256 _slippage,\n    uint256 _relayerFee\n  ) internal {\n    require(\n      IERC20(_token).allowance(msg.sender, address(this)) >= _amount,\n      \"User must approve amount\"\n    );\n\n    // User sends funds to this contract\n    IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n\n    // This contract approves transfer to Connext\n    IERC20(_token).approve(address(connext), _amount);\n\n    IConnext(connext).xcall{value: (msg.value - _relayerFee)}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      _recipient, // _to: address receiving the funds on the destination\n      _token, // _asset: address of the token contract\n      msg.sender, // _delegate: address that can revert or forceLocal on destination\n      _amount, // _amount: amount of tokens to transfer\n      _slippage, // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\n      bytes(\"\") // _callData: empty bytes because we're only sending funds\n    );\n  }\n\n  /// @notice function implemented from IXReceive from connext, standard way to receive messages with connext.\n  /// @param _transferId not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _amount not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _asset not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _originSender sender contract.\n  /// @param _origin sender domain id.\n  /// @param _callData calldata, contains function signature which has to be called in this contract as well as the values, hashed and encoded.\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external onlySource(_originSender, _origin) returns (bytes memory) {\n    (bool success, ) = address(this).call(_callData);\n    require(success, \"xReceive: No success\");\n  }\n\n  /// @notice Step 1 push; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Pushes the delta allocations from the game to the xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function pushAllocations(\n    uint256 _vaultNumber,\n    int256[] memory _deltas\n  ) external payable onlyGame {\n    if (homeChain == xControllerChain) {\n      return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n    }\n    bytes4 selector = bytes4(keccak256(\"receiveAllocations(uint256,int256[])\"));\n    bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _deltas);\n\n    xSend(xControllerChain, callData, 0);\n  }\n\n  /// @notice Step 1 receive; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Receives the delta allocations from the game and routes to xChainController\n  /// @param _vaultNumber number of the vault\n  /// @param _deltas Array with delta Allocations for all chainIds\n  function receiveAllocations(uint256 _vaultNumber, int256[] memory _deltas) external onlySelf {\n    return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\n  }\n\n  /// @notice Step 2 push; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Pushes cross chain requests for the totalUnderlying for a vaultNumber on a chainId\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _underlying TotalUnderling plus vault balance in vaultcurrency e.g USDC\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\n  function pushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  ) external payable onlyVaults {\n    if (_chainId == xControllerChain) {\n      return\n        IXChainController(xController).setTotalUnderlying(\n          _vaultNumber,\n          _chainId,\n          _underlying,\n          _totalSupply,\n          _withdrawalRequests\n        );\n    } else {\n      bytes4 selector = bytes4(\n        keccak256(\"receiveTotalUnderlying(uint256,uint32,uint256,uint256,uint256)\")\n      );\n      bytes memory callData = abi.encodeWithSelector(\n        selector,\n        _vaultNumber,\n        _chainId,\n        _underlying,\n        _totalSupply,\n        _withdrawalRequests\n      );\n\n      xSend(xControllerChain, callData, 0);\n    }\n  }\n\n  /// @notice Step 2 receive; Vaults push totalUnderlying, totalSupply and totalWithdrawalReq"
    }
  ]
}