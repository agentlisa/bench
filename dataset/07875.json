{
  "Title": "[G-01] Owner token enumeration is an extremely expensive operation but it is not essential to the protocol",
  "Content": "\n`LBToken` [enumerates token/bin IDs owned by users in a pair](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L26-L27). The enumeration is only exposed through [two external functions](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L96-L109), which are just for convenience for off-chain usage, and not necessary for the functionality of the protocol. Removing enumeration will save tremendous amounts of gas during essential operations of adding and removing liquidity.\n\n### Impact of enumeration\n\nOpenZeppelinâ€™s EnumerableSet roughly costs 50,000 gas when adding and removing elements from the set. Even for a small price range, adding liquidity in Liquidity Book requires minting tokens from many bins. For example, currently [the testnet user interface](https://gadgetzan.traderjoexyz.com/poolv2/0xb6076c93701d6a07266c31066b298aec6dd65c2d/0xab231a5744c8e6c45481754928ccffffd4aa0732/1) mints 31 tokens when adding liquidity in a normal distribution shape. This operation [roughly costs 4,000,000 gas](https://testnet.snowtrace.io/tx/0x88812398557021281e52eacf38f5064a344d4bee0290e96b37ffc2bea6102042), and removal costs about half of that. Given a volatile market, we can expect users to remove and re-add liquidity pretty often. This coupled operation costs around 6,000,000 gas if you have the minimum amount of bins in a normal distribution (31 as allowed by the current UI), which will be about 0.15 AVAX (25 nAVAX base fee). That would be `$2.25` in current AVAX price (`$15`). And that would be `$15` when AVAX is `$100`, and `$120` when AVAX is `$100` and network is heavily used (200 nAVAX base fee). Given that the protocol needs `swap_fee_earned / gas_fee_to_move_liquidity` to be greater than `1` to incentivize users to chase the price to concentrate the liquidity, the mint & burn fees must be as little as possible to allow non-whales to be also able to profitably move around their liquidity. Removing the enumeration can nearly halve that cost, making the protocol enticing to more users.\n\n### [Non-]reasons to enumerate\n\nEnumeration allows user interfaces to easily see which bins a user is in directly from the blockchain. With the absence of enumeration, Trader Joe will need to index this information either using in-house tools or using something like The Graph. Trader Joe team is already familiar with indexing through their NFT marketplace Joepegs, therefore it seems practical for them to go off-chain indexing route.\n\nEnumeration allows a decentralized way to pull the information from the blockchain. We have to admit that not enumerating would be in detriment to user interfaces that would have wanted to integrate Liquidity Book by using decentralized methods only. However, that is a very small percent of builders that hold such principles. The rest of the builders can also use off-chain indexing.\n\nThere is also the end user who might want to learn which bins they are in conveniently using decentralized methods. They can still do this in decentralized manner by checking all the bins, given the bin IDs are determined by step and price and have a range of few thousand (bin step = 100) to few millions (bin step = 1). Admittedly this is not very convenient, but it is doable.\n\n### Diff to remove enumeration\n\n*For diff that removes the enumeration from the code and tests, see warden's [original submission](https://github.com/code-423n4/2022-10-traderjoe-findings/issues/250).*\n\n### Gas savings\n\nBelow is the output of `forge snapshot --diff | tail -65` converted to CSV. Especially see `testInternalBurn` and `testInternalMint` functions showing greater than `50%` savings.\n\n```csv\nTest Function,Gas Cost Difference,Percent Difference\ntestSetLBPairImplementation(),-460002,-2.742%\ntestConstructor(uint16,uint16,uint16,uint16,uint16,uint24,uint16,uint24),-153429,-3.014%\ntestGetSwapInOverflowReverts(),-67031,-9.004%\ntestGetSwapOutWithMultipleChoices(),-427507,-10.436%\ntestOracleSampleFromWith2Samples(),-67031,-12.911%\ntestSwapYtoXSingleBinFromGetSwapIn(),-66966,-13.118%\ntestSwapYtoXSingleBinFromGetSwapOut(),-67031,-13.449%\ntestSwapXtoYSingleBinFromGetSwapOut(),-67031,-13.450%\ntestSwapXtoYSingleBinFromGetSwapIn(),-67031,-13.501%\ntestOracleSampleFromEdgeCases(),-67009,-13.970%\ntestFuzzingAddLiquidity(uint256),-157150,-15.139%\ntestDistributionOverflowReverts(),-134018,-15.454%\ntestOracleSampleFromWith100Samples(),-4487757,-17.917%\ntestClaimFeesComplex(uint256,uint256),-247423,-18.921%\ntestForIdSlippageCaughtReverts(),-427485,-19.194%\ntestClaimProtocolFees(),-247401,-19.862%\ntestClaimFeesY(),-247335,-20.163%\ntestClaimFeesX(),-247335,-20.163%\ntestFeesOnTokenTransfer(),-284146,-20.361%\ntestSwapWithDifferentBinSteps(),-427529,-20.375%\ntestForAmountSlippageCaughtReverts(),-473364,-21.279%\ntestGetSwapInWrongAmountsReverts(),-427485,-21.326%\ntestFlawedCompositionFactor(),-359365,-21.362%\ntestGetSwapInMoreBins(),-427031,-21.706%\ntestInsufficientLiquidityMinted(),-359321,-21.806%\ntestGetSwapOutOnComplexRoute(),-427464,-22.719%\ntestGetSwapInOnComplexRoute(),-427507,-22.968%\ntestOracleSampleFromWith100SamplesNotAllInitialized(),-4484457,-22.991%\ntestAddLiquidityIgnored(),-428376,-23.297%\ntestGetSwapInWithMultipleChoices(),-427507,-23.756%\ntestSwapYtoXDistantBinsFromGetSwapOut(),-427421,-23.911%\ntestSwapYtoXDistantBinsFromGetSwapIn(),-427421,-23.933%\ntestBalanceOfBatch(),-256383,-24.074%\ntestFeeOnActiveBinReverse(),-213936,-24.331%\ntestFeeOnActiveBin(),-213936,-24.331%\ntestSwapXtoYDistantBinsFromGetSwapOut(),-427486,-24.412%\ntestSafeBatchTransferNotApprovedReverts(),-256343,-24.420%\ntestSwapXtoYDistantBinsFromGetSwapIn(),-427486,-24.425%\ntestSafeTransferNotApprovedReverts(),-256376,-24.488%\ntestFlashloan(),-427513,-24.826%\ntestSwapXtoYConsecutiveBinFromGetSwapOut(),-427486,-25.050%\ntestSwapXtoYConsecutiveBinFromGetSwapIn(),-427486,-25.064%\ntestSwapYtoXConsecutiveBinFromGetSwapOut(),-427486,-25.089%\ntestSwapYtoXConsecutiveBinFromGetSwapIn(),-427486,-25.104%\ntestBurnLiquidity(),-477535,-25.129%\ntestSafeTransferFrom(),-295891,-25.295%\ntestGetSwapOutOnV2Pair(),-427507,-26.931%\ntestGetSwapInOnV2Pair(),-427507,-26.953%\ntestSweepLBToken(),-489987,-27.188%\ntestModifierCheckLength(),-535964,-28.163%\ntestSafeTransferFromReverts(),-537662,-28.222%\ntestForceDecay(),-2319546,-28.916%\ntestSafeBatchTransferFromReverts(),-606907,-29.824%\ntestAddLiquidityTaxToken(),-1076244,-29.978%\ntestTLowerThanTimestamp(),-2319913,-30.143%\ntestRemoveLiquidityReverseOrder(),-709108,-33.958%\ntestAddLiquidityNoSlippage(),-709107,-33.960%\ntestAddLiquidityAVAXReversed(),-1608674,-35.141%\ntestAddLiquidityAVAX(),-1758599,-35.555%\ntestSafeBatchTransferFrom(),-570685,-36.100%\ntestRemoveLiquiditySlippageReverts(),-2670446,-42.380%\ntestInternalBurn(uint256,uint256),-67156,-53.633%\ntestInternalMint(uint256),-67231,-55.603%\ntestInternalExcessiveBurnAmountReverts(uint128,uint128),-66987,-56.306%\nOverall,-39447398,-1550.248%\n```\n\nNote that there are other instances of enumeration in the protocol. However, they only cost gas in admin functions or during pair creation. Also they enumerate addresses. Therefore I believe them to be justified, hence I only focused on enumeration of this core protocol functionality (adding and removing liquidity). I think it is essential to remove this enumeration to improve the efficiency of the protocol. Reducing gas cost during adding or removing liquidity is of utmost importance for the optimization of this protocol, as it will make it feasible to do bin operations at greater scale.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-trader-joe-v2-contest",
  "Code": [
    {
      "filename": "src/LBToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin/utils/structs/EnumerableSet.sol\";\n\nimport \"./LBErrors.sol\";\nimport \"./interfaces/ILBToken.sol\";\n\n/// @title Liquidity Book Token\n/// @author Trader Joe\n/// @notice The LBToken is an implementation of a multi-token.\n/// It allows to create multi-ERC20 represented by their ids\ncontract LBToken is ILBToken {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @dev Mapping from token id to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    /// @dev Mapping from account to spender approvals\n    mapping(address => mapping(address => bool)) private _spenderApprovals;\n\n    /// @dev Mapping from token id to total supplies\n    mapping(uint256 => uint256) private _totalSupplies;\n\n    /// @dev  Mapping from account to set of ids, where user currently have a non-zero balance\n    mapping(address => EnumerableSet.UintSet) private _userIds;\n\n    string private constant _name = \"Liquidity Book Token\";\n    string private constant _symbol = \"LBT\";\n\n    modifier checkApproval(address _from, address _spender) {\n        if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender);\n        _;\n    }\n\n    modifier checkAddresses(address _from, address _to) {\n        if (_from == address(0) || _to == address(0)) revert LBToken__TransferFromOrToAddress0();\n        _;\n    }\n\n    modifier checkLength(uint256 _lengthA, uint256 _lengthB) {\n        if (_lengthA != _lengthB) revert LBToken__LengthMismatch(_lengthA, _lengthB);\n        _;\n    }\n\n    /// @notice Returns the name of the token\n    /// @return The name of the token\n    function name() public pure virtual override returns (string memory) {\n        return _name;\n    }\n\n    /// @notice Returns the symbol of the token, usually a shorter version of the name\n    /// @return The symbol of the token\n    function symbol() public pure virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice Returns the total supply of token of type `id`\n    /// @dev This is the amount of token of type `id` minted minus the amount burned\n    /// @param _id The token id\n    /// @return The total supply of that token id\n    function totalSupply(uint256 _id) public view virtual override returns (uint256) {\n        return _totalSupplies[_id];\n    }\n\n    /// @notice Returns the amount of tokens of type `id` owned by `_account`\n    /// @param _account The address of the owner\n    /// @param _id The token id\n    /// @return The amount of tokens of type `id` owned by `_account`\n    function balanceOf(address _account, uint256 _id) public view virtual override returns (uint256) {\n        return _balances[_id][_account];\n    }\n\n    /// @notice Return the balance of multiple (account/id) pairs\n    /// @param _accounts The addresses of the owners\n    /// @param _ids The token ids\n    /// @return batchBalances The balance for each (account, id) pair\n    function balanceOfBatch(address[] memory _accounts, uint256[] memory _ids)\n        public\n        view\n        virtual\n        override\n        checkLength(_accounts.length, _ids.length)\n        returns (uint256[] memory batchBalances)\n    {\n        batchBalances = new uint256[](_accounts.length);\n\n        unchecked {\n            for (uint256 i; i < _accounts.length; ++i) {\n                batchBalances[i] = balanceOf(_accounts[i], _ids[i]);\n            }\n        }\n    }\n\n    /// @notice Returns the type id at index `_index` where `account` has a non-zero balance\n    /// @param _account The address of the account\n    /// @param _index The position index\n    /// @return The `account` non-zero position at index `_index`\n    function userPositionAtIndex(address _account, uint256 _index) public view virtual override returns (uint256) {\n        return _userIds[_account].at(_index);\n    }\n\n    /// @notice Returns the number of non-zero balances of `account`\n    /// @param _account The address of the account\n    /// @return The number of non-zero balances of `account`\n    function userPositionNumber(address _account) public view virtual override returns (uint256) {\n        return _userIds[_account].length();\n    }\n\n    /// @notice Returns true if `spender` is approved to transfer `_account`'s tokens\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @return True if `spender` is approved to transfer `_account`'s tokens\n    function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) {\n        return _isApprovedForAll(_owner, _spender);\n    }\n\n    /// @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\n    /// @param _spender The address of the spender\n    /// @param _approved The boolean value to grant or revoke permission\n    function setApprovalForAll(address _spender, bool _approved) public virtual override {\n        _setApprovalForAll(msg.sender, _spender, _approved);\n    }\n\n    /// @notice Transfers `_amount` token of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to send\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) {\n        address _spender = msg.sender;\n\n        _transfer(_from, _to, _id, _amount);\n\n        emit TransferSingle(_spender, _from, _to, _id, _amount);\n    }\n\n    /// @notice Batch transfers `_amount` tokens of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the tokens\n    /// @param _to The address of the recipient\n    /// @param _ids The list of token ids\n    /// @param _amounts The list of amounts to send\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    )\n        public\n        virtual\n        override\n        checkLength(_ids.length, _amounts.length)\n        checkAddresses(_from, _to)\n        checkApproval(_from, msg.sender)\n    {\n        unchecked {\n            for (uint256 i; i < _ids.length; ++i) {\n                _transfer(_from, _to, _ids[i], _amounts[i]);\n            }\n        }\n\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n    }\n\n    /// @notice Internal function to transfer `_amount` tokens of type `_id` from `_from` to `_to`\n    /// @param _from The address of the owner of the token\n    /// @param _to The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to send\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        uint256 _fromBalance = _balances[_id][_from];\n        if (_fromBalance < _amount) revert LBToken__TransferExceedsBalance(_from, _id, _amount);\n\n        _beforeTokenTransfer(_from, _to, _id, _amount);\n\n        uint256 _toBalance = _balances[_id][_to];\n\n        unchecked {\n            _balances[_id][_from] = _fromBalance - _amount;\n            _balances[_id][_to] = _toBalance + _amount;\n        }\n\n        _remove(_from, _id, _fromBalance, _amount);\n        _add(_to, _id, _toBalance, _amount);\n    }\n\n    /// @dev Creates `_amount` tokens of type `_id`, and assigns them to `_account`\n    /// @param _account The address of the recipient\n    /// @param _id The token id\n    /// @param _amount The amount to mint\n    function _mint(\n        address _account,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        if (_account == address(0)) revert LBToken__MintToAddress0();\n\n        _beforeTokenTransfer(address(0), _account, _id, _amount);\n\n        _totalSupplies[_id] += _amount;\n\n        uint256 _accountBalance = _balances[_id][_account];\n        unchecked {\n            _balances[_id][_account] = _accountBalance + _amount;\n        }\n\n        _add(_account, _id, _accountBalance, _amount);\n\n        emit TransferSingle(msg.sender, address(0), _account, _id, _amount);\n    }\n\n    /// @dev Destroys `_amount` tokens of type `_id` from `_account`\n    /// @param _account The address of the owner\n    /// @param _id The token id\n    /// @param _amount The amount to destroy\n    function _burn(\n        address _account,\n        uint256 _id,\n        uint256 _amount\n    ) internal virtual {\n        if (_account == address(0)) revert LBToken__BurnFromAddress0();\n\n        uint256 _accountBalance = _balances[_id][_account];\n        if (_accountBalance < _amount) revert LBToken__BurnExceedsBalance(_account, _id, _amount);\n\n        _beforeTokenTransfer(address(0), _account, _id, _amount);\n\n        unchecked {\n            _balances[_id][_account] = _accountBalance - _amount;\n            _totalSupplies[_id] -= _amount;\n        }\n\n        _remove(_account, _id, _accountBalance, _amount);\n\n        emit TransferSingle(msg.sender, _account, address(0), _id, _amount);\n    }\n\n    /// @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @param _approved The boolean value to grant or revoke permission\n    function _setApprovalForAll(\n        address _owner,\n        address _spender,\n        bool _approved\n    ) internal virtual {\n        if (_owner == _spender) revert LBToken__SelfApproval(_owner);\n\n        _spenderApprovals[_owner][_spender] = _approved;\n        emit ApprovalForAll(_owner, _spender, _approved);\n    }\n\n    /// @notice Returns true if `spender` is approved to transfer `owner`'s tokens\n    /// or if `sender` is the `owner`\n    /// @param _owner The address of the owner\n    /// @param _spender The address of the spender\n    /// @return True if `spender` is approved to transfer `owner`'s tokens\n    function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {\n        return _owner == _spender || _spenderApprovals[_owner][_spender];\n    }\n\n    /// @notice Internal function to add an id to an user's set\n    /// @param _account The user's address\n    /// @param _id The id of the token\n    /// @param _accountBalance The user's balance\n    /// @param _amount The amount of tokens\n    function _add(\n        address _account,\n        uint256 _id,\n        uint256 _accountBalance,\n        uint256 _amount\n    ) internal {\n        if (_accountBalance == 0 && _amount != 0) {\n            _userIds[_account].add(_id);\n        }\n    }\n\n    /// @notice Internal function to remove an id from an user's set\n    /// @param _account The user's address\n    /// @param _id The id of the token\n    /// @param _accountBalance The user's balance\n    /// @param _amount The amount of tokens\n    function _remove(\n        address _account,\n        uint256 _id,\n        uint256 _accountBalance,\n        uint256 _amount\n    ) internal {\n        if (_accountBalance == _amount && _amount != 0) {\n            _userIds[_account].remove(_id);\n        }\n    }\n\n    /// @notice Hook that is called before any token transfer. This includes minting\n    /// and burning.\n    ///\n    /// Calling conditions (for each `id` and `amount` pair):\n    ///\n    /// - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n    /// of token type `id` will be  transferred to `to`.\n    /// - When `from` is zero, `amount` tokens of token type `id` will be minted\n    /// for `to`.\n    /// - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n    /// will be burned.\n    /// - `from` and `to` are never both zero.\n    /// @param from The address of the owner of the token\n    /// @param to The address of the recipient of the  token\n    /// @param id The id of the token\n    /// @param amount The amount of token of type `id`\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {}\n}"
    }
  ]
}