{
  "Title": "M-6: M-03 wrong token address on `ShortLongSpell.sol`",
  "Content": "# Issue M-6: M-03 wrong token address on `ShortLongSpell.sol` \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/114 \n\n## Found by \nCh\\_301\n## Summary\n\n## Vulnerability Detail\n[ShortLongSpell.openPosition()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#LL111C4-L151C6) send `uToken` to SoftVault then deposit it into the Compound protocol to earn a passive yield. In return, SPELL receives share tokes of SoftVault  `address(strategy.vault)`  \n\n`WERC20.sol` should receive `address(strategy.vault)` token, but the logic of `ShortLongSpell.sol` subcall (WERC20.sol) `wrapper.burn()` and pass the `uToken` address (please check the Code Snippet part) instead of `strategy.vault` address\n\n## Impact\nShort/Long Spell will never work\n\n## Code Snippet\n1- https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L128-L141\n```solidity\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n```\n2- https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L229-L234\n```solidity\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n1- \n```diff\n-            address burnToken = address(ISoftVault(strategy.vault).uToken());\n+            address burnToken = strategy.vault;\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n```\n2- \n```diff\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n-            address(ISoftVault(strategy.vault).uToken()),\n+            strategy.vault,\n            param.amountPosRemove\n        );\n```\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nThe same reason as #116 but in a different implementation and it needs another solution \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> The same reason as #116 but in a different implementation and it needs another solution \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nThis is a valid issue\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> This is a valid issue\n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/ShortLongSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BasicSpell.sol\";\n\nimport \"../interfaces/ISoftVault.sol\";\nimport \"../interfaces/IWERC20.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/**\n * @title Short/Long Spell\n * @author BlueberryProtocol\n * @notice Short/Long Spell is the factory contract that\n * defines how Blueberry Protocol interacts for leveraging\n * an asset either long or short\n */\ncontract ShortLongSpell is BasicSpell {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev WERC20\n    IWERC20 public wrapper;\n\n    /// @dev paraswap AugustusSwapper address\n    address public augustusSwapper;\n\n    /// @dev paraswap TokenTransferProxy address\n    address public tokenTransferProxy;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        if (augustusSwapper_ == address(0)) revert Errors.ZERO_ADDRESS();\n        if (tokenTransferProxy_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n        wrapper = IWERC20(werc20_);\n\n        __BasicSpell_init(bank_, werc20_, weth_);\n    }\n\n    /**\n     * @notice Internal function to swap token using paraswap assets\n     * @dev Deposit isolated underlying to Blueberry Money Market,\n     *      Borrow tokens from Blueberry Money Market,\n     *      Swap borrowed token to another token\n     *      Then deposit swapped token to softvault,\n     *\n     */\n    function _deposit(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt;\n        if (strTokenAmt < swapData.expectedAmount)\n            revert Errors.SWAP_FAILED(address(swapToken));\n\n        // 4. Deposit to SoftVault directly\n        _ensureApprove(\n            address(swapToken),\n            address(strategy.vault),\n            strTokenAmt\n        );\n        ISoftVault(strategy.vault).deposit(strTokenAmt);\n\n        // 5. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets\n     */\n    function openPosition(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        if (\n            address(ISoftVault(strategy.vault).uToken()) != param.borrowToken ||\n            swapData.fromToken != param.borrowToken\n        ) revert Errors.INCORRECT_LP(param.borrowToken);\n\n        // 1-3 Swap to strategy underlying token, deposit to softvault\n        _deposit(param, swapData);\n\n        // 4. Put collateral -\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collSize = pos.collateralSize;\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n        }\n\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Internal function to withdraw assets from SoftVault\n     * @dev Withdraw assets from Soft Vault,\n     *      Swap withdrawn assets to debt token,\n     *      Withdraw isolated collaterals from Blueberry Money Market,\n     *      Repay Debt and refund rest to user\n     */\n    function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n\n        Strategy memory strategy = strategies[param.strategyId];\n        ISoftVault vault = ISoftVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Calculate actual amount to remove\n        uint256 amountPosRemove = param.amountPosRemove;\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = vault.balanceOf(address(this));\n        }\n\n        // 2. Withdraw from softvault\n        vault.withdraw(amountPosRemove);\n\n        // 3. Swap strategy token to isolated collateral token\n        {\n            PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        }\n\n        // 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 5. Repay\n        {\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(positionId);\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets\n     */\n    function closePosition(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        if (address(ISoftVault(strategy.vault).uToken()) != swapData.fromToken)\n            revert Errors.INCORRECT_LP(swapData.fromToken);\n\n        address vault = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address posCollToken = pos.collToken;\n        uint256 collId = pos.collId;\n        if (IWERC20(posCollToken).getUnderlyingToken(collId) != vault)\n            revert Errors.INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(werc20))\n            revert Errors.INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n\n        // 2-7. Remove liquidity\n        _withdraw(param, swapData);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param swapToken Address of token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(\n        address swapToken,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(swapToken, maxPosSize);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/ShortLongSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BasicSpell.sol\";\n\nimport \"../interfaces/ISoftVault.sol\";\nimport \"../interfaces/IWERC20.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/**\n * @title Short/Long Spell\n * @author BlueberryProtocol\n * @notice Short/Long Spell is the factory contract that\n * defines how Blueberry Protocol interacts for leveraging\n * an asset either long or short\n */\ncontract ShortLongSpell is BasicSpell {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev WERC20\n    IWERC20 public wrapper;\n\n    /// @dev paraswap AugustusSwapper address\n    address public augustusSwapper;\n\n    /// @dev paraswap TokenTransferProxy address\n    address public tokenTransferProxy;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        if (augustusSwapper_ == address(0)) revert Errors.ZERO_ADDRESS();\n        if (tokenTransferProxy_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n        wrapper = IWERC20(werc20_);\n\n        __BasicSpell_init(bank_, werc20_, weth_);\n    }\n\n    /**\n     * @notice Internal function to swap token using paraswap assets\n     * @dev Deposit isolated underlying to Blueberry Money Market,\n     *      Borrow tokens from Blueberry Money Market,\n     *      Swap borrowed token to another token\n     *      Then deposit swapped token to softvault,\n     *\n     */\n    function _deposit(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt;\n        if (strTokenAmt < swapData.expectedAmount)\n            revert Errors.SWAP_FAILED(address(swapToken));\n\n        // 4. Deposit to SoftVault directly\n        _ensureApprove(\n            address(swapToken),\n            address(strategy.vault),\n            strTokenAmt\n        );\n        ISoftVault(strategy.vault).deposit(strTokenAmt);\n\n        // 5. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets\n     */\n    function openPosition(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        if (\n            address(ISoftVault(strategy.vault).uToken()) != param.borrowToken ||\n            swapData.fromToken != param.borrowToken\n        ) revert Errors.INCORRECT_LP(param.borrowToken);\n\n        // 1-3 Swap to strategy underlying token, deposit to softvault\n        _deposit(param, swapData);\n\n        // 4. Put collateral -\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collSize = pos.collateralSize;\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n        }\n\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Internal function to withdraw assets from SoftVault\n     * @dev Withdraw assets from Soft Vault,\n     *      Swap withdrawn assets to debt token,\n     *      Withdraw isolated collaterals from Blueberry Money Market,\n     *      Repay Debt and refund rest to user\n     */\n    function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n\n        Strategy memory strategy = strategies[param.strategyId];\n        ISoftVault vault = ISoftVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Calculate actual amount to remove\n        uint256 amountPosRemove = param.amountPosRemove;\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = vault.balanceOf(address(this));\n        }\n\n        // 2. Withdraw from softvault\n        vault.withdraw(amountPosRemove);\n\n        // 3. Swap strategy token to isolated collateral token\n        {\n            PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        }\n\n        // 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 5. Repay\n        {\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(positionId);\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets\n     */\n    function closePosition(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        if (address(ISoftVault(strategy.vault).uToken()) != swapData.fromToken)\n            revert Errors.INCORRECT_LP(swapData.fromToken);\n\n        address vault = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address posCollToken = pos.collToken;\n        uint256 collId = pos.collId;\n        if (IWERC20(posCollToken).getUnderlyingToken(collId) != vault)\n            revert Errors.INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(werc20))\n            revert Errors.INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n\n        // 2-7. Remove liquidity\n        _withdraw(param, swapData);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param swapToken Address of token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(\n        address swapToken,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(swapToken, maxPosSize);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/ShortLongSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BasicSpell.sol\";\n\nimport \"../interfaces/ISoftVault.sol\";\nimport \"../interfaces/IWERC20.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/**\n * @title Short/Long Spell\n * @author BlueberryProtocol\n * @notice Short/Long Spell is the factory contract that\n * defines how Blueberry Protocol interacts for leveraging\n * an asset either long or short\n */\ncontract ShortLongSpell is BasicSpell {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev WERC20\n    IWERC20 public wrapper;\n\n    /// @dev paraswap AugustusSwapper address\n    address public augustusSwapper;\n\n    /// @dev paraswap TokenTransferProxy address\n    address public tokenTransferProxy;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        if (augustusSwapper_ == address(0)) revert Errors.ZERO_ADDRESS();\n        if (tokenTransferProxy_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n        wrapper = IWERC20(werc20_);\n\n        __BasicSpell_init(bank_, werc20_, weth_);\n    }\n\n    /**\n     * @notice Internal function to swap token using paraswap assets\n     * @dev Deposit isolated underlying to Blueberry Money Market,\n     *      Borrow tokens from Blueberry Money Market,\n     *      Swap borrowed token to another token\n     *      Then deposit swapped token to softvault,\n     *\n     */\n    function _deposit(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt;\n        if (strTokenAmt < swapData.expectedAmount)\n            revert Errors.SWAP_FAILED(address(swapToken));\n\n        // 4. Deposit to SoftVault directly\n        _ensureApprove(\n            address(swapToken),\n            address(strategy.vault),\n            strTokenAmt\n        );\n        ISoftVault(strategy.vault).deposit(strTokenAmt);\n\n        // 5. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets\n     */\n    function openPosition(\n        OpenPosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        if (\n            address(ISoftVault(strategy.vault).uToken()) != param.borrowToken ||\n            swapData.fromToken != param.borrowToken\n        ) revert Errors.INCORRECT_LP(param.borrowToken);\n\n        // 1-3 Swap to strategy underlying token, deposit to softvault\n        _deposit(param, swapData);\n\n        // 4. Put collateral -\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collSize = pos.collateralSize;\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n        }\n\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Internal function to withdraw assets from SoftVault\n     * @dev Withdraw assets from Soft Vault,\n     *      Swap withdrawn assets to debt token,\n     *      Withdraw isolated collaterals from Blueberry Money Market,\n     *      Repay Debt and refund rest to user\n     */\n    function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n\n        Strategy memory strategy = strategies[param.strategyId];\n        ISoftVault vault = ISoftVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Calculate actual amount to remove\n        uint256 amountPosRemove = param.amountPosRemove;\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = vault.balanceOf(address(this));\n        }\n\n        // 2. Withdraw from softvault\n        vault.withdraw(amountPosRemove);\n\n        // 3. Swap strategy token to isolated collateral token\n        {\n            PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        }\n\n        // 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 5. Repay\n        {\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(positionId);\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets\n     */\n    function closePosition(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        if (address(ISoftVault(strategy.vault).uToken()) != swapData.fromToken)\n            revert Errors.INCORRECT_LP(swapData.fromToken);\n\n        address vault = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address posCollToken = pos.collToken;\n        uint256 collId = pos.collId;\n        if (IWERC20(posCollToken).getUnderlyingToken(collId) != vault)\n            revert Errors.INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(werc20))\n            revert Errors.INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n\n        // 2-7. Remove liquidity\n        _withdraw(param, swapData);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param swapToken Address of token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(\n        address swapToken,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(swapToken, maxPosSize);\n    }\n}"
    }
  ]
}