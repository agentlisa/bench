{
  "Title": "[M-02] PRBMATH `SD59x18.exp()` reverts on hugely negative numbers.",
  "Content": "\n<https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/libraries/ContinuousGDA.sol#L34-L36><br>\n<https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/libraries/ContinuousGDA.sol#L64><br>\n<https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/libraries/ContinuousGDA.sol#L85-L87><br>\n<https://github.com/PaulRBerg/prb-math/blob/5959ef59f906d689c2472ed08797872a1cc00644/src/sd59x18/Math.sol#L168-L181>\n\n`ContinuousGDA.sol` inherits a version of `PRB Math` that contains a vulnerability in the `SD59x18.exp()` function, which can be reverted on hugely negative numbers. `SD59x18.exp()` is used for calculations in `ContinuousGDA.sol#purchasePrice()` , `ContinuousGDA.sol#purchaseAmount()` and `ContinuousGDA.sol#computeK()`. Recently, the creators of the `PRBMath` have acknowledged this situation. Here is the corresponding [link](https://github.com/PaulRBerg/prb-math/issues/200). This issue should be proactively corrected by `PoolTogether` to avoid unexpected results that corrupt the protocol's computation flow.\n\n### Proof of Concept\n\nThere are 05 instances of this issue: [see here](https://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/libraries/ContinuousGDA.sol#L34-L36)\n\n    File: ContinuousGDA.sol\n    34:    topE = topE.exp().sub(ONE);\n    36:    bottomE = bottomE.exp();\n    64:    SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n    85:    SD59x18 eValue = exponent.exp();\n    87:    SD59x18 denominator = (_decayConstant.mul(_purchaseAmount).div(_emissionRate)).exp().sub(ONE);\n\n[Proof of the bug acknowledgment by the creator of the PRBMath](https://github.com/PaulRBerg/prb-math/issues/200).<br>\n`SD59x18.exp()` correctly returns 0 for inputs less than (roughly) -41.45e18, however it starts to throw `PRBMath_SD59x18_Exp2_InputTooBig` when the input gets hugely negative. This is because of the unchecked multiplication in `exp()` overflowing into positive values: [see here](https://github.com/PaulRBerg/prb-math/blob/5959ef59f906d689c2472ed08797872a1cc00644/src/sd59x18/Math.sol#L168-L181).\n\n    function exp(SD59x18 x) pure returns (SD59x18 result) {\n        int256 xInt = x.unwrap();\n\n        // This check prevents values greater than 192e18 from being passed to {exp2}.\n        if (xInt > uEXP_MAX_INPUT) {\n            revert Errors.PRBMath_SD59x18_Exp_InputTooBig(x);\n        }\n\n        unchecked {\n            // Inline the fixed-point multiplication to save gas.\n            int256 doubleUnitProduct = xInt * uLOG2_E;                // <== overflow\n            result = exp2(wrap(doubleUnitProduct / uUNIT));\n        }\n    }\n\n### Tools Used\n\nManual Review and [Proof of the bug acknowledgment by the creator of the PRBMath](https://github.com/PaulRBerg/prb-math/issues/200)\n\n### Recommended Mitigation Steps\n\nA potential fix would be to compare the input with the smallest (most negative) number that can be safely multiplied by `uLOG2_E`, and return 0 if it's smaller. Alternatively, `exp()` could return 0 for inputs smaller than -41.45e18, which are expected to be truncated to zero by `exp2()` anyway.\n\n### Assessed type\n\nMath\n\n**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/146#issuecomment-1673818283)**\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/146#issuecomment-1677023306):**\n > Would have been nice to see a concrete example where the input < -41.45e18. \n> \n> Given that the pricing formula parameters are determined by the liquidation pair creator, it is a possibility to achieve this condition and have this bug invoked. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/libraries/ContinuousGDA.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { SD59x18, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\n/// @title ContinuousGDA\n/// @author G9 Software Inc.\n/// @notice Implements the Continous Gradual Dutch Auction formula\n/// See https://www.paradigm.xyz/2022/04/gda\n/// @dev Pricing formula adapted from https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/src/ContinuousGDA.sol\nlibrary ContinuousGDA {\n\n  /// @notice a helpful constant\n  SD59x18 internal constant ONE = SD59x18.wrap(1e18);\n\n  /// @notice Calculate purchase price for a given amount of tokens\n  /// @param _amount The amount of tokens to purchase\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The purchase price for the given amount of tokens\n  function purchasePrice(\n    SD59x18 _amount,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_amount.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 topE = _decayConstant.mul(_amount).div(_emissionRate);\n    topE = topE.exp().sub(ONE);\n    SD59x18 bottomE = _decayConstant.mul(_timeSinceLastAuctionStart);\n    bottomE = bottomE.exp();\n    SD59x18 result;\n    if (_emissionRate.unwrap() > 1e18) {\n      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n    } else {\n      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n    }\n    return result;\n  }\n\n  /// @notice Computes the amount of tokens that can be purchased for a given price\n  /// @dev Note that this formula has significant floating point differences to the above. Either one, not both, should be used.\n  /// @param _price The price willing to be paid\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The number of tokens that can be purchased for the given price\n  function purchaseAmount(\n    SD59x18 _price,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_price.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n    SD59x18 lnParam = _k.add(_price.mul(_emissionRate).mul(exp)).div(_k);\n    SD59x18 numerator = _emissionRate.mul(lnParam.ln());\n    SD59x18 amount = numerator.div(_decayConstant);\n    return amount;\n  }\n\n  /// @notice Computes an initial price for the CGDA such that the purchase amount will cost the price at the given timestamp\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _targetFirstSaleTime The timestamp at which the CGDA price for the given amount matches the given price\n  /// @param _purchaseAmount The amount of tokens to purchase\n  /// @param _price The price to be paid for the amount of tokens\n  function computeK(\n    SD59x18 _emissionRate,\n    SD59x18 _decayConstant,\n    SD59x18 _targetFirstSaleTime,\n    SD59x18 _purchaseAmount,\n    SD59x18 _price\n  ) internal pure returns (SD59x18) {\n    SD59x18 exponent = _decayConstant.mul(_targetFirstSaleTime);\n    SD59x18 eValue = exponent.exp();\n    SD59x18 multiplier = _emissionRate.mul(_price);\n    SD59x18 denominator = (_decayConstant.mul(_purchaseAmount).div(_emissionRate)).exp().sub(ONE);\n    SD59x18 result = eValue.div(denominator);\n    return result.mul(multiplier);\n  }\n}"
    },
    {
      "filename": "src/libraries/ContinuousGDA.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { SD59x18, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\n/// @title ContinuousGDA\n/// @author G9 Software Inc.\n/// @notice Implements the Continous Gradual Dutch Auction formula\n/// See https://www.paradigm.xyz/2022/04/gda\n/// @dev Pricing formula adapted from https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/src/ContinuousGDA.sol\nlibrary ContinuousGDA {\n\n  /// @notice a helpful constant\n  SD59x18 internal constant ONE = SD59x18.wrap(1e18);\n\n  /// @notice Calculate purchase price for a given amount of tokens\n  /// @param _amount The amount of tokens to purchase\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The purchase price for the given amount of tokens\n  function purchasePrice(\n    SD59x18 _amount,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_amount.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 topE = _decayConstant.mul(_amount).div(_emissionRate);\n    topE = topE.exp().sub(ONE);\n    SD59x18 bottomE = _decayConstant.mul(_timeSinceLastAuctionStart);\n    bottomE = bottomE.exp();\n    SD59x18 result;\n    if (_emissionRate.unwrap() > 1e18) {\n      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n    } else {\n      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n    }\n    return result;\n  }\n\n  /// @notice Computes the amount of tokens that can be purchased for a given price\n  /// @dev Note that this formula has significant floating point differences to the above. Either one, not both, should be used.\n  /// @param _price The price willing to be paid\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The number of tokens that can be purchased for the given price\n  function purchaseAmount(\n    SD59x18 _price,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_price.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n    SD59x18 lnParam = _k.add(_price.mul(_emissionRate).mul(exp)).div(_k);\n    SD59x18 numerator = _emissionRate.mul(lnParam.ln());\n    SD59x18 amount = numerator.div(_decayConstant);\n    return amount;\n  }\n\n  /// @notice Computes an initial price for the CGDA such that the purchase amount will cost the price at the given timestamp\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _targetFirstSaleTime The timestamp at which the CGDA price for the given amount matches the given price\n  /// @param _purchaseAmount The amount of tokens to purchase\n  /// @param _price The price to be paid for the amount of tokens\n  function computeK(\n    SD59x18 _emissionRate,\n    SD59x18 _decayConstant,\n    SD59x18 _targetFirstSaleTime,\n    SD59x18 _purchaseAmount,\n    SD59x18 _price\n  ) internal pure returns (SD59x18) {\n    SD59x18 exponent = _decayConstant.mul(_targetFirstSaleTime);\n    SD59x18 eValue = exponent.exp();\n    SD59x18 multiplier = _emissionRate.mul(_price);\n    SD59x18 denominator = (_decayConstant.mul(_purchaseAmount).div(_emissionRate)).exp().sub(ONE);\n    SD59x18 result = eValue.div(denominator);\n    return result.mul(multiplier);\n  }\n}"
    },
    {
      "filename": "src/libraries/ContinuousGDA.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { SD59x18, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\n/// @title ContinuousGDA\n/// @author G9 Software Inc.\n/// @notice Implements the Continous Gradual Dutch Auction formula\n/// See https://www.paradigm.xyz/2022/04/gda\n/// @dev Pricing formula adapted from https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/src/ContinuousGDA.sol\nlibrary ContinuousGDA {\n\n  /// @notice a helpful constant\n  SD59x18 internal constant ONE = SD59x18.wrap(1e18);\n\n  /// @notice Calculate purchase price for a given amount of tokens\n  /// @param _amount The amount of tokens to purchase\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The purchase price for the given amount of tokens\n  function purchasePrice(\n    SD59x18 _amount,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_amount.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 topE = _decayConstant.mul(_amount).div(_emissionRate);\n    topE = topE.exp().sub(ONE);\n    SD59x18 bottomE = _decayConstant.mul(_timeSinceLastAuctionStart);\n    bottomE = bottomE.exp();\n    SD59x18 result;\n    if (_emissionRate.unwrap() > 1e18) {\n      result = _k.div(_emissionRate).mul(topE).div(bottomE);\n    } else {\n      result = _k.mul(topE.div(_emissionRate.mul(bottomE)));\n    }\n    return result;\n  }\n\n  /// @notice Computes the amount of tokens that can be purchased for a given price\n  /// @dev Note that this formula has significant floating point differences to the above. Either one, not both, should be used.\n  /// @param _price The price willing to be paid\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _k The initial price of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _timeSinceLastAuctionStart The elapsed time since the last consumed timestamp\n  /// @return The number of tokens that can be purchased for the given price\n  function purchaseAmount(\n    SD59x18 _price,\n    SD59x18 _emissionRate,\n    SD59x18 _k,\n    SD59x18 _decayConstant,\n    SD59x18 _timeSinceLastAuctionStart\n  ) internal pure returns (SD59x18) {\n    if (_price.unwrap() == 0) {\n      return SD59x18.wrap(0);\n    }\n    SD59x18 exp = _decayConstant.mul(_timeSinceLastAuctionStart).exp();\n    SD59x18 lnParam = _k.add(_price.mul(_emissionRate).mul(exp)).div(_k);\n    SD59x18 numerator = _emissionRate.mul(lnParam.ln());\n    SD59x18 amount = numerator.div(_decayConstant);\n    return amount;\n  }\n\n  /// @notice Computes an initial price for the CGDA such that the purchase amount will cost the price at the given timestamp\n  /// @param _emissionRate The emission rate of the CGDA\n  /// @param _decayConstant The decay constant of the CGDA\n  /// @param _targetFirstSaleTime The timestamp at which the CGDA price for the given amount matches the given price\n  /// @param _purchaseAmount The amount of tokens to purchase\n  /// @param _price The price to be paid for the amount of tokens\n  function computeK(\n    SD59x18 _emissionRate,\n    SD59x18 _decayConstant,\n    SD59x18 _targetFirstSaleTime,\n    SD59x18 _purchaseAmount,\n    SD59x18 _price\n  ) internal pure returns (SD59x18) {\n    SD59x18 exponent = _decayConstant.mul(_targetFirstSaleTime);\n    SD59x18 eValue = exponent.exp();\n    SD59x18 multiplier = _emissionRate.mul(_price);\n    SD59x18 denominator = (_decayConstant.mul(_purchaseAmount).div(_emissionRate)).exp().sub(ONE);\n    SD59x18 result = eValue.div(denominator);\n    return result.mul(multiplier);\n  }\n}"
    },
    {
      "filename": "src/sd59x18/Math.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\nimport \"../Common.sol\" as Common;\nimport \"./Errors.sol\" as Errors;\nimport {\n    uEXP_MAX_INPUT,\n    uEXP2_MAX_INPUT,\n    uHALF_UNIT,\n    uLOG2_10,\n    uLOG2_E,\n    uMAX_SD59x18,\n    uMAX_WHOLE_SD59x18,\n    uMIN_SD59x18,\n    uMIN_WHOLE_SD59x18,\n    UNIT,\n    uUNIT,\n    uUNIT_SQUARED,\n    ZERO\n} from \"./Constants.sol\";\nimport { wrap } from \"./Helpers.sol\";\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Calculates the absolute value of x.\n///\n/// @dev Requirements:\n/// - x must be greater than `MIN_SD59x18`.\n///\n/// @param x The SD59x18 number for which to calculate the absolute value.\n/// @param result The absolute value of x as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction abs(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt == uMIN_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Abs_MinSD59x18();\n    }\n    result = xInt < 0 ? wrap(-xInt) : x;\n}\n\n/// @notice Calculates the arithmetic average of x and y.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The arithmetic average as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction avg(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n\n    unchecked {\n        // This operation is equivalent to `x / 2 +  y / 2`, and it can never overflow.\n        int256 sum = (xInt >> 1) + (yInt >> 1);\n\n        if (sum < 0) {\n            // If at least one of x and y is odd, add 1 to the result, because shifting negative numbers to the right\n            // rounds toward negative infinity. The right part is equivalent to `sum + (x % 2 == 1 || y % 2 == 1)`.\n            assembly (\"memory-safe\") {\n                result := add(sum, and(or(xInt, yInt), 1))\n            }\n        } else {\n            // Add 1 if both x and y are odd to account for the double 0.5 remainder truncated after shifting.\n            result = wrap(sum + (xInt & yInt & 1));\n        }\n    }\n}\n\n/// @notice Yields the smallest whole number greater than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because every whole value has (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x must be less than or equal to `MAX_WHOLE_SD59x18`.\n///\n/// @param x The SD59x18 number to ceil.\n/// @param result The smallest whole number greater than or equal to x, as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction ceil(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt > uMAX_WHOLE_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Ceil_Overflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt > 0) {\n                resultInt += uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Divides two SD59x18 numbers, returning a new SD59x18 number.\n///\n/// @dev This is an extension of {Common.mulDiv} for signed numbers, which works by computing the signs and the absolute\n/// values separately.\n///\n/// Notes:\n/// - Refer to the notes in {Common.mulDiv}.\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {Common.mulDiv}.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The denominator must not be zero.\n/// - The result must fit in SD59x18.\n///\n/// @param x The numerator as an SD59x18 number.\n/// @param y The denominator as an SD59x18 number.\n/// @param result The quotient as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction div(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Div_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    // Compute the absolute value (x*UNITÃ·y). The resulting value must fit in SD59x18.\n    uint256 resultAbs = Common.mulDiv(xAbs, uint256(uUNIT), yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert Errors.PRBMath_SD59x18_Div_Overflow(x, y);\n    }\n\n    // Check if x and y have the same sign using two's complement representation. The left-most bit represents the sign (1 for\n    // negative, 0 for positive or zero).\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs have the same sign, the result should be positive. Otherwise, it should be negative.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Calculates the natural exponent of x using the following formula:\n///\n/// $$\n/// e^x = 2^{x * log_2{e}}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {exp2}.\n///\n/// Requirements:\n/// - Refer to the requirements in {exp2}.\n/// - x must be less than 133_084258667509499441.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n\n    // This check prevents values greater than 192e18 from being passed to {exp2}.\n    if (xInt > uEXP_MAX_INPUT) {\n        revert Errors.PRBMath_SD59x18_Exp_InputTooBig(x);\n    }\n\n    unchecked {\n        // Inline the fixed-point multiplication to save gas.\n        int256 doubleUnitProduct = xInt * uLOG2_E;\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method using the following formula:\n///\n/// $$\n/// 2^{-x} = \\frac{1}{2^x}\n/// $$\n///\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n///\n/// Notes:\n/// - If x is less than -59_794705707972522261, the result is zero.\n///\n/// Requirements:\n/// - x must be less than 192e18.\n/// - The result must fit in SD59x18.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < 0) {\n        // The inverse of any number less than this is truncated to zero.\n        if (xInt < -59_794705707972522261) {\n            return ZERO;\n        }\n\n        unchecked {\n            // Inline the fixed-point inversion to save gas.\n            result = wrap(uUNIT_SQUARED / exp2(wrap(-xInt)).unwrap());\n        }\n    } else {\n        // Numbers greater than or equal to 192e18 don't fit in the 192.64-bit format.\n        if (xInt > uEXP2_MAX_INPUT) {\n            revert Errors.PRBMath_SD59x18_Exp2_InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x_192x64 = uint256((xInt << 64) / uUNIT);\n\n            // It is safe to cast the result to int256 due to the checks above.\n            result = wrap(int256(Common.exp2(x_192x64)));\n        }\n    }\n}\n\n/// @notice Yields the greatest whole number less than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x must be greater than or equal to `MIN_WHOLE_SD59x18`.\n///\n/// @param x The SD59x18 number to floor.\n/// @param result The greatest whole number less than or equal to x, as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction floor(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < uMIN_WHOLE_SD59x18) {\n        revert Errors.PRBMath_SD59x18_Floor_Underflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt < 0) {\n                resultInt -= uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right.\n/// of the radix point for negative numbers.\n/// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\n/// @param x The SD59x18 number to get the fractional part of.\n/// @param result The fractional part of x as an SD59x18 number.\nfunction frac(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(x.unwrap() % uUNIT);\n}\n\n/// @notice Calculates the geometric mean of x and y, i.e. $\\sqrt{x * y}$.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x * y must fit in SD59x18.\n/// - x * y must not be negative, since complex numbers are not supported.\n///\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction gm(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    int256 yInt = y.unwrap();\n    if (xInt == 0 || yInt == 0) {\n        return ZERO;\n    }\n\n    unchecked {\n        // Equivalent to `xy / x != y`. Checking for overflow this way is faster than letting Solidity do it.\n        int256 xyInt = xInt * yInt;\n        if (xyInt / xInt != yInt) {\n            revert Errors.PRBMath_SD59x18_Gm_Overflow(x, y);\n        }\n\n        // The product must not be negative, since complex numbers are not supported.\n        if (xyInt < 0) {\n            revert Errors.PRBMath_SD59x18_Gm_NegativeProduct(x, y);\n        }\n\n        // We don't need to multiply the result by `UNIT` here because the x*y product picked up a factor of `UNIT`\n        // during multiplication. See the comments in {Common.sqrt}.\n        uint256 resultUint = Common.sqrt(uint256(xyInt));\n        result = wrap(int256(resultUint));\n    }\n}\n\n/// @notice Calculates the inverse of x.\n///\n/// @dev Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - x must not be zero.\n///\n/// @param x The SD59x18 number for which to calculate the inverse.\n/// @return result The inverse as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction inv(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(uUNIT_SQUARED / x.unwrap());\n}\n\n/// @notice Calculates the natural logarithm of x using the following formula:\n///\n/// $$\n/// ln{x} = log_2{x} / log_2{e}\n/// $$\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2}.\n/// - The precision isn't sufficiently fine-grained to return exactly `UNIT` when the input is `E`.\n///\n/// Requirements:\n/// - Refer to the requirements in {log2}.\n///\n/// @param x The SD59x18 number for which to calculate the natural logarithm.\n/// @return result The natural logarithm as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction ln(SD59x18 x) pure returns (SD59x18 result) {\n    // Inline the fixed-point multiplication to save gas. This is overflow-safe because the maximum value that\n    // {log2} can return is ~195_205294292027477728.\n    result = wrap(log2(x).unwrap() * uUNIT / uLOG2_E);\n}\n\n/// @notice Calculates the common logarithm of x using the following formula:\n///\n/// $$\n/// log_{10}{x} = log_2{x} / log_2{10}\n/// $$\n///\n/// However, if x is an exact power of ten, a hard coded value is returned.\n///\n/// @dev Notes:\n/// - Refer to the notes in {log2}.\n///\n/// Requirements:\n/// - Refer to the requirements in {log2}.\n///\n/// @param x The SD59x18 number for which to calculate the common logarithm.\n/// @return result The common logarithm as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction log10(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt < 0) {\n        revert Errors.PRBMath_SD59x18_Log_InputTooSmall(x);\n    }\n\n    // Note that the `mul` in this block is the standard multiplication operation, not {SD59x18.mul}.\n    // prettier-ignore\n    assembly (\"memory-safe\") {\n        switch x\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\n        case 1000000000000000000 { result := 0 }\n        case 10000000000000000000 { result := uUNIT }\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\n        default { result := uMAX_SD59x18 }\n    }\n\n    if (result.unwrap() == uMAX_SD59x18) {\n        unchecked {\n            // Inline the fixed-point division to save gas.\n            result = wrap(log2(x).unwrap() * uUNIT / uLOG2_10);\n        }\n    }\n}\n\n/// @notice Calculates the binary logarithm of x using the iterative approximation algorithm:\n///\n/// $$\n/// log_2{x} = n + log_2{y}, \\text{ where } y = x*2^{-n}, \\ y \\in [1, 2)\n/// $$\n///\n/// For $0 \\leq x \\lt 1$, the input is inverted:\n///\n/// $$\n/// log_2{x} = -log_2{\\frac{1}{x}}\n/// $$\n///\n/// @dev See https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation.\n///\n/// Notes:\n/// - Due to the lossy precision of the iterative approximation, the results are not perfectly accurate to the last decimal.\n///\n/// Requirements:\n/// - x must be greater than zero.\n///\n/// @param x The SD59x18 number for which to calculate the binary logarithm.\n/// @return result The binary logarithm as an SD59x18 number.\n/// @custom:smtchecker abstract-function-nondet\nfunction log2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = x.unwrap();\n    if (xInt <= 0) {\n        revert Errors.PRBMath_SD59x18_Log_InputTooSmall(x);\n    }\n\n    unchecked {\n        int256 sign;\n        if (xInt >= uUNIT) {\n            sign = 1;\n        } else {\n            sign = -1;\n            // Inline the fixed-point inversion to save gas.\n            xInt = uUNIT_SQUARED / xInt;\n        }\n\n        // Calculate the integer part of the logarithm.\n        uint256 n = Common.msb(uint256(xInt / uUNIT));\n\n        // This is the integer part of the logarithm as an SD59x18 number. The operation can't overflow\n        // because n is at most 255, `UNIT` is 1e18, and the sign is either 1 or -1.\n        int256 resultInt = int256(n) * uUNIT;\n\n        // Calculate $y = x * 2^{-n}$.\n        int256 y = xInt >> n;\n\n        // If y is the unit number, the fractional part is zero.\n        if (y == uUNIT) {\n            return wrap(resultInt * sign);\n        }\n\n        // Calculat"
    }
  ]
}