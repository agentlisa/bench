{
  "Title": "M-6: Lender.sol: Incorrect rewards accounting for RESERVE address in _transfer function",
  "Content": "# Issue M-6: Lender.sol: Incorrect rewards accounting for RESERVE address in _transfer function \n\nSource: https://github.com/sherlock-audit/2023-10-aloe-judging/issues/49 \n\n## Found by \nroguereddwarf\nThe `RESERVE` address is a special address in the `Lender` since it earns some of the interest that the `Lender` accrues.  \n\nAccording to the contest README, which links to the [auditor quick start guide](https://docs.aloe.capital/aloe-ii/auditor-quick-start), the `RESERVE` address should behave normally, i.e. all accounting should be done correctly for it:  \n\n```text\nSpecial-cases related to the RESERVE address and couriers\n\nWe believe the RESERVE address can operate without restriction, i.e. it can call any function in the protocol without causing accounting errors. Where it needs to be limited, we believe it is. For example, Lender.deposit prevents it from having a courier. But are we missing anything? Many of our invariants in LenderHarness have special logic to account for the RESERVE address, and while we think everything is correct, we'd like to have more eyes on it.\n```\n\nThe issue is that the [`Lender._transfer`](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/Lender.sol#L399-L425) function, which contains the logic for share transfers, does not accrue interest.  \n\nThereby the `RESERVE`'s share balance is not up-to-date and it loses out on any rewards that should be earned for the accrued balance.  \n\nFor all other addresses the reward accounting is performed correctly in the `Lender._transfer` function and according to the auditor quick start guide it is required that the same is true for the `RESERVE` address.  \n\n\n## Vulnerability Detail\nWhen interest is accrued, the `RESERVE` address [gets minted shares](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/Lender.sol#L536-L547).  \n\nHowever the `Lender._transfer` function does not accrue interest and so `RESERVE`'s balance is not up to date which means the `Rewards.updateUserState` call operates on an [incorrect balance](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/Lender.sol#L411-L421).  \n\nThe balance of `RESERVE` is too low which results in a loss of rewards.  \n\n## Impact\nAs described above, the `RESERVE` address should have its reward accounting done correctly just like all other addresses.  \n\nFailing to do so means that the `RESERVE` misses out on some rewards because `Lender._transfer` does not update the share balance correctly and so the rewards will be accrued on a balance that is too low.\n\n## Code Snippet\nhttps://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/Lender.sol#L399-L425\n\n## Tool used\nManual Review\n\n## Recommendation\nThe `RESERVE` address should be special-cased in the `Lender._transfer` function. Thereby gas is saved when transfers are executed that do not involve the `RESERVE` address and the reward accounting is done correctly for when the `RESERVE` address is involved.  \n\nWhen the `RESERVE` address is involved, `(Cache memory cache, ) = _load();` and `_save(cache, /* didChangeBorrowBase: */ false);` must be called. Also the Rewards state must be updated with this call: `Rewards.updatePoolState(s, a, newTotalSupply);`.  \n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> low, because the reward amount lost is very small and can be worked around by manually accuringInterest before transferring\n\n**MohammedRizwan** commented:\n>  valid\n\n\n\n**panprog**\n\nEscalate\n\nThis should be low, not medium.\n\nWhile it's valid, the reward lost by RESERVE is very small, and developers do not guarantee exact calculations, according to https://docs.aloe.capital/aloe-ii/auditor-quick-start:\n\n> The rewards logic is intentionally approximate, i.e. we do not care about 18 decimal precision. However, it should be somewhat accurate, and if it's wrong, it should always underestimate rewards rather than pay out too much.\n\nIn this case, RESERVE receives slightly smaller reward than theoretical calculations, but this is in-line with the protocol design in that rewards don't have to be exactly correct and can be slightly smaller.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should be low, not medium.\n> \n> While it's valid, the reward lost by RESERVE is very small, and developers do not guarantee exact calculations, according to https://docs.aloe.capital/aloe-ii/auditor-quick-start:\n> \n> > The rewards logic is intentionally approximate, i.e. we do not care about 18 decimal precision. However, it should be somewhat accurate, and if it's wrong, it should always underestimate rewards rather than pay out too much.\n> \n> In this case, RESERVE receives slightly smaller reward than theoretical calculations, but this is in-line with the protocol design in that rewards don't have to be exactly correct and can be slightly smaller.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**roguereddwarf**\n\nThe auditor quick start guide says that RESERVE should behave like any other address, i.e. transfers with the RESERVE address do not update rewards correctly. For all other addresses it is done correctly.\n\n**panprog**\n\n@roguereddwarf  Yes, it's incorrect. But my point is that the loss is really very small and falls within the developers intentions to award rewards not exactly in correct amounts and slightly less if error does occur. Reserve owner can also overcome this problem by manually accuring before doing transfer. So this is more low than medium.\n\n**cvetanovv**\n\nIt's really on the Medium/Low borderline, but the protocol is confirmed to be Medium severity\n\n**Trumpero**\n\nPlanning to reject the escalation and keep this issue as medium.\n\n\"Manually accruing before doing the transfer\" is not an intended flow for the reserve owner, so it isn't considered a valid solution. RESERVE account can lose rewards if the owner isn't aware of it and transfers normally.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [panprog](https://github.com/sherlock-audit/2023-10-aloe-judging/issues/49/#issuecomment-1802592369): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/120",
  "Code": [
    {
      "filename": "core/src/Lender.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20, SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\n\nimport {BORROWS_SCALER, ONE} from \"./libraries/constants/Constants.sol\";\nimport {Q112} from \"./libraries/constants/Q.sol\";\nimport {Rewards} from \"./libraries/Rewards.sol\";\n\nimport {Ledger} from \"./Ledger.sol\";\nimport {IRateModel} from \"./RateModel.sol\";\n\ninterface IFlashBorrower {\n    function onFlashLoan(address initiator, uint256 amount, bytes calldata data) external;\n}\n\n/// @title Lender\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract Lender is Ledger {\n    using FixedPointMathLib for uint256;\n    using SafeCastLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Borrow(address indexed caller, address indexed recipient, uint256 amount, uint256 units);\n\n    event Repay(address indexed caller, address indexed beneficiary, uint256 amount, uint256 units);\n\n    event CreditCourier(uint32 indexed id, address indexed account);\n\n    /*//////////////////////////////////////////////////////////////\n                       CONSTRUCTOR & INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address reserve) Ledger(reserve) {}\n\n    function initialize() external {\n        require(borrowIndex == 0);\n        borrowIndex = uint72(ONE);\n        lastAccrualTime = uint32(block.timestamp);\n    }\n\n    /// @notice Sets the `rateModel` and `reserveFactor`. Only the `FACTORY` can call this.\n    function setRateModelAndReserveFactor(IRateModel rateModel_, uint8 reserveFactor_) external {\n        require(msg.sender == address(FACTORY) && reserveFactor_ > 0);\n        rateModel = rateModel_;\n        reserveFactor = reserveFactor_;\n    }\n\n    /**\n     * @notice Sets the rewards rate. May be 0. Only the `FACTORY` can call this.\n     * @param rate The rewards rate, specified in [token units per second]. If non-zero, keep between 10^19 and\n     * 10^24 token units per year for smooth operation. Assuming `FACTORY.rewardsToken()` has 18 decimals, this is\n     * between 10 and 1 million tokens per year.\n     */\n    function setRewardsRate(uint56 rate) external {\n        require(msg.sender == address(FACTORY));\n        Rewards.setRate(rate);\n    }\n\n    /// @notice Allows `borrower` to call `borrow`. One the `FACTORY` can call this.\n    function whitelist(address borrower) external {\n        // Requirements:\n        // - `msg.sender == FACTORY` so that only the factory can whitelist borrowers\n        // - `borrows[borrower] == 0` ensures we don't accidentally erase debt\n        require(msg.sender == address(FACTORY) && borrows[borrower] == 0);\n\n        // `borrow` and `repay` have to read the `borrows` mapping anyway, so setting this to 1\n        // allows them to efficiently check whether a given borrower is whitelisted. This extra\n        // unit of debt won't accrue interest or impact solvency calculations.\n        borrows[borrower] = 1;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                REWARDS\n    //////////////////////////////////////////////////////////////*/\n\n    function claimRewards(address owner) external returns (uint112 earned) {\n        // All claims are made through the `FACTORY`\n        require(msg.sender == address(FACTORY));\n\n        (Rewards.Storage storage s, uint144 a) = Rewards.load();\n        earned = Rewards.claim(s, a, owner, balanceOf(owner));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints `shares` to `beneficiary` by depositing exactly `amount` of underlying tokens\n     * @dev `deposit` is more efficient than `mint` and is the recommended way of depositing. Also\n     * supports the additional flow where you prepay `amount` instead of relying on approve/transferFrom.\n     * @param amount The amount of underlying tokens to deposit\n     * @param beneficiary The receiver of `shares`\n     * @param courierId The identifier of the referrer to credit for this deposit. 0 indicates none.\n     * @return shares The number of shares (banknotes) minted to `beneficiary`\n     */\n    function deposit(uint256 amount, address beneficiary, uint32 courierId) public returns (uint256 shares) {\n        if (courierId != 0) {\n            (address courier, uint16 cut) = FACTORY.couriers(courierId);\n\n            require(\n                // Callers are free to set their own courier, but they need permission to mess with others'\n                (msg.sender == beneficiary || allowance[beneficiary][msg.sender] != 0) &&\n                    // Prevent `RESERVE` from having a courier, since its principle wouldn't be tracked properly\n                    (beneficiary != RESERVE) &&\n                    // Payout logic can't handle self-reference, so don't let accounts credit themselves\n                    (beneficiary != courier) &&\n                    // Make sure `cut` has been set\n                    (cut != 0),\n                \"Aloe: courier\"\n            );\n        }\n\n        // Accrue interest and update reserves\n        (Cache memory cache, uint256 inventory) = _load();\n\n        // Convert `amount` to `shares`\n        shares = _convertToShares(amount, inventory, cache.totalSupply, /* roundUp: */ false);\n        require(shares != 0, \"Aloe: zero impact\");\n\n        // Mint shares, track rewards, and (if applicable) handle courier accounting\n        cache.totalSupply = _mint(beneficiary, shares, amount, cache.totalSupply, courierId);\n        // Assume tokens are transferred\n        cache.lastBalance += amount;\n\n        // Save state to storage (thus far, only mappings have been updated, so we must address everything else)\n        _save(cache, /* didChangeBorrowBase: */ false);\n\n        // Ensure tokens are transferred\n        ERC20 asset_ = asset();\n        bool didPrepay = cache.lastBalance <= asset_.balanceOf(address(this));\n        if (!didPrepay) {\n            asset_.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        emit Deposit(msg.sender, beneficiary, amount, shares);\n    }\n\n    function deposit(uint256 amount, address beneficiary) external returns (uint256 shares) {\n        shares = deposit(amount, beneficiary, 0);\n    }\n\n    function mint(uint256 shares, address beneficiary) external returns (uint256 amount) {\n        amount = previewMint(shares);\n        deposit(amount, beneficiary, 0);\n    }\n\n    /**\n     * @notice Burns `shares` from `owner` and sends `amount` of underlying tokens to `receiver`. If\n     * `owner` has a courier, additional shares will be transferred from `owner` to the courier as a fee.\n     * @dev `redeem` is more efficient than `withdraw` and is the recommended way of withdrawing\n     * @param shares The number of shares to burn in exchange for underlying tokens. To burn all your shares,\n     * you can pass `maxRedeem(owner)`. If `maxRedeem(owner)` is changing over time (due to a courier or\n     * high utilization) you can pass `type(uint256).max` and it will be computed in-place.\n     * @param recipient The receiver of `amount` of underlying tokens\n     * @param owner The user from whom shares are taken (for both the burn and possible fee transfer)\n     * @return amount The number of underlying tokens transferred to `recipient`\n     */\n    function redeem(uint256 shares, address recipient, address owner) public returns (uint256 amount) {\n        if (shares == type(uint256).max) shares = maxRedeem(owner);\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender];\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Accrue interest and update reserves\n        (Cache memory cache, uint256 inventory) = _load();\n\n        // Convert `shares` to `amount`\n        amount = _convertToAssets(shares, inventory, cache.totalSupply, /* roundUp: */ false);\n        require(amount != 0, \"Aloe: zero impact\");\n\n        // Burn shares, track rewards, and (if applicable) handle courier accounting\n        cache.totalSupply = _burn(owner, shares, inventory, cache.totalSupply);\n        // Assume tokens are transferred\n        cache.lastBalance -= amount;\n\n        // Save state to storage (thus far, only mappings have been updated, so we must address everything else)\n        _save(cache, /* didChangeBorrowBase: */ false);\n\n        // Transfer tokens\n        asset().safeTransfer(recipient, amount);\n\n        emit Withdraw(msg.sender, recipient, owner, amount, shares);\n    }\n\n    function withdraw(uint256 amount, address recipient, address owner) external returns (uint256 shares) {\n        shares = previewWithdraw(amount);\n        redeem(shares, recipient, owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           BORROW/REPAY LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sends `amount` of `asset` to `recipient` and increases `msg.sender`'s debt by `units`\n    function borrow(uint256 amount, address recipient) external returns (uint256 units) {\n        uint256 b = borrows[msg.sender];\n        require(b != 0, \"Aloe: not a borrower\");\n\n        // Accrue interest and update reserves\n        (Cache memory cache, ) = _load();\n\n        unchecked {\n            // Convert `amount` to `units`\n            units = (amount * BORROWS_SCALER) / cache.borrowIndex;\n\n            // Track borrows\n            borrows[msg.sender] = b + units;\n        }\n        cache.borrowBase += units;\n        // Assume tokens are transferred\n        cache.lastBalance -= amount;\n\n        // Save state to storage (thus far, only mappings have been updated, so we must address everything else)\n        _save(cache, /* didChangeBorrowBase: */ true);\n\n        // Transfer tokens\n        asset().safeTransfer(recipient, amount);\n\n        emit Borrow(msg.sender, recipient, amount, units);\n    }\n\n    /**\n     * @notice Reduces `beneficiary`'s debt by `units`, assuming someone has pre-paid `amount` of `asset`. To repay\n     * all debt for some account, call `repay(borrowBalance(account), account)`.\n     * @dev To avoid frontrunning, `amount` should be pre-paid in the same transaction as the `repay` call.\n     * @custom:example ```solidity\n     *   PERMIT2.permitTransferFrom(\n     *     permitMsg,\n     *     IPermit2.SignatureTransferDetails({to: address(lender), requestedAmount: amount}),\n     *     msg.sender,\n     *     signature\n     *   );\n     *   lender.repay(amount, beneficiary)\n     * ```\n     */\n    function repay(uint256 amount, address beneficiary) external returns (uint256 units) {\n        uint256 b = borrows[beneficiary];\n\n        // Accrue interest and update reserves\n        (Cache memory cache, ) = _load();\n\n        unchecked {\n            // Convert `amount` to `units`\n            units = (amount * BORROWS_SCALER) / cache.borrowIndex;\n            if (!(units < b)) {\n                units = b - 1;\n\n                uint256 maxRepay = (units * cache.borrowIndex).unsafeDivUp(BORROWS_SCALER);\n                require(b > 1 && amount <= maxRepay, \"Aloe: repay too much\");\n            }\n\n            // Track borrows\n            borrows[beneficiary] = b - units;\n            cache.borrowBase -= units;\n        }\n        // Assume tokens are transferred\n        cache.lastBalance += amount;\n\n        // Save state to storage (thus far, only mappings have been updated, so we must address everything else)\n        _save(cache, /* didChangeBorrowBase: */ true);\n\n        // Ensure tokens are transferred\n        require(cache.lastBalance <= asset().balanceOf(address(this)), \"Aloe: insufficient pre-pay\");\n\n        emit Repay(msg.sender, beneficiary, amount, units);\n    }\n\n    /**\n     * @notice Gives `to` temporary control over `amount` of `asset` in the `IFlashBorrower.onFlashLoan` callback.\n     * Arbitrary `data` can be forwarded to the callback. Before returning, the `IFlashBorrower` must have sent\n     * at least `amount` back to this contract.\n     * @dev Reentrancy guard is critical here! Without it, one could use a flash loan to repay a normal loan.\n     */\n    function flash(uint256 amount, IFlashBorrower to, bytes calldata data) external {\n        // Guard against reentrancy\n        uint32 lastAccrualTime_ = lastAccrualTime;\n        require(lastAccrualTime_ != 0, \"Aloe: locked\");\n        lastAccrualTime = 0;\n\n        ERC20 asset_ = asset();\n\n        uint256 balance = asset_.balanceOf(address(this));\n        asset_.safeTransfer(address(to), amount);\n        to.onFlashLoan(msg.sender, amount, data);\n        require(balance <= asset_.balanceOf(address(this)), \"Aloe: insufficient pre-pay\");\n\n        lastAccrualTime = lastAccrualTime_;\n    }\n\n    function accrueInterest() external returns (uint72) {\n        (Cache memory cache, ) = _load();\n        _save(cache, /* didChangeBorrowBase: */ false);\n        return uint72(cache.borrowIndex);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 shares) external returns (bool) {\n        allowance[msg.sender][spender] = shares;\n\n        emit Approval(msg.sender, spender, shares);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 shares) external returns (bool) {\n        _transfer(msg.sender, to, shares);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 shares) external returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - shares;\n\n        _transfer(from, to, shares);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"Aloe: permit expired\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"Aloe: permit invalid\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Transfers `shares` from `from` to `to`, iff neither of them have a courier\n    function _transfer(address from, address to, uint256 shares) private {\n        (Rewards.Storage storage s, uint144 a) = Rewards.load();\n\n        unchecked {\n            // From most to least significant...\n            // -------------------------------\n            // | courier id       | 32 bits  |\n            // | user's principle | 112 bits |\n            // | user's balance   | 112 bits |\n            // -------------------------------\n            uint256 data;\n\n            data = balances[from];\n            require(data >> 224 == 0 && shares <= data % Q112);\n            balances[from] = data - shares;\n\n            Rewards.updateUserState(s, a, from, data % Q112);\n\n            data = balances[to];\n            require(data >> 224 == 0);\n            balances[to] = data + shares;\n\n            Rewards.updateUserState(s, a, to, data % Q112);\n        }\n\n        emit Transfer(from, to, shares);\n    }\n\n    /// @dev Make sure to do something with the return value, `newTotalSupply`!\n    function _mint(\n        address to,\n        uint256 shares,\n        uint256 amount,\n        uint256 totalSupply_,\n        uint32 courierId\n    ) private returns (uint256 newTotalSupply) {\n        // Need to compute `newTotalSupply` with checked math to avoid overflow\n        newTotalSupply = totalSupply_ + shares;\n\n        unchecked {\n            // From most to least significant...\n            // -------------------------------\n            // | courier id       | 32 bits  |\n            // | user's principle | 112 bits |\n            // | user's balance   | 112 bits |\n            // -------------------------------\n            uint256 data = balances[to];\n\n            // Get rewards accounting out of the way\n            (Rewards.Storage storage s, uint144 a) = Rewards.load();\n            Rewards.updatePoolState(s, a, newTotalSupply);\n            Rewards.updateUserState(s, a, to, data % Q112);\n\n            // Only set courier if balance is 0. Otherwise previous courier may be cheated out of fees.\n            if (data % Q112 == 0) {\n                data = uint256(courierId) << 224;\n                emit CreditCourier(courierId, to);\n            }\n\n            // Keep track of principle iff `to` has a courier\n            if (data >> 224 != 0) {\n                require(amount + ((data >> 112) % Q112) < Q112);\n                data += amount << 112;\n            }\n\n            // Keep track of balance regardless of courier.\n            // Since `totalSupply` fits in uint112, the user's balance will too. No need to check here.\n            balances[to] = data + shares;\n        }\n\n        emit Transfer(address(0), to, shares);\n    }\n\n    /// @dev Make sure to do something with the return value, `newTotalSupply`!\n    function _burn(\n        address from,\n        uint256 shares,\n        uint256 inventory,\n        uint256 totalSupply_\n    ) private returns (uint256 newTotalSupply) {\n        unchecked {\n            // Can compute `newTotalSupply` with unchecked math since other checks cover underflow\n            newTotalSupply = totalSupply_ - shares;\n\n            // From most to least significant...\n            // -------------------------------\n            // | courier id       | 32 bits  |\n            // | user's principle | 112 bits |\n            // | user's balance   | 112 bits |\n            // -------------------------------\n            uint256 data = balances[from];\n            uint256 balance = data % Q112;\n\n            // Get rewards accounting out of the way\n            (Rewards.Storage storage s, uint144 a) = Rewards.load();\n            Rewards.updatePoolState(s, a, newTotalSupply);\n            Rewards.updateUserState(s, a, from, balance);\n\n            uint32 id = uint32(data >> 224);\n            if (id != 0) {\n                uint256 principleAssets = (data >> 112) % Q112;\n                uint256 principleShares = principleAssets.mulDivUp(totalSupply_, inventory);\n\n                if (balance > principleShares) {\n                    (address courier, uint16 cut) = FACTORY.couriers(id);\n\n                    // Compute total fee owed to courier. Take it out of balance so that\n                    // comparison is correct later on (`shares <= balance`)\n                    uint256 fee = ((balance - principleShares) * cut) / 10_000;\n                    balance -= fee;\n\n                    // Compute portion of fee to pay out during this burn.\n                    fee = (fee * shares) / balance;\n\n                    // Send `fee` from `from` to `courier.wallet`.\n                    // NOTE: We skip principle update on courier, so if couriers credit\n                    // each other, 100% of `fee` is treated as profit and will pass through\n                    // to the next courier.\n                    // NOTE: We skip rewards update on the courier. This means accounting isn't\n                    // accurate for them, so they *should not* be allowed to claim rewards. This\n                    // slightly reduces the effective overall rewards rate.\n                    data -= fee;\n                    balances[courier] += fee;\n                    emit Transfer(from, courier, fee);\n                }\n\n                // Update principle\n                data -= ((principleAssets * shares) / balance) << 112;\n            }\n\n            require(shares <= balance);\n            balances[from] = data - shares;\n        }\n\n        emit Transfer(from, address(0), shares);\n    }\n\n    function _load() private returns (Cache memory cache, uint256 inventory) {\n        cache = Cache(totalSupply, lastBalance, lastAccrualTime, borrowBase, borrowIndex);\n\n        // Accrue interest (only in memory)\n        uint256 newTotalSupply;\n        (cache, inventory, newTotalSupply) = _previewInterest(cache); // Reverts if reentrancy guard is active\n\n        // Update reserves (new `totalSupply` is only in memory, but `balanceOf` is updated in storage)\n        if (newTotalSupply > cache.totalSupply) {\n            cache.totalSupply = _mint(RESERVE, newTotalSupply - cache.totalSupply, 0, cache.totalSupply, 0);\n        }\n    }\n\n    function _save(Cache memory cache, bool didChangeBorrowBase) private {\n        // `cache.lastAccrualTime == 0` implies that `cache.borrowIndex` was updated\n        if (cache.lastAccrualTime == 0 || didChangeBorrowBase) {\n            borrowBase = cache.borrowBase.safeCastTo184();\n            borrowIndex = cache.borrowIndex.safeCastTo72();\n        }\n\n        totalSupply = cache.totalSupply.safeCastTo112();\n        lastBalance = cache.lastBalance.safeCastTo112();\n        lastAccrualTime = uint32(block.timestamp); // Disables reentrancy guard if there was one\n    }\n}"
    },
    {
      "filename": "core/src/Lender.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20, SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\n\nimport {BORROWS_SCALER, ONE} from \"./libraries/constants/Constants.sol\";\nimport {Q112} from \"./libraries/constants/Q.sol\";\nimport {Rewards} from \"./libraries/Rewards.sol\";\n\nimport {Ledger} from \"./Ledger.sol\";\nimport {IRateModel} from \"./RateModel.sol\";\n\ninterface IFlashBorrower {\n    function onFlashLoan(address initiator, uint256 amount, bytes calldata data) external;\n}\n\n/// @title Lender\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract Lender is Ledger {\n    using FixedPointMathLib for uint256;\n    using SafeCastLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Borrow(address indexed caller, address indexed recipient, uint256 amount, uint256 units);\n\n    event Repay(address indexed caller, address indexed beneficiary, uint256 amount, uint256 units);\n\n    event CreditCourier(uint32 indexed id, address indexed account);\n\n    /*//////////////////////////////////////////////////////////////\n                       CONSTRUCTOR & INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address reserve) Ledger(reserve) {}\n\n    function initialize() external {\n        require(borrowIndex == 0);\n        borrowIndex = uint72(ONE);\n        lastAccrualTime = uint32(block.timestamp);\n    }\n\n    /// @notice Sets the `rateModel` and `reserveFactor`. Only the `FACTORY` can call this.\n    function setRateModelAndReserveFactor(IRateModel rateModel_, uint8 reserveFactor_) external {\n        require(msg.sender == address(FACTORY) && reserveFactor_ > 0);\n        rateModel = rateModel_;\n        reserveFactor = reserveFactor_;\n    }\n\n    /**\n     * @notice Sets the rewards rate. May be 0. Only the `FACTORY` can call this.\n     * @param rate The rewards rate, specified in [token units per second]. If non-zero, keep between 10^19 and\n     * 10^24 token units per year for smooth operation. Assuming `FACTORY.rewardsToken()` has 18 decimals, this is\n     * between 10 and 1 million tokens per year.\n     */\n    function setRewardsRate(uint56 rate) external {\n        require(msg.sender == address(FACTORY));\n        Rewards.setRate(rate);\n    }\n\n    /// @notice Allows `borrower` to call `borrow`. One the `FACTORY` can call this.\n    function whitelist(address borrower) external {\n        // Requirements:\n        // - `msg.sender == FACTORY` so that only the factory can whitelist borrowers\n        // - `borrows[borrower] == 0` ensures we don't accidentally erase debt\n        require(msg.sender == address(FACTORY) && borrows[borrower] == 0);\n\n        // `borrow` and `repay` have to read the `borrows` mapping anyway, so setting this to 1\n        // allows them to efficiently check whether a given borrower is whitelisted. This extra\n        // unit of debt won't accrue interest or impact solvency calculations.\n        borrows[borrower] = 1;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                REWARDS\n    //////////////////////////////////////////////////////////////*/\n\n    function claimRewards(address owner) external returns (uint112 earned) {\n        // All claims are made through the `FACTORY`\n        require(msg.sender == address(FACTORY));\n\n        (Rewards.Storage storage s, uint144 a) = Rewards.load();\n        earned = Rewards.claim(s, a, owner, balanceOf(owner));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints `shares` to `beneficiary` by depositing exactly `amount` of underlying tokens\n     * @dev `deposit` is more efficient than `mint` and is the recommended way of depositing. Also\n     * supports the additional flow where you prepay `amount` instead of relying on approve/transferFrom.\n     * @param amount The amount of underlying tokens to deposit\n     * @param beneficiary The receiver of `shares`\n     * @param courierId The identifier of the referrer to credit for this deposit. 0 indicates none.\n     * @return shares The number of shares (banknotes) minted to `beneficiary`\n     */\n    function deposit(uint256 amount, address beneficiary, uint32 courierId) public returns (uint256 shares) {\n        if (courierId != 0) {\n            (address courier, uint16 cut) = FACTORY.couriers(courierId);\n\n            require(\n                // Callers are free to set their own courier, but they need permission to mess with others'\n                (msg.sender == beneficiary || allowance[beneficiary][msg.sender] != 0) &&\n                    // Prevent `RESERVE` from having a courier, since its principle wouldn't be tracked properly\n                    (beneficiary != RESERVE) &&\n                    // Payout logic can't handle self-reference, so don't let accounts credit themselves\n                    (beneficiary != courier) &&\n                    // Make sure `cut` has been set\n                    (cut != 0),\n                \"Aloe: courier\"\n            );\n        }\n\n        // Accrue interest and update reserves\n        (Cache memory cache, uint256 inventory) = _load();\n\n        // Convert `amount` to `shares`\n        shares = _convertToShares(amount, inventory, cache.totalSupply, /* roundUp: */ false);\n        require(shares != 0, \"Aloe: zero impact\");\n\n        // Mint shares, track rewards, and (if applicable) handle courier accounting\n        cache.totalSupply = _mint(beneficiary, shares, amount, cache.totalSupply, courierId);\n        // Assume tokens are transferred\n        cache.lastBalance += amount;\n\n        // Save state to storage (thus far, only mappings have been updated, so we must address everything else)\n        _save(cache, /* didChangeBorrowBase: */ false);\n\n        // Ensure tokens are transferred\n        ERC20 asset_ = asset();\n        bool didPrepay = cache.lastBalance <= asset_.balanceOf(address(this));\n        if (!didPrepay) {\n            asset_.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        emit Deposit(msg.sender, beneficiary, amount, shares);\n    }\n\n    function deposit(uint256 amount, address beneficiary) external returns (uint256 shares) {\n        shares = deposit(amount, beneficiary, 0);\n    }\n\n    function mint(uint256 shares, address beneficiary) external returns (uint256 amount) {\n        amount = previewMint(shares);\n        deposit(amount, beneficiary, 0);\n    }\n\n    /**\n     * @notice Burns `shares` from `owner` and sends `amount` of underlying tokens to `receiver`. If\n     * `owner` has a courier, additional shares will be transferred from `owner` to the courier as a fee.\n     * @dev `redeem` is more efficient than `withdraw` and is the recommended way of withdrawing\n     * @param shares The number of shares to burn in exchange for underlying tokens. To burn all your shares,\n     * you can pass `maxRedeem(owner)`. If `maxRedeem(owner)` is changing over time (due to a courier or\n     * high utilization) you can pass `type(uint256).max` and it will be computed in-place.\n     * @param recipient The receiver of `amount` of underlying tokens\n     * @param owner The user from whom shares are taken (for both the burn and possible fee transfer)\n     * @return amount The number of underlying tokens transferred to `recipient`\n     */\n    function redeem(uint256 shares, address recipient, address owner) public returns (uint256 amount) {\n        if (shares == type(uint256).max) shares = maxRedeem(owner);\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender];\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Accrue interest and update reserves\n        (Cache memory cache, uint256 inventory) = _load();\n\n        // Convert `shares` to `amount`\n        amount = _convertToAssets(shares, inventory, cache.totalSupply, /* roundUp: */ false);\n        require(amount != 0, \"Aloe: zero impact\");\n\n        // Burn shares, track rewards, and (if applicable) handle courier accounting\n        cache.totalSupply = _burn(owner, shares, inventory, cache.totalSupply);\n        // Assume tokens are transferred\n        cache.lastBalance -= amount;\n\n        // Save state to storage (thus far, only mappings have been updated, so we must address everything else)\n        _save(cache, /* didChangeBorrowBase: */ false);\n\n        // Transfer tokens\n        asset().safeTransfer(recipient, amount);\n\n        emit Withdraw(msg.sender, recipient, owner, amount, shares);\n    }\n\n    function withdraw(uint256 amount, address recipient, address owner) external returns (uint256 shares) {\n        shares = previewWithdraw(amount);\n        redeem(shares, recipient, owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           BORROW/REPAY LOGIC\n    /////////////////////"
    }
  ]
}