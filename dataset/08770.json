{
  "Title": "[L-05] Receive function",
  "Content": "\nInfinityStaker.sol is not supposed to receive ETH. Instead of using a rescue function, remove `receive()` and `fallback()` altogether.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[fallback() external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L55)\\\n[receive() external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L57)\\\n[function rescueETH(address destination) external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L345)\n\n### Mitigation\n\nRemove these functions, or include a call to `rescueETH` in `receive()`, so that a user that mistakenly sends ETH to the Staker retrieves it immediately.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
  "Code": [
    {
      "filename": "contracts/staking/InfinityStaker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IStaker, Duration, StakeLevel} from '../interfaces/IStaker.sol';\n\n/**\n * @title InfinityStaker\n * @author nneverlander. Twitter @nneverlander\n * @notice The staker contract that allows people to stake tokens and earn voting power to be used in curation and possibly other places\n */\ncontract InfinityStaker is IStaker, Ownable, Pausable, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n  struct StakeAmount {\n    uint256 amount;\n    uint256 timestamp;\n  }\n\n  ///@dev Storage variable to keep track of the staker's staked duration and amounts\n  mapping(address => mapping(Duration => StakeAmount)) public userstakedAmounts;\n\n  address public INFINITY_TOKEN;\n  ///@dev Infinity treasury address - will be a EOA/multisig\n  address public INFINITY_TREASURY;\n\n  /**@dev Power levels to reach the specified stake thresholds. Users can reach these levels \n          either by staking the specified number of tokens for no duration or a less number of tokens but with higher durations.\n          See getUserStakePower() to see how users can reach these levels.\n  */\n  uint16 public BRONZE_STAKE_THRESHOLD = 1000;\n  uint16 public SILVER_STAKE_THRESHOLD = 5000;\n  uint16 public GOLD_STAKE_THRESHOLD = 10000;\n  uint16 public PLATINUM_STAKE_THRESHOLD = 20000;\n\n  ///@dev Penalties if staked tokens are rageQuit early. Example: If 100 tokens are staked for twelve months but rageQuit right away,\n  /// the user will get back 100/4 tokens.\n  uint16 public THREE_MONTH_PENALTY = 2;\n  uint16 public SIX_MONTH_PENALTY = 3;\n  uint16 public TWELVE_MONTH_PENALTY = 4;\n\n  event Staked(address indexed user, uint256 amount, Duration duration);\n  event DurationChanged(address indexed user, uint256 amount, Duration oldDuration, Duration newDuration);\n  event UnStaked(address indexed user, uint256 amount);\n  event RageQuit(address indexed user, uint256 totalToUser, uint256 penalty);\n\n  constructor(address _tokenAddress, address _infinityTreasury) {\n    INFINITY_TOKEN = _tokenAddress;\n    INFINITY_TREASURY = _infinityTreasury;\n  }\n\n  // Fallback\n  fallback() external payable {}\n\n  receive() external payable {}\n\n  // =================================================== USER FUNCTIONS =======================================================\n\n  /**\n   * @notice Stake tokens for a specified duration\n   * @dev Tokens are transferred from the user to this contract\n   * @param amount Amount of tokens to stake\n   * @param duration Duration of the stake\n   */\n  function stake(uint256 amount, Duration duration) external override nonReentrant whenNotPaused {\n    require(amount != 0, 'stake amount cant be 0');\n    require(IERC20(INFINITY_TOKEN).balanceOf(msg.sender) >= amount, 'insufficient balance to stake');\n    // update storage\n    userstakedAmounts[msg.sender][duration].amount += amount;\n    userstakedAmounts[msg.sender][duration].timestamp = block.timestamp;\n    // perform transfer\n    IERC20(INFINITY_TOKEN).safeTransferFrom(msg.sender, address(this), amount);\n    // emit event\n    emit Staked(msg.sender, amount, duration);\n  }\n\n  /**\n   * @notice Change duration of staked tokens\n   * @dev Duration can be changed from low to high but not from high to low. State updates are performed\n   * @param amount Amount of tokens to change duration\n   * @param oldDuration Old duration of the stake\n   * @param newDuration New duration of the stake\n   */\n  function changeDuration(\n    uint256 amount,\n    Duration oldDuration,\n    Duration newDuration\n  ) external override nonReentrant whenNotPaused {\n    require(amount != 0, 'amount cant be 0');\n    require(\n      userstakedAmounts[msg.sender][oldDuration].amount >= amount,\n      'insufficient staked amount to change duration'\n    );\n    require(newDuration > oldDuration, 'new duration must be greater than old duration');\n\n    // update storage\n    userstakedAmounts[msg.sender][oldDuration].amount -= amount;\n    userstakedAmounts[msg.sender][newDuration].amount += amount;\n    // update timestamp for new duration\n    userstakedAmounts[msg.sender][newDuration].timestamp = block.timestamp;\n    // only update old duration timestamp if old duration amount is 0\n    if (userstakedAmounts[msg.sender][oldDuration].amount == 0) {\n      userstakedAmounts[msg.sender][oldDuration].timestamp = 0;\n    }\n    // emit event\n    emit DurationChanged(msg.sender, amount, oldDuration, newDuration);\n  }\n\n  /**\n   * @notice Untake tokens\n   * @dev Storage updates are done for each stake level. See _updateUserStakedAmounts for more details\n   * @param amount Amount of tokens to unstake\n   */\n  function unstake(uint256 amount) external override nonReentrant whenNotPaused {\n    require(amount != 0, 'stake amount cant be 0');\n    uint256 noVesting = userstakedAmounts[msg.sender][Duration.NONE].amount;\n    uint256 vestedThreeMonths = getVestedAmount(msg.sender, Duration.THREE_MONTHS);\n    uint256 vestedsixMonths = getVestedAmount(msg.sender, Duration.SIX_MONTHS);\n    uint256 vestedTwelveMonths = getVestedAmount(msg.sender, Duration.TWELVE_MONTHS);\n    uint256 totalVested = noVesting + vestedThreeMonths + vestedsixMonths + vestedTwelveMonths;\n    require(totalVested >= amount, 'insufficient balance to unstake');\n\n    // update storage\n    _updateUserStakedAmounts(msg.sender, amount, noVesting, vestedThreeMonths, vestedsixMonths, vestedTwelveMonths);\n    // perform transfer\n    IERC20(INFINITY_TOKEN).safeTransfer(msg.sender, amount);\n    // emit event\n    emit UnStaked(msg.sender, amount);\n  }\n\n  /**\n   * @notice Ragequit tokens. Applies penalties for unvested tokens\n   */\n  function rageQuit() external override nonReentrant {\n    (uint256 totalToUser, uint256 penalty) = getRageQuitAmounts(msg.sender);\n    // update storage\n    _clearUserStakedAmounts(msg.sender);\n    // perform transfers\n    IERC20(INFINITY_TOKEN).safeTransfer(msg.sender, totalToUser);\n    IERC20(INFINITY_TOKEN).safeTransfer(INFINITY_TREASURY, penalty);\n    // emit event\n    emit RageQuit(msg.sender, totalToUser, penalty);\n  }\n\n  // ====================================================== VIEW FUNCTIONS ======================================================\n\n  /**\n   * @notice Get total staked tokens for a user for all durations\n   * @param user address of the user\n   * @return total amount of tokens staked by the user\n   */\n  function getUserTotalStaked(address user) public view override returns (uint256) {\n    return\n      userstakedAmounts[user][Duration.NONE].amount +\n      userstakedAmounts[user][Duration.THREE_MONTHS].amount +\n      userstakedAmounts[user][Duration.SIX_MONTHS].amount +\n      userstakedAmounts[user][Duration.TWELVE_MONTHS].amount;\n  }\n\n  /**\n   * @notice Get total vested tokens for a user for all durations\n   * @param user address of the user\n   * @return total amount of vested tokens for the user\n   */\n  function getUserTotalVested(address user) public view override returns (uint256) {\n    uint256 noVesting = getVestedAmount(user, Duration.NONE);\n    uint256 vestedThreeMonths = getVestedAmount(user, Duration.THREE_MONTHS);\n    uint256 vestedsixMonths = getVestedAmount(user, Duration.SIX_MONTHS);\n    uint256 vestedTwelveMonths = getVestedAmount(user, Duration.TWELVE_MONTHS);\n    return noVesting + vestedThreeMonths + vestedsixMonths + vestedTwelveMonths;\n  }\n\n  /**\n   * @notice Gets rageQuit amounts for a user after applying penalties\n   * @dev Penalty amounts are sent to Infinity treasury\n   * @param user address of the user\n   * @return Total amount to user and penalties\n   */\n  function getRageQuitAmounts(address user) public view override returns (uint256, uint256) {\n    uint256 noLock = userstakedAmounts[user][Duration.NONE].amount;\n    uint256 threeMonthLock = userstakedAmounts[user][Duration.THREE_MONTHS].amount;\n    uint256 sixMonthLock = userstakedAmounts[user][Duration.SIX_MONTHS].amount;\n    uint256 twelveMonthLock = userstakedAmounts[user][Duration.TWELVE_MONTHS].amount;\n\n    uint256 threeMonthVested = getVestedAmount(user, Duration.THREE_MONTHS);\n    uint256 sixMonthVested = getVestedAmount(user, Duration.SIX_MONTHS);\n    uint256 twelveMonthVested = getVestedAmount(user, Duration.TWELVE_MONTHS);\n\n    uint256 totalVested = noLock + threeMonthVested + sixMonthVested + twelveMonthVested;\n    uint256 totalStaked = noLock + threeMonthLock + sixMonthLock + twelveMonthLock;\n    require(totalStaked >= 0, 'nothing staked to rage quit');\n\n    uint256 totalToUser = totalVested +\n      ((threeMonthLock - threeMonthVested) / THREE_MONTH_PENALTY) +\n      ((sixMonthLock - sixMonthVested) / SIX_MONTH_PENALTY) +\n      ((twelveMonthLock - twelveMonthVested) / TWELVE_MONTH_PENALTY);\n\n    uint256 penalty = totalStaked - totalToUser;\n\n    return (totalToUser, penalty);\n  }\n\n  /**\n   * @notice Gets a user's stake level\n   * @param user address of the user\n   * @return StakeLevel\n   */\n  function getUserStakeLevel(address user) external view override returns (StakeLevel) {\n    uint256 totalPower = getUserStakePower(user);\n\n    if (totalPower <= BRONZE_STAKE_THRESHOLD) {\n      return StakeLevel.NONE;\n    } else if (totalPower > BRONZE_STAKE_THRESHOLD && totalPower <= SILVER_STAKE_THRESHOLD) {\n      return StakeLevel.BRONZE;\n    } else if (totalPower > SILVER_STAKE_THRESHOLD && totalPower <= GOLD_STAKE_THRESHOLD) {\n      return StakeLevel.SILVER;\n    } else if (totalPower > GOLD_STAKE_THRESHOLD && totalPower <= PLATINUM_STAKE_THRESHOLD) {\n      return StakeLevel.GOLD;\n    } else {\n      return StakeLevel.PLATINUM;\n    }\n  }\n\n  /**\n   * @notice Gets a user stake power. Used to determine voting power in curating collections and possibly other places\n   * @dev Tokens staked for higher duration apply a multiplier\n   * @param user address of the user\n   * @return user stake power\n   */\n  function getUserStakePower(address user) public view override returns (uint256) {\n    return\n      ((userstakedAmounts[user][Duration.NONE].amount * 1) +\n        (userstakedAmounts[user][Duration.THREE_MONTHS].amount * 2) +\n        (userstakedAmounts[user][Duration.SIX_MONTHS].amount * 3) +\n        (userstakedAmounts[user][Duration.TWELVE_MONTHS].amount * 4)) / (10**18);\n  }\n\n  /**\n   * @notice Returns staking info for a user's staked amounts for different durations\n   * @param user address of the user\n   * @return Staking amounts for different durations\n   */\n  function getStakingInfo(address user) external view returns (StakeAmount[] memory) {\n    StakeAmount[] memory stakingInfo = new StakeAmount[](4);\n    stakingInfo[0] = userstakedAmounts[user][Duration.NONE];\n    stakingInfo[1] = userstakedAmounts[user][Duration.THREE_MONTHS];\n    stakingInfo[2] = userstakedAmounts[user][Duration.SIX_MONTHS];\n    stakingInfo[3] = userstakedAmounts[user][Duration.TWELVE_MONTHS];\n    return stakingInfo;\n  }\n\n  /**\n   * @notice Returns vested amount for a user for a given duration\n   * @param user address of the user\n   * @param duration the duration\n   * @return Vested amount for the given duration\n   */\n  function getVestedAmount(address user, Duration duration) public view returns (uint256) {\n    uint256 amount = userstakedAmounts[user][duration].amount;\n    uint256 timestamp = userstakedAmounts[user][duration].timestamp;\n    // short circuit if no vesting for this duration\n    if (timestamp == 0) {\n      return 0;\n    }\n    uint256 durationInSeconds = _getDurationInSeconds(duration);\n    uint256 secondsSinceStake = block.timestamp - timestamp;\n\n    return secondsSinceStake >= durationInSeconds ? amount : 0;\n  }\n\n  // ====================================================== INTERNAL FUNCTIONS ================================================\n\n  function _getDurationInSeconds(Duration duration) internal pure returns (uint256) {\n    if (duration == Duration.THREE_MONTHS) {\n      return 90 days;\n    } else if (duration == Duration.SIX_MONTHS) {\n      return 180 days;\n    } else if (duration == Duration.TWELVE_MONTHS) {\n      return 360 days;\n    } else {\n      return 0 seconds;\n    }\n  }\n\n  /** @notice Update user staked amounts for different duration on unstake\n    * @dev A more elegant recursive function is possible but this is more gas efficient\n   */\n  function _updateUserStakedAmounts(\n    address user,\n    uint256 amount,\n    uint256 noVesting,\n    uint256 vestedThreeMonths,\n    uint256 vestedSixMonths,\n    uint256 vestedTwelveMonths\n  ) internal {\n    if (amount > noVesting) {\n      userstakedAmounts[user][Duration.NONE].amount = 0;\n      userstakedAmounts[user][Duration.NONE].timestamp = 0;\n      amount = amount - noVesting;\n      if (amount > vestedThreeMonths) {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n        userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n        amount = amount - vestedThreeMonths;\n        if (amount > vestedSixMonths) {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n          userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n          amount = amount - vestedSixMonths;\n          if (amount > vestedTwelveMonths) {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n          } else {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;\n          }\n        } else {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;\n        }\n      } else {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;\n      }\n    } else {\n      userstakedAmounts[user][Duration.NONE].amount -= amount;\n    }\n  }\n\n  /// @dev clears staking info for a user on rageQuit\n  function _clearUserStakedAmounts(address user) internal {\n    // clear amounts\n    userstakedAmounts[user][Duration.NONE].amount = 0;\n    userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n    userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n    userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n\n    // clear timestamps\n    userstakedAmounts[user][Duration.NONE].timestamp = 0;\n    userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n    userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n    userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n  }\n\n  // ====================================================== ADMIN FUNCTIONS ================================================\n\n  /// @dev Admin function to rescue any ETH accidentally sent to the contract\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'Failed to send Ether');\n  }\n\n  /// @dev Admin function to update stake level thresholds\n  function updateStakeLevelThreshold(StakeLevel stakeLevel, uint16 threshold) external onlyOwner {\n    if (stakeLevel == StakeLevel.BRONZE) {\n      BRONZE_STAKE_THRESHOLD = threshold;\n    } else if (stakeLevel == StakeLevel.SILVER) {\n      SILVER_STAKE_THRESHOLD = threshold;\n    } else if (stakeLevel == StakeLevel.GOLD) {\n      GOLD_STAKE_THRESHOLD = threshold;\n    } else if (stakeLevel == StakeLevel.PLATINUM) {\n      PLATINUM_STAKE_THRESHOLD = threshold;\n    }\n  }\n\n  /// @dev Admin function to update rageQuit penalties\n  function updatePenalties(\n    uint16 threeMonthPenalty,\n    uint16 sixMonthPenalty,\n    uint16 twelveMonthPenalty\n  ) external onlyOwner {\n    THREE_MONTH_PENALTY = threeMonthPenalty;\n    SIX_MONTH_PENALTY = sixMonthPenalty;\n    TWELVE_MONTH_PENALTY = twelveMonthPenalty;\n  }\n\n  /// @dev Admin function to update Infinity treasury\n  function updateInfinityTreasury(address _infinityTreasury) external onlyOwner {\n    INFINITY_TREASURY = _infinityTreasury;\n  }\n}"
    },
    {
      "filename": "contracts/staking/InfinityStaker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IStaker, Duration, StakeLevel} from '../interfaces/IStaker.sol';\n\n/**\n * @title InfinityStaker\n * @author nneverlander. Twitter @nneverlander\n * @notice The staker contract that allows people to stake tokens and earn voting power to be used in curation and possibly other places\n */\ncontract InfinityStaker is IStaker, Ownable, Pausable, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n  struct StakeAmount {\n    uint256 amount;\n    uint256 timestamp;\n  }\n\n  ///@dev Storage variable to keep track of the staker's staked duration and amounts\n  mapping(address => mapping(Duration => StakeAmount)) public userstakedAmounts;\n\n  address public INFINITY_TOKEN;\n  ///@dev Infinity treasury address - will be a EOA/multisig\n  address public INFINITY_TREASURY;\n\n  /**@dev Power levels to reach the specified stake thresholds. Users can reach these levels \n          either by staking the specified number of tokens for no duration or a less number of tokens but with higher durations.\n          See getUserStakePower() to see how users can reach these levels.\n  */\n  uint16 public BRONZE_STAKE_THRESHOLD = 1000;\n  uint16 public SILVER_STAKE_THRESHOLD = 5000;\n  uint16 public GOLD_STAKE_THRESHOLD = 10000;\n  uint16 public PLATINUM_STAKE_THRESHOLD = 20000;\n\n  ///@dev Penalties if staked tokens are rageQuit early. Example: If 100 tokens are staked for twelve months but rageQuit right away,\n  /// the user will get back 100/4 tokens.\n  uint16 public THREE_MONTH_PENALTY = 2;\n  uint16 public SIX_MONTH_PENALTY = 3;\n  uint16 public TWELVE_MONTH_PENALTY = 4;\n\n  event Staked(address indexed user, uint256 amount, Duration duration);\n  event DurationChanged(address indexed user, uint256 amount, Duration oldDuration, Duration newDuration);\n  event UnStaked(address indexed user, uint256 amount);\n  event RageQuit(address indexed user, uint256 totalToUser, uint256 penalty);\n\n  constructor(address _tokenAddress, address _infinityTreasury) {\n    INFINITY_TOKEN = _tokenAddress;\n    INFINITY_TREASURY = _infinityTreasury;\n  }\n\n  // Fallback\n  fallback() external payable {}\n\n  receive() external payable {}\n\n  // =================================================== USER FUNCTIONS =======================================================\n\n  /**\n   * @notice Stake tokens for a specified duration\n   * @dev Tokens are transferred from the user to this contract\n   * @param amount Amount of tokens to stake\n   * @param duration Duration of the stake\n   */\n  function stake(uint256 amount, Duration duration) external override nonReentrant whenNotPaused {\n    require(amount != 0, 'stake amount cant be 0');\n    require(IERC20(INFINITY_TOKEN).balanceOf(msg.sender) >= amount, 'insufficient balance to stake');\n    // update storage\n    userstakedAmounts[msg.sender][duration].amount += amount;\n    userstakedAmounts[msg.sender][duration].timestamp = block.timestamp;\n    // perform transfer\n    IERC20(INFINITY_TOKEN).safeTransferFrom(msg.sender, address(this), amount);\n    // emit event\n    emit Staked(msg.sender, amount, duration);\n  }\n\n  /**\n   * @notice Change duration of staked tokens\n   * @dev Duration can be changed from low to high but not from high to low. State updates are performed\n   * @param amount Amount of tokens to change duration\n   * @param oldDuration Old duration of the stake\n   * @param newDuration New duration of the stake\n   */\n  function changeDuration(\n    uint256 amount,\n    Duration oldDuration,\n    Duration newDuration\n  ) external override nonReentrant whenNotPaused {\n    require(amount != 0, 'amount cant be 0');\n    require(\n      userstakedAmounts[msg.sender][oldDuration].amount >= amount,\n      'insufficient staked amount to change duration'\n    );\n    require(newDuration > oldDuration, 'new duration must be greater than old duration');\n\n    // update storage\n    userstakedAmounts[msg.sender][oldDuration].amount -= amount;\n    userstakedAmounts[msg.sender][newDuration].amount += amount;\n    // update timestamp for new duration\n    userstakedAmounts[msg.sender][newDuration].timestamp = block.timestamp;\n    // only update old duration timestamp if old duration amount is 0\n    if (userstakedAmounts[msg.sender][oldDuration].amount == 0) {\n      userstakedAmounts[msg.sender][oldDuration].timestamp = 0;\n    }\n    // emit event\n    emit DurationChanged(msg.sender, amount, oldDuration, newDuration);\n  }\n\n  /**\n   * @notice Untake tokens\n   * @dev Storage updates are done for each stake level. See _updateUserStakedAmounts for more details\n   * @param amount Amount of tokens to unstake\n   */\n  function unstake(uint256 amount) external override nonReentrant whenNotPaused {\n    require(amount != 0, 'stake amount cant be 0');\n    uint256 noVesting = userstakedAmounts[msg.sender][Duration.NONE].amount;\n    uint256 vestedThreeMonths = getVestedAmount(msg.sender, Duration.THREE_MONTHS);\n    uint256 vestedsixMonths = getVestedAmount(msg.sender, Duration.SIX_MONTHS);\n    uint256 vestedTwelveMonths = getVestedAmount(msg.sender, Duration.TWELVE_MONTHS);\n    uint256 totalVested = noVesting + vestedThreeMonths + vestedsixMonths + vestedTwelveMonths;\n    require(totalVested >= amount, 'insufficient balance to unstake');\n\n    // update storage\n    _updateUserStakedAmounts(msg.sender, amount, noVesting, vestedThreeMonths, vestedsixMonths, vestedTwelveMonths);\n    // perform transfer\n    IERC20(INFINITY_TOKEN).safeTransfer(msg.sender, amount);\n    // emit event\n    emit UnStaked(msg.sender, amount);\n  }\n\n  /**\n   * @notice Ragequit tokens. Applies penalties for unvested tokens\n   */\n  function rageQuit() external override nonReentrant {\n    (uint256 totalToUser, uint256 penalty) = getRageQuitAmounts(msg.sender);\n    // update storage\n    _clearUserStakedAmounts(msg.sender);\n    // perform transfers\n    IERC20(INFINITY_TOKEN).safeTransfer(msg.sender, totalToUser);\n    IERC20(INFINITY_TOKEN).safeTransfer(INFINITY_TREASURY, penalty);\n    // emit event\n    emit RageQuit(msg.sender, totalToUser, penalty);\n  }\n\n  // ====================================================== VIEW FUNCTIONS ======================================================\n\n  /**\n   * @notice Get total staked tokens for a user for all durations\n   * @param user address of the user\n   * @return total amount of tokens staked by the user\n   */\n  function getUserTotalStaked(address user) public view override returns (uint256) {\n    return\n      userstakedAmounts[user][Duration.NONE].amount +\n      userstakedAmounts[user][Duration.THREE_MONTHS].amount +\n      userstakedAmounts[user][Duration.SIX_MONTHS].amount +\n      userstakedAmounts[user][Duration.TWELVE_MONTHS].amount;\n  }\n\n  /**\n   * @notice Get total vested tokens for a user for all durations\n   * @param user address of the user\n   * @return total amount of vested tokens for the user\n   */\n  function getUserTotalVested(address user) public view override returns (uint256) {\n    uint256 noVesting = getVestedAmount(user, Duration.NONE);\n    uint256 vestedThreeMonths = getVestedAmount(user, Duration.THREE_MONTHS);\n    uint256 vestedsixMonths = getVestedAmount(user, Duration.SIX_MONTHS);\n    uint256 vestedTwelveMonths = getVestedAmount(user, Duration.TWELVE_MONTHS);\n    return noVesting + vestedThreeMonths + vestedsixMonths + vestedTwelveMonths;\n  }\n\n  /**\n   * @notice Gets rageQuit amounts for a user after applying penalties\n   * @dev Penalty amounts are sent to Infinity treasury\n   * @param user address of the user\n   * @return Total amount to user and penalties\n   */\n  function getRageQuitAmounts(address user) public view override returns (uint256, uint256) {\n    uint256 noLock = userstakedAmounts[user][Duration.NONE].amount;\n    uint256 threeMonthLock = userstakedAmounts[user][Duration.THREE_MONTHS].amount;\n    uint256 sixMonthLock = userstakedAmounts[user][Duration.SIX_MONTHS].amount;\n    uint256 twelveMonthLock = userstakedAmounts[user][Duration.TWELVE_MONTHS].amount;\n\n    uint256 threeMonthVested = getVestedAmount(user, Duration.THREE_MONTHS);\n    uint256 sixMonthVested = getVestedAmount(user, Duration.SIX_MONTHS);\n    uint256 twelveMonthVested = getVestedAmount(user, Duration.TWELVE_MONTHS);\n\n    uint256 totalVested = noLock + threeMonthVested + sixMonthVested + twelveMonthVested;\n    uint256 totalStaked = noLock + threeMonthLock + sixMonthLock + twelveMonthLock;\n    require(totalStaked >= 0, 'nothing staked to rage quit');\n\n    uint256 totalToUser = totalVested +\n      ((threeMonthLock - threeMonthVested) / THREE_MONTH_PENALTY) +\n      ((sixMonthLock - sixMonthVested) / SIX_MONTH_PENALTY) +\n      ((twelveMonthLock - twelveMonthVested) / TWELVE_MONTH_PENALTY);\n\n    uint256 penalty = totalStaked - totalToUser;\n\n    return (totalToUser, penalty);\n  }\n\n  /**\n   * @notice Gets a user's stake level\n   * @param user address of the user\n   * @return StakeLevel\n   */\n  function getUserStakeLevel(address user) external view override returns (StakeLevel) {\n    uint256 totalPower = getUserStakePower(user);\n\n    if (totalPower <= BRONZE_STAKE_THRESHOLD) {\n      return StakeLevel.NONE;\n    } else if (totalPower > BRONZE_STAKE_THRESHOLD && totalPower <= SILVER_STAKE_THRESHOLD) {\n      return StakeLevel.BRONZE;\n    } else if (totalPower > SILVER_STAKE_THRESHOLD && totalPower <= GOLD_STAKE_THRESHOLD) {\n      return StakeLevel.SILVER;\n    } else if (totalPower > GOLD_STAKE_THRESHOLD && totalPower <= PLATINUM_STAKE_THRESHOLD) {\n      return StakeLevel.GOLD;\n    } else {\n      return StakeLevel.PLATINUM;\n    }\n  }\n\n  /**\n   * @notice Gets a user stake power. Used to determine voting power in curating collections and possibly other places\n   * @dev Tokens staked for higher duration apply a multiplier\n   * @param user address of the user\n   * @return user stake power\n   */\n  function getUserStakePower(address user) public view override returns (uint256) {\n    return\n      ((userstakedAmounts[user][Duration.NONE].amount * 1) +\n        (userstakedAmounts[user][Duration.THREE_MONTHS].amount * 2) +\n        (userstakedAmounts[user][Duration.SIX_MONTHS].amount * 3) +\n        (userstakedAmounts[user][Duration.TWELVE_MONTHS].amount * 4)) / (10**18);\n  }\n\n  /**\n   * @notice Returns staking info for a user's staked amounts for different durations\n   * @param user address of the user\n   * @return Staking amounts for different durations\n   */\n  function getStakingInfo(address user) external view returns (StakeAmount[] memory) {\n    StakeAmount[] memory stakingInfo = new StakeAmount[](4);\n    stakingInfo[0] = userstakedAmounts[user][Duration.NONE];\n    stakingInfo[1] = userstakedAmounts[user][Duration.THREE_MONTHS];\n    stakingInfo[2] = userstakedAmounts[user][Duration.SIX_MONTHS];\n    stakingInfo[3] = userstakedAmounts[user][Duration.TWELVE_MONTHS];\n    return stakingInfo;\n  }\n\n  /**\n   * @notice Returns vested amount for a user for a given duration\n   * @param user address of the user\n   * @param duration the duration\n   * @return Vested amount for the given duration\n   */\n  function getVestedAmount(address user, Duration duration) public view returns (uint256) {\n    uint256 amount = userstakedAmounts[user][duration].amount;\n    uint256 timestamp = userstakedAmounts[user][duration].timestamp;\n    // short circuit if no vesting for this duration\n    if (timestamp == 0) {\n      return 0;\n    }\n    uint256 durationInSeconds = _getDurationInSeconds(duration);\n    uint256 secondsSinceStake = block.timestamp - timestamp;\n\n    return secondsSinceStake >= durationInSeconds ? amount : 0;\n  }\n\n  // ====================================================== INTERNAL FUNCTIONS ================================================\n\n  function _getDurationInSeconds(Duration duration) internal pure returns (uint256) {\n    if (duration == Duration.THREE_MONTHS) {\n      return 90 days;\n    } else if (duration == Duration.SIX_MONTHS) {\n      return 180 days;\n    } else if (duration == Duration.TWELVE_MONTHS) {\n      return 360 days;\n    } else {\n      return 0 seconds;\n    }\n  }\n\n  /** @notice Update user staked amounts for different duration on unstake\n    * @dev A more elegant recursive function is possible but this is more gas efficient\n   */\n  function _updateUserStakedAmounts(\n    address user,\n    uint256 amount,\n    uint256 noVesting,\n    uint256 vestedThreeMonths,\n    uint256 vestedSixMonths,\n    uint256 vestedTwelveMonths\n  ) internal {\n    if (amount > noVesting) {\n      userstakedAmounts[user][Duration.NONE].amount = 0;\n      userstakedAmounts[user][Duration.NONE].timestamp = 0;\n      amount = amount - noVesting;\n      if (amount > vestedThreeMonths) {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n        userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n        amount = amount - vestedThreeMonths;\n        if (amount > vestedSixMonths) {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n          userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n          amount = amount - vestedSixMonths;\n          if (amount > vestedTwelveMonths) {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n          } else {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;\n          }\n        } else {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;\n        }\n      } else {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;\n      }\n    } else {\n      userstakedAmounts[user][Duration.NONE].amount -= amount;\n    }\n  }\n\n  /// @dev clears staking info for a user on rageQuit\n  function _clearUserStakedAmounts(address user) internal {\n    // clear amounts\n    userstakedAmounts[user][Duration.NONE].amount = 0;\n    userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n    userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n    userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n\n    // clear timestamps\n    userstakedAmounts[user][Duration.NONE].timestamp = 0;\n    userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n    userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n    userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n  }\n\n  // ====================================================== ADMIN FUNCTIONS ================================================\n\n  /// @dev Admin function to rescue any ETH accidentally sent to the contract\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'Failed to send Ether');\n  }\n\n  /// @dev Admin function to update stake level thresholds\n  function updateStakeLevelThreshold(StakeLevel stakeLevel, uint16 threshold) external onlyOwner {\n    if (stakeLevel == StakeLevel.BRONZE) {\n      BRONZE_STAKE_THRESHOLD = threshold;\n    } else if (stakeLevel == StakeLevel.SILVER) {\n      SILVER_STAKE_THRESHOLD = threshold;\n    } else if (stakeLevel == StakeLevel.GOLD) {\n      GOLD_STAKE_THRESHOLD = threshold;\n    } else if (stakeLevel == StakeLevel.PLATINUM) {\n      PLATINUM_STAKE_THRESHOLD = threshold;\n    }\n  }\n\n  /// @dev Admin function to update rageQuit penalties\n  function updatePenalties(\n    uint16 threeMonthPenalty,\n    uint16 sixMonthPenalty,\n    uint16 twelveMonthPenalty\n  ) external onlyOwner {\n    THREE_MONTH_PENALTY = threeMonthPenalty;\n    SIX_MONTH_PENALTY = sixMonthPenalty;\n    TWELVE_MONTH_PENALTY = twelveMonthPenalty;\n  }\n\n  /// @dev Admin function to update Infinity treasury\n  function updateInfinityTreasury(address _infinityTreasury) external onlyOwner {\n    INFINITY_TREASURY = _infinityTreasury;\n  }\n}"
    },
    {
      "filename": "contracts/staking/InfinityStaker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IStaker, Duration, StakeLevel} from '../interfaces/IStaker.sol';\n\n/**\n * @title InfinityStaker\n * @author nneverlander. Twitter @nneverlander\n * @notice The staker contract that allows people to stake tokens and earn voting power to be used in curation and possibly other places\n */\ncontract InfinityStaker is IStaker, Ownable, P"
    }
  ]
}