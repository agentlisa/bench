{
  "Title": "[M-07] `Auction.sol#settleAuction()` Bonder may not be able to settle a bonded auction, leading to loss of funds",
  "Content": "_Submitted by WatchPug_\n\n[Auction.sol#L97-L102](https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Auction.sol#L97-L102)\n\n```solidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a - b;\n\n(address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();\nrequire(newRatio >= minIbRatio);\n```\n\nIn the current implementation, `newRatio` is calculated and compared with `minIbRatio` in `settleAuction()`.\n\nHowever, if `newRatio` is less than `minIbRatio`, `settleAuction()` will always fail and there is no way for the bonder to cancel and get a refund.\n\n### Proof of Concept\n\nGiven:\n\n*   `bondPercentDiv` = 400\n*   `basketToken.totalSupply` = 40,000\n*   `factory.auctionMultiplier` = 2\n*   `factory.auctionDecrement` = 10,000\n*   `basket.ibRatio` = 1e18\n*   p`endingWeights.minIbRatio` = 1.9 \\* 1e18\n\n1.  Alice called `bondForRebalance()` `2,000` blocks after the auction started, paid `100` basketToken for the bond;\n2.  Alice tries to `settleAuction()`, it will always fail because `newRatio < minIbRatio`;\n\n*   a = 2 \\* 1e18\n*   b = 0.2 \\* 1e18\n*   newRatio = 1.8 \\* 1e18;\n\n3.  Bob calls `bondBurn()` one day after, `100` basketToken from Alice will been burned.\n\n### Recommended Mitigation Steps\n\nMove the `minIbRatio` check to `bondForRebalance()`:\n\n```solidity\nfunction bondForRebalance() public override {\nrequire(auctionOngoing);\nrequire(!hasBonded);\n\nbondTimestamp = block.timestamp;\nbondBlock = block.number;\n\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a - b;\n\n(address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();\nrequire(newRatio >= minIbRatio);\n\nIERC20 basketToken = IERC20(address(basket));\nbondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\nbasketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\nhasBonded = true;\nauctionBonder = msg.sender;\n\nemit Bonded(msg.sender, bondAmount);\n}\n```\n\n**[frank-beard (Kuiper) confirmed](https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/106)**\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/106#issuecomment-1079817328):**\n> While this issue is correct and I think this is a safer way to handle the `require(newRatio >= minIbRatio)` check, there are a few assumptions that are made. For example, it is assumed that the user bonds their tokens without checking `minIbRatio` and a publisher is able to maliciously update `minIbRatio` which must first go through timelock. Based on this, I'm more inclined to downgrade this to `medium` severity as I think this more accurately reflects the threat model.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-12-defiProtocol",
  "Code": [
    {
      "filename": "contracts/contracts/Auction.sol",
      "content": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 1 days;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    uint256 public override bondBlock;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    bool public override initialized;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.timestamp;\n        bondBlock = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public nonReentrant override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.timestamp);\n        require(msg.sender == auctionBonder);\n        require(inputTokens.length == inputWeights.length);\n        require(outputTokens.length == outputWeights.length);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        //TODO: name a and b or further split up\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();\n        require(newRatio >= minIbRatio);\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        basketAsERC20.safeTransfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.timestamp);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty storage bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).safeTransfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }"
    }
  ]
}