{
  "Title": "[N-04] Adding a `return` statement when the function defines a named return variable, is redundant",
  "Content": "\n```solidity\nFile: contracts/pool/PoolFactory.sol   #1\n\n216         return addrs;\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L216>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-backd",
  "Code": [
    {
      "filename": "backd/contracts/pool/PoolFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"../../interfaces/IStakerVault.sol\";\nimport \"../../interfaces/IVault.sol\";\nimport \"../../interfaces/ILpToken.sol\";\nimport \"../../interfaces/IAdmin.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../interfaces/pool/IErc20Pool.sol\";\nimport \"../../interfaces/pool/IEthPool.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"../access/Authorization.sol\";\n\ncontract PoolFactory is Authorization {\n    using AddressProviderHelpers for IAddressProvider;\n\n    struct Addresses {\n        address pool;\n        address vault;\n        address lpToken;\n        address stakerVault;\n    }\n\n    struct ImplementationNames {\n        bytes32 pool;\n        bytes32 vault;\n        bytes32 lpToken;\n        bytes32 stakerVault;\n    }\n\n    struct VaultArgs {\n        uint256 debtLimit;\n        uint256 targetAllocation;\n        uint256 bound;\n    }\n\n    struct LpTokenArgs {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    struct DeployPoolVars {\n        address lpTokenImplementation;\n        address poolImplementation;\n        address stakerVaultImplementation;\n        address vaultImplementation;\n    }\n\n    bytes32 internal constant _POOL_KEY = \"pool\";\n    bytes32 internal constant _LP_TOKEN_KEY = \"lp_token\";\n    bytes32 internal constant _STAKER_VAULT_KEY = \"staker_vault\";\n    bytes32 internal constant _VAULT_KEY = \"vault\";\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    /**\n     * @dev maps a contract type (e.g. \"pool\" or \"lp_token\", as defined in constants above)\n     * to a mapping from an implementation name to the actual implementation\n     * The implementation name is decided when registering the implementation\n     * and can be arbitrary (e.g. \"ERC20PoolV1\")\n     */\n    mapping(bytes32 => mapping(bytes32 => address)) public implementations;\n\n    event NewPool(address pool, address vault, address lpToken, address stakerVault);\n    event NewImplementation(bytes32 key, bytes32 name, address implementation);\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = IController(_controller);\n        addressProvider = IController(_controller).addressProvider();\n    }\n\n    /**\n     * @notice Add a new pool implementation to the factory.\n     * @param name of the pool implementation.\n     * @param implementation of pool implementation to add.\n     */\n    function addPoolImplementation(bytes32 name, address implementation)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _addImplementation(_POOL_KEY, name, implementation);\n    }\n\n    /**\n     * @notice Add a new LP token implementation to the factory.\n     * @param name of the LP token implementation.\n     * @param implementation of lp token implementation to add.\n     */\n    function addLpTokenImplementation(bytes32 name, address implementation)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _addImplementation(_LP_TOKEN_KEY, name, implementation);\n    }\n\n    /**\n     * @notice Add a new vault implementation to the factory.\n     * @param name of the vault implementation.\n     * @param implementation of vault implementation to add.\n     */\n    function addVaultImplementation(bytes32 name, address implementation)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _addImplementation(_VAULT_KEY, name, implementation);\n    }\n\n    /**\n     * @notice Add a new staker vault implementation to the factory.\n     * @param name of the staker vault implementation.\n     * @param implementation of staker vault implementation to add.\n     */\n    function addStakerVaultImplementation(bytes32 name, address implementation)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _addImplementation(_STAKER_VAULT_KEY, name, implementation);\n    }\n\n    /**\n     * @notice Deploys a new pool and LP token.\n     * @dev Decimals is an argument as not all ERC20 tokens implement the ERC20Detailed interface.\n     *      An implementation where `getUnderlying()` returns the zero address is for ETH pools.\n     * @param poolName Name of the pool.\n     * @param underlying Address of the pool's underlying.\n     * @param lpTokenArgs Arguments to create the LP token for the pool\n     * @param vaultArgs Arguments to create the vault\n     * @param implementationNames Name of the implementations to use\n     * @return addrs Address of the deployed pool, address of the pool's deployed LP token.\n     */\n    function deployPool(\n        string calldata poolName,\n        uint256 depositCap,\n        address underlying,\n        LpTokenArgs calldata lpTokenArgs,\n        VaultArgs calldata vaultArgs,\n        ImplementationNames calldata implementationNames\n    ) external onlyGovernance returns (Addresses memory addrs) {\n        DeployPoolVars memory vars;\n\n        vars.poolImplementation = implementations[_POOL_KEY][implementationNames.pool];\n        require(vars.poolImplementation != address(0), Error.INVALID_POOL_IMPLEMENTATION);\n\n        vars.lpTokenImplementation = implementations[_LP_TOKEN_KEY][implementationNames.lpToken];\n        require(vars.lpTokenImplementation != address(0), Error.INVALID_LP_TOKEN_IMPLEMENTATION);\n\n        vars.vaultImplementation = implementations[_VAULT_KEY][implementationNames.vault];\n        require(vars.vaultImplementation != address(0), Error.INVALID_VAULT_IMPLEMENTATION);\n\n        vars.stakerVaultImplementation = implementations[_STAKER_VAULT_KEY][\n            implementationNames.stakerVault\n        ];\n        require(\n            vars.stakerVaultImplementation != address(0),\n            Error.INVALID_STAKER_VAULT_IMPLEMENTATION\n        );\n\n        addrs.pool = Clones.clone(vars.poolImplementation);\n        addrs.vault = Clones.clone(vars.vaultImplementation);\n\n        if (underlying == address(0)) {\n            // ETH pool\n            require(\n                ILiquidityPool(vars.poolImplementation).getUnderlying() == address(0),\n                Error.INVALID_POOL_IMPLEMENTATION\n            );\n            require(lpTokenArgs.decimals == 18, Error.INVALID_DECIMALS);\n            IEthPool(addrs.pool).initialize(poolName, depositCap, addrs.vault);\n        } else {\n            IErc20Pool(addrs.pool).initialize(poolName, underlying, depositCap, addrs.vault);\n        }\n\n        addrs.lpToken = Clones.clone(vars.lpTokenImplementation);\n\n        ILpToken(addrs.lpToken).initialize(\n            lpTokenArgs.name,\n            lpTokenArgs.symbol,\n            lpTokenArgs.decimals,\n            addrs.pool\n        );\n\n        addrs.stakerVault = Clones.clone(vars.stakerVaultImplementation);\n        IStakerVault(addrs.stakerVault).initialize(addrs.lpToken);\n        controller.addStakerVault(addrs.stakerVault);\n\n        ILiquidityPool(addrs.pool).setLpToken(addrs.lpToken);\n        ILiquidityPool(addrs.pool).setStaker();\n\n        IVault(addrs.vault).initialize(\n            addrs.pool,\n            vaultArgs.debtLimit,\n            vaultArgs.targetAllocation,\n            vaultArgs.bound\n        );\n\n        addressProvider.addPool(addrs.pool);\n\n        emit NewPool(addrs.pool, addrs.vault, addrs.lpToken, addrs.stakerVault);\n        return addrs;\n    }\n\n    /**\n     * @notice Add a new implementation of type `name` to the factory.\n     * @param key of the implementation to add.\n     * @param name of the implementation to add.\n     * @param implementation of lp token implementation to add.\n     */\n    function _addImplementation(\n        bytes32 key,\n        bytes32 name,\n        address implementation\n    ) internal returns (bool) {\n        mapping(bytes32 => address) storage currentImplementations = implementations[key];\n        if (currentImplementations[name] != address(0)) {\n            return false;\n        }\n        currentImplementations[name] = implementation;\n        emit NewImplementation(key, name, implementation);\n        return true;\n    }\n}"
    }
  ]
}