{
  "Title": "[G-02] The creation of an intermediary array can be avoided",
  "Content": "Sometimes, it's not necessary to create an intermediate array to store  values.\n\n*1 instance*\n\n- [SecurityCouncilMgmtUtils.sol#L15-L36](https://github.com/arbitrumfoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/SecurityCouncilMgmtUtils.sol#L15-L36)\n\nIn this case, an array of maximum size is created because we don't yet know what size the final array will be. This is not useful, as it's more efficient to keep this maximum-size array, fill it and then reduce its size using assembly.\n\nThe function can be changed like that:\n\n```diff\nfunction filterAddressesWithExcludeList(\naddress[]  memory input,\nmapping(address => bool)  storage excludeList\n)  internal  view  returns  (address[]  memory)  {\n- /* */\n+\taddress[]  memory output =  new  address[](input.length);\n+\tuint256 outputLength =  0;\n+\tfor  (uint256 i =  0; i < input.length; i++)  {\n+\t\tif  (!excludeList[input[i]])  {\n+\t\t\toutput[outputLength]  = input[i];\n+\t\t\toutputLength++;\n+\t\t}\n+\t}\n+\tassembly {\n+\t\tmstore(output, outputLength) //Set the appropriate size\n+\t}\n+\treturn output;\n}\n```\n\nApplying this optimisation, those changes appear in the snapshot:\n\n```\ntestE2E() (gas: -31712 (-0.038%))\ntestSecurityCouncilManagerDeployment() (gas: -30294 (-0.101%))\ntestNomineeElectionGovDeployment() (gas: -30294 (-0.101%))\ntestRemovalGovDeployment() (gas: -30294 (-0.101%))\ntestMemberElectionGovDeployment() (gas: -30294 (-0.101%))\ntestOnlyOwnerCanDeploy() (gas: -30294 (-0.120%))\ntestInvalidInit() (gas: -30293 (-0.433%))\ntestTopNomineesGas() (gas: -109619 (-2.434%))\nOverall gas change: -323094 (-0.023%)\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-08-arbitrum",
  "Code": [
    {
      "filename": "src/security-council-mgmt/SecurityCouncilMgmtUtils.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nlibrary SecurityCouncilMgmtUtils {\n    function isInArray(address addr, address[] memory arr) internal pure returns (bool) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            if (arr[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // filters an array of addresses by removing any addresses that are in the excludeList\n    function filterAddressesWithExcludeList(\n        address[] memory input,\n        mapping(address => bool) storage excludeList\n    ) internal view returns (address[] memory) {\n        address[] memory intermediate = new address[](input.length);\n        uint256 intermediateLength = 0;\n\n        for (uint256 i = 0; i < input.length; i++) {\n            address nominee = input[i];\n            if (!excludeList[nominee]) {\n                intermediate[intermediateLength] = nominee;\n                intermediateLength++;\n            }\n        }\n\n        address[] memory output = new address[](intermediateLength);\n        for (uint256 i = 0; i < intermediateLength; i++) {\n            output[i] = intermediate[i];\n        }\n\n        return output;\n    }\n}"
    }
  ]
}