{
  "Title": "[H-01] Incorrect amounts of ETH are transferred to the DAO treasury in `ERC20TokenEmitter::buyToken()`, causing a value leak in every transaction",
  "Content": "\nWhile users buying governance tokens with `ERC20TokenEmitter::buyToken` function, some portion of the provided ETH is reserved for creators according to the [`creatorRateBps`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L42).\n\nA part of this creator's reserved ETH is directly sent to the creators according to [`entropyRateBps`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L45), and the remaining part is used to buy governance tokens for creators.\n\nThat remaining part, which is used to buy governance tokens, is never sent to the DAO treasury. It is locked in the `ERC20Emitter` contract, causing value leaks for treasury in every `buyToken` function call.\n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L190C1-L198C10>\n\n```solidity\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n    // ...\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n\n        //Share of purchase amount to send to treasury\n        uint256 toPayTreasury = (msgValueRemaining * (10_000 - creatorRateBps)) / 10_000;\n\n        //Share of purchase amount to reserve for creators\n        //Ether directly sent to creators\n        uint256 creatorDirectPayment = ((msgValueRemaining - toPayTreasury) * entropyRateBps) / 10_000;\n        //Tokens to emit to creators\n        int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n            ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n        // Tokens to emit to buyers\n        int totalTokensForBuyers = toPayTreasury > 0 ? getTokenQuoteForEther(toPayTreasury) : int(0);\n\n        //Transfer ETH to treasury and update emitted\n        emittedTokenWad += totalTokensForBuyers;\n        if (totalTokensForCreators > 0) emittedTokenWad += totalTokensForCreators;\n\n        //Deposit funds to treasury\n-->     (bool success, ) = treasury.call{ value: toPayTreasury }(new bytes(0)); //@audit-issue Treasury is not paid correctly. Only the buyers share is sent. Creators share to buy governance tokens are not sent to treasury\n        require(success, \"Transfer failed.\");                                   //@audit `creators total share` - `creatorDirectPayment` should also be sent to treasury. ==> Which is \"((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\"\n\n        //Transfer ETH to creators\n        if (creatorDirectPayment > 0) {\n            (success, ) = creatorsAddress.call{ value: creatorDirectPayment }(new bytes(0));\n            require(success, \"Transfer failed.\");\n        }\n\n        // ... rest of the code\n    }\n```\n\nIn the code above:\n\n`toPayTreasury` is the buyer's portion of the sent ether.\\\n`(msgValueRemaining - toPayTreasury)` is the creator's portion of the sent ether.\\\n`((msgValueRemaining - toPayTreasury) - creatorDirectPayment)` is the remaining part of the creator's share after direct payment *(which is used to buy the governance token).*\n\nAs we can see above, the part that is used to buy governance tokens is not sent to the treasury. Only the buyer's portion is sent.\n\n### Impact\n\n*   DAO treasury is not properly paid even though the corresponding governance tokens are minted.\n\n*   Every `buyToken` transaction will cause a value leak to the DAO treasury. The leaked ETH amounts are stuck in the `ERC20TokenEmitter` contract.\n\n### Proof of Concept\n\n**Coded PoC**\n\nYou can use the protocol's own test suite to run this PoC.\n\n\\-Copy and paste the snippet below into the `ERC20TokenEmitter.t.sol` test file.\\\n\\-Run it with `forge test --match-test testBuyToken_ValueLeak -vvv`\n\n<details>\n\n```solidity\nfunction testBuyToken_ValueLeak() public {\n        \n        // Set creator and entropy rates.\n        // Creator rate will be 10% and entropy rate will be 40%\n        uint256 creatorRate = 1000;\n        uint256 entropyRate = 5000;\n        vm.startPrank(address(dao));\n        erc20TokenEmitter.setCreatorRateBps(creatorRate);\n        erc20TokenEmitter.setEntropyRateBps(entropyRate);\n\n        // Check dao treasury and erc20TokenEmitter balances. Balance of both of them should be 0.\n        uint256 treasuryETHBalance_BeforePurchase = address(erc20TokenEmitter.treasury()).balance;\n        uint256 emitterContractETHBalance_BeforePurchase = address(erc20TokenEmitter).balance;\n        \n        assertEq(treasuryETHBalance_BeforePurchase, 0);\n        assertEq(emitterContractETHBalance_BeforePurchase, 0);\n\n        // Create token purchase parameters\n        address[] memory recipients = new address[](1);\n        recipients[0] = address(1);\n        uint256[] memory bps = new uint256[](1);\n        bps[0] = 10_000;\n\n        // Give some ETH to user and buy governance token.\n        vm.startPrank(address(0));\n        vm.deal(address(0), 100000 ether);\n\n        erc20TokenEmitter.buyToken{ value: 100 ether }(\n            recipients,\n            bps,\n            IERC20TokenEmitter.ProtocolRewardAddresses({\n                builder: address(0),\n                purchaseReferral: address(0),\n                deployer: address(0)\n            })\n        );\n\n        // User bought 100 ether worth of tokens.\n        // Normally with 2.5% fixed protocol rewards, 10% creator share and 50% entropy share: \n        //  ->  2.5 ether is protocol rewards.\n        //  ->  87.75 ether is buyer share (90% of the 97.5)\n        //  ->  9.75 of the ether is creators share\n        //          - 4.875 ether directly sent to creators\n        //          - 4.875 ether should be used to buy governance token and should be sent to the treasury.\n        // However, the 4.875 ether is never sent to the treasury even though it is used to buy governance tokens. It is stuck in the Emitter contract. \n\n        // Check balances after purchase.\n        uint256 treasuryETHBalance_AfterPurchase = address(erc20TokenEmitter.treasury()).balance;\n        uint256 emitterContractETHBalance_AfterPurchase = address(erc20TokenEmitter).balance;\n        uint256 creatorETHBalance_AfterPurchase = address(erc20TokenEmitter.creatorsAddress()).balance;\n\n        // Creator direct payment amount is 4.875 as expected\n        assertEq(creatorETHBalance_AfterPurchase, 4.875 ether);\n        \n        // Dao treasury has 87.75 ether instead of 92.625 ether. \n        // 4.875 ether that is used to buy governance tokens for creators is never sent to treasury and still in the emitter contract.\n        assertEq(treasuryETHBalance_AfterPurchase, 87.75 ether);\n        assertEq(emitterContractETHBalance_AfterPurchase, 4.875 ether);\n    }\n```\n\n</details>\n\nResults after running the test:\n\n```solidity\nRunning 1 test for test/token-emitter/ERC20TokenEmitter.t.sol:ERC20TokenEmitterTest\n[PASS] testBuyToken_ValueLeak() (gas: 459490)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.25ms\n \nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nI would recommend transferring the remaining ETH used to buy governance tokens to the treasury.\n\n```diff\n+       uint256 creatorsEthAfterDirectPayment = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment);\n\n         //Deposit funds to treasury\n-       (bool success, ) = treasury.call{ value: toPayTreasury }(new bytes(0));\n+       (bool success, ) = treasury.call{ value: toPayTreasury + creatorsEthAfterDirectPayment }(new bytes(0));\n        require(success, \"Transfer failed.\");\n```\n\n**[rocketman-21 (Revolution) confirmed](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/210#issuecomment-1883282354)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/ERC20TokenEmitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { TokenEmitterRewards } from \"@collectivexyz/protocol-rewards/src/abstract/TokenEmitter/TokenEmitterRewards.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport { VRGDAC } from \"./libs/VRGDAC.sol\";\nimport { toDaysWadUnsafe } from \"./libs/SignedWadMath.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { NontransferableERC20Votes } from \"./NontransferableERC20Votes.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract ERC20TokenEmitter is\n    IERC20TokenEmitter,\n    ReentrancyGuardUpgradeable,\n    TokenEmitterRewards,\n    Ownable2StepUpgradeable,\n    PausableUpgradeable\n{\n    // treasury address to pay funds to\n    address public treasury;\n\n    // The token that is being minted.\n    NontransferableERC20Votes public token;\n\n    // The VRGDA contract\n    VRGDAC public vrgdac;\n\n    // solhint-disable-next-line not-rely-on-time\n    uint256 public startTime;\n\n    /**\n     * @notice A running total of the amount of tokens emitted.\n     */\n    int256 public emittedTokenWad;\n\n    // The split of the purchase that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The split of (purchase proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The account or contract to pay the creator reward to\n    address public creatorsAddress;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _protocolRewards The protocol rewards contract address\n    /// @param _protocolFeeRecipient The protocol fee recipient address\n    constructor(\n        address _manager,\n        address _protocolRewards,\n        address _protocolFeeRecipient\n    ) payable TokenEmitterRewards(_protocolRewards, _protocolFeeRecipient) initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the token emitter\n     * @param _initialOwner The initial owner of the token emitter\n     * @param _erc20Token The ERC-20 token contract address\n     * @param _vrgdac The VRGDA contract address\n     * @param _treasury The treasury address to pay funds to\n     * @param _creatorsAddress The address to pay the creator reward to\n     */\n    function initialize(\n        address _initialOwner,\n        address _erc20Token,\n        address _treasury,\n        address _vrgdac,\n        address _creatorsAddress\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        require(_treasury != address(0), \"Invalid treasury address\");\n\n        // Set up ownable\n        __Ownable_init(_initialOwner);\n\n        treasury = _treasury;\n        creatorsAddress = _creatorsAddress;\n        vrgdac = VRGDAC(_vrgdac);\n        token = NontransferableERC20Votes(_erc20Token);\n        startTime = block.timestamp;\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        token.mint(_to, _amount);\n    }\n\n    function totalSupply() public view returns (uint) {\n        // returns total supply issued so far\n        return token.totalSupply();\n    }\n\n    function decimals() public view returns (uint8) {\n        // returns decimals\n        return token.decimals();\n    }\n\n    function balanceOf(address _owner) public view returns (uint) {\n        // returns balance of address\n        return token.balanceOf(_owner);\n    }\n\n    /**\n     * @notice Pause the contract.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the token emitter.\n     * @dev This function can only be called by the owner when the\n     * contract is paused.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice A payable function that allows a user to buy tokens for a list of addresses and a list of basis points to split the token purchase between.\n     * @param addresses The addresses to send purchased tokens to.\n     * @param basisPointSplits The basis points of the purchase to send to each address.\n     * @param protocolRewardsRecipients The addresses to pay the builder, purchaseRefferal, and deployer rewards to\n     * @return tokensSoldWad The amount of tokens sold in wad units.\n     */\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n        //prevent treasury from paying itself\n        require(msg.sender != treasury && msg.sender != creatorsAddress, \"Funds recipient cannot buy tokens\");\n\n        require(msg.value > 0, \"Must send ether\");\n        // ensure the same number of addresses and bps\n        require(addresses.length == basisPointSplits.length, \"Parallel arrays required\");\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n\n        //Share of purchase amount to send to treasury\n        uint256 toPayTreasury = (msgValueRemaining * (10_000 - creatorRateBps)) / 10_000;\n\n        //Share of purchase amount to reserve for creators\n        //Ether directly sent to creators\n        uint256 creatorDirectPayment = ((msgValueRemaining - toPayTreasury) * entropyRateBps) / 10_000;\n        //Tokens to emit to creators\n        int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n            ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n        // Tokens to emit to buyers\n        int totalTokensForBuyers = toPayTreasury > 0 ? getTokenQuoteForEther(toPayTreasury) : int(0);\n\n        //Transfer ETH to treasury and update emitted\n        emittedTokenWad += totalTokensForBuyers;\n        if (totalTokensForCreators > 0) emittedTokenWad += totalTokensForCreators;\n\n        //Deposit funds to treasury\n        (bool success, ) = treasury.call{ value: toPayTreasury }(new bytes(0));\n        require(success, \"Transfer failed.\");\n\n        //Transfer ETH to creators\n        if (creatorDirectPayment > 0) {\n            (success, ) = creatorsAddress.call{ value: creatorDirectPayment }(new bytes(0));\n            require(success, \"Transfer failed.\");\n        }\n\n        //Mint tokens for creators\n        if (totalTokensForCreators > 0 && creatorsAddress != address(0)) {\n            _mint(creatorsAddress, uint256(totalTokensForCreators));\n        }\n\n        uint256 bpsSum = 0;\n\n        //Mint tokens to buyers\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (totalTokensForBuyers > 0) {\n                // transfer tokens to address\n                _mint(addresses[i], uint256((totalTokensForBuyers * int(basisPointSplits[i])) / 10_000));\n            }\n            bpsSum += basisPointSplits[i];\n        }\n\n        require(bpsSum == 10_000, \"bps must add up to 10_000\");\n\n        emit PurchaseFinalized(\n            msg.sender,\n            msg.value,\n            toPayTreasury,\n            msg.value - msgValueRemaining,\n            uint256(totalTokensForBuyers),\n            uint256(totalTokensForCreators),\n            creatorDirectPayment\n        );\n\n        return uint256(totalTokensForBuyers);\n    }\n\n    /**\n     * @notice Returns the amount of wei that would be spent to buy an amount of tokens. Does not take into account the protocol rewards.\n     * @param amount the amount of tokens to buy.\n     * @return spentY The cost in wei of the token purchase.\n     */\n    function buyTokenQuote(uint256 amount) public view returns (int spentY) {\n        require(amount > 0, \"Amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.xToY({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(amount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for an amount of wei. Does not take into account the protocol rewards.\n     * @param etherAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForEther(uint256 etherAmount) public view returns (int gainedX) {\n        require(etherAmount > 0, \"Ether amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(etherAmount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for the payment amount, taking into account the protocol rewards.\n     * @param paymentAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForPayment(uint256 paymentAmount) external view returns (int gainedX) {\n        require(paymentAmount > 0, \"Payment amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(((paymentAmount - computeTotalReward(paymentAmount)) * (10_000 - creatorRateBps)) / 10_000)\n            });\n    }\n\n    /**\n     * @notice Set the split of (purchase * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        emit EntropyRateBpsUpdated(entropyRateBps = _entropyRateBps);\n    }\n\n    /**\n     * @notice Set the split of the payment that is reserved for creators in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n\n        emit CreatorRateBpsUpdated(creatorRateBps = _creatorRateBps);\n    }\n\n    /**\n     * @notice Set the creators address to pay the creatorRate to. Can be a contract.\n     * @dev Only callable by the owner.\n     */\n    function setCreatorsAddress(address _creatorsAddress) external override onlyOwner nonReentrant {\n        require(_creatorsAddress != address(0), \"Invalid address\");\n\n        emit CreatorsAddressUpdated(creatorsAddress = _creatorsAddress);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/ERC20TokenEmitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { TokenEmitterRewards } from \"@collectivexyz/protocol-rewards/src/abstract/TokenEmitter/TokenEmitterRewards.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport { VRGDAC } from \"./libs/VRGDAC.sol\";\nimport { toDaysWadUnsafe } from \"./libs/SignedWadMath.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { NontransferableERC20Votes } from \"./NontransferableERC20Votes.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract ERC20TokenEmitter is\n    IERC20TokenEmitter,\n    ReentrancyGuardUpgradeable,\n    TokenEmitterRewards,\n    Ownable2StepUpgradeable,\n    PausableUpgradeable\n{\n    // treasury address to pay funds to\n    address public treasury;\n\n    // The token that is being minted.\n    NontransferableERC20Votes public token;\n\n    // The VRGDA contract\n    VRGDAC public vrgdac;\n\n    // solhint-disable-next-line not-rely-on-time\n    uint256 public startTime;\n\n    /**\n     * @notice A running total of the amount of tokens emitted.\n     */\n    int256 public emittedTokenWad;\n\n    // The split of the purchase that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The split of (purchase proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The account or contract to pay the creator reward to\n    address public creatorsAddress;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _protocolRewards The protocol rewards contract address\n    /// @param _protocolFeeRecipient The protocol fee recipient address\n    constructor(\n        address _manager,\n        address _protocolRewards,\n        address _protocolFeeRecipient\n    ) payable TokenEmitterRewards(_protocolRewards, _protocolFeeRecipient) initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the token emitter\n     * @param _initialOwner The initial owner of the token emitter\n     * @param _erc20Token The ERC-20 token contract address\n     * @param _vrgdac The VRGDA contract address\n     * @param _treasury The treasury address to pay funds to\n     * @param _creatorsAddress The address to pay the creator reward to\n     */\n    function initialize(\n        address _initialOwner,\n        address _erc20Token,\n        address _treasury,\n        address _vrgdac,\n        address _creatorsAddress\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        require(_treasury != address(0), \"Invalid treasury address\");\n\n        // Set up ownable\n        __Ownable_init(_initialOwner);\n\n        treasury = _treasury;\n        creatorsAddress = _creatorsAddress;\n        vrgdac = VRGDAC(_vrgdac);\n        token = NontransferableERC20Votes(_erc20Token);\n        startTime = block.timestamp;\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        token.mint(_to, _amount);\n    }\n\n    function totalSupply() public view returns (uint) {\n        // returns total supply issued so far\n        return token.totalSupply();\n    }\n\n    function decimals() public view returns (uint8) {\n        // returns decimals\n        return token.decimals();\n    }\n\n    function balanceOf(address _owner) public view returns (uint) {\n        // returns balance of address\n        return token.balanceOf(_owner);\n    }\n\n    /**\n     * @notice Pause the contract.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the token emitter.\n     * @dev This function can only be called by the owner when the\n     * contract is paused.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice A payable function that allows a user to buy tokens for a list of addresses and a list of basis points to split the token purchase between.\n     * @param addresses The addresses to send purchased tokens to.\n     * @param basisPointSplits The basis points of the purchase to send to each address.\n     * @param protocolRewardsRecipients The addresses to pay the builder, purchaseRefferal, and deployer rewards to\n     * @return tokensSoldWad The amount of tokens sold in wad units.\n     */\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n        //prevent treasury from paying itself\n        require(msg.sender != treasury && msg.sender != creatorsAddress, \"Funds recipient cannot buy tokens\");\n\n        require(msg.value > 0, \"Must send ether\");\n        // ensure the same number of addresses and bps\n        require(addresses.length == basisPointSplits.length, \"Parallel arrays required\");\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n\n        //Share of purchase amount to send to treasury\n        uint256 toPayTreasury = (msgValueRemaining * (10_000 - creatorRateBps)) / 10_000;\n\n        //Share of purchase amount to reserve for creators\n        //Ether directly sent to creators\n        uint256 creatorDirectPayment = ((msgValueRemaining - toPayTreasury) * entropyRateBps) / 10_000;\n        //Tokens to emit to creators\n        int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n            ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n        // Tokens to emit to buyers\n        int totalTokensForBuyers = toPayTreasury > 0 ? getTokenQuoteForEther(toPayTreasury) : int(0);\n\n        //Transfer ETH to treasury and update emitted\n        emittedTokenWad += totalTokensForBuyers;\n        if (totalTokensForCreators > 0) emittedTokenWad += totalTokensForCreators;\n\n        //Deposit funds to treasury\n        (bool success, ) = treasury.call{ value: toPayTreasury }(new bytes(0));\n        require(success, \"Transfer failed.\");\n\n        //Transfer ETH to creators\n        if (creatorDirectPayment > 0) {\n            (success, ) = creatorsAddress.call{ value: creatorDirectPayment }(new bytes(0));\n            require(success, \"Transfer failed.\");\n        }\n\n        //Mint tokens for creators\n        if (totalTokensForCreators > 0 && creatorsAddress != address(0)) {\n            _mint(creatorsAddress, uint256(totalTokensForCreators));\n        }\n\n        uint256 bpsSum = 0;\n\n        //Mint tokens to buyers\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (totalTokensForBuyers > 0) {\n                // transfer tokens to address\n                _mint(addresses[i], uint256((totalTokensForBuyers * int(basisPointSplits[i])) / 10_000));\n            }\n            bpsSum += basisPointSplits[i];\n        }\n\n        require(bpsSum == 10_000, \"bps must add up to 10_000\");\n\n        emit PurchaseFinalized(\n            msg.sender,\n            msg.value,\n            toPayTreasury,\n            msg.value - msgValueRemaining,\n            uint256(totalTokensForBuyers),\n            uint256(totalTokensForCreators),\n            creatorDirectPayment\n        );\n\n        return uint256(totalTokensForBuyers);\n    }\n\n    /**\n     * @notice Returns the amount of wei that would be spent to buy an amount of tokens. Does not take into account the protocol rewards.\n     * @param amount the amount of tokens to buy.\n     * @return spentY The cost in wei of the token purchase.\n     */\n    function buyTokenQuote(uint256 amount) public view returns (int spentY) {\n        require(amount > 0, \"Amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.xToY({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(amount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for an amount of wei. Does not take into account the protocol rewards.\n     * @param etherAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForEther(uint256 etherAmount) public view returns (int gainedX) {\n        require(etherAmount > 0, \"Ether amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(etherAmount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for the payment amount, taking into account the protocol rewards.\n     * @param paymentAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForPayment(uint256 paymentAmount) external view returns (int gainedX) {\n        require(paymentAmount > 0, \"Payment amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(((paymentAmount - computeTotalReward(paymentAmount)) * (10_000 - creatorRateBps)) / 10_000)\n            });\n    }\n\n    /**\n     * @notice Set the split of (purchase * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        emit EntropyRateBpsUpdated(entropyRateBps = _entropyRateBps);\n    }\n\n    /**\n     * @notice Set the split of the payment that is reserved for creators in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n\n        emit CreatorRateBpsUpdated(creatorRateBps = _creatorRateBps);\n    }\n\n    /**\n     * @notice Set the creators address to pay the creatorRate to. Can be a contract.\n     * @dev Only callable by the owner.\n     */\n    function setCreatorsAddress(address _creatorsAddress) external override onlyOwner nonReentrant {\n        require(_creatorsAddress != address(0), \"Invalid address\");\n\n        emit CreatorsAddressUpdated(creatorsAddress = _creatorsAddress);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/ERC20TokenEmitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { TokenEmitterRewards } from \"@collectivexyz/protocol-rewards/src/abstract/TokenEmitter/TokenEmitterRewards.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport { VRGDAC } from \"./libs/VRGDAC.sol\";\nimport { toDaysWadUnsafe } from \"./libs/SignedWadMath.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { NontransferableERC20Votes } from \"./NontransferableERC20Votes.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract ERC20TokenEmitter is\n    IERC20TokenEmitter,\n    ReentrancyGuardUpgradeable,\n    TokenEmitterRewards,\n    Ownable2StepUpgradeable,\n    PausableUpgradeable\n{\n    // treasury address to pay funds to\n    address public treasury;\n\n    // The token that is being minted.\n    NontransferableERC20Votes public token;\n\n    // The VRGDA contract\n    VRGDAC public vrgdac;\n\n    // solhint-disable-next-line not-rely-on-time\n    uint256 public startTime;\n\n    /**\n     * @notice A running total of the amount of tokens emitted.\n     */\n    int256 public emittedTokenWad;\n\n    // The split of the purchase that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The split of (purchase proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The account or contract to pay the creator reward to\n    address public creatorsAddress;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _protocolRewards The protocol rewards contract address\n    /// @param _protocolFeeRecipient The protocol fee recipient address\n    constructor(\n        address _manager,\n        address _protocolRewards,\n        address _protocolFeeRecipient\n    ) payable TokenEmitterRewards(_protocolRewards, _protocolFeeRecipient) initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the token emitter\n     * @param _initialOwner The initial owner of the token emitter\n     * @param _erc20Token The ERC-20 token contract address\n     * @param _vrgdac The VRGDA contract address\n     * @param _treasury The treasury address to pay funds to\n     * @param _creatorsAddress The address to pay the creator reward to\n     */\n    function initialize(\n        address _initialOwner,\n        address _erc20Token,\n        address _treasury,\n        address _vrgdac,\n        address _creatorsAddress\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        require(_treasury != address(0), \"Invalid treasury address\");\n\n        // Set up ownable\n        __Ownable_init(_initialOwner);\n\n        treasury = _treasury;\n        creatorsAddress = _creatorsAddress;\n        vrgdac = VRGDAC(_vrgdac);\n        token = NontransferableERC20Votes(_erc20Token);\n        startTime = block.timestamp;\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        token.mint(_to, _amount);\n    }\n\n    function totalSupply() public view returns (uint) {\n        // returns total supply issued so far\n        return token.totalSupply();\n    }\n\n    function decimals() public view returns (uint8) {\n        // returns decimals\n        return token.decimals();\n    }\n\n    function balanceOf(address _owner) public view returns (uint) {\n        // returns balance of address\n        return token.balanceOf(_owner);\n    }\n\n    /**\n     * @notice Pause the contract.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the token emitter.\n     * @dev This function can only be called by the owner when the\n     * contract is paused.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice A payable function that allows a user to buy tokens for a list of addresses and a list of basis points to split the token purchase between.\n     * @param addresses The addresses to send purchased tokens to.\n     * @param basisPointSplits The basis points of the purchase to send to each address.\n     * @param protocolRewardsRecipients The addresses to pay the builder, purchaseRefferal, and deployer rewards to\n     * @return tokensSoldWad The amount of tokens sold in wad units.\n     */\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n        //prevent treasury from paying itself\n        require(msg.sender != treasury && msg.sender != creatorsAddress, \"Funds recipient cannot buy tokens\");\n\n        require(msg.value > 0, \"Must send ether\");\n        // ensure the same number of addresses and bps\n        require(addresses.length == basisPointSplits.length, \"Parallel arrays required\");\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n\n        //Share of purchase amount to send to treasury\n        uint256 toPayTreasury = (msgValueRemaining * (10_000 - creatorRateBps)) / 10_000;\n\n        //Share of purchase amount to reserve for creators\n        //Ether directly sent to creators\n        uint256 creatorDirectPayment = ((msgValueRemaining - toPayTreasury) * entropyRateBps) / 10_000;\n        //Tokens to emit to creators\n        int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n            ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n        // Tokens to emit to"
    }
  ]
}