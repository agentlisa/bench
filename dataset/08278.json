{
  "Title": "[Nâ€‘11]  Not using the named return variables anywhere in the function is confusing",
  "Content": "\nConsider changing the variable to be an unnamed one\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/actions/automated/MIMOAutoRebalance.sol\n\n/// @audit rebalanceAmount\n/// @audit mintAmount\n/// @audit autoFee\n142     function getAmounts(uint256 vaultId, address toCollateral)\n143       external\n144       view\n145       override\n146       returns (\n147         uint256 rebalanceAmount,\n148         uint256 mintAmount,\n149:        uint256 autoFee\n\n```\n\n<https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/automated/MIMOAutoRebalance.sol#L142-L149>\n\n**[m19 (Mimo) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/118#issuecomment-1219169496):**\n > This is an outstanding QA report.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-mimo",
  "Code": [
    {
      "filename": "contracts/actions/automated/MIMOAutoRebalance.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IMIMOAutoRebalance.sol\";\nimport \"../interfaces/IMIMORebalance.sol\";\nimport \"./MIMOAutoAction.sol\";\nimport \"../MIMOFlashloan.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\n/**\n  Rebalance value is calculated by the formula below :\n\n        targetRatio * (vaultDebt + fixedFee) - collateralValue\n      ----------------------------------------------------------\n          targetRatio / mcrB - 1 - targetRatio * variableFee \n */\n\n/// @title A `SuperVault V2` action contract for configuring a vault to be autorebalanced.\n/// @notice This allows anyone to rebalance the vault, as long as the rebalance meets the `autoRebalance` configuration.\ncontract MIMOAutoRebalance is MIMOAutoAction, MIMOFlashloan, IMIMOAutoRebalance {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  address public immutable mimoRebalance;\n\n  /**\n    @param _a The addressProvider for the MIMO protocol \n    @param _lendingPool The AAVE lending pool used for flashloans \n    @param _proxyRegistry The MIMOProxyRegistry used to verify access control \n    @param _mimoRebalance The MIMORebalance contract address that holds the logic for the rebalance call \n   */\n  constructor(\n    IAddressProvider _a,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry,\n    address _mimoRebalance\n  ) MIMOAutoAction(_a, _proxyRegistry) MIMOFlashloan(_lendingPool) {\n    if (_mimoRebalance == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    mimoRebalance = _mimoRebalance;\n  }\n\n  /**\n    @notice Perform a rebalance on a vault on behalf of vault owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Reverts if operation results in vault value change above allowed variation or in vault ratio lower than min ratio\n    @param vaultId Vault id of the vault to rebalance\n    @param swapData SwapData struct containing aggegator swap parameters\n   */\n  function rebalance(uint256 vaultId, IMIMOSwap.SwapData calldata swapData) external override {\n    AutomatedVault memory autoVault = _automatedVaults[vaultId];\n\n    (uint256 vaultARatioBefore, VaultState memory vaultAState) = _getVaultStats(vaultId);\n\n    _preRebalanceChecks(autoVault, vaultId, vaultARatioBefore);\n\n    IVaultsDataProvider vaultsData = a.vaultsData();\n    address vaultOwner = vaultsData.vaultOwner(vaultId);\n    uint256 vaultBId = vaultsData.vaultId(address(autoVault.toCollateral), vaultOwner);\n    uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n\n    (IMIMORebalance.RebalanceData memory rbData, FlashLoanData memory flData, uint256 autoFee) = _getRebalanceParams(\n      autoVault,\n      vaultAState,\n      IERC20(autoVault.toCollateral),\n      vaultId\n    );\n\n    _takeFlashLoan(flData, abi.encode(vaultOwner, autoFee, rbData, swapData));\n    _postRebalanceChecks(autoVault, flData.amount, vaultBBalanceBefore, vaultId, vaultOwner, vaultsData);\n\n    _operationTracker[vaultId] = block.timestamp;\n\n    IERC20(a.stablex()).safeTransfer(msg.sender, autoFee);\n  }\n\n  /**\n    @notice Routes a call from a flashloan pool to a leverage or rebalance operation\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the reblanced asset\n    @param amounts Uint array with one element corresponding to the amount of the rebalanced asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, RebalanceData struct and SwapData struct\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (\n      address mimoProxy,\n      uint256 managerFee,\n      IMIMORebalance.RebalanceData memory rbData,\n      IMIMOSwap.SwapData memory swapData\n    ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n    if (initiator != address(this)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 fromCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      mimoRebalance,\n      abi.encodeWithSignature(\n        \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n        fromCollateral,\n        amount,\n        flashloanRepayAmount,\n        managerFee,\n        rbData,\n        swapData\n      )\n    );\n\n    fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Getter function returning rebalance amounts for specific vault id\n    @param vaultId Vault id of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @return rebalanceAmount Amount to rebalance\n    @return mintAmount Amount to mint on vault B\n    @return autoFee Automation fee\n   */\n  function getAmounts(uint256 vaultId, address toCollateral)\n    external\n    view\n    override\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    (, VaultState memory vaultState) = _getVaultStats(vaultId);\n    return _getAmounts(_automatedVaults[vaultId], vaultState, toCollateral);\n  }\n\n  /**\n    @notice Helper function calculating the amount to rebalance from vault A and to mint from vault B with rebalnce formula\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultState VaultState struct og the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @return rebalanceAmount Amount to rebalance\n    @return mintAmount Amount to mint on vault b\n    @return autoFee Automation fee\n   */\n  function _getAmounts(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    address toCollateral\n  )\n    internal\n    view\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    IAddressProvider _a = a;\n\n    uint256 targetRatio = autoVault.targetRatio + 1e15; // add 0.1% to account for rounding\n    uint256 toVaultMcr = _a.config().collateralMinCollateralRatio(address(toCollateral));\n\n    // The rebalanceValue is the PAR value of the amount of collateral we need to rebalance\n    uint256 rebalanceValue = (targetRatio.wadMul(vaultState.vaultDebt + autoVault.fixedFee) -\n      vaultState.collateralValue).wadDiv(\n        (targetRatio.wadDiv(toVaultMcr + autoVault.mcrBuffer) - targetRatio.wadMul(autoVault.varFee) - WadRayMath.WAD)\n      );\n\n    autoFee = autoVault.fixedFee + rebalanceValue.wadMul(autoVault.varFee);\n    rebalanceAmount = _a.priceFeed().convertTo(vaultState.collateralType, rebalanceValue);\n    mintAmount = rebalanceValue.wadDiv(toVaultMcr + autoVault.mcrBuffer) - autoFee;\n  }\n\n  /**\n    @notice Helper function formatting FlashloanData and RebalanceData parameters\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultState VaultState struct of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @param vaultId Vault id of the vault to rebalance\n    @return rbData RebalanceData struct\n    @return flData FlashloanData struct\n    @return autoFee Automation fee\n   */\n  function _getRebalanceParams(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    IERC20 toCollateral,\n    uint256 vaultId\n  )\n    internal\n    view\n    returns (\n      IMIMORebalance.RebalanceData memory rbData,\n      FlashLoanData memory flData,\n      uint256 autoFee\n    )\n  {\n    (uint256 rebalanceAmount, uint256 mintAmount, uint256 _autoFee) = _getAmounts(\n      autoVault,\n      vaultState,\n      address(toCollateral)\n    );\n\n    autoFee = _autoFee;\n    rbData = IMIMORebalance.RebalanceData({ toCollateral: toCollateral, vaultId: vaultId, mintAmount: mintAmount });\n    flData = FlashLoanData({ asset: vaultState.collateralType, proxyAction: address(this), amount: rebalanceAmount });\n  }\n\n  /**\n    @notice Helper function performing pre rebalance operation sanity checks\n    @dev Checks that vault is automated, that maximum daily operation was not reached and that trigger ratio was reached\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultARatio Collateral to debt ratio of the vault to rebalance\n   */\n  function _preRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 vaultId,\n    uint256 vaultARatio\n  ) internal view {\n    if (!autoVault.isAutomated) {\n      revert CustomErrors.VAULT_NOT_AUTOMATED();\n    }\n    if (_operationTracker[vaultId] > block.timestamp - 1 days) {\n      revert CustomErrors.MAX_OPERATIONS_REACHED();\n    }\n    if (vaultARatio > autoVault.triggerRatio) {\n      revert CustomErrors.VAULT_TRIGGER_RATIO_NOT_REACHED(vaultARatio, autoVault.triggerRatio);\n    }\n  }\n\n  /**\n    @notice Helper function performing post rebalance operation sanity checks\n    @dev Checks that change in global vault value (vault A + B) is below allowedVaration and vault A ratio equal or above targetRatio\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param rebalanceAmount Rebalanced amount\n    @param vaultBBalanceBefore Collateral balance of the vault to be rebalanced to before the rebalance operation\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultOwner Rebalanced vault owner\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _postRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceAmount,\n    uint256 vaultBBalanceBefore,\n    uint256 vaultId,\n    address vaultOwner,\n    IVaultsDataProvider vaultsData\n  ) internal view {\n    IPriceFeed priceFeed = a.priceFeed();\n    address fromCollateral = vaultsData.vaultCollateralType(vaultId);\n    uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, rebalanceAmount);\n    uint256 vaultBId = vaultsData.vaultId(autoVault.toCollateral, vaultOwner);\n    uint256 vaultBBalanceAfter = vaultsData.vaultCollateralBalance(vaultBId);\n    uint256 swapResultValue = priceFeed.convertFrom(autoVault.toCollateral, vaultBBalanceAfter - vaultBBalanceBefore);\n\n    if (!_isVaultVariationAllowed(autoVault, rebalanceValue, swapResultValue)) {\n      revert CustomErrors.VAULT_VALUE_CHANGE_TOO_HIGH();\n    }\n\n    (uint256 vaultARatio, ) = _getVaultStats(vaultId);\n\n    if (vaultARatio < autoVault.targetRatio) {\n      revert CustomErrors.FINAL_VAULT_RATIO_TOO_LOW(autoVault.targetRatio, vaultARatio);\n    }\n  }\n}"
    }
  ]
}