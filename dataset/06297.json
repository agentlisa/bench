{
  "Title": "[G-09] Replace state variable reads and writes within loops with local variable reads and writes.",
  "Content": "When accessing state variables within loops, each read or write operation incurs additional gas costs due to the storage and memory access operations involved. These costs can accumulate quickly, particularly in loops with a large number of iterations.\n\n\n```solidity\nFile: /src/Well.sol\n101        for (uint256 i; i < _pumps.length; i++) {\n            _pumps[i].target = _getArgAddress(dataLoc);\n            dataLoc += PACKED_ADDRESS;\n            pumpDataLength = _getArgUint256(dataLoc);\n            dataLoc += ONE_WORD;\n            _pumps[i].data = _getArgBytes(dataLoc, pumpDataLength);\n            dataLoc += pumpDataLength;\n        }\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Well.sol#L101-L108  \n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/Well.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {ReentrancyGuardUpgradeable} from \"ozu/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC20Upgradeable, ERC20PermitUpgradeable} from \"ozu/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {IERC20, SafeERC20} from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\nimport {IWell, Call} from \"src/interfaces/IWell.sol\";\nimport {IWellErrors} from \"src/interfaces/IWellErrors.sol\";\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\nimport {LibBytes} from \"src/libraries/LibBytes.sol\";\nimport {ClonePlus} from \"src/utils/ClonePlus.sol\";\n\n/**\n * @title Well\n * @author Publius, Silo Chad, Brean\n * @dev A Well is a constant function AMM allowing the provisioning of liquidity\n * into a single pooled on-chain liquidity position.\n */\ncontract Well is ERC20PermitUpgradeable, IWell, IWellErrors, ReentrancyGuardUpgradeable, ClonePlus {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    uint256 constant ONE_WORD = 32;\n    uint256 constant PACKED_ADDRESS = 20;\n    uint256 constant ONE_WORD_PLUS_PACKED_ADDRESS = 52; // For gas efficiency purposes\n    bytes32 constant RESERVES_STORAGE_SLOT = bytes32(uint256(keccak256(\"reserves.storage.slot\")) - 1);\n\n    function init(string memory name, string memory symbol) public initializer {\n        __ERC20Permit_init(name);\n        __ERC20_init(name, symbol);\n\n        IERC20[] memory _tokens = tokens();\n        for (uint256 i; i < _tokens.length - 1; ++i) {\n            for (uint256 j = i + 1; j < _tokens.length; ++j) {\n                if (_tokens[i] == _tokens[j]) {\n                    revert DuplicateTokens(_tokens[i]);\n                }\n            }\n        }\n    }\n\n    //////////////////// WELL DEFINITION ////////////////////\n\n    /// This Well uses a dynamic immutable storage layout. Immutable storage is\n    /// used for gas-efficient reads during Well operation. The Well must be\n    /// created by cloning with a pre-encoded byte string containing immutable\n    /// data.\n    ///\n    /// Let n = number of tokens\n    ///     m = length of well function data (bytes)\n    ///\n    /// TYPE        NAME                       LOCATION (CONSTANT)\n    /// ==============================================================\n    /// address     aquifer()                  0        (LOC_AQUIFER_ADDR)\n    /// uint256     numberOfTokens()           20       (LOC_TOKENS_COUNT)\n    /// address     wellFunctionAddress()      52       (LOC_WELL_FUNCTION_ADDR)\n    /// uint256     wellFunctionDataLength()   72       (LOC_WELL_FUNCTION_DATA_LENGTH)\n    /// uint256     numberOfPumps()            104      (LOC_PUMPS_COUNT)\n    /// --------------------------------------------------------------\n    /// address     token0                     136      (LOC_VARIABLE)\n    /// ...\n    /// address     tokenN                     136 + (n-1) * 32\n    /// --------------------------------------------------------------\n    /// byte        wellFunctionData0          136 + n * 32\n    /// ...\n    /// byte        wellFunctionDataM          136 + n * 32 + m\n    /// --------------------------------------------------------------\n    /// address     pump1Address               136 + n * 32 + m\n    /// uint256     pump1DataLength            136 + n * 32 + m + 20\n    /// byte        pump1Data                  136 + n * 32 + m + 52\n    /// ...\n    /// ==============================================================\n\n    uint256 constant LOC_AQUIFER_ADDR = 0;\n    uint256 constant LOC_TOKENS_COUNT = LOC_AQUIFER_ADDR + PACKED_ADDRESS;\n    uint256 constant LOC_WELL_FUNCTION_ADDR = LOC_TOKENS_COUNT + ONE_WORD;\n    uint256 constant LOC_WELL_FUNCTION_DATA_LENGTH = LOC_WELL_FUNCTION_ADDR + PACKED_ADDRESS;\n    uint256 constant LOC_PUMPS_COUNT = LOC_WELL_FUNCTION_DATA_LENGTH + ONE_WORD;\n    uint256 constant LOC_VARIABLE = LOC_PUMPS_COUNT + ONE_WORD;\n\n    function tokens() public pure returns (IERC20[] memory ts) {\n        ts = _getArgIERC20Array(LOC_VARIABLE, numberOfTokens());\n    }\n\n    function wellFunction() public pure returns (Call memory _wellFunction) {\n        _wellFunction.target = wellFunctionAddress();\n        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD;\n        _wellFunction.data = _getArgBytes(dataLoc, wellFunctionDataLength());\n    }\n\n    function pumps() public pure returns (Call[] memory _pumps) {\n        if (numberOfPumps() == 0) return _pumps;\n\n        _pumps = new Call[](numberOfPumps());\n        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD + wellFunctionDataLength();\n\n        uint256 pumpDataLength;\n        for (uint256 i; i < _pumps.length; i++) {\n            _pumps[i].target = _getArgAddress(dataLoc);\n            dataLoc += PACKED_ADDRESS;\n            pumpDataLength = _getArgUint256(dataLoc);\n            dataLoc += ONE_WORD;\n            _pumps[i].data = _getArgBytes(dataLoc, pumpDataLength);\n            dataLoc += pumpDataLength;\n        }\n    }\n\n    /**\n     * @dev {wellData} is unused in this implementation.\n     */\n    function wellData() public pure returns (bytes memory) {}\n\n    function aquifer() public pure override returns (address) {\n        return _getArgAddress(LOC_AQUIFER_ADDR);\n    }\n\n    function well()\n        external\n        pure\n        returns (\n            IERC20[] memory _tokens,\n            Call memory _wellFunction,\n            Call[] memory _pumps,\n            bytes memory _wellData,\n            address _aquifer\n        )\n    {\n        _tokens = tokens();\n        _wellFunction = wellFunction();\n        _pumps = pumps();\n        _wellData = wellData();\n        _aquifer = aquifer();\n    }\n\n    //////////////////// WELL DEFINITION: HELPERS ////////////////////\n\n    /**\n     * @notice Returns the number of tokens that are tradable in this Well.\n     * @dev Length of the `tokens()` array.\n     */\n    function numberOfTokens() public pure returns (uint256) {\n        return _getArgUint256(LOC_TOKENS_COUNT);\n    }\n\n    /**\n     * @notice Returns the address of the Well Function.\n     */\n    function wellFunctionAddress() public pure returns (address) {\n        return _getArgAddress(LOC_WELL_FUNCTION_ADDR);\n    }\n\n    /**\n     * @notice Returns the length of the configurable `data` parameter passed during calls to the Well Function.\n     */\n    function wellFunctionDataLength() public pure returns (uint256) {\n        return _getArgUint256(LOC_WELL_FUNCTION_DATA_LENGTH);\n    }\n\n    /**\n     * @notice Returns the number of Pumps which this Well was initialized with.\n     */\n    function numberOfPumps() public pure returns (uint256) {\n        return _getArgUint256(LOC_PUMPS_COUNT);\n    }\n\n    /**\n     * @notice Returns address & data used to call the first Pump.\n     * @dev Provided as an optimization in the case where {numberOfPumps} returns 1.\n     */\n    function firstPump() public pure returns (Call memory _pump) {\n        uint256 dataLoc = LOC_VARIABLE + numberOfTokens() * ONE_WORD + wellFunctionDataLength();\n        _pump.target = _getArgAddress(dataLoc);\n        uint256 pumpDataLength = _getArgUint256(dataLoc + PACKED_ADDRESS);\n        _pump.data = _getArgBytes(dataLoc + ONE_WORD_PLUS_PACKED_ADDRESS, pumpDataLength);\n    }\n\n    //////////////////// SWAP: FROM ////////////////////\n\n    /**\n     * @dev MUST revert if a fee on transfer token is used. The requisite check\n     * is performed in {_setReserves}.\n     */\n    function swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 amountOut) {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    /**\n     * @dev Note that `amountOut` is the amount *transferred* by the Well; if a fee\n     * is charged on transfers of `toToken`, the amount received by `recipient`\n     * will be less than `amountOut`.\n     */\n    function swapFromFeeOnTransfer(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 amountOut) {\n        amountIn = _safeTransferFromFeeOnTransfer(fromToken, msg.sender, amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    function _swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient\n    ) internal returns (uint256 amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _updatePumps(_tokens.length);\n        (uint256 i, uint256 j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[i] += amountIn;\n        uint256 reserveJBefore = reserves[j];\n        reserves[j] = _calcReserve(wellFunction(), reserves, j, totalSupply());\n\n        // Note: The rounding approach of the Well function determines whether\n        // slippage from imprecision goes to the Well or to the User.\n        amountOut = reserveJBefore - reserves[j];\n        if (amountOut < minAmountOut) {\n            revert SlippageOut(amountOut, minAmountOut);\n        }\n\n        toToken.safeTransfer(recipient, amountOut);\n        emit Swap(fromToken, toToken, amountIn, amountOut, recipient);\n        _setReserves(_tokens, reserves);\n    }\n\n    /**\n     * @dev Assumes both tokens incur no fee on transfer.\n     */\n    function getSwapOut(IERC20 fromToken, IERC20 toToken, uint256 amountIn) external view returns (uint256 amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _getReserves(_tokens.length);\n        (uint256 i, uint256 j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[i] += amountIn;\n\n        // underflow is desired; Well Function SHOULD NOT increase reserves of both `i` and `j`\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n    }\n\n    //////////////////// SWAP: TO ////////////////////\n\n    /**\n     * @dev {swapTo} does not support fee on transfer tokens, and no corresponding\n     * \"swapToFeeOnTransfer\" function is provided as this would require either:\n     * (a) inclusion of the fee as a parameter with verification; or\n     * (b) iterative transfers which attempts to back-calculate the fee.\n     */\n    function swapTo(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 maxAmountIn,\n        uint256 amountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 amountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _updatePumps(_tokens.length);\n        (uint256 i, uint256 j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[j] -= amountOut;\n        uint256 reserveIBefore = reserves[i];\n        reserves[i] = _calcReserve(wellFunction(), reserves, i, totalSupply());\n\n        // Note: The rounding approach of the Well function determines whether\n        // slippage from imprecision goes to the Well or to the User.\n        amountIn = reserves[i] - reserveIBefore;\n\n        if (amountIn > maxAmountIn) {\n            revert SlippageIn(amountIn, maxAmountIn);\n        }\n\n        _swapTo(fromToken, toToken, amountIn, amountOut, recipient);\n        _setReserves(_tokens, reserves);\n    }\n\n    /**\n     * @dev Executes token transfers and emits Swap event. Used by {swapTo} to\n     * avoid stack too deep errors.\n     */\n    function _swapTo(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 amountIn,\n        uint256 amountOut,\n        address recipient\n    ) internal {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        toToken.safeTransfer(recipient, amountOut);\n        emit Swap(fromToken, toToken, amountIn, amountOut, recipient);\n    }\n\n    /**\n     * @dev Assumes both tokens incur no fee on transfer.\n     */\n    function getSwapIn(IERC20 fromToken, IERC20 toToken, uint256 amountOut) external view returns (uint256 amountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _getReserves(_tokens.length);\n        (uint256 i, uint256 j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[j] -= amountOut;\n\n        amountIn = _calcReserve(wellFunction(), reserves, i, totalSupply()) - reserves[i];\n    }\n\n    //////////////////// SHIFT ////////////////////\n\n    /**\n     * @dev When using Wells for a multi-step swap, gas costs can be reduced by\n     * \"shifting\" tokens from one Well to another rather than returning them to\n     * a router (like Pipeline).\n     *\n     * Example multi-hop swap: WETH -> DAI -> USDC\n     *\n     * 1. Using a router without {shift}:\n     *  WETH.transfer(sender=0xUSER, recipient=0xROUTER)                     [1]\n     *  Call the router, which performs:\n     *      Well1.swapFrom(fromToken=WETH, toToken=DAI, recipient=0xROUTER)\n     *          WETH.transfer(sender=0xROUTER, recipient=Well1)              [2]\n     *          DAI.transfer(sender=Well1, recipient=0xROUTER)               [3]\n     *      Well2.swapFrom(fromToken=DAI, toToken=USDC, recipient=0xROUTER)\n     *          DAI.transfer(sender=0xROUTER, recipient=Well2)               [4]\n     *          USDC.transfer(sender=Well2, recipient=0xROUTER)              [5]\n     *  USDC.transfer(sender=0xROUTER, recipient=0xUSER)                     [6]\n     *\n     *  Note: this could be optimized by configuring the router to deliver\n     *  tokens from the last swap directly to the user.\n     *\n     * 2. Using a router with {shift}:\n     *  WETH.transfer(sender=0xUSER, recipient=Well1)                        [1]\n     *  Call the router, which performs:\n     *      Well1.shift(tokenOut=DAI, recipient=Well2)\n     *          DAI.transfer(sender=Well1, recipient=Well2)                  [2]\n     *      Well2.shift(tokenOut=USDC, recipient=0xUSER)\n     *          USDC.transfer(sender=Well2, recipient=0xUSER)                [3]\n     */\n    function shift(\n        IERC20 tokenOut,\n        uint256 minAmountOut,\n        address recipient\n    ) external nonReentrant returns (uint256 amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = new uint256[](_tokens.length);\n\n        // Use the balances of the pool instead of the stored reserves.\n        // If there is a change in token balances relative to the currently\n        // stored reserves, the extra tokens can be shifted into `tokenOut`.\n        for (uint256 i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n        uint256 j = _getJ(_tokens, tokenOut);\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n\n        if (amountOut >= minAmountOut) {\n            tokenOut.safeTransfer(recipient, amountOut);\n            reserves[j] -= amountOut;\n            _setReserves(_tokens, reserves);\n            emit Shift(reserves, tokenOut, amountOut, recipient);\n        } else {\n            revert SlippageOut(amountOut, minAmountOut);\n        }\n    }\n\n    function getShiftOut(IERC20 tokenOut) external view returns (uint256 amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = new uint256[](_tokens.length);\n        for (uint256 i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n\n        uint256 j = _getJ(_tokens, tokenOut);\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n    }\n\n    //////////////////// ADD LIQUIDITY ////////////////////\n\n    function addLiquidity(\n        uint256[] memory tokenAmountsIn,\n        uint256 minLpAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 lpAmountOut) {\n        lpAmountOut = _addLiquidity(tokenAmountsIn, minLpAmountOut, recipient, false);\n    }\n\n    function addLiquidityFeeOnTransfer(\n        uint256[] memory tokenAmountsIn,\n        uint256 minLpAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 lpAmountOut) {\n        lpAmountOut = _addLiquidity(tokenAmountsIn, minLpAmountOut, recipient, true);\n    }\n\n    /**\n     * @dev Gas optimization: {IWell.AddLiquidity} is emitted even if `lpAmountOut` is 0.\n     */\n    function _addLiquidity(\n        uint256[] memory tokenAmountsIn,\n        uint256 minLpAmountOut,\n        address recipient,\n        bool feeOnTransfer\n    ) internal returns (uint256 lpAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _updatePumps(_tokens.length);\n\n        if (feeOnTransfer) {\n            for (uint256 i; i < _tokens.length; ++i) {\n                if (tokenAmountsIn[i] == 0) continue;\n                tokenAmountsIn[i] = _safeTransferFromFeeOnTransfer(_tokens[i], msg.sender, tokenAmountsIn[i]);\n                reserves[i] = reserves[i] + tokenAmountsIn[i];\n            }\n        } else {\n            for (uint256 i; i < _tokens.length; ++i) {\n                if (tokenAmountsIn[i] == 0) continue;\n                _tokens[i].safeTransferFrom(msg.sender, address(this), tokenAmountsIn[i]);\n                reserves[i] = reserves[i] + tokenAmountsIn[i];\n            }\n        }\n\n        lpAmountOut = _calcLpTokenSupply(wellFunction(), reserves) - totalSupply();\n        if (lpAmountOut < minLpAmountOut) {\n            revert SlippageOut(lpAmountOut, minLpAmountOut);\n        }\n\n        _mint(recipient, lpAmountOut);\n        _setReserves(_tokens, reserves);\n        emit AddLiquidity(tokenAmountsIn, lpAmountOut, recipient);\n    }\n\n    /**\n     * @dev Assumes that no tokens involved incur a fee on transfer.\n     */\n    function getAddLiquidityOut(uint256[] memory tokenAmountsIn) external view returns (uint256 lpAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _getReserves(_tokens.length);\n        for (uint256 i; i < _tokens.length; ++i) {\n            reserves[i] = reserves[i] + tokenAmountsIn[i];\n        }\n        lpAmountOut = _calcLpTokenSupply(wellFunction(), reserves) - totalSupply();\n    }\n\n    //////////////////// REMOVE LIQUIDITY: BALANCED ////////////////////\n\n    function removeLiquidity(\n        uint256 lpAmountIn,\n        uint256[] calldata minTokenAmountsOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256[] memory tokenAmountsOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _updatePumps(_tokens.length);\n        uint256 lpTokenSupply = totalSupply();\n\n        tokenAmountsOut = new uint256[](_tokens.length);\n        _burn(msg.sender, lpAmountIn);\n        tokenAmountsOut = _calcLPTokenUnderlying(wellFunction(), lpAmountIn, reserves, lpTokenSupply);\n        for (uint256 i; i < _tokens.length; ++i) {\n            if (tokenAmountsOut[i] < minTokenAmountsOut[i]) {\n                revert SlippageOut(tokenAmountsOut[i], minTokenAmountsOut[i]);\n            }\n            _tokens[i].safeTransfer(recipient, tokenAmountsOut[i]);\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidity(lpAmountIn, tokenAmountsOut, recipient);\n    }\n\n    function getRemoveLiquidityOut(uint256 lpAmountIn) external view returns (uint256[] memory tokenAmountsOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _getReserves(_tokens.length);\n        uint256 lpTokenSupply = totalSupply();\n\n        tokenAmountsOut = _calcLPTokenUnderlying(wellFunction(), lpAmountIn, reserves, lpTokenSupply);\n    }\n\n    //////////////////// REMOVE LIQUIDITY: ONE TOKEN ////////////////////\n\n    function removeLiquidityOneToken(\n        uint256 lpAmountIn,\n        IERC20 tokenOut,\n        uint256 minTokenAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 tokenAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _updatePumps(_tokens.length);\n        uint256 j = _getJ(_tokens, tokenOut);\n\n        tokenAmountOut = _getRemoveLiquidityOneTokenOut(lpAmountIn, j, reserves);\n        if (tokenAmountOut < minTokenAmountOut) {\n            revert SlippageOut(tokenAmountOut, minTokenAmountOut);\n        }\n\n        _burn(msg.sender, lpAmountIn);\n        tokenOut.safeTransfer(recipient, tokenAmountOut);\n\n        reserves[j] = reserves[j] - tokenAmountOut;\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidityOneToken(lpAmountIn, tokenOut, tokenAmountOut, recipient);\n    }\n\n    function getRemoveLiquidityOneTokenOut(\n        uint256 lpAmountIn,\n        IERC20 tokenOut\n    ) external view returns (uint256 tokenAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _getReserves(_tokens.length);\n        uint256 j = _getJ(_tokens, tokenOut);\n        tokenAmountOut = _getRemoveLiquidityOneTokenOut(lpAmountIn, j, reserves);\n    }\n\n    /**\n     * @dev Shared logic for removing a single token from liquidity.\n     * Calculates change in reserve `j` given a change in LP token supply.\n     *\n     * Note: `lpAmountIn` is the amount of LP the user is burning in exchange\n     * for some amount of token `j`.\n     */\n    function _getRemoveLiquidityOneTokenOut(\n        uint256 lpAmountIn,\n        uint256 j,\n        uint256[] memory reserves\n    ) private view returns (uint256 tokenAmountOut) {\n        uint256 newLpTokenSupply = totalSupply() - lpAmountIn;\n        uint256 newReserveJ = _calcReserve(wellFunction(), reserves, j, newLpTokenSupply);\n        tokenAmountOut = reserves[j] - newReserveJ;\n    }\n\n    //////////// REMOVE LIQUIDITY: IMBALANCED ////////////\n\n    function removeLiquidityImbalanced(\n        uint256 maxLpAmountIn,\n        uint256[] calldata tokenAmountsOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant expire(deadline) returns (uint256 lpAmountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _updatePumps(_tokens.length);\n\n        for (uint256 i; i < _tokens.length; ++i) {\n            _tokens[i].safeTransfer(recipient, tokenAmountsOut[i]);\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n\n        lpAmountIn = totalSupply() - _calcLpTokenSupply(wellFunction(), reserves);\n        if (lpAmountIn > maxLpAmountIn) {\n            revert SlippageIn(lpAmountIn, maxLpAmountIn);\n        }\n        _burn(msg.sender, lpAmountIn);\n\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidity(lpAmountIn, tokenAmountsOut, recipient);\n    }\n\n    function getRemoveLiquidityImbalancedIn(uint256[] calldata tokenAmountsOut)\n        external\n        view\n        returns (uint256 lpAmountIn)\n    {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _getReserves(_tokens.length);\n        for (uint256 i; i < _tokens.length; ++i) {\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n        lpAmountIn = totalSupply() - _calcLpTokenSupply(wellFunction(), reserves);\n    }\n\n    //////////////////// RESERVES ////////////////////\n\n    /**\n     * @dev Sync the reserves of the Well with its current balance of underlying tokens.\n     */\n    function sync() external nonReentrant {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = new uint256[](_tokens.length);\n        for (uint256 i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n        _setReserves(_tokens, reserves);\n        emit Sync(reserves);\n    }\n\n    /**\n     * @dev Transfer excess tokens held by the Well to `recipient`.\n     */\n    function skim(address recipient) external nonReentrant returns (uint256[] memory skimAmounts) {\n        IERC20[] memory _tokens = tokens();\n        uint256[] memory reserves = _getReserves(_tokens.length);\n        skimAmounts = new uint256[](_tokens.length);\n        for (uint256 i; i < _tokens.length; ++i) {\n            skimAmounts[i] = _tokens[i].balanceOf(address(this)) - reserves[i];\n            if (skimAmounts[i] > 0) {\n                _tokens[i].safeTransfer(recipient, skimAmounts[i]);\n            }\n        }\n    }\n\n    function getReserves() external view returns (uint256[] memory reserves) {\n        // Use the same error as `ReentrancyGuardUpgradeable` instead of using a custom error for consistency.\n        require(!_reentrancyGuardEntered(), \"ReentrancyGuard: reentrant call\");\n        reserves = _getReserves(numberOfTokens());\n    }\n\n    /**\n     * @dev Gets the Well's token reserves by reading from byte storage.\n     */\n    function _getReserves(uint256 _numberOfTokens) internal view returns (uint256[] memory reserves) {\n        reserves = LibBytes.readUint128(RESERVES_STORAGE_SLOT, _numberOfTokens);\n    }\n\n    /**\n     * @dev Checks that the balance of each ERC-20 token is >= the reserves and\n     * sets the Well's reserves of each token by writing to byte storage.\n     */\n    function _setReserves(IERC20[] memory _tokens, uint256[] memory reserves) internal {\n        for (uint256 i; i < reserves.length; ++i) {\n            if (reserves[i] > _tokens[i].balanceOf(address(this))) revert InvalidReserves();\n        }\n        LibBytes.storeUint128(RESERVES_STORAGE_SLOT, reserves);\n    }\n\n    //////////////////// INTERNAL: UPDATE PUMPS ////////////////////\n\n    /**\n     * @dev Fetches the current token reserves of the Well and updates the Pumps.\n     * Typically called before an operation that modifies the Well's reserves.\n     */\n    function _updatePumps(uint256 _numberOfTokens) internal returns (uint256[] memory reserves) {\n        reserves = _getReserves(_numberOfTokens);\n\n        if (numberOfPumps() == 0) {\n            return reserves;\n        }\n\n        // gas optimization: avoid looping if there is only one pump\n        if (numberOfPumps() == 1) {\n            Call memory _pump = firstPump();\n            // Don't revert if the update call fails.\n            try IPump(_pump.target).update(reserves, _pump.data) {}\n            catch {\n                // ignore reversion. If an external shutoff mechanism is added to a Pump, it could be called here.\n            }\n        } else {\n            Call[] memory _pumps = pumps();\n            for (uint256 i; i < _pumps.length; ++i) {\n                // Don't revert if the update call fails.\n                try IPump(_pumps[i].target).update(reserves, _pumps[i].data) {}\n                catch {\n                    // ignore reversion. If an external shutoff mechanism is added to a Pump, it could be called here.\n                }\n            }\n        }\n    }\n\n    //////////////////// INTERNAL: WELL FUNCTION INTERACTION ////////////////////\n\n    /**\n     * @dev Calculates the LP token supply given a list of `reserves` using the\n     * provided `_wellFunction`. Wraps {IWellFunction.calcLpTokenSupply}.\n     *\n     * The Well function is passed as a parameter to minimize gas in instances\n     * where it is called multiple times in one transaction.\n     */\n    function _calcLpTokenSupply(\n        Call memory _wellFunction,\n        uint256[] memory reserves\n    ) internal view returns (uint256 lpTokenSupply) {\n        lpTokenSupply = IWellFunction(_wellFunction.target).calcLpTokenSupply(reserves, _wellFunction.data);\n    }\n\n    /**\n     * @dev Calculates the `j`th reserve given a list of `reserves` and `lpTokenSupply`\n     * using the provided `_wellFunction`. Wraps {IWellFunction.calcReserve}.\n     *\n     * The Well function is passed as a parameter to minimize gas in instances\n     * where it is called multiple times in one transaction.\n     */\n    function _calcReserve(\n        Call memory _wellFunction,\n        uint256[] memory reserves,\n        uint256 j,\n        uint256 lpTokenSupply\n    ) internal view returns (uint256 reserve) {\n        reserve = IWellFunction(_wellFunction.target).calcReserve(reserves, j, lpTokenSupply, _wellFunction.data);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that underly a given amount of LP tokens\n     * Wraps {IWellFunction.calcLPTokenAmount}.\n     *\n     * Used to determine the how many tokens to send to a user when they remove LP.\n     *\n     * The Well function is passed as a parameter to minimize gas in instances\n     * where it is called multiple times in one transaction.\n     */\n    function _calcLPTokenUnderlying(\n        Call memory _wellFunction,\n        uint256 lpTokenAmount,\n        uint256[] memory reserves,\n        uint256 lpTokenSupply\n    ) internal view returns (uint256[] memory tokenAmounts) {\n        tokenAmounts = IWellFunction(_wellFunction.target).calcLPTokenUnderlying(\n            lpTokenAmount, reserves, lpTokenSupply, _wellFunction.data\n        );\n    }\n\n    //////////////////// INTERNAL: WELL TOKEN INDEXING ////////////////////\n\n    /**\n     * @dev Returns the indices of `iToken` and `jToken` in `_tokens`.\n     * Reverts if either token is not in `_tokens`.\n     */\n    function _getIJ(\n        IERC20[] memory _tokens,\n        IERC20 iToken,\n        IERC20 jToken\n    ) internal pure returns (uint256 i, uint256 j) {\n        bool foundI = false;\n        bool foundJ = false;\n\n        for (uint256 k; k < _tokens.length; ++k) {\n            if (iToken == _tokens[k]) {\n                i = k;\n                foundI = true;\n            } else if (jToken == _tokens[k]) {\n                j = k;\n                foundJ = true;\n            }\n        }\n\n        if (!foundI) revert InvalidTokens();\n        if (!foundJ) revert InvalidTokens();\n    }\n\n    /**\n     * @dev Returns the index of `jToken` in `_tokens`. Reverts if `jToken` is\n     * not in `_tokens`.\n     *\n     * If `_tokens` contains multiple instances of `jToken`, this will return\n     * the first one. A {Well} with duplicate tokens has been misconfigured.\n     */\n    function _getJ(IERC20[] memory _tokens, IERC20 jToken) internal pure returns (uint256 j) {\n        for (j; j < _tokens.length; ++j) {\n            if (jToken == _tokens[j]) {\n                return j;\n            }\n        }\n        revert InvalidTokens();\n    }\n\n    //////////////////// INTERNAL: TRANSFER HELPERS ////////////////////\n\n    /**\n     * @dev Calculates the change in token balance of the Well across a transfer.\n     * Used when a fee might be incurred during safeTransferFrom.\n     */\n    function _safeTransferFromFeeOnTransfer(\n        IERC20 token,\n        address from,\n        uint256 amount\n    ) internal returns (uint256 amountTransferred) {\n        uint256 balanceBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        amountTransferred = token.balanceOf(address(this)) - balanceBefore;\n    }\n\n    //////////////////// INTERNAL: EXPIRY ////////////////////\n\n    /**\n     * @dev Reverts if the deadline has passed.\n     */\n    modifier expire(uint256 deadline) {\n        if (block.timestamp > deadline) {\n            revert Expired();\n        }\n        _;\n    }\n}"
    }
  ]
}