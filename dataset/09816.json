{
  "Title": "[M-12] Private sale spoofing",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketPrivateSale.sol#L156\n\n\n# Vulnerability details\n\n## Impact\nSimilar to [spoofing in finance](https://en.wikipedia.org/wiki/Spoofing_(finance)), users can create private sales with correct signatures but then frontrun the buy with a transfer to a different wallet they control.\n\nNo funds are lost as this the NFT <> FETH exchange is atomic but it can be bad if third parties create a naive off-chain centralized NFT market based on this signature feature.\nIt's also frustrating for the users if they try to accept the private sale but their transaction fails.\n\n## Recommended Mitigation Steps\nThis is made possible because private sales do not keep the NFT in escrow.\nConsider escrowing the NFT also for private sales.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-foundation-contest",
  "Code": [
    {
      "filename": "contracts/mixins/NFTMarketPrivateSale.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./NFTMarketFees.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nerror NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();\nerror NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();\nerror NFTMarketPrivateSale_Sale_Expired();\nerror NFTMarketPrivateSale_Signature_Verification_Failed();\nerror NFTMarketPrivateSale_Too_Much_Value_Provided();\n\n/**\n * @title Allows owners to offer an NFT for sale to a specific collector.\n * @notice Private sales are authorized by the seller with an EIP-712 signature.\n * @dev Private sale offers must be accepted by the buyer before they expire, typically in 24 hours.\n */\nabstract contract NFTMarketPrivateSale is NFTMarketFees {\n  using AddressUpgradeable for address;\n\n  /// @dev This value was replaced with an immutable version.\n  bytes32 private __gap_was_DOMAIN_SEPARATOR;\n\n  /// @notice The domain used in EIP-712 signatures.\n  /// @dev It is not a constant so that the chainId can be determined dynamically.\n  /// If multiple classes use EIP-712 signatures in the future this can move to a shared file.\n  bytes32 private immutable DOMAIN_SEPARATOR;\n\n  /// @notice The hash of the private sale method signature used for EIP-712 signatures.\n  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =\n    keccak256(\"BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)\");\n  /// @notice The name used in the EIP-712 domain.\n  /// @dev If multiple classes use EIP-712 signatures in the future this can move to the shared constants file.\n  string private constant NAME = \"FNDNFTMarket\";\n\n  /**\n   * @notice Emitted when an NFT is sold in a private sale.\n   * @dev The total amount of this sale is `f8nFee` + `creatorFee` + `ownerRev`.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The ID of the NFT.\n   * @param seller The address of the seller.\n   * @param buyer The address of the buyer.\n   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\n   * @param ownerRev The amount of ETH that was sent to the owner for this sale.\n   */\n  event PrivateSaleFinalized(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address indexed seller,\n    address buyer,\n    uint256 f8nFee,\n    uint256 creatorFee,\n    uint256 ownerRev,\n    uint256 deadline\n  );\n\n  /**\n   * @notice Configures the contract to accept EIP-712 signatures.\n   * @param marketProxyAddress The address of the proxy contract which will be called when accepting a private sale.\n   */\n  constructor(address marketProxyAddress) {\n    if (!marketProxyAddress.isContract()) {\n      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();\n    }\n    uint256 chainId;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      chainId := chainid()\n    }\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n        keccak256(bytes(NAME)),\n        // Incrementing the version can be used to invalidate previously signed messages.\n        keccak256(bytes(\"1\")),\n        chainId,\n        marketProxyAddress\n      )\n    );\n  }\n\n  /**\n   * @notice Buy an NFT from a private sale.\n   * @dev The seller signs a message approving the sale and then the buyer calls this function\n   * with the `msg.value` equal to the agreed upon price.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The ID of the NFT.\n   * @param deadline The timestamp at which the offer to sell will expire.\n   * @param v The v value of the EIP-712 signature.\n   * @param r The r value of the EIP-712 signature.\n   * @param s The s value of the EIP-712 signature.\n   */\n  function buyFromPrivateSale(\n    IERC721 nftContract,\n    uint256 tokenId,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external payable {\n    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);\n  }\n\n  /**\n   * @notice Buy an NFT from a private sale.\n   * @dev The seller signs a message approving the sale and then the buyer calls this function\n   * with the `amount` equal to the agreed upon price.\n   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The ID of the NFT.\n   * @param amount The amount to buy for, if this is more than `msg.value` funds will be\n   * withdrawn from your FETH balance.\n   * @param deadline The timestamp at which the offer to sell will expire.\n   * @param v The v value of the EIP-712 signature.\n   * @param r The r value of the EIP-712 signature.\n   * @param s The s value of the EIP-712 signature.\n   */\n  function buyFromPrivateSaleFor(\n    IERC721 nftContract,\n    uint256 tokenId,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public payable nonReentrant {\n    if (deadline < block.timestamp) {\n      // The signed message from the seller has expired.\n      revert NFTMarketPrivateSale_Sale_Expired();\n    } else if (deadline > block.timestamp + 2 days) {\n      // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure\n      // that transactions do not fail due to a minor timezone error or similar during signing.\n\n      // This prevents malicious actors from requesting signatures that never expire.\n      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();\n    }\n\n    if (amount > msg.value) {\n      // Withdraw additional ETH required from their available FETH balance.\n\n      unchecked {\n        // The if above ensures delta will not underflow\n        uint256 delta = amount - msg.value;\n        feth.marketWithdrawFrom(msg.sender, delta);\n      }\n    } else if (amount < msg.value) {\n      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.\n      revert NFTMarketPrivateSale_Too_Much_Value_Provided();\n    }\n\n    // The seller must have the NFT in their wallet when this function is called,\n    // otherwise the signature verification below will fail.\n    address payable seller = payable(nftContract.ownerOf(tokenId));\n\n    // Scoping this block to avoid a stack too deep error\n    {\n      bytes32 digest = keccak256(\n        abi.encodePacked(\n          \"\\x19\\x01\",\n          DOMAIN_SEPARATOR,\n          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))\n        )\n      );\n\n      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.\n      if (ecrecover(digest, v, r, s) != seller) {\n        revert NFTMarketPrivateSale_Signature_Verification_Failed();\n      }\n    }\n\n    // This should revert if the seller has not given the market contract approval.\n    nftContract.transferFrom(seller, msg.sender, tokenId);\n\n    // Distribute revenue for this sale.\n    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(\n      address(nftContract),\n      tokenId,\n      seller,\n      amount\n    );\n\n    emit PrivateSaleFinalized(\n      address(nftContract),\n      tokenId,\n      seller,\n      msg.sender,\n      f8nFee,\n      creatorFee,\n      ownerRev,\n      deadline\n    );\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}"
    }
  ]
}