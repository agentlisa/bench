{
  "Title": "M-10: bids can be created against markets that doesn't exist",
  "Content": "# Issue M-10: bids can be created against markets that doesn't exist \n\nSource: https://github.com/sherlock-audit/2023-03-teller-judging/issues/323 \n\n## Found by \nimmeas, saidam017\n## Summary\nBids can be created against markets that does not yet exist. When this market is created, the bid can be accepted but neither defaulted/liquidated nor repaid.\n\n## Vulnerability Detail\nThere's no verification that the market actually exists when submitting a bid. Hence a user could submit a bid for a non existing market.\n\nFor it to not revert it must have 0% APY and the bid cannot be accepted until a market exists.\n\nHowever, when this market is created the bid can be accepted. Then the loan would be impossible to default/liquidate:\n\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/TellerV2.sol#L963\n```solidity\nFile: TellerV2.sol\n\n963:        if (bidDefaultDuration[_bidId] == 0) return false;\n```\nSince `bidDefaultDuration[_bidId]` will be `0`\n\nAny attempt to repay will revert due to division by 0:\n\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol#L116-L117\n```solidity\nFile: libraries/V2Calculations.sol\n\n116:            uint256 owedAmount = (maxCycleOwed * owedTime) /\n117:                _bid.terms.paymentCycle; \n``` \nSince `_bid.terms.paymentCycle` will also be `0` (and it will always end up in this branch since `PaymentType` will be `EMI (0)`).\n\nHence the loan can never be closed.\n\nPoC:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { UpgradeableBeacon } from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\nimport { TellerV2 } from \"../contracts/TellerV2.sol\";\nimport { CollateralManager } from \"../contracts/CollateralManager.sol\";\nimport { LenderCommitmentForwarder } from \"../contracts/LenderCommitmentForwarder.sol\";\nimport { CollateralEscrowV1 } from \"../contracts/escrow/CollateralEscrowV1.sol\";\nimport { MarketRegistry } from \"../contracts/MarketRegistry.sol\";\n\nimport { ReputationManagerMock } from \"../contracts/mock/ReputationManagerMock.sol\";\nimport { LenderManagerMock } from \"../contracts/mock/LenderManagerMock.sol\";\nimport { TellerASMock } from \"../contracts/mock/TellerASMock.sol\";\n\nimport {TestERC20Token} from \"./tokens/TestERC20Token.sol\";\n\nimport \"lib/forge-std/src/Test.sol\";\nimport \"lib/forge-std/src/StdAssertions.sol\";\n\ncontract LoansTest is Test {\n    MarketRegistry marketRegistry;\n    TellerV2 tellerV2;\n    \n    TestERC20Token principalToken;\n\n    address alice = address(0x1111);\n    address bob = address(0x2222);\n    address owner = address(0x3333);\n\n    function setUp() public {\n        tellerV2 = new TellerV2(address(0));\n\n        marketRegistry = new MarketRegistry();\n        TellerASMock tellerAs = new TellerASMock();\n        marketRegistry.initialize(tellerAs);\n\n        LenderCommitmentForwarder lenderCommitmentForwarder = \n            new LenderCommitmentForwarder(address(tellerV2),address(marketRegistry));\n        CollateralManager collateralManager = new CollateralManager();\n        collateralManager.initialize(address(new UpgradeableBeacon(address(new CollateralEscrowV1()))),\n            address(tellerV2));\n        address rm = address(new ReputationManagerMock());\n        address lm = address(new LenderManagerMock());\n        tellerV2.initialize(0, address(marketRegistry), rm, address(lenderCommitmentForwarder),\n            address(collateralManager), lm);\n\n        principalToken = new TestERC20Token(\"Principal Token\", \"PRIN\", 12e18, 18);\n    }\n\n    function testSubmitBidForNonExistingMarket() public {\n        uint256 amount = 12e18;\n        principalToken.transfer(bob,amount);\n\n        vm.prank(bob);\n        principalToken.approve(address(tellerV2),amount);\n\n        // alice places bid on non-existing market\n        vm.prank(alice);\n        uint256 bidId = tellerV2.submitBid(\n            address(principalToken),\n            1, // non-existing right now\n            amount,\n            360 days,\n            0, // any APY != 0 will cause revert on div by 0\n            \"\",\n            alice\n        );\n\n        // bid cannot be accepted before market\n        vm.expectRevert(); // div by 0\n        vm.prank(bob);\n        tellerV2.lenderAcceptBid(bidId);\n\n        vm.startPrank(owner);\n        uint256 marketId = marketRegistry.createMarket(\n            owner,\n            30 days,\n            30 days,\n            1 days,\n            0,\n            false,\n            false,\n            \"\"\n        );\n        marketRegistry.setMarketFeeRecipient(marketId, owner);\n        vm.stopPrank();\n\n        // lender takes bid\n        vm.prank(bob);\n        tellerV2.lenderAcceptBid(bidId);\n\n        // should be liquidatable now\n        vm.warp(32 days);\n\n        // loan cannot be defaulted/liquidated\n        assertFalse(tellerV2.isLoanDefaulted(bidId));\n        assertFalse(tellerV2.isLoanLiquidateable(bidId));\n\n        vm.startPrank(alice);\n        principalToken.approve(address(tellerV2),12e18);\n\n        // and loan cannot be repaid\n        vm.expectRevert(); // division by 0\n        tellerV2.repayLoanFull(bidId);\n        vm.stopPrank();\n    }\n}\n```\n\n## Impact\nThis will lock any collateral forever since there's no way to retrieve it. For this to happen accidentally a borrower would have to create a bid for a non existing market with 0% APY though.\n\nThis could also be used to lure lenders since the loan cannot be liquidated/defaulted. This might be difficult since the APY must be 0% for the bid to be created. Also, this will lock any collateral provided by the borrower forever.\n\nDue to these circumstances I'm categorizing this as medium.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/TellerV2.sol#L334-L411\n\n## Tool used\nManual Review\n\n## Recommendation\nWhen submitting a bid, verify that the market exists.\n\n\n\n## Discussion\n\n**ethereumdegen**\n\nA user creating a bid for a market that does not yet exist yet COULD exist in the future is potentially a concern.  For example an attacker could see that there are bids open for market 88, create markets until market 88 exists , and then fulfill those loans with whatever rules they want.   Our user interface on the front end will prevent bids from being created with an invalid market ID so in reality this should not be an issue but in solidity strictly yes this is a valid issue.   Thank you. \n\n**ethereumdegen**\n\nWe should make a function name isMarketOpen that verifies that 1) the marketId is less than the number of markets and 2) the market is not closed and we should use that in submitBid instead of !isMarketClosed \n\n**iamjakethehuman**\n\nEscalate for 10 USDC \nThe issue requires the borrower to intentionally send his assets to a non-existing market. This would be the same as mistakenly sending the assets to a wrong address. Issues requiring the user to use wrong input have historically been invalidated/ considered QA.\nFurthermore, it also requires the said market to have 0% APY which is unrealistic, as there is no incentive for such markets to exist.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC \n> The issue requires the borrower to intentionally send his assets to a non-existing market. This would be the same as mistakenly sending the assets to a wrong address. Issues requiring the user to use wrong input have historically been invalidated/ considered QA.\n> Furthermore, it also requires the said market to have 0% APY which is unrealistic, as there is no incentive for such markets to exist.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**said017**\n\nEscalate for 10 USDC\n\nThis is valid issue. \n\nThis scenario not only applied with borrower accidentally create to a non-existing market.  \n\nConsider this scenario, malicious borrower listen to `marketRegistry's` `createMarket()` market creation.\nThe `marketId` can easily be seen in mempool or can be predicted since it only increment of the previous `marketId`.\n\nThe attacker then front run the market creation and create malicious borrow offer trough TellerV2 's `submitBid()` and provide the soon to be created `marketId`. \n\n0% APY is part of malicious borrower input so it is realistic.\n\nThis is valid issue, caused by the relatively easy and likely setup, and also caused the following impact : \n\n1. Malicious borrower can create borrow offer in trusted and exclusive marketplace before it is created, make clueless lender that thought the marketplace is legit take the bid.\n\n2. And the more harmful impact is the borrow offer can't be liquidated nor defaulted since `bidDefaultDuration[_bidId]` will be 0 and checking if bid can be liquidated or defaulted always return false.\n\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is valid issue. \n> \n> This scenario not only applied with borrower accidentally create to a non-existing market.  \n> \n> Consider this scenario, malicious borrower listen to `marketRegistry's` `createMarket()` market creation.\n> The `marketId` can easily be seen in mempool or can be predicted since it only increment of the previous `marketId`.\n> \n> The attacker then front run the market creation and create malicious borrow offer trough TellerV2 's `submitBid()` and provide the soon to be created `marketId`. \n> \n> 0% APY is part of malicious borrower input so it is realistic.\n> \n> This is valid issue, caused by the relatively easy and likely setup, and also caused the following impact : \n> \n> 1. Malicious borrower can create borrow offer in trusted and exclusive marketplace before it is created, make clueless lender that thought the marketplace is legit take the bid.\n> \n> 2. And the more harmful impact is the borrow offer can't be liquidated nor defaulted since `bidDefaultDuration[_bidId]` will be 0 and checking if bid can be liquidated or defaulted always return false.\n> \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ethereumdegen**\n\nGithub PR: [Issue 323 - add check for is market open](https://github.com/teller-protocol/teller-protocol-v2/pull/88)\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nAccepting the second escalaiton\nBased on the above comments, This is a valid issue confirmed by the sponsor and the attack path in the 2nd escalation is possible and confirmed by the Sponsor too. \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Accepting the second escalaiton\n> Based on the above comments, This is a valid issue confirmed by the sponsor and the attack path in the 2nd escalation is possible and confirmed by the Sponsor too. \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.\n\n**IAm0x52**\n\nFix looks good. Creates and utilizes a new check called \"isMarketOpen\" which requires that specified market exists\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/62",
  "Code": [
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/TellerV2.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"./ProtocolFee.sol\";\nimport \"./TellerV2Storage.sol\";\nimport \"./TellerV2Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\n// Interfaces\nimport \"./interfaces/IMarketRegistry.sol\";\nimport \"./interfaces/IReputationManager.sol\";\nimport \"./interfaces/ITellerV2.sol\";\nimport { Collateral } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./libraries/NumbersLib.sol\";\nimport { BokkyPooBahsDateTimeLibrary as BPBDTL } from \"./libraries/DateTimeLib.sol\";\nimport { V2Calculations, PaymentCycleType } from \"./libraries/V2Calculations.sol\";\n\n/* Errors */\n/**\n * @notice This error is reverted when the action isn't allowed\n * @param bidId The id of the bid.\n * @param action The action string (i.e: 'repayLoan', 'cancelBid', 'etc)\n * @param message The message string to return to the user explaining why the tx was reverted\n */\nerror ActionNotAllowed(uint256 bidId, string action, string message);\n\n/**\n * @notice This error is reverted when repayment amount is less than the required minimum\n * @param bidId The id of the bid the borrower is attempting to repay.\n * @param payment The payment made by the borrower\n * @param minimumOwed The minimum owed value\n */\nerror PaymentNotMinimum(uint256 bidId, uint256 payment, uint256 minimumOwed);\n\ncontract TellerV2 is\n    ITellerV2,\n    OwnableUpgradeable,\n    ProtocolFee,\n    PausableUpgradeable,\n    TellerV2Storage,\n    TellerV2Context\n{\n    using Address for address;\n    using SafeERC20 for ERC20;\n    using NumbersLib for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /** Events */\n\n    /**\n     * @notice This event is emitted when a new bid is submitted.\n     * @param bidId The id of the bid submitted.\n     * @param borrower The address of the bid borrower.\n     * @param metadataURI URI for additional bid information as part of loan bid.\n     */\n    event SubmittedBid(\n        uint256 indexed bidId,\n        address indexed borrower,\n        address receiver,\n        bytes32 indexed metadataURI\n    );\n\n    /**\n     * @notice This event is emitted when a bid has been accepted by a lender.\n     * @param bidId The id of the bid accepted.\n     * @param lender The address of the accepted bid lender.\n     */\n    event AcceptedBid(uint256 indexed bidId, address indexed lender);\n\n    /**\n     * @notice This event is emitted when a previously submitted bid has been cancelled.\n     * @param bidId The id of the cancelled bid.\n     */\n    event CancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when market owner has cancelled a pending bid in their market.\n     * @param bidId The id of the bid funded.\n     *\n     * Note: The `CancelledBid` event will also be emitted.\n     */\n    event MarketOwnerCancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a payment is made towards an active loan.\n     * @param bidId The id of the bid/loan to which the payment was made.\n     */\n    event LoanRepayment(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanRepaid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanLiquidated(uint256 indexed bidId, address indexed liquidator);\n\n    /**\n     * @notice This event is emitted when a fee has been paid related to a bid.\n     * @param bidId The id of the bid.\n     * @param feeType The name of the fee being paid.\n     * @param amount The amount of the fee being paid.\n     */\n    event FeePaid(\n        uint256 indexed bidId,\n        string indexed feeType,\n        uint256 indexed amount\n    );\n\n    /** Modifiers */\n\n    /**\n     * @notice This modifier is used to check if the state of a bid is pending, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier pendingBid(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.PENDING) {\n            revert ActionNotAllowed(_bidId, _action, \"Bid must be pending\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to check if the state of a loan has been accepted, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier acceptedLoan(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.ACCEPTED) {\n            revert ActionNotAllowed(_bidId, _action, \"Loan must be accepted\");\n        }\n\n        _;\n    }\n\n    /** Constant Variables **/\n\n    uint8 public constant CURRENT_CODE_VERSION = 9;\n\n    uint32 public constant LIQUIDATION_DELAY = 86400; //ONE DAY IN SECONDS\n\n    /** Constructor **/\n\n    constructor(address trustedForwarder) TellerV2Context(trustedForwarder) {}\n\n    /** External Functions **/\n\n    /**\n     * @notice Initializes the proxy.\n     * @param _protocolFee The fee collected by the protocol for loan processing.\n     * @param _marketRegistry The address of the market registry contract for the protocol.\n     * @param _reputationManager The address of the reputation manager contract.\n     * @param _lenderCommitmentForwarder The address of the lender commitment forwarder contract.\n     * @param _collateralManager The address of the collateral manager contracts.\n     * @param _lenderManager The address of the lender manager contract for loans on the protocol.\n     */\n    function initialize(\n        uint16 _protocolFee,\n        address _marketRegistry,\n        address _reputationManager,\n        address _lenderCommitmentForwarder,\n        address _collateralManager,\n        address _lenderManager\n    ) external initializer {\n        __ProtocolFee_init(_protocolFee);\n\n        __Pausable_init();\n\n        require(\n            _lenderCommitmentForwarder.isContract(),\n            \"LenderCommitmentForwarder must be a contract\"\n        );\n        lenderCommitmentForwarder = _lenderCommitmentForwarder;\n\n        require(\n            _marketRegistry.isContract(),\n            \"MarketRegistry must be a contract\"\n        );\n        marketRegistry = IMarketRegistry(_marketRegistry);\n\n        require(\n            _reputationManager.isContract(),\n            \"ReputationManager must be a contract\"\n        );\n        reputationManager = IReputationManager(_reputationManager);\n\n        require(\n            _collateralManager.isContract(),\n            \"CollateralManager must be a contract\"\n        );\n        collateralManager = ICollateralManager(_collateralManager);\n\n        _setLenderManager(_lenderManager);\n    }\n\n    function setLenderManager(address _lenderManager)\n        external\n        reinitializer(8)\n        onlyOwner\n    {\n        _setLenderManager(_lenderManager);\n    }\n\n    function _setLenderManager(address _lenderManager)\n        internal\n        onlyInitializing\n    {\n        require(\n            _lenderManager.isContract(),\n            \"LenderManager must be a contract\"\n        );\n        lenderManager = ILenderManager(_lenderManager);\n    }\n\n    /**\n     * @notice Gets the metadataURI for a bidId.\n     * @param _bidId The id of the bid to return the metadataURI for\n     * @return metadataURI_ The metadataURI for the bid, as a string.\n     */\n    function getMetadataURI(uint256 _bidId)\n        public\n        view\n        returns (string memory metadataURI_)\n    {\n        // Check uri mapping first\n        metadataURI_ = uris[_bidId];\n        // If the URI is not present in the mapping\n        if (\n            keccak256(abi.encodePacked(metadataURI_)) ==\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 // hardcoded constant of keccak256('')\n        ) {\n            // Return deprecated bytes32 uri as a string\n            uint256 convertedURI = uint256(bids[_bidId]._metadataURI);\n            metadataURI_ = StringsUpgradeable.toHexString(convertedURI, 32);\n        }\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol to set a new reputation manager contract.\n     * @param _reputationManager The new contract address.\n     */\n    function setReputationManager(address _reputationManager) public onlyOwner {\n        reputationManager = IReputationManager(_reputationManager);\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan without Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan with Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     * @param _collateralInfo Additional information about the collateral asset.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver,\n        Collateral[] calldata _collateralInfo\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n\n        bool validation = collateralManager.commitCollateral(\n            bidId_,\n            _collateralInfo\n        );\n\n        require(\n            validation == true,\n            \"Collateral balance could not be validated\"\n        );\n    }\n\n    function _submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) internal virtual returns (uint256 bidId_) {\n        address sender = _msgSenderForMarket(_marketplaceId);\n\n        (bool isVerified, ) = marketRegistry.isVerifiedBorrower(\n            _marketplaceId,\n            sender\n        );\n\n        require(isVerified, \"Not verified borrower\");\n\n        require(\n            !marketRegistry.isMarketClosed(_marketplaceId),\n            \"Market is closed\"\n        );\n\n        // Set response bid ID.\n        bidId_ = bidId;\n\n        // Create and store our bid into the mapping\n        Bid storage bid = bids[bidId];\n        bid.borrower = sender;\n        bid.receiver = _receiver != address(0) ? _receiver : bid.borrower;\n        bid.marketplaceId = _marketplaceId;\n        bid.loanDetails.lendingToken = ERC20(_lendingToken);\n        bid.loanDetails.principal = _principal;\n        bid.loanDetails.loanDuration = _duration;\n        bid.loanDetails.timestamp = uint32(block.timestamp);\n\n        // Set payment cycle type based on market setting (custom or monthly)\n        (bid.terms.paymentCycle, bidPaymentCycleType[bidId]) = marketRegistry\n            .getPaymentCycle(_marketplaceId);\n\n        bid.terms.APR = _APR;\n\n        bidDefaultDuration[bidId] = marketRegistry.getPaymentDefaultDuration(\n            _marketplaceId\n        );\n\n        bidExpirationTime[bidId] = marketRegistry.getBidExpirationTime(\n            _marketplaceId\n        );\n\n        bid.paymentType = marketRegistry.getPaymentType(_marketplaceId);\n\n        bid.terms.paymentCycleAmount = V2Calculations\n            .calculatePaymentCycleAmount(\n                bid.paymentType,\n                bidPaymentCycleType[bidId],\n                _principal,\n                _duration,\n                bid.terms.paymentCycle,\n                _APR\n            );\n\n        uris[bidId] = _metadataURI;\n        bid.state = BidState.PENDING;\n\n        emit SubmittedBid(\n            bidId,\n            bid.borrower,\n            bid.receiver,\n            keccak256(abi.encodePacked(_metadataURI))\n        );\n\n        // Store bid inside borrower bids mapping\n        borrowerBids[bid.borrower].push(bidId);\n\n        // Increment bid id counter\n        bidId++;\n    }\n\n    /**\n     * @notice Function for a borrower to cancel their pending bid.\n     * @param _bidId The id of the bid to cancel.\n     */\n    function cancelBid(uint256 _bidId) external {\n        if (\n            _msgSenderForMarket(bids[_bidId].marketplaceId) !=\n            bids[_bidId].borrower\n        ) {\n            revert ActionNotAllowed({\n                bidId: _bidId,\n                action: \"cancelBid\",\n                message: \"Only the bid owner can cancel!\"\n            });\n        }\n        _cancelBid(_bidId);\n    }\n\n    /**\n     * @notice Function for a market owner to cancel a bid in the market.\n     * @param _bidId The id of the bid to cancel.\n     */\n    function marketOwnerCancelBid(uint256 _bidId) external {\n        if (\n            _msgSender() !=\n            marketRegistry.getMarketOwner(bids[_bidId].marketplaceId)\n        ) {\n            revert ActionNotAllowed({\n                bidId: _bidId,\n                action: \"marketOwnerCancelBid\",\n                message: \"Only the market owner can cancel!\"\n            });\n        }\n        _cancelBid(_bidId);\n        emit MarketOwnerCancelledBid(_bidId);\n    }\n\n    /**\n     * @notice Function for users to cancel a bid.\n     * @param _bidId The id of the bid to be cancelled.\n     */\n    function _cancelBid(uint256 _bidId)\n        internal\n        virtual\n        pendingBid(_bidId, \"cancelBid\")\n    {\n        // Set the bid state to CANCELLED\n        bids[_bidId].state = BidState.CANCELLED;\n\n        // Emit CancelledBid event\n        emit CancelledBid(_bidId);\n    }\n\n    /**\n     * @notice Function for a lender to accept a proposed loan bid.\n     * @param _bidId The id of the loan bid to accept.\n     */\n    function lenderAcceptBid(uint256 _bidId)\n        external\n        override\n        pendingBid(_bidId, \"lenderAcceptBid\")\n        whenNotPaused\n        returns (\n            uint256 amountToProtocol,\n            uint256 amountToMarketplace,\n            uint256 amountToBorrower\n        )\n    {\n        // Retrieve bid\n        Bid storage bid = bids[_bidId];\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n\n        (bool isVerified, ) = marketRegistry.isVerifiedLender(\n            bid.marketplaceId,\n            sender\n        );\n        require(isVerified, \"Not verified lender\");\n\n        require(\n            !marketRegistry.isMarketClosed(bid.marketplaceId),\n            \"Market is closed\"\n        );\n\n        require(!isLoanExpired(_bidId), \"Bid has expired\");\n\n        // Set timestamp\n        bid.loanDetails.acceptedTimestamp = uint32(block.timestamp);\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n\n        // Mark borrower's request as accepted\n        bid.state = BidState.ACCEPTED;\n\n        // Declare the bid acceptor as the lender of the bid\n        bid.lender = sender;\n\n        // Tell the collateral manager to deploy the escrow and pull funds from the borrower if applicable\n        collateralManager.deployAndDeposit(_bidId);\n\n        // Transfer funds to borrower from the lender\n        amountToProtocol = bid.loanDetails.principal.percent(protocolFee());\n        amountToMarketplace = bid.loanDetails.principal.percent(\n            marketRegistry.getMarketplaceFee(bid.marketplaceId)\n        );\n        amountToBorrower =\n            bid.loanDetails.principal -\n            amountToProtocol -\n            amountToMarketplace;\n        //transfer fee to protocol\n        bid.loanDetails.lendingToken.safeTransferFrom(\n            sender,\n            owner(),\n            amountToProtocol\n        );\n\n        //transfer fee to marketplace\n        bid.loanDetails.lendingToken.safeTransferFrom(\n            sender,\n            marketRegistry.getMarketFeeRecipient(bid.marketplaceId),\n            amountToMarketplace\n        );\n\n        //transfer funds to borrower\n        bid.loanDetails.lendingToken.safeTransferFrom(\n            sender,\n            bid.receiver,\n            amountToBorrower\n        );\n\n        // Record volume filled by lenders\n        lenderVolumeFilled[address(bid.loanDetails.lendingToken)][sender] += bid\n            .loanDetails\n            .principal;\n        totalVolumeFilled[address(bid.loanDetails.lendingToken)] += bid\n            .loanDetails\n            .principal;\n\n        // Add borrower's active bid\n        _borrowerBidsActive[bid.borrower].add(_bidId);\n\n        // Emit AcceptedBid\n        emit AcceptedBid(_bidId, sender);\n\n        emit FeePaid(_bidId, \"protocol\", amountToProtocol);\n        emit FeePaid(_bidId, \"marketplace\", amountToMarketplace);\n    }\n\n    function claimLoanNFT(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"claimLoanNFT\")\n        whenNotPaused\n    {\n        // Retrieve bid\n        Bid storage bid = bids[_bidId];\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n        require(sender == bid.lender, \"only lender can claim NFT\");\n        // mint an NFT with the lender manager\n        lenderManager.registerLoan(_bidId, sender);\n        // set lender address to the lender manager so we know to check the owner of the NFT for the true lender\n        bid.lender = address(lenderManager);\n    }\n\n    /**\n     * @notice Function for users to make the minimum amount due for an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanMinimum(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        (\n            uint256 owedPrincipal,\n            uint256 duePrincipal,\n            uint256 interest\n        ) = V2Calculations.calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                bidPaymentCycleType[_bidId]\n            );\n        _repayLoan(\n            _bidId,\n            Payment({ principal: duePrincipal, interest: interest }),\n            owedPrincipal + interest,\n            true\n        );\n    }\n\n    /**\n     * @notice Function for users to repay an active loan in full.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanFull(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                bidPaymentCycleType[_bidId]\n            );\n        _repayLoan(\n            _bidId,\n            Payment({ principal: owedPrincipal, interest: interest }),\n            owedPrincipal + interest,\n            true\n        );\n    }\n\n    // function that the borrower (ideally) sends to repay the loan\n    /**\n     * @notice Function for users to make a payment towards an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _amount The amount of the payment.\n     */\n    function repayLoan(uint256 _bidId, uint256 _amount)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        (\n            uint256 owedPrincipal,\n            uint256 duePrincipal,\n            uint256 interest\n        ) = V2Calculations.calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                bidPaymentCycleType[_bidId]\n            );\n        uint256 minimumOwed = duePrincipal + interest;\n\n        // If amount is less than minimumOwed, we revert\n        if (_amount < minimumOwed) {\n            revert PaymentNotMinimum(_bidId, _amount, minimumOwed);\n        }\n\n        _repayLoan(\n            _bidId,\n            Payment({ principal: _amount - interest, interest: interest }),\n            owedPrincipal + interest,\n            true\n        );\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol implement an emergency stop mechanism.\n     */\n    function pauseProtocol() public virtual onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol undo a previously implemented emergency stop.\n     */\n    function unpauseProtocol() public virtual onlyOwner whenPaused {\n        _unpause();\n    }\n\n    //TODO: add an incentive for liquidator\n    /**\n     * @notice Function for users to liquidate a defaulted loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function liquidateLoanFull(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        require(isLoanLiquidateable(_bidId), \"Loan must be liquidateable.\");\n\n        Bid storage bid = bids[_bidId];\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bid,\n                block.timestamp,\n                bidPaymentCycleType[_bidId]\n            );\n        _repayLoan(\n            _bidId,\n            Payment({ principal: owedPrincipal, interest: interest }),\n            owedPrincipal + interest,\n            false\n        );\n\n        bid.state = BidState.LIQUIDATED;\n\n        // If loan is backed by collateral, withdraw and send to the liquidator\n        address liquidator = _msgSenderForMarket(bid.marketplaceId);\n        collateralManager.liquidateCollateral(_bidId, liquidator);\n\n        emit LoanLiquidated(_bidId, liquidator);\n    }\n\n    /**\n     * @notice Internal function to make a loan payment.\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _payment The Payment struct with payments amounts towards principal and interest respectively.\n     * @param _owedAmount The total amount owed on the loan.\n     */\n    function _repayLoan(\n        uint256 _bidId,\n        Payment memory _payment,\n        uint256 _owedAmount,\n        bool _shouldWithdrawCollateral\n    ) internal virtual {\n        Bid storage bid = bids[_bidId];\n        uint256 paymentAmount = _payment.principal + _payment.interest;\n\n        RepMark mark = reputationManager.updateAccountReputation(\n            bid.borrower,\n            _bidId\n        );\n\n        // Check if we are sending a payment or amount remaining\n        if (paymentAmount >= _owedAmount) {\n            paymentAmount = _owedAmount;\n            bid.state = BidState.PAID;\n\n            // Remove borrower's active bid\n            _borrowerBidsActive[bid.borrower].remove(_bidId);\n\n            // If loan is is being liquidated and backed by collateral, withdraw and send to borrower\n            if (_shouldWithdrawCollateral) {\n                collateralManager.withdraw(_bidId);\n            }\n\n            emit LoanRepaid(_bidId);\n        } else {\n            emit LoanRepayment(_bidId);\n        }\n\n        address lender = getLoanLender(_bidId);\n\n        // Send payment to the lender\n        bid.loanDetails.lendingToken.safeTransferFrom(\n            _msgSenderForMarket(bid.marketplaceId),\n            lender,\n            paymentAmount\n        );\n\n        // update our mappings\n        bid.loanDetails.totalRepaid.principal += _payment.principal;\n        bid.loanDetails.totalRepaid.interest += _payment.interest;\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n\n        // If the loan is paid in full and has a mark, we should update the current reputation\n        if (mark != RepMark.Good) {\n            reputationManager.updateAccountReputation(bid.borrower, _bidId);\n        }\n    }\n\n    /**\n     * @notice Calculates the total amount owed for a bid.\n     * @param _bidId The id of the loan bid to calculate the owed amount for.\n     */\n    function calculateAmountOwed(uint256 _bidId)\n        public\n        view\n        returns (Payment memory owed)\n    {\n        if (bids[_bidId].state != BidState.ACCEPTED) return owed;\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                bidPaymentCycleType[_bidId]\n            );\n        owed.principal = owedPrincipal;\n        owed.interest = interest;\n    }\n\n    /**\n     * @notice Calculates the total amount owed for a loan bid at a specific timestamp.\n     * @param _bidId The id of the loan bid to calculate the owed amount for.\n     * @param _timestamp The timestamp at which to calculate the loan owed amount at.\n     */\n    function calculateAmountOwed(uint256 _bidId, uint256 _timestamp)\n        public\n        view\n        returns (Payment memory owed)\n    {\n        Bid storage bid = bids[_bidId];\n        if (\n            bid.state != BidState.ACCEPTED ||\n            bid.loanDetails.acceptedTimestamp >= _timestamp\n        ) return owed;\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(bid, _timestamp, bidPaymentCycleType[_bidId]);\n        owed.principal = owedPrincipal;\n        owed.interest = interest;\n    }\n\n    /**\n     * @notice Calculates the minimum payment amount due for a loan.\n     * @param _bidId The id of the loan bid to get the payment amount for.\n     */\n    function calculateAmountDue(uint256 _bidId)\n        public\n        view\n        returns (Payment memory due)\n    {\n        if (bids[_bidId].state != BidState.ACCEPTED) return due;\n\n        (, uint256 duePrincipal, uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                bidPaymentCycleType[_bidId]\n            );\n        due.principal = duePrincipal;\n        due.interest = interest;\n    }\n\n    /**\n     * @notice Calculates the minimum payment amount due for a loan at a specific timestamp.\n     * @param _bidId The id of the loan bid to get the payment amount for.\n     * @param _timestamp The timestamp at which to get the due payment at.\n     */\n    function calculateAmountDue(uint256 _bidId, uint256 _timestamp)\n        public\n        view\n        returns (Payment memory due)\n    {\n        Bid storage bid = bids[_bidId];\n        if (\n            bids[_bidId].state != BidState.ACCEPTED ||\n            bid.loanDetails.acceptedTimestamp >= _timestamp\n        ) return due;\n\n        (, uint256 duePrincipal, uint256 interest) = V2Calculations\n            .calculateAmountOwed(bid, _timestamp, bidPaymentCycleType[_bidId]);\n        due.principal = duePrincipal;\n        due.interest = interest;\n    }\n\n    /**\n     * @notice Returns the next due date for a loan payment.\n     * @param _bidId The id of the loan bid.\n     */\n    function calculateNextDueDate(uint256 _bidId)\n        public\n        view\n        returns (uint32 dueDate_)\n    {\n        Bid storage bid = bids[_bidId];\n        if (bids[_bidId].state != BidState.ACCEPTED) return dueDate_;\n\n        uint32 lastRepaidTimestamp = lastRepaidTimestamp(_bidId);\n\n        // Calculate due date if payment cycle is set to monthly\n        if (bidPaymentCycleType[_bidId] == PaymentCycleType.Monthly) {\n            // Calculate the cycle number the last repayment was made\n            uint256 lastPaymentCycle = BPBDTL.diffMonths(\n                bid.loanDetails.acceptedTimestamp,\n                lastRepaidTimestamp\n            );\n            if (\n                BPBDTL.getDay(lastRepaidTimestamp) >\n                BPBDTL.getDay(bid.loanDetails.acceptedTimestamp)\n            ) {\n                lastPaymentCycle += 2;\n            } else {\n                lastPaymentCycle += 1;\n            }\n\n            dueDate_ = uint32(\n                BPBDTL.addMonths(\n                    bid.loanDetails.acceptedTimestamp,\n                    lastPaymentCycle\n                )\n            );\n        } else if (bidPaymentCycleType[_bidId] == PaymentCycleType.Seconds) {\n            // Start with the original due date being 1 payment cycle since bid was accepted\n            dueDate_ =\n                bid.loanDetails.acceptedTimestamp +\n                bid.terms.paymentCycle;\n            // Calculate the cycle number the last repayment was made\n            uint32 delta = lastRepaidTimestamp -\n                bid.loanDetails.acceptedTimestamp;\n            if (delta > 0) {\n                uint32 repaymentCycle = uint32(\n                    Math.ceilDiv(delta, bid.terms.paymentCycle)\n                );\n                dueDate_ += (repaymentCycle * bid.terms.paymentCycle);\n            }\n        }\n\n        uint32 endOfLoan = bid.loanDetails.acceptedTimestamp +\n            bid.loanDetails.loanDuration;\n        //if we are in the last payment cycle, the next due date is the end of loan duration\n        if (dueDate_ > endOfLoan) {\n            dueDate_ = endOfLoan;\n        }\n    }\n\n    /**\n     * @notice Checks to see if a borrower is delinquent.\n     * @param _bidId The id of the loan bid to check for.\n     */\n    function isPaymentLate(uint256 _bidId) public view override returns (bool) {\n        if (bids[_bidId].state != BidState.ACCEPTED) return false;\n        return uint32(block.timestamp) > calculateNextDueDate(_bidId);\n    }\n\n    /**\n     * @notice Checks to see if a borrower is delinquent.\n     * @param _bidId The id of the loan bid to check for.\n     * @return bool True if the loan is defaulted.\n     */\n    function isLoanDefaulted(uint256 _bidId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _canLiquidateLoan(_bidId, 0);\n    }\n\n    /**\n     * @notice Checks to see if a loan was delinquent for longer than liquidation delay.\n     * @param _bidId The id of the loan bid to check for.\n     * @return bool True if the loan is liquidateable.\n     */\n    function isLoanLiquidateable(uint256 _bidId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _canLiquidateLoan(_bidId, LIQUIDATION_DELAY);\n    }\n\n    /**\n     * @notice Checks to see if a borrower is delinquent.\n     * @param _bidId The id of the loan bid to check for.\n     * @param _liquidationDelay Amount of additional seconds after a loan defaulted to allow a liquidation.\n     * @return bool True if the loan is liquidateable.\n     */\n    function _canLiquidateLoan(uint256 _bidId, uint32 _liquidationDelay)\n        internal\n        view\n        returns (bool)\n    {\n        Bid storage bid = bids[_bidId];\n\n        // Make sure loan cannot be liquidated if it is not active\n        if (bid.state != BidState.ACCEPTED) return false;\n\n        if (bidDefaultDuration[_bidId] == 0) return false;\n\n        return (uint32(block.timestamp) -\n            _liquidationDelay -\n            lastRepaidTimestamp(_bidId) >\n            bidDefaultDuration[_bidId]);\n    }\n\n    function getBidState(uint256 _bidId)\n        external\n        view\n        override\n        returns (BidState)\n    {\n        return bids[_bidId].state;\n    }\n\n    function getBorrowerActiveLoanIds(address _borrower)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _borrowerBidsActive[_borr"
    }
  ]
}