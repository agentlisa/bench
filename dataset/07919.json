{
  "Title": "[N-02] Missing Zero-address Validation",
  "Content": "\n### Context\n[`AlgebraPoolFactory.sol#L77`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraFactory.sol#L77), [`AlgebraPoolFactory.sol#L84`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraFactory.sol#L84), [`AlgebraPoolFactory.sol#L91`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraFactory.sol#L91), [`AlgebraPool.sol#L959`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraPool.sol#L959), [`DataStorageOperator.sol#L31`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/DataStorageOperator.sol#L31), [`PoolImmutables.sol#L29`](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/base/PoolImmutables.sol#L29)\n\n### Description\nLack of zero-address validation on address parameters may lead to transaction reverts, waste gas, require resubmission of transactions and may even force contract redeployments in certain cases within the protocol.\n\n### Recommendation\nConsider adding explicit zero-address validation on input parameters of address type.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-09-quickswap",
  "Code": [
    {
      "filename": "src/core/contracts/AlgebraFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraPoolDeployer.sol';\nimport './interfaces/IDataStorageOperator.sol';\nimport './libraries/AdaptiveFee.sol';\nimport './DataStorageOperator.sol';\n\n/**\n * @title Algebra factory\n * @notice Is used to deploy pools and its dataStorages\n */\ncontract AlgebraFactory is IAlgebraFactory {\n  /// @inheritdoc IAlgebraFactory\n  address public override owner;\n\n  /// @inheritdoc IAlgebraFactory\n  address public immutable override poolDeployer;\n\n  /// @inheritdoc IAlgebraFactory\n  address public override farmingAddress;\n\n  /// @inheritdoc IAlgebraFactory\n  address public override vaultAddress;\n\n  // values of constants for sigmoids in fee calculation formula\n  AdaptiveFee.Configuration public baseFeeConfiguration =\n    AdaptiveFee.Configuration(\n      3000 - Constants.BASE_FEE, // alpha1\n      15000 - 3000, // alpha2\n      360, // beta1\n      60000, // beta2\n      59, // gamma1\n      8500, // gamma2\n      0, // volumeBeta\n      10, // volumeGamma\n      Constants.BASE_FEE // baseFee\n    );\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  mapping(address => mapping(address => address)) public override poolByPair;\n\n  constructor(address _poolDeployer, address _vaultAddress) {\n    owner = msg.sender;\n    emit Owner(msg.sender);\n\n    poolDeployer = _poolDeployer;\n    vaultAddress = _vaultAddress;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function createPool(address tokenA, address tokenB) external override returns (address pool) {\n    require(tokenA != tokenB);\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0));\n    require(poolByPair[token0][token1] == address(0));\n\n    IDataStorageOperator dataStorage = new DataStorageOperator(computeAddress(token0, token1));\n\n    dataStorage.changeFeeConfiguration(baseFeeConfiguration);\n\n    pool = IAlgebraPoolDeployer(poolDeployer).deploy(address(dataStorage), address(this), token0, token1);\n\n    poolByPair[token0][token1] = pool; // to avoid future addresses comparing we are populating the mapping twice\n    poolByPair[token1][token0] = pool;\n    emit Pool(token0, token1, pool);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setOwner(address _owner) external override onlyOwner {\n    require(owner != _owner);\n    emit Owner(_owner);\n    owner = _owner;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setFarmingAddress(address _farmingAddress) external override onlyOwner {\n    require(farmingAddress != _farmingAddress);\n    emit FarmingAddress(_farmingAddress);\n    farmingAddress = _farmingAddress;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setVaultAddress(address _vaultAddress) external override onlyOwner {\n    require(vaultAddress != _vaultAddress);\n    emit VaultAddress(_vaultAddress);\n    vaultAddress = _vaultAddress;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setBaseFeeConfiguration(\n    uint16 alpha1,\n    uint16 alpha2,\n    uint32 beta1,\n    uint32 beta2,\n    uint16 gamma1,\n    uint16 gamma2,\n    uint32 volumeBeta,\n    uint16 volumeGamma,\n    uint16 baseFee\n  ) external override onlyOwner {\n    require(uint256(alpha1) + uint256(alpha2) + uint256(baseFee) <= type(uint16).max, 'Max fee exceeded');\n    require(gamma1 != 0 && gamma2 != 0 && volumeGamma != 0, 'Gammas must be > 0');\n\n    baseFeeConfiguration = AdaptiveFee.Configuration(alpha1, alpha2, beta1, beta2, gamma1, gamma2, volumeBeta, volumeGamma, baseFee);\n    emit FeeConfiguration(alpha1, alpha2, beta1, beta2, gamma1, gamma2, volumeBeta, volumeGamma, baseFee);\n  }\n\n  bytes32 internal constant POOL_INIT_CODE_HASH = 0x6ec6c9c8091d160c0aa74b2b14ba9c1717e95093bd3ac085cee99a49aab294a4;\n\n  /// @notice Deterministically computes the pool address given the factory and PoolKey\n  /// @param token0 first token\n  /// @param token1 second token\n  /// @return pool The contract address of the Algebra pool\n  function computeAddress(address token0, address token1) internal view returns (address pool) {\n    pool = address(uint256(keccak256(abi.encodePacked(hex'ff', poolDeployer, keccak256(abi.encode(token0, token1)), POOL_INIT_CODE_HASH))));\n  }\n}"
    }
  ]
}