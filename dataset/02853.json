{
  "Title": "H-14: `LiquidationAccountant.claim()` can be called by anyone causing vault insolvency",
  "Content": "# Issue H-14: `LiquidationAccountant.claim()` can be called by anyone causing vault insolvency \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/188 \n\n## Found by \nobront, TurnipBoy, 0xRajeev, rvierdiiev\n\n## Summary\n\n`LiquidationAccountant.claim()` can be called by anyone to reduce the implied value of a public vault.\n\n## Vulnerability Detail\n\n`LiquidationAccountant.claim()` is called by the `PublicVault` as part of the `processEpoch()` flow. But it has no access control and can be called by anyone and any number of times. If called after `finalAuctionEnd`, one will be able to trigger `decreaseYIntercept()` on the vault even if they cannot affect fund transfer to withdrawing liquidity providers and the PublicVault.\n\n## Impact\n\nThis allows anyone to manipulate the `yIntercept` of a public vault by triggering the `claim()` flow after liquidations resulting in vault insolvency.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L65-L97\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow only vault to call `claim()` by requiring authorizations.\n\n## Discussion\n\n**SantiagoGregory**\n\nOur updated LiquidationAccountant implementation (now moved to WithdrawProxy) tracks a hasClaimed bool to make sure claim() is only called once (we also now block claim() from being called until after finalAuctionEnd).\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nAbuse can cause vault to implode and cause loss of funds to all depositors. Should be high\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Abuse can cause vault to implode and cause loss of funds to all depositors. Should be high\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\n\nEscalation accepted.\n\n\n\n**sherlock-admin**\n\n> \n> Escalation accepted.\n> \n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/LiquidationAccountant.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\n\nimport {ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {PublicVault} from \"./PublicVault.sol\";\nimport {WithdrawProxy} from \"./WithdrawProxy.sol\";\n\nabstract contract LiquidationBase is Clone {\n  function underlying() public pure returns (address) {\n    return _getArgAddress(0);\n  }\n\n  function ROUTER() public pure returns (address) {\n    return _getArgAddress(20);\n  }\n\n  function VAULT() public pure returns (address) {\n    return _getArgAddress(40);\n  }\n\n  function LIEN_TOKEN() public pure returns (address) {\n    return _getArgAddress(60);\n  }\n\n  function WITHDRAW_PROXY() public pure returns (address) {\n    return _getArgAddress(80);\n  }\n}\n\n/**\n * @title LiquidationAccountant\n * @author santiagogregory\n * @notice This contract collects funds from liquidations that overlap with an epoch boundary where liquidity providers are exiting.\n * When the final auction being tracked by a LiquidationAccountant for a given epoch is completed,\n * claim() proportionally pays out auction funds to withdrawing liquidity providers and the PublicVault.\n */\ncontract LiquidationAccountant is LiquidationBase {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  uint256 withdrawRatio;\n\n  uint256 expected; // Expected value of auctioned NFTs. yIntercept (virtual assets) of a PublicVault are not modified on liquidation, only once an auction is completed.\n  uint256 finalAuctionEnd; // when this is deleted, we know the final auction is over\n\n  /**\n   * @notice Proportionally sends funds collected from auctions to withdrawing liquidity providers and the PublicVault for this LiquidationAccountant.\n   */\n  function claim() public {\n    require(\n      block.timestamp > finalAuctionEnd || finalAuctionEnd == uint256(0),\n      \"final auction has not ended\"\n    );\n\n    uint256 balance = ERC20(underlying()).balanceOf(address(this));\n    // would happen if there was no WithdrawProxy for current epoch\n    if (withdrawRatio == uint256(0)) {\n      ERC20(underlying()).safeTransfer(VAULT(), balance);\n    } else {\n      //should be wad multiplication\n      // declining\n      uint256 transferAmount = withdrawRatio.mulDivDown(balance, 1e18);\n\n      if (transferAmount > uint256(0)) {\n        ERC20(underlying()).safeTransfer(WITHDRAW_PROXY(), transferAmount);\n      }\n\n      unchecked {\n        balance -= transferAmount;\n      }\n\n      ERC20(underlying()).safeTransfer(VAULT(), balance);\n    }\n\n    PublicVault(VAULT()).decreaseYIntercept(\n      (expected - ERC20(underlying()).balanceOf(address(this))).mulDivDown(\n        1e18 - withdrawRatio,\n        1e18\n      )\n    );\n  }\n\n  /**\n   * @notice Called at epoch boundary, computes the ratio between the funds of withdrawing liquidity providers and the balance of the underlying PublicVault so that claim() proportionally pays out to all parties.\n   */\n  function setWithdrawRatio(uint256 liquidationWithdrawRatio) public {\n    require(msg.sender == VAULT());\n\n    withdrawRatio = liquidationWithdrawRatio;\n  }\n\n  /**\n   * @notice Adds an auction scheduled to end in a new epoch to this LiquidationAccountant.\n   * @param newLienExpectedValue The expected auction value for the lien being auctioned.\n   * @param finalAuctionTimestamp The timestamp by which the auction being added is guaranteed to end. As new auctions are added to the LiquidationAccountant, this value will strictly increase as all auctions have the same maximum duration.\n   */\n  function handleNewLiquidation(\n    uint256 newLienExpectedValue,\n    uint256 finalAuctionTimestamp\n  ) public {\n    require(msg.sender == ROUTER());\n    expected += newLienExpectedValue;\n    finalAuctionEnd = finalAuctionTimestamp;\n  }\n\n  function getFinalAuctionEnd() external view returns (uint256) {\n    return finalAuctionEnd;\n  }\n}"
    }
  ]
}