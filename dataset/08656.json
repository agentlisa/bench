{
  "Title": "[L-02] Staking contract's token not verified to be the same token as the staking token",
  "Content": "\nThere may be a mismatch between the token that `_stakingContract` is in charge of, and the actual token used by the `LiquidityReserve`. This code should check that they are in fact the same\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/contracts/LiquidityReserve.sol   #1\n\n57       function enableLiquidityReserve(address _stakingContract)\n58           external\n59           onlyOwner\n60       {\n61           require(!isReserveEnabled, \"Already enabled\");\n62           require(_stakingContract != address(0), \"Invalid address\");\n63   \n64           uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n65               msg.sender\n66           );\n67           // require address has minimum liquidity\n68           require(\n69               stakingTokenBalance >= MINIMUM_LIQUIDITY,\n70               \"Not enough staking tokens\"\n71           );\n72:          stakingContract = _stakingContract;\n```\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/LiquidityReserve.sol#L57-L72>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-06-yieldy-contest",
  "Code": [
    {
      "filename": "src/contracts/LiquidityReserve.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/ILiquidityReserve.sol\";\nimport \"./LiquidityReserveStorage.sol\";\n\ncontract LiquidityReserve is\n    LiquidityReserveStorage,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    ILiquidityReserve\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    event FeeChanged(uint256 fee);\n\n    // check if sender is the stakingContract\n    modifier onlyStakingContract() {\n        require(msg.sender == stakingContract, \"Not staking contract\");\n        _;\n    }\n\n    /**\n        @notice initialize by setting stakingContract & setting initial liquidity\n        @param _tokenName name of the lrToken to be created\n        @param _tokenSymbol symbol of the lrToken to be created.\n        @param _stakingToken the staking token in use\n        @param _rewardToken the reward token in use\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _stakingToken,\n        address _rewardToken\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        OwnableUpgradeable.__Ownable_init();\n        require(\n            _stakingToken != address(0) && _rewardToken != address(0),\n            \"Invalid address\"\n        );\n        stakingToken = _stakingToken;\n        rewardToken = _rewardToken;\n    }\n\n    /**\n        @notice callable once after initialized by the owner to set the staking contract and enable\n        our reserve to be used.\n        @param _stakingContract address of the staking contract\n     */\n    function enableLiquidityReserve(address _stakingContract)\n        external\n        onlyOwner\n    {\n        require(!isReserveEnabled, \"Already enabled\");\n        require(_stakingContract != address(0), \"Invalid address\");\n\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            msg.sender\n        );\n        // require address has minimum liquidity\n        require(\n            stakingTokenBalance >= MINIMUM_LIQUIDITY,\n            \"Not enough staking tokens\"\n        );\n        stakingContract = _stakingContract;\n\n        // permanently lock the first MINIMUM_LIQUIDITY of lrTokens\n        IERC20Upgradeable(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            MINIMUM_LIQUIDITY\n        );\n        _mint(address(this), MINIMUM_LIQUIDITY);\n        IERC20Upgradeable(rewardToken).approve(\n            stakingContract,\n            type(uint256).max\n        );\n        isReserveEnabled = true;\n    }\n\n    /**\n        @notice sets Fee (in basis points eg. 100 bps = 1%) for instant unstaking\n        @param _fee uint - fee in basis points\n     */\n    function setFee(uint256 _fee) external onlyOwner {\n        // check range before setting fee\n        require(_fee <= BASIS_POINTS, \"Out of range\");\n        fee = _fee;\n\n        emit FeeChanged(_fee);\n    }\n\n    /**\n        @notice addLiquidity for the stakingToken and receive lrToken in exchange\n        @param _amount uint - amount of staking tokens to add\n     */\n    function addLiquidity(uint256 _amount) external {\n        require(isReserveEnabled, \"Not enabled yet\");\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            address(this)\n        );\n        uint256 rewardTokenBalance = IERC20Upgradeable(rewardToken).balanceOf(\n            address(this)\n        );\n        uint256 lrFoxSupply = totalSupply();\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        uint256 totalLockedValue = stakingTokenBalance +\n            rewardTokenBalance +\n            coolDownAmount;\n\n        uint256 amountToMint = (_amount * lrFoxSupply) / totalLockedValue;\n        IERC20Upgradeable(stakingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        _mint(msg.sender, amountToMint);\n    }\n\n    /**\n        @notice calculate current lrToken withdraw value\n        @param _amount uint - amount of tokens that will be withdrawn\n        @return uint - converted amount of staking tokens to withdraw from lr tokens\n     */\n    function _calculateReserveTokenValue(uint256 _amount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 lrFoxSupply = totalSupply();\n        uint256 stakingTokenBalance = IERC20Upgradeable(stakingToken).balanceOf(\n            address(this)\n        );\n        uint256 rewardTokenBalance = IERC20Upgradeable(rewardToken).balanceOf(\n            address(this)\n        );\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        uint256 totalLockedValue = stakingTokenBalance +\n            rewardTokenBalance +\n            coolDownAmount;\n        uint256 convertedAmount = (_amount * totalLockedValue) / lrFoxSupply;\n\n        return convertedAmount;\n    }\n\n    /**\n        @notice removeLiquidity by swapping your lrToken for stakingTokens\n        @param _amount uint - amount of tokens to remove from liquidity reserve\n     */\n    function removeLiquidity(uint256 _amount) external {\n        // check balance before removing liquidity\n        require(_amount <= balanceOf(msg.sender), \"Not enough lr tokens\");\n        // claim the stakingToken from previous unstakes\n        IStaking(stakingContract).claimWithdraw(address(this));\n\n        uint256 amountToWithdraw = _calculateReserveTokenValue(_amount);\n\n        // verify that we have enough stakingTokens\n        require(\n            IERC20Upgradeable(stakingToken).balanceOf(address(this)) >=\n                amountToWithdraw,\n            \"Not enough funds\"\n        );\n\n        _burn(msg.sender, _amount);\n        IERC20Upgradeable(stakingToken).safeTransfer(\n            msg.sender,\n            amountToWithdraw\n        );\n    }\n\n    /**\n        @notice allow instant unstake their stakingToken for a fee paid to the liquidity providers\n        @param _amount uint - amount of tokens to instantly unstake\n        @param _recipient address - address to send staking tokens to\n     */\n    function instantUnstake(uint256 _amount, address _recipient)\n        external\n        onlyStakingContract\n    {\n        require(isReserveEnabled, \"Not enabled yet\");\n        // claim the stakingToken from previous unstakes\n        IStaking(stakingContract).claimWithdraw(address(this));\n\n        uint256 amountMinusFee = _amount - ((_amount * fee) / BASIS_POINTS);\n\n        IERC20Upgradeable(rewardToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        IERC20Upgradeable(stakingToken).safeTransfer(\n            _recipient,\n            amountMinusFee\n        );\n        unstakeAllRewardTokens();\n    }\n\n    /**\n        @notice find balance of reward tokens in contract and unstake them from staking contract\n     */\n    function unstakeAllRewardTokens() public {\n        require(isReserveEnabled, \"Not enabled yet\");\n        uint256 coolDownAmount = IStaking(stakingContract)\n            .coolDownInfo(address(this))\n            .amount;\n        if (coolDownAmount == 0) {\n            uint256 amount = IERC20Upgradeable(rewardToken).balanceOf(\n                address(this)\n            );\n            if (amount > 0) IStaking(stakingContract).unstake(amount, false);\n        }\n    }\n}"
    }
  ]
}