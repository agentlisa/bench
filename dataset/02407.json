{
  "Title": "Passing the `return data` by the EVM state",
  "Content": "##### Description\n[`execTransactionFromModuleReturnData`](https://github.com/EnsoFinance/shortcuts-contracts/blob/951a4a247165f4209bceb6deb628a4970bf3f6da/contracts/wallet/ModuleManager.sol#L45) is using `returndatasize` and `returndatacopy` in the assumption that virtual function `_executeCall` is preserving the result of the corresponding external call at the EVM state. As for the audited commit, this assumption is correct. However, the implementation of the virtual `_executeCall` function may become more complex during a past codebase development, and this assumption may break the contract logic later.\n##### Recommendation\nIt is recommended to avoid using the EVM state as a method of passing values outside of a single solidity function, especially if the values are passed between functions located in different source files.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/wallet/ModuleManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.16;\n\nimport \"../interfaces/IModuleManager.sol\";\nimport \"../access/ACL.sol\";\nimport \"../access/Roles.sol\";\n\nabstract contract ModuleManager is IModuleManager, ACL, Roles {\n\n    error NoDelegateCalls();\n\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    ) public virtual isPermitted(MODULE_ROLE) returns (bool success) {\n        if (operation != Operation.Call) revert NoDelegateCalls();\n        success = _executeCall(to, value, data);\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    function _executeCall(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bool success);\n}"
    }
  ]
}