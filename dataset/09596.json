{
  "Title": "[M-02] Setting new buffer does not reduce current buffer to cap",
  "Content": "_Submitted by cmichel, also found by rayn and catchup_\n\n[RateLimited.sol#L142](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L142)<br>\n\nThe `RateLimited.setBufferCap` function first updates the buffer and then sets the new cap, but does not apply the new cap to the updated buffer.<br>\nMeaning, the updated buffer value can be larger than the new buffer cap which should never be the case.<br>\nActions consuming more than the new buffer cap can be performed.\n\n```solidity\nfunction _setBufferCap(uint256 newBufferCap) internal {\n    // @audit still uses old buffer cap, should set buffer first\n    _updateBufferStored();\n\n    uint256 oldBufferCap = bufferCap;\n    bufferCap = newBufferCap;\n\n\n    emit BufferCapUpdate(oldBufferCap, newBufferCap);\n}\n```\n\n### Recommended Mitigation Steps\n\nUpdate the buffer after setting the new cap:\n\n```diff\nfunction _setBufferCap(uint256 newBufferCap) internal {\n-   _updateBufferStored();\n    uint256 oldBufferCap = bufferCap;\n    bufferCap = newBufferCap;\n\n+   _updateBufferStored();\n\n    emit BufferCapUpdate(oldBufferCap, newBufferCap);\n}\n```\n\n**[ElliotFriedman (Volt) confirmed](https://github.com/code-423n4/2022-03-volt-findings/issues/29)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-volt-protocol-contest",
  "Code": [
    {
      "filename": "contracts/utils/RateLimited.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../refs/CoreRef.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title abstract contract for putting a rate limit on how fast a contract can perform an action e.g. Minting\n/// @author Fei Protocol\nabstract contract RateLimited is CoreRef {\n    /// @notice maximum rate limit per second governance can set for this contract\n    uint256 public immutable MAX_RATE_LIMIT_PER_SECOND;\n\n    /// @notice the rate per second for this contract\n    uint256 public rateLimitPerSecond;\n\n    /// @notice the last time the buffer was used by the contract\n    uint256 public lastBufferUsedTime;\n\n    /// @notice the cap of the buffer that can be used at once\n    uint256 public bufferCap;\n\n    /// @notice a flag for whether to allow partial actions to complete if the buffer is less than amount\n    bool public doPartialAction;\n\n    /// @notice the buffer at the timestamp of lastBufferUsedTime\n    uint256 public bufferStored;\n\n    event BufferUsed(uint256 amountUsed, uint256 bufferRemaining);\n    event BufferCapUpdate(uint256 oldBufferCap, uint256 newBufferCap);\n    event RateLimitPerSecondUpdate(\n        uint256 oldRateLimitPerSecond,\n        uint256 newRateLimitPerSecond\n    );\n\n    constructor(\n        uint256 _maxRateLimitPerSecond,\n        uint256 _rateLimitPerSecond,\n        uint256 _bufferCap,\n        bool _doPartialAction\n    ) {\n        lastBufferUsedTime = block.timestamp;\n\n        _setBufferCap(_bufferCap);\n        bufferStored = _bufferCap;\n\n        require(\n            _rateLimitPerSecond <= _maxRateLimitPerSecond,\n            \"RateLimited: rateLimitPerSecond too high\"\n        );\n        _setRateLimitPerSecond(_rateLimitPerSecond);\n\n        MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;\n        doPartialAction = _doPartialAction;\n    }\n\n    /// @notice set the rate limit per second\n    function setRateLimitPerSecond(uint256 newRateLimitPerSecond)\n        external\n        virtual\n        onlyGovernorOrAdmin\n    {\n        require(\n            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"RateLimited: rateLimitPerSecond too high\"\n        );\n        _updateBufferStored();\n\n        _setRateLimitPerSecond(newRateLimitPerSecond);\n    }\n\n    /// @notice set the buffer cap\n    function setBufferCap(uint256 newBufferCap)\n        external\n        virtual\n        onlyGovernorOrAdmin\n    {\n        _setBufferCap(newBufferCap);\n    }\n\n    /// @notice the amount of action used before hitting limit\n    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap\n    function buffer() public view returns (uint256) {\n        uint256 elapsed = block.timestamp - lastBufferUsedTime;\n        return\n            Math.min(bufferStored + (rateLimitPerSecond * elapsed), bufferCap);\n    }\n\n    /** \n        @notice the method that enforces the rate limit. Decreases buffer by \"amount\". \n        If buffer is <= amount either\n        1. Does a partial mint by the amount remaining in the buffer or\n        2. Reverts\n        Depending on whether doPartialAction is true or false\n    */\n    function _depleteBuffer(uint256 amount) internal virtual returns (uint256) {\n        uint256 newBuffer = buffer();\n\n        uint256 usedAmount = amount;\n        if (doPartialAction && usedAmount > newBuffer) {\n            usedAmount = newBuffer;\n        }\n\n        require(newBuffer != 0, \"RateLimited: no rate limit buffer\");\n        require(usedAmount <= newBuffer, \"RateLimited: rate limit hit\");\n\n        bufferStored = newBuffer - usedAmount;\n\n        lastBufferUsedTime = block.timestamp;\n\n        emit BufferUsed(usedAmount, bufferStored);\n\n        return usedAmount;\n    }\n\n    /// @notice function to replenish buffer\n    /// @param amount to increase buffer by if under buffer cap\n    function _replenishBuffer(uint256 amount) internal {\n        uint256 newBuffer = buffer();\n\n        uint256 _bufferCap = bufferCap; /// gas opti, save an SLOAD\n\n        /// cannot replenish any further if already at buffer cap\n        if (newBuffer == _bufferCap) {\n            return;\n        }\n\n        /// ensure that bufferStored cannot be gt buffer cap\n        bufferStored = Math.min(newBuffer + amount, _bufferCap);\n    }\n\n    function _setRateLimitPerSecond(uint256 newRateLimitPerSecond) internal {\n        uint256 oldRateLimitPerSecond = rateLimitPerSecond;\n        rateLimitPerSecond = newRateLimitPerSecond;\n\n        emit RateLimitPerSecondUpdate(\n            oldRateLimitPerSecond,\n            newRateLimitPerSecond\n        );\n    }\n\n    function _setBufferCap(uint256 newBufferCap) internal {\n        _updateBufferStored();\n\n        uint256 oldBufferCap = bufferCap;\n        bufferCap = newBufferCap;\n\n        emit BufferCapUpdate(oldBufferCap, newBufferCap);\n    }\n\n    function _resetBuffer() internal {\n        bufferStored = bufferCap;\n    }\n\n    function _updateBufferStored() internal {\n        bufferStored = buffer();\n        lastBufferUsedTime = block.timestamp;\n    }\n}"
    }
  ]
}