{
  "Title": "Incorrect Event Emission",
  "Content": "The [`logBorrowChange`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/BorrowUtils.sol#L156-L169) function is expected to emit accurate events based on both the previously owed amount and the currently owed amount. However, within the [`increaseBorrow`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/BorrowUtils.sol#L40-L50), [`decreaseBorrow`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/BorrowUtils.sol#L52-L68), and [`transferBorrow`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/BorrowUtils.sol#L70-L95) functions, the [`logBorrowChange`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/BorrowUtils.sol#L67) function is triggered with the value of `prevOwed` instead of utilizing the currently owed amount retrieved from the `getCurrentOwed` function. This creates a scenario where, if the difference between the amount borrowed or repaid is smaller than the accrued interest, incorrect events may be emitted.\n\n\nConsider passing the value of the owed amount after considering interest as the `prevOwed` parameter. This will help improve the readability of the logs for both users and off-chain systems.\n\n\n***Update:** Resolved in [pull request #160](https://github.com/euler-xyz/euler-vault-kit/pull/160). The Euler team stated:*\n\n\n\n> *The fix consists of adding the `InterestAccrued` event which ensures that the `Borrow` and `Repay` events are always emitted in line with the function the user called, and that the amounts of the borrows/repays are included explicitly in the logs.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/EVault/shared/BorrowUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Base} from \"./Base.sol\";\nimport {DToken} from \"../DToken.sol\";\nimport {IIRM} from \"../../InterestRateModels/IIRM.sol\";\n\nimport \"./types/Types.sol\";\n\n/// @title BorrowUtils\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Utilities for tracking debt and interest rates\nabstract contract BorrowUtils is Base {\n    using TypesLib for uint256;\n\n    function getCurrentOwed(VaultCache memory vaultCache, address account, Owed owed) internal view returns (Owed) {\n        // Don't bother loading the user's accumulator\n        if (owed.isZero()) return Owed.wrap(0);\n\n        // Can't divide by 0 here: If owed is non-zero, we must've initialized the user's interestAccumulator\n        return owed.mulDiv(vaultCache.interestAccumulator, vaultStorage.users[account].interestAccumulator);\n    }\n\n    function getCurrentOwed(VaultCache memory vaultCache, address account) internal view returns (Owed) {\n        return getCurrentOwed(vaultCache, account, vaultStorage.users[account].getOwed());\n    }\n\n    function updateUserBorrow(VaultCache memory vaultCache, address account)\n        private\n        returns (Owed newOwed, Owed prevOwed)\n    {\n        prevOwed = vaultStorage.users[account].getOwed();\n        newOwed = getCurrentOwed(vaultCache, account, prevOwed);\n\n        vaultStorage.users[account].setOwed(newOwed);\n        vaultStorage.users[account].interestAccumulator = vaultCache.interestAccumulator;\n    }\n\n    function increaseBorrow(VaultCache memory vaultCache, address account, Assets assets) internal virtual {\n        (Owed owed, Owed prevOwed) = updateUserBorrow(vaultCache, account);\n\n        Owed amount = assets.toOwed();\n        owed = owed + amount;\n\n        vaultStorage.users[account].setOwed(owed);\n        vaultStorage.totalBorrows = vaultCache.totalBorrows = vaultCache.totalBorrows + amount;\n\n        logBorrowChange(account, prevOwed, owed);\n    }\n\n    function decreaseBorrow(VaultCache memory vaultCache, address account, Assets amount) internal virtual {\n        (Owed owedExact, Owed prevOwed) = updateUserBorrow(vaultCache, account);\n        Assets owed = owedExact.toAssetsUp();\n\n        if (amount > owed) revert E_RepayTooMuch();\n\n        Owed owedRemaining;\n        unchecked {\n            owedRemaining = (owed - amount).toOwed();\n        }\n\n        vaultStorage.users[account].setOwed(owedRemaining);\n        vaultStorage.totalBorrows = vaultCache.totalBorrows =\n            vaultCache.totalBorrows > owedExact ? vaultCache.totalBorrows - owedExact + owedRemaining : owedRemaining;\n\n        logBorrowChange(account, prevOwed, owedRemaining);\n    }\n\n    function transferBorrow(VaultCache memory vaultCache, address from, address to, Assets assets) internal virtual {\n        Owed amount = assets.toOwed();\n\n        (Owed fromOwed, Owed fromOwedPrev) = updateUserBorrow(vaultCache, from);\n        (Owed toOwed, Owed toOwedPrev) = updateUserBorrow(vaultCache, to);\n\n        // If amount was rounded up, or dust is left over, transfer exact amount owed\n        if ((amount > fromOwed && (amount - fromOwed).isDust()) || (amount < fromOwed && (fromOwed - amount).isDust()))\n        {\n            amount = fromOwed;\n        }\n\n        if (amount > fromOwed) revert E_InsufficientBalance();\n\n        unchecked {\n            fromOwed = fromOwed - amount;\n        }\n\n        toOwed = toOwed + amount;\n\n        vaultStorage.users[from].setOwed(fromOwed);\n        vaultStorage.users[to].setOwed(toOwed);\n\n        logBorrowChange(from, fromOwedPrev, fromOwed);\n        logBorrowChange(to, toOwedPrev, toOwed);\n    }\n\n    function computeInterestRate(VaultCache memory vaultCache) internal virtual returns (uint256) {\n        // single sload\n        address irm = vaultStorage.interestRateModel;\n        uint256 newInterestRate = vaultStorage.interestRate;\n\n        if (irm != address(0)) {\n            (bool success, bytes memory data) = irm.call(\n                abi.encodeCall(\n                    IIRM.computeInterestRate,\n                    (address(this), vaultCache.cash.toUint(), vaultCache.totalBorrows.toAssetsUp().toUint())\n                )\n            );\n\n            if (success && data.length >= 32) {\n                newInterestRate = abi.decode(data, (uint256));\n                if (newInterestRate > MAX_ALLOWED_INTEREST_RATE) newInterestRate = MAX_ALLOWED_INTEREST_RATE;\n                vaultStorage.interestRate = uint72(newInterestRate);\n            }\n        }\n\n        return newInterestRate;\n    }\n\n    function computeInterestRateView(VaultCache memory vaultCache) internal view virtual returns (uint256) {\n        // single sload\n        address irm = vaultStorage.interestRateModel;\n        uint256 newInterestRate = vaultStorage.interestRate;\n\n        if (irm != address(0) && isVaultStatusCheckDeferred()) {\n            (bool success, bytes memory data) = irm.staticcall(\n                abi.encodeCall(\n                    IIRM.computeInterestRateView,\n                    (address(this), vaultCache.cash.toUint(), vaultCache.totalBorrows.toAssetsUp().toUint())\n                )\n            );\n\n            if (success && data.length >= 32) {\n                newInterestRate = abi.decode(data, (uint256));\n                if (newInterestRate > MAX_ALLOWED_INTEREST_RATE) newInterestRate = MAX_ALLOWED_INTEREST_RATE;\n            }\n        }\n\n        return newInterestRate;\n    }\n\n    function calculateDTokenAddress() internal view returns (address dToken) {\n        // inspired by https://github.com/Vectorized/solady/blob/229c18cfcdcd474f95c30ad31b0f7d428ee8a31a/src/utils/CREATE3.sol#L82-L90\n        assembly (\"memory-safe\") {\n            mstore(0x14, address())\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ address(this) ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            // Nonce of the contract when DToken was deployed (1).\n            mstore8(0x34, 0x01)\n\n            dToken := keccak256(0x1e, 0x17)\n        }\n    }\n\n    function logBorrowChange(address account, Owed prevOwed, Owed owed) private {\n        address dTokenAddress = calculateDTokenAddress();\n\n        if (owed > prevOwed) {\n            uint256 change = (owed.toAssetsUp() - prevOwed.toAssetsUp()).toUint();\n            emit Borrow(account, change);\n            DToken(dTokenAddress).emitTransfer(address(0), account, change);\n        } else if (prevOwed > owed) {\n            uint256 change = (prevOwed.toAssetsUp() - owed.toAssetsUp()).toUint();\n\n            emit Repay(account, change);\n            DToken(dTokenAddress).emitTransfer(account, address(0), change);\n        }\n    }\n}"
    }
  ]
}