{
  "Title": "[M-09] StakingRewards: recoverERC20() can be used as a backdoor by the owner to retrieve rewardsToken",
  "Content": "\nSimilar to <https://github.com/code-423n4/2022-02-concur-findings/issues/210>\nStakingRewards.recoverERC20 rightfully checks against the stakingToken being sweeped away.\nHowever, thereâ€™s no check against the rewardsToken.\nThis is the case of an admin privilege, which allows the owner to sweep the rewards tokens, perhaps as a way to rug depositors.\n\n        function recoverERC20(address tokenAddress, uint256 tokenAmount)\n            external\n            onlyOwner\n        {\n            require(\n                tokenAddress != address(stakingToken),\n                \"Cannot withdraw the staking token\"\n            );\n            ERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n            emit Recovered(tokenAddress, tokenAmount);\n        }\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/rewards/StakingRewards.sol#L213-L223>\n\n### Recommended Mitigation Steps\n\nAdd an additional check\n\n            require(\n                tokenAddress != address(rewardsToken),\n                \"Cannot withdraw the rewards token\"\n            );\n\n**[scaraven (warden) commented](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/49#issuecomment-1251509588):**\n > I'm curious what others think about this issue, if users do not receive any reward tokens is that really a problem? Users are still able to withdraw their ERC1155 tokens at any time, and vaults still work as expected. If the admin is malicious, users will miss out on tokens which will be worthless after a rugpull anyway.\n\n**[MiguelBits (Y2K Finance) disputed and commented](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/49#issuecomment-1263075624):**\n > This is how synthetix rewards work, I forked their smart contracts.\n\n**[HickupHH3 commented](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/49#issuecomment-1295781746):**\n > Including this issue, issues [#50](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/50), [#51](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/51) and [#52](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/52) can be considered to be admin privilege findings. There's active discussion revolving how findings of this category should be handled / standardized.\n> \n> For now, I'm keeping the medium severity due to historical context (past contest references). l also reproduce the classification rationale that I gave for a previous contest below:\n> \n> > ### Classification and thought process\n> > The issues raised about rugpull vulnerabilities via centralisation risks can be broadly classified into 2 categories:\n> \n> > 1. Those that can be mitigated with contract modifications. Examples include:\n> > - ensuring upper / lower proper bounds on key variables (fees not exceeding max threshold, for instance)\n> > - adding safeguards and conditional checks (require statements)\n> > 2) Those that can't be strictly enforced\n> > - Use multisig, put admin under timelock\n> \n> > Category 1 can be separated into the various attack vectors and actors (admin / strategist), as the mitigation is more tangible in nature. This way, the recommended fixes can also be easily identified and adopted. A warden that grouped multiple attack vectors together will have their issue made the primary issue; the rest will be marked as duplicates of it. \n> \n> > Regarding category 2, for issues that are generic \"put admin under timelock\" without explaining how and why a compromised owner / strategist can rug, as per the rulebook and judges' general consensus, I will downgrade their severity to QA. Those that explained the impact and vulnerability in detail will be grouped together with medium severity because there isn't much that can be done about it.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-y2k-finance-contest",
  "Code": [
    {
      "filename": "src/rewards/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeTransferLib} from \"@solmate/utils/SafeTransferLib.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n// Inheritance\nimport {IStakingRewards} from \"./IStakingRewards.sol\";\nimport {RewardsDistributionRecipient} from \"./RewardsDistributionRecipient.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {\n    ERC1155Holder\n} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Owned.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/stakingrewards\ncontract StakingRewards is\n    IStakingRewards,\n    RewardsDistributionRecipient,\n    ReentrancyGuard,\n    Pausable,\n    ERC1155Holder\n{\n    using SafeMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    ERC20 public immutable rewardsToken;\n    IERC1155 public immutable stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate;\n    uint256 public rewardsDuration;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public id;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 id, uint256 amount);\n    event Withdrawn(address indexed user, uint256 id, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        uint256 _epochEnd,\n        uint256 _rewardsDuration,\n        uint256 _rewardRate\n    ) Owned(_owner) {\n        rewardsToken = ERC20(_rewardsToken);\n        stakingToken = IERC1155(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        id = _epochEnd;\n        rewardsDuration = _rewardsDuration;\n        rewardRate = _rewardRate;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount != 0, \"Cannot stake 0\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            amount,\n            \"\"\n        );\n        emit Staked(msg.sender, id, amount);\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        emit Withdrawn(msg.sender, id, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(_totalSupply)\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardsDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance.div(rewardsDuration),\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        ERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n}"
    }
  ]
}