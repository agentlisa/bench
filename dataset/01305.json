{
  "Title": "M-14: [M-01] Allocation can start before registration ends. Which can break things in strategies.",
  "Content": "# Issue M-14: [M-01] Allocation can start before registration ends. Which can break things in strategies. \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/751 \n\n## Found by \n0xkaden, Kral01, WATCHPUG, ace13567, honeymewn, lemonmon, tnquanghuy0512\nAllocation can start before registration ends. Which can break things in strategies. When using `QVBaseStrategy` and `DonationVotingMerkleDistributionBaseStrategy` .\n\n## Vulnerability Detail\n\nThe way that timestamps are set or specifically, validated right now allows `Allocation` to start before `Registration` ends. I havent git a clear answer from the protocol team regarding whether this is intended or not, but even if it is intended, this can potentially break some stuff in `QVBaseStrategy` and `DonationVotingMerkleDistributionBaseStrategy`. \n\nIf `_registerRecipient` is called while `Allocation` is active on both [QVBaseStrategy](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/6430c8004017e96ae2f5aac365bdefd0b6eeea72/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L369C3-L430C6) and [DonationVotingMerkleDistributionBaseStrategy](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/6430c8004017e96ae2f5aac365bdefd0b6eeea72/allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol#L528C4-L601C6) This can completely modify the effects of `reviewRecipients` and rewrite the status of already 'reviewed' recipients. This can cause rewards being falsely distributed or even stuck as well.\n\nOf course there is a check to see if the caller is a member of the pool. Since the members are 'trusted' then the likelihood is low, thus the impact will be medium, if those roles are not to be trusted, then impact can potentially be high.\n\n## Impact\n\nRecipient statuses can be modified and altered causing funds to sent falsely or get stuck.\n\n## Code Snippet\n\nThis is the check to validate timestamps in both strategies. As we can see, it allows `allocationStartTime` to be less than `registrationEndTime`.\n\n```javascript\n  if (\n            block.timestamp > _registrationStartTime || _registrationStartTime > _registrationEndTime\n                || _registrationStartTime > _allocationStartTime || _allocationStartTime > _allocationEndTime\n                || _registrationEndTime > _allocationEndTime \n        ) {//@audit I think we can start allocation before registration ends\n            revert INVALID();\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding check to revert if allocation can start before registration ends:\n```javascript\n  if (\n            block.timestamp > _registrationStartTime || _registrationStartTime > _registrationEndTime\n                || _registrationStartTime > _allocationStartTime || _allocationStartTime > _allocationEndTime\n                || _registrationEndTime > _allocationEndTime  || _registrationEndTime > _allocationStartTime \n        ) {\n            revert INVALID();\n```\n\n\n\n## Discussion\n\n**thelostone-mc**\n\nIt is intended to have the ability to register even after allocation has started.\nBut the funds getting stuck for a recipient who has reapplied can be tricky. \nWe could explore a fix this to ensure reapplications are not possible once the allocation has started\n\n**0xKurt**\n\n> But the funds getting stuck for a recipient who has reapplied can be tricky.\n\nWe don't see a way how funds could get stuck in the contract.\n\n**thelostone-mc**\n\nYup this doesn't seem to be an issue. \nThis can be ignored as it works as intended\n\n**neeksec**\n\nAgree with sponsor.\n\n**kadenzipfel**\n\nEscalate\nThis should be a valid medium. Locked funds can happen as follows:\n\n- Recipient registers and is accepted\n- Recipient receives allocation (possible because crossover of registration and allocation periods)\n- Recipient re-registers (perhaps near the end of registration period)\n  - Recipient now has status of pending until a new review is processed\n  - Recipient still has allocated credits\n- Registration period completes before recipient is re-reviewed (possible since `registerRecipient` and `reviewRecipients` both are `onlyActiveRegistration`, so there may not be time for the recipient to be re-reviewed\n- Distribution can no longer be processed to re-registered recipient as they are no longer accepted [revert](https://github.com/allo-protocol/allo-v2/blob/851571c27df5c16f6586ece2a1cb6fd0acf04ec9/contracts/strategies/qv-base/QVBaseStrategy.sol#L451)\n- No other way to withdraw allocated share of `poolAmount` and thus the funds will be permanently locked in the contract\n\nI've included a similar explanation in my submission which may better explain the finding: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/361\n\n**sherlock-admin2**\n\n > Escalate\n> This should be a valid medium. Locked funds can happen as follows:\n> \n> - Recipient registers and is accepted\n> - Recipient receives allocation (possible because crossover of registration and allocation periods)\n> - Recipient re-registers (perhaps near the end of registration period)\n>   - Recipient now has status of pending until a new review is processed\n>   - Recipient still has allocated credits\n> - Registration period completes before recipient is re-reviewed (possible since `registerRecipient` and `reviewRecipients` both are `onlyActiveRegistration`, so there may not be time for the recipient to be re-reviewed\n> - Distribution can no longer be processed to re-registered recipient as they are no longer accepted [revert](https://github.com/allo-protocol/allo-v2/blob/851571c27df5c16f6586ece2a1cb6fd0acf04ec9/contracts/strategies/qv-base/QVBaseStrategy.sol#L451)\n> - No other way to withdraw allocated share of `poolAmount` and thus the funds will be permanently locked in the contract\n> \n> I've included a similar explanation in my submission which may better explain the finding: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/361\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**neeksec**\n\nSuggest to keep invalid.\n\nSponsor said that \"It is intended to have the ability to register even after allocation has started.\"\n\nAccepted recipient re-register should be re-reviewed. They should know this risk.\n\nIf funds are not successfully distributed, pool manager should be able to withdraw them. Fixing #446 solves the locking problem.\n\n**kadenzipfel**\n\n> Suggest to keep invalid.\n> \n> Sponsor said that \"It is intended to have the ability to register even after allocation has started.\"\n> \n> Accepted recipient re-register should be re-reviewed. They should know this risk.\n> \n> If funds are not successfully distributed, pool manager should be able to withdraw them. Fixing #446 solves the locking problem.\n\nDisagree. While functionality may be inline with sponsor intent, the result of funds being locked under normal usage is clearly not intended. Recipients being aware of the risk of losing _their own allocation_ is valid, but they shouldn't be aware of and responsible for this leading to funds being permanently locked. \n\nThe fact that the solution to https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/446 happens to solve this should not invalidate the finding. If that were reasonable, then it would be equally reasonable to invalidate https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/446 if the recommended mitigation to this issue solved https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/446.\n\nNote that this is issue was initially sponsor disputed because it was unclear how it would lead to funds being locked, which has since been clarified https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/751#issuecomment-1763188537 and was already made clear in other issues, including https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/361\n\n**Evert0x**\n\n@neeksec any follow up comment?\n\n**neeksec**\n\nAgree with @kadenzipfel on\n\n> the result of funds being locked under normal usage is clearly not intended\n\nAgree with escalation that this should be medium.\n\n**Evert0x**\n\nThanks. Planning to accept escalation and make medium\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [kadenzipfel](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/751/#issuecomment-1763188537): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title QVBaseStrategy\n/// @notice Base strategy for quadratic voting strategies\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\nabstract contract QVBaseStrategy is BaseStrategy {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId ID of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    /// @param status The updated status of the recipient\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender, Status status);\n\n    /// @notice Emitted when a recipient is registered\n    /// @param recipientId ID of the recipient\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event RecipientStatusUpdated(address indexed recipientId, Status status, address sender);\n    /// @notice Emitted when the pool timestamps are updated\n    /// @param registrationStartTime The start time for the registration\n    /// @param registrationEndTime The end time for the registration\n    /// @param allocationStartTime The start time for the allocation\n    /// @param allocationEndTime The end time for the allocation\n    /// @param sender The sender of the transaction\n    event TimestampsUpdated(\n        uint64 registrationStartTime,\n        uint64 registrationEndTime,\n        uint64 allocationStartTime,\n        uint64 allocationEndTime,\n        address sender\n    );\n\n    /// @notice Emitted when a recipient receives votes\n    /// @param recipientId ID of the recipient\n    /// @param votes The votes allocated to the recipient\n    /// @param allocator The allocator assigning the votes\n    event Allocated(address indexed recipientId, uint256 votes, address allocator);\n\n    /// @notice Emitted when a recipient is reviewed\n    /// @param recipientId ID of the recipient\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event Reviewed(address indexed recipientId, Status status, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    // slot 0\n    /// @notice The total number of votes cast for all recipients\n    uint256 public totalRecipientVotes;\n\n    // slot 1\n    /// @notice The number of votes required to review a recipient\n    uint256 public reviewThreshold;\n\n    // slot 2\n    /// @notice The start and end times for registrations and allocations\n    /// @dev The values will be in milliseconds since the epoch\n    uint64 public registrationStartTime;\n    uint64 public registrationEndTime;\n    uint64 public allocationStartTime;\n    uint64 public allocationEndTime;\n\n    // slot 3\n    /// @notice Whether or not the strategy is using registry gating\n    bool public registryGating;\n\n    /// @notice Whether or not the strategy requires metadata\n    bool public metadataRequired;\n\n    /// @notice The registry contract\n    IRegistry private _registry;\n\n    // slots [4...n]\n    /// @notice The status of the recipient for this strategy only\n    /// @dev There is a core `IStrategy.RecipientStatus` that this should map to\n    enum InternalRecipientStatus {\n        None,\n        Pending,\n        Accepted,\n        Rejected,\n        Appealed\n    }\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParams {\n        // slot 0\n        bool registryGating;\n        bool metadataRequired;\n        // slot 1\n        uint256 reviewThreshold;\n        // slot 2\n        uint64 registrationStartTime;\n        uint64 registrationEndTime;\n        uint64 allocationStartTime;\n        uint64 allocationEndTime;\n    }\n\n    /// @notice The details of the recipient\n    struct Recipient {\n        // slot 0\n        uint256 totalVotesReceived;\n        // slot 1\n        bool useRegistryAnchor;\n        address recipientAddress;\n        Metadata metadata;\n        Status recipientStatus;\n    }\n\n    /// @notice The details of the allocator\n    struct Allocator {\n        // slot 0\n        uint256 voiceCredits;\n        // slots [1...n]\n        mapping(address => uint256) voiceCreditsCastToRecipient;\n        mapping(address => uint256) votesCastToRecipient;\n    }\n\n    /// @notice The details of the recipient are returned using their ID\n    /// @dev recipientId => Recipient\n    mapping(address => Recipient) public recipients;\n\n    /// @notice The details of the allocator are returned using their address\n    /// @dev allocator address => Allocator\n    mapping(address => Allocator) public allocators;\n\n    /// @notice Returns whether or not the recipient has been paid out using their ID\n    /// @dev recipientId => paid out\n    mapping(address => bool) public paidOut;\n\n    // recipientId -> status -> count\n    mapping(address => mapping(Status => uint256)) public reviewsByStatus;\n\n    /// ================================\n    /// ========== Modifier ============\n    /// ================================\n\n    /// @notice Modifier to check if the registration is active\n    /// @dev Reverts if the registration is not active\n    modifier onlyActiveRegistration() {\n        _checkOnlyActiveRegistration();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    modifier onlyActiveAllocation() {\n        _checkOnlyActiveAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    modifier onlyAfterAllocation() {\n        _checkOnlyAfterAllocation();\n        _;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ====================================\n    /// =========== Initialize =============\n    /// ====================================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    function initialize(uint256 _poolId, bytes memory _data) external virtual;\n\n    /// @notice Internal initialize function\n    /// @param _poolId The ID of the pool\n    /// @param _params The initialize params for the strategy\n    function __QVBaseStrategy_init(uint256 _poolId, InitializeParams memory _params) internal {\n        __BaseStrategy_init(_poolId);\n\n        registryGating = _params.registryGating;\n        metadataRequired = _params.metadataRequired;\n        _registry = allo.getRegistry();\n\n        reviewThreshold = _params.reviewThreshold;\n\n        _updatePoolTimestamps(\n            _params.registrationStartTime,\n            _params.registrationEndTime,\n            _params.allocationStartTime,\n            _params.allocationEndTime\n        );\n    }\n\n    /// =========================\n    /// ==== View Functions =====\n    /// =========================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Get recipient status\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view virtual override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Checks if a pool is active or not\n    /// @return Whether the pool is active or not\n    function _isPoolActive() internal view virtual override returns (bool) {\n        if (registrationStartTime <= block.timestamp && block.timestamp <= registrationEndTime) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Review recipient(s) application(s)\n    /// @dev You can review multiple recipients at once or just one. This can only be called by a pool manager and\n    ///      only during active registration.\n    /// @param _recipientIds Ids of the recipients\n    /// @param _recipientStatuses Statuses of the recipients\n    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)\n        external\n        virtual\n        onlyPoolManager(msg.sender)\n        onlyActiveRegistration\n    {\n        // make sure the arrays are the same length\n        uint256 recipientLength = _recipientIds.length;\n        if (recipientLength != _recipientStatuses.length) revert INVALID();\n\n        for (uint256 i; i < recipientLength;) {\n            Status recipientStatus = _recipientStatuses[i];\n            address recipientId = _recipientIds[i];\n\n            // if the status is none or appealed then revert\n            if (recipientStatus == Status.None || recipientStatus == Status.Appealed) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            reviewsByStatus[recipientId][recipientStatus]++;\n\n            if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) {\n                Recipient storage recipient = recipients[recipientId];\n                recipient.recipientStatus = recipientStatus;\n\n                emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));\n            }\n\n            emit Reviewed(recipientId, recipientStatus, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) external onlyPoolManager(msg.sender) {\n        _updatePoolTimestamps(_registrationStartTime, _registrationEndTime, _allocationStartTime, _allocationEndTime);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Check if the registration is active\n    /// @dev Reverts if the registration is not active\n    function _checkOnlyActiveRegistration() internal view virtual {\n        if (registrationStartTime > block.timestamp || block.timestamp > registrationEndTime) {\n            revert REGISTRATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    function _checkOnlyActiveAllocation() internal view virtual {\n        if (allocationStartTime > block.timestamp || block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    function _checkOnlyAfterAllocation() internal view virtual {\n        if (block.timestamp < allocationEndTime) revert ALLOCATION_NOT_ENDED();\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function _updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) internal {\n        // validate the timestamps for this strategy\n        if (\n            block.timestamp > _registrationStartTime || _registrationStartTime > _registrationEndTime\n                || _registrationStartTime > _allocationStartTime || _allocationStartTime > _allocationEndTime\n                || _registrationEndTime > _allocationEndTime\n        ) {\n            revert INVALID();\n        }\n\n        // Set the new values\n        registrationStartTime = _registrationStartTime;\n        registrationEndTime = _registrationEndTime;\n        allocationStartTime = _allocationStartTime;\n        allocationEndTime = _allocationEndTime;\n\n        // emit the event\n        emit TimestampsUpdated(\n            registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime, msg.sender\n        );\n    }\n\n    /// @notice Submit application to pool\n    /// @dev The '_data' parameter is encoded as follows:\n    ///     - If registryGating is true, then the data is encoded as (address recipientId, address recipientAddress, Metadata metadata)\n    ///     - If registryGating is false, then the data is encoded as (address recipientAddress, address registryAnchor, Metadata metadata)\n    /// @param _data The data to be decoded\n    /// @param _sender The sender of the transaction\n    /// @return recipientId The ID of the recipient\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        virtual\n        override\n        onlyActiveRegistration\n        returns (address recipientId)\n    {\n        address recipientAddress;\n        address registryAnchor;\n        bool isUsingRegistryAnchor;\n\n        Metadata memory metadata;\n\n        // decode data custom to this strategy\n        if (registryGating) {\n            (recipientId, recipientAddress, metadata) = abi.decode(_data, (address, address, Metadata));\n\n            // when registry gating is enabled, the recipientId must be a profile member\n            if (!_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        } else {\n            (recipientAddress, registryAnchor, metadata) = abi.decode(_data, (address, address, Metadata));\n            isUsingRegistryAnchor = registryAnchor != address(0);\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\n\n            // when using registry anchor, the ID of the recipient must be a profile member\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        }\n\n        // make sure that if metadata is required, it is provided\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\n            revert INVALID_METADATA();\n        }\n\n        // make sure the recipient address is not the zero address\n        if (recipientAddress == address(0)) revert RECIPIENT_ERROR(recipientId);\n\n        Recipient storage recipient = recipients[recipientId];\n\n        // update the recipients data\n        recipient.recipientAddress = recipientAddress;\n        recipient.metadata = metadata;\n        recipient.useRegistryAnchor = registryGating ? true : isUsingRegistryAnchor;\n\n        Status currentStatus = recipient.recipientStatus;\n\n        if (currentStatus == Status.None) {\n            // recipient registering new application\n            recipient.recipientStatus = Status.Pending;\n            emit Registered(recipientId, _data, _sender);\n        } else {\n            if (currentStatus == Status.Accepted) {\n                // recipient updating accepted application\n                recipient.recipientStatus = Status.Pending;\n            } else if (currentStatus == Status.Rejected) {\n                // recipient updating rejected application\n                recipient.recipientStatus = Status.Appealed;\n            }\n\n            // emit the new status with the '_data' that was passed in\n            emit UpdatedRegistration(recipientId, _data, _sender, recipient.recipientStatus);\n        }\n    }\n\n    /// @notice Distribute the tokens to the recipients\n    /// @dev The '_sender' must be a pool manager and the allocation must have ended\n    /// @param _recipientIds The recipient ids\n    /// @param _sender The sender of the transaction\n    function _distribute(address[] memory _recipientIds, bytes memory, address _sender)\n        internal\n        virtual\n        override\n        onlyPoolManager(_sender)\n        onlyAfterAllocation\n    {\n        uint256 payoutLength = _recipientIds.length;\n        for (uint256 i; i < payoutLength;) {\n            address recipientId = _recipientIds[i];\n            Recipient storage recipient = recipients[recipientId];\n\n            PayoutSummary memory payout = _getPayout(recipientId, \"\");\n            uint256 amount = payout.amount;\n\n            if (paidOut[recipientId] || !_isAcceptedRecipient(recipientId) || amount == 0) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            IAllo.Pool memory pool = allo.getPool(poolId);\n            _transferAmount(pool.token, recipient.recipientAddress, amount);\n\n            paidOut[recipientId] = true;\n\n            emit Distributed(recipientId, recipient.recipientAddress, amount, _sender);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Check if sender is a profile member\n    /// @param _anchor Anchor of the profile\n    /// @param _sender The sender of the transaction\n    /// @return If the '_sender' is a profile member\n    function _isProfileMember(address _anchor, address _sender) internal view returns (bool) {\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\n    }\n\n    /// @notice Getter for a recipient using the ID\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory) {\n        return recipients[_recipientId];\n    }\n\n    /// ====================================\n    /// ============ QV Helper ==============\n    /// ====================================\n\n    /// @notice Calculate the square root of a number (Babylonian method)\n    /// @param x The number\n    /// @return y The square root\n    function _sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /// @notice Allocate voice credits to a recipient\n    /// @dev This can only be called during active allocation period\n    /// @param _allocator The allocator details\n    /// @param _recipient The recipient details\n    /// @param _recipientId The ID of the recipient\n    /// @param _voiceCreditsToAllocate The voice credits to allocate to the recipient\n    /// @param _sender The sender of the transaction\n    function _qv_allocate(\n        Allocator storage _allocator,\n        Recipient storage _recipient,\n        address _recipientId,\n        uint256 _voiceCreditsToAllocate,\n        address _sender\n    ) internal onlyActiveAllocation {\n        // check the `_voiceCreditsToAllocate` is > 0\n        if (_voiceCreditsToAllocate == 0) revert INVALID();\n\n        // get the previous values\n        uint256 creditsCastToRecipient = _allocator.voiceCreditsCastToRecipient[_recipientId];\n        uint256 votesCastToRecipient = _allocator.votesCastToRecipient[_recipientId];\n\n        // get the total credits and calculate the vote result\n        uint256 totalCredits = _voiceCreditsToAllocate + creditsCastToRecipient;\n        uint256 voteResult = _sqrt(totalCredits * 1e18);\n\n        // update the values\n        voteResult -= votesCastToRecipient;\n        totalRecipientVotes += voteResult;\n        _recipient.totalVotesReceived += voteResult;\n\n        _allocator.voiceCreditsCastToRecipient[_recipientId] += totalCredits;\n        _allocator.votesCastToRecipient[_recipientId] += voteResult;\n\n        // emit the event with the vote results\n        emit Allocated(_recipientId, voteResult, _sender);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return If the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view virtual returns (bool);\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return If the allocator is valid\n    function _isValidAllocator(address _allocator) internal view virtual override returns (bool);\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return If the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        virtual\n        returns (bool);\n\n    /// @notice Get the payout for a single recipient\n    /// @param _recipientId The ID of the recipient\n    /// @return The payout as a 'PayoutSummary' struct\n    function _getPayout(address _recipientId, bytes memory)\n        internal\n        view\n        virtual\n        override\n        returns (PayoutSummary memory)\n    {\n        Recipient memory recipient = recipients[_recipientId];\n\n        // Calculate the payout amount based on the percentage of total votes\n        uint256 amount;\n        if (!paidOut[_recipientId] && totalRecipientVotes != 0) {\n            amount = poolAmount * recipient.totalVotesReceived / totalRecipientVotes;\n        }\n        return PayoutSummary(recipient.recipientAddress, amount);\n    }\n}"
    },
    {
      "filename": "contracts/strategies/qv-base/QVBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title QVBaseStrategy\n/// @notice Base strategy for quadratic voting strategies\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\nabstract contract QVBaseStrategy is BaseStrategy {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId ID of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    /// @param status The updated status of the recipient\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender, Status status);\n\n    /// @notice Emitted when a recipient is registered\n    /// @param recipientId ID of the recipient\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event RecipientStatusUpdated(address indexed recipientId, Status status, address sender);\n    /// @notice Emitted when the pool timestamps are updated\n    /// @param registrationStartTime The start time for the registration\n    /// @param registrationEndTime The end time for the registration\n    /// @param allocationStartTime The start time for the allocation\n    /// @param allocationEndTime The end time for the allocation\n    /// @param sender The sender of the transaction\n    event TimestampsUpdated(\n        uint64 registrationStartTime,\n        uint64 registrationEndTime,\n        uint64 allocationStartTime,\n        uint64 allocationEndTime,\n        address sender\n    );\n\n    /// @notice Emitted when a recipient receives votes\n    /// @param recipientId ID of the recipient\n    /// @param votes The votes allocated to the recipient\n    /// @param allocator The allocator assigning the votes\n    event Allocated(address indexed recipientId, uint256 votes, address allocator);\n\n    /// @notice Emitted when a recipient is reviewed\n    /// @param recipientId ID of the recipient\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event Reviewed(address indexed recipientId, Status status, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    // slot 0\n    /// @notice The total number of votes cast for all recipients\n    uint256 public totalRecipientVotes;\n\n    // slot 1\n    /// @notice The number of votes required to review a recipient\n    uint256 public reviewThreshold;\n\n    // slot 2\n    /// @notice The start and end times for registrations and allocations\n    /// @dev The values will be in milliseconds since the epoch\n    uint64 public registrationStartTime;\n    uint64 public registrationEndTime;\n    uint64 public allocationStartTime;\n    uint64 public allocationEndTime;\n\n    // slot 3\n    /// @notice Whether or not the strategy is using registry gating\n    bool public registryGating;\n\n    /// @notice Whether or not the strategy requires metadata\n    bool public metadataRequired;\n\n    /// @notice The registry contract\n    IRegistry private _registry;\n\n    // slots [4...n]\n    /// @notice The status of the recipient for this strategy only\n    /// @dev There is a core `IStrategy.RecipientStatus` that this should map to\n    enum InternalRecipientStatus {\n        None,\n        Pending,\n        Accepted,\n        Rejected,\n        Appealed\n    }\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParams {\n        // slot 0\n        bool registryGating;\n        bool metadataRequired;\n        // slot 1\n        uint256 reviewThreshold;\n        // slot 2\n        uint64 registrationStartTime;\n        uint64 registrationEndTime;\n        uint64 allocationStartTime;\n        uint64 allocationEndTime;\n    }\n\n    /// @notice The details of the recipient\n    struct Recipient {\n        // slot 0\n        uint256 totalVotesReceived;\n        // slot 1\n        bool useRegistryAnchor;\n        address recipientAddress;\n        Metadata metadata;\n        Status recipientStatus;\n    }\n\n    /// @notice The details of the allocator\n    struct Allocator {\n        // slot 0\n        uint256 voiceCredits;\n        // slots [1...n]\n        mapping(address => uint256) voiceCreditsCastToRecipient;\n        mapping(address => uint256) votesCastToRecipient;\n    }\n\n    /// @notice The details of the recipient are returned using their ID\n    /// @dev recipientId => Recipient\n    mapping(address => Recipient) public recipients;\n\n    /// @notice The details of the allocator are returned using their address\n    /// @dev allocator address => Allocator\n    mapping(address => Allocator) public allocators;\n\n    /// @notice Returns whether or not the recipient has been paid out using their ID\n    /// @dev recipientId => paid out\n    mapping(address => bool) public paidOut;\n\n    // recipientId -> status -> count\n    mapping(address => mapping(Status => uint256)) public reviewsByStatus;\n\n    /// ================================\n    /// ========== Modifier ============\n    /// ================================\n\n    /// @notice Modifier to check if the registration is active\n    /// @dev Reverts if the registration is not active\n    modifier onlyActiveRegistration() {\n        _checkOnlyActiveRegistration();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    modifier onlyActiveAllocation() {\n        _checkOnlyActiveAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    modifier onlyAfterAllocation() {\n        _checkOnlyAfterAllocation();\n        _;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ====================================\n    /// =========== Initialize =============\n    /// ====================================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    function initialize(uint256 _poolId, bytes memory _data) external virtual;\n\n    /// @notice Internal initialize function\n    /// @param _poolId The ID of the pool\n    /// @param _params The initialize params for the strategy\n    function __QVBaseStrategy_init(uint256 _poolId, InitializeParams memory _params) internal {\n        __BaseStrategy_init(_poolId);\n\n        registryGating = _params.registryGating;\n        metadataRequired = _params.metadataRequired;\n        _registry = allo.getRegistry();\n\n        reviewThreshold = _params.reviewThreshold;\n\n        _updatePoolTimestamps(\n            _params.registrationStartTime,\n            _params.registrationEndTime,\n            _params.allocationStartTime,\n            _params.allocationEndTime\n        );\n    }\n\n    /// =========================\n    /// ==== View Functions =====\n    /// =========================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    ///"
    }
  ]
}