{
  "Title": "M-1: governor can permanently prevent withdrawals in spite of being restricted",
  "Content": "# Issue M-1: governor can permanently prevent withdrawals in spite of being restricted \n\nSource: https://github.com/sherlock-audit/2023-10-aloe-judging/issues/35 \n\n## Found by \nroguereddwarf\nAccording to the Contest README (which is the highest order source of truth), the `governor` address should be restricted and not be able to prevent withdrawals from the `Lender`s.  \n\nThis doesn't hold true. By setting the interest rate that the borrowers have to pay to zero, the `governor` can effectively prevent withdrawals.  \n\n## Vulnerability Detail\nQuoting from the Contest README:  \n```text\nIs the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n\nRestricted. The governor address should not be able to steal funds or prevent users from withdrawing. It does have access to the govern methods in Factory, and it could trigger liquidations by increasing nSigma. We consider this an acceptable risk, and the governor itself will have a timelock.\n```\n\nThe mechanism by which users are ensured that they can withdraw their funds is the interest rate which increases with utilization.  \n\nMarket forces will keep the utilization in balance such that when users want to withdraw their funds from the `Lender` contracts, the interest rate increases and `Borrower`s pay back their loans (or get liquidated).  \n\nWhat the `governor` is allowed to do is to set a interest rate model via the [`Factory.governMarketConfig`](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/Factory.sol#L282-L303) function.  \n\nThe `SafeRateLib` is used to safely call the `RateModel` by e.g. handling the case when the call to the `RateModel` reverts and limiting the interest to a `MAX_RATE`: https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/RateModel.sol#L38-L60.  \n\nThis clearly shows that the `governor` should be very much restricted in setting the `RateModel` such as to not damage users of the protocol which is in line with how the `governor` role is described in the README.  \n\nHowever the interest rate can be set to zero even if the utilization is very high. If `Borrower`s can borrow funds for a zero interest rate, they will never pay back their loans. This means that users in the `Lender`s will never be able to withdraw their funds.  \n\nIt is also noteworthy that the timelock that the governor uses won't be able to prevent this scenario since even if users withdraw their funds as quickly as possible, there will probably not be enough time / availability of funds for everyone to withdraw in time (assuming a realistic timelock length).  \n\n## Impact\nThe `governor` is able to permanently prevent withdrawals from the `Lender`s which it should not be able to do according to the contest README.  \n\n## Code Snippet\nFunction to set the rate model:  \nhttps://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/Factory.sol#L282-L303\n\n`SafeRateLib` allows for a zero interest rate:  \nhttps://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/RateModel.sol#L38-L60\n\n## Tool used\nManual Review\n\n## Recommendation\nThe `SafeRateLib` should ensure that as the utilization approaches `1e18` (100%), the interest rate cannot be below a certain minimum value.\n\nThis ensures that even if the `governor` behaves maliciously or uses a broken `RateModel`, `Borrower`s will never borrow all funds without paying them back.  \n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> low, because even zero interest rates still enforce higher deposit than borrow, so there is still incentive for borrowers to return funds. 0 rate doesn't really lock the funds, just makes incentive to return them smaller, but I think it's still allowed according to protocol docs/rules, so is probably intended possibility.\n\n**MohammedRizwan** commented:\n>  invalid as governor actions are timelocked \n\n\n\n**panprog**\n\nEscalate\n\nI don't think this should be Medium, it's more info/low, because apparently 0 rates are allowed by the protocol which is the design decision and like I've mentioned in comments, there is still incentive to repay the borrow. I believe the following statements:\n\n> By setting the interest rate that the borrowers have to pay to zero, the governor can effectively prevent withdrawals.\n\n> If Borrowers can borrow funds for a zero interest rate, they will never pay back their loans.\n\nare incorrect. Governor **can't prevent withdrawals**. Governor can make it less attractive to withdraw, but can't prevent it. Borrowers can still repay their loans for different reasons, including their price risk, their requirements for collateral etc.\n\nAlso, I don't think it's possible to come up with any valid low limit for high utilization - setting this too low (like 0.01% or even 1%) will not change anything significantly for high volatility tokens. Setting this too high might be too high for, say, some stablecoins.\n\nSo my point is that 0 rates certainly create less incentive to repay loans, but it doesn't prevent repayments and it's hard to fix anyway.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> I don't think this should be Medium, it's more info/low, because apparently 0 rates are allowed by the protocol which is the design decision and like I've mentioned in comments, there is still incentive to repay the borrow. I believe the following statements:\n> \n> > By setting the interest rate that the borrowers have to pay to zero, the governor can effectively prevent withdrawals.\n> \n> > If Borrowers can borrow funds for a zero interest rate, they will never pay back their loans.\n> \n> are incorrect. Governor **can't prevent withdrawals**. Governor can make it less attractive to withdraw, but can't prevent it. Borrowers can still repay their loans for different reasons, including their price risk, their requirements for collateral etc.\n> \n> Also, I don't think it's possible to come up with any valid low limit for high utilization - setting this too low (like 0.01% or even 1%) will not change anything significantly for high volatility tokens. Setting this too high might be too high for, say, some stablecoins.\n> \n> So my point is that 0 rates certainly create less incentive to repay loans, but it doesn't prevent repayments and it's hard to fix anyway.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**roguereddwarf**\n\n@panprog \n\nWhat a zero interest rate allows is to gain leverage on your funds (collateral) for free.\nImagine a bank where you can deposit $100 to then be able to get $500 and invest in stocks without ever having to pay that back.\n\nIt is true that a borrower might no longer want to participate in borrowing:\n```including their price risk, their requirements for collateral etc.```\n\nBut then another borrower may just immediately take up the funds again (-> front-running since there is a for-profit incentive to do so).\n\nBut these are edge cases. In reality all funds from the Lender will just be used by Borrowers, meaning utilization will be 100%.\n\nAccording to the README this must not be possible.\n\nBeyond that, the \"hard to fix\" objection of yours seems invalid to me\n```\nAlso, I don't think it's possible to come up with any valid low limit for high utilization - setting this too low (like 0.01% or even 1%) will not change anything significantly for high volatility tokens. Setting this too high might be too high for, say, some stablecoins.\n\nSo my point is that 0 rates certainly create less incentive to repay loans, but it doesn't prevent repayments and it's hard to fix anyway.\n```\n\nYou can easily enforce a check that at a utilization rate of say 99%, that the interest rate cannot go below x%.\nSo all we need to do is to determine a cutoff for utilization where we enforce x% of minimum interest rate.\nx% just needs to be very costly. And since we only enforce it starting from 99% we can still have interest rates based on the specific pair for all utilization ratios from 0% to 99%.\n\n**haydenshively**\n\nMy view on this is that if governance sets a rate model that returns 0% interest (intentionally or otherwise), interested parties could create repayment incentives exogenous to the protocol. For example, \"Borrowers commit to close their positions by signing X. Lenders commit to give those Borrowers a rebate Y. Past some participation threshold Z, commitments are processed atomically and participating lenders receive (1 - Y)% of their funds.\"\n\nObviously this is roundabout and lossy, but I don't want to hardcode any utilization → interest rate relationships into the `SafeRateLib`. I'm hoping to implement PID-controlled rates in the future, and boundary conditions could make that difficult.\n\nI don't have an opinion on severity; just thought I'd explain why we're not going to fix it.\n\n**roguereddwarf**\n\nI understand. I still stick to my assessment of \"Medium\" severity as\n1) not being able to withdraw shouldn't be possible according to README\n2) the \"fix\" would create a loss due to having to pay the incentives. Also this is an argument of the kind \"not a big deal if we get hacked, we just pay the hacker and we're fine\"\n\n**cvetanovv**\n\nI think this issue should stay Medium. The sponsor confirmed the issue at the beginning and doesn't have a problem with being medium. Also in the README admin/owner is RESTRICTED.\n\n**Trumpero**\n\nPlanning to reject escalation and keep this issue medium because admin/owner is RESTRICTED in the contest readme.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [panprog](https://github.com/sherlock-audit/2023-10-aloe-judging/issues/35/#issuecomment-1801323246): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/120",
  "Code": [
    {
      "filename": "core/src/Factory.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\nimport {ERC20, SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {\n    DEFAULT_ANTE,\n    DEFAULT_N_SIGMA,\n    DEFAULT_MANIPULATION_THRESHOLD_DIVISOR,\n    DEFAULT_RESERVE_FACTOR,\n    CONSTRAINT_N_SIGMA_MIN,\n    CONSTRAINT_N_SIGMA_MAX,\n    CONSTRAINT_MANIPULATION_THRESHOLD_DIVISOR_MIN,\n    CONSTRAINT_MANIPULATION_THRESHOLD_DIVISOR_MAX,\n    CONSTRAINT_RESERVE_FACTOR_MIN,\n    CONSTRAINT_RESERVE_FACTOR_MAX,\n    CONSTRAINT_ANTE_MAX,\n    UNISWAP_AVG_WINDOW\n} from \"./libraries/constants/Constants.sol\";\n\nimport {Borrower} from \"./Borrower.sol\";\nimport {Lender} from \"./Lender.sol\";\nimport {IRateModel} from \"./RateModel.sol\";\nimport {VolatilityOracle} from \"./VolatilityOracle.sol\";\n\n/// @title Factory\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract Factory {\n    using ClonesWithImmutableArgs for address;\n    using SafeTransferLib for ERC20;\n\n    event CreateMarket(IUniswapV3Pool indexed pool, Lender lender0, Lender lender1);\n\n    event CreateBorrower(IUniswapV3Pool indexed pool, address indexed owner, Borrower account);\n\n    event EnrollCourier(uint32 indexed id, address indexed wallet, uint16 cut);\n\n    event SetMarketConfig(IUniswapV3Pool indexed pool, MarketConfig config);\n\n    // This `Factory` can create a `Market` for any Uniswap V3 pool\n    struct Market {\n        // The `Lender` of `token0` in the Uniswap pool\n        Lender lender0;\n        // The `Lender` of `token1` in the Uniswap pool\n        Lender lender1;\n        // The implementation to which all `Borrower` clones will point\n        Borrower borrowerImplementation;\n    }\n\n    // Each `Market` has a set of borrowing `Parameters` to help manage risk\n    struct Parameters {\n        // The amount of Ether a `Borrower` must hold in order to borrow assets\n        uint208 ante;\n        // To avoid liquidation, a `Borrower` must be solvent at TWAP * e^{± nSigma * IV}\n        uint8 nSigma;\n        // Borrowing is paused when the manipulation metric > threshold; this scales the threshold up/down\n        uint8 manipulationThresholdDivisor;\n        // The time at which borrowing can resume\n        uint32 pausedUntilTime;\n    }\n\n    // The set of all governable `Market` properties\n    struct MarketConfig {\n        // Described above\n        uint208 ante;\n        // Described above\n        uint8 nSigma;\n        // Described above\n        uint8 manipulationThresholdDivisor;\n        // The reserve factor for `market.lender0`, expressed as a reciprocal\n        uint8 reserveFactor0;\n        // The reserve factor for `market.lender1`, expressed as a reciprocal\n        uint8 reserveFactor1;\n        // The rate model for `market.lender0`\n        IRateModel rateModel0;\n        // The rate model for `market.lender1`\n        IRateModel rateModel1;\n    }\n\n    // By enrolling as a `Courier`, frontends can earn a portion of their users' interest\n    struct Courier {\n        // The address that receives earnings whenever users withdraw\n        address wallet;\n        // The portion of users' interest to take, expressed in basis points\n        uint16 cut;\n    }\n\n    /// @notice The only address that can propose new `MarketConfig`s and rewards programs\n    address public immutable GOVERNOR;\n\n    /// @notice The oracle to use for prices and implied volatility\n    VolatilityOracle public immutable ORACLE;\n\n    /// @notice The implementation to which all `Lender` clones will point\n    address public immutable LENDER_IMPLEMENTATION;\n\n    /// @notice A simple contract that deploys `Borrower`s to keep `Factory` bytecode size down\n    BorrowerDeployer private immutable _BORROWER_DEPLOYER;\n\n    /// @notice The rate model that `Lender`s will use when first created\n    IRateModel public immutable DEFAULT_RATE_MODEL;\n\n    /*//////////////////////////////////////////////////////////////\n                             WORLD STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the `Market` addresses associated with a Uniswap V3 pool\n    mapping(IUniswapV3Pool => Market) public getMarket;\n\n    /// @notice Returns the borrowing `Parameters` associated with a Uniswap V3 pool\n    mapping(IUniswapV3Pool => Parameters) public getParameters;\n\n    /// @notice Returns the other `Lender` in the `Market` iff input is itself a `Lender`, otherwise 0\n    mapping(address => address) public peer;\n\n    /// @notice Returns whether the given address is a `Borrower` deployed by this `Factory`\n    mapping(address => bool) public isBorrower;\n\n    /*//////////////////////////////////////////////////////////////\n                           INCENTIVE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The token in which rewards are paid out\n    ERC20 public rewardsToken;\n\n    /// @notice Returns the `Courier` for any given ID\n    mapping(uint32 => Courier) public couriers;\n\n    /// @notice Returns whether the given address has enrolled as a courier\n    mapping(address => bool) public isCourier;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        address governor,\n        address reserve,\n        VolatilityOracle oracle,\n        BorrowerDeployer borrowerDeployer,\n        IRateModel defaultRateModel\n    ) {\n        GOVERNOR = governor;\n        ORACLE = oracle;\n        LENDER_IMPLEMENTATION = address(new Lender(reserve));\n        _BORROWER_DEPLOYER = borrowerDeployer;\n        DEFAULT_RATE_MODEL = defaultRateModel;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               EMERGENCY\n    //////////////////////////////////////////////////////////////*/\n\n    function pause(IUniswapV3Pool pool, uint40 oracleSeed) external {\n        (, bool seemsLegit) = getMarket[pool].borrowerImplementation.getPrices(oracleSeed);\n        if (seemsLegit) return;\n\n        unchecked {\n            getParameters[pool].pausedUntilTime = uint32(block.timestamp) + UNISWAP_AVG_WINDOW;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             WORLD CREATION\n    //////////////////////////////////////////////////////////////*/\n\n    function createMarket(IUniswapV3Pool pool) external {\n        ORACLE.prepare(pool);\n\n        address asset0 = pool.token0();\n        address asset1 = pool.token1();\n\n        // Deploy market-specific components\n        bytes32 salt = keccak256(abi.encodePacked(pool));\n        Lender lender0 = Lender(LENDER_IMPLEMENTATION.cloneDeterministic({salt: salt, data: abi.encodePacked(asset0)}));\n        Lender lender1 = Lender(LENDER_IMPLEMENTATION.cloneDeterministic({salt: salt, data: abi.encodePacked(asset1)}));\n        Borrower borrowerImplementation = _newBorrower(pool, lender0, lender1);\n\n        // Store deployment addresses\n        getMarket[pool] = Market(lender0, lender1, borrowerImplementation);\n        peer[address(lender0)] = address(lender1);\n        peer[address(lender1)] = address(lender0);\n\n        // Initialize lenders and set default market config\n        lender0.initialize();\n        lender1.initialize();\n        _setMarketConfig(\n            pool,\n            MarketConfig(\n                DEFAULT_ANTE,\n                DEFAULT_N_SIGMA,\n                DEFAULT_MANIPULATION_THRESHOLD_DIVISOR,\n                DEFAULT_RESERVE_FACTOR,\n                DEFAULT_RESERVE_FACTOR,\n                DEFAULT_RATE_MODEL,\n                DEFAULT_RATE_MODEL\n            ),\n            0\n        );\n\n        emit CreateMarket(pool, lender0, lender1);\n    }\n\n    function createBorrower(IUniswapV3Pool pool, address owner, bytes12 salt) external returns (Borrower borrower) {\n        Market memory market = getMarket[pool];\n\n        borrower = Borrower(\n            address(market.borrowerImplementation).cloneDeterministic({\n                salt: bytes32(bytes.concat(bytes20(msg.sender), salt)),\n                data: abi.encodePacked(owner)\n            })\n        );\n        isBorrower[address(borrower)] = true;\n\n        market.lender0.whitelist(address(borrower));\n        market.lender1.whitelist(address(borrower));\n\n        emit CreateBorrower(pool, owner, borrower);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INCENTIVES\n    //////////////////////////////////////////////////////////////*/\n\n    function claimRewards(Lender[] calldata lenders, address beneficiary) external returns (uint256 earned) {\n        // Couriers cannot claim rewards because the accounting isn't quite correct for them. Specifically, we\n        // save gas by omitting a `Rewards.updateUserState` call for the courier in `Lender._burn`\n        require(!isCourier[msg.sender]);\n\n        unchecked {\n            uint256 count = lenders.length;\n            for (uint256 i = 0; i < count; i++) {\n                // Make sure it is, in fact, a `Lender`\n                require(peer[address(lenders[i])] != address(0));\n                earned += lenders[i].claimRewards(msg.sender);\n            }\n        }\n\n        rewardsToken.safeTransfer(beneficiary, earned);\n    }\n\n    /**\n     * @notice Enrolls `msg.sender` in the referral program. This allows frontends/wallets/apps to\n     * credit themselves for a given user's deposit, and receive a portion of their interest. Note\n     * that after enrolling, `msg.sender` will not be eligible for `REWARDS_TOKEN` rewards.\n     * @dev See `Lender.creditCourier`\n     * @param id A unique identifier for the courier\n     * @param cut The portion of interest the courier will receive. Should be in the range [0, 10000),\n     * with 10000 being 100%.\n     */\n    function enrollCourier(uint32 id, uint16 cut) external {\n        // Requirements:\n        // - `id != 0` because 0 is reserved as the no-courier case\n        // - `cut != 0 && cut < 10_000` just means between 0 and 100%\n        require(id != 0 && cut != 0 && cut < 10_000);\n        // Once an `id` has been enrolled, its info can't be changed\n        require(couriers[id].cut == 0);\n\n        couriers[id] = Courier(msg.sender, cut);\n        isCourier[msg.sender] = true;\n\n        emit EnrollCourier(id, msg.sender, cut);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               GOVERNANCE\n    //////////////////////////////////////////////////////////////*/\n\n    function governRewardsToken(ERC20 rewardsToken_) external {\n        require(msg.sender == GOVERNOR && address(rewardsToken) == address(0));\n        rewardsToken = rewardsToken_;\n    }\n\n    function governRewardsRate(Lender lender, uint56 rate) external {\n        require(msg.sender == GOVERNOR);\n        lender.setRewardsRate(rate);\n    }\n\n    function governMarketConfig(IUniswapV3Pool pool, MarketConfig memory config) external {\n        require(msg.sender == GOVERNOR);\n\n        require(\n            // ante: max\n            (config.ante <= CONSTRAINT_ANTE_MAX) &&\n                // nSigma: min, max\n                (CONSTRAINT_N_SIGMA_MIN <= config.nSigma && config.nSigma <= CONSTRAINT_N_SIGMA_MAX) &&\n                // manipulationThresholdDivisor: min, max\n                (CONSTRAINT_MANIPULATION_THRESHOLD_DIVISOR_MIN <= config.manipulationThresholdDivisor &&\n                    config.manipulationThresholdDivisor <= CONSTRAINT_MANIPULATION_THRESHOLD_DIVISOR_MAX) &&\n                // reserveFactor0: min, max\n                (CONSTRAINT_RESERVE_FACTOR_MIN <= config.reserveFactor0 &&\n                    config.reserveFactor0 <= CONSTRAINT_RESERVE_FACTOR_MAX) &&\n                // reserveFactor1: min, max\n                (CONSTRAINT_RESERVE_FACTOR_MIN <= config.reserveFactor1 &&\n                    config.reserveFactor1 <= CONSTRAINT_RESERVE_FACTOR_MAX),\n            \"Aloe: constraints\"\n        );\n\n        _setMarketConfig(pool, config, getParameters[pool].pausedUntilTime);\n    }\n\n    function _setMarketConfig(IUniswapV3Pool pool, MarketConfig memory config, uint32 pausedUntilTime) private {\n        getParameters[pool] = Parameters({\n            ante: config.ante,\n            nSigma: config.nSigma,\n            manipulationThresholdDivisor: config.manipulationThresholdDivisor,\n            pausedUntilTime: pausedUntilTime\n        });\n\n        Market memory market = getMarket[pool];\n        market.lender0.setRateModelAndReserveFactor(config.rateModel0, config.reserveFactor0);\n        market.lender1.setRateModelAndReserveFactor(config.rateModel1, config.reserveFactor1);\n\n        emit SetMarketConfig(pool, config);\n    }\n\n    function _newBorrower(IUniswapV3Pool pool, Lender lender0, Lender lender1) private returns (Borrower) {\n        (bool success, bytes memory data) = address(_BORROWER_DEPLOYER).delegatecall(\n            abi.encodeCall(BorrowerDeployer.deploy, (ORACLE, pool, lender0, lender1))\n        );\n        require(success);\n        return abi.decode(data, (Borrower));\n    }\n}\n\ncontract BorrowerDeployer {\n    function deploy(\n        VolatilityOracle oracle,\n        IUniswapV3Pool pool,\n        Lender lender0,\n        Lender lender1\n    ) external returns (Borrower) {\n        return new Borrower(oracle, pool, lender0, lender1);\n    }\n}"
    },
    {
      "filename": "core/src/RateModel.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {MAX_RATE, ONE} from \"./libraries/constants/Constants.sol\";\n\ninterface IRateModel {\n    /**\n     * @notice Specifies the percentage yield per second for a `lender`. Need not be a pure function\n     * of `utilization`. To convert to APY: `(1 + returnValue / 1e12) ** secondsPerYear - 1`\n     * @param utilization The `lender`'s total borrows divided by total assets, scaled up by 1e18\n     * @param lender The `Lender` to examine\n     * @return The percentage yield per second, scaled up by 1e12\n     */\n    function getYieldPerSecond(uint256 utilization, address lender) external view returns (uint256);\n}\n\n/// @title RateModel\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract RateModel is IRateModel {\n    uint256 private constant _A = 6.1010463348e20;\n\n    uint256 private constant _B = _A / 1e18;\n\n    /// @inheritdoc IRateModel\n    function getYieldPerSecond(uint256 utilization, address) external pure returns (uint256) {\n        unchecked {\n            return (utilization < 0.99e18) ? _A / (1e18 - utilization) - _B : 60400;\n        }\n    }\n}\n\nlibrary SafeRateLib {\n    using FixedPointMathLib for uint256;\n\n    function getAccrualFactor(IRateModel rateModel, uint256 utilization, uint256 dt) internal view returns (uint256) {\n        uint256 rate;\n\n        // Essentially `rate = rateModel.getYieldPerSecond(utilization, address(this)) ?? 0`, i.e. if the call\n        // fails, we set `rate = 0` instead of reverting. Solidity's try/catch could accomplish the same thing,\n        // but this is slightly more gas efficient.\n        bytes memory encodedCall = abi.encodeCall(IRateModel.getYieldPerSecond, (utilization, address(this)));\n        assembly (\"memory-safe\") {\n            let success := staticcall(100000, rateModel, add(encodedCall, 32), mload(encodedCall), 0, 32)\n            rate := mul(success, mload(0))\n        }\n\n        return _computeAccrualFactor(rate, dt);\n    }\n\n    function _computeAccrualFactor(uint256 rate, uint256 dt) private pure returns (uint256) {\n        if (rate > MAX_RATE) rate = MAX_RATE;\n        if (dt > 1 weeks) dt = 1 weeks;\n\n        unchecked {\n            return (ONE + rate).rpow(dt, ONE);\n        }\n    }\n}"
    },
    {
      "filename": "core/src/Factory.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\nimport {ERC20, SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {\n    DEFAULT_ANTE,\n    DEFAULT_N_SIGMA,\n    DEFAULT_MANIPULATION_THRESHOLD_DIVISOR,\n    DEFAULT_RESERVE_FACTOR,\n    CONSTRAINT_N_SIGMA_MIN,\n    CONSTRAINT_N_SIGMA_MAX,\n    CONSTRAINT_MANIPULATION_THRESHOLD_DIVISOR_MIN,\n    CONSTRAINT_MANIPULATION_THRESHOLD_DIVISOR_MAX,\n    CONSTRAINT_RESERVE_FACTOR_MIN,\n    CONSTRAINT_RESERVE_FACTOR_MAX,\n    CONSTRAINT_ANTE_MAX,\n    UNISWAP_AVG_WINDOW\n} from \"./libraries/constants/Constants.sol\";\n\nimport {Borrower} from \"./Borrower.sol\";\nimport {Lender} from \"./Lender.sol\";\nimport {IRateModel} from \"./RateModel.sol\";\nimport {VolatilityOracle} from \"./VolatilityOracle.sol\";\n\n/// @title Factory\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract Factory {\n    using ClonesWithImmutableArgs for address;\n    using SafeTransferLib for ERC20;\n\n    event CreateMarket(IUniswapV3Pool indexed pool, Lender lender0, Lender lender1);\n\n    event CreateBorrower(IUniswapV3Pool indexed pool, address indexed owner, Borrower account);\n\n    event EnrollCourier(uint32 indexed id, address indexed wallet, uint16 cut);\n\n    event SetMarketConfig(IUniswapV3Pool indexed pool, MarketConfig config);\n\n    // This `Factory` can create a `Market` for any Uniswap V3 pool\n    struct Market {\n        // The `Lender` of `token0` in the Uniswap pool\n        Lender lender0;\n        // The `Lender` of `token1` in the Uniswap pool\n        Lender lender1;\n        // The implementation to which all `Borrower` clones will point\n        Borrower borrowerImplementation;\n    }\n\n    // Each `Market` has a set of borrowing `Parameters` to help manage risk\n    struct Parameters {\n        // The amount of Ether a `Borrower` must hold in order to borrow assets\n        uint208 ante;\n        // To avoid liquidation, a `Borrower` must be solvent at TWAP * e^{± nSigma * IV}\n        uint8 nSigma;\n        // Borrowing is paused when the manipulation metric > threshold; this scales the threshold up/down\n        uint8 manipulationThresholdDivisor;\n        // The time at which borrowing can resume\n        uint32 pausedUntilTime;\n    }\n\n    // The set of all governable `Market` properties\n    struct MarketConfig {\n        // Described above\n        uint208 ante;\n        // Described above\n        uint8 nSigma;\n        // Described above\n        uint8 manipulationThresholdDivisor;\n        // The reserve factor for `market.lender0`, expressed as a reciprocal\n        uint8 reserveFactor0;\n        // The reserve factor for `market.lender1`, expressed as a reciprocal\n        uint8 reserveFactor1;\n        // The rate model for `market.lender0`\n        IRateModel rateModel0;\n        // The rate model for `market.lender1`\n        IRateModel rateModel1;\n    }\n\n    // By enrolling as a `Courier`, frontends can earn a portion of their users' interest\n    struct Courier {\n        // The address that receives earnings whenever users withdraw\n        address wallet;\n        // The portion of users' interest to take, expressed in basis points\n        uint16 cut;\n    }\n\n    /// @notice The only address that can propose new `MarketConfig`s and rewards programs\n    address public immutable GOVERNOR;\n\n    /// @notice The oracle to use for prices and implied volatility\n    VolatilityOracle public immutable ORACLE;\n\n    /// @notice The implementation to which all `Lender` clones will point\n    address public immutable LENDER_IMPLEMENTATION;\n\n    /// @notice A simple contract that deploys `Borrower`s to keep `Factory` bytecode size down\n    BorrowerDeployer private immutable _BORROWER_DEPLOYER;\n\n    /// @notice The rate model that `Lender`s will use when first created\n    IRateModel public immutable DEFAULT_RATE_MODEL;\n\n    /*//////////////////////////////////////////////////////////////\n                             WORLD STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the `Market` addresses associated with a Uniswap V3 pool\n    mapping(IUniswapV3Pool => Market) public getMarket;\n\n    /// @notice Returns the borrowing `Parameters` associated with a Uniswap V3 pool\n    mapping(IUniswapV3Pool => Parameters) public getParameters;\n\n    /// @notice Returns the other `Lender` in the `Market` iff input is itself a `Lender`, otherwise 0\n    mapping(address => address) public peer;\n\n    /// @notice Returns whether the given address is a `Borrower` deployed by this `Factory`\n    mapping(address => bool) public isBorrower;\n\n    /*//////////////////////////////////////////////////////////////\n                           INCENTIVE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The token in which rewards are paid out\n    ERC20 public rewardsToken;\n\n    /// @notice Returns the `Courier` for any given ID\n    mapping(uint32 => Courier) public couriers;\n\n    /// @notice Returns whether the given address has enrolled as a courier\n    mapping(address => bool) public isCourier;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        address governor,\n        address reserve,\n        VolatilityOracle oracle,\n        BorrowerDeployer borrowerDeployer,\n        IRateModel defaultRateModel\n    ) {\n        GOVERNOR = governor;\n        ORACLE = oracle;\n        LENDER_IMPLEMENTATION = address(new Lender(reserve));\n        _BORROWER_DEPLOYER = borrowerDeployer;\n        DEFAULT_RATE_MODEL = defaultRateModel;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               EMERGENCY\n    //////////////////////////////////////////////////////////////*/\n\n    function pause(IUniswapV3Pool pool, uint40 oracleSeed) external {\n        (, bool seemsLegit) = getMarket[pool].borrowerImplementation.getPrices(oracleSeed);\n        if (seemsLegit) return;\n\n        unchecked {\n            getParameters[pool].pausedUntilTime = uint32(block.timestamp) + UNISWAP_AVG_WINDOW;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             WORLD CREATION\n    //////////////////////////////////////////////////////////////*/\n\n    function createMarket(IUniswapV3Pool pool) external {\n        ORACLE.prepare(pool);\n\n        address asset0 = pool.token0();\n        address asset1 = pool.token1();\n\n        // Deploy market-specific components\n        bytes32 salt = keccak256(abi.encodePacked(pool));\n        Lender lender0 = Lender(LENDER_IMPLEMENTATION.cloneDeterministic({salt: salt, data: abi.encodePacked(asset0)}));\n        Lender lender1 = Lender(LENDER_IMPLEMENTATION.cloneDeterministic({salt: salt, data: abi.encodePacked(asset1)}));\n        Borrower borrowerImplementation = _newBorrower(pool, lender0, lender1);\n\n        // Store deployment addresses\n        getMarket[pool] = Market(lender0, lender1, borrowerImplementation);\n        peer[address(lender0)] = address(lender1);\n        peer[address(lender1)] = address(lender0);\n\n        // Initialize lenders and set default market config\n        lender0.initialize();\n        lender1.initialize();\n        _setMarketConfig(\n            pool,\n            MarketConfig(\n                DEFAULT_ANTE,\n                DEFAULT_N_SIGMA,\n                DEFAULT_MANIPULATION_THRESHOLD_DIVISOR,\n                DEFAULT_RESERVE_FACTOR,\n                DEFAULT_RESERVE_FACTOR,\n                DEFAULT_RATE_MODEL,\n                DEFAULT_RATE_MODEL\n            ),\n            0\n        );\n\n        emit CreateMarket(pool, lender0, lender1);\n    }\n\n    function createBorrower(IUniswapV3Pool pool, address owner, bytes12 salt) external returns (Borrower borrower) {\n        Market memory market = getMarket[pool];\n\n        borrower = Borrower(\n            address(market.borrowerImplementation).cloneDeterministic({\n                salt: bytes32(bytes.concat(bytes20(msg.sender), salt)),\n                data: abi.encodePacked(owner)\n            })\n        );\n        isBorrower[address(borrower)] = true;\n\n        market.lender0.whitelist(address(borrower));\n        market.lender1.whitelist(address(borrower));\n\n        emit CreateBorrower(pool, owner, borrower);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INCENTIVES\n    //////////////////////////////////////////////////////////////*/\n\n    function claimRewards(Lender[] calldata lenders, address beneficiary) external returns (uint256 earned) {\n        // Couriers cannot claim rewards because the accounting isn't quite correct for them. Specifically, we\n        // save gas by omitting a `Rewards.updateUserState` call for the courier in `Lender._burn`\n        require(!isCourier[msg.sender]);\n\n        unchecked {\n            uint256 count = lenders.length;\n            for (uint256 i = 0; i < count; i++) {\n                // Make sure it is, in fact, a `Lender`\n                require(peer[address(lenders[i])] != address(0));\n                earned += lenders[i].claimRewards(msg.sender);\n            }\n        }\n\n        rewardsToken.safeTransfer(beneficiary, earned);\n    }\n\n    /**\n     * @notice Enrolls `msg.sender` in the referral program. This allows frontends/wallets/apps to\n     * credit themselves for a given user's deposit, and receive a portion of their interest. Note\n     * that after enrolling, `msg.sender` will not be eligible for `REWARDS_TOKEN` rewards.\n     * @dev See `Lender.creditCourier`\n     * @param id A unique identifier for the courier\n     * @param cut The portion of interest the courier will receive. Should be in the range [0, 10000),\n     * with 10000 being 100%.\n     */\n    function enrollCourier(uint32 id, uint16 cut) external {\n        // Requirements:\n        // - `id != 0` because 0 is reserved as the no-courier case\n        // - `cut != 0 && cut < 10_000` just means between 0 and 100%\n        require(id != 0 && cut != 0 && cut < 10_000);\n        // Once an `id` has been enrolled, its info can't be changed\n        require(couriers[id].cut == 0);\n\n        couriers[id] = Courier(msg.sender, cut);\n        isCourier[msg.sender] = true;\n\n        emit EnrollCourier(id, msg.sender, cut);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               GOVERNANCE\n    //////////////////////////////////////////////////////////////*/\n\n    function governRewardsToken(ERC20 rewardsToken_) external {\n        require(msg.sender == GOVERNOR && address(rewardsToken) == address(0));\n        rewardsToken = rewardsToken_;\n    }\n\n    function governRewardsRate(Lender lender, uint56 rate) external {\n        require(msg.sender == GOVERNOR);\n        lender.setRewardsRate(rate);\n    }\n\n    function governMarketConfig(IUniswapV3Pool pool, MarketConfig memory config) external {\n        require(msg.sender == GOVERNOR);\n\n        require(\n            // ante: max\n            (config.ante <= CONSTRAINT_ANTE_MAX) &&\n                // nSigma: min, max\n                (CONSTRAINT_N_SIGMA_MIN <= config.nSigma && config.nSigma <= CONSTRAINT_N_SIGMA_MAX) &&\n                // manipulationThresholdDivisor: min, max\n                (CONSTRAINT_MANIPULATION_THRESHOLD_DIVISOR_MIN <= config.manipulationThresholdDivisor &&\n                    config.manipulationThresholdDivisor <= CONSTRAINT_MANIPULATION_THRESHOLD_DIVISOR_MAX) &&\n                // reserveFactor0: min, max\n                (CONSTRAINT_RESERVE_FACTOR_MIN <= config.reserveFactor0 &&\n                    config.reserveFactor0 <= CONSTRAINT_RESERVE_FACTOR_MAX) &&\n                // reserveFactor1: min, max\n                (CONSTRAINT_RESERVE_FACTOR_MIN <= config.reserveFactor1 &&\n                    config.reserveFactor1 <= CONSTRAINT_RESERVE_FACTOR_MAX),\n            \"Aloe: constraints\"\n        );\n\n        _setMarketConfig(pool, config, getParameters[pool].pausedUntilTime);\n    }\n\n    function _setMarketConfig(IUniswapV3Pool pool, MarketConfig memory config, uint32 pausedUntilTime) private {\n        getParameters[pool] = Parameters({\n            ante: config.ante,\n            nSigma: config.nSigma,\n            manipulationThresholdDivisor: config.manipulationThresholdDivisor,\n            pausedUntilTime: pausedUntilTime\n        });\n\n        Market memory market = getMarket[pool];\n        market.lender0.setRateModelAndReserveFactor(config.rateModel0, config.reserveFactor0);\n        market.lender1.setRateModelAndReserveFactor(config.rateModel1, config.reserveFactor1);\n\n        emit SetMarketConfig(pool, config);\n    }\n\n    function _newBorrower(IUniswapV3Pool pool, Lender lender0, Lender lender1) private returns (Borrower) {\n        (bool success, bytes memory data) = address(_BORROWER_DEPLOYER).delegatecall(\n            abi.encodeCall(BorrowerDeployer.deploy, (ORACLE, pool, lender0, lender1))\n        );\n        require(success);\n        return abi.decode(data, (Borrower));\n    }\n}\n\ncontract BorrowerDeployer {\n    function deploy(\n        VolatilityOracle oracle,\n        IUniswapV3Pool pool,\n        Lender lender0,\n        Lender lender1\n    ) external returns (Borrower) {\n        return new Borrower(oracle, pool, lender0, lender1);\n    }\n}"
    },
    {
      "filename": "core/src/RateModel.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {MAX_RATE, ONE} from \"./libraries/constants/Constants.sol\";\n\ninterface IRateModel {\n    /**\n     * @notice Specifies the percentage yield per second for a `lender`. Need not be a pure function\n     * of `utilization`. To convert to APY: `(1 + returnValue / 1e12) ** secondsPerYear - 1`\n     * @param utilization The `lender`'s total borrows divided by total assets, scaled up by 1e18\n     * @param lender The `Lender` to examine\n     * @return The percentage yield per second, scaled up by 1e12\n     */\n    function getYieldPerSecond(uint256 utilization, address lender) external view returns (uint256);\n}\n\n/// @title RateModel\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract RateModel is IRateModel {\n    uint256 private constant _A = 6.1010463348e20;\n\n    uint256 private constant _B = _A / 1e18;\n\n    /// @inheritdoc IRateModel\n    function getYieldPerSecond(uint256 utilization, address) external pure returns (uint256) {\n        unchecked {\n            return (utilization < 0.99e18) ? _A / (1e18 - utilization) - _B : 60400;\n        }\n    }\n}\n\nlibrary SafeRateLib {\n    using FixedPointMathLib for uint256;\n\n    function getAccrualFactor(IRateModel rateModel, uint256 utilization, uint256 dt) internal view returns (uint256) {\n        uint256 rate;\n\n        // Essentially `rate = rateModel.getYieldPerSecond(utilization, address(this)) ?? 0`, i.e. if the call\n        // fails, we set `rate = 0` instead of reverting. Solidity's try/catch could accomplish the same thing,\n        // but this is slightly more gas efficient.\n        bytes memory encodedCall = abi.encodeCall(IRateModel.getYieldPerSecond, (utilization, address(this)));\n        assembly (\"memory-safe\") {\n            let success := staticcall(100000, rateModel, add(encodedCall, 32), mload(encodedCall), 0, 32)\n            rate := mul(success, mload(0))\n        }\n\n        return _computeAccrualFactor(rate, dt);\n    }\n\n    function _computeAccrualFactor(uint256 rate, uint256 dt) private pure returns (uint256) {\n        if (rate > MAX_RATE) rate = MAX_RATE;\n        if (dt > 1 weeks) dt = 1 weeks;\n\n        unchecked {\n            return (ONE + rate).rpow(dt, ONE);\n        }\n    }\n}"
    }
  ]
}