{
  "Title": "[M-03] Issue from previous audit still present: Gauge can have bigger weight than was intended by protocol",
  "Content": "\n[M-01 from previous audit is still present](https://github.com/code-423n4/2023-08-verwa-findings/issues/294). In this issue, the sponsor said [they fixed it](https://github.com/code-423n4/2023-08-verwa-findings/issues/294#issuecomment-1698755740). I tried to check how it was fixed, but the link doesn't work for me.\n\nBut `change_gauge_weight` function [still exists](https://github.com/code-423n4/2024-03-neobase/blob/main/src/GaugeController.sol#L346-L348) which makes it possible to reproduce this. Also `remove_gauge_weight` function is present, that allows [to completely remove gauge](https://github.com/code-423n4/2024-03-neobase/blob/main/src/GaugeController.sol#L378-L380) and i think that fix was to remove `change_gauge_weight` function.\n\n### Impact\n\nGauge can have bigger weight than was intended by protocol.\n\n### Tools Used\n\nVsCode\n\n### Recommendation\n\nRemove `change_gauge_weight` function.\n\n### Assessed type\n\nError\n\n**[zjesko (Neobase) confirmed](https://github.com/code-423n4/2024-03-neobase-findings/issues/17#issuecomment-2040754015)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-neobase",
  "Code": [
    {
      "filename": "src/GaugeController.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title  GaugeController\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///         mkt.market - Porting to Solidity with some modifications (this version)\n/// @notice Allows users to vote on distribution of CANTO that the contract receives from governance. Modifications from Curve:\n///         - Different whitelisting of gauge addresses\n///         - Removal of gauges\ncontract GaugeController {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Events\n    event NewType(string mame, int128 type_id);\n    event NewGauge(address indexed gauge_address, int128 gauge_type);\n    event GaugeRemoved(address indexed gauge_address);\n\n    // State\n    VotingEscrow public votingEscrow;\n    address public governance;\n\n    int128 public n_gauge_types;\n    mapping(int128 => string) public gauge_type_names;\n    // we increment values by 1 prior to storing them here so we can rely on a value\n    // of zero as meaning the gauge has not been set\n    mapping(address => int128) public gauge_types_;\n\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes;\n    mapping(address => uint256) public vote_user_power;\n    mapping(address => mapping(address => uint256)) public last_user_vote;\n\n    mapping(address => mapping(uint256 => Point)) public points_weight;\n    mapping(address => mapping(uint256 => uint256)) public changes_weight;\n    mapping(address => uint256) time_weight;\n\n    mapping(int128 => mapping(uint256 => Point)) points_sum;\n    mapping(int128 => mapping(uint256 => uint256)) changes_sum;\n    mapping(int128 => uint256) public time_sum;\n\n    mapping(uint256 => uint256) points_total;\n    uint256 time_total;\n\n    mapping(int128 => mapping(uint256 => uint256)) points_type_weight;\n    mapping(int128 => uint256) time_type_weight;\n\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    /// @notice Initializes state\n    /// @param _votingEscrow The voting escrow address\n    constructor(address _votingEscrow, address _governance) {\n        votingEscrow = VotingEscrow(_votingEscrow);\n        governance = _governance;\n        uint256 last_epoch = (block.timestamp / WEEK) * WEEK;\n        time_total = last_epoch;\n    }\n\n    /// @notice Set governance address\n    /// @param _governance New governance address\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n    }\n\n    // @notice Get gauge type for address\n    // @param _addr Gauge address\n    // @return Gauge type id\n    function gauge_types(address _addr) external view returns (int128) {\n        int128 gauge_type = gauge_types_[_addr];\n        require(gauge_type != 0, \"Invalid gauge address\");\n\n        return gauge_type - 1;\n    }\n\n    /// @notice Fill historic type weights week-over-week for missed checkins\n    /// and return the type weight for the future week\n    /// @param gauge_type Gauge type id\n    /// @return Type weight\n    function _get_type_weight(int128 gauge_type) internal returns (uint256) {\n        uint256 t = time_type_weight[gauge_type];\n        if (t > 0) {\n            uint256 w = points_type_weight[gauge_type][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                points_type_weight[gauge_type][t] = w;\n                if (t > block.timestamp) time_type_weight[gauge_type] = t;\n            }\n            return w;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins and return the sum for the future week\n    /// @return Sum of weights\n    function _get_sum(int128 gauge_type) internal returns (uint256) {\n        uint256 t = time_sum[gauge_type];\n        if (t > 0) {\n            Point memory pt = points_sum[gauge_type][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_sum[gauge_type][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_sum[gauge_type][t] = pt;\n                if (t > block.timestamp) time_sum[gauge_type] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    // @notice Fill historic total weights week-over-week for missed checkins\n    // and return the total for the future week\n    // @return Total weight\n    function _get_total() internal returns (uint256) {\n        uint256 t = time_total;\n        int128 _n_gauge_types = n_gauge_types;\n        if (t > block.timestamp) {\n            // If we have already checkpointed - still need to change the value\n            t -= WEEK;\n        }\n        uint256 pt = points_total[t];\n\n        for (int128 gauge_type; gauge_type < _n_gauge_types; ++gauge_type) {\n            _get_sum(gauge_type);\n            _get_type_weight(gauge_type);\n        }\n\n        for (uint256 i; i < 500; ++i) {\n            if (t > block.timestamp) break;\n            t += WEEK;\n            pt = 0;\n            for (int128 gauge_type; gauge_type < _n_gauge_types; ++gauge_type) {\n                uint256 type_sum = points_sum[gauge_type][t].bias;\n                uint256 type_weight = points_type_weight[gauge_type][t];\n                pt += type_sum * type_weight;\n            }\n            points_total[t] = pt;\n\n            if (t > block.timestamp) {\n                time_total = t;\n            }\n        }\n        return pt;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\n    /// and return the total for the future week\n    /// @param _gauge_addr Address of the gauge\n    /// @return Gauge weight\n    function _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Add a new gauge, only callable by governance\n    /// @param addr The gauge address\n    /// @param gauge_type The gauge type\n    function add_gauge(address addr, int128 gauge_type) external onlyGovernance {\n        require(gauge_type >= 0 && gauge_type < n_gauge_types, \"Invalid gauge type\");\n        require(gauge_types_[addr] == 0, \"Gauge already exists\");\n\n        gauge_types_[addr] = gauge_type + 1;\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        _change_gauge_weight(addr, 0);\n\n        if (time_sum[gauge_type] == 0) time_sum[gauge_type] = next_time;\n        time_weight[addr] = next_time;\n\n        emit NewGauge(addr, gauge_type);\n    }\n\n    /// @notice Remove a gauge, only callable by governance\n    /// @dev Sets the gauge weight to 0\n    /// @param _gauge The gauge address\n    function remove_gauge(address _gauge) external onlyGovernance {\n        require(gauge_types_[_gauge] != 0, \"Invalid gauge address\");\n        gauge_types_[_gauge] = 0;\n        _remove_gauge_weight(_gauge);\n        emit GaugeRemoved(_gauge);\n    }\n\n    /// @notice Checkpoint to fill data common for all gauges\n    function checkpoint() external {\n        _get_total();\n    }\n\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    /// @param _gauge The gauge address\n    function checkpoint_gauge(address _gauge) external {\n        _get_weight(_gauge);\n        _get_total();\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function _gauge_relative_weight(address _gauge, uint256 _time) private view returns (uint256) {\n        uint256 t = (_time / WEEK) * WEEK;\n        uint256 total_weight = points_total[t];\n        if (total_weight > 0) {\n            int128 gauge_type = gauge_types_[_gauge] - 1;\n            uint256 _type_weight = points_type_weight[gauge_type][t];\n            uint256 gauge_weight = points_weight[_gauge][t].bias;\n            return (MULTIPLIER * _type_weight * gauge_weight) / total_weight;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight(address _gauge, uint256 _time) external view returns (uint256) {\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n    ///     values for type and gauge records\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight_write(address _gauge, uint256 _time) external returns (uint256) {\n        _get_weight(_gauge);\n        _get_total();\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    // @notice Change type weight\n    // @param type_id Type id\n    // @param weight New type weight\n    function _change_type_weight(int128 type_id, uint256 weight) internal {\n        uint256 old_weight = _get_type_weight(type_id);\n        uint256 old_sum = _get_sum(type_id);\n        uint256 _total_weight = _get_total();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        _total_weight = _total_weight + old_sum * weight - old_sum * old_weight;\n        points_total[next_time] = _total_weight;\n        points_type_weight[type_id][next_time] = weight;\n        time_total = next_time;\n        time_type_weight[type_id] = next_time;\n    }\n\n    // @notice Add gauge type with name `_name` and weight `weight`\n    // @param _name Name of gauge type\n    // @param weight Weight of gauge type\n    function add_type(string memory _name, uint256 _weight) external onlyGovernance {\n        int128 type_id = n_gauge_types;\n        gauge_type_names[type_id] = _name;\n        n_gauge_types = type_id + 1;\n        if (_weight != 0) {\n            _change_type_weight(type_id, _weight);\n        }\n        emit NewType(_name, type_id);\n    }\n\n    // @notice Change gauge type `type_id` weight to `weight`\n    // @param type_id Gauge type id\n    // @param weight New Gauge weight\n    function change_type_weight(int128 type_id, uint256 weight) external onlyGovernance {\n        _change_type_weight(type_id, weight);\n    }\n\n    /// @notice Overwrite gauge weight\n    /// @param addr Gauge address\n    /// @param weight New weight\n    function _change_gauge_weight(address addr, uint256 weight) internal {\n        int128 gauge_type = gauge_types_[addr] - 1;\n        uint256 old_gauge_weight = _get_weight(addr);\n        uint256 type_weight = _get_type_weight(gauge_type);\n        uint256 old_sum = _get_sum(gauge_type);\n        uint256 _total_weight = _get_total();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[addr][next_time].bias = weight;\n        time_weight[addr] = next_time;\n\n        uint256 new_sum = old_sum + weight - old_gauge_weight;\n        points_sum[gauge_type][next_time].bias = new_sum;\n        time_sum[gauge_type] = next_time;\n\n        _total_weight = _total_weight + new_sum * type_weight - old_sum * type_weight;\n        points_total[next_time] = _total_weight;\n        time_total = next_time;\n    }\n\n    // @notice Change weight of gauge `addr` to `weight`\n    // @param addr `GaugeController` contract address\n    // @param weight New Gauge weight\n    function change_gauge_weight(address addr, uint256 weight) external onlyGovernance {\n        _change_gauge_weight(addr, weight);\n    }\n\n    function _remove_gauge_weight(address _gauge) internal {\n        int128 gauge_type = gauge_types_[_gauge] - 1;\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        uint256 old_weight_bias = _get_weight(_gauge);\n        uint256 old_weight_slope = points_weight[_gauge][next_time].slope;\n        uint256 old_sum_bias = _get_sum(gauge_type);\n\n        points_weight[_gauge][next_time].bias = 0;\n        points_weight[_gauge][next_time].slope = 0;\n\n        uint256 new_sum = old_sum_bias - old_weight_bias;\n        points_sum[gauge_type][next_time].bias = new_sum;\n        points_sum[gauge_type][next_time].slope -= old_weight_slope;\n        // We have to cancel all slope changes (gauge specific and global) that were caused by this gauge\n        // This is not very efficient, but does the job for a governance function that is called very rarely\n        for (uint256 i; i < 263; ++i) {\n            uint256 time_to_check = next_time + i * WEEK;\n            uint256 gauge_weight_change = changes_weight[_gauge][time_to_check];\n            if (gauge_weight_change > 0) {\n                changes_weight[_gauge][time_to_check] = 0;\n                changes_sum[gauge_type][time_to_check] -= gauge_weight_change;\n            }\n        }\n    }\n\n    /// @notice Allows governance to remove gauge weights\n    /// @param _gauge Gauge address\n    function remove_gauge_weight(address _gauge) public onlyGovernance {\n        _remove_gauge_weight(_gauge);\n    }\n\n    /// @notice Allocate voting power for changing pool weights\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\n    /// @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\n        require(_user_weight >= 0 && _user_weight <= 10_000, \"Invalid user weight\");\n        require(_user_weight == 0 || gauge_types_[_gauge_addr] != 0, \"Can only vote 0 on non-gauges\"); // We allow withdrawing voting power from invalid (removed) gauges\n        VotingEscrow ve = votingEscrow;\n        (\n            ,\n            /*int128 bias*/\n            int128 slope_, /*uint256 ts*/\n\n        ) = ve.getLastUserPoint(msg.sender);\n        require(slope_ >= 0, \"Invalid slope\");\n        uint256 slope = uint256(uint128(slope_));\n        uint256 lock_end = ve.lockEnd(msg.sender);\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n        require(lock_end > next_time, \"Lock expires too soon\");\n\n        int128 gauge_type = gauge_types_[_gauge_addr] - 1;\n        require(gauge_type >= 0, \"Gauge not added\");\n\n        VotedSlope memory old_slope = vote_user_slopes[msg.sender][_gauge_addr];\n        uint256 old_dt = 0;\n        if (old_slope.end > next_time) old_dt = old_slope.end - next_time;\n        uint256 old_bias = old_slope.slope * old_dt;\n        VotedSlope memory new_slope = VotedSlope({\n            slope: (slope * _user_weight) / 10_000,\n            end: lock_end,\n            power: _user_weight\n        });\n        uint256 new_dt = lock_end - next_time;\n        uint256 new_bias = new_slope.slope * new_dt;\n\n        // Check and update powers (weights) used\n        uint256 power_used = vote_user_power[msg.sender];\n        power_used = power_used + new_slope.power - old_slope.power;\n        require(power_used >= 0 && power_used <= 10_000, \"Used too much power\");\n        vote_user_power[msg.sender] = power_used;\n\n        // Remove old and schedule new slope changes\n        // Remove slope changes for old slopes\n        // Schedule recording of initial slope for next_time\n        uint256 old_weight_bias = _get_weight(_gauge_addr);\n        uint256 old_weight_slope = points_weight[_gauge_addr][next_time].slope;\n        uint256 old_sum_bias = _get_sum(gauge_type);\n        uint256 old_sum_slope = points_sum[gauge_type][next_time].slope;\n\n        points_weight[_gauge_addr][next_time].bias = Math.max(old_weight_bias + new_bias, old_bias) - old_bias;\n        points_sum[gauge_type][next_time].bias = Math.max(old_sum_bias + new_bias, old_bias) - old_bias;\n        if (old_slope.end > next_time) {\n            points_weight[_gauge_addr][next_time].slope =\n                Math.max(old_weight_slope + new_slope.slope, old_slope.slope) -\n                old_slope.slope;\n            points_sum[gauge_type][next_time].slope =\n                Math.max(old_sum_slope + new_slope.slope, old_slope.slope) -\n                old_slope.slope;\n        } else {\n            points_weight[_gauge_addr][next_time].slope += new_slope.slope;\n            points_sum[gauge_type][next_time].slope += new_slope.slope;\n        }\n        if (old_slope.end > block.timestamp) {\n            // Cancel old slope changes if they still didn't happen\n            // Because of manual slope changes when gauge is removed, an underflow is possible here and we have to check for that.\n            if (changes_weight[_gauge_addr][old_slope.end] >= old_slope.slope) {\n                changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope;\n            } else {\n                changes_weight[_gauge_addr][old_slope.end] = 0;\n            }\n            if (changes_sum[gauge_type][old_slope.end] >= old_slope.slope) {\n                changes_sum[gauge_type][old_slope.end] -= old_slope.slope;\n            } else {\n                changes_sum[gauge_type][old_slope.end] = 0;\n            }\n        }\n        // Add slope changes for new slopes\n        changes_weight[_gauge_addr][new_slope.end] += new_slope.slope;\n        changes_sum[gauge_type][new_slope.end] += new_slope.slope;\n\n        _get_total();\n\n        vote_user_slopes[msg.sender][_gauge_addr] = new_slope;\n\n        // Record last action time\n        last_user_vote[msg.sender][_gauge_addr] = block.timestamp;\n    }\n\n    /// @notice Get current gauge weight\n    /// @param _gauge Gauge address\n    /// @return Gauge weight\n    function get_gauge_weight(address _gauge) external view returns (uint256) {\n        return points_weight[_gauge][time_weight[_gauge]].bias;\n    }\n\n    // @notice Get current type weight\n    // @param type_id Type id\n    // @return Type weight\n    function get_type_weight(int128 type_id) external view returns (uint256) {\n        return points_type_weight[type_id][time_type_weight[type_id]];\n    }\n\n    /// @notice Get total weight\n    /// @return Total weight\n    function get_total_weight() external view returns (uint256) {\n        return points_total[time_total];\n    }\n\n    // @notice Get sum of gauge weights per type\n    // @param type_id Type id\n    // @return Sum of gauge weights\n    function get_weights_sum_per_type(int128 type_id) external view returns (uint256) {\n        return points_sum[type_id][time_sum[type_id]].bias;\n    }\n}"
    }
  ]
}