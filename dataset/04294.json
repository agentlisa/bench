{
  "Title": "[M04] Possible mismatch between price identifier and collateral",
  "Content": "The `ExpiringMultiPartyCreator` contract allows the deployer to [choose the price identifier and collateral token](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/ExpiringMultiPartyCreator.sol#L24-L25). If these are chosen to be inconsistent with each other, the price returned by the oracle will not match the expected token price, which could confuse users and lead to unexpected behavior. Consider maintaining an approved mapping between collateral tokens and price identifiers to enforce consistency between these values.\n\n\n**Update**: *Not an issue. There are use cases of the UMA contracts where the price identifier may not match the collateral token. In the words of the UMA team:*\n\n\n\n> \n>  While many products will have matching price quote currencies and collateral tokens, we want to allow creating exotic / complex risk exposures if users prefer.\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/financial-templates/implementation/ExpiringMultiPartyCreator.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../oracle/implementation/ContractCreator.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../common/implementation/AddressWhitelist.sol\";\nimport \"./ExpiringMultiParty.sol\";\n\n\n/**\n * @title Expiring Multi Party Contract creator.\n * @notice Factory contract to create and register new instances of expiring multiparty contracts.\n * Responsible for constraining the parameters used to construct a new EMP.\n */\ncontract ExpiringMultiPartyCreator is ContractCreator, Testable {\n    using FixedPoint for FixedPoint.Unsigned;\n\n    /****************************************\n     *     EMP CREATOR DATA STRUCTURES      *\n     ****************************************/\n\n    struct Params {\n        uint expirationTimestamp;\n        address collateralAddress;\n        bytes32 priceFeedIdentifier;\n        string syntheticName;\n        string syntheticSymbol;\n        FixedPoint.Unsigned collateralRequirement;\n        FixedPoint.Unsigned disputeBondPct;\n        FixedPoint.Unsigned sponsorDisputeRewardPct;\n        FixedPoint.Unsigned disputerDisputeRewardPct;\n        FixedPoint.Unsigned minSponsorTokens;\n    }\n\n    /**\n     * @notice Deployment Configuration Constraints.\n     * @dev: These constraints can evolve over time and are initially constrained to conservative values\n     * in this first iteration of an EMP creator. Technically there is nothing in the ExpiringMultiParty\n     * contract requiring these constraints. However, because \"createExpiringMultiParty()\" is intended to\n     * be the only way to create valid financial contracts that are **registered** with the\n     * DVM (via \"_registerContract()\"), we can enforce deployment configurations here.\n     **/\n\n    // - Whitelist allowed collateral currencies.\n    // Note: before an instantiation of ExpiringMultipartyCreator is approved to register contracts, voters should\n    // ensure that the ownership of this collateralTokenWhitelist has been renounced (so it is effectively\n    // frozen). One could also set the owner to the address of the Governor contract, but voters may find that option\n    // less preferable since it would force them to take a more active role in managing this financial contract\n    // template.\n    AddressWhitelist public collateralTokenWhitelist;\n    // - Address of TokenFactory to pass into newly constructed ExpiringMultiParty contracts\n    address public tokenFactoryAddress;\n    // - Discretize expirations such that they must expire on the first of each month.\n    uint[17] public VALID_EXPIRATION_TIMESTAMPS = [\n        1585699200, // 2020-04-01T00:00:00.000Z\n        1588291200, // 2020-05-01T00:00:00.000Z\n        1590969600, // 2020-06-01T00:00:00.000Z\n        1593561600, // 2020-07-01T00:00:00.000Z\n        1596240000, // 2020-08-01T00:00:00.000Z\n        1598918400, // 2020-09-01T00:00:00.000Z\n        1601510400, // 2020-10-01T00:00:00.000Z\n        1604188800, // 2020-11-01T00:00:00.000Z\n        1606780800, // 2020-12-01T00:00:00.000Z\n        1609459200, // 2021-01-01T00:00:00.000Z\n        1612137600, // 2021-02-01T00:00:00.000Z\n        1614556800, // 2021-03-01T00:00:00.000Z\n        1617235200, // 2021-04-01T00:00:00.000Z\n        1619827200, // 2021-05-01T00:00:00.000Z\n        1622505600, // 2021-06-01T00:00:00.000Z\n        1625097600 // 2021-07-01T00:00:00.000Z\n    ];\n    // - Time for pending withdrawal to be disputed: 60 minutes. Lower liveness increases sponsor usability.\n    // However, this parameter is a reflection of how long we expect it to take for liquidators to identify\n    // that a sponsor is undercollateralized and acquire the tokens needed to liquidate them. This is also a\n    // reflection of how long a malicious sponsor would need to maintain a lower-price manipulation to get\n    // their withdrawal processed maliciously (if set too low, itâ€™s quite easy for malicious sponsors to\n    // request a withdrawal and spend gas to prevent other transactions from processing until the withdrawal\n    //  gets approved). Ultimately, liveness is a friction to be minimized, but not critical to system function.\n    uint public constant STRICT_WITHDRAWAL_LIVENESS = 3600;\n    // - Time for liquidation to be disputed: 60 minutes. Similar reasoning to withdrawal liveness.\n    // Lower liveness is more usable for liquidators. However, the parameter is a reflection of how\n    // long we expect it to take disputers to notice bad liquidations. Malicious liquidators would\n    // also need to attack the base chain for this long to prevent dispute transactions from processing.\n    uint public constant STRICT_LIQUIDATION_LIVENESS = 3600;\n\n    event CreatedExpiringMultiParty(address expiringMultiPartyAddress, address partyMemberAddress);\n\n    /**\n     * @notice Constructs the ExpiringMultiPartyCreator contract.\n     * @param _isTest whether this contract is being constructed for the purpose of running tests.\n     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\n     * @param _collateralTokenWhitelist UMA protocol contract to track whitelisted collateral.\n     * @param _tokenFactoryAddress ERC20 token factory used to deploy synthetic token instances.\n     */\n    constructor(bool _isTest, address _finderAddress, address _collateralTokenWhitelist, address _tokenFactoryAddress)\n        public\n        ContractCreator(_finderAddress)\n        Testable(_isTest)\n    {\n        collateralTokenWhitelist = AddressWhitelist(_collateralTokenWhitelist);\n        tokenFactoryAddress = _tokenFactoryAddress;\n    }\n\n    /**\n     * @notice Creates an instance of expiring multi party and registers it within the registry.\n     * @dev caller is automatically registered as the first (and only) party member.\n     * @param params is a `ConstructorParams` object from ExpiringMultiParty.\n     * @return address of the deployed ExpiringMultiParty contract\n     */\n    function createExpiringMultiParty(Params memory params) public returns (address) {\n        ExpiringMultiParty derivative = new ExpiringMultiParty(_convertParams(params));\n\n        address[] memory parties = new address[](1);\n        parties[0] = msg.sender;\n\n        _registerContract(parties, address(derivative));\n\n        emit CreatedExpiringMultiParty(address(derivative), msg.sender);\n\n        return address(derivative);\n    }\n\n    /****************************************\n     *          PRIVATE FUNCTIONS           *\n     ****************************************/\n\n    //  Returns if expiration timestamp is on hardcoded list.\n    function _isValidTimestamp(uint timestamp) private view returns (bool) {\n        for (uint i = 0; i < VALID_EXPIRATION_TIMESTAMPS.length; i++) {\n            if (VALID_EXPIRATION_TIMESTAMPS[i] == timestamp) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Converts createExpiringMultiParty params to ExpiringMultiParty constructor params.\n    function _convertParams(Params memory params)\n        private\n        view\n        returns (ExpiringMultiParty.ConstructorParams memory constructorParams)\n    {\n        // Known from creator deployment.\n        constructorParams.isTest = isTest;\n        constructorParams.finderAddress = finderAddress;\n        constructorParams.tokenFactoryAddress = tokenFactoryAddress;\n\n        // Enforce configuration constrainments.\n        require(_isValidTimestamp(params.expirationTimestamp));\n        require(bytes(params.syntheticName).length != 0);\n        require(bytes(params.syntheticSymbol).length != 0);\n        constructorParams.withdrawalLiveness = STRICT_WITHDRAWAL_LIVENESS;\n        constructorParams.liquidationLiveness = STRICT_LIQUIDATION_LIVENESS;\n        require(collateralTokenWhitelist.isOnWhitelist(params.collateralAddress));\n\n        // Input from function call.\n        constructorParams.expirationTimestamp = params.expirationTimestamp;\n        constructorParams.collateralAddress = params.collateralAddress;\n        constructorParams.priceFeedIdentifier = params.priceFeedIdentifier;\n        constructorParams.syntheticName = params.syntheticName;\n        constructorParams.syntheticSymbol = params.syntheticSymbol;\n        constructorParams.collateralRequirement = params.collateralRequirement;\n        constructorParams.disputeBondPct = params.disputeBondPct;\n        constructorParams.sponsorDisputeRewardPct = params.sponsorDisputeRewardPct;\n        constructorParams.disputerDisputeRewardPct = params.disputerDisputeRewardPct;\n        constructorParams.minSponsorTokens = params.minSponsorTokens;\n    }\n}"
    }
  ]
}