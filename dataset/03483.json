{
  "Title": "[H04] Irrelevant proof contributions are accepted",
  "Content": "The [`contributesToFraudProof` modifier](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/Abs_FraudContributor.sol#L12) declared in the `Abs_FraudContributor` contract is used to [reward users for participating in proving fraud](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/Abs_FraudContributor.sol#L11).\n\n\nThere are several functions marked with this modifier to assign rewards to users, regardless of whether they are making meaningful proof contributions. Some examples of irrelevant contributions that would grant rewards include:\n\n\n* contributing [irrelevant contract state](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L193) before a fraud proof.\n* contributing [irrelevant storage slots](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L265) before a fraud proof.\n* attempting to [initialize a fraud proof](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L103) that has already been initialized. This is possible because if the fraud proof has been initialized, executing the `initializeFraudVerification` function of the `OVM_FraudVerifier` contract [will still finish execution rather than reverting](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L107-L109).\n\n\nIt should be noted that the [`OVM_BondManager` contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_BondManager.sol) is out this auditâ€™s scope. Nevertheless, consider changing the [`contributesToFraudProof` modifier](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/Abs_FraudContributor.sol#L12) or the logic within the `OVM_BondManager` contract to prevent abuse of rewards during fraud proofs.\n\n\n***Update:** Acknowledged. The Optimism team decided not to prioritize this issue because it does not apply to the current release, since the bond manager is disabled.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/OVM/verification/Abs_FraudContributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\nimport { iOVM_BondManager } from \"../../iOVM/verification/iOVM_BondManager.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\n\n/// Minimal contract to be inherited by contracts consumed by users that provide\n/// data for fraud proofs\nabstract contract Abs_FraudContributor is Lib_AddressResolver {\n    /// Decorate your functions with this modifier to store how much total gas was\n    /// consumed by the sender, to reward users fairly\n    modifier contributesToFraudProof(bytes32 preStateRoot, bytes32 txHash) {\n        uint256 startGas = gasleft();\n        _;\n        uint256 gasSpent = startGas - gasleft();\n        iOVM_BondManager(resolve('OVM_BondManager')).recordGasSpent(preStateRoot, txHash, msg.sender, gasSpent);\n    }\n}"
    },
    {
      "filename": "contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol",
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_EthUtils } from \"../../libraries/utils/Lib_EthUtils.sol\";\nimport { Lib_Bytes32Utils } from \"../../libraries/utils/Lib_Bytes32Utils.sol\";\nimport { Lib_BytesUtils } from \"../../libraries/utils/Lib_BytesUtils.sol\";\nimport { Lib_SecureMerkleTrie } from \"../../libraries/trie/Lib_SecureMerkleTrie.sol\";\nimport { Lib_RLPWriter } from \"../../libraries/rlp/Lib_RLPWriter.sol\";\nimport { Lib_RLPReader } from \"../../libraries/rlp/Lib_RLPReader.sol\";\n\n/* Interface Imports */\nimport { iOVM_StateTransitioner } from \"../../iOVM/verification/iOVM_StateTransitioner.sol\";\nimport { iOVM_BondManager } from \"../../iOVM/verification/iOVM_BondManager.sol\";\nimport { iOVM_ExecutionManager } from \"../../iOVM/execution/iOVM_ExecutionManager.sol\";\nimport { iOVM_StateManager } from \"../../iOVM/execution/iOVM_StateManager.sol\";\nimport { iOVM_StateManagerFactory } from \"../../iOVM/execution/iOVM_StateManagerFactory.sol\";\n\n/* Contract Imports */\nimport { Abs_FraudContributor } from \"./Abs_FraudContributor.sol\";\n\n/**\n * @title OVM_StateTransitioner\n * @dev The State Transitioner coordinates the execution of a state transition during the evaluation of a\n * fraud proof. It feeds verified input to the Execution Manager's run(), and controls a State Manager (which is\n * uniquely created for each fraud proof).\n * Once a fraud proof has been initialized, this contract is provided with the pre-state root and verifies\n * that the OVM storage slots committed to the State Mangager are contained in that state\n * This contract controls the State Manager and Execution Manager, and uses them to calculate the\n * post-state root by applying the transaction. The Fraud Verifier can then check for fraud by comparing\n * the calculated post-state root with the proposed post-state root.\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_StateTransitioner is Lib_AddressResolver, Abs_FraudContributor, iOVM_StateTransitioner {\n\n    /*******************\n     * Data Structures *\n     *******************/\n\n    enum TransitionPhase {\n        PRE_EXECUTION,\n        POST_EXECUTION,\n        COMPLETE\n    }\n\n\n    /*******************************************\n     * Contract Variables: Contract References *\n     *******************************************/\n\n    iOVM_StateManager public ovmStateManager;\n\n\n    /*******************************************\n     * Contract Variables: Internal Accounting *\n     *******************************************/\n\n    bytes32 internal preStateRoot;\n    bytes32 internal postStateRoot;\n    TransitionPhase public phase;\n    uint256 internal stateTransitionIndex;\n    bytes32 internal transactionHash;\n\n\n    /*************\n     * Constants *\n     *************/\n\n    bytes32 internal constant EMPTY_ACCOUNT_CODE_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    bytes32 internal constant EMPTY_ACCOUNT_STORAGE_ROOT = 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421;\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     * @param _stateTransitionIndex Index of the state transition being verified.\n     * @param _preStateRoot State root before the transition was executed.\n     * @param _transactionHash Hash of the executed transaction.\n     */\n    constructor(\n        address _libAddressManager,\n        uint256 _stateTransitionIndex,\n        bytes32 _preStateRoot,\n        bytes32 _transactionHash\n    )\n        Lib_AddressResolver(_libAddressManager)\n    {\n        stateTransitionIndex = _stateTransitionIndex;\n        preStateRoot = _preStateRoot;\n        postStateRoot = _preStateRoot;\n        transactionHash = _transactionHash;\n\n        ovmStateManager = iOVM_StateManagerFactory(resolve(\"OVM_StateManagerFactory\")).create(address(this));\n    }\n\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Checks that a function is only run during a specific phase.\n     * @param _phase Phase the function must run within.\n     */\n    modifier onlyDuringPhase(\n        TransitionPhase _phase\n    ) {\n        require(\n            phase == _phase,\n            \"Function must be called during the correct phase.\"\n        );\n        _;\n    }\n\n\n    /**********************************\n     * Public Functions: State Access *\n     **********************************/\n\n    /**\n     * Retrieves the state root before execution.\n     * @return _preStateRoot State root before execution.\n     */\n    function getPreStateRoot()\n        override\n        public\n        view\n        returns (\n            bytes32 _preStateRoot\n        )\n    {\n        return preStateRoot;\n    }\n\n    /**\n     * Retrieves the state root after execution.\n     * @return _postStateRoot State root after execution.\n     */\n    function getPostStateRoot()\n        override\n        public\n        view\n        returns (\n            bytes32 _postStateRoot\n        )\n    {\n        return postStateRoot;\n    }\n\n    /**\n     * Checks whether the transitioner is complete.\n     * @return _complete Whether or not the transition process is finished.\n     */\n    function isComplete()\n        override\n        public\n        view\n        returns (\n            bool _complete\n        )\n    {\n        return phase == TransitionPhase.COMPLETE;\n    }\n\n\n    /***********************************\n     * Public Functions: Pre-Execution *\n     ***********************************/\n\n    /**\n     * Allows a user to prove the initial state of a contract.\n     * @param _ovmContractAddress Address of the contract on the OVM.\n     * @param _ethContractAddress Address of the corresponding contract on L1.\n     * @param _stateTrieWitness Proof of the account state.\n     */\n    function proveContractState(\n        address _ovmContractAddress,\n        address _ethContractAddress,\n        bytes memory _stateTrieWitness\n    )\n        override\n        public\n        onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n        contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            (\n                ovmStateManager.hasAccount(_ovmContractAddress) == false\n                && ovmStateManager.hasEmptyAccount(_ovmContractAddress) == false\n            ),\n            \"Account state has already been proven.\"\n        );\n\n        // Function will fail if the proof is not a valid inclusion or exclusion proof.\n        (\n            bool exists,\n            bytes memory encodedAccount\n        ) = Lib_SecureMerkleTrie.get(\n            abi.encodePacked(_ovmContractAddress),\n            _stateTrieWitness,\n            preStateRoot\n        );\n\n        if (exists == true) {\n            // Account exists, this was an inclusion proof.\n            Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\n                encodedAccount\n            );\n\n            address ethContractAddress = _ethContractAddress;\n            if (account.codeHash == EMPTY_ACCOUNT_CODE_HASH) {\n                // Use a known empty contract to prevent an attack in which a user provides a\n                // contract address here and then later deploys code to it.\n                ethContractAddress = 0x0000000000000000000000000000000000000000;\n            } else {\n                // Otherwise, make sure that the code at the provided eth address matches the hash\n                // of the code stored on L2.\n                require(\n                    Lib_EthUtils.getCodeHash(ethContractAddress) == account.codeHash,\n                    \"OVM_StateTransitioner: Provided L1 contract code hash does not match L2 contract code hash.\"\n                );\n            }\n\n            ovmStateManager.putAccount(\n                _ovmContractAddress,\n                Lib_OVMCodec.Account({\n                    nonce: account.nonce,\n                    balance: account.balance,\n                    storageRoot: account.storageRoot,\n                    codeHash: account.codeHash,\n                    ethAddress: ethContractAddress,\n                    isFresh: false\n                })\n            );\n        } else {\n            // Account does not exist, this was an exclusion proof.\n            ovmStateManager.putEmptyAccount(_ovmContractAddress);\n        }\n    }\n\n    /**\n     * Allows a user to prove the initial state of a contract storage slot.\n     * @param _ovmContractAddress Address of the contract on the OVM.\n     * @param _key Claimed account slot key.\n     * @param _storageTrieWitness Proof of the storage slot.\n     */\n    function proveStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes memory _storageTrieWitness\n    )\n        override\n        public\n        onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n        contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            ovmStateManager.hasContractStorage(_ovmContractAddress, _key) == false,\n            \"Storage slot has already been proven.\"\n        );\n\n        require(\n            ovmStateManager.hasAccount(_ovmContractAddress) == true,\n            \"Contract must be verified before proving a storage slot.\"\n        );\n\n        bytes32 storageRoot = ovmStateManager.getAccountStorageRoot(_ovmContractAddress);\n        bytes32 value;\n\n        if (storageRoot == EMPTY_ACCOUNT_STORAGE_ROOT) {\n            // Storage trie was empty, so the user is always allowed to insert zero-byte values.\n            value = bytes32(0);\n        } else {\n            // Function will fail if the proof is not a valid inclusion or exclusion proof.\n            (\n                bool exists,\n                bytes memory encodedValue\n            ) = Lib_SecureMerkleTrie.get(\n                abi.encodePacked(_key),\n                _storageTrieWitness,\n                storageRoot\n            );\n\n            if (exists == true) {\n                // Inclusion proof.\n                // Stored values are RLP encoded, with leading zeros removed.\n                value = Lib_BytesUtils.toBytes32PadLeft(\n                    Lib_RLPReader.readBytes(encodedValue)\n                );\n            } else {\n                // Exclusion proof, can only be zero bytes.\n                value = bytes32(0);\n            }\n        }\n\n        ovmStateManager.putContractStorage(\n            _ovmContractAddress,\n            _key,\n            value\n        );\n    }\n\n\n    /*******************************\n     * Public Functions: Execution *\n     *******************************/\n\n    /**\n     * Executes the state transition.\n     * @param _transaction OVM transaction to execute.\n     */\n    function applyTransaction(\n        Lib_OVMCodec.Transaction memory _transaction\n    )\n        override\n        public\n        onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n        contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            Lib_OVMCodec.hashTransaction(_transaction) == transactionHash,\n            \"Invalid transaction provided.\"\n        );\n\n        // We require gas to complete the logic here in run() before/after execution,\n        // But must ensure the full _tx.gasLimit can be given to the ovmCALL (determinism)\n        // This includes 1/64 of the gas getting lost because of EIP-150 (lost twice--first\n        // going into EM, then going into the code contract).\n        require(\n            gasleft() >= 100000 + _transaction.gasLimit * 1032 / 1000, // 1032/1000 = 1.032 = (64/63)^2 rounded up\n            \"Not enough gas to execute transaction deterministically.\"\n        );\n\n        iOVM_ExecutionManager ovmExecutionManager = iOVM_ExecutionManager(resolve(\"OVM_ExecutionManager\"));\n\n        // We call `setExecutionManager` right before `run` (and not earlier) just in case the\n        // OVM_ExecutionManager address was updated between the time when this contract was created\n        // and when `applyTransaction` was called.\n        ovmStateManager.setExecutionManager(address(ovmExecutionManager));\n\n        // `run` always succeeds *unless* the user hasn't provided enough gas to `applyTransaction`\n        // or an INVALID_STATE_ACCESS flag was triggered. Either way, we won't get beyond this line\n        // if that's the case.\n        ovmExecutionManager.run(_transaction, address(ovmStateManager));\n\n        // Prevent the Execution Manager from calling this SM again.\n        ovmStateManager.setExecutionManager(address(0));\n        phase = TransitionPhase.POST_EXECUTION;\n    }\n\n\n    /************************************\n     * Public Functions: Post-Execution *\n     ************************************/\n\n    /**\n     * Allows a user to commit the final state of a contract.\n     * @param _ovmContractAddress Address of the contract on the OVM.\n     * @param _stateTrieWitness Proof of the account state.\n     */\n    function commitContractState(\n        address _ovmContractAddress,\n        bytes memory _stateTrieWitness\n    )\n        override\n        public\n        onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n        contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.getTotalUncommittedContractStorage() == 0,\n            \"All storage must be committed before committing account states.\"\n        );\n\n        require (\n            ovmStateManager.commitAccount(_ovmContractAddress) == true,\n            \"Account state wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n\n        postStateRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_ovmContractAddress),\n            Lib_OVMCodec.encodeEVMAccount(\n                Lib_OVMCodec.toEVMAccount(account)\n            ),\n            _stateTrieWitness,\n            postStateRoot\n        );\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit AccountCommitted(\n            _ovmContractAddress\n        );\n    }\n\n    /**\n     * Allows a user to commit the final state of a contract storage slot.\n     * @param _ovmContractAddress Address of the contract on the OVM.\n     * @param _key Claimed account slot key.\n     * @param _storageTrieWitness Proof of the storage slot.\n     */\n    function commitStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes memory _storageTrieWitness\n    )\n        override\n        public\n        onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n        contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.commitContractStorage(_ovmContractAddress, _key) == true,\n            \"Storage slot value wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n        bytes32 value = ovmStateManager.getContractStorage(_ovmContractAddress, _key);\n\n        account.storageRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_key),\n            Lib_RLPWriter.writeBytes(\n                Lib_Bytes32Utils.removeLeadingZeros(value)\n            ),\n            _storageTrieWitness,\n            account.storageRoot\n        );\n\n        ovmStateManager.putAccount(_ovmContractAddress, account);\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit ContractStorageCommitted(\n            _ovmContractAddress,\n            _key\n        );\n    }\n\n\n    /**********************************\n     * Public Functions: Finalization *\n     **********************************/\n\n    /**\n     * Finalizes the transition process.\n     */\n    function completeTransition()\n        override\n        public\n        onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n    {\n        require(\n            ovmStateManager.getTotalUncommittedAccounts() == 0,\n            \"All accounts must be committed before completing a transition.\"\n        );\n\n        require(\n            ovmStateManager.getTotalUncommittedContractStorage() == 0,\n            \"All storage must be committed before completing a transition.\"\n        );\n\n        phase = TransitionPhase.COMPLETE;\n    }\n}"
    },
    {
      "filename": "contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol",
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_EthUtils } from \"../../libraries/utils/Lib_EthUtils.sol\";\nimport { Lib_Bytes32Utils } from \"../../libraries/utils/Lib_Bytes32Utils.sol\";\nimport { Lib_BytesUtils } from \"../../libraries/utils/Lib_BytesUtils.sol\";\nimport { Lib_SecureMerkleTrie } from \"../../libraries/trie/Lib_SecureMerkleTrie.sol\";\nimport { Lib_RLPWriter } from \"../../libraries/rlp/Lib_RLPWriter.sol\";\nimport { Lib_RLPReader } from \"../../libraries/rlp/Lib_RLPReader.sol\";\n\n/* Interface Imports */\nimport { iOVM_StateTransitioner } from \"../../iOVM/verification/iOVM_StateTransitioner.sol\";\nimport { iOVM_BondManager } from \"../../iOVM/verification/iOVM_BondManager.sol\";\nimport { iOVM_ExecutionManager } from \"../../iOVM/execution/iOVM_ExecutionManager.sol\";\nimport { iOVM_StateManager } from \"../../iOVM/execution/iOVM_StateManager.sol\";\nimport { iOVM_StateManagerFactory } from \"../../iOVM/execution/iOVM_StateManagerFactory.sol\";\n\n/* Contract Imports */\nimport { Abs_FraudContributor } from \"./Abs_FraudContributor.sol\";\n\n/**\n * @title OVM_StateTransitioner\n * @dev The State Transitioner coordinates the execution of a state transition during the evaluation of a\n * fraud proof. It feeds verified input to the Execution Manager's run(), and controls a State Manager (which is\n * uniquely created for each fraud proof).\n * Once a fraud proof has been initialized, this contract is provided with the pre-state root and verifies\n * that the OVM storage slots committed to the State Mangager are contained in that state\n * This contract controls the State Manager and Execution Manager, and uses them to calculate the\n * post-state root by applying the transaction. The Fraud Verifier can then check for fraud by comparing\n * the calculated post-state root with the proposed post-state root.\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_StateTransitioner is Lib_AddressResolver, Abs_FraudContributor, iOVM_StateTransitioner {\n\n    /*******************\n     * Data Structures *\n     *******************/\n\n    enum TransitionPhase {\n        PRE_EXECUTION,\n        POST_EXECUTION,\n        COMPLETE\n    }\n\n\n    /*******************************************\n     * Contract Variables: Contract References *\n     *******************************************/\n\n    iOVM_StateManager public ovmStateManager;\n\n\n    /*******************************************\n     * Contract Variables: Internal Accounting *\n     *******************************************/\n\n    bytes32 internal preStateRoot;\n    bytes32 internal postStateRoot;\n    TransitionPhase public phase;\n    uint256 internal stateTransitionIndex;\n    bytes32 internal transactionHash;\n\n\n    /*************\n     * Constants *\n     *************/\n\n    bytes32 internal constant EMPTY_ACCOUNT_CODE_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    bytes32 internal constant EMPTY_ACCOUNT_STORAGE_ROOT = 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421;\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     * @param _stateTransitionIndex Index of the state transition being verified.\n     * @param _preStateRoot State root before the transition was executed.\n     * @param _transactionHash Hash of the executed transaction.\n     */\n    constructor(\n        address _libAddressManager,\n        uint256 _stateTransitionIndex,\n        bytes32 _preStateRoot,\n        bytes32 _transactionHash\n    )\n        Lib_AddressResolver(_libAddressManager)\n    {\n        stateTransitionIndex = _stateTransitionIndex;\n        preStateRoot = _preStateRoot;\n        postStateRoot = _preStateRoot;\n        transactionHash = _transactionHash;\n\n        ovmStateManager = iOVM_StateManagerFactory(resolve(\"OVM_StateManagerFactory\")).create(address(this));\n    }\n\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Checks that a function is only run during a specific phase.\n     * @param _phase Phase the function must run within.\n     */\n    modifier onlyDuringPhase(\n        TransitionPhase _phase\n    ) {\n        require(\n            phase == _phase,\n            \"Function must be called during the correct phase.\"\n        );\n        _;\n    }\n\n\n    /**********************************\n     * Public Functions: State Access *\n     **********************************/\n\n    /**\n     * Retrieves the state root before execution.\n     * @return _preStateRoot State root before execution.\n     */\n    function getPreStateRoot()\n        override\n        public\n        view\n        returns (\n            bytes32 _preStateRoot\n        )\n    {\n        return preStateRoot;\n    }\n\n    /**\n     * Retrieves the state root after execution.\n     * @return _postStateRoot State root after execution.\n     */\n    function getPostStateRoot()\n        override\n        public\n        view\n        returns (\n            bytes32 _postStateRoot\n        )\n    {\n        return postStateRoot;\n    }\n\n    /**\n     * Checks whether the transitioner is complete.\n     * @return _complete Whether or not the transition process is finished.\n     */\n    function isComplete()\n        override\n        public\n        view\n        returns (\n            bool _complete\n        )\n    {\n        return phase == TransitionPhase.COMPLETE;\n    }\n\n\n    /***********************************\n     * Public Functions: Pre-Execution *\n     ***********************************/\n\n    /**\n     * Allows a user to prove the initial state of a contract.\n     * @param _ovmContractAddress Address of the contract on the OVM.\n     * @param _ethContractAddress Address of the corresponding contract on L1.\n     * @param _stateTrieWitness Proof of the account state.\n     */\n    function proveContractState(\n        address _ovmContractAddress,\n        address _ethContractAddress,\n        bytes memory _stateTrieWitness\n    )\n        override\n        public\n        onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n        contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            (\n                ovmStateManager.hasAccount(_ovmContractAddress) == false\n                && ovmStateManager.hasEmptyAccount(_ovmContractAddress) == false\n            ),\n            \"Account state has already been proven.\"\n        );\n\n        // Function will fail if the proof is not a valid inclusion or exclusion proof.\n        (\n            bool exists,\n            bytes memory encodedAccount\n        ) = Lib_SecureMerkleTrie.get(\n            abi.encodePacked(_ovmContractAddress),\n            _stateTrieWitness,\n            preStateRoot\n        );\n\n        if (exists == true) {\n            // Account exists, this was an inclusion proof.\n            Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\n                encodedAccount\n            );\n\n            address ethContractAddress = _ethContractAddress;\n            if (account.codeHash == EMPTY_ACCOUNT_CODE_HASH) {\n                // Use a known empty contract to prevent an attack in which a user provides a\n                // contract address here and then later deploys code to it.\n                ethContractAddress = 0x0000000000000000000000000000000000000000;\n            } else {\n                // Otherwise, make sure that the code at the provided eth address matches the hash\n                // of the code stored on L2.\n                require(\n                    Lib_EthUtils.getCodeHash(ethContractAddress) == account.codeHash,\n                    \"OVM_StateTransitioner: Provided L1 contract code hash does not match L2 contract code hash.\"\n                );\n            }\n\n            ovmStateManager.putAccount(\n                _ovmContractAddress,\n                Lib_OVMCodec.Account({\n                    nonce: account.nonce,\n                    balance: account.balance,\n                    storageRoot: account.storageRoot,\n                    codeHash: account.codeHash,\n                    ethAddress: ethContractAddress,\n                    isFresh: false\n                })\n            );\n        } else {\n            // Account does not exist, this was an exclusion proof.\n            ovmStateManager.putEmptyAccount(_ovmContractAddress);\n        }\n    }\n\n    /**\n     * Allows a user to prove the initial state of a contract storage slot.\n     * @param _ovmContractAddress Address of the contract on the OVM.\n     * @param _key Claimed account slot key.\n     * @param _storageTrieWitness Proof of the storage slot.\n     */\n    function proveStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes memory _storageTrieWitness\n    )\n        override\n        public\n        onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n        contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            ovmStateManager.hasContractStorage(_ovmContractAddress, _key) == false,\n            \"Storage slot has already been proven.\"\n        );\n\n        require(\n            ovmStateManager.hasAccount(_ovmContractAddress) == true,\n            \"Contract must be verified before proving a storage slot.\"\n        );\n\n        bytes32 storageRoot = ovmStateManager.getAccountStorageRoot(_ovmContractAddress);\n        bytes32 value;\n\n        if (storageRoot == EMPTY_ACCOUNT_STORAGE_ROOT) {\n            // Storage trie was empty, so the user is always allowed to insert zero-byte values.\n            value = bytes32(0);\n        } else {\n            // Function will fail if the proof is not a valid inclusion or exclusion proof.\n            (\n                bool exists,\n                bytes memory encodedValue\n            ) = Lib_SecureMerkleTrie.get(\n                abi.encodePacked(_key),\n                _storageTrieWitness,\n                storageRoot\n            );\n\n            if (exists == true) {\n                // Inclusion proof.\n                // Stored values are RLP encoded, with leading zeros removed.\n                value = Lib_BytesUtils.toBytes32PadLeft(\n                    Lib_RLPReader.readBytes(encodedValue)\n                );\n            } else {\n                // Exclusion proof, can only be zero bytes.\n                value = bytes32(0);\n            }\n        }\n\n        ovmStateManager.putContractStorage(\n            _ovmContractAddress,\n            _key,\n            value\n        );\n    }\n\n\n    /*******************************\n     * Public Functions: Execution *\n     *******************************/\n\n    /**\n     * Executes the state transition.\n     * @param _transaction OVM transaction to execute.\n     */\n    function applyTransaction(\n        Lib_OVMCodec.Transaction memory _transaction\n    )\n        override\n        public\n        onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n        contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            Lib_OVMCodec.hashTransaction(_transaction) == transactionHash,\n            \"Invalid transaction provided.\"\n        );\n\n        // We require gas to complete the logic here in run() before/after execution,\n        // But must ensure the full _tx.gasLimit can be given to the ovmCALL (determinism)\n        // This includes 1/64 of the gas getting lost because of EIP-150 (lost twice--first\n        // going into EM, then going into the code contract).\n        require(\n            gasleft() >= 100000 + _transaction.gasLimit * 1032 / 1000, // 1032/1000 = 1.032 = (64/63)^2 rounded up\n            \"Not enough gas to execute transaction deterministically.\"\n        );\n\n        iOVM_ExecutionManager ovmExecutionManager = iOVM_ExecutionManager(resolve(\"OVM_ExecutionManager\"));\n\n        // We call `setExecutionManager` right before `run` (and not earlier) just in case the\n        // OVM_ExecutionManager address was updated between the time when this contract was created\n        // and when `applyTransaction` was called.\n        ovmStateManager.setExecutionManager(address(ovmExecutionManager));\n\n        // `run` always succeeds *unless* the user hasn't provided enough gas to `applyTransaction`\n        // or an INVALID_STATE_ACCESS flag was triggered. Either way, we won't get beyond this line\n        // if that's the case.\n        ovmExecutionManager.run(_transaction, address(ovmStateManager));\n\n        // Prevent the Execution Manager from calling this SM again.\n        ovmStateManager.setExecutionManager(address(0));\n        phase = TransitionPhase.POST_EXECUTION;\n    }\n\n\n    /************************************\n     * Public Functions: Post-Execution *\n     ************************************/\n\n    /**\n     * Allows a user to commit the final state of a contract.\n     * @param _ovmContractAddress Address of the contract on the OVM.\n     * @param _stateTrieWitness Proof of the account state.\n     */\n    function commitContractState(\n        address _ovmContractAddress,\n        bytes memory _stateTrieWitness\n    )\n        override\n        public\n        onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n        contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.getTotalUncommittedContractStorage() == 0,\n            \"All storage must be committed before committing account states.\"\n        );\n\n        require (\n            ovmStateManager.commitAccount(_ovmContractAddress) == true,\n            \"Account state wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n\n        postStateRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_ovmContractAddress),\n            Lib_OVMCodec.encodeEVMAccount(\n                Lib_OVMCodec.toEVMAccount(account)\n            ),\n            _stateTrieWitness,\n            postStateRoot\n        );\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit AccountCommitted(\n            _ovmContractAddress\n        );\n    }\n\n    /**\n     * Allows a user to commit the final state of a contract storage slot.\n     * @param _ovmContractAddress Address of the contract on the OVM.\n     * @param _key Claimed account slot key.\n     * @param _storageTrieWitness Proof of the storage slot.\n     */\n    function commitStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes memory _storageTrieWitness\n    )\n        override\n        public\n        onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n        contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.commitContractStorage(_ovmContractAddress, _key) == true,\n            \"Storage slot value wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContrac"
    }
  ]
}