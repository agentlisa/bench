{
  "Title": "[G-04] State variables can be cached instead of re-reading them from storage",
  "Content": "\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/RiskFund/ReserveHelpers.sol#L60-L66\n\n*There are 40 instances of this issue.*\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/RiskFund/ReserveHelpers.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../ComptrollerInterface.sol\";\nimport \"../Pool/PoolRegistryInterface.sol\";\n\ncontract ReserveHelpers {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Store the previous state for the asset transferred to ProtocolShareReserve combined(for all pools).\n    mapping(address => uint256) internal assetsReserves;\n\n    // Store the asset's reserve per pool in the ProtocolShareReserve.\n    // Comptroller(pool) -> Asset -> amount\n    mapping(address => mapping(address => uint256)) internal poolsAssetsReserves;\n\n    // Address of pool registry contract\n    address internal poolRegistry;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     */\n    uint256[48] private __gap;\n\n    // Event emitted after the updation of the assets reserves.\n    // amount -> reserve increased by amount.\n    event AssetsReservesUpdated(address indexed comptroller, address indexed asset, uint256 amount);\n\n    /**\n     * @dev Get the Amount of the asset in the risk fund for the specific pool.\n     * @param comptroller  Comptroller address(pool).\n     * @param asset Asset address.\n     * @return Asset's reserve in risk fund.\n     */\n    function getPoolAssetReserve(address comptroller, address asset) external view returns (uint256) {\n        require(ComptrollerInterface(comptroller).isComptroller(), \"ReserveHelpers: Comptroller address invalid\");\n        require(asset != address(0), \"ReserveHelpers: Asset address invalid\");\n        return poolsAssetsReserves[comptroller][asset];\n    }\n\n    /**\n     * @dev Update the reserve of the asset for the specific pool after transferring to risk fund\n     * and transferring funds to the protocol share reserve\n     * @param comptroller  Comptroller address(pool).\n     * @param asset Asset address.\n     */\n    function updateAssetsState(address comptroller, address asset) public virtual {\n        require(ComptrollerInterface(comptroller).isComptroller(), \"ReserveHelpers: Comptroller address invalid\");\n        require(asset != address(0), \"ReserveHelpers: Asset address invalid\");\n        require(poolRegistry != address(0), \"ReserveHelpers: Pool Registry address is not set\");\n        require(\n            PoolRegistryInterface(poolRegistry).getVTokenForAsset(comptroller, asset) != address(0),\n            \"ReserveHelpers: The pool doesn't support the asset\"\n        );\n\n        uint256 currentBalance = IERC20Upgradeable(asset).balanceOf(address(this));\n        uint256 assetReserve = assetsReserves[asset];\n        if (currentBalance > assetReserve) {\n            uint256 balanceDifference;\n            unchecked {\n                balanceDifference = currentBalance - assetReserve;\n            }\n            assetsReserves[asset] += balanceDifference;\n            poolsAssetsReserves[comptroller][asset] += balanceDifference;\n            emit AssetsReservesUpdated(comptroller, asset, balanceDifference);\n        }\n    }\n}"
    }
  ]
}