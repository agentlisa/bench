{
  "Title": "[H-02] A registered contract won't earn fees if `_recipient` is a fresh address",
  "Content": "\nUsers might become victims of a false positive: if they use a fresh account as an NFT recipient during contract registration, the transaction won't revert, but the registered contract will never earn fees for the token holder. And since a contract can be registered only once, there won't be a way for affected users to re-register contracts and start earning fees. This can affect both bigger and smaller projects that register their contracts with the Turnstile contract: the only condition for the bug to happen is that the recipient address that's used during registration is a fresh address (i.e. an address that hasn't been used yet).\n\n### Proof of Concept\n\nThe `register` function allows the calling contract to specify the address that will receive the freshly minted NFT ([Turnstile.sol#L86](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/CIP-001/src/Turnstile.sol#L86)):\n\n```solidity\nfunction register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n    address smartContract = msg.sender;\n\n    if (_recipient == address(0)) revert InvalidRecipient();\n\n    tokenId = _tokenIdTracker.current();\n    _mint(_recipient, tokenId);\n    _tokenIdTracker.increment();\n\n    emit Register(smartContract, _recipient, tokenId);\n\n    feeRecipient[smartContract] = NftData({\n        tokenId: tokenId,\n        registered: true\n    });\n}\n```\n\nA recipient address can be any address besides the zero address. However, on the consensus layer, there's a stricter requirement ([event_handler.go#L31-L33](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/event_handler.go#L31-L33)): a recipient address cannot be a *fresh account*, that is an address that:\n\n*   hasn't ever received native coins;\n*   hasn't ever sent a transaction;\n*   hasn't ever had contract code.\n\nWhile, on the application layer, calling the `register` function with a fresh address will succeed, on the consensus layer a contract won't be registered. \n\nWhen a `Register` event is processed on the consensus layer, there's a check that requires that the recipient address is an *existing account* in the state database ([event_handler.go#L31-L33](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/event_handler.go#L31-L33)):\n\n```go\n// Check that the receiver account  exists in the evm store\nif acct := k.evmKeeper.GetAccount(ctx, event.Recipient); acct == nil {\n  return sdkerrors.Wrapf(ErrNonexistentAcct, \"EventHandler::RegisterEvent account does not exist: %s\", event.Recipient)\n}\n```\n\nIf the recipient account doesn't exist, the function will return, but the register transaction won't revert (errors during the events processing doesn't result in a revert: [evm_hooks.go#L123-L132](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L123-L132), [evm_hooks.go#L49](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L49)).\n\nThe `GetAccount` function above returns `nil` when an address doesn't exist in the state database. To see this, we need to unwind the `GetAccount` execution:\n\n1.  The `GetAccount` is called on an `evmKeeper` ([event_handler.go#L31](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/event_handler.go#L31)):\n    ```go\n    if acct := k.evmKeeper.GetAccount(ctx, event.Recipient); acct == nil {\n      return sdkerrors.Wrapf(ErrNonexistentAcct, \"EventHandler::RegisterEvent account does not exist: %s\", event.Recipient)\n    }\n    ```\n2.  `evmKeeper` is set during the CSR Keeper initialization ([keeper.go#L27](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/keeper.go#L27)):\n    ```go\n    func NewKeeper(\n      cdc codec.BinaryCodec,\n      storeKey sdk.StoreKey,\n      ps paramtypes.Subspace,\n      accountKeeper types.AccountKeeper,\n      evmKeeper types.EVMKeeper,\n      bankKeeper types.BankKeeper,\n      FeeCollectorName string,\n    ) Keeper {\n      // set KeyTable if it has not already been set\n      if !ps.HasKeyTable() {\n        ps = ps.WithKeyTable(types.ParamKeyTable())\n      }\n\n      return Keeper{\n        storeKey:         storeKey,\n        cdc:              cdc,\n        paramstore:       ps,\n        accountKeeper:    accountKeeper,\n        evmKeeper:        evmKeeper,\n        bankKeeper:       bankKeeper,\n        FeeCollectorName: FeeCollectorName,\n      }\n    }\n    ```\n3.  The CSR Keeper is initialized during the main app initialization ([app.go#L473-L478](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/app/app.go#L473-L478)), this is also when the EVM Keeper is initialized ([app.go#L409-L413](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/app/app.go#L409-L413)):\n    ```go\n    app.EvmKeeper = evmkeeper.NewKeeper(\n      appCodec, keys[evmtypes.StoreKey], tkeys[evmtypes.TransientKey], app.GetSubspace(evmtypes.ModuleName),\n      app.AccountKeeper, app.BankKeeper, &stakingKeeper, app.FeeMarketKeeper,\n      tracer,\n    )\n    ```\n4.  The EVM Keeper is implemented and imported from Ethermint ([keeper.go#L67](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/keeper/keeper.go#L67));\n5.  Here's the `GetAccount` function ([statedb.go#L25](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/keeper/statedb.go#L25)):\n    ```go\n    func (k *Keeper) GetAccount(ctx sdk.Context, addr common.Address) *statedb.Account {\n      acct := k.GetAccountWithoutBalance(ctx, addr)\n      if acct == nil {\n        return nil\n      }\n\n      acct.Balance = k.GetBalance(ctx, addr)\n      return acct\n    }\n    ```\n6.  The `GetAccountWithoutBalance` function calls `GetAccount` on `accountKeeper` ([keeper.go#L255-L258](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/keeper/keeper.go#L255-L258)):\n    ```go\n    acct := k.accountKeeper.GetAccount(ctx, cosmosAddr)\n    if acct == nil {\n      return nil\n    }\n    ```\n7.  The Account Keeper is implemented in the Cosmos SDK ([account.go#L41-L49](https://github.com/cosmos/cosmos-sdk/blob/394f1b9478a8dc568d4bab079732932488b46704/x/auth/keeper/account.go#L41-L49)):\n    ```go\n    func (ak AccountKeeper) GetAccount(ctx sdk.Context, addr sdk.AccAddress) types.AccountI {\n      store := ctx.KVStore(ak.storeKey)\n      bz := store.Get(types.AddressStoreKey(addr))\n      if bz == nil {\n        return nil\n      }\n\n      return ak.decodeAccount(bz)\n    }\n    ```\n8.  It basically reads an account from the store passed in the context object ([context.go#L280-L282](https://github.com/cosmos/cosmos-sdk/blob/394f1b9478a8dc568d4bab079732932488b46704/types/context.go#L280-L282));\n9.  In the Account Keeper, there's also `SetAccount` function ([account.go#L72](https://github.com/cosmos/cosmos-sdk/blob/394f1b9478a8dc568d4bab079732932488b46704/x/auth/keeper/account.go#L72)), and it's called in Ethermint by the EVM Keeper ([statedb.go#L126](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/keeper/statedb.go#L126));\n10. The EVM Keeper's `SetAccount` is called when transaction changes are committed to the state database ([statedb.go#L449](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/statedb/statedb.go#L449));\n11. The state database is a set of state objects, where keys are account addresses and values are accounts themselves;\n12. The `getOrNewStateObject` function initializes new state objects ([statedb.go#L221-L227](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/statedb/statedb.go#L221-L227));\n13. `getOrNewStateObject` is only called by these functions: `AddBalance`, `SubBalance`, `SetNonce`, `SetCode`, `SetState` ([statedb.go#L290-L328](https://github.com/evmos/ethermint/blob/f7f1e1c18c64c912e7b5d524ae710e542b47e02a/x/evm/statedb/statedb.go#L290-L328)).\n\nThus, a new account object in the state database is only created when an address receives native coins, sends a transaction (which increases the nonce), or when contract code is deployed at it.\n\n**Example Exploit Scenario**\n\n1.  Alice deploys a smart contract that attracts a lot of users.\n2.  Alice registers the contract in Turnstile. As a recipient contract for the NFT, Alice decides to use a dedicated address that hasn't been used for anything else before (hasn't received coins, hasn't sent a transaction, etc.).\n3.  The `register` function call succeeds and Alice's contract gets registered in Turnstile.\n4.  However, due to the \"only existing recipient account\" check on the consensus layer, Alice's contract wasn't registered on the consensus layer and doesn't earn fees.\n5.  Since `register` and `assign` can only be called once (due to the `onlyUnregistered` modifier), Alice cannot re-register her contract. She can transfer the NFT to a different address, however this won't make the contract registered on the consensus layer and the owner of the NFT will never receive fees.\n\n### Recommended Mitigation Steps\n\nConsider removing the \"only existing recipient account\" check in the `RegisterEvent` handler since it creates a discrepancy between the application and the consensus layers. Otherwise, if it's mandatory that receiver addresses are not fresh, consider returning an error in the `PostTxProcessing` hook (which will revert a transaction) if there was an error during events processing.\n\n**[tkkwon1998 (Canto) confirmed and commented](https://github.com/code-423n4/2022-11-canto-findings/issues/93#issuecomment-1356328725):**\n > This is certainly an issue as there is a mismatch in checks between app and consensus layers.\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-11-canto",
  "Code": [
    {
      "filename": "CIP-001/src/Turnstile.sol",
      "content": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.8.17;\n\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"openzeppelin/utils/Counters.sol\";\n\n/// @notice Implementation of CIP-001 https://github.com/Canto-Improvement-Proposals/CIPs/blob/main/CIP-001.md\n/// @dev Every contract is responsible to register itself in the constructor by calling `register(address)`.\n///      If contract is using proxy pattern, it's possible to register retroactively, however past fees will be lost.\n///      Recipient withdraws fees by calling `withdraw(uint256,address,uint256)`.\ncontract Turnstile is Ownable, ERC721Enumerable {\n    using Counters for Counters.Counter;\n\n    struct NftData {\n        uint256 tokenId;\n        bool registered;\n    }\n\n    Counters.Counter private _tokenIdTracker;\n\n    /// @notice maps smart contract address to tokenId\n    mapping(address => NftData) public feeRecipient;\n\n    /// @notice maps tokenId to fees earned\n    mapping(uint256 => uint256) public balances;\n\n    event Register(address smartContract, address recipient, uint256 tokenId);\n    event Assign(address smartContract, uint256 tokenId);\n    event Withdraw(uint256 tokenId, address recipient, uint256 feeAmount);\n    event DistributeFees(uint256 tokenId, uint256 feeAmount);\n\n    error NotAnOwner();\n    error AlreadyRegistered();\n    error Unregistered();\n    error InvalidRecipient();\n    error InvalidTokenId();\n    error NothingToWithdraw();\n    error NothingToDistribute();\n\n    /// @dev only owner of _tokenId can call this function\n    modifier onlyNftOwner(uint256 _tokenId) {\n        if (ownerOf(_tokenId) != msg.sender) revert NotAnOwner();\n\n        _;\n    }\n\n    /// @dev only smart contract that is unregistered can call this function\n    modifier onlyUnregistered() {\n        address smartContract = msg.sender;\n\n        if (isRegistered(smartContract)) revert AlreadyRegistered();\n\n        _;\n    }\n\n    constructor() ERC721(\"Turnstile\", \"Turnstile\") {}\n\n    /// @notice Returns current value of counter used to tokenId of new minted NFTs\n    /// @return current counter value\n    function currentCounterId() external view returns (uint256) {\n        return _tokenIdTracker.current();\n    }\n\n    /// @notice Returns tokenId that collects fees generated by the smart contract\n    /// @param _smartContract address of the smart contract\n    /// @return tokenId that collects fees generated by the smart contract\n    function getTokenId(address _smartContract) external view returns (uint256) {\n        if (!isRegistered(_smartContract)) revert Unregistered();\n\n        return feeRecipient[_smartContract].tokenId;\n    }\n\n    /// @notice Returns true if smart contract is registered to collect fees\n    /// @param _smartContract address of the smart contract\n    /// @return true if smart contract is registered to collect fees, false otherwise\n    function isRegistered(address _smartContract) public view returns (bool) {\n        return feeRecipient[_smartContract].registered;\n    }\n\n    /// @notice Mints ownership NFT that allows the owner to collect fees earned by the smart contract.\n    ///         `msg.sender` is assumed to be a smart contract that earns fees. Only smart contract itself\n    ///         can register a fee receipient.\n    /// @param _recipient recipient of the ownership NFT\n    /// @return tokenId of the ownership NFT that collects fees\n    function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n        address smartContract = msg.sender;\n\n        if (_recipient == address(0)) revert InvalidRecipient();\n\n        tokenId = _tokenIdTracker.current();\n        _mint(_recipient, tokenId);\n        _tokenIdTracker.increment();\n\n        emit Register(smartContract, _recipient, tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: tokenId,\n            registered: true\n        });\n    }\n\n    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.\n    ///         Callable only by smart contract itself.\n    /// @param _tokenId tokenId which will collect fees\n    /// @return tokenId of the ownership NFT that collects fees\n    function assign(uint256 _tokenId) public onlyUnregistered returns (uint256) {\n        address smartContract = msg.sender;\n\n        if (!_exists(_tokenId)) revert InvalidTokenId();\n\n        emit Assign(smartContract, _tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: _tokenId,\n            registered: true\n        });\n\n        return _tokenId;\n    }\n\n    /// @notice Withdraws earned fees to `_recipient` address. Only callable by NFT owner.\n    /// @param _tokenId token Id\n    /// @param _recipient recipient of fees\n    /// @param _amount amount of fees to withdraw\n    /// @return amount of fees withdrawn\n    function withdraw(uint256 _tokenId, address payable _recipient, uint256 _amount)\n        public\n        onlyNftOwner(_tokenId)\n        returns (uint256)\n    {\n        uint256 earnedFees = balances[_tokenId];\n\n        if (earnedFees == 0 || _amount == 0) revert NothingToWithdraw();\n        if (_amount > earnedFees) _amount = earnedFees;\n\n        balances[_tokenId] = earnedFees - _amount;\n\n        emit Withdraw(_tokenId, _recipient, _amount);\n\n        Address.sendValue(_recipient, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Distributes collected fees to the smart contract. Only callable by owner.\n    /// @param _tokenId NFT that earned fees\n    function distributeFees(uint256 _tokenId) public onlyOwner payable {\n        if (msg.value == 0) revert NothingToDistribute();\n\n        balances[_tokenId] += msg.value;\n        emit DistributeFees(_tokenId, msg.value);\n    }\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/event_handler.go",
      "content": "package keeper\n\nimport (\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n)\n\n// Register events occur in the Turnstile Contract when a user is attempting to create a new\n// NFT with a smart contract that was just deployed. This event handler will unpack the\n// event data, validate that the smart contract address, check that the receiver address is not null,\n// and validate that this NFT is new. Only register can create new NFTs. Returns an error if the\n// register event fails.\nfunc (k Keeper) RegisterEvent(ctx sdk.Context, data []byte) error {\n\tvar event types.RegisterCSREvent\n\t// Unpack the data\n\terr := TurnstileContract.UnpackIntoInterface(&event, types.TurnstileEventRegister, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate that the contract entered can be registered\n\terr = k.ValidateContract(ctx, event.SmartContract)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check that the receiver account  exists in the evm store\n\tif acct := k.evmKeeper.GetAccount(ctx, event.Recipient); acct == nil {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentAcct, \"EventHandler::RegisterEvent account does not exist: %s\", event.Recipient)\n\t}\n\n\t// Set the NFTID in the store if it has not been registered yet\n\tnftID := event.TokenId.Uint64()\n\t_, found := k.GetCSR(ctx, nftID)\n\tif found {\n\t\treturn sdkerrors.Wrapf(ErrDuplicateNFTID, \"EventHandler::RegisterEvent this NFT id has already been registered: %d\", nftID)\n\t}\n\n\t// Create CSR object and perform stateless validation\n\tcsr := types.NewCSR(\n\t\t[]string{event.SmartContract.String()},\n\t\tnftID,\n\t)\n\tif err := csr.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\t// Set the CSR in the store\n\tk.SetCSR(ctx, csr)\n\n\treturn nil\n}\n\n// Update events occur in the Turnstile contract when a user is attempting to assign their newly\n// deployed smart contract to an existing NFT. This event handler will unpack the data, validate\n// that the smart contract to be assigned is valid, check that NFT id exists, and append the smart contract\n// to the NFT id entered. Update is permissionless in the sense that you do not have to be the owner\n// of the NFT to be able to add new smart contracts to it.\nfunc (k Keeper) UpdateEvent(ctx sdk.Context, data []byte) error {\n\tvar event types.UpdateCSREvent\n\t// Unpack the data\n\terr := TurnstileContract.UnpackIntoInterface(&event, types.TurnstileEventUpdate, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Validate that the contract entered can be registered\n\terr = k.ValidateContract(ctx, event.SmartContract)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the NFT that is being updated exists in the CSR store\n\tnftID := event.TokenId.Uint64()\n\tcsr, found := k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNFTNotFound, \"EventHandler::UpdateEvent the nft entered does not currently exist: %d\", nftID)\n\t}\n\t// Add the new smart contract to the CSR NFT and validate\n\tcsr.Contracts = append(csr.Contracts, event.SmartContract.String())\n\terr = csr.Validate()\n\tif err != nil {\n\t\treturn err\n\t}\n\tk.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\n// ValidateContract checks if the smart contract can be registered to a CSR. It checks\n// if the address is a smart contract address, whether the smart contract has code, and\n// whether the contract is already assigned to some other NFT.\nfunc (k Keeper) ValidateContract(ctx sdk.Context, contract common.Address) error {\n\t// Check if the smart contract is already registered -> prevent double registration\n\tnftID, found := k.GetNFTByContract(ctx, contract.String())\n\tif found {\n\t\treturn sdkerrors.Wrapf(ErrPrevRegisteredSmartContract,\n\t\t\t\"EventHandler::ValidateContract this smart contract is already registered to an existing NFT: %d\", nftID)\n\t}\n\n\t// Check if the user is attempting to register a non-smart contract address (i.e. an EOA or non-existent address)\n\taccount := k.evmKeeper.GetAccount(ctx, contract)\n\tif account == nil || !account.IsContract() {\n\t\treturn sdkerrors.Wrapf(ErrRegisterInvalidContract,\n\t\t\t\"EventHandler::ValidateContract user is attempting to register/assign a nil or non-smart contract address\")\n\t}\n\treturn nil\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/event_handler.go",
      "content": "package keeper\n\nimport (\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n)\n\n// Register events occur in the Turnstile Contract when a user is attempting to create a new\n// NFT with a smart contract that was just deployed. This event handler will unpack the\n// event data, validate that the smart contract address, check that the receiver address is not null,\n// and validate that this NFT is new. Only register can create new NFTs. Returns an error if the\n// register event fails.\nfunc (k Keeper) RegisterEvent(ctx sdk.Context, data []byte) error {\n\tvar event types.RegisterCSREvent\n\t// Unpack the data\n\terr := TurnstileContract.UnpackIntoInterface(&event, types.TurnstileEventRegister, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate that the contract entered can be registered\n\terr = k.ValidateContract(ctx, event.SmartContract)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check that the receiver account  exists in the evm store\n\tif acct := k.evmKeeper.GetAccount(ctx, event.Recipient); acct == nil {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentAcct, \"EventHandler::RegisterEvent account does not exist: %s\", event.Recipient)\n\t}\n\n\t// Set the NFTID in the store if it has not been registered yet\n\tnftID := event.TokenId.Uint64()\n\t_, found := k.GetCSR(ctx, nftID)\n\tif found {\n\t\treturn sdkerrors.Wrapf(ErrDuplicateNFTID, \"EventHandler::RegisterEvent this NFT id has already been registered: %d\", nftID)\n\t}\n\n\t// Create CSR object and perform stateless validation\n\tcsr := types.NewCSR(\n\t\t[]string{event.SmartContract.String()},\n\t\tnftID,\n\t)\n\tif err := csr.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\t// Set the CSR in the store\n\tk.SetCSR(ctx, csr)\n\n\treturn nil\n}\n\n// Update events occur in the Turnstile contract when a user is attempting to assign their newly\n// deployed smart contract to an existing NFT. This event handler will unpack the data, validate\n// that the smart contract to be assigned is valid, check that NFT id exists, and append the smart contract\n// to the NFT id entered. Update is permissionless in the sense that you do not have to be the owner\n// of the NFT to be able to add new smart contracts to it.\nfunc (k Keeper) UpdateEvent(ctx sdk.Context, data []byte) error {\n\tvar event types.UpdateCSREvent\n\t// Unpack the data\n\terr := TurnstileContract.UnpackIntoInterface(&event, types.TurnstileEventUpdate, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Validate that the contract entered can be registered\n\terr = k.ValidateContract(ctx, event.SmartContract)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the NFT that is being updated exists in the CSR store\n\tnftID := event.TokenId.Uint64()\n\tcsr, found := k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNFTNotFound, \"EventHandler::UpdateEvent the nft entered does not currently exist: %d\", nftID)\n\t}\n\t// Add the new smart contract to the CSR NFT and validate\n\tcsr.Contracts = append(csr.Contracts, event.SmartContract.String())\n\terr = csr.Validate()\n\tif err != nil {\n\t\treturn err\n\t}\n\tk.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\n// ValidateContract checks if the smart contract can be registered to a CSR. It checks\n// if the address is a smart contract address, whether the smart contract has code, and\n// whether the contract is already assigned to some other NFT.\nfunc (k Keeper) ValidateContract(ctx sdk.Context, contract common.Address) error {\n\t// Check if the smart contract is already registered -> prevent double registration\n\tnftID, found := k.GetNFTByContract(ctx, contract.String())\n\tif found {\n\t\treturn sdkerrors.Wrapf(ErrPrevRegisteredSmartContract,\n\t\t\t\"EventHandler::ValidateContract this smart contract is already registered to an existing NFT: %d\", nftID)\n\t}\n\n\t// Check if the user is attempting to register a non-smart contract address (i.e. an EOA or non-existent address)\n\taccount := k.evmKeeper.GetAccount(ctx, contract)\n\tif account == nil || !account.IsContract() {\n\t\treturn sdkerrors.Wrapf(ErrRegisterInvalidContract,\n\t\t\t\"EventHandler::ValidateContract user is attempting to register/assign a nil or non-smart contract address\")\n\t}\n\treturn nil\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/event_handler.go",
      "content": "package keeper\n\nimport (\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n)\n\n// Register events occur in the Turnstile Contract when a user is attempting to create a new\n// NFT with a smart contract that was just deployed. This event handler will unpack the\n// event data, validate that the smart contract address, check that the receiver address is not null,\n// and validate that this NFT is new. Only register can create new NFTs. Returns an error if the\n// register event fails.\nfunc (k Keeper) RegisterEvent(ctx sdk.Context, data []byte) error {\n\tvar event types.RegisterCSREvent\n\t// Unpack the data\n\terr := TurnstileContract.UnpackIntoInterface(&event, types.TurnstileEventRegister, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate that the contract entered can be registered\n\terr = k.ValidateContract(ctx, event.SmartContract)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check that the receiver account  exists in the evm store\n\tif acct := k.evmKeeper.GetAccount(ctx, event.Recipient); acct == nil {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentAcct, \"EventHandler::RegisterEvent account does not exist: %s\", event.Recipient)\n\t}\n\n\t// Set the NFTID in the store if it has not been registered yet\n\tnftID := event.TokenId.Uint64()\n\t_, found := k.GetCSR(ctx, nftID)\n\tif found {\n\t\treturn sdkerrors.Wrapf(ErrDuplicateNFTID, \"EventHandler::RegisterEvent this NFT id has already been registered: %d\", nftID)\n\t}\n\n\t// Create CSR object and perform stateless validation\n\tcsr := types.NewCSR(\n\t\t[]string{event.SmartContract.String()},\n\t\tnftID,\n\t)\n\tif err := csr.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\t// Set the CSR in the store\n\tk.SetCSR(ctx, csr)\n\n\treturn nil\n}\n\n// Update events occur in the Turnstile contract when a user is attempting to assign their newly\n// deployed smart contract to an existing NFT. This event handler will unpack the data, validate\n// that the smart contract to be assigned is valid, check that NFT id exists, and append the smart contract\n// to the NFT id entered. Update is permissionless in the sense that you do not have to be the owner\n// of the NFT to be able to add new smart contracts to it.\nfunc (k Keeper) UpdateEvent(ctx sdk.Context, data []byte) error {\n\tvar event types.UpdateCSREvent\n\t// Unpack the data\n\terr := TurnstileContract.UnpackIntoInterface(&event, types.TurnstileEventUpdate, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Validate that the contract entered can be registered\n\terr = k.ValidateContract(ctx, event.SmartContract)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the NFT that is being updated exists in the CSR store\n\tnftID := event.TokenId.Uint64()\n\tcsr, found := k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNFTNotFound, \"EventHandler::UpdateEvent the nft entered does not currently exist: %d\", nftID)\n\t}\n\t// Add the new smart contract to the CSR NFT and validate\n\tcsr.Contracts = append(csr.Contracts, event.SmartContract.String())\n\terr = csr.Validate()\n\tif err != nil {\n\t\treturn err\n\t}\n\tk.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\n// ValidateContract checks if the smart contract can be registered to a CSR. It checks\n// if the address is a smart contract address, whether the smart contract has code, and\n// whether the contract is already assigned to some other NFT.\nfunc (k Keeper) ValidateContract(ctx sdk.Context, contract common.Address) error {\n\t// Check if the smart contract is already registered -> prevent double registration\n\tnftID, found := k.GetNFTByContract(ctx, contract.String())\n\tif found {\n\t\treturn sdkerrors.Wrapf(ErrPrevRegisteredSmartContract,\n\t\t\t\"EventHandler::ValidateContract this smart contract is already registered to an existing NFT: %d\", nftID)\n\t}\n\n\t// Check if the user is attempting to register a non-smart contract address (i.e. an EOA or non-existent address)\n\taccount := k.evmKeeper.GetAccount(ctx, contract)\n\tif account == nil || !account.IsContract() {\n\t\treturn sdkerrors.Wrapf(ErrRegisterInvalidContract,\n\t\t\t\"EventHandler::ValidateContract user is attempting to register/assign a nil or non-smart contract address\")\n\t}\n\treturn nil\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/keeper.go",
      "content": "package keeper\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/tendermint/tendermint/libs/log\"\n\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/cosmos/cosmos-sdk/codec\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tparamtypes \"github.com/cosmos/cosmos-sdk/x/params/types\"\n)\n\ntype (\n\tKeeper struct {\n\t\tcdc        codec.BinaryCodec\n\t\tstoreKey   sdk.StoreKey\n\t\tparamstore paramtypes.Subspace\n\n\t\taccountKeeper    types.AccountKeeper\n\t\tevmKeeper        types.EVMKeeper\n\t\tbankKeeper       types.BankKeeper\n\t\tFeeCollectorName string\n\t}\n)\n\nfunc NewKeeper(\n\tcdc codec.BinaryCodec,\n\tstoreKey sdk.StoreKey,\n\tps paramtypes.Subspace,\n\taccountKeeper types.AccountKeeper,\n\tevmKeeper types.EVMKeeper,\n\tbankKeeper types.BankKeeper,\n\tFeeCollectorName string,\n) Keeper {\n\t// set KeyTable if it has not already been set\n\tif !ps.HasKeyTable() {\n\t\tps = ps.WithKeyTable(types.ParamKeyTable())\n\t}\n\n\treturn Keeper{\n\t\tstoreKey:         storeKey,\n\t\tcdc:              cdc,\n\t\tparamstore:       ps,\n\t\taccountKeeper:    accountKeeper,\n\t\tevmKeeper:        evmKeeper,\n\t\tbankKeeper:       bankKeeper,\n\t\tFeeCollectorName: FeeCollectorName,\n\t}\n}\n\nfunc (k Keeper) Logger(ctx sdk.Context) log.Logger {\n\treturn ctx.Logger().With(\"module\", fmt.Sprintf(\"x/%s\", types.ModuleName))\n}"
    },
    {
      "filename": "Canto/app/app.go",
      "content": "package app\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/rakyll/statik/fs\"\n\t\"github.com/spf13/cast\"\n\n\tabci \"github.com/tendermint/tendermint/abci/types\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmos \"github.com/tendermint/tendermint/libs/os\"\n\tdbm \"github.com/tendermint/tm-db\"\n\n\t\"github.com/cosmos/cosmos-sdk/baseapp\"\n\t\"github.com/cosmos/cosmos-sdk/client\"\n\t\"github.com/cosmos/cosmos-sdk/client/grpc/tmservice\"\n\t\"github.com/cosmos/cosmos-sdk/client/rpc\"\n\t\"github.com/cosmos/cosmos-sdk/codec\"\n\t\"github.com/cosmos/cosmos-sdk/codec/types\"\n\t\"github.com/cosmos/cosmos-sdk/server/api\"\n\t\"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n\t\"github.com/cosmos/cosmos-sdk/simapp\"\n\tsimappparams \"github.com/cosmos/cosmos-sdk/simapp/params\"\n\n\tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\t\"github.com/cosmos/cosmos-sdk/types/module\"\n\t\"github.com/cosmos/cosmos-sdk/version\"\n\t\"github.com/cosmos/cosmos-sdk/x/auth\"\n\tauthkeeper \"github.com/cosmos/cosmos-sdk/x/auth/keeper\"\n\tauthtx \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n\t\"github.com/cosmos/cosmos-sdk/x/authz\"\n\tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n\tauthzmodule \"github.com/cosmos/cosmos-sdk/x/authz/module\"\n\t\"github.com/cosmos/cosmos-sdk/x/bank\"\n\tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n\t\"github.com/cosmos/cosmos-sdk/x/capability\"\n\tcapabilitykeeper \"github.com/cosmos/cosmos-sdk/x/capability/keeper\"\n\tcapabilitytypes \"github.com/cosmos/cosmos-sdk/x/capability/types\"\n\t\"github.com/cosmos/cosmos-sdk/x/crisis\"\n\tcrisiskeeper \"github.com/cosmos/cosmos-sdk/x/crisis/keeper\"\n\tcrisistypes \"github.com/cosmos/cosmos-sdk/x/crisis/types\"\n\tdistr \"github.com/cosmos/cosmos-sdk/x/distribution\"\n\tdistrclient \"github.com/cosmos/cosmos-sdk/x/distribution/client\"\n\tdistrkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n\tdistrtypes \"github.com/cosmos/cosmos-sdk/x/distribution/types\"\n\t\"github.com/cosmos/cosmos-sdk/x/evidence\"\n\tevidencekeeper \"github.com/cosmos/cosmos-sdk/x/evidence/keeper\"\n\tevidencetypes \"github.com/cosmos/cosmos-sdk/x/evidence/types\"\n\t\"github.com/cosmos/cosmos-sdk/x/feegrant\"\n\tfeegrantkeeper \"github.com/cosmos/cosmos-sdk/x/feegrant/keeper\"\n\tfeegrantmodule \"github.com/cosmos/cosmos-sdk/x/feegrant/module\"\n\t\"github.com/cosmos/cosmos-sdk/x/genutil\"\n\tgenutiltypes \"github.com/cosmos/cosmos-sdk/x/genutil/types\"\n\t\"github.com/cosmos/cosmos-sdk/x/gov\"\n\tgovkeeper \"github.com/cosmos/cosmos-sdk/x/gov/keeper\"\n\tgovtypes \"github.com/cosmos/cosmos-sdk/x/gov/types\"\n\t\"github.com/cosmos/cosmos-sdk/x/params\"\n\tparamsclient \"github.com/cosmos/cosmos-sdk/x/params/client\"\n\tparamskeeper \"github.com/cosmos/cosmos-sdk/x/params/keeper\"\n\tparamstypes \"github.com/cosmos/cosmos-sdk/x/params/types\"\n\tparamproposal \"github.com/cosmos/cosmos-sdk/x/params/types/proposal\"\n\t\"github.com/cosmos/cosmos-sdk/x/slashing\"\n\tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n\tslashingtypes \"github.com/cosmos/cosmos-sdk/x/slashing/types\"\n\t\"github.com/cosmos/cosmos-sdk/x/staking\"\n\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n\t\"github.com/cosmos/cosmos-sdk/x/upgrade\"\n\tupgradeclient \"github.com/cosmos/cosmos-sdk/x/upgrade/client\"\n\tupgradekeeper \"github.com/cosmos/cosmos-sdk/x/upgrade/keeper\"\n\tupgradetypes \"github.com/cosmos/cosmos-sdk/x/upgrade/types\"\n\n\t\"github.com/cosmos/ibc-go/v3/modules/apps/transfer\"\n\tibctransferkeeper \"github.com/cosmos/ibc-go/v3/modules/apps/transfer/keeper\"\n\tibctransfertypes \"github.com/cosmos/ibc-go/v3/modules/apps/transfer/types\"\n\tibc \"github.com/cosmos/ibc-go/v3/modules/core\"\n\tibcclient \"github.com/cosmos/ibc-go/v3/modules/core/02-client\"\n\tibcclientclient \"github.com/cosmos/ibc-go/v3/modules/core/02-client/client\"\n\tibcclienttypes \"github.com/cosmos/ibc-go/v3/modules/core/02-client/types\"\n\tporttypes \"github.com/cosmos/ibc-go/v3/modules/core/05-port/types\"\n\tibchost \"github.com/cosmos/ibc-go/v3/modules/core/24-host\"\n\tibckeeper \"github.com/cosmos/ibc-go/v3/modules/core/keeper\"\n\tibctesting \"github.com/cosmos/ibc-go/v3/testing\"\n\n\tethermintapp \"github.com/evmos/ethermint/app\"\n\t\"github.com/evmos/ethermint/encoding\"\n\tsrvflags \"github.com/evmos/ethermint/server/flags\"\n\tethermint \"github.com/evmos/ethermint/types\"\n\t\"github.com/evmos/ethermint/x/evm\"\n\tevmrest \"github.com/evmos/ethermint/x/evm/client/rest\"\n\tevmkeeper \"github.com/evmos/ethermint/x/evm/keeper\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n\t\"github.com/evmos/ethermint/x/feemarket\"\n\tfeemarketkeeper \"github.com/evmos/ethermint/x/feemarket/keeper\"\n\tfeemarkettypes \"github.com/evmos/ethermint/x/feemarket/types\"\n\n\t// unnamed import of statik for swagger UI support\n\t_ \"github.com/Canto-Network/Canto/v2/client/docs/statik\"\n\n\t\"github.com/Canto-Network/Canto/v2/app/ante\"\n\t\"github.com/Canto-Network/Canto/v2/x/epochs\"\n\tepochskeeper \"github.com/Canto-Network/Canto/v2/x/epochs/keeper\"\n\tepochstypes \"github.com/Canto-Network/Canto/v2/x/epochs/types\"\n\t\"github.com/Canto-Network/Canto/v2/x/erc20\"\n\terc20client \"github.com/Canto-Network/Canto/v2/x/erc20/client\"\n\terc20keeper \"github.com/Canto-Network/Canto/v2/x/erc20/keeper\"\n\terc20types \"github.com/Canto-Network/Canto/v2/x/erc20/types\"\n\t\"github.com/Canto-Network/Canto/v2/x/fees\"\n\tfeeskeeper \"github.com/Canto-Network/Canto/v2/x/fees/keeper\"\n\tfeestypes \"github.com/Canto-Network/Canto/v2/x/fees/types\"\n\n\t\"github.com/Canto-Network/Canto/v2/x/inflation\"\n\tinflationkeeper \"github.com/Canto-Network/Canto/v2/x/inflation/keeper\"\n\tinflationtypes \"github.com/Canto-Network/Canto/v2/x/inflation/types\"\n\t\"github.com/Canto-Network/Canto/v2/x/recovery\"\n\trecoverykeeper \"github.com/Canto-Network/Canto/v2/x/recovery/keeper\"\n\trecoverytypes \"github.com/Canto-Network/Canto/v2/x/recovery/types\"\n\t\"github.com/Canto-Network/Canto/v2/x/vesting\"\n\tvestingkeeper \"github.com/Canto-Network/Canto/v2/x/vesting/keeper\"\n\tvestingtypes \"github.com/Canto-Network/Canto/v2/x/vesting/types\"\n\n\t//govshuttle imports\n\t\"github.com/Canto-Network/Canto/v2/x/govshuttle\"\n\tgovshuttleclient \"github.com/Canto-Network/Canto/v2/x/govshuttle/client\"\n\tgovshuttlekeeper \"github.com/Canto-Network/Canto/v2/x/govshuttle/keeper\"\n\tgovshuttletypes \"github.com/Canto-Network/Canto/v2/x/govshuttle/types\"\n\n\t\"github.com/Canto-Network/Canto/v2/x/csr\"\n\tcsrkeeper \"github.com/Canto-Network/Canto/v2/x/csr/keeper\"\n\tcsrtypes \"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\n\tv2 \"github.com/Canto-Network/Canto/v2/app/upgrades/v2\"\n\tv5 \"github.com/Canto-Network/Canto/v2/app/upgrades/v5\"\n)\n\nfunc init() {\n\tuserHomeDir, err := os.UserHomeDir()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tDefaultNodeHome = filepath.Join(userHomeDir, \".cantod\")\n\n\t// manually update the power reduction by replacing micro (u) -> atto (a) Canto\n\tsdk.DefaultPowerReduction = ethermint.PowerReduction\n\t// modify fee market parameter defaults through global\n\tfeemarkettypes.DefaultMinGasPrice = sdk.NewDec(20_000_000_000)\n\tfeemarkettypes.DefaultMinGasMultiplier = sdk.NewDecWithPrec(5, 1)\n}\n\n// Name defines the application binary name\nconst Name = \"cantod\"\n\nvar (\n\t// DefaultNodeHome default home directories for the application daemon\n\tDefaultNodeHome string\n\n\t// ModuleBasics defines the module BasicManager is in charge of setting up basic,\n\t// non-dependant module elements, such as codec registration\n\t// and genesis verification.\n\tModuleBasics = module.NewBasicManager(\n\t\tauth.AppModuleBasic{},\n\t\tgenutil.AppModuleBasic{},\n\t\tbank.AppModuleBasic{},\n\t\tcapability.AppModuleBasic{},\n\t\tstaking.AppModuleBasic{},\n\t\tdistr.AppModuleBasic{},\n\t\tgov.NewAppModuleBasic(\n\t\t\tparamsclient.ProposalHandler, distrclient.ProposalHandler, upgradeclient.ProposalHandler, upgradeclient.CancelProposalHandler,\n\t\t\tibcclientclient.UpdateClientProposalHandler, ibcclientclient.UpgradeProposalHandler,\n\t\t\t// Canto proposal types\n\t\t\terc20client.RegisterCoinProposalHandler, erc20client.RegisterERC20ProposalHandler, erc20client.ToggleTokenConversionProposalHandler,\n\t\t\tgovshuttleclient.LendingMarketProposalHandler,\n\t\t\tgovshuttleclient.TreasuryProposalHandler,\n\t\t),\n\t\tparams.AppModuleBasic{},\n\t\tcrisis.AppModuleBasic{},\n\t\tslashing.AppModuleBasic{},\n\t\tibc"
    }
  ]
}