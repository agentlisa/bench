{
  "Title": "[H-01] Bond max-buyer might end up buying the max buy of the next epoch",
  "Content": "\nThe `MuteBond.deposit()` function allows users to specify the amount of value they want to purchase bonds for or to set `max_buy` to true.\nIf `max_buy` is set to true the amount specified in the `value` parameter is ignored and instead the maximum amount available for purchase in the current epoch is used.\nThis can lead to a scenario where a user intends to purchase the remaining amount of current epoch, but till the tx is included in the blockchain a new epoch starts (either by an innocent user or by an attacker) and the user ends up buying the entire amount of the next epoch.\n\n### Impact\n\nA. The user ends up buying a much higher amount than intended<br>\nB. The user ends up buying it for a lower price than intended (i.e. less payout for the buyer)\n\n### Proof of Concept\n\nThe PoC below shows how `maxPurchaseAmount()` increases when a new era starts.\n\nFile: `test/bonds.ts`\n\n```solidity\n  it('Max buy PoC', async function () {\n\n    // buy 99% of amount available for purchase in current epoch\n    let maxValue = await bondContract.maxPurchaseAmount();\n    let depositValue = maxValue.mul(99).div(100);\n    await bondContract.connect(buyer1).deposit(depositValue, buyer1.address, false);\n    \n    // The amount available when the victim sends out the tx\n    var expectedDeposit = await bondContract.maxPurchaseAmount()\n\n    await bondContract.connect(buyer1).deposit('0', buyer1.address, true);\n\n    // The amount available when the victims's tx is included in the blockchain\n    var actualDeposit = await bondContract.maxPurchaseAmount();    \n\n    // expected deposit = 1 wad\n    // actual deposit = 100 wad\n    console.log({expectedDeposit, actualDeposit});\n  })\n```\n\n[The following snippet](https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/bonds/MuteBond.sol#L156-L159) shows that when a user sets `max_buy` to true the value used is the `maxPurchaseAmount()`\n\n```solidity\n        if(max_buy == true){\n          value = maxPurchaseAmount();\n          payout = maxDeposit();\n        } else {\n```\n\n### Recommended Mitigation Steps\n\nRequire the user to specify the epoch number when doing a 'max buy', and revert if it doesn't match the current epoch (it might be a good idea to refactor the code to 2 external functions for normal buy and max buy, where they both share an internal function to make the actual deposit).\n\nSide note: this is similar to another bug I've reported regarding getting a lower price than expected, however the root cause, impact, and mitigation are different and therefore I've reported this separately.\n\n**[mattt21 (Mute Switch) confirmed](https://github.com/code-423n4/2023-03-mute-findings/issues/25#issuecomment-1499248207)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-03-mute-switch-versus-contest",
  "Code": [
    {
      "filename": "contracts/bonds/MuteBond.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../libraries/SafeMath.sol';\nimport '../libraries/TransferHelper.sol';\n\ncontract MuteBond {\n    using SafeMath for uint;\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated(uint deposit, uint payout, address depositor, uint time);\n    event BondPriceChanged(uint internalPrice, uint debtRatio);\n    event MaxPriceChanged(uint _price);\n    event MaxPayoutChanged(uint _price);\n    event EpochDurationChanged(uint _payout);\n    event BondLockTimeChanged(uint _duration);\n    event StartPriceChanged(uint _lock);\n\n     /* ======== STATE VARIABLES ======== */\n\n    address immutable private muteToken; // token paid for principal\n    address immutable private dMuteToken;\n    address immutable private lpToken; // inflow token\n    ITreasury immutable private customTreasury; // pays for and receives principal\n    uint public bond_time_lock = 7 days; // length of lockup in dMute for bonds\n\n    uint public totalPayoutGiven; // total amount of mute paid\n    uint public totalDebt; // total amount of LP collected\n\n    uint public epochDuration = 7 days; // the length of an epoch from getting from startPrice  to maxPrice\n    uint public maxPrice; // max limit price for the LP token (LP:mute ratio)\n    uint public startPrice; // start price of the LP token (LP:mute ratio)\n    uint public maxPayout; // max amount of mute tokens to sell in each epoch\n    uint public epochStart; // timestamp of the current epoch start\n    uint public epoch; // amount of cycles for bonds so far\n\n    BondTerms[] public terms; // identifies the terms for a bond in a given epoch\n    Bonds[] public bonds; // stores individual deposits\n\n    // Info for bond epochs\n    struct BondTerms {\n        uint bondTotal; // amount of tokens bonded so far\n        uint payoutTotal;\n        uint lastTimestamp;\n    }\n\n    // Info for a single depositors bond info\n    struct Bonds {\n        uint value; //\n        uint payout; //\n        address depositor; //\n        uint timestamp;\n    }\n\n\n\n    /* ======== CONSTRUCTOR ======== */\n\n    /**\n     *  @notice initializes the bond\n     *  @param _customTreasury address\n     *  @param _lpToken address\n     *  @param _dmuteToken address\n     *  @param _maxPrice uint\n     *  @param _startPrice uint\n     *  @param _maxPayout uint\n     */\n    constructor(address _customTreasury, address _lpToken, address _dmuteToken,\n                uint _maxPrice, uint _startPrice, uint _maxPayout) {\n        require( _customTreasury != address(0) && _lpToken != address(0));\n        customTreasury = ITreasury( _customTreasury );\n        muteToken = ITreasury(_customTreasury).payoutToken();\n        dMuteToken = _dmuteToken;\n\n        lpToken = _lpToken;\n\n        // approve lock token to spend payout\n        TransferHelper.safeApprove(muteToken, dMuteToken, type(uint256).max);\n\n\n        require(_maxPrice >= _startPrice, \"starting price < min\");\n\n        epochStart = block.timestamp;\n        maxPrice = _maxPrice;\n        startPrice = _startPrice;\n        maxPayout = _maxPayout;\n\n        terms.push(BondTerms(0,0,0));\n    }\n\n\n    /* ======== OWNER FUNCTIONS ======== */\n\n    /**\n     *  @notice sets the max limit price for the LP token\n     *  @param _price uint\n     */\n    function setMaxPrice(uint _price) external {\n        require(msg.sender == customTreasury.owner());\n        maxPrice = _price;\n        emit MaxPriceChanged(_price);\n    }\n\n    /**\n     *  @notice sets the start price for the LP token\n     *  @param _price uint\n     */\n    function setStartPrice(uint _price) external {\n        require(msg.sender == customTreasury.owner());\n        startPrice = _price;\n        emit StartPriceChanged(_price);\n    }\n\n    /**\n     *  @notice sets the max amount of mute tokens to sell in each epoch\n     *  @param _payout uint\n     */\n    function setMaxPayout(uint _payout) external {\n        require(msg.sender == customTreasury.owner());\n        maxPayout = _payout;\n        emit MaxPayoutChanged(_payout);\n    }\n\n    /**\n     *  @notice sets the length of bond epoch\n     *  @param _duration uint\n     */\n    function setEpochDuration(uint _duration) external {\n        require(msg.sender == customTreasury.owner());\n        epochDuration = _duration;\n        emit EpochDurationChanged(_duration);\n    }\n\n    /**\n     *  @notice sets the length of lockup for mute purchases in dMute\n     *  @param _lock uint\n     */\n    function setBondTimeLock(uint _lock) external {\n        require(msg.sender == customTreasury.owner());\n        bond_time_lock = _lock;\n        emit BondLockTimeChanged(_lock);\n    }\n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice purchase a bond with LP, bump bond price back by 5% after purchase based on current delta\n     *  @param value uint\n     *  @param _depositor address\n     *  @param max_buy bool\n     */\n    function deposit(uint value, address _depositor, bool max_buy) external returns (uint) {\n        // amount of mute tokens\n        uint payout = payoutFor( value );\n        if(max_buy == true){\n          value = maxPurchaseAmount();\n          payout = maxDeposit();\n        } else {\n          // safety checks for custom purchase\n          require( payout >= ((10**18) / 100), \"Bond too small\" ); // must be > 0.01 payout token ( underflow protection )\n          require( payout <= maxPayout, \"Bond too large\"); // size protection because there is no slippage\n          require( payout <= maxDeposit(), \"Deposit too large\"); // size protection because there is no slippage\n        }\n\n\n        // total debt is increased\n        totalDebt = totalDebt.add( value );\n        totalPayoutGiven = totalPayoutGiven.add(payout); // total payout increased\n\n        customTreasury.sendPayoutTokens(payout);\n        TransferHelper.safeTransferFrom(lpToken, msg.sender, address(customTreasury), value ); // transfer principal bonded to custom treasury\n\n        // indexed events are emitted\n        emit BondCreated(value, payout, _depositor, block.timestamp);\n\n        bonds.push(Bonds(value, payout, _depositor, block.timestamp));\n        // redeem bond for user, mint dMute tokens for duration of vest period\n        IDMute(dMuteToken).LockTo(payout, bond_time_lock, _depositor);\n\n        terms[epoch].payoutTotal = terms[epoch].payoutTotal + payout;\n        terms[epoch].bondTotal = terms[epoch].bondTotal + value;\n        terms[epoch].lastTimestamp = block.timestamp;\n\n        // adjust price by a ~5% premium of delta\n        uint timeElapsed = block.timestamp - epochStart;\n        epochStart = epochStart.add(timeElapsed.mul(5).div(100));\n        // safety check\n        if(epochStart >= block.timestamp)\n          epochStart = block.timestamp;\n\n        // exhausted this bond, issue new one\n        if(terms[epoch].payoutTotal == maxPayout){\n            terms.push(BondTerms(0,0,0));\n            epochStart = block.timestamp;\n            epoch++;\n        }\n\n        return payout;\n    }\n\n    /* ======== HELPER FUNCTIONS ======== */\n\n\n    /**\n     *  @notice returns bond info for the current epoch and global values\n     */\n    function bondInfo() external view returns (uint totDebt, uint totPayout, uint price, uint maxDep, uint maxPurchase, uint maxPay) {\n        totDebt = totalDebt;\n        totPayout = totalPayoutGiven;\n        price = bondPrice();\n        maxDep = maxDeposit();\n        maxPurchase = maxPurchaseAmount();\n        maxPay = maxPayout;\n    }\n\n    /**\n     *  @notice returns current epoch\n     */\n    function currentEpoch() public view returns (uint) {\n        return epoch;\n    }\n\n    /**\n     *  @notice returns current bond price\n     */\n    function bondPrice() public view returns (uint) {\n        uint timeElapsed = block.timestamp - epochStart;\n        uint priceDelta = maxPrice - startPrice;\n\n        if(timeElapsed > epochDuration)\n          timeElapsed = epochDuration;\n\n        return timeElapsed.mul(priceDelta).div(epochDuration).add(startPrice);\n    }\n\n    /**\n     *  @notice returns bond price for amount\n     *  @param _am uint\n     */\n    function payoutFor(uint _am) public view returns (uint) {\n        return bondPrice().mul(_am).div(10**18);\n    }\n\n    /**\n     *  @notice returns max amount of lp tokens receivable in current bond epoch\n     */\n    function maxPurchaseAmount() public view returns (uint) {\n        return maxDeposit().mul(10**18).div(bondPrice());\n    }\n\n    /**\n     *  @notice returns remaining mute tokens in current bond epoch\n     */\n    function maxDeposit() public view returns (uint) {\n        return maxPayout.sub(terms[epoch].payoutTotal);\n    }\n\n}\n\ninterface ITreasury {\n    function sendPayoutTokens(uint _amountPayoutToken) external;\n    function valueOfToken( address _principalTokenAddress, uint _amount ) external view returns ( uint value_ );\n    function payoutToken() external view returns (address);\n    function owner() external view returns (address);\n}\n\ninterface IDMute {\n  function LockTo(uint256 _amount, uint256 _lock_time, address to) external;\n}"
    }
  ]
}