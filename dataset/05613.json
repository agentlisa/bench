{
  "Title": "[M-08] `setAnnualInterestBips()` can be abused to keep a market's reserve ratio at 90%",
  "Content": "\nIf a borrower calls `setAnnualInterestBips()` to reduce a market's annual interest rate, its reserve ratio will be set to 90% for 2 weeks:\n\n[WildcatMarketController.sol#L472-L485](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketController.sol#L472-L485)\n\n```solidity\n    // If borrower is reducing the interest rate, increase the reserve\n    // ratio for the next two weeks.\n    if (annualInterestBips < WildcatMarket(market).annualInterestBips()) {\n      TemporaryReserveRatio storage tmp = temporaryExcessReserveRatio[market];\n\n      if (tmp.expiry == 0) {\n        tmp.reserveRatioBips = uint128(WildcatMarket(market).reserveRatioBips());\n\n        // Require 90% liquidity coverage for the next 2 weeks\n        WildcatMarket(market).setReserveRatioBips(9000);\n      }\n\n      tmp.expiry = uint128(block.timestamp + 2 weeks);\n    }\n```\n\nThis is meant to give lenders the option to withdraw from the market should they disagree with the decrease in annual interest rate.\n\nHowever, such an implementation can be abused by a borrower in a market where the reserve ratio above 90%:\n\n1. Borrower deploys a market with a reserve ratio at 95%.\n2. A lender, who agrees to a 95% reserve ratio, deposits into the market.\n3. Borrower calls `setAnnualInterestBips()` to reduce `annualInterestBips` by 1.\n   - This causes the market's reserve ratio to be set to 90% for 2 weeks.\n4. After 2 weeks, the borrower calls `setAnnualInterestBips()` and decreases `annualInterestBips` by 1 again.\n5. By repeating steps 3 and 4, the borrower can effectively keep the market's reserve ratio at 90% forever.\n\nIn the scenario above, the 5% reduction in reserve ratio works in favor of the borrower since they do not have to keep as much assets in the market. The amount of assets that all lenders can withdraw at any given time will also be 5% less than what it should be.\n\nNote that it is possible for a market to be deployed with a reserve ratio above 90% if the protocol's `MaximumReserveRatioBips` permits. For example, `MaximumReserveRatioBips` is set to 100% in current tests:\n\n[TestConstants.sol#L21](https://github.com/code-423n4/2023-10-wildcat/blob/main/test/shared/TestConstants.sol#L21)\n\n```solidity\nuint16 constant MaximumReserveRatioBips = 10_000;\n```\n\n### Impact\n\nIn a market where the reserve ratio is above 90%, a borrower can repeatedly call `setAnnualInterestBips()` every two weeks to keep the reserve ratio at 90%.\n\nThis is problematic, as a market's reserve ratio is not meant to be adjustable post-deployment, since the borrower and their lenders must agree to a fixed reserve ratio beforehand.\n\n### Recommended Mitigation\n\nIn `setAnnualInterestBips()`, consider setting the market's reserve ratio to 90% only if it is lower:\n\n[WildcatMarketController.sol#L472-L485](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketController.sol#L472-L485)\n\n```diff\n    // If borrower is reducing the interest rate, increase the reserve\n    // ratio for the next two weeks.\n-   if (annualInterestBips < WildcatMarket(market).annualInterestBips()) {\n+   if (annualInterestBips < WildcatMarket(market).annualInterestBips() && WildcatMarket(market).reserveRatioBips() < 9000) {\n      TemporaryReserveRatio storage tmp = temporaryExcessReserveRatio[market];\n\n      if (tmp.expiry == 0) {\n        tmp.reserveRatioBips = uint128(WildcatMarket(market).reserveRatioBips());\n\n        // Require 90% liquidity coverage for the next 2 weeks\n        WildcatMarket(market).setReserveRatioBips(9000);\n      }\n\n      tmp.expiry = uint128(block.timestamp + 2 weeks);\n    }\n```\n\n**[laurenceday (Wildcat) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/497#issuecomment-1803435735):**\n > Tricky one that we went over several times with wardens. 90% was presented here to illustrate the functionality of setting a higher reserve, rather than one we actually wanted to use. Turns out I misjudged the willingness to bikeshed this point. Not going to quibble over this being a medium, since it's on me and my documentation.\n> \n> The relationship between APR and willingness to grant credit is not linear - a 20% decrease in APR may induce far more than that amount of deposits to exit. At the same time, however, insisting on a full return of assets for a small decrease renders the credit facility useless to the borrower, while still leaving them liable to pay interest - in that situation, they might as well force a market closed and restart a different one.\n> \n> We've ultimately chosen to - for this first wave of markets - utilize the following formula:\n> \n> `newReserve = max(max(100%, 2 * (oldRate - newRate)/oldRate)), oldReserve)`\n> \n> As an example, reducing the lender APR of a market from 5% to 3% will require an 80% reserve ratio (twice the 40% relative difference), but if the previous ratio was higher than this, it persists. Meeting point between competing sets of interests.\n> \n> We've implemented this over the course of a few commits, final result is shown below -\n> \n> ![image](https://gist.github.com/assets/135237830/9759f3bc-46a9-4191-882c-3c3cbedffed7)\n>\n> ![image](https://gist.github.com/assets/135237830/74aa79f5-a3b1-45bd-aa61-a5ffdb607b77)\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/497#issuecomment-1804305663):**\n > I understand the sponsor's dissatisfaction about those findings and appreciate the insightful comment, as well as the proposed formula which would avoid the issue. However, it's my duty to judge the issues with respect to this audit's codebase (source of truth).\n\n**[laurenceday (Wildcat) confirmed](https://github.com/code-423n4/2023-10-wildcat-findings/issues/497#issuecomment-1810765652)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/WildcatMarketController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/utils/SafeTransferLib.sol';\nimport './market/WildcatMarket.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './interfaces/IWildcatMarketControllerEventsAndErrors.sol';\nimport './interfaces/IWildcatMarketControllerFactory.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\n\nstruct TemporaryReserveRatio {\n  uint128 reserveRatioBips;\n  uint128 expiry;\n}\n\nstruct TmpMarketParameterStorage {\n  address asset;\n  string namePrefix;\n  string symbolPrefix;\n  address feeRecipient;\n  uint16 protocolFeeBips;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n}\n\ncontract WildcatMarketController is IWildcatMarketControllerEventsAndErrors {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                 Immutables                                 */\n  /* -------------------------------------------------------------------------- */\n\n  IWildcatArchController public immutable archController;\n\n  IWildcatMarketControllerFactory public immutable controllerFactory;\n\n  address public immutable borrower;\n\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  EnumerableSet.AddressSet internal _authorizedLenders;\n  EnumerableSet.AddressSet internal _controlledMarkets;\n\n  /// @dev Temporary storage for market parameters, used during market deployment\n  TmpMarketParameterStorage internal _tmpMarketParameters;\n\n  mapping(address => TemporaryReserveRatio) public temporaryExcessReserveRatio;\n\n  // MarketParameterConstraints internal immutable constraints\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) {\n      revert CallerNotBorrower();\n    }\n    _;\n  }\n\n  modifier onlyControlledMarket(address market) {\n    if (!_controlledMarkets.contains(market)) {\n      revert NotControlledMarket();\n    }\n    _;\n  }\n\n  constructor() {\n    controllerFactory = IWildcatMarketControllerFactory(msg.sender);\n    MarketControllerParameters memory parameters = controllerFactory.getMarketControllerParameters();\n    archController = IWildcatArchController(parameters.archController);\n    borrower = parameters.borrower;\n    sentinel = parameters.sentinel;\n    marketInitCodeStorage = parameters.marketInitCodeStorage;\n    marketInitCodeHash = parameters.marketInitCodeHash;\n    MinimumDelinquencyGracePeriod = parameters.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = parameters.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = parameters.minimumReserveRatioBips;\n    MaximumReserveRatioBips = parameters.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = parameters.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = parameters.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = parameters.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = parameters.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = parameters.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = parameters.maximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                               Lender Registry                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the set of authorized lenders.\n   */\n  function getAuthorizedLenders() external view returns (address[] memory) {\n    return _authorizedLenders.values();\n  }\n\n  function getAuthorizedLenders(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _authorizedLenders.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _authorizedLenders.at(start + i);\n    }\n  }\n\n  function getAuthorizedLendersCount() external view returns (uint256) {\n    return _authorizedLenders.length();\n  }\n\n  function isAuthorizedLender(address lender) external view virtual returns (bool) {\n    return _authorizedLenders.contains(lender);\n  }\n\n  /**\n   * @dev Grant authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function authorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.add(lender)) {\n        emit LenderAuthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Revoke authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function deauthorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.remove(lender)) {\n        emit LenderDeauthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Update lender authorization for a set of markets to the current\n   *      status.\n   */\n  function updateLenderAuthorization(address lender, address[] memory markets) external {\n    for (uint256 i; i < markets.length; i++) {\n      address market = markets[i];\n      if (!_controlledMarkets.contains(market)) {\n        revert NotControlledMarket();\n      }\n      WildcatMarket(market).updateAccountAuthorization(lender, _authorizedLenders.contains(lender));\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                Market Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  function isControlledMarket(address market) external view returns (bool) {\n    return _controlledMarkets.contains(market);\n  }\n\n  function getControlledMarkets() external view returns (address[] memory) {\n    return _controlledMarkets.values();\n  }\n\n  function getControlledMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controlledMarkets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controlledMarkets.at(start + i);\n    }\n  }\n\n  function getControlledMarketsCount() external view returns (uint256) {\n    return _controlledMarkets.length();\n  }\n\n  function computeMarketAddress(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) external view returns (address) {\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    return LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                              Market Deployment                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Get the temporarily stored market parameters for a market that is\n   *      currently being deployed.\n   */\n  function getMarketParameters() external view returns (MarketParameters memory parameters) {\n    parameters.asset = _tmpMarketParameters.asset;\n    parameters.namePrefix = _tmpMarketParameters.namePrefix;\n    parameters.symbolPrefix = _tmpMarketParameters.symbolPrefix;\n    parameters.borrower = borrower;\n    parameters.controller = address(this);\n    parameters.feeRecipient = _tmpMarketParameters.feeRecipient;\n    parameters.sentinel = sentinel;\n    parameters.maxTotalSupply = _tmpMarketParameters.maxTotalSupply;\n    parameters.protocolFeeBips = _tmpMarketParameters.protocolFeeBips;\n    parameters.annualInterestBips = _tmpMarketParameters.annualInterestBips;\n    parameters.delinquencyFeeBips = _tmpMarketParameters.delinquencyFeeBips;\n    parameters.withdrawalBatchDuration = _tmpMarketParameters.withdrawalBatchDuration;\n    parameters.reserveRatioBips = _tmpMarketParameters.reserveRatioBips;\n    parameters.delinquencyGracePeriod = _tmpMarketParameters.delinquencyGracePeriod;\n  }\n\n  function _resetTmpMarketParameters() internal {\n    _tmpMarketParameters.asset = address(1);\n    _tmpMarketParameters.namePrefix = '_';\n    _tmpMarketParameters.symbolPrefix = '_';\n    _tmpMarketParameters.feeRecipient = address(1);\n    _tmpMarketParameters.protocolFeeBips = 1;\n    _tmpMarketParameters.maxTotalSupply = 1;\n    _tmpMarketParameters.annualInterestBips = 1;\n    _tmpMarketParameters.delinquencyFeeBips = 1;\n    _tmpMarketParameters.withdrawalBatchDuration = 1;\n    _tmpMarketParameters.reserveRatioBips = 1;\n    _tmpMarketParameters.delinquencyGracePeriod = 1;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarket` unique to the\n   *      combination of `asset, namePrefix, symbolPrefix` and registers\n   *      it with the arch-controller.\n   *\n   *      If a market has already been deployed with these parameters,\n   *      reverts with `MarketAlreadyDeployed`.\n   *\n   *      If `msg.sender` is not `borrower` or `controllerFactory`,\n   *      reverts with `CallerNotBorrowerOrControllerFactory`.\n   *\n   *\t    If `msg.sender == borrower && !archController.isRegisteredBorrower(msg.sender)`,\n   *\t\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      If called by `controllerFactory`, skips borrower check.\n   *\n   *      If either string is empty, reverts with `EmptyString`.\n   *\n   *      If `originationFeeAmount` returned by controller factory is not zero,\n   *      transfers `originationFeeAmount` of `originationFeeAsset` from\n   *      `msg.sender` to `feeRecipient`.\n   */\n  function deployMarket(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address market) {\n    if (msg.sender == borrower) {\n      if (!archController.isRegisteredBorrower(msg.sender)) {\n        revert NotRegisteredBorrower();\n      }\n    } else if (msg.sender != address(controllerFactory)) {\n      revert CallerNotBorrowerOrControllerFactory();\n    }\n\n    enforceParameterConstraints(\n      namePrefix,\n      symbolPrefix,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n\n    TmpMarketParameterStorage memory parameters = TmpMarketParameterStorage({\n      asset: asset,\n      namePrefix: namePrefix,\n      symbolPrefix: symbolPrefix,\n      feeRecipient: address(0),\n      maxTotalSupply: maxTotalSupply,\n      protocolFeeBips: 0,\n      annualInterestBips: annualInterestBips,\n      delinquencyFeeBips: delinquencyFeeBips,\n      withdrawalBatchDuration: withdrawalBatchDuration,\n      reserveRatioBips: reserveRatioBips,\n      delinquencyGracePeriod: delinquencyGracePeriod\n    });\n\n    address originationFeeAsset;\n    uint80 originationFeeAmount;\n    (\n      parameters.feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      parameters.protocolFeeBips\n    ) = controllerFactory.getProtocolFeeConfiguration();\n\n    _tmpMarketParameters = parameters;\n\n    if (originationFeeAsset != address(0)) {\n      originationFeeAsset.safeTransferFrom(borrower, parameters.feeRecipient, originationFeeAmount);\n    }\n\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n    if (market.codehash != bytes32(0)) {\n      revert MarketAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    archController.registerMarket(market);\n    _controlledMarkets.add(market);\n\n    _resetTmpMarketParameters();\n  }\n\n  /**\n   * @dev Derive create2 salt for a market given the asset address,\n   *      name prefix and symbol prefix.\n   *\n   *      The salt is unique to each market deployment in the controller,\n   *      so only one market can be deployed for each combination of `asset`,\n   *      `namePrefix` and `symbolPrefix`\n   */\n  function _deriveSalt(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) internal pure returns (bytes32 salt) {\n    assembly {\n      // Cache free memory pointer\n      let freeMemoryPointer := mload(0x40)\n      // `keccak256(abi.encode(asset, keccak256(namePrefix), keccak256(symbolPrefix)))`\n      mstore(0x00, asset)\n      mstore(0x20, keccak256(add(namePrefix, 32), mload(namePrefix)))\n      mstore(0x40, keccak256(add(symbolPrefix, 32), mload(symbolPrefix)))\n      salt := keccak256(0, 0x60)\n      // Restore free memory pointer\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n\n  /**\n   * @dev Enforce constraints on market parameters, ensuring that\n   *      `annualInterestBips`, `delinquencyFeeBips`, `withdrawalBatchDuration`,\n   *      `reserveRatioBips` and `delinquencyGracePeriod` are within the\n   *      allowed ranges and that `namePrefix` and `symbolPrefix` are not null.\n   */\n  function enforceParameterConstraints(\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n    assembly {\n      if or(iszero(mload(namePrefix)), iszero(mload(symbolPrefix))) {\n        // revert EmptyString();\n        mstore(0x00, 0xecd7b0d1)\n        revert(0x1c, 0x04)\n      }\n    }\n    assertValueInRange(\n      annualInterestBips,\n      MinimumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      AnnualInterestBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyFeeBips,\n      MinimumDelinquencyFeeBips,\n      MaximumDelinquencyFeeBips,\n      DelinquencyFeeBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      withdrawalBatchDuration,\n      MinimumWithdrawalBatchDuration,\n      MaximumWithdrawalBatchDuration,\n      WithdrawalBatchDurationOutOfBounds.selector\n    );\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    view\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /**\n   * @dev Modify the interest rate for a market.\n   * If the new interest rate is lower than the current interest rate,\n   * the reserve ratio is set to 90% for the next two weeks.\n   */\n  function setAnnualInterestBips(\n    address market,\n    uint16 annualInterestBips\n  ) external virtual onlyBorrower onlyControlledMarket(market) {\n    // If borrower is reducing the interest rate, increase the reserve\n    // ratio for the next two weeks.\n    if (annualInterestBips < WildcatMarket(market).annualInterestBips()) {\n      TemporaryReserveRatio storage tmp = temporaryExcessReserveRatio[market];\n\n      if (tmp.expiry == 0) {\n        tmp.reserveRatioBips = uint128(WildcatMarket(market).reserveRatioBips());\n\n        // Require 90% liquidity coverage for the next 2 weeks\n        WildcatMarket(market).setReserveRatioBips(9000);\n      }\n\n      tmp.expiry = uint128(block.timestamp + 2 weeks);\n    }\n\n    WildcatMarket(market).setAnnualInterestBips(annualInterestBips);\n  }\n\n  function resetReserveRatio(address market) external virtual {\n    TemporaryReserveRatio memory tmp = temporaryExcessReserveRatio[market];\n    if (tmp.expiry == 0) {\n      revertWithSelector(AprChangeNotPending.selector);\n    }\n    if (block.timestamp < tmp.expiry) {\n      revertWithSelector(ExcessReserveRatioStillActive.selector);\n    }\n\n    WildcatMarket(market).setReserveRatioBips(uint256(tmp.reserveRatioBips).toUint16());\n    delete temporaryExcessReserveRatio[market];\n  }\n\n  function assertValueInRange(\n    uint256 value,\n    uint256 min,\n    uint256 max,\n    bytes4 errorSelector\n  ) internal pure {\n    assembly {\n      if or(lt(value, min), gt(value, max)) {\n        mstore(0, errorSelector)\n        revert(0, 4)\n      }\n    }\n  }\n}"
    },
    {
      "filename": "test/shared/TestConstants.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\naddress constant alice = address(0xa11ce);\naddress constant bob = address(0xb0b);\naddress constant feeRecipient = address(0xfee);\naddress constant borrower = address(0xb04405e4);\n\nuint128 constant DefaultMaximumSupply = 100_000e18;\nuint16 constant DefaultInterest = 1000;\nuint16 constant DefaultDelinquencyFee = 1000;\nuint16 constant DefaultReserveRatio = 2000;\nuint32 constant DefaultGracePeriod = 2000;\nuint16 constant DefaultProtocolFeeBips = 1000;\nuint32 constant DefaultWithdrawalBatchDuration = 86400;\n\nuint32 constant MinimumDelinquencyGracePeriod = 0;\nuint32 constant MaximumDelinquencyGracePeriod = 86_400;\n\nuint16 constant MinimumReserveRatioBips = 1_000;\nuint16 constant MaximumReserveRatioBips = 10_000;\n\nuint16 constant MinimumDelinquencyFeeBips = 1_000;\nuint16 constant MaximumDelinquencyFeeBips = 10_000;\n\nuint32 constant MinimumWithdrawalBatchDuration = 0;\nuint32 constant MaximumWithdrawalBatchDuration = 365 days;\n\nuint16 constant MinimumAnnualInterestBips = 0;\nuint16 constant MaximumAnnualInterestBips = 10_000;"
    },
    {
      "filename": "src/WildcatMarketController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/utils/SafeTransferLib.sol';\nimport './market/WildcatMarket.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './interfaces/IWildcatMarketControllerEventsAndErrors.sol';\nimport './interfaces/IWildcatMarketControllerFactory.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\n\nstruct TemporaryReserveRatio {\n  uint128 reserveRatioBips;\n  uint128 expiry;\n}\n\nstruct TmpMarketParameterStorage {\n  address asset;\n  string namePrefix;\n  string symbolPrefix;\n  address feeRecipient;\n  uint16 protocolFeeBips;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n}\n\ncontract WildcatMarketController is IWildcatMarketControllerEventsAndErrors {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                 Immutables                                 */\n  /* -------------------------------------------------------------------------- */\n\n  IWildcatArchController public immutable archController;\n\n  IWildcatMarketControllerFactory public immutable controllerFactory;\n\n  address public immutable borrower;\n\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  EnumerableSet.AddressSet internal _authorizedLenders;\n  EnumerableSet.AddressSet internal _controlledMarkets;\n\n  /// @dev Temporary storage for market parameters, used during market deployment\n  TmpMarketParameterStorage internal _tmpMarketParameters;\n\n  mapping(address => TemporaryReserveRatio) public temporaryExcessReserveRatio;\n\n  // MarketParameterConstraints internal immutable constraints\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) {\n      revert CallerNotBorrower();\n    }\n    _;\n  }\n\n  modifier onlyControlledMarket(address market) {\n    if (!_controlledMarkets.contains(market)) {\n      revert NotControlledMarket();\n    }\n    _;\n  }\n\n  constructor() {\n    controllerFactory = IWildcatMarketControllerFactory(msg.sender);\n    MarketControllerParameters memory parameters = controllerFactory.getMarketControllerParameters();\n    archController = IWildcatArchController(parameters.archController);\n    borrower = parameters.borrower;\n    sentinel = parameters.sentinel;\n    marketInitCodeStorage = parameters.marketInitCodeStorage;\n    marketInitCodeHash = parameters.marketInitCodeHash;\n    MinimumDelinquencyGracePeriod = parameters.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = parameters.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = parameters.minimumReserveRatioBips;\n    MaximumReserveRatioBips = parameters.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = parameters.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = parameters.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = parameters.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = parameters.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = parameters.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = parameters.maximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                               Lender Registry                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the set of authorized lenders.\n   */\n  function getAuthorizedLenders() external view returns (address[] memory) {\n    return _authorizedLenders.values();\n  }\n\n  function getAuthorizedLenders(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _authorizedLenders.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _authorizedLenders.at(start + i);\n    }\n  }\n\n  function getAuthorizedLendersCount() external view returns (uint256) {\n    return _authorizedLenders.length();\n  }\n\n  function isAuthorizedLender(address lender) external view virtual returns (bool) {\n    return _authorizedLenders.contains(lender);\n  }\n\n  /**\n   * @dev Grant authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function authorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.add(lender)) {\n        emit LenderAuthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Revoke authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function deauthorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.remove(lender)) {\n        emit LenderDeauthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Update lender authorization for a set of markets to the current\n   *      status.\n   */\n  function updateLenderAuthorization(address lender, address[] memory markets) external {\n    for (uint256 i; i < markets.length; i++) {\n      address market = markets[i];\n      if (!_controlledMarkets.contains(market)) {\n        revert NotControlledMarket();\n      }\n      WildcatMarket(market).updateAccountAuthorization(lender, _authorizedLenders.contains(lender));\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                Market Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  function isControlledMarket(address market) external view returns (bool) {\n    return _controlledMarkets.contains(market);\n  }\n\n  function getControlledMarkets() external view returns (address[] memory) {\n    return _controlledMarkets.values();\n  }\n\n  function getControlledMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controlledMarkets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controlledMarkets.at(start + i);\n    }\n  }\n\n  function getControlledMarketsCount() external view returns (uint256) {\n    return _controlledMarkets.length();\n  }\n\n  function computeMarketAddress(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) external view returns (address) {\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    return LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                              Market Deployment                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Get the temporarily stored market parameters for a market that is\n   *      currently being deployed.\n   */\n  function getMarketParameters() external view returns (MarketParameters memory parameters) {\n    parameters.asset = _tmpMarketParameters.asset;\n    parameters.namePrefix = _tmpMarketParameters.namePrefix;\n    parameters.symbolPrefix = _tmpMarketParameters.symbolPrefix;\n    parameters.borrower = borrower;\n    parameters.controller = address(this);\n    parameters.feeRecipient = _tmpMarketParameters.feeRecipient;\n    parameters.sentinel = sentinel;\n    parameters.maxTotalSupply = _tmpMarketParameters.maxTotalSupply;\n    parameters.protocolFeeBips = _tmpMarketParameters.protocolFeeBips;\n    parameters.annualInterestBips = _tmpMarketParameters.annualInterestBips;\n    parameters.delinquencyFeeBips = _tmpMarketParameters.delinquencyFeeBips;\n    parameters.withdrawalBatchDuration = _tmpMarketParameters.withdrawalBatchDuration;\n    parameters.reserveRatioBips = _tmpMarketParameters.reserveRatioBips;\n    parameters.delinquencyGracePeriod = _tmpMarketParameters.delinquencyGracePeriod;\n  }\n\n  function _resetTmpMarketParameters() internal {\n    _tmpMarketParameters.asset = address(1);\n    _tmpMarketParameters.namePrefix = '_';\n    _tmpMarketParameters.symbolPrefix = '_';\n    _tmpMarketParameters.feeRecipient = address(1);\n    _tmpMarketParameters.protocolFeeBips = 1;\n    _tmpMarketParameters.maxTotalSupply = 1;\n    _tmpMarketParameters.annualInterestBips = 1;\n    _tmpMarketParameters.delinquencyFeeBips = 1;\n    _tmpMarketParameters.withdrawalBatchDuration = 1;\n    _tmpMarketParameters.reserveRatioBips = 1;\n    _tmpMarketParameters.delinquencyGracePeriod = 1;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarket` unique to the\n   *      combination of `asset, namePrefix, symbolPrefix` and registers\n   *      it with the arch-controller.\n   *\n   *      If a market has already been deployed with these parameters,\n   *      reverts with `MarketAlreadyDeployed`.\n   *\n   *      If `msg.sender` is not `borrower` or `controllerFactory`,\n   *      reverts with `CallerNotBorrowerOrControllerFactory`.\n   *\n   *\t    If `msg.sender == borrower && !archController.isRegisteredBorrower(msg.sender)`,\n   *\t\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      If called by `controllerFactory`, skips borrower check.\n   *\n   *      If either string is empty, reverts with `EmptyString`.\n   *\n   *      If `originationFeeAmount` returned by controller factory is not zero,\n   *      transfers `originationFeeAmount` of `originationFeeAsset` from\n   *      `msg.sender` to `feeRecipient`.\n   */\n  function deployMarket(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address market) {\n    if (msg.sender == borrower) {\n      if (!archController.isRegisteredBorrower(msg.sender)) {\n        revert NotRegisteredBorrower();\n      }\n    } else if (msg.sender != address(controllerFactory)) {\n      revert CallerNotBorrowerOrControllerFactory();\n    }\n\n    enforceParameterConstraints(\n      namePrefix,\n      symbolPrefix,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n\n    TmpMarketParameterStorage memory parameters = TmpMarketParameterStorage({\n      asset: asset,\n      namePrefix: namePrefix,\n      symbolPrefix: symbolPrefix,\n      feeRecipient: address(0),\n      maxTotalSupply: maxTotalSupply,\n      protocolFeeBips: 0,\n      annualInterestBips: annualInterestBips,\n      delinquencyFeeBips: delinquencyFeeBips,\n      withdrawalBatchDuration: withdrawalBatchDuration,\n      reserveRatioBips: reserveRatioBips,\n      delinquencyGracePeriod: delinquencyGracePeriod\n    });\n\n    address originationFeeAsset;\n    uint80 originationFeeAmount;\n    (\n      parameters.feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      parameters.protocolFeeBips\n    ) = controllerFactory.getProtocolFeeConfiguration();\n\n    _tmpMarketParameters = parameters;\n\n    if (originationFeeAsset != address(0)) {\n      originationFeeAsset.safeTransferFrom(borrower, parameters.feeRecipient, originationFeeAmount);\n    }\n\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n    if (market.codehash != bytes32(0)) {\n      revert MarketAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    archController.registerMarket(market);\n    _controlledMarkets.add(market)"
    }
  ]
}