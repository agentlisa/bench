{
  "Title": "Read-only reentrancy is possible in SponsorPaymaster",
  "Content": "##### Description\n\n`SponsorPaymaster.withdrawTokensTo()` does not follow CEI pattern:\n1) sends native tokens to the withdrawal target\n2) then updates balances\n- https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/paymasters/SponsorPaymaster.sol#L107-L108\n\nWhen native tokens are withdrawn, it uses a raw call without gas limits, so the reentrancy is possible:\n```\n(bool success, ) = withdrawAddress.call{value: withdrawAmount}(\"\");\n```\n- https://github.com/eth-infinitism/account-abstraction/blob/558e024161cf355e5a0fa59b1b5c0c5cb5aeac74/contracts/core/StakeManager.sol#L145C9-L145C76\n\nIn this case, the withdrawal target is able to receive tokens and run additional attack logic.\n\nAt least, in this reentrancy, some read-only functions will return wrong balances:\n- https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/paymasters/SponsorPaymaster.sol#L119-L120\n- https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/paymasters/SponsorPaymaster.sol#L32\n\n##### Recommendation\n\nWe recommend replacing lines from:\n```\n        withdrawTo(payable(target), amount);\n        balances[msg.sender] -= amount;\n```\n...to:\n```\n        balances[msg.sender] -= amount;\n        withdrawTo(payable(target), amount);\n```\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/paymasters/SponsorPaymaster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '../interfaces/ISponsorPaymaster.sol';\n\nimport '@aa/core/BasePaymaster.sol';\nimport 'forge-std/console2.sol';\n\n/**\n * An ETH-based paymaster that accepts ETH deposits\n * The deposit is only a safeguard: the user pays with his ETH deposited in the entry point if any.\n * The deposit is locked for the current block: the user must issue unlockTokenDeposit() to be allowed to withdraw\n *  (but can't use the deposit for this or further operations)\n *\n * paymasterAndData holds the paymaster address followed by the token address to use.\n */\ncontract SponsorPaymaster is Initializable, BasePaymaster, UUPSUpgradeable, ReentrancyGuard, ISponsorPaymaster {\n\n    using UserOperationLib for UserOperation;\n    using SafeERC20 for IERC20;\n\n    //calculated cost of the postOp\n    uint256 constant public COST_OF_POST = 35000;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public contractSpent; // keeps track of total gas consumption by contract\n    mapping(address => uint256) public unlockBlock;\n\n    constructor(IEntryPoint __entryPoint) BasePaymaster(__entryPoint) {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev The _entryPoint member is immutable, to reduce gas consumption.  To upgrade EntryPoint,\n     * a new implementation of SimpleAccount must be deployed with the new EntryPoint address, then upgrading\n     * the implementation by calling `upgradeTo()`\n     */\n    function initialize(address _owner) external virtual initializer {\n        __UUPSUpgradeable_init();\n        _transferOwnership(_owner);\n        // unlocks owner\n        unlockTokenDeposit();\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by an owner.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the implementation is upgraded\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        require(msg.sender == owner(), 'SponsorPaymaster: not owner');\n        (newImplementation);\n    }\n\n    /**\n     * ETH value that a specific account can use to pay for gas.\n     * Note depositing the tokens is equivalent to transferring them to the \"account\" - only the account can later\n     *  use them - either as gas, or using withdrawTo()\n     *\n     * @param account the account to deposit for.\n     * msg.value the amount of token to deposit.\n     */\n    function addDepositFor(address account) payable external override {\n        require(msg.value > 0, 'requires a deposit');\n        //(sender must have approval for the paymaster)\n        balances[account] += msg.value;\n        if (msg.sender == account) {\n            lockTokenDeposit();\n        }\n        this.deposit{value: msg.value}();\n    }\n\n    /**\n     * Unlocks deposit, so that it can be withdrawn.\n     * can't be called in the same block as withdrawTo()\n     */\n    function unlockTokenDeposit() public override {\n        unlockBlock[msg.sender] = block.number;\n    }\n\n    /**\n     * Lock the ETH deposited for this account so they can be used to pay for gas.\n     * after calling unlockTokenDeposit(), the account can't use this paymaster until the deposit is locked.\n     */\n    function lockTokenDeposit() public override {\n        unlockBlock[msg.sender] = 0;\n    }\n\n    /**\n     * Withdraw ETH\n     * can only be called after unlock() is called in a previous block.\n     * @param target address to send to\n     * @param amount amount to withdraw\n     */\n    function withdrawTokensTo(address target, uint256 amount) external override nonReentrant() {\n        require(\n            unlockBlock[msg.sender] != 0 && block.number > unlockBlock[msg.sender],\n            'DepositPaymaster: must unlockTokenDeposit'\n        );\n        withdrawTo(payable(target), amount);\n        balances[msg.sender] -= amount;\n    }\n\n    /*******************************\n      Viewers *********************\n    *******************************/\n\n    /**\n     * @return amount - the amount of given token deposited to the Paymaster.\n     * @return _unlockBlock - the block height at which the deposit can be withdrawn.\n     */\n    function depositInfo(address account) public view returns (uint256 amount, uint256 _unlockBlock) {\n        amount = balances[account];\n        _unlockBlock = unlockBlock[account];\n    }\n\n    /**\n     * Validate the request:\n     * The sender should have enough deposit to pay the max possible cost.\n     * Note that the sender's balance is not checked. If it fails to pay from its balance,\n     * this deposit will be used to compensate the paymaster for the transaction.\n     */\n    function _validatePaymasterUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal view override returns (bytes memory context, uint256 validationData) {\n        (userOpHash);\n        // verificationGasLimit is dual-purposed, as gas limit for postOp. make sure it is high enough\n        require(userOp.verificationGasLimit > COST_OF_POST, 'DepositPaymaster: gas too low for postOp');\n\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        require(paymasterAndData.length == 20, 'DepositPaymaster: paymasterAndData must be empty');\n        // Get the contract deployed address from the first 20 bytes of the paymasterAndData\n        address targetAccount =  address(bytes20(userOp.callData[16:]));\n        uint256 gasPriceUserOp = userOp.gasPrice();\n        require(unlockBlock[targetAccount] == 0, 'DepositPaymaster: deposit not locked');\n        require(balances[targetAccount] >= maxCost, 'DepositPaymaster: deposit too low');\n        return (abi.encode(targetAccount, gasPriceUserOp), 0);\n    }\n\n    /**\n     * perform the post-operation to charge the sender for the gas.\n     * in normal mode, use transferFrom to withdraw enough tokens from the sender's balance.\n     * in case the transferFrom fails, the _postOp reverts and the entryPoint will call it again,\n     * this time in *postOpReverted* mode.\n     * In this mode, we use the deposit to pay (which we validated to be large enough)\n     */\n    function _postOp(PostOpMode /* mode */, bytes calldata context, uint256 actualGasCost) internal override {\n        (address account, uint256 gasPricePostOp) = abi.decode(context, (address, uint256));\n        //use same conversion rate as used for validation.\n        uint256 ethCost = (actualGasCost + COST_OF_POST * gasPricePostOp);\n        balances[account] -= ethCost;\n        contractSpent[account] += ethCost;\n        balances[owner()] += ethCost;\n    }\n    \n}"
    },
    {
      "filename": "contracts/core/StakeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IStakeManager.sol\";\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable not-rely-on-time */\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by a paymaster.\n */\nabstract contract StakeManager is IStakeManager {\n    /// maps paymaster to their deposits and stakes\n    mapping(address => DepositInfo) public deposits;\n\n    /// @inheritdoc IStakeManager\n    function getDepositInfo(\n        address account\n    ) public view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    /**\n     * Internal method to return just the stake info.\n     * @param addr - The account to query.\n     */\n    function _getStakeInfo(\n        address addr\n    ) internal view returns (StakeInfo memory info) {\n        DepositInfo storage depositInfo = deposits[addr];\n        info.stake = depositInfo.stake;\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\n    }\n\n    /**\n     * Return the deposit (for gas payment) of the account.\n     * @param account - The account to query.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits[account].deposit;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    /**\n     * Increments an account's deposit.\n     * @param account - The account to increment.\n     * @param amount  - The amount to increment by.\n     */\n    function _incrementDeposit(address account, uint256 amount) internal {\n        DepositInfo storage info = deposits[account];\n        uint256 newAmount = info.deposit + amount;\n        require(newAmount <= type(uint112).max, \"deposit overflow\");\n        info.deposit = uint112(newAmount);\n    }\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) public virtual payable {\n        _incrementDeposit(account, msg.value);\n        DepositInfo storage info = deposits[account];\n        emit Deposited(account, info.deposit);\n    }\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param unstakeDelaySec The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[msg.sender];\n        require(unstakeDelaySec > 0, \"must specify unstake delay\");\n        require(\n            unstakeDelaySec >= info.unstakeDelaySec,\n            \"cannot decrease unstake time\"\n        );\n        uint256 stake = info.stake + msg.value;\n        require(stake > 0, \"no stake specified\");\n        require(stake <= type(uint112).max, \"stake overflow\");\n        deposits[msg.sender] = DepositInfo(\n            info.deposit,\n            true,\n            uint112(stake),\n            unstakeDelaySec,\n            0\n        );\n        emit StakeLocked(msg.sender, stake, unstakeDelaySec);\n    }\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        require(info.staked, \"already unstaking\");\n        uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        info.staked = false;\n        emit StakeUnlocked(msg.sender, withdrawTime);\n    }\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external {\n        DepositInfo storage info = deposits[msg.sender];\n        uint256 stake = info.stake;\n        require(stake > 0, \"No stake to withdraw\");\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\n        require(\n            info.withdrawTime <= block.timestamp,\n            \"Stake withdrawal is not due\"\n        );\n        info.unstakeDelaySec = 0;\n        info.withdrawTime = 0;\n        info.stake = 0;\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\n        (bool success, ) = withdrawAddress.call{value: stake}(\"\");\n        require(success, \"failed to withdraw stake\");\n    }\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n        info.deposit = uint112(info.deposit - withdrawAmount);\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n        (bool success, ) = withdrawAddress.call{value: withdrawAmount}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n}"
    },
    {
      "filename": "src/paymasters/SponsorPaymaster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '../interfaces/ISponsorPaymaster.sol';\n\nimport '@aa/core/BasePaymaster.sol';\nimport 'forge-std/console2.sol';\n\n/**\n * An ETH-based paymaster that accepts ETH deposits\n * The deposit is only a safeguard: the user pays with his ETH deposited in the entry point if any.\n * The deposit is locked for the current block: the user must issue unlockTokenDeposit() to be allowed to withdraw\n *  (but can't use the deposit for this or further operations)\n *\n * paymasterAndData holds the paymaster address followed by the token address to use.\n */\ncontract SponsorPaymaster is Initializable, BasePaymaster, UUPSUpgradeable, ReentrancyGuard, ISponsorPaymaster {\n\n    using UserOperationLib for UserOperation;\n    using SafeERC20 for IERC20;\n\n    //calculated cost of the postOp\n    uint256 constant public COST_OF_POST = 35000;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public contractSpent; // keeps track of total gas consumption by contract\n    mapping(address => uint256) public unlockBlock;\n\n    constructor(IEntryPoint __entryPoint) BasePaymaster(__entryPoint) {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev The _entryPoint member is immutable, to reduce gas consumption.  To upgrade EntryPoint,\n     * a new implementation of SimpleAccount must be deployed with the new EntryPoint address, then upgrading\n     * the implementation by calling `upgradeTo()`\n     */\n    function initialize(address _owner) external virtual initializer {\n        __UUPSUpgradeable_init();\n        _transferOwnership(_owner);\n        // unlocks owner\n        unlockTokenDeposit();\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by an owner.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the implementation is upgraded\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        require(msg.sender == owner(), 'SponsorPaymaster: not owner');\n        (newImplementation);\n    }\n\n    /**\n     * ETH value that a specific account can use to pay for gas.\n     * Note depositing the tokens is equivalent to transferring them to the \"account\" - only the account can later\n     *  use them - either as gas, or using withdrawTo()\n     *\n     * @param account the account to deposit for.\n     * msg.value the amount of token to deposit.\n     */\n    function addDepositFor(address account) payable external override {\n        require(msg.value > 0, 'requires a deposit');\n        //(sender must have approval for the paymaster)\n        balances[account] += msg.value;\n        if (msg.sender == account) {\n            lockTokenDeposit();\n        }\n        this.deposit{value: msg.value}();\n    }\n\n    /**\n     * Unlocks deposit, so that it can be withdrawn.\n     * can't be called in the same block as withdrawTo()\n     */\n    function unlockTokenDeposit() public override {\n        unlockBlock[msg.sender] = block.number;\n    }\n\n    /**\n     * Lock the ETH deposited for this account so they can be used to pay for gas.\n     * after calling unlockTokenDeposit(), the account can't use this paymaster until the deposit is locked.\n     */\n    function lockTokenDeposit() public override {\n        unlockBlock[msg.sender] = 0;\n    }\n\n    /**\n     * Withdraw ETH\n     * can only be called after unlock() is called in a previous block.\n     * @param target address to send to\n     * @param amount amount to withdraw\n     */\n    function withdrawTokensTo(address target, uint256 amount) external override nonReentrant() {\n        require(\n            unlockBlock[msg.sender] != 0 && block.number > unlockBlock[msg.sender],\n            'DepositPaymaster: must unlockTokenDeposit'\n        );\n        withdrawTo(payable(target), amount);\n        balances[msg.sender] -= amount;\n    }\n\n    /*******************************\n      Viewers *********************\n    *******************************/\n\n    /**\n     * @return amount - the amount of given token deposited to the Paymaster.\n     * @return _unlockBlock - the block height at which the deposit can be withdrawn.\n     */\n    function depositInfo(address account) public view returns (uint256 amount, uint256 _unlockBlock) {\n        amount = balances[account];\n        _unlockBlock = unlockBlock[account];\n    }\n\n    /**\n     * Validate the request:\n     * The sender should have enough deposit to pay the max possible cost.\n     * Note that the sender's balance is not checked. If it fails to pay from its balance,\n     * this deposit will be used to compensate the paymaster for the transaction.\n     */\n    function _validatePaymasterUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal view override returns (bytes memory context, uint256 validationData) {\n        (userOpHash);\n        // verificationGasLimit is dual-purposed, as gas limit for postOp. make sure it is high enough\n        require(userOp.verificationGasLimit > COST_OF_POST, 'DepositPaymaster: gas too low for postOp');\n\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        require(paymasterAndData.length == 20, 'DepositPaymaster: paymasterAndData must be empty');\n        // Get the contract deployed address from the first 20 bytes of the paymasterAndData\n        address targetAccount =  address(bytes20(userOp.callData[16:]));\n        uint256 gasPriceUserOp = userOp.gasPrice();\n        require(unlockBlock[targetAccount] == 0, 'DepositPaymaster: deposit not locked');\n        require(balances[targetAccount] >= maxCost, 'DepositPaymaster: deposit too low');\n        return (abi.encode(targetAccount, gasPriceUserOp), 0);\n    }\n\n    /**\n     * perform the post-operation to charge the sender for the gas.\n     * in normal mode, use transferFrom to withdraw enough tokens from the sender's balance.\n     * in case the transferFrom fails, the _postOp reverts and the entryPoint will call it again,\n     * this time in *postOpReverted* mode.\n     * In this mode, we use the deposit to pay (which we validated to be large enough)\n     */\n    function _postOp(PostOpMode /* mode */, bytes calldata context, uint256 actualGasCost) internal override {\n        (address account, uint256 gasPricePostOp) = abi.decode(context, (address, uint256));\n        //use same conversion rate as used for validation.\n        uint256 ethCost = (actualGasCost + COST_OF_POST * gasPricePostOp);\n        balances[account] -= ethCost;\n        contractSpent[account] += ethCost;\n        balances[owner()] += ethCost;\n    }\n    \n}"
    },
    {
      "filename": "src/paymasters/SponsorPaymaster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '../interfaces/ISponsorPaymaster.sol';\n\nimport '@aa/core/BasePaymaster.sol';\nimport 'forge-std/console2.sol';\n\n/**\n * An ETH-based paymaster that accepts ETH deposits\n * The deposit is only a safeguard: the user pays with his ETH deposited in the entry point if any.\n * The deposit is locked for the current block: the user must issue unlockTokenDeposit() to be allowed to withdraw\n *  (but can't use the deposit for this or further operations)\n *\n * paymasterAndData holds the paymaster address followed by the token address to use.\n */\ncontract SponsorPaymaster is Initializable, BasePaymaster, UUPSUpgradeable, ReentrancyGuard, ISponsorPaymaster {\n\n    using UserOperationLib for UserOperation;\n    using SafeERC20 for IERC20;\n\n    //calculated cost of the postOp\n    uint256 constant public COST_OF_POST = 35000;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public contractSpent; // keeps track of total gas consumption by contract\n    mapping(address => uint256) public unlockBlock;\n\n    constructor(IEntryPoint __entryPoint) BasePaymaster(__entryPoint) {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev The _entryPoint member is immutable, to reduce gas consumption.  To upgrade EntryPoint,\n     * a new implementation of SimpleAccount must be deployed with the new EntryPoint address, then upgrading\n     * the implementation by calling `upgradeTo()`\n     */\n    function initialize(address _owner) external virtual initializer {\n        __UUPSUpgradeable_init();\n        _transferOwnership(_owner);\n        // unlocks owner\n        unlockTokenDeposit();\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by an owner.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the implementation is upgraded\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        require(msg.sender == owner(), 'SponsorPaymaster: not owner');\n        (newImplementation);\n    }\n\n    /**\n     * ETH value that a specific account can use to pay for gas.\n     * Note depositing the tokens is equivalent to transferring them to the \"account\" - only the account can later\n     *  use them - either as gas, or using withdrawTo()\n     *\n     * @param account the account to deposit for.\n     * msg.value the amount of token to deposit.\n     */\n    function addDepositFor(address account) payable external override {\n        require(msg.value > 0, 'requires a deposit');\n        //(sender must have approval for the paymaster)\n        balances[account] += msg.value;\n        if (msg.sender == account) {\n            lockTokenDeposit();\n        }\n        this.deposit{value: msg.value}();\n    }\n\n    /**\n     * Unlocks deposit, so that it can be withdrawn.\n     * can't be called in the same block as withdrawTo()\n     */\n    function unlockTokenDeposit() public override {\n        unlockBlock[msg.sender] = block.number;\n    }\n\n    /**\n     * Lock the ETH deposited for this account so they can be used to pay for gas.\n     * after calling unlockTokenDeposit(), the account can't use this paymaster until the deposit is locked.\n     */\n    function lockTokenDeposit() public override {\n        unlockBlock[msg.sender] = 0;\n    }\n\n    /**\n     * Withdraw ETH\n     * can only be called after unlock() is called in a previous block.\n     * @param target address to send to\n     * @param amount amount to withdraw\n     */\n    function withdrawTokensTo(address target, uint256 amount) external override nonReentrant() {\n        require(\n            unlockBlock[msg.sender] != 0 && block.number > unlockBlock[msg.sender],\n            'DepositPaymaster: must unlockTokenDeposit'\n        );\n        withdrawTo(payable(target), amount);\n        balances[msg.sender] -= amount;\n    }\n\n    /*******************************\n      Viewers *********************\n    *******************************/\n\n    /**\n     * @return amount - the amount of given token deposited to the Paymaster.\n     * @return _unlockBlock - the block height at which the deposit can be withdrawn.\n     */\n    function depositInfo(address account) public view returns (uint256 amount, uint256 _unlockBlock) {\n        amount = balances[account];\n        _unlockBlock = unlockBlock[account];\n    }\n\n    /**\n     * Validate the request:\n     * The sender should have enough deposit to pay the max possible cost.\n     * Note that the sender's balance is not checked. If it fails to pay from its balance,\n     * this deposit will be used to compensate the paymaster for the transaction.\n     */\n    function _validatePaymasterUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal view override returns (bytes memory context, uint256 validationData) {\n        (userOpHash);\n        // verificationGasLimit is dual-purposed, as gas limit for postOp. make sure it is high enough\n        require(userOp.verificationGasLimit > COST_OF_POST, 'DepositPaymaster: gas too low for postOp');\n\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        require(paymasterAndData.length == 20, 'DepositPaymaster: paymasterAndData must be empty');\n        // Get the contract deployed address from the first 20 bytes of the paymasterAndData\n        address targetAccount =  address(bytes20(userOp.callData[16:]));\n        uint256 gasPriceUserOp = userOp.gasPrice();\n        require(unlockBlock[targetAccount] == 0, 'DepositPaymaster: deposit not locked');\n        require(balances[targetAccount] >= maxCost, 'DepositPaymaster: deposit too low');\n        return (abi.encode(targetAccount, gasPriceUserOp), 0);\n    }\n\n    /**\n     * perform the post-operation to charge the sender for the gas.\n     * in normal mode, use transferFrom to withdraw enough tokens from the sender's balance.\n     * in case the transferFrom fails, the _postOp reverts and the entryPoint will call it again,\n     * this time in *postOpReverted* mode.\n     * In this mode, we use the deposit to pay (which we validated to be large enough)\n     */\n    function _postOp(PostOpMode /* mode */, bytes calldata context, uint256 actualGasCost) internal override {\n        (address account, uint256 gasPricePostOp) = abi.decode(context, (address, uint256));\n        //use same conversion rate as used for validation.\n        uint256 ethCost = (actualGasCost + COST_OF_POST * gasPricePostOp);\n        balances[account] -= ethCost;\n        contractSpent[account] += ethCost;\n        balances[owner()] += ethCost;\n    }\n    \n}"
    }
  ]
}