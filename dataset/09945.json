{
  "Title": "[M-07] Itâ€™s possible to follow deleted profiles",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/libraries/InteractionLogic.sol#L49\n\n\n# Vulnerability details\n\nWhen someone tries to follow a profile, it checks if the handle exists, and if it doesn't, it reverts because the profile is deleted.\nThe problem is that there might be a new profile with the same handle as the deleted one, allowing following deleted profiles.\n\n\n## Proof of Concept\nAlice creates a profile with the handle \"alice.\" The profile id is 1.\nshe deleted the profile.\nshe opens a new profile with the handle \"alice\". The new profile id is 2.\nbob tries to follow the deleted profile (id is 1).\nthe check\n```\nif (_profileIdByHandleHash[keccak256(bytes(handle))] == 0)\n\trevert Errors.TokenDoesNotExist();\n```\ndoesn't revert because there exists a profile with the handle \"alice\".\nTherefore bob followed a deleted profile when he meant to follow the new profile.\n\n\n## Recommended Mitigation Steps\n\nchange to:\n```\nif (_profileIdByHandleHash[keccak256(bytes(handle))] != profileIds[i])\n\trevert Errors.TokenDoesNotExist();\n```\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-aave-lens-contest",
  "Code": [
    {
      "filename": "contracts/libraries/InteractionLogic.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {Helpers} from './Helpers.sol';\nimport {DataTypes} from './DataTypes.sol';\nimport {Errors} from './Errors.sol';\nimport {Events} from './Events.sol';\nimport {Constants} from './Constants.sol';\nimport {IFollowNFT} from '../interfaces/IFollowNFT.sol';\nimport {ICollectNFT} from '../interfaces/ICollectNFT.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ICollectModule} from '../interfaces/ICollectModule.sol';\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\n\n/**\n * @title InteractionLogic\n * @author Lens Protocol\n *\n * @notice This is the library that contains the logic for follows & collects. \n \n * @dev The functions are external, so they are called from the hub via `delegateCall` under the hood.\n */\nlibrary InteractionLogic {\n    using Strings for uint256;\n\n    /**\n     * @notice Follows the given profiles, executing the necessary logic and module calls before minting the follow\n     * NFT(s) to the follower.\n     *\n     * @param follower The address executing the follow.\n     * @param profileIds The array of profile token IDs to follow.\n     * @param followModuleDatas The array of follow module data parameters to pass to each profile's follow module.\n     * @param followNFTImpl The address of the follow NFT implementation, which has to be passed because it's an immutable in the hub.\n     * @param _profileById A pointer to the storage mapping of profile structs by profile ID.\n     */\n    function follow(\n        address follower,\n        uint256[] calldata profileIds,\n        bytes[] calldata followModuleDatas,\n        address followNFTImpl,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById,\n        mapping(bytes32 => uint256) storage _profileIdByHandleHash\n    ) external {\n        if (profileIds.length != followModuleDatas.length) revert Errors.ArrayMismatch();\n        for (uint256 i = 0; i < profileIds.length; ++i) {\n            string memory handle = _profileById[profileIds[i]].handle;\n            if (_profileIdByHandleHash[keccak256(bytes(handle))] == 0)\n                revert Errors.TokenDoesNotExist();\n\n            address followModule = _profileById[profileIds[i]].followModule;\n\n            address followNFT = _profileById[profileIds[i]].followNFT;\n\n            if (followNFT == address(0)) {\n                followNFT = Clones.clone(followNFTImpl);\n                _profileById[profileIds[i]].followNFT = followNFT;\n\n                bytes4 firstBytes = bytes4(bytes(handle));\n\n                string memory followNFTName = string(\n                    abi.encodePacked(handle, Constants.FOLLOW_NFT_NAME_SUFFIX)\n                );\n                string memory followNFTSymbol = string(\n                    abi.encodePacked(firstBytes, Constants.FOLLOW_NFT_SYMBOL_SUFFIX)\n                );\n\n                IFollowNFT(followNFT).initialize(profileIds[i], followNFTName, followNFTSymbol);\n                emit Events.FollowNFTDeployed(profileIds[i], followNFT, block.timestamp);\n            }\n\n            IFollowNFT(followNFT).mint(follower);\n\n            if (followModule != address(0)) {\n                IFollowModule(followModule).processFollow(\n                    follower,\n                    profileIds[i],\n                    followModuleDatas[i]\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Collects the given publication, executing the necessary logic and module call before minting the\n     * collect NFT to the collector.\n     *\n     * @param collector The address executing the collect.\n     * @param profileId The token ID of the publication being collected's parent profile.\n     * @param pubId The publication ID of the publication being collected.\n     * @param collectModuleData The data to pass to the publication's collect module.\n     * @param collectNFTImpl The address of the collect NFT implementation, which has to be passed because it's an immutable in the hub.\n     * @param _pubByIdByProfile A pointer to the storage mapping of publications by pubId by profile ID.\n     * @param _profileById A pointer to the storage mapping of profile structs by profile ID.\n     */\n    function collect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata collectModuleData,\n        address collectNFTImpl,\n        mapping(uint256 => mapping(uint256 => DataTypes.PublicationStruct))\n            storage _pubByIdByProfile,\n        mapping(uint256 => DataTypes.ProfileStruct) storage _profileById\n    ) external {\n        (uint256 rootProfileId, uint256 rootPubId, address rootCollectModule) = Helpers\n            .getPointedIfMirror(profileId, pubId, _pubByIdByProfile);\n\n        address collectNFT = _pubByIdByProfile[rootProfileId][rootPubId].collectNFT;\n\n        if (collectNFT == address(0)) {\n            collectNFT = Clones.clone(collectNFTImpl);\n            _pubByIdByProfile[rootProfileId][rootPubId].collectNFT = collectNFT;\n\n            string memory handle = _profileById[rootProfileId].handle;\n            bytes4 firstBytes = bytes4(bytes(handle));\n\n            string memory collectNFTName = string(\n                abi.encodePacked(handle, Constants.COLLECT_NFT_NAME_INFIX, rootPubId.toString())\n            );\n            string memory collectNFTSymbol = string(\n                abi.encodePacked(\n                    firstBytes,\n                    Constants.COLLECT_NFT_SYMBOL_INFIX,\n                    rootPubId.toString()\n                )\n            );\n\n            ICollectNFT(collectNFT).initialize(\n                rootProfileId,\n                rootPubId,\n                collectNFTName,\n                collectNFTSymbol\n            );\n            emit Events.CollectNFTDeployed(rootProfileId, rootPubId, collectNFT, block.timestamp);\n        }\n\n        ICollectNFT(collectNFT).mint(collector);\n\n        ICollectModule(rootCollectModule).processCollect(\n            profileId,\n            collector,\n            rootProfileId,\n            rootPubId,\n            collectModuleData\n        );\n        emit Events.Collected(\n            collector,\n            profileId,\n            pubId,\n            rootProfileId,\n            rootPubId,\n            block.timestamp\n        );\n    }\n}"
    }
  ]
}