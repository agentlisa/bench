{
  "Title": "[G-04] Optimal State Variable Order",
  "Content": "- Severity: Gas Optimization\n- Confidence: High\n- Total Gas Saved: 5000\n\n### Description\nDetects optimal variable order in contract storage layouts to decrease the number of storage slots used. Each storage slot used can cost at least 5,000 gas for each write operation, and potentially up to 20,000 gas if you're turning a zero value into a non-zero value. Hence, optimizing storage usage can result in significant gas savings. The real-world savings could vary depending on your contract's specific logic and the state of the Ethereum network.\n\n<details>\n\n<summary>\nThere are 1 instances of this issue:\n\n</summary>\n\n###\n- Optimization opportunity in storage variable layout of contract File: solidity/contracts/utils/UFragments.sol\n```\n \nLine: 20          contract UFragments is Ownable, IERC20Metadata \n```\n\n- original variable order (count: 17 slots)\n    - address monetaryPolicy\n    - uint256 DECIMALS\n    - uint256 MAX_UINT256\n    - uint256 INITIAL_FRAGMENTS_SUPPLY\n    - uint256 _totalGons\n    - uint256 MAX_SUPPLY\n    - uint256 _totalSupply\n    - uint256 _gonsPerFragment\n    - mapping(address => uint256) _gonBalances\n    - string name\n    - string symbol\n    - uint8 decimals\n    - mapping(address => mapping(address => uint256)) _allowedFragments\n    - string EIP712_REVISION\n    - bytes32 EIP712_DOMAIN\n    - bytes32 PERMIT_TYPEHASH\n    - mapping(address => uint256) _nonces\n\n\n - optimized variable order (count: 16 slots)\n    - address monetaryPolicy\n    - uint8 decimals\n    - uint256 DECIMALS\n    - uint256 MAX_UINT256\n    - uint256 INITIAL_FRAGMENTS_SUPPLY\n    - uint256 _totalGons\n    - uint256 MAX_SUPPLY\n    - uint256 _totalSupply\n    - uint256 _gonsPerFragment\n    - mapping(address => uint256) _gonBalances\n    - string name\n    - string symbol\n    - mapping(address => mapping(address => uint256)) _allowedFragments\n    - string EIP712_REVISION\n    - bytes32 EIP712_DOMAIN\n    - bytes32 PERMIT_TYPEHASH\n    - mapping(address => uint256) _nonces\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L20-L341](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L20-L341)\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/utils/UFragments.sol",
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity ^0.8.9;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\n/**\n * @title uFragments ERC20 token\n * @notice USDA uses the uFragments concept from the Ideal Money project to play interest\n *      Implementation is shamelessly borrowed from Ampleforth project\n *      uFragments is a normal ERC20 token, but its supply can be adjusted by splitting and\n *      combining tokens proportionally across all wallets.\n *\n *\n *      uFragment balances are internally represented with a hidden denomination, 'gons'.\n *      We support splitting the currency in expansion and combining the currency on contraction by\n *      changing the exchange rate between the hidden 'gons' and the public 'fragments'.\n */\ncontract UFragments is Ownable, IERC20Metadata {\n  // PLEASE READ BEFORE CHANGING ANY ACCOUNTING OR MATH\n  // Anytime there is division, there is a risk of numerical instability from rounding errors. In\n  // order to minimize this risk, we adhere to the following guidelines:\n  // 1) The conversion rate adopted is the number of gons that equals 1 fragment.\n  //    The inverse rate must not be used--_totalGons is always the numerator and _totalSupply is\n  //    always the denominator. (i.e. If you want to convert gons to fragments instead of\n  //    multiplying by the inverse rate, you should divide by the normal rate)\n  // 2) Gon balances converted into Fragments are always rounded down (truncated).\n  //\n  // We make the following guarantees:\n  // - If address 'A' transfers x Fragments to address 'B'. A's resulting external balance will\n  //   be decreased by precisely x Fragments, and B's external balance will be precisely\n  //   increased by x Fragments.\n  //\n  // We do not guarantee that the sum of all balances equals the result of calling totalSupply().\n  // This is because, for any conversion function 'f()' that has non-zero rounding error,\n  // f(x0) + f(x1) + ... + f(xn) is not always equal to f(x0 + x1 + ... xn).\n\n  event LogRebase(uint256 indexed epoch, uint256 totalSupply);\n  event LogMonetaryPolicyUpdated(address monetaryPolicy);\n\n  /// @notice Thrown when the signature is invalid\n  error UFragments_InvalidSignature();\n\n  /// @notice Thrown when the recipient is invalid\n  error UFragments_InvalidRecipient();\n\n  // Used for authentication\n  address public monetaryPolicy;\n\n  modifier onlyMonetaryPolicy() {\n    require(msg.sender == monetaryPolicy);\n    _;\n  }\n\n  modifier validRecipient(address _to) {\n    if (_to == address(0) || _to == address(this)) revert UFragments_InvalidRecipient();\n    _;\n  }\n\n  uint256 private constant DECIMALS = 18;\n  uint256 private constant MAX_UINT256 = 2 ** 256 - 1;\n  uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 1 * 10 ** DECIMALS;\n\n  // _totalGons is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\n  // Use the highest value that fits in a uint256 for max granularity.\n  uint256 public _totalGons; // = INITIAL_FRAGMENTS_SUPPLY * 10**48;\n\n  // MAX_SUPPLY = maximum integer < (sqrt(4*_totalGons + 1) - 1) / 2\n  uint256 public MAX_SUPPLY; // = type(uint128).max; // (2^128) - 1\n\n  uint256 public _totalSupply;\n  uint256 public _gonsPerFragment;\n  mapping(address => uint256) public _gonBalances;\n\n  string public name;\n  string public symbol;\n  uint8 public constant decimals = uint8(DECIMALS);\n\n  // This is denominated in Fragments, because the gons-fragments conversion might change before\n  // it's fully paid.\n  mapping(address => mapping(address => uint256)) private _allowedFragments;\n\n  // EIP-2612: permit â€“ 712-signed approvals\n  // https://eips.ethereum.org/EIPS/eip-2612\n  string public constant EIP712_REVISION = '1';\n  bytes32 public constant EIP712_DOMAIN =\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  // EIP-2612: keeps track of number of permits per address\n  mapping(address => uint256) private _nonces;\n\n  constructor(string memory _name, string memory _symbol) {\n    name = _name;\n    symbol = _symbol;\n\n    //set og initial values\n    _totalGons = INITIAL_FRAGMENTS_SUPPLY * 10 ** 48;\n    MAX_SUPPLY = 2 ** 128 - 1;\n    _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n    _gonBalances[address(0x0)] = _totalGons; //send starting supply to a burner address so _totalSupply is never 0\n    _gonsPerFragment = _totalGons / _totalSupply;\n    emit Transfer(address(this), address(0x0), _totalSupply);\n  }\n\n  /**\n   * @param _monetaryPolicy The address of the monetary policy contract to use for authentication.\n   */\n  function setMonetaryPolicy(address _monetaryPolicy) external onlyOwner {\n    monetaryPolicy = _monetaryPolicy;\n    emit LogMonetaryPolicyUpdated(_monetaryPolicy);\n  }\n\n  /**\n   * @notice returns the total supply\n   * @return __totalSupply The total number of fragments.\n   */\n  function totalSupply() external view override returns (uint256 __totalSupply) {\n    return _totalSupply;\n  }\n\n  /**\n   * @param _who The address to query.\n   * @return _balance The balance of the specified address.\n   */\n  function balanceOf(address _who) external view override returns (uint256 _balance) {\n    return _gonBalances[_who] / _gonsPerFragment;\n  }\n\n  /**\n   * @param _who The address to query.\n   * @return _balance The gon balance of the specified address.\n   */\n  function scaledBalanceOf(address _who) external view returns (uint256 _balance) {\n    return _gonBalances[_who];\n  }\n\n  /**\n   *  @notice Returns the scaled total supply\n   * @return __totalGons the total number of gons.\n   */\n  function scaledTotalSupply() external view returns (uint256 __totalGons) {\n    return _totalGons;\n  }\n\n  /**\n   * @notice Returns the nonces of a given address\n   * @param _who The address to query.\n   * @return _addressNonces The number of successful permits by the specified address.\n   */\n  function nonces(address _who) public view returns (uint256 _addressNonces) {\n    return _nonces[_who];\n  }\n\n  /**\n   * @notice Returns the EIP712 domain separator\n   * @return _domainSeparator The computed DOMAIN_SEPARATOR to be used off-chain services\n   *         which implement EIP-712.\n   *         https://eips.ethereum.org/EIPS/eip-2612\n   */\n  function DOMAIN_SEPARATOR() public view returns (bytes32 _domainSeparator) {\n    uint256 _chainId;\n    assembly {\n      _chainId := chainid()\n    }\n    return keccak256(\n      abi.encode(EIP712_DOMAIN, keccak256(bytes(name)), keccak256(bytes(EIP712_REVISION)), _chainId, address(this))\n    );\n  }\n\n  /**\n   * @notice Transfer tokens to a specified address.\n   * @param _to The address to transfer to.\n   * @param _value The amount to be transferred.\n   * @return _success True on success, false otherwise.\n   */\n  function transfer(address _to, uint256 _value) external override validRecipient(_to) returns (bool _success) {\n    uint256 _gonValue = _value * _gonsPerFragment;\n\n    _gonBalances[msg.sender] = _gonBalances[msg.sender] - _gonValue;\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer all of the sender's wallet balance to a specified address.\n   * @param _to The address to transfer to.\n   * @return _success True on success, false otherwise.\n   */\n  function transferAll(address _to) external validRecipient(_to) returns (bool _success) {\n    uint256 _gonValue = _gonBalances[msg.sender];\n    uint256 _value = _gonValue / _gonsPerFragment;\n\n    delete _gonBalances[msg.sender];\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Function to check the amount of tokens that an owner has allowed to a spender.\n   * @param _owner The address which owns the funds.\n   * @param _spender The address which will spend the funds.\n   * @return _remaining The number of tokens still available for the _spender.\n   */\n  function allowance(address _owner, address _spender) external view override returns (uint256 _remaining) {\n    return _allowedFragments[_owner][_spender];\n  }\n\n  /**\n   * @notice Transfer tokens from one address to another.\n   * @param _from The address you want to send tokens from.\n   * @param _to The address you want to transfer to.\n   * @param _value The amount of tokens to be transferred.\n   * @return _success True on success, false otherwise.\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external override validRecipient(_to) returns (bool _success) {\n    _allowedFragments[_from][msg.sender] = _allowedFragments[_from][msg.sender] - _value;\n\n    uint256 _gonValue = _value * _gonsPerFragment;\n    _gonBalances[_from] = _gonBalances[_from] - _gonValue;\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer all balance tokens from one address to another.\n   * @param _from The address you want to send tokens from.\n   * @param _to The address you want to transfer to.\n   * @return _success True on success, false otherwise.\n   */\n  function transferAllFrom(address _from, address _to) external validRecipient(_to) returns (bool _success) {\n    uint256 _gonValue = _gonBalances[_from];\n    uint256 _value = _gonValue / _gonsPerFragment;\n\n    _allowedFragments[_from][msg.sender] = _allowedFragments[_from][msg.sender] - _value;\n\n    delete _gonBalances[_from];\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Approve the passed address to spend the specified amount of tokens on behalf of\n   * msg.sender. This method is included for ERC20 compatibility.\n   * increaseAllowance and decreaseAllowance should be used instead.\n   * Changing an allowance with this method brings the risk that someone may transfer both\n   * the old and the new allowance - if they are both greater than zero - if a transfer\n   * transaction is mined before the later approve() call is mined.\n   *\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   * @return _success True on success, false otherwise.\n   */\n  function approve(address _spender, uint256 _value) external override returns (bool _success) {\n    _allowedFragments[msg.sender][_spender] = _value;\n\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @notice Increase the amount of tokens that an owner has allowed to a spender.\n   * This method should be used instead of approve() to avoid the double approval vulnerability\n   * described above.\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   * @return _success True on success, false otherwise.\n   */\n  function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool _success) {\n    _allowedFragments[msg.sender][_spender] = _allowedFragments[msg.sender][_spender] + _addedValue;\n\n    emit Approval(msg.sender, _spender, _allowedFragments[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @notice Decrease the amount of tokens that an owner has allowed to a spender.\n   *\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   * @return _success True on success, false otherwise.\n   */\n  function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool _success) {\n    uint256 _oldValue = _allowedFragments[msg.sender][_spender];\n    _allowedFragments[msg.sender][_spender] = (_subtractedValue >= _oldValue) ? 0 : _oldValue - _subtractedValue;\n\n    emit Approval(msg.sender, _spender, _allowedFragments[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @notice Allows for approvals to be made via secp256k1 signatures.\n   * @param _owner The owner of the funds\n   * @param _spender The _spender\n   * @param _value The amount\n   * @param _deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param _v Signature param\n   * @param _s Signature param\n   * @param _r Signature param\n   */\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _value,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public {\n    require(block.timestamp <= _deadline);\n\n    uint256 _ownerNonce = _nonces[_owner];\n    bytes32 _permitDataDigest = keccak256(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _ownerNonce, _deadline));\n    bytes32 _digest = keccak256(abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR(), _permitDataDigest));\n\n    if (uint256(_s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      revert UFragments_InvalidSignature();\n    }\n    require(_owner == ecrecover(_digest, _v, _r, _s));\n    if (_owner == address(0x0)) revert UFragments_InvalidSignature();\n\n    _nonces[_owner] = _ownerNonce + 1;\n\n    _allowedFragments[_owner][_spender] = _value;\n    emit Approval(_owner, _spender, _value);\n  }\n}"
    }
  ]
}