{
  "Title": "[M-23] Claiming outstanding utility tokens from `vMaia` vault DoS on `pbHermes<>bHermes` conversion rate `>` 1",
  "Content": "\nOnce a user deposits `Maia` ERC-20 tokens into the `vMaia` ERC-4626 vault, they are eligible to claim 3 kinds of utility tokens: `bHermes Weight` and `Governance` and `Maia Governance` (`pbHermes`, partner governance), via the [ERC4626PartnerManager.claimOutstanding()](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L89-L97) method ( `ERC4626PartnerManager` is the base of the `vMaia` contract). The conversion rate between the utility tokens and [vMaia tokens minted on deposit](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L235-L246) can be increased (and **only** increased) by the contract owner via the [ERC4626PartnerManager.increaseConversionRate(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L215-L229) method.\n\nHowever, the [checkWeight, checkGovernance & checkPartnerGovernance](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/vMaia.sol#L66-L88) modifiers in the `vMaia` contract do not account for this conversion rate and therefore implicity only allow a conversion rate of 1.\n\nAs a consequence, as soon as the conversion rate is increased to `>` 1, a call to [ERC4626PartnerManager.claimOutstanding()](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L89-L97) will inevitably revert due to subsequent calls to the above modifiers. Since the conversion rate can [only be increased](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L217) and the `vMaia` vault contract is not upgradeable, the `claimOutstanding()` method is subject to **permanent DoS**.\n\nOf course, the user can still claim a reduced amount of utility tokens (according to a conversion rate of 1) via the [PartnerUtilityManager.claimMultipleAmounts(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/PartnerUtilityManager.sol#L115-L124) method (`PartnerUtilityManager` is the base of the `ERC4626PartnerManager` contract), but this still implies a loss of assets for the user since not all utility tokens they are eligible for can be claimed. Furthermore, this workaround doesn't help when the user is a contract which implemented a call to the `claimOutstanding()` method.\n\n### Proof of Concept\n\nThe following PoC demonstrates the above DoS when trying to claim the utility tokens with increased conversion rate. Just apply the *diff* below and run the test cases with `forge test -vv --match-test testDepositMaia`:\n\n```diff\ndiff --git a/test/maia/vMaiaTest.t.sol b/test/maia/vMaiaTest.t.sol\nindex 6efabc5..499abb6 100644\n--- a/test/maia/vMaiaTest.t.sol\n+++ b/test/maia/vMaiaTest.t.sol\n@@ -7,9 +7,11 @@ import {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\n import {vMaia, PartnerManagerFactory, ERC20} from \"@maia/vMaia.sol\";\n import {IBaseVault} from \"@maia/interfaces/IBaseVault.sol\";\n+import {IERC4626PartnerManager} from \"@maia/interfaces/IERC4626PartnerManager.sol\";\n import {MockVault} from \"./mock/MockVault.t.sol\";\n\n import {bHermes} from \"@hermes/bHermes.sol\";\n+import {IUtilityManager} from \"@hermes/interfaces/IUtilityManager.sol\";\n\n import {DateTimeLib} from \"solady/utils/DateTimeLib.sol\";\n\n@@ -47,7 +49,7 @@ contract vMaiaTest is DSTestPlus {\n             \"vMAIA\",\n             address(bhermes),\n             address(vault),\n-            address(0)\n+            address(this) // set owner to allow call to 'increaseConversionRate'\n         );\n     }\n\n@@ -86,6 +88,33 @@ contract vMaiaTest is DSTestPlus {\n         assertEq(vmaia.balanceOf(address(this)), amount);\n     }\n\n+    function testDepositMaiaClaimDoS() public {\n+        testDepositMaia();\n+\n+        // increase 'pbHermes<>bHermes' conversion rate\n+        vmaia.increaseConversionRate(bHermesRate * 2);\n+\n+        // claim utility tokens DoS\n+        hevm.expectRevert(IUtilityManager.InsufficientShares.selector);\n+        vmaia.claimOutstanding();\n+\n+        // cannot undo conversion rate -> claimOutstanding() method is broken forever\n+        hevm.expectRevert(IERC4626PartnerManager.InvalidRate.selector);\n+        vmaia.increaseConversionRate(bHermesRate);\n+    }\n+\n+    function testDepositMaiaClaimSuccess() public {\n+        testDepositMaia();\n+\n+        vmaia.claimOutstanding();\n+\n+        // got utility tokens as expected\n+        assertGt(vmaia.bHermesToken().gaugeWeight().balanceOf(address(this)), 0);\n+        assertGt(vmaia.bHermesToken().governance().balanceOf(address(this)), 0);\n+        assertGt(vmaia.partnerGovernance().balanceOf(address(this)), 0);\n+    }\n+\n+\n     function testDepositMaiaAmountFail() public {\n         assertEq(vmaia.bHermesRate(), bHermesRate);\n\n```\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\nSimply remove the incorrect [checkWeight, checkGovernance & checkPartnerGovernance](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/vMaia.sol#L66-L88) modifiers from the `vMaia` contract, since the [correct modifiers](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L293-L323) (which account for the conversion rate), are already implemented in the `ERC4626PartnerManager` contract.\n\n```diff\ndiff --git a/src/maia/vMaia.sol b/src/maia/vMaia.sol\nindex 3aa70cf..5ee6f66 100644\n--- a/src/maia/vMaia.sol\n+++ b/src/maia/vMaia.sol\n@@ -59,34 +59,6 @@ contract vMaia is ERC4626PartnerManager {\n         currentMonth = DateTimeLib.getMonth(block.timestamp);\n     }\n\n-    /*///////////////////////////////////////////////////////////////\n-                            MODIFIERS\n-    //////////////////////////////////////////////////////////////*/\n-\n-    /// @dev Checks available weight allows for the call.\n-    modifier checkWeight(uint256 amount) virtual override {\n-        if (balanceOf[msg.sender] < amount + userClaimedWeight[msg.sender]) {\n-            revert InsufficientShares();\n-        }\n-        _;\n-    }\n-\n-    /// @dev Checks available governance allows for the call.\n-    modifier checkGovernance(uint256 amount) virtual override {\n-        if (balanceOf[msg.sender] < amount + userClaimedGovernance[msg.sender]) {\n-            revert InsufficientShares();\n-        }\n-        _;\n-    }\n-\n-    /// @dev Checks available partner governance allows for the call.\n-    modifier checkPartnerGovernance(uint256 amount) virtual override {\n-        if (balanceOf[msg.sender] < amount + userClaimedPartnerGovernance[msg.sender]) {\n-            revert InsufficientShares();\n-        }\n-        _;\n-    }\n-\n     /// @dev Boost can't be claimed; does not fail. It is all used by the partner vault.\n     function claimBoost(uint256 amount) public override {}\n\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/470#issuecomment-1632861068)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/470#issuecomment-1709166459):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/470).\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/maia/tokens/ERC4626PartnerManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {bHermes} from \"@hermes/bHermes.sol\";\nimport {bHermesVotes as ERC20MultiVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {PartnerManagerFactory} from \"../factories/PartnerManagerFactory.sol\";\nimport {IBaseVault} from \"../interfaces/IBaseVault.sol\";\nimport {PartnerUtilityManager} from \"../PartnerUtilityManager.sol\";\n\nimport {IERC4626PartnerManager} from \"../interfaces/IERC4626PartnerManager.sol\";\n\n/// @title Yield bearing, boosting, voting, and gauge enabled Partner Token\nabstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC4626, IERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         PARTNER MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    PartnerManagerFactory public immutable override factory;\n\n    /// @inheritdoc IERC4626PartnerManager\n    bHermes public immutable override bHermesToken;\n\n    /// @inheritdoc IERC4626PartnerManager\n    uint256 public override bHermesRate;\n\n    /**\n     * @notice Initializes the ERC4626PartnerManager token.\n     * @param _factory The partner manager factory.\n     * @param _bHermesRate The rate at which bHermes underlying's can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get partner tokens.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of this contract.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    )\n        PartnerUtilityManager(\n            address(bHermes(_bhermes).gaugeWeight()),\n            address(bHermes(_bhermes).gaugeBoost()),\n            address(bHermes(_bhermes).governance()),\n            address(new ERC20MultiVotes(_owner)),\n            partnerVault\n        )\n        ERC4626(\n            _partnerAsset,\n            string.concat(_name, \" - Burned Hermes: Aggregated Gov + Yield + Boost\"),\n            string.concat(_symbol, \"-bHermes\")\n        )\n    {\n        _initializeOwner(_owner);\n        partnerVault = _partnerVault;\n        factory = _factory;\n        bHermesRate = _bHermesRate;\n        bHermesToken = bHermes(_bhermes);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            UTILITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function updateUnderlyingBalance() public virtual {\n        bHermesToken.claimOutstanding();\n    }\n\n    /// @inheritdoc IERC4626PartnerManager\n    function claimOutstanding() public virtual {\n        uint256 balance = balanceOf[msg.sender] * bHermesRate;\n        /// @dev Never overflows since balandeOf >= userClaimed.\n        claimWeight(balance - userClaimedWeight[msg.sender]);\n        claimBoost(balance - userClaimedBoost[msg.sender]);\n        claimGovernance(balance - userClaimedGovernance[msg.sender]);\n        claimPartnerGovernance(balance - userClaimedPartnerGovernance[msg.sender]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Compute the amount of tokens available in contract.\n    /// @dev 1:1 with underlying asset.\n    function totalAssets() public view override returns (uint256) {\n        return totalSupply;\n    }\n\n    /**\n     * @notice Computes and returns the amount of shares from a given amount of assets.\n     * @param assets amount of assets to convert to shares\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Computes and returns the amount of assets from a given amount of shares.\n     * @param shares amount of shares to convert to assets\n     */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Simulates the amount of shares that the assets deposited are worth.\n     * @param assets amount of assets to simulate the deposit.\n     */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Calculates the amount of shares that the assets deposited are worth.\n     */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be withdrawn from a given amount of shares.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be redeemed from a given amount of shares.\n     * @param shares amount of shares to convert to assets.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ER4626 DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxMint(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be withdrawn by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxWithdraw(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /// @notice Returns the maximum amount of assets that can be redeemed by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxRedeem(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function migratePartnerVault(address newPartnerVault) external onlyOwner {\n        if (factory.vaultIds(IBaseVault(newPartnerVault)) == 0) revert UnrecognizedVault();\n\n        address oldPartnerVault = partnerVault;\n        if (oldPartnerVault != address(0)) IBaseVault(oldPartnerVault).clearAll();\n        bHermesToken.claimOutstanding();\n\n        address(gaugeWeight).safeApprove(oldPartnerVault, 0);\n        address(gaugeBoost).safeApprove(oldPartnerVault, 0);\n        address(governance).safeApprove(oldPartnerVault, 0);\n        address(partnerGovernance).safeApprove(oldPartnerVault, 0);\n\n        address(gaugeWeight).safeApprove(newPartnerVault, type(uint256).max);\n        address(gaugeBoost).safeApprove(newPartnerVault, type(uint256).max);\n        address(governance).safeApprove(newPartnerVault, type(uint256).max);\n        address(partnerGovernance).safeApprove(newPartnerVault, type(uint256).max);\n\n        partnerVault = newPartnerVault;\n        if (newPartnerVault != address(0)) IBaseVault(newPartnerVault).applyAll();\n\n        emit MigratePartnerVault(address(this), newPartnerVault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function increaseConversionRate(uint256 newRate) external onlyOwner {\n        if (newRate < bHermesRate) revert InvalidRate();\n\n        if (newRate > (address(bHermesToken).balanceOf(address(this)) / totalSupply)) {\n            revert InsufficientBacking();\n        }\n\n        bHermesRate = newRate;\n\n        partnerGovernance.mint(\n            address(this), totalSupply * newRate - address(partnerGovernance).balanceOf(address(this))\n        );\n        bHermesToken.claimOutstanding();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints new partner bhermes tokens to a specific address.\n     * @param to address to mints tokens to.\n     * @param amount amount of tokens to mint.\n     */\n    function _mint(address to, uint256 amount) internal virtual override {\n        if (amount > maxMint(to)) revert ExceedsMaxDeposit();\n        bHermesToken.claimOutstanding();\n\n        ERC20MultiVotes(partnerGovernance).mint(address(this), amount * bHermesRate);\n        super._mint(to, amount);\n    }\n\n    /**\n     * @notice Burns (or unstakes) the vMaia token in exchange for the underlying\n     *         Partner tokens, performing changes around bHermes tokens.\n     * @param from account to burn the partner manager from\n     * @param amount amounts of vMaia to burn\n     */\n    function _burn(address from, uint256 amount) internal virtual override checkTransfer(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfer partner manager to a specific address.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(msg.sender, amount)\n        returns (bool)\n    {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer tokens from a given address.\n     * @param from address to transfer the tokens from.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available boost allows for call.\n    modifier checkBoost(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedBoost[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    modifier checkTransfer(address from, uint256 amount) virtual {\n        uint256 userBalance = balanceOf[from] * bHermesRate;\n\n        if (\n            userBalance - userClaimedWeight[from] < amount || userBalance - userClaimedBoost[from] < amount\n                || userBalance - userClaimedGovernance[from] < amount\n                || userBalance - userClaimedPartnerGovernance[from] < amount\n        ) revert InsufficientUnderlying();\n\n        _;\n    }\n}"
    },
    {
      "filename": "src/maia/vMaia.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesVotes as vMaiaVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {DateTimeLib} from \"./libraries/DateTimeLib.sol\";\nimport {ERC4626PartnerManager, PartnerManagerFactory} from \"./tokens/ERC4626PartnerManager.sol\";\n\n/**\n * @title vMaia: Yield bearing, boosting, voting, and gauge enabled MAIA\n * @author Maia DAO (https://github.com/Maia-DAO)\n * @notice vMaia is an ERC-4626 compliant MAIA token which:\n *         distributes bHermes utility tokens (Weight, Governance) and Maia Governance\n *         in exchange for staking MAIA.\n *\n *         NOTE: Withdraw is only allowed once per month,\n *               during the 1st Tuesday (UTC+0) of the month.\n */\ncontract vMaia is ERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         vMAIA STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 private currentMonth;\n    uint256 private unstakePeriodEnd;\n\n    /**\n     * @notice Initializes the vMaia token.\n     * @param _factory The factory that created this contract.\n     * @param _bHermesRate The rate at which bHermes can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get vMaia.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of the token.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    ) ERC4626PartnerManager(_factory, _bHermesRate, _partnerAsset, _name, _symbol, _bhermes, _partnerVault, _owner) {\n        // Set the current month to the current month.\n        currentMonth = DateTimeLib.getMonth(block.timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for the call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for the call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for the call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Boost can't be claimed; does not fail. It is all used by the partner vault.\n    function claimBoost(uint256 amount) public override {}\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function that performs the necessary verifications before a user can withdraw from their vMaia position.\n     *  Checks if we're inside the unstaked period, if so then the user is able to withdraw.\n     * If we're not in the unstake period, then there will be checks to determine if this is the beginning of the month.\n     */\n    function beforeWithdraw(uint256, uint256) internal override {\n        /// @dev Check if unstake period has not ended yet, continue if it is the case.\n        if (unstakePeriodEnd >= block.timestamp) return;\n\n        uint256 _currentMonth = DateTimeLib.getMonth(block.timestamp);\n        if (_currentMonth == currentMonth) revert UnstakePeriodNotLive();\n\n        (bool isTuesday, uint256 _unstakePeriodStart) = DateTimeLib.isTuesday(block.timestamp);\n        if (!isTuesday) revert UnstakePeriodNotLive();\n\n        currentMonth = _currentMonth;\n        unstakePeriodEnd = _unstakePeriodStart + 1 days;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Error thrown when trying to withdraw and it is not the first Tuesday of the month.\n    error UnstakePeriodNotLive();\n}"
    },
    {
      "filename": "src/maia/tokens/ERC4626PartnerManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {bHermes} from \"@hermes/bHermes.sol\";\nimport {bHermesVotes as ERC20MultiVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {PartnerManagerFactory} from \"../factories/PartnerManagerFactory.sol\";\nimport {IBaseVault} from \"../interfaces/IBaseVault.sol\";\nimport {PartnerUtilityManager} from \"../PartnerUtilityManager.sol\";\n\nimport {IERC4626PartnerManager} from \"../interfaces/IERC4626PartnerManager.sol\";\n\n/// @title Yield bearing, boosting, voting, and gauge enabled Partner Token\nabstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC4626, IERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         PARTNER MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    PartnerManagerFactory public immutable override factory;\n\n    /// @inheritdoc IERC4626PartnerManager\n    bHermes public immutable override bHermesToken;\n\n    /// @inheritdoc IERC4626PartnerManager\n    uint256 public override bHermesRate;\n\n    /**\n     * @notice Initializes the ERC4626PartnerManager token.\n     * @param _factory The partner manager factory.\n     * @param _bHermesRate The rate at which bHermes underlying's can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get partner tokens.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of this contract.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    )\n        PartnerUtilityManager(\n            address(bHermes(_bhermes).gaugeWeight()),\n            address(bHermes(_bhermes).gaugeBoost()),\n            address(bHermes(_bhermes).governance()),\n            address(new ERC20MultiVotes(_owner)),\n            partnerVault\n        )\n        ERC4626(\n            _partnerAsset,\n            string.concat(_name, \" - Burned Hermes: Aggregated Gov + Yield + Boost\"),\n            string.concat(_symbol, \"-bHermes\")\n        )\n    {\n        _initializeOwner(_owner);\n        partnerVault = _partnerVault;\n        factory = _factory;\n        bHermesRate = _bHermesRate;\n        bHermesToken = bHermes(_bhermes);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            UTILITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function updateUnderlyingBalance() public virtual {\n        bHermesToken.claimOutstanding();\n    }\n\n    /// @inheritdoc IERC4626PartnerManager\n    function claimOutstanding() public virtual {\n        uint256 balance = balanceOf[msg.sender] * bHermesRate;\n        /// @dev Never overflows since balandeOf >= userClaimed.\n        claimWeight(balance - userClaimedWeight[msg.sender]);\n        claimBoost(balance - userClaimedBoost[msg.sender]);\n        claimGovernance(balance - userClaimedGovernance[msg.sender]);\n        claimPartnerGovernance(balance - userClaimedPartnerGovernance[msg.sender]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Compute the amount of tokens available in contract.\n    /// @dev 1:1 with underlying asset.\n    function totalAssets() public view override returns (uint256) {\n        return totalSupply;\n    }\n\n    /**\n     * @notice Computes and returns the amount of shares from a given amount of assets.\n     * @param assets amount of assets to convert to shares\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Computes and returns the amount of assets from a given amount of shares.\n     * @param shares amount of shares to convert to assets\n     */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Simulates the amount of shares that the assets deposited are worth.\n     * @param assets amount of assets to simulate the deposit.\n     */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Calculates the amount of shares that the assets deposited are worth.\n     */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be withdrawn from a given amount of shares.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be redeemed from a given amount of shares.\n     * @param shares amount of shares to convert to assets.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ER4626 DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxMint(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be withdrawn by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxWithdraw(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /// @notice Returns the maximum amount of assets that can be redeemed by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxRedeem(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function migratePartnerVault(address newPartnerVault) external onlyOwner {\n        if (factory.vaultIds(IBaseVault(newPartnerVault)) == 0) revert UnrecognizedVault();\n\n        address oldPartnerVault = partnerVault;\n        if (oldPartnerVault != address(0)) IBaseVault(oldPartnerVault).clearAll();\n        bHermesToken.claimOutstanding();\n\n        address(gaugeWeight).safeApprove(oldPartnerVault, 0);\n        address(gaugeBoost).safeApprove(oldPartnerVault, 0);\n        address(governance).safeApprove(oldPartnerVault, 0);\n        address(partnerGovernance).safeApprove(oldPartnerVault, 0);\n\n        address(gaugeWeight).safeApprove(newPartnerVault, type(uint256).max);\n        address(gaugeBoost).safeApprove(newPartnerVault, type(uint256).max);\n        address(governance).safeApprove(newPartnerVault, type(uint256).max);\n        address(partnerGovernance).safeApprove(newPartnerVault, type(uint256).max);\n\n        partnerVault = newPartnerVault;\n        if (newPartnerVault != address(0)) IBaseVault(newPartnerVault).applyAll();\n\n        emit MigratePartnerVault(address(this), newPartnerVault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function increaseConversionRate(uint256 newRate) external onlyOwner {\n        if (newRate < bHermesRate) revert InvalidRate();\n\n        if (newRate > (address(bHermesToken).balanceOf(address(this)) / totalSupply)) {\n            revert InsufficientBacking();\n        }\n\n        bHermesRate = newRate;\n\n        partnerGovernance.mint(\n            address(this), totalSupply * newRate - address(partnerGovernance).balanceOf(address(this))\n        );\n        bHermesToken.claimOutstanding();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints new partner bhermes tokens to a specific address.\n     * @param to address to mints tokens to.\n     * @param amount amount of tokens to mint.\n     */\n    function _mint(address to, uint256 amount) internal virtual override {\n        if (amount > maxMint(to)) revert ExceedsMaxDeposit();\n        bHermesToken.claimOutstanding();\n\n        ERC20MultiVotes(partnerGovernance).mint(address(this), amount * bHermesRate);\n        super._mint(to, amount);\n    }\n\n    /**\n     * @notice Burns (or unstakes) the vMaia token in exchange for the underlying\n     *         Partner tokens, performing changes around bHermes tokens.\n     * @param from account to burn the partner manager from\n     * @param amount amounts of vMaia to burn\n     */\n    function _burn(address from, uint256 amount) internal virtual override checkTransfer(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfer partner manager to a specific address.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(msg.sender, amount)\n        returns (bool)\n    {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer tokens from a given address.\n     * @param from address to transfer the tokens from.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available boost allows for call.\n    modifier checkBoost(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedBoost[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    modifier checkTransfer(address from, uint256 amount) virtual {\n        uint256 userBalance = balanceOf[from] * bHermesRate;\n\n        if (\n            userBalance - userClaimedWeight[from] < amount || userBalance - userClaimedBoost[from] < amount\n                || userBalance - userClaimedGovernance[from] < amount\n                || userBalance - userClaimedPartnerGovernance[from] < amount\n        ) revert InsufficientUnderlying();\n\n        _;\n    }\n}"
    },
    {
      "filename": "src/maia/PartnerUtilityManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20Votes, UtilityManager, IUtilityManager} from \"@hermes/UtilityManager.sol\";\n\nimport {IBaseVault} from \"./interfaces/IBaseVault.sol\";\nimport {IPartnerUtilityManager} from \"./interfaces/IPartnerUtilityManager.sol\";\n\n/// @title Partner Utility Tokens Manager Contract\nabstract contract PartnerUtilityManager is UtilityManager, IPartnerUtilityManager {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                         UTILITY MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IPartnerUtilityManager\n    address public partnerVault;\n\n    /// @inheritdoc IPartnerUtilityManager\n    ERC20Votes public immutable partnerGovernance;\n\n    /// @inheritdoc IPartnerUtilityManager\n    mapping(address => uint256) public userClaimedPartnerGovernance;\n\n    /**\n     * @notice Constructs the Utility Manager Contract.\n     * @param _gaugeWeight The address of the weight gauge.\n     * @param _gaugeBoost The address of the boost gauge.\n     * @param _governance The address of the governance token.\n     * @param _partnerGovernance The address of the partner governance token.\n     * @param _partnerVault The address of the partner vault.\n     */\n    constructor(\n        address _gaugeWeight,"
    }
  ]
}