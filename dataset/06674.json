{
  "Title": "[G-01] Optimize `merkleizeSha256` function for gas-efficiency",
  "Content": "\nAlthough the current implementation of the [`merkleizeSha256`](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/libraries/Merkle.sol#L129-L153) function in the [`Merkle`](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/libraries/Merkle.sol) contract is correct, it can be more gas-efficient by making use of the following optimizations:\n\n### 1. In-place Computation\n\nThe `merkleizeSha256` function can be optimized by using in-place computation to store intermediate hashes at each level of the Merkle tree. This approach eliminates the need to create new arrays, reducing memory usage and gas costs.\n\nNote: this optimization requires the `leaves` array not to be used again after it is modified. Based on the current implementation, this optimization is safe because the `leaves` array is not used again after it is modified.\n\n### 2. Assembly\n\nThe use of assembly code to load the left and right siblings into memory is more gas-efficient than using the `abi.encodePacked` function.\n\n### 3. Unchecked Arithmetic\n\nThe use of unchecked arithmetic for `uint i` is more gas-efficient as it skips checks for overflow or underflow. This optimization is safe because `i` is always less than `numNodesInLayer`, meaning that overflow is not possible.\n\n### Proof of Concept\n\nThe function `merkleizeSha256Optimized` provided below is an optimized version of the `merkleizeSha256` function.\n\n[src/contracts/libraries/MerkleOptimized.sol](https://github.com/code-423n4/2023-04-eigenlayer/blob/main/src/contracts/libraries/Merkle.sol)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity =0.8.12;\n\nlibrary MerkleOptimized {\n    /**\n     * @notice Returns the Merkle root of a tree created from a set of leaves using SHA256 as its hash function.\n     * @param leaves The leaves of the Merkle tree. This parameter is modified during the execution of the function and must not be used again afterwards.\n     * @return The Merkle root of the tree.\n     *\n     * @notice Requires the leaves.length is a power of 2.\n     * @dev This is adapted from https://github.com/ethereum-optimism/optimism/blob/e6f1f61c569dbabffa2cfe6129e8e23a8646ffca/packages/contracts/contracts/libraries/utils/Lib_MerkleTree.sol#L13C1-L96\n     */\n    function merkleizeSha256Optimized(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        // Reserve memory space for our hashes.\n        bytes memory buf = new bytes(64);\n\n        // We'll need to keep track of left and right siblings.\n        bytes32 leftSibling;\n        bytes32 rightSibling;\n\n        // Number of non-empty nodes at the current depth.\n        uint256 rowSize = leaves.length;\n\n        // Common sub-expressions\n        uint256 halfRowSize; // rowSize / 2\n\n        while (rowSize > 1) {\n            halfRowSize = rowSize / 2;\n\n            for (uint256 i = 0; i < halfRowSize; ) {\n                leftSibling = leaves[(2 * i)];\n                rightSibling = leaves[(2 * i) + 1];\n                assembly {\n                    mstore(add(buf, 32), leftSibling)\n                    mstore(add(buf, 64), rightSibling)\n                }\n\n                leaves[i] = sha256(buf);\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            rowSize = halfRowSize;\n        }\n\n        return leaves[0];\n    }\n}\n```\n| Function Name            | min  | avg    | median | max     | # calls |\n| ------------------------ | ---- | ------ | ------ | ------- | ------- |\n| merkleizeSha256          | 2353 | 274987 | 62975  | 1396167 | 10      |\n| merkleizeSha256Optimized | 2136 | 238896 | 56158  | 1197190 | 10      |\n\n| Improvement |        |\n| ----------- | ------ |\n| Minimum     | 9.22%  |\n| Average     | 13.12% |\n| Median      | 10.82% |\n| Maximum     | 14.25% |\n\nThe data shows a significant increase in gas efficiency with the use of `merkleizeSha256Optimized` compared to `merkleizeSha256`. It's worth emphasizing, that these results are influenced by the input data and execution environment, so the actual improvement may differ in other contexts. Nonetheless, the results provide valuable insight into the potential gas cost savings that can be achieved by leveraging the optimized version of the function.\n\nThe test codes are the following:\n\nsrc/test/unit/Merkle.t.sol\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {Merkle} from \"../../contracts/libraries/Merkle.sol\";\nimport {MerkleOptimized} from \"../../contracts/libraries/MerkleOptimized.sol\";\n\ncontract MerkleMock {\n    function merkleizeSha256(\n        bytes32[] calldata leaves\n    ) external pure returns (bytes32) {\n        return Merkle.merkleizeSha256(leaves);\n    }\n\n    function merkleizeSha256Optimized(\n        bytes32[] calldata leaves\n    ) external pure returns (bytes32) {\n        return MerkleOptimized.merkleizeSha256Optimized(leaves);\n    }\n}\n\ncontract MerkleTest is Test {\n    MerkleMock public c;\n\n    function setUp() external {\n        c = new MerkleMock();\n    }\n\n    function gen(uint256 length) internal pure returns (bytes32[] memory) {\n        bytes32[] memory leaves = new bytes32[](length);\n        for (uint i = 0; i < length; i++) {\n            leaves[i] = bytes32(i);\n        }\n        return leaves;\n    }\n\n    function testMerkleizeSha256Equivalence() external {\n        for (uint i = 2; i <= 1024; i *= 2) {\n            assertEq(\n                c.merkleizeSha256(gen(i)),\n                c.merkleizeSha256Optimized(gen(i)),\n                \"ok\"\n            );\n        }\n    }\n}\n```\n\n### Recommendation\n\nConsider optimizing `merkleizeSha256` by using in-place computation, assembly, and unchecked arithmetic.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-04-eigenlayer",
  "Code": [
    {
      "filename": "src/contracts/libraries/Merkle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity =0.8.12;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary Merkle {\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function verifyInclusionKeccak(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal pure returns (bool) {\n        return processInclusionProofKeccak(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, computedHash)\n                    mstore(0x20, mload(add(proof, i)))\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, computedHash)\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function verifyInclusionSha256(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bool) {\n        return processInclusionProofSha256(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function processInclusionProofSha256(bytes memory proof, bytes32 leaf, uint256 index) internal view returns (bytes32) {\n        bytes32[1] memory computedHash = [leaf];\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, mload(computedHash))\n                    mstore(0x20, mload(add(proof, i)))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, mload(computedHash))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash[0];\n    }\n\n    /**\n     @notice this function returns the merkle root of a tree created from a set of leaves using sha256 as its hash function\n     @param leaves the leaves of the merkle tree\n\n     @notice requires the leaves.length is a power of 2\n     */ \n    function merkleizeSha256(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2*i], leaves[2*i+1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2*i], layer[2*i+1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n}"
    },
    {
      "filename": "packages/contracts/contracts/libraries/utils/Lib_MerkleTree.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_MerkleTree\n * @author River Keefer\n */\nlibrary Lib_MerkleTree {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number\n     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.\n     * If you do not know the original length of elements for the tree you are verifying, then\n     * this may allow empty leaves past _elements.length to pass a verification check down the line.\n     * Note that the _elements argument is modified, therefore it must not be used again afterwards\n     * @param _elements Array of hashes from which to generate a merkle root.\n     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).\n     */\n    function getMerkleRoot(bytes32[] memory _elements) internal pure returns (bytes32) {\n        require(_elements.length > 0, \"Lib_MerkleTree: Must provide at least one leaf hash.\");\n\n        if (_elements.length == 1) {\n            return _elements[0];\n        }\n\n        uint256[16] memory defaults = [\n            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,\n            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,\n            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,\n            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,\n            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,\n            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,\n            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,\n            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,\n            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,\n            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,\n            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,\n            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,\n            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,\n            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,\n            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,\n            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10\n        ];\n\n        // Reserve memory space for our hashes.\n        bytes memory buf = new bytes(64);\n\n        // We'll need to keep track of left and right siblings.\n        bytes32 leftSibling;\n        bytes32 rightSibling;\n\n        // Number of non-empty nodes at the current depth.\n        uint256 rowSize = _elements.length;\n\n        // Current depth, counting from 0 at the leaves\n        uint256 depth = 0;\n\n        // Common sub-expressions\n        uint256 halfRowSize; // rowSize / 2\n        bool rowSizeIsOdd; // rowSize % 2 == 1\n\n        while (rowSize > 1) {\n            halfRowSize = rowSize / 2;\n            rowSizeIsOdd = rowSize % 2 == 1;\n\n            for (uint256 i = 0; i < halfRowSize; i++) {\n                leftSibling = _elements[(2 * i)];\n                rightSibling = _elements[(2 * i) + 1];\n                assembly {\n                    mstore(add(buf, 32), leftSibling)\n                    mstore(add(buf, 64), rightSibling)\n                }\n\n                _elements[i] = keccak256(buf);\n            }\n\n            if (rowSizeIsOdd) {\n                leftSibling = _elements[rowSize - 1];\n                rightSibling = bytes32(defaults[depth]);\n                assembly {\n                    mstore(add(buf, 32), leftSibling)\n                    mstore(add(buf, 64), rightSibling)\n                }\n\n                _elements[halfRowSize] = keccak256(buf);\n            }\n\n            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);\n            depth++;\n        }\n\n        return _elements[0];\n    }\n\n    /**\n     * Verifies a merkle branch for the given leaf hash.  Assumes the original length\n     * of leaves generated is a known, correct input, and does not return true for indices\n     * extending past that index (even if _siblings would be otherwise valid.)\n     * @param _root The Merkle root to verify against.\n     * @param _leaf The leaf hash to verify inclusion of.\n     * @param _index The index in the tree of this leaf.\n     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0\n     * (bottom of the tree).\n     * @param _totalLeaves The total number of leaves originally passed into.\n     * @return Whether or not the merkle branch and leaf passes verification.\n     */\n    function verify(\n        bytes32 _root,\n        bytes32 _leaf,\n        uint256 _index,\n        bytes32[] memory _siblings,\n        uint256 _totalLeaves\n    ) internal pure returns (bool) {\n        require(_totalLeaves > 0, \"Lib_MerkleTree: Total leaves must be greater than zero.\");\n\n        require(_index < _totalLeaves, \"Lib_MerkleTree: Index out of bounds.\");\n\n        require(\n            _siblings.length == _ceilLog2(_totalLeaves),\n            \"Lib_MerkleTree: Total siblings does not correctly correspond to total leaves.\"\n        );\n\n        bytes32 computedRoot = _leaf;\n\n        for (uint256 i = 0; i < _siblings.length; i++) {\n            if ((_index & 1) == 1) {\n                computedRoot = keccak256(abi.encodePacked(_siblings[i], computedRoot));\n            } else {\n                computedRoot = keccak256(abi.encodePacked(computedRoot, _siblings[i]));\n            }\n\n            _index >>= 1;\n        }\n\n        return _root == computedRoot;\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Calculates the integer ceiling of the log base 2 of an input.\n     * @param _in Unsigned input to calculate the log.\n     * @return ceil(log_base_2(_in))\n     */\n    function _ceilLog2(uint256 _in) private pure returns (uint256) {\n        require(_in > 0, \"Lib_MerkleTree: Cannot compute ceil(log_2) of 0.\");\n\n        if (_in == 1) {\n            return 0;\n        }\n\n        // Find the highest set bit (will be floor(log_2)).\n        // Borrowed with <3 from https://github.com/ethereum/solidity-examples\n        uint256 val = _in;\n        uint256 highest = 0;\n        for (uint256 i = 128; i >= 1; i >>= 1) {\n            if (val & (((uint256(1) << i) - 1) << i) != 0) {\n                highest += i;\n                val >>= i;\n            }\n        }\n\n        // Increment by one if this is not a perfect logarithm.\n        if ((uint256(1) << highest) != _in) {\n            highest += 1;\n        }\n\n        return highest;\n    }\n}"
    }
  ]
}