{
  "Title": "[G-01] Use `require` instead of `assert`",
  "Content": "\nThe `assert()` and `require()` functions are a part of the error handling aspect in Solidity. Solidity makes use of state-reverting error handling exceptions. This means all changes made to the contract on that call or any sub-calls are undone if an error is thrown. It also flags an error.\n\nThey are quite similar as both check for conditions and if they are not met, would throw an error.\n\nThe big difference between the two is that the `assert()` function when false, **uses up all the remaining gas and reverts all the changes made.**\n\nMeanwhile, a `require()` function when false, also reverts back all the changes made to the contract but **does refund all the remaining gas fees we offered to pay**. This is the most common Solidity function used by developers for debugging and error handling.\n\n**Affected source code:**\n\n*   [DiamondCut.sol:16](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L16)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-zksync-v2-contest",
  "Code": [
    {
      "filename": "ethereum/contracts/zksync/facets/DiamondCut.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../libraries/Diamond.sol\";\nimport \"../Config.sol\";\nimport \"./Base.sol\";\n\n/// @title DiamondCut contract responsible for the management of upgrades.\n/// @author Matter Labs\ncontract DiamondCutFacet is Base, IDiamondCut {\n    constructor() {\n        // Caution check for config value.\n        // Should be greater than 0, otherwise zero approvals will be enough to make an instant upgrade!\n        assert(SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE > 0);\n    }\n\n    /// @dev Starts the upgrade process. Only the current governor can propose an upgrade.\n    /// @param _facetCuts The set of proposed changes to the facets (adding/replacement/removing)\n    /// @param _initAddress Address of the fallback contract that will be called after the upgrade execution\n    function proposeDiamondCut(Diamond.FacetCut[] calldata _facetCuts, address _initAddress) external onlyGovernor {\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp == 0, \"a3\"); // proposal already exists\n\n        // NOTE: governor commits only to the `facetCuts` and `initAddress`, but not to the calldata on `initAddress` call.\n        // That means the governor can call `initAddress` with ANY calldata while executing the upgrade.\n        s.diamondCutStorage.proposedDiamondCutHash = keccak256(abi.encode(_facetCuts, _initAddress));\n        s.diamondCutStorage.proposedDiamondCutTimestamp = block.timestamp;\n        s.diamondCutStorage.currentProposalId += 1;\n\n        emit DiamondCutProposal(_facetCuts, _initAddress);\n    }\n\n    /// @notice Removes the upgrade proposal. Only current governor can remove proposal.\n    function cancelDiamondCutProposal() external onlyGovernor {\n        emit DiamondCutProposalCancelation(\n            s.diamondCutStorage.currentProposalId,\n            s.diamondCutStorage.proposedDiamondCutHash\n        );\n        require(_resetProposal(), \"g1\"); // failed cancel diamond cut\n    }\n\n    /// @notice Executes a proposed governor upgrade. Only the current governor can execute the upgrade.\n    /// NOTE: Governor can execute diamond cut ONLY with proposed `facetCuts` and `initAddress`.\n    /// `initCalldata` can be arbitrarily.\n    function executeDiamondCutProposal(Diamond.DiamondCutData calldata _diamondCut) external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        bool approvedBySecurityCouncil = s.diamondCutStorage.securityCouncilEmergencyApprovals >=\n            SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE;\n\n        bool upgradeNoticePeriodPassed = block.timestamp >=\n            s.diamondCutStorage.proposedDiamondCutTimestamp + UPGRADE_NOTICE_PERIOD;\n\n        require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire\n        require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");\n        // should not be frozen or should have enough security council approvals\n\n        require(\n            s.diamondCutStorage.proposedDiamondCutHash ==\n                keccak256(abi.encode(_diamondCut.facetCuts, _diamondCut.initAddress)),\n            \"a4\"\n        ); // proposal should be created\n\n        require(_resetProposal(), \"a5\"); // failed reset proposal\n\n        if (diamondStorage.isFrozen) {\n            diamondStorage.isFrozen = false;\n            emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n        }\n\n        Diamond.diamondCut(_diamondCut);\n\n        emit DiamondCutProposalExecution(_diamondCut);\n    }\n\n    /// @notice Instantly pause the functionality of all freezable facets & their selectors\n    function emergencyFreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        _resetProposal();\n\n        diamondStorage.isFrozen = true;\n        // Limited-time freezing feature will be added in the future upgrades, so keeping this variable for simplification\n        s.diamondCutStorage.lastDiamondFreezeTimestamp = block.timestamp;\n\n        emit EmergencyFreeze();\n    }\n\n    /// @notice Unpause the functionality of all freezable facets & their selectors\n    function unfreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n\n        _resetProposal();\n\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n    }\n\n    /// @notice Gives another approval for the instant upgrade (diamond cut) by the security council member\n    /// @param _diamondCutHash The hash of the diamond cut that security council members want to approve. Needed to prevent unintentional approvals, including reorg attacks\n    function approveEmergencyDiamondCutAsSecurityCouncilMember(bytes32 _diamondCutHash) external {\n        require(s.diamondCutStorage.securityCouncilMembers[msg.sender], \"a9\"); // not a security council member\n        uint256 currentProposalId = s.diamondCutStorage.currentProposalId;\n        require(s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] < currentProposalId, \"ao\"); // already approved this proposal\n        s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] = currentProposalId;\n\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp != 0, \"f0\"); // there is no proposed diamond cut\n        require(s.diamondCutStorage.proposedDiamondCutHash == _diamondCutHash, \"f1\"); // proposed diamond cut do not match to the approved\n        uint256 securityCouncilEmergencyApprovals = s.diamondCutStorage.securityCouncilEmergencyApprovals;\n        s.diamondCutStorage.securityCouncilEmergencyApprovals = securityCouncilEmergencyApprovals + 1;\n\n        emit EmergencyDiamondCutApproved(\n            msg.sender,\n            currentProposalId,\n            securityCouncilEmergencyApprovals,\n            _diamondCutHash\n        );\n    }\n\n    /// @dev Set up the proposed diamond cut state to the default values\n    /// @return Whether the proposal is reset or it was already empty\n    function _resetProposal() private returns (bool) {\n        if (s.diamondCutStorage.proposedDiamondCutTimestamp == 0) {\n            return false;\n        }\n\n        delete s.diamondCutStorage.proposedDiamondCutHash;\n        delete s.diamondCutStorage.proposedDiamondCutTimestamp;\n        delete s.diamondCutStorage.securityCouncilEmergencyApprovals;\n\n        return true;\n    }\n}"
    }
  ]
}