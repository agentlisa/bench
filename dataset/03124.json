{
  "Title": "Implement a remove-whitelist functionality",
  "Content": "Currently, to prevent tokens from being transferred while within the vesting schedule, a [`WHITELIST_ROLE` is defined and checked in `FortaCommon._beforeTokenTransfer`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/token/FortaCommon.sol#L36-L37). The user or contract can only transfer tokens if “whitelisted”. Eventually, the whitelist requirement is planned to be removed via a contract upgrade.\n\n\nSince contract upgrades are notoriously risky due to storage slot assignment issues, and since the removal of the whitelist functionality is planned for future development, consider implementing an access controlled “remove whitelist” functionality in the existing contract which disables the whitelist. This will also give users greater confidence about the future state of the system and allow development which may depend on the future system design to proceed more smoothly.\n\n\n***Update:** Fixed on [commit `dd558f1017eee429e8d66d9d151de3adf1d02a6d` in pull request 58](https://github.com/forta-protocol/forta-token/pull/58/commits/dd558f1017eee429e8d66d9d151de3adf1d02a6d).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/FortaCommon.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"../tools/ENSReverseRegistration.sol\";\n\nabstract contract FortaCommon is AccessControlUpgradeable, ERC20VotesUpgradeable, UUPSUpgradeable {\n    bytes32 public constant ADMIN_ROLE       = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant WHITELISTER_ROLE = keccak256(\"WHITELISTER_ROLE\");\n    bytes32 public constant WHITELIST_ROLE   = keccak256(\"WHITELIST_ROLE\");\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function __FortaCommon_init(address admin) internal initializer {\n        require(admin != address(0), \"FortaCommon: admin cannot be address 0\");\n        __AccessControl_init();\n        __ERC20_init(\"Forta\", \"FORT\");\n        __ERC20Permit_init(\"Forta\");\n        __UUPSUpgradeable_init();\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(WHITELISTER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(WHITELIST_ROLE, WHITELISTER_ROLE);\n        _grantRole(ADMIN_ROLE, admin);\n    }\n\n    // Allow whitelister to assign other whitelisters\n    function grantWhitelister(address to) public onlyRole(WHITELISTER_ROLE) {\n        _grantRole(WHITELISTER_ROLE, to);\n    }\n\n    // Only allow transfer to whitelisted accounts\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        require(from == address(0) || hasRole(WHITELIST_ROLE, from), \"Forta: sender is not whitelisted\");\n        require(to   == address(0) || hasRole(WHITELIST_ROLE, to), \"Forta: receiver is not whitelisted\");\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    // Access control for the upgrade process\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyRole(ADMIN_ROLE) {\n    }\n\n    // Allow the upgrader to set ENS reverse registration\n    function setName(address ensRegistry, string calldata ensName) external onlyRole(ADMIN_ROLE) {\n        ENSReverseRegistration.setName(ensRegistry, ensName);\n    }\n}"
    }
  ]
}