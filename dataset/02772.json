{
  "Title": "H-3: Adversary can brick AutoRoller by creating another AutoRoller on the same adapter",
  "Content": "# Issue H-3: Adversary can brick AutoRoller by creating another AutoRoller on the same adapter \n\nSource: https://github.com/sherlock-audit/2022-11-sense-judging/issues/20 \n\n## Found by \n0x52\n\n## Summary\n\nonSponsorWindowOpened attempts to make a new series at the desired maturity. Each adapter can only have one of each maturity. If the maturity requested already exists then onSponsorWindowOpened will revert, making it impossible to roll the AutoRoller. An adversary can take advantage of this to brick an AutoRoller by creating a second AutoRoller on the same adapter that will create a target maturity before the first AutoRoller. Since the maturity now exists, the first AutoRoller will always revert when trying to Roll.  \n\n## Vulnerability Detail\n\n    uint256 _maturity = utils.getFutureMaturity(targetDuration);\n\n    function getFutureMaturity(uint256 monthsForward) public view returns (uint256) {\n        (uint256 year, uint256 month, ) = DateTime.timestampToDate(DateTime.addMonths(block.timestamp, monthsForward));\n        return DateTime.timestampFromDateTime(year, month, 1 /* top of the month */, 0, 0, 0);\n    }\n\nInside AutoRoller#onSponsorWindowOpened the maturity is calculated using RollerUtils#getFutureMaturity. This returns the timestamp the requested months ahead, truncated down to the first of the month. It passes this calculated maturity as the maturity to sponsor a new series.\n\n    (ERC20 _pt, YTLike _yt) = periphery.sponsorSeries(address(adapter), _maturity, true);\n\nhttps://etherscan.io/address/0xFff11417a58781D3C72083CB45EF54d79Cd02437#code#F1#L90\n\n    function sponsorSeries(\n        address adapter,\n        uint256 maturity,\n        bool withPool\n    ) external returns (address pt, address yt) {\n        (, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n\n        // Transfer stakeSize from sponsor into this contract\n        ERC20(stake).safeTransferFrom(msg.sender, address(this), stakeSize);\n\n        // Approve divider to withdraw stake assets\n        ERC20(stake).approve(address(divider), stakeSize);\n\n        (pt, yt) = divider.initSeries(adapter, maturity, msg.sender);\n\n        // Space pool is always created for verified adapters whilst is optional for unverified ones.\n        // Automatically queueing series is only for verified adapters\n        if (verified[adapter]) {\n            poolManager.queueSeries(adapter, maturity, spaceFactory.create(adapter, maturity));\n        } else {\n            if (withPool) {\n                spaceFactory.create(adapter, maturity);\n            }\n        }\n        emit SeriesSponsored(adapter, maturity, msg.sender);\n    }\n\nperiphery#sponsorSeries is called with true indicating to create a space pool for the newly created series. \n\nhttps://etherscan.io/address/0x5f6e8e9C888760856e22057CBc81dD9e0494aA34#code#F1#L75\n\n    function create(address adapter, uint256 maturity) external returns (address pool) {\n        address pt = divider.pt(adapter, maturity);\n        _require(pt != address(0), Errors.INVALID_SERIES);\n        _require(pools[adapter][maturity] == address(0), Errors.POOL_ALREADY_EXISTS);\n\n        pool = address(new Space(\n            vault,\n            adapter,\n            maturity,\n            pt,\n            ts,\n            g1,\n            g2,\n            oracleEnabled\n        ));\n\n        pools[adapter][maturity] = pool;\n    }\n\nWe run into an issue inside SpaceFactory#create because it only allows a single pool per adapter/maturity. If a pool already exist then it will revert.\n\nAn adversary can abuse this revert to brick an existing AutoRoller. Assume AutoRoller A has a duration of 3 months. Its current maturity is December 1st 2022, when rolled it will attempt to create a series at March 1st 2023. An adversary could abuse this and create AutoRoller B with a maturity of 4 months. When they roll for the first time it will create a series with maturity at March 1st 2023. When AutoRoller A attempts to roll it will revert since a series already exists at March 1st 2023.\n\nThis conflict can happen accidentally if there is a monthly AutoRoller and a quarterly AutoRoller. It also hinders the viability of using an AutoRoller for an adapter that is popular because the series will likely have been created by the time the autoroller tries to roll into it.\n\n## Impact\n\nAutoRollers will frequently be bricked\n\n## Code Snippet\n\n[AutoRoller.sol#L174-L272](https://github.com/sherlock-audit/2022-11-sense/blob/main/contracts/src/AutoRoller.sol#L174-L272)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRequiring that the AutoRoller has to create the series seems overly restrictive and leads to a large number of issues. Attempting to join an a series that is already initialized could also lead to pool manipulation rates. It seems like a large refactoring is needed for the rolling section of the AutoRoller\n\n## Discussion\n\n**jparklev**\n\nThis is a great observation and a valid high severity finding. We have a fix in mind that we'll share once implemented – appreciate the submission\n\n**jparklev**\n\nFix: https://github.com/sense-finance/auto-roller/pull/20\n\n**aktech297**\n\nThe fix is done by considering the trusted caller.\nIf the caller is trusted, contract allows for auto roller creation.\nThis fix will be valid till `isTrusted[msg.sender] == true`  after first one is created.\nEven the trusted caller should not be allowed to create auto roller with maturity less than the existing auto roller.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/19",
  "Code": [
    {
      "filename": "contracts/src/AutoRoller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.13;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\n\nimport { DateTime } from \"./external/DateTime.sol\";\n\nimport { SafeCast } from \"./SafeCast.sol\";\n\nimport { BalancerVault } from \"./interfaces/BalancerVault.sol\";\nimport { Space } from \"./interfaces/Space.sol\";\n\ninterface SpaceFactoryLike {\n    function divider() external view returns (address);\n    function create(address, uint256) external returns (address);\n    function pools(address, uint256) external view returns (Space);\n}\n\ninterface DividerLike {\n    function series(address, uint256) external returns (address, uint48, address, uint96, address, uint256, uint256, uint256, uint256);\n    function issue(address, uint256, uint256) external returns (uint256);\n    function settleSeries(address, uint256) external;\n    function mscale(address, uint256) external view returns (uint256);\n    function redeem(address, uint256, uint256) external;\n    function combine(address, uint256, uint256) external;\n}\n\ninterface YTLike {\n    function approve(address, uint256) external;\n    function transfer(address, uint256) external;\n    function collect() external;\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface PeripheryLike {\n    function sponsorSeries(address, uint256, bool) external returns (ERC20, YTLike);\n    function swapYTsForTarget(address, uint256, uint256) external returns (uint256);\n    function create(address, uint256) external returns (address);\n    function spaceFactory() external view returns (SpaceFactoryLike);\n    function MIN_YT_SWAP_IN() external view returns (uint256);\n}\n\ninterface OwnedAdapterLike {\n    function target() external view returns (address);\n    function ifee() external view returns (uint256);\n    function openSponsorWindow() external;\n    function scale() external returns (uint256);\n    function scaleStored() external view returns (uint256);\n    function getStakeAndTarget() external view returns (address,address,uint256);\n    function setIsTrusted(address,bool) external;\n}\n\ncontract AutoRoller is ERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using SafeCast for *;\n\n    /* ========== ERRORS ========== */\n\n    error ActivePhaseOnly();\n    error UnrecognizedParam(bytes32 what);\n    error InsufficientLiquidity();\n    error RollWindowNotOpen();\n    error OnlyAdapter();\n    error InvalidSettler();\n\n    /* ========== CONSTANTS ========== */\n\n    uint32 internal constant MATURITY_NOT_SET = type(uint32).max;\n    int256 internal constant WITHDRAWAL_GUESS_OFFSET = 0.95e18; // Offset from the number of assets in this contract the first withdrawal guess will be made.\n\n    /* ========== IMMUTABLES ========== */\n\n    DividerLike      internal immutable divider;\n    BalancerVault    internal immutable balancerVault;\n    OwnedAdapterLike internal immutable adapter;\n\n    uint256 internal immutable ifee; // Cached issuance fee.\n    uint256 internal immutable minSwapAmount; // Min number of PTs that can be swapped out when exiting.\n    uint256 internal immutable firstDeposit; // Size of the first deposit that gets locked in the contract permanently.\n    uint256 internal immutable maxError; // A conservative buffer for \"rounding\" swap previews that accounts for compounded pow of imprecision.\n    address internal immutable rewardRecipient; // Recipient address for any unexpected tokens that end up in this contract.\n\n    /* ========== MUTABLE STORAGE ========== */\n\n    PeripheryLike    internal periphery;\n    SpaceFactoryLike internal spaceFactory;\n    address          internal owner; // Admin that can set params.\n    RollerUtils      internal utils; // Utility contract with convenience getter functions.\n\n    // Active Series\n    YTLike  internal yt;\n    ERC20   internal pt;\n    Space   internal space;\n    bytes32 internal poolId;\n    address internal lastRoller; // Last address to call roll.\n\n    // Separate slots to meet contract size limits.\n    uint256 internal initScale;\n    uint256 public  maturity = MATURITY_NOT_SET;\n    uint256 internal pti;\n\n    uint256 internal maxRate        = 53144e19; // Max implied rate stretched to Space pool's TS period. (531440% over 12 years ≈ 200% APY)\n    uint256 internal targetedRate   = 2.9e18; // Targeted implied rate stretched to Space pool's TS period. (2.9% over 12 years ≈ 0.12% APY)\n    uint256 internal targetDuration = 3; // Number of months or weeks in the future newly sponsored Series should mature.\n\n    uint256 public cooldown         = 10 days; // Length of mandatory cooldown period during which LPs can withdraw without slippage.\n    uint256 public lastSettle; // Timestamp from when settlement was last called.\n\n    constructor(\n        ERC20 _target,\n        DividerLike _divider,\n        address _periphery,\n        address _spaceFactory,\n        address _balancerVault,\n        OwnedAdapterLike _adapter,\n        RollerUtils _utils,\n        address _rewardRecipient\n    ) ERC4626(\n        _target,\n        string(abi.encodePacked(_target.name(), \" Sense Auto Roller\")),\n        string(abi.encodePacked(_target.symbol(), \"-sAR\"))\n    ) {\n        divider       = _divider;\n        periphery     = PeripheryLike(_periphery);\n        spaceFactory  = SpaceFactoryLike(_spaceFactory);\n        balancerVault = BalancerVault(_balancerVault);\n\n        // Allow the Divder to move this contract's Target for PT/YT issuance.\n        _target.safeApprove(address(_divider), type(uint256).max);\n\n        // Allow Balancer to move this contract's Target for Space pools joins.\n        _target.safeApprove(address(_balancerVault), type(uint256).max);\n\n        uint256 scalingFactor = 10**(18 - decimals);\n\n        minSwapAmount = (periphery.MIN_YT_SWAP_IN() - 1) / scalingFactor + 1; // Rounds up to cover low decimal tokens.\n        maxError      = (1e7 - 1) / scalingFactor + 1;\n        firstDeposit  = (0.01e18 - 1) / scalingFactor + 1;\n\n        adapter = _adapter;\n        ifee    = _adapter.ifee(); // Assumption: ifee will not change. Don't break this assumption and expect good things.\n        owner   = msg.sender;\n        utils   = _utils;\n        rewardRecipient = _rewardRecipient;\n    }\n\n    /* ========== SERIES MANAGEMENT ========== */\n\n    /// @notice Roll into the next Series if there isn't an active series and the cooldown period has elapsed.\n    function roll() external {\n        if (maturity != MATURITY_NOT_SET) revert RollWindowNotOpen();\n\n        if (lastSettle == 0) {\n            // If this is the first roll, lock some shares in by minting them for the zero address.\n            // This prevents the contract from reaching an empty state during future active periods.\n            deposit(firstDeposit, address(0));\n        } else if (lastSettle + cooldown > block.timestamp) {\n            revert RollWindowNotOpen();\n        }\n\n        lastRoller = msg.sender;\n        adapter.openSponsorWindow();\n    }\n\n    /// @notice Sponsor a new Series, issue PTs, and migrate liquidity into the new Space pool.\n    /// @dev We only expect this function to be called by this roller's adapter in the callback triggered within the adapter.openSponsorWindow call.\n    ///      Assumption: all of this Vault's LP shares will have been exited before this function is called.\n    /// @param stake the adapter's stake token address.\n    /// @param stakeSize the adapter's stake size.\n    function onSponsorWindowOpened(ERC20 stake, uint256 stakeSize) external {\n        if (msg.sender != address(adapter)) revert OnlyAdapter();\n\n        stake.safeTransferFrom(lastRoller, address(this), stakeSize);\n\n        // Allow the Periphery to move stake for sponsoring the Series.\n        stake.safeApprove(address(periphery), stakeSize);\n\n        uint256 _maturity = utils.getFutureMaturity(targetDuration);\n\n        // Assign Series data.\n        (ERC20 _pt, YTLike _yt) = periphery.sponsorSeries(address(adapter), _maturity, true);\n        (Space _space, bytes32 _poolId, uint256 _pti, uint256 _initScale) = utils.getSpaceData(periphery, OwnedAdapterLike(msg.sender), _maturity);\n\n        // Allow Balancer to move the new PTs for joins & swaps.\n        _pt.approve(address(balancerVault), type(uint256).max);\n\n        // Allow Periphery to move the new YTs for swaps.\n        _yt.approve(address(periphery), type(uint256).max);\n\n        ERC20 _asset = asset;\n\n        ERC20[] memory tokens = new ERC20[](2);\n        tokens[1 - _pti] = _asset;\n        tokens[_pti] = _pt;\n\n        uint256 targetBal = _asset.balanceOf(address(this));\n\n        // Get the reserve balances that would imply the given targetedRate in the Space pool,\n        // assuming that we we're going to deposit the amount of Target currently in this contract.\n        // In other words, this function simulating the reserve balances that would result from the actions:\n        // 1) Use the some Target to issue PTs/YTs\n        // 2) Deposit some amount of Target\n        // 3) Swap PTs into the pool to initialize the targeted rate\n        // 4) Deposit the rest of the PTs and Target in this contract (which remain in the exact ratio the pool expects)\n        // Since we're determining the resulting reserve balances of these operations, we can issue exactly the amount of PTs we'll need to keep the ratio in the pool.\n        (uint256 eqPTReserves, uint256 eqTargetReserves) = _space.getEQReserves(\n            targetedRate < 0.01e18 ? 0.01e18 : targetedRate, // Don't let the pool start below 0.01% stretched yield\n            _maturity,\n            0, // PT reserves, starting with 0\n            targetBal, // Target reserves, starting with the entire Target balance in this contract.\n            targetBal.mulWadDown(_initScale), // Total supply, starting with Target * initScale, since that's the BPT supply if once deposit all of the Target.\n            _space.g2() // Space fee, g2 because the swap we'll make to initialize these reserve balances is PT -> Target (see https://yield.is/YieldSpace.pdf section \"5 Fees\").\n        );\n\n        // Calculate & issue an amount of PTs, such that all PTs are used to add liquidity while preserving the PT:Target reserve ratio in the Space Pool.\n        uint256 targetForIssuance = _getTargetForIssuance(eqPTReserves, eqTargetReserves, targetBal, _initScale);\n        divider.issue(address(adapter), _maturity, targetForIssuance);\n\n        uint256[] memory balances = new uint256[](2);\n        balances[1 - _pti] = targetBal - targetForIssuance;\n\n        // Initialize the targeted rate in the Space pool with a join, a swap, and another join.\n        _joinPool(\n            _poolId,\n            BalancerVault.JoinPoolRequest({\n                assets: tokens,\n                maxAmountsIn: balances,\n                userData: abi.encode(balances, 0), // No min BPT out: first join.\n                fromInternalBalance: false\n            })\n        );\n        _swap(\n            BalancerVault.SingleSwap({\n                poolId: _poolId,\n                kind: BalancerVault.SwapKind.GIVEN_IN,\n                assetIn: address(_pt),\n                assetOut: address(tokens[1 - _pti]),\n                amount: eqPTReserves.mulDivDown(balances[1 - _pti], targetBal),\n                userData: hex\"\"\n            })\n        );\n\n        balances[_pti    ] = _pt.balanceOf(address(this));\n        balances[1 - _pti] = _asset.balanceOf(address(this));\n\n        _joinPool(\n            _poolId,\n            BalancerVault.JoinPoolRequest({\n                assets: tokens,\n                maxAmountsIn: balances,\n                userData: abi.encode(balances, 0), // No min BPT out: the pool was created in this tx and the join can't be sandwiched.\n                fromInternalBalance: false\n            })\n        );\n\n        // Cache Series data.\n        space  = _space;\n        poolId = _poolId;\n        pt     = _pt;\n        yt     = _yt;\n\n        // Combined single SSTORE.\n        initScale = _initScale;\n        maturity  = _maturity; // OK until Feb 07, 2106\n        pti       = _pti;\n\n        emit Rolled(_maturity, uint256(_initScale), address(_space), msg.sender);\n    }\n\n    /// @notice Settle the active Series, transfer stake and ifees to the settler, and enter a cooldown phase.\n    /// @dev Because the auto-roller is the series sponsor from the Divider's perspective, this.settle is the only entrypoint for athe lastRoller to settle during the series' sponsor window.\n    ///      More info on the series lifecylce: https://docs.sense.finance/docs/series-lifecycle-detail/#phase-3-settling.\n    function settle() public {\n        if(msg.sender != lastRoller) revert InvalidSettler();\n\n        uint256 assetBalPre = asset.balanceOf(address(this));\n        divider.settleSeries(address(adapter), maturity); // Settlement will fail if maturity hasn't been reached.\n        uint256 assetBalPost = asset.balanceOf(address(this));\n\n        asset.safeTransfer(msg.sender, assetBalPost - assetBalPre); // Send issuance fees to the sender.\n\n        (, address stake, uint256 stakeSize) = adapter.getStakeAndTarget();\n        if (stake != address(asset)) {\n            ERC20(stake).safeTransfer(msg.sender, stakeSize);\n        }\n\n        startCooldown();\n    }\n\n    /// @notice Enter a cooldown phase where users can redeem without slippage. Often this will be initiated by this.settle,\n    ///         but it can be called externally if the Series was settled externally.\n    function startCooldown() public {\n        require(divider.mscale(address(adapter), maturity) != 0);\n\n        ERC20[] memory tokens = new ERC20[](2);\n        tokens[1 - pti] = asset;\n        tokens[pti    ] = pt;\n\n        _exitPool(\n            poolId,\n            BalancerVault.ExitPoolRequest({\n                assets: tokens,\n                minAmountsOut: new uint256[](2),\n                userData: abi.encode(space.balanceOf(address(this))),\n                toInternalBalance: false\n            })\n        );\n\n        divider.redeem(address(adapter), maturity, pt.balanceOf(address(this))); // Burns the PTs.\n        yt.collect(); // Burns the YTs.\n\n        // Calculate the initial market fixed rate for the upcoming series, using the historical avg Target rate across the previous series.\n        targetedRate = utils.getNewTargetedRate(targetedRate, address(adapter), maturity, space);\n\n        maturity   = MATURITY_NOT_SET;\n        lastSettle = uint32(block.timestamp);\n        delete pt; delete yt; delete space; delete pti; delete poolId; delete initScale; // Re-set variables to defaults, collect gas refund.\n    }\n\n    /* ========== 4626 SPEC ========== */\n    // see: https://eips.ethereum.org/EIPS/eip-4626\n\n    /// @dev exit LP shares commensurate the given number of shares, and sell the excess PTs or YTs into Target if possible.\n    function beforeWithdraw(uint256, uint256 shares) internal override {\n        if (maturity != MATURITY_NOT_SET) {\n            (uint256 excessBal, bool isExcessPTs) = _exitAndCombine(shares);\n\n            if (excessBal < minSwapAmount) return;\n\n            if (isExcessPTs) {\n                (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n                uint256 maxPTSale = _maxPTSell(ptReserves, targetReserves, space.adjustedTotalSupply());\n\n                if (excessBal > maxPTSale) revert InsufficientLiquidity(); // Need to eject, wait for more liquidity, or wait until a cooldown phase.\n\n                _swap(\n                    BalancerVault.SingleSwap({\n                        poolId: poolId,\n                        kind: BalancerVault.SwapKind.GIVEN_IN,\n                        assetIn: address(pt),\n                        assetOut: address(asset),\n                        amount: excessBal,\n                        userData: hex\"\"\n                    })\n                );\n            } else {\n                periphery.swapYTsForTarget(address(adapter), maturity, excessBal); // Swapping YTs will fail if there isn't enough liquidity.\n            }\n        }\n    }\n\n    /// @dev Joins the Space pool, issuing PTs in order to match the current pool's ratio of Target:PT\n    function afterDeposit(uint256 assets, uint256 shares) internal override {\n        if (maturity != MATURITY_NOT_SET) {\n            uint256 _supply = totalSupply; // Saves extra SLOADs.\n            bytes32 _poolId = poolId;\n            uint256 _pti    = pti;\n\n            (ERC20[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(_poolId);\n\n            uint256 previewedLPBal = _supply - shares == 0 ?\n                shares : shares.mulDivUp(space.balanceOf(address(this)), _supply - shares); // _supply - shares b/c this is after minting new shares.\n\n            uint256 targetToJoin = previewedLPBal.mulDivUp(balances[1 - _pti], space.adjustedTotalSupply());\n\n            balances[1 - _pti] = targetToJoin;\n\n            if (assets - targetToJoin > 0) { // Assumption: this is false if Space has only Target liquidity.\n                balances[_pti] = divider.issue(address(adapter), maturity, assets - targetToJoin);\n            }\n\n            _joinPool(\n                _poolId,\n                BalancerVault.JoinPoolRequest({\n                    assets: tokens,\n                    maxAmountsIn: balances,\n                    userData: abi.encode(balances, 0),\n                    fromInternalBalance: false\n                })\n            );\n        }\n    }\n\n    /// @notice Calculates the total assets of this vault using the current spot prices, with no regard for slippage.\n    function totalAssets() public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return asset.balanceOf(address(this));\n        } \n        else {\n            Space _space = space;\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n            \n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, ) = _decomposeShares(ptReserves, targetReserves, totalSupply, true);\n\n            uint256 ptSpotPrice = _space.getPriceFromImpliedRate(\n                (ptReserves + _space.adjustedTotalSupply()).divWadDown(targetReserves.mulWadDown(initScale)) - 1e18\n            ); // PT price in Target.\n\n            uint256 scale = adapter.scaleStored();\n\n            if (ptBal >= ytBal) {\n                // Target + combined PTs/YTs + PT spot value in Target.\n                return targetBal + ytBal.divWadDown(scale) + ptSpotPrice.mulWadDown(ptBal - ytBal);\n            } else {\n                uint256 ytSpotPrice = (1e18 - ptSpotPrice.mulWadDown(scale)).divWadDown(scale);\n\n                // Target + combined PTs/YTs + YT spot value in Target.\n                return targetBal + ptBal.divWadDown(scale) + ytSpotPrice.mulWadDown(ytBal - ptBal);\n            }\n        }\n    }\n\n    /// @notice The same as convertToShares, except that slippage is considered.\n    /// @dev Preview the number of new LP shares that would be minted by joining with the given amount of Target, then use that\n    ///      as a percentage of the total number of LP shares held in this contract to preview the number of new roller shares.\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewDeposit(assets);\n        } else {\n            Space _space = space;\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            // Calculate how much Target we'll end up joining the pool with, and use that to preview minted LP shares.\n            uint256 previewedLPBal = (assets - _getTargetForIssuance(ptReserves, targetReserves, assets, adapter.scaleStored()))\n                .mulDivDown(_space.adjustedTotalSupply(), targetReserves);\n\n            // Shares represent proportional ownership of LP shares the vault holds.\n            return previewedLPBal.mulDivDown(totalSupply, _space.balanceOf(address(this)));\n        }\n    }\n\n    /// @dev Preview the amount of Target needed to mint the given number of shares by determining how much of\n    ///      each asset in this contract the given number of shares represent, then conver that all into Target.\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewMint(shares);\n        } else {\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            (uint256 targetToJoin, uint256 ptsToJoin, , ) = _decomposeShares(ptReserves, targetReserves, shares, true);\n\n            return targetToJoin + ptsToJoin.divWadUp(adapter.scaleStored().mulWadDown(1e18 - ifee)); // targetToJoin + targetToIssue\n        }\n    }\n\n    /// @notice The same as convertToAssets, except that slippage is considered.\n    function previewRedeem(uint256 shares) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewRedeem(shares);\n        } else {\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, uint256 lpBal) = _decomposeShares(ptReserves, targetReserves, shares, false);\n\n            uint256 scale = adapter.scaleStored();\n\n            ptReserves     = ptReserves - ptBal;\n            targetReserves = targetReserves - targetBal;\n\n            uint256 spaceSupply = space.adjustedTotalSupply();\n\n            // Adjust balances for loose asset share.\n            ptBal       = ptBal       + lpBal.mulDivDown(pt.balanceOf(address(this)), spaceSupply);\n            targetBal   = targetBal   + lpBal.mulDivDown(asset.balanceOf(address(this)), spaceSupply);\n            spaceSupply = spaceSupply - lpBal;\n\n            if (ptBal > ytBal) {\n                unchecked {\n                    // Safety: an inequality check is done before ptBal - ytBal.\n                    //         shares must be lte total supply, so ptReserves & targetReserves wil always be gte ptBal & targetBal.\n                    uint256 maxPTSale = _maxPTSell(\n                        ptReserves,\n                        targetReserves,\n                        spaceSupply\n                    );\n\n                    // If there isn't enough liquidity to sell all of the PTs, sell the max that we can and ignore the remaining PTs.\n                    uint256 ptsToSell = _min(ptBal - ytBal, maxPTSale);\n\n                    uint256 targetOut = ptsToSell > minSwapAmount ?\n                        space.onSwapPreview(\n                            true,\n                            true,\n                            ptsToSell,\n                            ptReserves,\n                            targetReserves,\n                            spaceSupply,\n                            scale\n                        ) : 0;\n\n                    // target + combined PTs/YTs + sold PTs - buffer for pow of discrepencies.\n                    return targetBal + ytBal.divWadDown(scale) + targetOut - maxError;\n                }\n            } else {\n                unchecked {\n                    // Safety: an inequality check is done before ytBal - ptBal.\n                    //         shares must be lte total supply, so ptReserves & targetReserves wil always be gte ptBal & targetBal.\n\n                    // If there isn't enough liquidity to sell all of the YTs, sell the max that we can and ignore the remaining YTs.\n                    uint256 ytsToSell = _min(ytBal - ptBal, ptReserves);\n\n                    // Target from combining YTs with PTs - target needed to buy PTs.\n                    uint256 targetOut = ytsToSell > minSwapAmount ? \n                        ytsToSell.divWadDown(scale) - space.onSwapPreview(\n                            false,\n                            false,\n                            ytsToSell,\n                            targetReserves,\n                            ptReserves,\n                            spaceSupply,\n                            scale\n                        ) : 0;\n\n                    // target + combined PTs/YTs + sold YTs - buffer for pow of discrepencies.\n                    return targetBal + ptBal.divWadDown(scale) + targetOut - maxError;\n                }\n            }\n        }\n    }\n\n    /// @notice Amount of shares needed to redeem the given assets, erring on the side of overestimation.\n    ///         The calculation for previewWithdraw is quite imprecise and expensive, so previewRedeem & redeem\n    ///         should be favored over previewWithdraw & withdraw.\n    function previewWithdraw(uint256 assets) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.previewWithdraw(assets);\n        } else {\n            uint256 _supply = totalSupply - firstDeposit;\n\n            int256 prevGuess  = _min(assets, _supply).safeCastToInt();\n            int256 prevAnswer = previewRedeem(prevGuess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n\n            int256 guess = prevGuess * WITHDRAWAL_GUESS_OFFSET / 1e18;\n\n            int256 supply = _supply.safeCastToInt();\n\n            // Find the root or get very close to it using the secant method, which is slightly more efficient than Newton's\n            // method if the cost of evaluating f and f' is similar.\n            for (uint256 i = 0; i < 20;) { // 20 chosen as a safe bound for convergence from practical trials.\n                if (guess > supply) {\n                    guess = supply;\n                }\n\n                int256 answer = previewRedeem(guess.safeCastToUint()).safeCastToInt() - assets.safeCastToInt();\n\n                if (answer >= 0 && answer <= assets.mulWadDown(0.001e18).safeCastToInt() || (prevAnswer == answer)) { // Err on the side of overestimating shares needed. Could reduce precision for gas efficiency.\n                    break;\n                }\n\n                if (guess == supply && answer < 0) revert InsufficientLiquidity();\n\n                int256 nextGuess = guess - (answer * (guess - prevGuess) / (answer - prevAnswer));\n                prevGuess  = guess;\n                prevAnswer = answer;\n                guess      = nextGuess;\n\n                unchecked { ++i; }\n            }\n\n            return guess.safeCastToUint() + maxError; // Buffer for pow discrepancies.\n        }\n    }\n\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        if (maturity == MATURITY_NOT_SET) {\n            return super.maxWithdraw(owner);\n        } else {\n            return previewRedeem(maxRedeem(owner));\n        }\n    }\n\n    /// @notice Maximum number of shares the given owner can redeem, given Space pool liquidity constraints and the maxRate guard.\n    function maxRedeem(address owner) public view override returns (uint256) { // No idiosyncratic owner restrictions.\n        if (maturity == MATURITY_NOT_SET) {\n            return super.maxRedeem(owner);\n        } else {\n            uint256 shares = balanceOf[owner];\n\n            (uint256 ptReserves, uint256 targetReserves) = _getSpaceReserves();\n\n            (uint256 targetBal, uint256 ptBal, uint256 ytBal, uint256 lpBal) = _decomposeShares(ptReserves, targetReserves, shares, false);\n\n            ptReserves     = ptReserves - ptBal;\n            targetReserves = targetReserves - targetBal;\n\n            uint256 spaceSupply = space.adjustedTotalSupply();\n\n            ptBal       = ptBal       + lpBal.mulDivDown(pt.balanceOf(address(this)), spaceSupply);\n            targetBal   = targetBal   + lpBal.mulDivDown(asset.balanceOf(address(this)), spaceSupply);\n            spaceSupply = spaceSupply - lpBal;\n\n            bool isExcessPTs = ptBal > ytBal;\n            uint256 diff = isExcessPTs ? ptBal - ytBal : ytBal - ptBal;\n\n            if (isExcessPTs) {\n                uint256 maxPTSale = _maxPTSell(ptReserves, targetReserves, spaceSupply);\n\n                if (maxPTSale >= diff) {\n                    // We have enough liquidity to handle the sale.\n                    return shares;\n                } else {\n                    // For every unit of LP Share, the excess PT balance grows by \"hole\".\n                    uint256 hole = diff.divWadDown(lpBal);\n\n                    // Determine how many shares we can redeem without exceeding sell limits.\n                    return maxPTSale.divWadDown(hole).mulDivDown(totalSupply, space.balanceOf(address(this)));\n                }\n            } else {\n                if (ptReserves >= diff) { // We can redeem YTs up to the point where there are PTs in Space to swap for.\n                    // We have enough liquidity to handle the sale.\n                    return shares;\n                } else {\n                    // For every unit of LP Share, the excess YT balance grows by \"hole\".\n                    uint256 hole = diff.divWadDown(lpBal);\n\n                    // Determine how many shares we can redeem without exceeding sell limits.\n                    return ptReserves.divWadDown(hole).mulDivDown(totalSupply, space.balanceOf(address(this)));\n                }\n            }\n        }\n    }\n\n    /* ========== 4626 EXTENSIONS ========== */\n\n    /// @notice Quick exit into the constituent assets.\n    /// @param shares Number of shares to eject with.\n    /// @param receiver Destination address for the constituent assets.\n    /// @param owner Onwer of the shares.\n    /// @return assets Amount of asset redeemable by the given number of shares.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function eject(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets, uint256 excessBal, bool isExcessPTs) {\n        if (maturity == MATURITY_NOT_SET) revert ActivePhaseOnly();\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        (excessBal, isExcessPTs) = _exitAndCombine(shares);\n\n        _burn(owner, shares); // Burn after percent ownership is determined in _exitAndCombine.\n\n        if (isExcessPTs) {\n            pt.transfer(receiver, excessBal);\n        } else {\n            yt.transfer(receiver, excessBal);\n        }\n\n        asset.transfer(receiver, assets = asset.balanceOf(address(this)));\n        emit Ejected(msg.sender, receiver, owner, assets, shares,\n            isExcessPTs ? excessBal : 0,\n            isExcessPTs ? 0 : excessBal\n        );\n    }\n\n    /* ========== GENERAL UTILS ========== */\n\n    /// @dev Exit Assets from the Space pool and combine the PTs with YTs we have reserved for the given number of shares.\n    /// @param shares number of shares to exit and combine with.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function _exitAndCombine(uint256 shares) internal returns (uint256, bool) {\n        uint256 supply = totalSupply; // Save extra SLOAD.\n\n        uint256 lpBal      = shares.mulDivDown(space.balanceOf(address(this)), supply);\n        uint256 totalPTBal = pt.balanceOf(address(this));\n        uint256 ptShare    = shares.mulDivDown(totalPTBal, supply);\n\n        ERC20[] memory tokens = new ERC20[](2);\n        tokens[1 - pti] = asset;\n        tokens[pti    ] = pt;\n\n        _exitPool(\n            poolId,\n            BalancerVault.ExitPoolRequest({\n                assets: tokens,\n                minAmountsOut: new uint256[](2),\n                userData: abi.encode(lpBal),\n                toInternalBalance: false\n            })\n        );\n\n        uint256 ytBal = shares.mulDivDown(yt.balanceOf(address(this)), supply);\n        ptShare += pt.balanceOf(address(this)) - totalPTBal;\n\n        unchecked {\n            // Safety: an inequality check is done before subtraction.\n            if (ptShare > ytBal) {\n                divider.combine(address(adapter), maturity, ytBal);\n                return (ptShare - ytBal, true);\n            } else { // Set excess PTs to false if the balances are exactly equal.\n                divider.combine(address(adapter), maturity, ptShare);\n                return (ytBal - ptShare, false);\n            }\n        }\n    }\n\n    /// @notice Transfer any token not included in the set {asset,yt,pt,space} to the rewards recipient.\n    /// @param coin address of the coin to transfer out.\n    function claimRewards(ERC20 coin) external {\n        requ"
    }
  ]
}