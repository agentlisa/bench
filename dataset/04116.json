{
  "Title": "Inaccurate `liquidityAdded` Parameter Before Flashloan Transfer",
  "Content": "##### Description\n\nhttps://github.com/aave/protocol-v2/blob/56d25e81cb0fdfcac785d669d3577b1ef2d9286e/contracts/lendingpool/LendingPool.sol#L511\n\nThe `liquidityAdded` parameter of the `updateInterestRates` call seems to be incorrect as the flashloan body is yet to be transferred thus it will not be included in the interest rates calculation.\n\n##### Recommendation\n\nIt is recommended to fix the `liquidityAdded` parameter.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/lendingpool/LendingPool.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from '../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IAToken} from '../tokenization/interfaces/IAToken.sol';\nimport {Helpers} from '../libraries/helpers/Helpers.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\nimport {GenericLogic} from '../libraries/logic/GenericLogic.sol';\nimport {ValidationLogic} from '../libraries/logic/ValidationLogic.sol';\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol';\nimport {IStableDebtToken} from '../tokenization/interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../tokenization/interfaces/IVariableDebtToken.sol';\nimport {DebtTokenBase} from '../tokenization/base/DebtTokenBase.sol';\nimport {IFlashLoanReceiver} from '../flashloan/interfaces/IFlashLoanReceiver.sol';\nimport {LendingPoolCollateralManager} from './LendingPoolCollateralManager.sol';\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\nimport {LendingPoolStorage} from './LendingPoolStorage.sol';\nimport {Address} from '../dependencies/openzeppelin/contracts/Address.sol';\n\n/**\n * @title LendingPool contract\n * @notice Implements the actions of the LendingPool, and exposes accessory methods to fetch the users and reserve data\n * @author Aave\n **/\ncontract LendingPool is VersionedInitializable, ILendingPool, LendingPoolStorage {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //main configuration parameters\n  uint256 public constant MAX_STABLE_RATE_BORROW_SIZE_PERCENT = 2500;\n  uint256 public constant FLASHLOAN_PREMIUM_TOTAL = 9;\n  uint256 public constant MAX_NUMBER_RESERVES = 128;\n  uint256 public constant LENDINGPOOL_REVISION = 0x2;\n\n  /**\n   * @dev functions marked by this modifier can only be called when the protocol is not paused\n   **/\n  modifier whenNotPaused() {\n    _whenNotPaused();\n    _;\n  }\n\n  /**\n   * @dev functions marked by this modifier can only be called by the LendingPoolConfigurator\n   **/\n  modifier onlyLendingPoolConfigurator() {\n    _onlyLendingPoolConfigurator();\n    _;\n  }\n\n  /**\n   * @dev only lending pools configurator can use functions affected by this modifier\n   **/\n  function _onlyLendingPoolConfigurator() internal view {\n    require(\n      _addressesProvider.getLendingPoolConfigurator() == msg.sender,\n      Errors.LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR\n    );\n  }\n\n  /**\n   * @dev Function to make a function callable only when the contract is not paused.\n   *\n   * Requirements:\n   *\n   * - The contract must not be paused.\n   */\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.LP_IS_PAUSED);\n  }\n\n  function getRevision() internal override pure returns (uint256) {\n    return LENDINGPOOL_REVISION;\n  }\n\n  /**\n   * @dev this function is invoked by the proxy contract when the LendingPool contract is added to the\n   * AddressesProvider.\n   * @param provider the address of the LendingPoolAddressesProvider registry\n   **/\n  function initialize(ILendingPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev deposits The underlying asset into the reserve. A corresponding amount of the overlying asset (aTokens)\n   * is minted.\n   * @param asset the address of the reserve\n   * @param amount the amount to be deposited\n   * @param referralCode integrators are assigned a referral code and can potentially receive rewards.\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override whenNotPaused {\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    ValidationLogic.validateDeposit(reserve, amount);\n\n    address aToken = reserve.aTokenAddress;\n\n    reserve.updateState();\n    reserve.updateInterestRates(asset, aToken, amount, 0);\n\n    bool isFirstDeposit = IAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\n\n    if (isFirstDeposit) {\n      _usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\n      emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\n    }\n\n    //transfer to the aToken contract\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\n\n    emit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\n  }\n\n  /**\n   * @dev withdraws the _reserves of user.\n   * @param asset the address of the reserve\n   * @param amount the underlying amount to be redeemed\n   * @param to address that will receive the underlying\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external override whenNotPaused {\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    address aToken = reserve.aTokenAddress;\n\n    uint256 userBalance = IAToken(aToken).balanceOf(msg.sender);\n\n    uint256 amountToWithdraw = amount;\n\n    //if amount is equal to uint(-1), the user wants to redeem everything\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    ValidationLogic.validateWithdraw(\n      asset,\n      amountToWithdraw,\n      userBalance,\n      _reserves,\n      _usersConfig[msg.sender],\n      _reservesList,\n      _reservesCount,\n      _addressesProvider.getPriceOracle()\n    );\n\n    reserve.updateState();\n\n    reserve.updateInterestRates(asset, aToken, 0, amountToWithdraw);\n\n    if (amountToWithdraw == userBalance) {\n      _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n    }\n\n    IAToken(aToken).burn(msg.sender, to, amountToWithdraw, reserve.liquidityIndex);\n\n    emit Withdraw(asset, msg.sender, to, amountToWithdraw);\n  }\n\n  /**\n   * @dev Allows users to borrow a specific amount of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * @param asset the address of the reserve\n   * @param amount the amount to be borrowed\n   * @param interestRateMode the interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode a referral code for integrators\n   * @param onBehalfOf address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance \n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external override whenNotPaused {\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    _executeBorrow(\n      ExecuteBorrowParams(\n        asset,\n        msg.sender,\n        onBehalfOf,\n        amount,\n        interestRateMode,\n        reserve.aTokenAddress,\n        referralCode,\n        true\n      )\n    );\n  }\n\n  /**\n   * @notice repays a borrow on the specific reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n   * @dev the target user is defined by onBehalfOf. If there is no repayment on behalf of another account,\n   * onBehalfOf must be equal to msg.sender.\n   * @param asset the address of the reserve on which the user borrowed\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n   * @param onBehalfOf the address for which msg.sender is repaying.\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external override whenNotPaused {\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\n\n    ReserveLogic.InterestRateMode interestRateMode = ReserveLogic.InterestRateMode(rateMode);\n\n    ValidationLogic.validateRepay(\n      reserve,\n      amount,\n      interestRateMode,\n      onBehalfOf,\n      stableDebt,\n      variableDebt\n    );\n\n    //default to max amount\n    uint256 paybackAmount = interestRateMode == ReserveLogic.InterestRateMode.STABLE\n      ? stableDebt\n      : variableDebt;\n\n    if (amount < paybackAmount) {\n      paybackAmount = amount;\n    }\n\n    reserve.updateState();\n\n    //burns an equivalent amount of debt tokens\n    if (interestRateMode == ReserveLogic.InterestRateMode.STABLE) {\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount);\n    } else {\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n        onBehalfOf,\n        paybackAmount,\n        reserve.variableBorrowIndex\n      );\n    }\n\n    address aToken = reserve.aTokenAddress;\n    reserve.updateInterestRates(asset, aToken, paybackAmount, 0);\n\n    if (stableDebt.add(variableDebt).sub(paybackAmount) == 0) {\n      _usersConfig[onBehalfOf].setBorrowing(reserve.id, false);\n    }\n\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount);\n\n    emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\n  }\n\n  /**\n   * @dev borrowers can user this function to swap between stable and variable borrow rate modes.\n   * @param asset the address of the reserve on which the user borrowed\n   * @param rateMode the rate mode that the user wants to swap\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external override whenNotPaused {\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(msg.sender, reserve);\n\n    ReserveLogic.InterestRateMode interestRateMode = ReserveLogic.InterestRateMode(rateMode);\n\n    ValidationLogic.validateSwapRateMode(\n      reserve,\n      _usersConfig[msg.sender],\n      stableDebt,\n      variableDebt,\n      interestRateMode\n    );\n\n    reserve.updateState();\n\n    if (interestRateMode == ReserveLogic.InterestRateMode.STABLE) {\n      //burn stable rate tokens, mint variable rate tokens\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(msg.sender, stableDebt);\n      IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n        msg.sender,\n        msg.sender,\n        stableDebt,\n        reserve.variableBorrowIndex\n      );\n    } else {\n      //do the opposite\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n        msg.sender,\n        variableDebt,\n        reserve.variableBorrowIndex\n      );\n      IStableDebtToken(reserve.stableDebtTokenAddress).mint(\n        msg.sender,\n        msg.sender,\n        variableDebt,\n        reserve.currentStableBorrowRate\n      );\n    }\n\n    reserve.updateInterestRates(asset, reserve.aTokenAddress, 0, 0);\n\n    emit Swap(asset, msg.sender, rateMode);\n  }\n\n  /**\n   * @dev rebalances the stable interest rate of a user. Users can be rebalanced if the following conditions are satisfied:\n   * 1. Usage ratio is above 95%\n   * 2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *    borrowed at a stable rate and depositors are not earning enough.\n   * @param asset the address of the reserve\n   * @param user the address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external override whenNotPaused {\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    IERC20 stableDebtToken = IERC20(reserve.stableDebtTokenAddress);\n    IERC20 variableDebtToken = IERC20(reserve.variableDebtTokenAddress);\n    address aTokenAddress = reserve.aTokenAddress;\n\n    uint256 stableDebt = IERC20(stableDebtToken).balanceOf(user);\n\n    ValidationLogic.validateRebalanceStableBorrowRate(\n      reserve,\n      asset,\n      stableDebtToken,\n      variableDebtToken,\n      aTokenAddress\n    );\n\n    reserve.updateState();\n\n    IStableDebtToken(address(stableDebtToken)).burn(user, stableDebt);\n    IStableDebtToken(address(stableDebtToken)).mint(\n      user,\n      user,\n      stableDebt,\n      reserve.currentStableBorrowRate\n    );\n\n    reserve.updateInterestRates(asset, aTokenAddress, 0, 0);\n\n    emit RebalanceStableBorrowRate(asset, user);\n  }\n\n  /**\n   * @dev allows depositors to enable or disable a specific deposit as collateral.\n   * @param asset the address of the reserve\n   * @param useAsCollateral true if the user wants to use the deposit as collateral, false otherwise.\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n    external\n    override\n    whenNotPaused\n  {\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    ValidationLogic.validateSetUseReserveAsCollateral(\n      reserve,\n      asset,\n      useAsCollateral,\n      _reserves,\n      _usersConfig[msg.sender],\n      _reservesList,\n      _reservesCount,\n      _addressesProvider.getPriceOracle()\n    );\n\n    _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, useAsCollateral);\n\n    if (useAsCollateral) {\n      emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\n    } else {\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n    }\n  }\n\n  /**\n   * @dev users can invoke this function to liquidate an undercollateralized position.\n   * @param asset the address of the collateral to liquidated\n   * @param asset the address of the principal reserve\n   * @param user the address of the borrower\n   * @param purchaseAmount the amount of principal that the liquidator wants to repay\n   * @param receiveAToken true if the liquidators wants to receive the aTokens, false if\n   * he wants to receive the underlying asset directly\n   **/\n  function liquidationCall(\n    address collateral,\n    address asset,\n    address user,\n    uint256 purchaseAmount,\n    bool receiveAToken\n  ) external override whenNotPaused {\n    address collateralManager = _addressesProvider.getLendingPoolCollateralManager();\n\n    //solium-disable-next-line\n    (bool success, bytes memory result) = collateralManager.delegatecall(\n      abi.encodeWithSignature(\n        'liquidationCall(address,address,address,uint256,bool)',\n        collateral,\n        asset,\n        user,\n        purchaseAmount,\n        receiveAToken\n      )\n    );\n    require(success, Errors.LP_LIQUIDATION_CALL_FAILED);\n\n    (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\n\n    require(returnCode == 0, string(abi.encodePacked(returnMessage)));\n  }\n\n  struct FlashLoanLocalVars {\n    IFlashLoanReceiver receiver;\n    address oracle;\n    uint256 i;\n    address currentAsset;\n    address currentATokenAddress;\n    uint256 currentAmount;\n    uint256 currentPremium;\n    uint256 currentAmountPlusPremium;\n    address debtToken;\n  }\n\n  /**\n   * @dev allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned. NOTE There are security concerns for developers of flashloan receiver contracts\n   * that must be kept into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds. The receiver should implement the IFlashLoanReceiver interface.\n   * @param assets The addresss of the assets being flashborrowed\n   * @param amounts The amounts requested for this flashloan for each asset\n   * @param modes Types of the debt to open if the flash loan is not returned. 0 -> Don't open any debt, just revert, 1 -> stable, 2 -> variable\n   * @param onBehalfOf If mode is not 0, then the address to take the debt onBehalfOf. The onBehalfOf address must already have approved `msg.sender` to incur the debt on their behalf.\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Referral code of the flash loan\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external override whenNotPaused {\n    FlashLoanLocalVars memory vars;\n\n    ValidationLogic.validateFlashloan(assets, amounts);\n\n    address[] memory aTokenAddresses = new address[](assets.length);\n    uint256[] memory premiums = new uint256[](assets.length);\n\n    vars.receiver = IFlashLoanReceiver(receiverAddress);\n\n    for (vars.i = 0; vars.i < assets.length; vars.i++) {\n      aTokenAddresses[vars.i] = _reserves[assets[vars.i]].aTokenAddress;\n\n      premiums[vars.i] = amounts[vars.i].mul(FLASHLOAN_PREMIUM_TOTAL).div(10000);\n\n      //transfer funds to the receiver\n      IAToken(aTokenAddresses[vars.i]).transferUnderlyingTo(receiverAddress, amounts[vars.i]);\n    }\n\n    //execute action of the receiver\n    require(\n      vars.receiver.executeOperation(assets, amounts, premiums, msg.sender, params),\n      Errors.LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN\n    );\n\n    for (vars.i = 0; vars.i < assets.length; vars.i++) {\n      vars.currentAsset = assets[vars.i];\n      vars.currentAmount = amounts[vars.i];\n      vars.currentPremium = premiums[vars.i];\n      vars.currentATokenAddress = aTokenAddresses[vars.i];\n      vars.currentAmountPlusPremium = vars.currentAmount.add(vars.currentPremium);\n\n      if (ReserveLogic.InterestRateMode(modes[vars.i]) == ReserveLogic.InterestRateMode.NONE) {\n        _reserves[vars.currentAsset].updateState();\n        _reserves[vars.currentAsset].cumulateToLiquidityIndex(\n          IERC20(vars.currentATokenAddress).totalSupply(),\n          vars.currentPremium\n        );\n        _reserves[vars.currentAsset].updateInterestRates(\n          vars.currentAsset,\n          vars.currentATokenAddress,\n          vars.currentPremium,\n          0\n        );\n\n        IERC20(vars.currentAsset).safeTransferFrom(\n          receiverAddress,\n          vars.currentATokenAddress,\n          vars.currentAmountPlusPremium\n        );\n      } else {\n        //if the user didn't choose to return the funds, the system checks if there\n        //is enough collateral and eventually open a position\n        _executeBorrow(\n          ExecuteBorrowParams(\n            vars.currentAsset,\n            msg.sender,\n            onBehalfOf,\n            vars.currentAmount,\n            modes[vars.i],\n            vars.currentATokenAddress,\n            referralCode,\n            false\n          )\n        );\n      }\n      emit FlashLoan(\n        receiverAddress,\n        msg.sender,\n        vars.currentAsset,\n        vars.currentAmount,\n        vars.currentPremium,\n        referralCode\n      );\n    }\n  }\n\n  /**\n   * @dev returns the state and configuration of the reserve\n   * @param asset the address of the reserve\n   * @return the state of the reserve\n   **/\n  function getReserveData(address asset)\n    external\n    override\n    view\n    returns (ReserveLogic.ReserveData memory)\n  {\n    return _reserves[asset];\n  }\n\n  /**\n   * @dev returns the user account data across all the reserves\n   * @param user the address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    override\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    )\n  {\n    (\n      totalCollateralETH,\n      totalDebtETH,\n      ltv,\n      currentLiquidationThreshold,\n      healthFactor\n    ) = GenericLogic.calculateUserAccountData(\n      user,\n      _reserves,\n      _usersConfig[user],\n      _reservesList,\n      _reservesCount,\n      _addressesProvider.getPriceOracle()\n    );\n\n    availableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH(\n      totalCollateralETH,\n      totalDebtETH,\n      ltv\n    );\n  }\n\n  /**\n   * @dev returns the configuration of the reserve\n   * @param asset the address of the reserve\n   * @return the configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    override\n    view\n    returns (ReserveConfiguration.Map memory)\n  {\n    return _reserves[asset].configuration;\n  }\n\n  /**\n   * @dev returns the configuration of the user across all the reserves\n   * @param user the user\n   * @return the configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    override\n    view\n    returns (UserConfiguration.Map memory)\n  {\n    return _usersConfig[user];\n  }\n\n  /**\n   * @dev returns the normalized income per unit of asset\n   * @param asset the address of the reserve\n   * @return the reserve normalized income\n   */\n  function getReserveNormalizedIncome(address asset)\n    external\n    virtual\n    override\n    view\n    returns (uint256)\n  {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev returns the normalized variable debt per unit of asset\n   * @param asset the address of the reserve\n   * @return the reserve normalized debt\n   */\n  function getReserveNormalizedVariableDebt(address asset)\n    external\n    override\n    view\n    returns (uint256)\n  {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /**\n   * @dev Returns if the LendingPool is paused\n   */\n  function paused() external override view returns (bool) {\n    return _paused;\n  }\n\n  /**\n   * @dev returns the list of the initialized reserves\n   **/\n  function getReservesList() external override view returns (address[] memory) {\n    address[] memory _activeReserves = new address[](_reservesCount);\n\n    for (uint256 i = 0; i < _reservesCount; i++) {\n      _activeReserves[i] = _reservesList[i];\n    }\n    return _activeReserves;\n  }\n\n  /**\n   * @dev returns the addresses provider\n   **/\n  function getAddressesProvider() external override view returns (ILendingPoolAddressesProvider) {\n    return _addressesProvider;\n  }\n\n  /**\n   * @dev validates and finalizes an aToken transfer\n   * @param asset the address of the reserve\n   * @param from the user from which the aTokens are transferred\n   * @param to the user receiving the aTokens\n   * @param amount the amount being transferred/redeemed\n   * @param balanceFromBefore the balance of the from user before the transfer\n   * @param balanceToBefore the balance of the to user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external override whenNotPaused {\n    require(msg.sender == _reserves[asset].aTokenAddress, Errors.LP_CALLER_MUST_BE_AN_ATOKEN);\n\n    ValidationLogic.validateTransfer(\n      from,\n      _reserves,\n      _usersConfig[from],\n      _reservesList,\n      _reservesCount,\n      _addressesProvider.getPriceOracle()\n    );\n\n    uint256 reserveId = _reserves[asset].id;\n\n    if (from != to) {\n      if (balanceFromBefore.sub(amount) == 0) {\n        UserConfiguration.Map storage fromConfig = _usersConfig[from];\n        fromConfig.setUsingAsCollateral(reserveId, false);\n        emit ReserveUsedAsCollateralDisabled(asset, from);\n      }\n\n      if (balanceToBefore == 0 && amount != 0) {\n        UserConfiguration.Map storage toConfig = _usersConfig[to];\n        toConfig.setUsingAsCollateral(reserveId, true);\n        emit ReserveUsedAsCollateralEnabled(asset, to);\n      }\n    }\n  }\n\n  /**\n   * @dev initializes a reserve\n   * @param asset the address of the reserve\n   * @param aTokenAddress the address of the overlying aToken contract\n   * @param interestRateStrategyAddress the address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external override onlyLendingPoolConfigurator {\n    require(Address.isContract(asset), Errors.LP_NOT_CONTRACT);\n    _reserves[asset].init(\n      aTokenAddress,\n      stableDebtAddress,\n      variableDebtAddress,\n      interestRateStrategyAddress\n    );\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev updates the address of the interest rate strategy contract\n   * @param asset the address of the reserve\n   * @param rateStrategyAddress the address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external\n    override\n    onlyLendingPoolConfigurator\n  {\n    _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n  }\n\n  /**\n   * @dev sets the configuration map of the reserve\n   * @param asset the address of the reserve\n   * @param configuration the configuration map\n   **/\n  function setConfiguration(address asset, uint256 configuration)\n    external\n    override\n    onlyLendingPoolConfigurator\n  {\n    _reserves[asset].configuration.data = configuration;\n  }\n\n  /**\n   * @dev Set the _pause state\n   * @param val the boolean value to set the current pause state of LendingPool\n   */\n  function setPause(bool val) external override onlyLendingPoolConfigurator {\n    _paused = val;\n    if (_paused) {\n      emit Paused();\n    } else {\n      emit Unpaused();\n    }\n  }\n\n  // internal functions\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    uint256 interestRateMode;\n    address aTokenAddress;\n    uint16 referralCode;\n    bool releaseUnderlying;\n  }\n\n  /**\n   * @dev Internal function to execute a borrowing action, allowing to transfer or not the underlying\n   * @param vars Input struct for the borrowing action, in order to avoid STD errors\n   **/\n  function _executeBorrow(ExecuteBorrowParams memory vars) internal {\n    ReserveLogic.ReserveData storage reserve = _reserves[vars.asset];\n    UserConfiguration.Map storage userConfig = _usersConfig[vars.onBehalfOf];\n\n    address oracle = _addressesProvider.getPriceOracle();\n\n    uint256 amountInETH = IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div(\n      10**reserve.configuration.getDecimals()\n    );\n\n    ValidationLogic.validateBorrow(\n      vars.asset,\n      reserve,\n      vars.onBehalfOf,\n      vars.amount,\n      amountInETH,\n      vars.interestRateMode,\n      MAX_STABLE_RATE_BORROW_SIZE_PERCENT,\n      _reserves,\n      userConfig,\n      _reservesList,\n      _reservesCount,\n      oracle\n    );\n\n    reserve.updateState();\n\n    //caching the current stable borrow rate\n    uint256 currentStableRate = 0;\n\n    bool isFirstBorrowing = false;\n    if (\n      ReserveLogic.InterestRateMode(vars.interestRateMode) == ReserveLogic.InterestRateMode.STABLE\n    ) {\n      currentStableRate = reserve.currentStableBorrowRate;\n\n      isFirstBorrowing = IStableDebtToken(reserve.stableDebtTokenAddress).mint(\n        vars.user,\n        vars.onBehalfOf,\n        vars.amount,\n        currentStableRate\n      );\n    } else {\n      isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n        vars.user,\n        vars.onBehalfOf,\n        vars.amount,\n        reserve.variableBorrowIndex\n      );\n    }\n\n    if (isFirstBorrowing) {\n      userConfig.setBorrowing(reserve.id, true);\n    }\n\n    reserve.updateInterestRates(\n      vars.asset,\n      vars.aTokenAddress,\n      0,\n      vars.releaseUnderlying ? vars.amount : 0\n    );\n\n    if (vars.releaseUnderlying) {\n      IAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount);\n    }\n\n    emit Borrow(\n      vars.asset,\n      vars.user,\n      vars.onBehalfOf,\n      vars.amount,\n      vars.interestRateMode,\n      ReserveLogic.InterestRateMode(vars.interestRateMode) == ReserveLogic.InterestRateMode.STABLE\n        ? currentStableRate\n        : reserve.currentVariableBorrowRate,\n      vars.referralCode\n    );\n  }\n\n  /**\n   * @dev adds a reserve to the array of the _reserves address\n   **/\n  function _addReserveToList(address asset) internal {\n    uint256 reservesCount = _reservesCount;\n\n    require(reservesCount < MAX_NUMBER_RESERVES, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(reservesCount);\n      _reservesList[reservesCount] = asset;\n\n      _reservesCount = reservesCount + 1;\n    }\n  }\n}"
    }
  ]
}