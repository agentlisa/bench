{
  "Title": "[07] Consider using BST instead",
  "Content": "\nTake a look [here](https://github.com/code-423n4/2024-03-acala/blob/9c71c05cf2d9f0a2603984c50f76fc8a315d4d65/src/orml/rewards/src/lib.rs#L21-L26).\n\n```rust\npub struct PoolInfo<Share: HasCompact, Balance: HasCompact, CurrencyId: Ord> {\n\t/// Total shares amount\n\tpub total_shares: Share,\n\t/// Reward infos <reward_currency, (total_reward, total_withdrawn_reward)>\n\tpub rewards: BTreeMap<CurrencyId, (Balance, Balance)>,\n}\n```\n\nEvidently, the reward infos are stores in a B-Tree map which is in short an ordered map based on a `B-Tree`.\n\n`B-Trees` represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log2n).\n\n### Impact\n\nNon-optimized method of finding elements.\n\n### Recommended Mitigation Steps\n\nConsider using binary search trees instead.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-acala",
  "Code": [
    {
      "filename": "src/orml/rewards/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::unused_unit)]\n#![allow(clippy::too_many_arguments)]\n\nmod mock;\nmod tests;\n\nuse frame_support::pallet_prelude::*;\nuse orml_traits::RewardHandler;\nuse parity_scale_codec::{FullCodec, HasCompact};\nuse scale_info::TypeInfo;\nuse sp_core::U256;\nuse sp_runtime::{\n\ttraits::{AtLeast32BitUnsigned, MaybeSerializeDeserialize, Member, Saturating, UniqueSaturatedInto, Zero},\n\tFixedPointOperand, RuntimeDebug, SaturatedConversion,\n};\nuse sp_std::{borrow::ToOwned, collections::btree_map::BTreeMap, fmt::Debug, prelude::*};\n\n/// The Reward Pool Info.\n#[derive(Clone, Encode, Decode, PartialEq, Eq, RuntimeDebug, TypeInfo)]\npub struct PoolInfo<Share: HasCompact, Balance: HasCompact, CurrencyId: Ord> {\n\t/// Total shares amount\n\tpub total_shares: Share,\n\t/// Reward infos <reward_currency, (total_reward, total_withdrawn_reward)>\n\tpub rewards: BTreeMap<CurrencyId, (Balance, Balance)>,\n}\n\nimpl<Share, Balance, CurrencyId> Default for PoolInfo<Share, Balance, CurrencyId>\nwhere\n\tShare: Default + HasCompact,\n\tBalance: HasCompact,\n\tCurrencyId: Ord,\n{\n\tfn default() -> Self {\n\t\tSelf {\n\t\t\ttotal_shares: Default::default(),\n\t\t\trewards: BTreeMap::new(),\n\t\t}\n\t}\n}\n\npub use module::*;\n\n#[frame_support::pallet]\npub mod module {\n\n\tuse super::*;\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The share type of pool.\n\t\ttype Share: Parameter\n\t\t\t+ Member\n\t\t\t+ AtLeast32BitUnsigned\n\t\t\t+ Default\n\t\t\t+ Copy\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ Debug\n\t\t\t+ FixedPointOperand;\n\n\t\t/// The reward balance type.\n\t\ttype Balance: Parameter\n\t\t\t+ Member\n\t\t\t+ AtLeast32BitUnsigned\n\t\t\t+ Default\n\t\t\t+ Copy\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ Debug\n\t\t\t+ FixedPointOperand;\n\n\t\t/// The reward pool ID type.\n\t\ttype PoolId: Parameter + Member + Clone + FullCodec;\n\n\t\ttype CurrencyId: Parameter + Member + Copy + MaybeSerializeDeserialize + Ord;\n\n\t\t/// The `RewardHandler`\n\t\ttype Handler: RewardHandler<Self::AccountId, Self::CurrencyId, Balance = Self::Balance, PoolId = Self::PoolId>;\n\t}\n\n\ttype WithdrawnRewards<T> = BTreeMap<<T as Config>::CurrencyId, <T as Config>::Balance>;\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Pool does not exist\n\t\tPoolDoesNotExist,\n\t\tShareDoesNotExist,\n\t\tCanSplitOnlyLessThanShare,\n\t}\n\n\t/// Record reward pool info.\n\t///\n\t/// map PoolId => PoolInfo\n\t#[pallet::storage]\n\t#[pallet::getter(fn pool_infos)]\n\tpub type PoolInfos<T: Config> =\n\t\tStorageMap<_, Twox64Concat, T::PoolId, PoolInfo<T::Share, T::Balance, T::CurrencyId>, ValueQuery>;\n\n\t/// Record share amount, reward currency and withdrawn reward amount for\n\t/// specific `AccountId` under `PoolId`.\n\t///\n\t/// double_map (PoolId, AccountId) => (Share, BTreeMap<CurrencyId, Balance>)\n\t#[pallet::storage]\n\t#[pallet::getter(fn shares_and_withdrawn_rewards)]\n\tpub type SharesAndWithdrawnRewards<T: Config> = StorageDoubleMap<\n\t\t_,\n\t\tTwox64Concat,\n\t\tT::PoolId,\n\t\tTwox64Concat,\n\t\tT::AccountId,\n\t\t(T::Share, WithdrawnRewards<T>),\n\t\tValueQuery,\n\t>;\n\n\t#[pallet::pallet]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet<T>(_);\n}\n\nimpl<T: Config> Pallet<T> {\n\tpub fn accumulate_reward(\n\t\tpool: &T::PoolId,\n\t\treward_currency: T::CurrencyId,\n\t\treward_increment: T::Balance,\n\t) -> DispatchResult {\n\t\tif reward_increment.is_zero() {\n\t\t\treturn Ok(());\n\t\t}\n\t\tPoolInfos::<T>::mutate_exists(pool, |maybe_pool_info| -> DispatchResult {\n\t\t\tlet pool_info = maybe_pool_info.as_mut().ok_or(Error::<T>::PoolDoesNotExist)?;\n\n\t\t\tpool_info\n\t\t\t\t.rewards\n\t\t\t\t.entry(reward_currency)\n\t\t\t\t.and_modify(|(total_reward, _)| {\n\t\t\t\t\t*total_reward = total_reward.saturating_add(reward_increment);\n\t\t\t\t})\n\t\t\t\t.or_insert((reward_increment, Zero::zero()));\n\n\t\t\tOk(())\n\t\t})\n\t}\n\n\tpub fn add_share(who: &T::AccountId, pool: &T::PoolId, add_amount: T::Share) {\n\t\tif add_amount.is_zero() {\n\t\t\treturn;\n\t\t}\n\n\t\tPoolInfos::<T>::mutate(pool, |pool_info| {\n\t\t\tlet initial_total_shares = pool_info.total_shares;\n\t\t\tpool_info.total_shares = pool_info.total_shares.saturating_add(add_amount);\n\n\t\t\tlet mut withdrawn_inflation = Vec::<(T::CurrencyId, T::Balance)>::new();\n\n\t\t\tpool_info\n\t\t\t\t.rewards\n\t\t\t\t.iter_mut()\n\t\t\t\t.for_each(|(reward_currency, (total_reward, total_withdrawn_reward))| {\n\t\t\t\t\tlet reward_inflation = if initial_total_shares.is_zero() {\n\t\t\t\t\t\tZero::zero()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tU256::from(add_amount.to_owned().saturated_into::<u128>())\n\t\t\t\t\t\t\t.saturating_mul(total_reward.to_owned().saturated_into::<u128>().into())\n\t\t\t\t\t\t\t.checked_div(initial_total_shares.to_owned().saturated_into::<u128>().into())\n\t\t\t\t\t\t\t.unwrap_or_default()\n\t\t\t\t\t\t\t.as_u128()\n\t\t\t\t\t\t\t.saturated_into()\n\t\t\t\t\t};\n\t\t\t\t\t*total_reward = total_reward.saturating_add(reward_inflation);\n\t\t\t\t\t*total_withdrawn_reward = total_withdrawn_reward.saturating_add(reward_inflation);\n\n\t\t\t\t\twithdrawn_inflation.push((*reward_currency, reward_inflation));\n\t\t\t\t});\n\n\t\t\tSharesAndWithdrawnRewards::<T>::mutate(pool, who, |(share, withdrawn_rewards)| {\n\t\t\t\t*share = share.saturating_add(add_amount);\n\t\t\t\t// update withdrawn inflation for each reward currency\n\t\t\t\twithdrawn_inflation\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.for_each(|(reward_currency, reward_inflation)| {\n\t\t\t\t\t\twithdrawn_rewards\n\t\t\t\t\t\t\t.entry(reward_currency)\n\t\t\t\t\t\t\t.and_modify(|withdrawn_reward| {\n\t\t\t\t\t\t\t\t*withdrawn_reward = withdrawn_reward.saturating_add(reward_inflation);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.or_insert(reward_inflation);\n\t\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tpub fn remove_share(who: &T::AccountId, pool: &T::PoolId, remove_amount: T::Share) {\n\t\tif remove_amount.is_zero() {\n\t\t\treturn;\n\t\t}\n\n\t\t// claim rewards firstly\n\t\tSelf::claim_rewards(who, pool);\n\n\t\tSharesAndWithdrawnRewards::<T>::mutate_exists(pool, who, |share_info| {\n\t\t\tif let Some((mut share, mut withdrawn_rewards)) = share_info.take() {\n\t\t\t\tlet remove_amount = remove_amount.min(share);\n\n\t\t\t\tif remove_amount.is_zero() {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPoolInfos::<T>::mutate_exists(pool, |maybe_pool_info| {\n\t\t\t\t\tif let Some(mut pool_info) = maybe_pool_info.take() {\n\t\t\t\t\t\tlet removing_share = U256::from(remove_amount.saturated_into::<u128>());\n\n\t\t\t\t\t\tpool_info.total_shares = pool_info.total_shares.saturating_sub(remove_amount);\n\n\t\t\t\t\t\t// update withdrawn rewards for each reward currency\n\t\t\t\t\t\twithdrawn_rewards\n\t\t\t\t\t\t\t.iter_mut()\n\t\t\t\t\t\t\t.for_each(|(reward_currency, withdrawn_reward)| {\n\t\t\t\t\t\t\t\tlet withdrawn_reward_to_remove: T::Balance = removing_share\n\t\t\t\t\t\t\t\t\t.saturating_mul(withdrawn_reward.to_owned().saturated_into::<u128>().into())\n\t\t\t\t\t\t\t\t\t.checked_div(share.saturated_into::<u128>().into())\n\t\t\t\t\t\t\t\t\t.unwrap_or_default()\n\t\t\t\t\t\t\t\t\t.as_u128()\n\t\t\t\t\t\t\t\t\t.saturated_into();\n\n\t\t\t\t\t\t\t\tif let Some((total_reward, total_withdrawn_reward)) =\n\t\t\t\t\t\t\t\t\tpool_info.rewards.get_mut(reward_currency)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t*total_reward = total_reward.saturating_sub(withdrawn_reward_to_remove);\n\t\t\t\t\t\t\t\t\t*total_withdrawn_reward =\n\t\t\t\t\t\t\t\t\t\ttotal_withdrawn_reward.saturating_sub(withdrawn_reward_to_remove);\n\n\t\t\t\t\t\t\t\t\t// remove if all reward is withdrawn\n\t\t\t\t\t\t\t\t\tif total_reward.is_zero() {\n\t\t\t\t\t\t\t\t\t\tpool_info.rewards.remove(reward_currency);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t*withdrawn_reward = withdrawn_reward.saturating_sub(withdrawn_reward_to_remove);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif !pool_info.total_shares.is_zero() {\n\t\t\t\t\t\t\t*maybe_pool_info = Some(pool_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tshare = share.saturating_sub(remove_amount);\n\t\t\t\tif !share.is_zero() {\n\t\t\t\t\t*share_info = Some((share, withdrawn_rewards));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpub fn set_share(who: &T::AccountId, pool: &T::PoolId, new_share: T::Share) {\n\t\tlet (share, _) = Self::shares_and_withdrawn_rewards(pool, who);\n\n\t\tif new_share > share {\n\t\t\tSelf::add_share(who, pool, new_share.saturating_sub(share));\n\t\t} else {\n\t\t\tSelf::remove_share(who, pool, share.saturating_sub(new_share));\n\t\t}\n\t}\n\n\tpub fn claim_rewards(who: &T::AccountId, pool: &T::PoolId) {\n\t\tSharesAndWithdrawnRewards::<T>::mutate_exists(pool, who, |maybe_share_withdrawn| {\n\t\t\tif let Some((share, withdrawn_rewards)) = maybe_share_withdrawn {\n\t\t\t\tif share.is_zero() {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPoolInfos::<T>::mutate_exists(pool, |maybe_pool_info| {\n\t\t\t\t\tif let Some(pool_info) = maybe_pool_info {\n\t\t\t\t\t\tlet total_shares = U256::from(pool_info.total_shares.to_owned().saturated_into::<u128>());\n\t\t\t\t\t\tpool_info.rewards.iter_mut().for_each(\n\t\t\t\t\t\t\t|(reward_currency, (total_reward, total_withdrawn_reward))| {\n\t\t\t\t\t\t\t\tSelf::claim_one(\n\t\t\t\t\t\t\t\t\twithdrawn_rewards,\n\t\t\t\t\t\t\t\t\t*reward_currency,\n\t\t\t\t\t\t\t\t\tshare.to_owned(),\n\t\t\t\t\t\t\t\t\ttotal_reward.to_owned(),\n\t\t\t\t\t\t\t\t\ttotal_shares,\n\t\t\t\t\t\t\t\t\ttotal_withdrawn_reward,\n\t\t\t\t\t\t\t\t\twho,\n\t\t\t\t\t\t\t\t\tpool,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tpub fn claim_reward(who: &T::AccountId, pool: &T::PoolId, reward_currency: T::CurrencyId) {\n\t\tSharesAndWithdrawnRewards::<T>::mutate_exists(pool, who, |maybe_share_withdrawn| {\n\t\t\tif let Some((share, withdrawn_rewards)) = maybe_share_withdrawn {\n\t\t\t\tif share.is_zero() {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPoolInfos::<T>::mutate(pool, |pool_info| {\n\t\t\t\t\tlet total_shares = U256::from(pool_info.total_shares.to_owned().saturated_into::<u128>());\n\t\t\t\t\tif let Some((total_reward, total_withdrawn_reward)) = pool_info.rewards.get_mut(&reward_currency) {\n\t\t\t\t\t\tSelf::claim_one(\n\t\t\t\t\t\t\twithdrawn_rewards,\n\t\t\t\t\t\t\treward_currency,\n\t\t\t\t\t\t\tshare.to_owned(),\n\t\t\t\t\t\t\ttotal_reward.to_owned(),\n\t\t\t\t\t\t\ttotal_shares,\n\t\t\t\t\t\t\ttotal_withdrawn_reward,\n\t\t\t\t\t\t\twho,\n\t\t\t\t\t\t\tpool,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/// Splits share into two parts.\n\t///\n\t/// `move_share` - amount of share to remove and put into `other` share\n\t/// `other` - new account who will own new share\n\t///\n\t/// Similar too claim and add 2 shares later, but does not requires pool\n\t/// inflation and is more efficient.\n\tpub fn transfer_share_and_rewards(\n\t\twho: &T::AccountId,\n\t\tpool: &T::PoolId,\n\t\tmove_share: T::Share,\n\t\tother: &T::AccountId,\n\t) -> DispatchResult {\n\t\tSharesAndWithdrawnRewards::<T>::mutate(pool, other, |increased_share| {\n\t\t\tlet (increased_share, increased_rewards) = increased_share;\n\t\t\tSharesAndWithdrawnRewards::<T>::mutate_exists(pool, who, |share| {\n\t\t\t\tlet (share, rewards) = share.as_mut().ok_or(Error::<T>::ShareDoesNotExist)?;\n\t\t\t\tensure!(move_share < *share, Error::<T>::CanSplitOnlyLessThanShare);\n\t\t\t\tfor (reward_currency, balance) in rewards {\n\t\t\t\t\t// u128 * u128 is always less than u256\n\t\t\t\t\t// move_share / share always less then 1 and share > 0\n\t\t\t\t\t// so final results is computable and is always less or equal than u128\n\t\t\t\t\tlet move_balance = U256::from(balance.to_owned().saturated_into::<u128>())\n\t\t\t\t\t\t* U256::from(move_share.to_owned().saturated_into::<u128>())\n\t\t\t\t\t\t/ U256::from(share.to_owned().saturated_into::<u128>());\n\t\t\t\t\tlet move_balance: Option<u128> = move_balance.try_into().ok();\n\t\t\t\t\tif let Some(move_balance) = move_balance {\n\t\t\t\t\t\tlet move_balance: T::Balance = move_balance.unique_saturated_into();\n\t\t\t\t\t\t*balance = balance.saturating_sub(move_balance);\n\t\t\t\t\t\tincreased_rewards\n\t\t\t\t\t\t\t.entry(*reward_currency)\n\t\t\t\t\t\t\t.and_modify(|increased_reward| {\n\t\t\t\t\t\t\t\t*increased_reward = increased_reward.saturating_add(move_balance);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.or_insert(move_balance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*share = share.saturating_sub(move_share);\n\t\t\t\t*increased_share = increased_share.saturating_add(move_share);\n\t\t\t\tOk(())\n\t\t\t})\n\t\t})\n\t}\n\n\t#[allow(clippy::too_many_arguments)] // just we need to have all these to do the stuff\n\tfn claim_one(\n\t\twithdrawn_rewards: &mut BTreeMap<T::CurrencyId, T::Balance>,\n\t\treward_currency: T::CurrencyId,\n\t\tshare: T::Share,\n\t\ttotal_reward: T::Balance,\n\t\ttotal_shares: U256,\n\t\ttotal_withdrawn_reward: &mut T::Balance,\n\t\twho: &T::AccountId,\n\t\tpool: &T::PoolId,\n\t) {\n\t\tlet withdrawn_reward = withdrawn_rewards.get(&reward_currency).copied().unwrap_or_default();\n\t\tlet reward_to_withdraw = Self::reward_to_withdraw(\n\t\t\tshare,\n\t\t\ttotal_reward,\n\t\t\ttotal_shares,\n\t\t\twithdrawn_reward,\n\t\t\ttotal_withdrawn_reward.to_owned(),\n\t\t);\n\t\tif !reward_to_withdraw.is_zero() {\n\t\t\t*total_withdrawn_reward = total_withdrawn_reward.saturating_add(reward_to_withdraw);\n\t\t\twithdrawn_rewards.insert(reward_currency, withdrawn_reward.saturating_add(reward_to_withdraw));\n\n\t\t\t// pay reward to `who`\n\t\t\tT::Handler::payout(who, pool, reward_currency, reward_to_withdraw);\n\t\t}\n\t}\n\n\tfn reward_to_withdraw(\n\t\tshare: T::Share,\n\t\ttotal_reward: T::Balance,\n\t\ttotal_shares: U256,\n\t\twithdrawn_reward: T::Balance,\n\t\ttotal_withdrawn_reward: T::Balance,\n\t) -> T::Balance {\n\t\tlet total_reward_proportion: T::Balance = U256::from(share.saturated_into::<u128>())\n\t\t\t.saturating_mul(U256::from(total_reward.saturated_into::<u128>()))\n\t\t\t.checked_div(total_shares)\n\t\t\t.unwrap_or_default()\n\t\t\t.as_u128()\n\t\t\t.unique_saturated_into();\n\t\ttotal_reward_proportion\n\t\t\t.saturating_sub(withdrawn_reward)\n\t\t\t.min(total_reward.saturating_sub(total_withdrawn_reward))\n\t}\n}"
    }
  ]
}