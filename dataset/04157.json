{
  "Title": "[L01] Transfer may fail",
  "Content": "The `UniERC20` contract [performs a low-level `transfer`](https://github.com/1inch-exchange/1inch-v2-contracts/blob/72f2812837fdd73ec2d32c8988811df361e80985/contracts/helpers/UniERC20.sol#L32) to send ETH. This has some notable shortcomings when the recipient is a smart contract. Specifically, the transfer will fail when:\n\n\n* the withdrawer smart contract does not implement a payable fallback or receive function\n* the smart contract implements a payable fallback function that uses more than 2300 gas, potentially due to a proxy that increases the call’s gas usage.\n\n\nTo prevent unexpected behavior, consider explicitly warning users about these shortcomings. Additionally, note that the [`sendValue` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/utils/Address.sol#L63) available in OpenZeppelin Contract’s `Address` library can be used to transfer Ether without being limited to 2300 gas units. Risks of reentrancy stemming from the use of this function can be mitigated by tightly following the [“Check-effects-interactions” pattern](https://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern) and using OpenZeppelin Contract’s [`ReentrancyGuard` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/utils/ReentrancyGuard.sol). For further reference on why using Solidity’s `transfer` is no longer recommended, refer to these articles:\n\n\n* [Stop using Solidity’s transfer now](https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/)\n* [Reentrancy after Istanbul](https://blog.openzeppelin.com/reentrancy-after-istanbul/)\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/helpers/UniERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n\nlibrary UniERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    IERC20 private constant _ZERO_ADDRESS = IERC20(0);\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\n    }\n\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\n        if (isETH(token)) {\n            return account.balance;\n        } else {\n            return token.balanceOf(account);\n        }\n    }\n\n    function uniTransfer(IERC20 token, address payable to, uint256 amount) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                to.transfer(amount);\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    function uniApprove(IERC20 token, address to, uint256 amount) internal {\n        require(!isETH(token), \"Approve called on ETH\");\n\n        if (amount == 0) {\n            token.safeApprove(to, 0);\n        } else {\n            uint256 allowance = token.allowance(address(this), to);\n            if (allowance < amount) {\n                if (allowance > 0) {\n                    token.safeApprove(to, 0);\n                }\n                token.safeApprove(to, amount);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/utils/Address.sol",
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}"
    }
  ]
}