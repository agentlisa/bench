{
  "Title": "[M-07] `boreWell` can be frontrun/DoS-d",
  "Content": "\nThe `boreWell` function in the Aquifer contract is responsible for creating new Wells. However, there are two critical security issues:\n\n1.  **Stealing of user's deposit amount**: The public readability of the `salt` parameter allows an attacker to frontrun a user's transaction and capture the deposit amount intended for the user's Well. By creating a Well with the same `salt` value, the attacker can receive the deposit intended for the user's Well and withdraw the funds.\n2.  **DoS for `boreWell`**: Another attack vector involves an attacker deploying a Well with the same `salt` value as the user's intended Well. This causes the user's transaction to be reverted, resulting in a denial-of-service (DoS) attack on the `boreWell` function. The attacker can repeatedly execute this attack, preventing users from creating new Wells.\n\n## Proof of Concept\n\n### Stealing of user's deposit amount\n\nIf a user intends to create a new Well and deposit funds into it, an attacker can frontrun the user's transactions and capture the deposit amount. Here is how the attack scenario unfolds:\n\n1.  The user broadcasts two transactions: the first to create a Well with a specific `salt` value, and the second to deposit funds into the newly created Well.\n2.  The attacker views these pending transactions and frontruns them by creating a Well for themselves using the same `salt` value.\n3.  The attacker's Well gets created with the same address that the user was expecting for their Well.\n4.  As a result, the user's create Well transaction gets reverted, but the deposit transaction successfully executes, depositing the funds into the attacker's Well.\n5.  Being the owner of the Well, the attacker can simply withdraw the deposited funds from the Well.\n\n### DoS for `boreWell`\n\nIn this attack scenario, an attacker can forcefully revert a user's create Well transaction by deploying a Well for themselves using the user's `salt` value. Here are the steps of the attack:\n\n1.  The user broadcasts a create Well transaction with a specific `salt` value.\n2.  The attacker frontruns the user's transaction and creates a Well for themselves using the same `salt` value.\n3.  As a result, the user's original create Well transaction gets reverted since the attacker's Well already exists at the predetermined address.\n4.  This attack can be repeated multiple times, effectively causing a denial-of-service (DoS) attack on the boreWell function.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nTo mitigate the identified security issues, it is recommended to make the upcoming Well address user-specific by combining the `salt` value with the user's address. This ensures that each user's Well has a unique address and prevents frontrunning attacks and DoS attacks. The following code snippet demonstrates the recommended modification:\n\n```\nwell = implementation.cloneDeterministic(\n    keccak256(abi.encode(msg.sender, `salt`))\n);\n\n```\n\n**[publiuss (Basin) confirmed and commented](https://github.com/code-423n4/2023-07-basin-findings/issues/181#issuecomment-1689101090):**\n > This issue has been addressed in the code. The `boreWell(...)` function now uses a `salt` consisting of the hash of `msg.sender` appended to the input `salt` value. \n >\n >See [here](https://github.com/BeanstalkFarms/Basin/blob/91233a22005986aa7c9f3b0c67393842cd8a8e4d/src/Aquifer.sol#L40).\n> \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/Aquifer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {ReentrancyGuard} from \"oz/security/ReentrancyGuard.sol\";\n\nimport {IAquifer} from \"src/interfaces/IAquifer.sol\";\nimport {IWell} from \"src/Well.sol\";\nimport {LibClone} from \"src/libraries/LibClone.sol\";\n\n/**\n * @title Aquifer\n * @author Publius, Silo Chad, Brean\n * @notice Aquifer is a permissionless Well registry and factory.\n * @dev Aquifer deploys Wells by cloning a pre-deployed Well implementation.\n */\ncontract Aquifer is IAquifer, ReentrancyGuard {\n    using LibClone for address;\n\n    // A mapping of Well address to the Well implementation addresses\n    // Mapping gets set on Well deployment\n    mapping(address => address) public wellImplementation;\n\n    constructor() ReentrancyGuard() {}\n\n    /**\n     * @dev\n     * Use `salt == 0` to deploy a new Well with `create`\n     * Use `salt > 0` to deploy a new Well with `create2`\n     */\n    function boreWell(\n        address implementation,\n        bytes calldata immutableData,\n        bytes calldata initFunctionCall,\n        bytes32 salt\n    ) external nonReentrant returns (address well) {\n        if (immutableData.length > 0) {\n            if (salt != bytes32(0)) {\n                // Encode the salt with the `msg.sender` address to prevent frontrunning attack\n                salt = keccak256(abi.encode(msg.sender, salt));\n                well = implementation.cloneDeterministic(immutableData, salt);\n            } else {\n                well = implementation.clone(immutableData);\n            }\n        } else {\n            if (salt != bytes32(0)) {\n                // Encode the salt with the `msg.sender` address to prevent frontrunning attack\n                salt = keccak256(abi.encode(msg.sender, salt));\n                well = implementation.cloneDeterministic(salt);\n            } else {\n                well = implementation.clone();\n            }\n        }\n\n        if (initFunctionCall.length > 0) {\n            (bool success, bytes memory returnData) = well.call(initFunctionCall);\n            if (!success) {\n                // Next 5 lines are based on https://ethereum.stackexchange.com/a/83577\n                if (returnData.length < 68) revert InitFailed(\"\");\n                assembly {\n                    returnData := add(returnData, 0x04)\n                }\n                revert InitFailed(abi.decode(returnData, (string)));\n            }\n        }\n\n        if (!IWell(well).isInitialized()) {\n            revert WellNotInitialized();\n        }\n\n        // The Aquifer address MUST be set, either (a) via immutable data during cloning,\n        // or (b) as a storage variable during an init function call. In either case,\n        // the address MUST match the address of the Aquifer that performed deployment.\n        if (IWell(well).aquifer() != address(this)) {\n            revert InvalidConfig();\n        }\n\n        // Save implementation\n        wellImplementation[well] = implementation;\n\n        emit BoreWell(\n            well,\n            implementation,\n            IWell(well).tokens(),\n            IWell(well).wellFunction(),\n            IWell(well).pumps(),\n            IWell(well).wellData()\n        );\n    }\n\n    function predictWellAddress(\n        address implementation,\n        bytes calldata immutableData,\n        bytes32 salt\n    ) external view returns (address well) {\n        // Aquifer doesn't support using a salt of 0 to deploy a Well at a deterministic address.\n        if (salt == bytes32(0)) {\n            revert InvalidSalt();\n        }\n        salt = keccak256(abi.encode(msg.sender, salt));\n        if (immutableData.length > 0) {\n            well = implementation.predictDeterministicAddress(immutableData, salt, address(this));\n        } else {\n            well = implementation.predictDeterministicAddress(salt, address(this));\n        }\n    }\n}"
    }
  ]
}