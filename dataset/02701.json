{
  "Title": "M-1: Flashloan `TEL` tokens to stake and exit in the same block can fake a huge amount of stake with minimal material cost",
  "Content": "# Issue M-1: Flashloan `TEL` tokens to stake and exit in the same block can fake a huge amount of stake with minimal material cost \n\nSource: https://github.com/sherlock-audit/2022-11-telcoin-judging/issues/83 \n\n## Found by \nWATCHPUG\n\n## Summary\n\n`Checkpoints#getAtBlock()` can be faked with falshloan as it may return the value of the first checkpoint in the same block.\n\n## Vulnerability Detail\n\n`Checkpoints#getAtBlock()` will return the value on check point #0 when there are two check points in the same block (#0 and #1).\n\nTherefore, one can take a falshloan of TEL tokens to stake and exit in the same block, which will create two checkpoints.\n\n## Impact\n\nMalicious user can fake their stake to gain a high percentage rewards with falshloan and avoid slashing.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/StakingModule.sol#L147-L149\n\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/StakingModule.sol#L403-L406\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider requiring the `exit` to be at least 1 block later than the blocknumber of the original stake.\n\n## Discussion\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-staking/pull/9\n\n**dmitriia**\n\nEscalate for 30 USDC\nI apologize if missed some point, but how this can be used to drain funds from the protocol?\n\nstakedByAt  is used only at balanceOfAt():\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/StakingModule.sol#L98-L104\n\nWhich is stand-alone view function:\nhttps://github.com/sherlock-audit/2022-11-telcoin/search?q=balanceOfAt\n\n\nSlashing example is clear, but it uses latest(), not stakedByAt():\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/StakingModule.sol#L403-L406\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/StakingModule.sol#L356-L360\n\nFor the latest() Checkpoints will return the latest entry, after the flash loan:\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/CheckpointsUpgradeable.sol#L94-L100\n\nI.e. if an attacker front-run the slashing, his flashloan will be finished when slashing run and the latest, small, entry will be used in claiming.\n\nAm I missing something here?\n\nIf not the severity should be Med as view function is impacted, which can backfire downstream, but that's an assumption typically meaning downgrading the severity.\n\n**sherlock-admin**\n\n > Escalate for 30 USDC\n> I apologize if missed some point, but how this can be used to drain funds from the protocol?\n> \n> stakedByAt  is used only at balanceOfAt():\n> https://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/StakingModule.sol#L98-L104\n> \n> Which is stand-alone view function:\n> https://github.com/sherlock-audit/2022-11-telcoin/search?q=balanceOfAt\n> \n> \n> Slashing example is clear, but it uses latest(), not stakedByAt():\n> https://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/StakingModule.sol#L403-L406\n> https://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/StakingModule.sol#L356-L360\n> \n> For the latest() Checkpoints will return the latest entry, after the flash loan:\n> https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/CheckpointsUpgradeable.sol#L94-L100\n> \n> I.e. if an attacker front-run the slashing, his flashloan will be finished when slashing run and the latest, small, entry will be used in claiming.\n> \n> Am I missing something here?\n> \n> If not the severity should be Med as view function is impacted, which can backfire downstream, but that's an assumption typically meaning downgrading the severity.\n\nYou've created a valid escalation for 30 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted \n\nAfter consulting with the sponsors, judges took a deep dive on the issue and decided to make this a medium severity.\n\n**sherlock-admin**\n\n> Escalation accepted \n> \n> After consulting with the sponsors, judges took a deep dive on the issue and decided to make this a medium severity.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**jack-the-pug**\n\nFix confirmed\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/25",
  "Code": [
    {
      "filename": "contracts/StakingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol\";\n\nimport \"./interfaces/IPlugin.sol\";\n\n// TODO: improve require messages\n\n/// @title Staking Module\n/// @notice Users interact directly with this contract to participate in staking. \n/// @dev This contract holds user funds. It does not accrue any staking yield on its own, it must have one or more `IPlugin` contracts \"connected\" to it.\ncontract StakingModule is ReentrancyGuardUpgradeable, AccessControlEnumerableUpgradeable, PausableUpgradeable {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.History;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice This role grants the ability to slash users' stakes at its own discretion\n    bytes32 public constant SLASHER_ROLE = keccak256(\"SLASHER_ROLE\");\n    /// @notice This role grants the ability to add and remove IPlugin contracts\n    bytes32 public constant PLUGIN_EDITOR_ROLE = keccak256(\"PLUGIN_EDITOR_ROLE\");\n    /// @notice This role grants the ability to pause all unrestricted external functions in an emergency situation\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    /// @notice This role grants the ability to rescue ERC20 tokens that do not rightfully belong to this contract\n    bytes32 public constant RECOVERY_ROLE = keccak256(\"RECOVERY_ROLE\");\n\n    /// @notice TEL ERC20 address\n    address public tel;\n\n    /// @notice Array of all connected IPlugin contracts\n    address[] public plugins;\n\n    /// @notice Number of currently connected Plugins\n    uint256 public nPlugins;\n\n    /// @notice Maps a Plugin to whether or not it is included in `plugins`\n    /// @dev This allows duplicate plugins to be prevented\n    mapping(address => bool) public pluginsMapping;\n\n    /// @notice Total TEL staked by users in this contract\n    uint256 private _totalStaked;\n    /// @notice Maps an account to its staked amount history\n    mapping(address => CheckpointsUpgradeable.History) private _stakes;\n\n    /// @notice An event that's emitted when a account's stake changes (deposit/withdraw/slash)\n    event StakeChanged(address indexed account, uint256 oldStake, uint256 newStake);\n    /// @notice An event that's emitted when an account claims some yield\n    event Claimed(address indexed account, uint256 amount);\n    /// @notice An event that's emitted when an account's stake is slashed\n    event Slashed(address indexed account, uint256 amount);\n\n    /// @notice An event that's emitted when a plugin is added\n    event PluginAdded(address indexed plugin, uint256 nPlugins);\n    /// @notice An event that's emitted when a plugin is removed\n    event PluginRemoved(address indexed plugin, uint256 nPlugins);\n\n    function initialize(address _telAddress) public payable initializer {\n        tel = _telAddress;\n\n        // initialize OZ stuff\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained();\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init_unchained();\n        PausableUpgradeable.__Pausable_init_unchained();\n\n        // set deployer as ADMIN\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n    *   view functions\n    ************************************************/\n\n    /// @dev For some future Plugins not yet ideated, totalClaimable may be hard or impossible to implement. \n    /// @dev This would break `totalSupply`, but `totalSupply` is not strictly necessary anyway.\n    /// @return Total supply of staked TEL, including all yield\n    function totalSupply() external view returns (uint256) {\n        uint256 total;\n\n        // loop over all plugins and sum up totalClaimable\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).totalClaimable();\n        }\n        \n        // totalSupply is the total claimable from all plugins plus the total amount staked\n        return total + _totalStaked;\n    }\n\n    /// @return Balance of an account. This includes stake and claimable yield.\n    /// @param account Account to query balance of\n    /// @param auxData Auxiliary data to pass to plugins\n    function balanceOf(address account, bytes calldata auxData) public view returns (uint256) {\n        return _stakes[account].latest() + claimable(account, auxData);\n    }\n\n    /// @return Balance of an account at a specific block. This includes stake and claimable yield.\n    /// @param account Account to query balance of\n    /// @param blockNumber Block at which to query balance\n    /// @param auxData Auxiliary data to pass to plugins\n    function balanceOfAt(address account, uint256 blockNumber, bytes calldata auxData) external view returns (uint256) {\n        return stakedByAt(account, blockNumber) + claimableAt(account, blockNumber, auxData);\n    }\n\n    /// @return Total amount staked by all accounts\n    function totalStaked() external view returns (uint256) {\n        return _totalStaked;\n    }\n\n    /// @dev Checks `claimable(account)` of all Plugins and returns the total.\n    /// @param account Account to query balance of\n    /// @param auxData Auxiliary data to pass to plugins\n    /// @return Total amount claimable by an account\n    function claimable(address account, bytes calldata auxData) public view returns (uint256) {\n        uint256 total;\n        // loop over all plugins, sum claimable of account\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).claimable(account, auxData);\n        }\n        return total;\n    }\n\n    /// @dev Checks `claimableAt(account, blockNumber)` of all Plugins.\n    /// @param account Account to query claimable amount\n    /// @param blockNumber Block at which to query claimable amount\n    /// @param auxData Auxiliary data to pass to plugins\n    /// @return Total amount claimable by an account at a specific block number.\n    function claimableAt(address account, uint256 blockNumber, bytes calldata auxData) public view returns (uint256) {\n        uint256 total;\n        // loop over all plugins, sum claimableAt of account\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).claimableAt(account, blockNumber, auxData);\n        }\n        return total;\n    }\n\n    /// @return Amount staked by an account. This does not include claimable yield from plugins.\n    /// @param account Account to query staked amount\n    function stakedBy(address account) external view returns (uint256) {\n        return _stakes[account].latest();\n    }\n\n    /// @return Amount staked by an account at a specific block number excluding claimable yield.\n    /// @param account Account to query staked amount\n    /// @param blockNumber Block at which to query staked amount\n    function stakedByAt(address account, uint256 blockNumber) public view returns (uint256) {\n        return _stakes[account].getAtBlock(blockNumber);\n    }\n\n    /************************************************\n    *   external mutative functions\n    ************************************************/\n\n    /// @notice Stakes some amount of TEL to earn potential rewards.\n    /// @param amount Amount to stake\n    function stake(uint256 amount) external whenNotPaused nonReentrant {\n        _stake({\n            account: msg.sender, \n            from: msg.sender, \n            amount: amount\n        });\n    }\n\n    /// @notice Withdraws staked TEL, does not claim any yield.\n    /// @return Amount withdrawn\n    function exit() external whenNotPaused nonReentrant returns (uint256) {\n        return _exit({\n            account: msg.sender, \n            to: msg.sender\n        });\n    }\n\n    /// @notice Claims yield from an individual plugin and sends it to calling account.\n    /// @param pluginIndex Index of desired plugin\n    /// @param auxData Auxiliary data for the plugin\n    /// @return Amount claimed\n    function claimFromIndividualPlugin(uint256 pluginIndex, bytes calldata auxData) external whenNotPaused nonReentrant returns (uint256) {\n        return _claimFromIndividualPlugin({\n            account: msg.sender, \n            to: msg.sender, \n            pluginIndex: pluginIndex, \n            auxData: auxData\n        });\n    }\n\n    /// @notice Claims yield from all plugins and sends it to calling account.\n    /// @param auxData Auxiliary data for the plugins\n    /// @return Amount claimed\n    function claim(bytes calldata auxData) external whenNotPaused nonReentrant returns (uint256) {\n        return _claim({\n            account: msg.sender, \n            to: msg.sender, \n            auxData: auxData\n        });\n    }\n\n    /// @notice Claims all yield and withdraws all stake.\n    /// @param auxData Auxiliary data for the plugins\n    /// @return Amount claimed\n    /// @return Amount withdrawn\n    function fullClaimAndExit(bytes calldata auxData) external whenNotPaused nonReentrant returns (uint256, uint256) {\n        return (\n            _claim({ account: msg.sender, to: msg.sender, auxData: auxData }), \n            _exit(msg.sender, msg.sender)\n        );\n    }\n\n    /// @notice Claims yield and withdraws some of stake.\n    /// @param amount Amount to withdraw\n    /// @param auxData Auxiliary data for the plugins\n    function partialClaimAndExit(uint256 amount, bytes calldata auxData) external whenNotPaused nonReentrant {\n        _claimAndExit({\n            account: msg.sender, \n            amount: amount, \n            to: msg.sender,\n            auxData: auxData\n        });\n    }\n\n    \n\n    /************************************************\n    *   private mutative functions\n    ************************************************/\n\n    /// @notice Claims earned yield from an individual plugin\n    /// @param account Account to claim on behalf of.\n    /// @param to Address to send the claimed yield to.\n    /// @param pluginIndex Index of the desired plugin to claim from\n    /// @dev Calls `claim` on the desired plugin\n    /// @dev Checks to make sure the amount of tokens the plugins sent matches what the `claim` functions returned. (Probably unnecessary)\n    /// @return Amount claimed\n    function _claimFromIndividualPlugin(address account, address to, uint256 pluginIndex, bytes calldata auxData) private returns (uint256) {\n        require(pluginIndex < nPlugins, \"StakingModule::_claimFromIndividualPlugin: Provided pluginIndex is out of bounds\");\n        \n        // balance of `to` before claiming\n        uint256 balBefore = IERC20Upgradeable(tel).balanceOf(to);\n\n        // xClaimed = \"amount of TEL claimed from the plugin\"\n        uint256 xClaimed = IPlugin(plugins[pluginIndex]).claim(account, to, auxData);\n\n        // we want to make sure the plugin did not return the wrong amount\n        require(IERC20Upgradeable(tel).balanceOf(to) - balBefore == xClaimed, \"The plugin did not send appropriate token amount\");\n\n        // only emit Claimed if anything was actually claimed\n        if (xClaimed > 0) {\n            emit Claimed(account, xClaimed);\n        }\n\n        return xClaimed;\n    }\n\n    /// @notice Claims earned yield\n    /// @param account Account to claim on behalf of.\n    /// @param to Address to send the claimed yield to.\n    /// @param auxData Auxiliary data for the plugins\n    /// @dev Iterates over all plugins and calls `claim`\n    /// @dev Checks to make sure the amount of tokens the plugins sent matches what the `claim` functions returned.\n    /// @dev If amount claimed is >0, emit Claimed\n    /// @return Amount claimed\n    function _claim(address account, address to, bytes calldata auxData) private returns (uint256) {\n        // balance of `to` before claiming\n        uint256 balBefore = IERC20Upgradeable(tel).balanceOf(to);\n\n        // call claim on all plugins and count the total amount claimed\n        uint256 total;\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).claim(account, to, auxData);\n        }\n\n        // make sure `total` actually matches how much we've claimed\n        require(IERC20Upgradeable(tel).balanceOf(to) - balBefore == total, \"one or more plugins did not send appropriate token amount\");\n\n        // only emit Claimed if anything was actually claimed\n        if (total > 0) {\n            emit Claimed(account, total);\n        }\n\n        return total;\n    }\n\n    /// @notice Withdraws staked TEL to the specified `to` address, does not claim any yield.\n    /// @dev Notifies all plugins that account's stake is changing.\n    /// @dev Writes _stakes checkpoint. \n    /// @dev Decrements _totalStaked\n    /// @dev Transfers TEL\n    /// @dev Emits StakeChanged.\n    /// @param account Account to exit on behalf of.\n    /// @param to Address to send the withdrawn balance to.\n    /// @return Amount withdrawn\n    function _exit(address account, address to) private returns (uint256) {\n        uint256 amt = _stakes[account].latest();\n\n        if (amt == 0) {\n            return 0;\n        }\n\n        // notify plugins\n        _notifyStakeChangeAllPlugins(account, amt, 0);\n\n        // update checkpoints\n        _stakes[account].push(0);\n\n        // update _totalStaked\n        _totalStaked -= amt;\n\n        // move the tokens\n        IERC20Upgradeable(tel).safeTransfer(to, amt);\n\n        emit StakeChanged(account, amt, 0);\n\n        return amt;\n    }\n\n    /// @notice Stakes some amount of TEL to earn potential rewards.\n    /// @dev Notifies all plugins that account's stake is changing.\n    /// @dev Updates _stakes[account]\n    /// @dev Increments _totalStaked\n    /// @dev Transfers TEL\n    /// @dev Emits StakeChanged.\n    /// @param account Account to stake on behalf of\n    /// @param from Address to pull TEL from\n    /// @param amount Amount to stake\n    function _stake(address account, address from, uint256 amount) private {\n        require(amount > 0, \"Cannot stake 0\");\n\n        uint256 stakedBefore = _stakes[account].latest();\n        uint256 stakedAfter = stakedBefore + amount;\n\n        // notify plugins\n        _notifyStakeChangeAllPlugins(account, stakedBefore, stakedAfter);\n        \n        // update _stakes\n        _stakes[account].push(stakedAfter);\n\n        // update _totalStaked\n        _totalStaked += amount;\n\n        // move the tokens\n        IERC20Upgradeable(tel).safeTransferFrom(from, address(this), amount);\n\n        emit StakeChanged(account, stakedBefore, stakedAfter);\n    }\n\n    /// @notice Claims yield and withdraws some of stake. Everything leftover remains staked\n    /// @param account account\n    /// @param amount amount to withdraw\n    /// @param to account to send withdrawn funds to\n    /// @dev The yield of the account is claimed to this contract\n    /// @dev Call `notifyStakeChange` on all plugins\n    /// @dev Update _stakes[account]\n    /// @dev Update _totalStaked\n    /// @dev Transfer `amount` of tokens to `to`\n    /// @dev Emit StakeChanged\n    function _claimAndExit(address account, uint256 amount, address to, bytes calldata auxData) private {\n        require(amount <= balanceOf(account, auxData), \"Account has insufficient balance\");\n\n        // keep track of initial stake\n        uint256 oldStake = _stakes[account].latest();\n        // xClaimed = total amount claimed\n        uint256 xClaimed = _claim(account, address(this), auxData);\n\n        uint256 newStake = oldStake + xClaimed - amount;\n\n        // notify all plugins that account's stake has changed (if the plugin requires)\n        _notifyStakeChangeAllPlugins(account, oldStake, newStake);\n\n        // update _stakes\n        _stakes[account].push(newStake);\n\n        // decrement _totalStaked\n        _totalStaked = _totalStaked - oldStake + newStake;\n\n        // transfer the tokens to `to`\n        IERC20Upgradeable(tel).safeTransfer(to, amount);\n\n        emit StakeChanged(account, oldStake, newStake);\n    }\n\n    /// @dev Calls `notifyStakeChange` on all plugins that require it. This is done in case any given plugin needs to do some stuff when a user exits.\n    /// @param account Account that is exiting\n    function _notifyStakeChangeAllPlugins(address account, uint256 amountBefore, uint256 amountAfter) private {\n        // loop over all plugins\n        for (uint256 i = 0; i < nPlugins; i++) {\n            // only notify if the plugin requires\n            // if (IPlugin(plugins[i]).requiresNotification()) {\n                IPlugin(plugins[i]).notifyStakeChange(account, amountBefore, amountAfter);\n            // }\n        }\n    }\n\n\n    /************************************************\n    *   restricted functions\n    ************************************************/\n\n    /// @notice Slashes stake of an account.\n    /// @notice Only those holding the `SLASHER_ROLE` may call this.\n    /// @param account account to slash\n    /// @param amount amount to slash\n    /// @param to account to send slashed funds to\n    function slash(address account, uint amount, address to, bytes calldata auxData) external onlyRole(SLASHER_ROLE) nonReentrant {\n        _claimAndExit(account, amount, to, auxData);\n        emit Slashed(account, amount);\n    }\n\n    /// @notice Adds a new plugin\n    function addPlugin(address plugin) external onlyRole(PLUGIN_EDITOR_ROLE) {\n        require(!pluginsMapping[plugin], \"StakingModule::addPlugin: Cannot add an existing plugin\");\n\n        plugins.push(plugin);\n        pluginsMapping[plugin] = true;\n        nPlugins++;\n\n        emit PluginAdded(plugin, nPlugins);\n    }\n\n    /// @notice Removes a plugin\n    function removePlugin(uint256 index) external onlyRole(PLUGIN_EDITOR_ROLE) {\n        address plugin = plugins[index];\n\n        pluginsMapping[plugin] = false;\n        plugins[index] = plugins[nPlugins - 1];\n        plugins.pop();\n        nPlugins--;\n\n        emit PluginRemoved(plugin, nPlugins);\n    }\n\n    /// @notice Pause all unrestricted external functions\n    function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    /// @notice Unpause all unrestricted external functions\n    function unpause() external onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    /// @notice rescues any stuck erc20\n    /// @dev if the token is TEL, then it only allows maximum of balanceOf(this) - _totalStaked to be rescued\n    function rescueTokens(IERC20Upgradeable token, address to) external onlyRole(RECOVERY_ROLE) {\n        if (address(token) == tel) {\n            // if the token is TEL, only remove the extra amount that isn't staked\n            token.safeTransfer(to, token.balanceOf(address(this)) - _totalStaked);\n        }\n        else {\n            // if the token isn't TEL, remove all of it\n            token.safeTransfer(to, token.balanceOf(address(this)));\n        }\n    }\n\n    /// @notice claim and exit on behalf of a user\n    /// @dev This function is in case of a token migration\n    /// @dev We know this would be insanely gas intensive if there are a lot of users\n    function claimAndExitFor(address account, address to, bytes calldata auxData) external onlyRole(RECOVERY_ROLE) whenPaused nonReentrant returns (uint256, uint256) {\n        return (_claim(account, to, auxData), _exit(account, to));\n    }\n\n    /// @notice stake on behalf of a user\n    /// @dev This function is in case of a token migration\n    /// @dev We know this would be insanely gas intensive if there are a lot of users\n    function stakeFor(address account, uint256 amount) external onlyRole(RECOVERY_ROLE) whenPaused nonReentrant {\n        _stake(account, msg.sender, amount);\n    }\n}"
    },
    {
      "filename": "contracts/StakingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol\";\n\nimport \"./interfaces/IPlugin.sol\";\n\n// TODO: improve require messages\n\n/// @title Staking Module\n/// @notice Users interact directly with this contract to participate in staking. \n/// @dev This contract holds user funds. It does not accrue any staking yield on its own, it must have one or more `IPlugin` contracts \"connected\" to it.\ncontract StakingModule is ReentrancyGuardUpgradeable, AccessControlEnumerableUpgradeable, PausableUpgradeable {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.History;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice This role grants the ability to slash users' stakes at its own discretion\n    bytes32 public constant SLASHER_ROLE = keccak256(\"SLASHER_ROLE\");\n    /// @notice This role grants the ability to add and remove IPlugin contracts\n    bytes32 public constant PLUGIN_EDITOR_ROLE = keccak256(\"PLUGIN_EDITOR_ROLE\");\n    /// @notice This role grants the ability to pause all unrestricted external functions in an emergency situation\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    /// @notice This role grants the ability to rescue ERC20 tokens that do not rightfully belong to this contract\n    bytes32 public constant RECOVERY_ROLE = keccak256(\"RECOVERY_ROLE\");\n\n    /// @notice TEL ERC20 address\n    address public tel;\n\n    /// @notice Array of all connected IPlugin contracts\n    address[] public plugins;\n\n    /// @notice Number of currently connected Plugins\n    uint256 public nPlugins;\n\n    /// @notice Maps a Plugin to whether or not it is included in `plugins`\n    /// @dev This allows duplicate plugins to be prevented\n    mapping(address => bool) public pluginsMapping;\n\n    /// @notice Total TEL staked by users in this contract\n    uint256 private _totalStaked;\n    /// @notice Maps an account to its staked amount history\n    mapping(address => CheckpointsUpgradeable.History) private _stakes;\n\n    /// @notice An event that's emitted when a account's stake changes (deposit/withdraw/slash)\n    event StakeChanged(address indexed account, uint256 oldStake, uint256 newStake);\n    /// @notice An event that's emitted when an account claims some yield\n    event Claimed(address indexed account, uint256 amount);\n    /// @notice An event that's emitted when an account's stake is slashed\n    event Slashed(address indexed account, uint256 amount);\n\n    /// @notice An event that's emitted when a plugin is added\n    event PluginAdded(address indexed plugin, uint256 nPlugins);\n    /// @notice An event that's emitted when a plugin is removed\n    event PluginRemoved(address indexed plugin, uint256 nPlugins);\n\n    function initialize(address _telAddress) public payable initializer {\n        tel = _telAddress;\n\n        // initialize OZ stuff\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained();\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init_unchained();\n        PausableUpgradeable.__Pausable_init_unchained();\n\n        // set deployer as ADMIN\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n    *   view functions\n    ************************************************/\n\n    /// @dev For some future Plugins not yet ideated, totalClaimable may be hard or impossible to implement. \n    /// @dev This would break `totalSupply`, but `totalSupply` is not strictly necessary anyway.\n    /// @return Total supply of staked TEL, including all yield\n    function totalSupply() external view returns (uint256) {\n        uint256 total;\n\n        // loop over all plugins and sum up totalClaimable\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).totalClaimable();\n        }\n        \n        // totalSupply is the total claimable from all plugins plus the total amount staked\n        return total + _totalStaked;\n    }\n\n    /// @return Balance of an account. This includes stake and claimable yield.\n    /// @param account Account to query balance of\n    /// @param auxData Auxiliary data to pass to plugins\n    function balanceOf(address account, bytes calldata auxData) public view returns (uint256) {\n        return _stakes[account].latest() + claimable(account, auxData);\n    }\n\n    /// @return Balance of an account at a specific block. This includes stake and claimable yield.\n    /// @param account Account to query balance of\n    /// @param blockNumber Block at which to query balance\n    /// @param auxData Auxiliary data to pass to plugins\n    function balanceOfAt(address account, uint256 blockNumber, bytes calldata auxData) external view returns (uint256) {\n        return stakedByAt(account, blockNumber) + claimableAt(account, blockNumber, auxData);\n    }\n\n    /// @return Total amount staked by all accounts\n    function totalStaked() external view returns (uint256) {\n        return _totalStaked;\n    }\n\n    /// @dev Checks `claimable(account)` of all Plugins and returns the total.\n    /// @param account Account to query balance of\n    /// @param auxData Auxiliary data to pass to plugins\n    /// @return Total amount claimable by an account\n    function claimable(address account, bytes calldata auxData) public view returns (uint256) {\n        uint256 total;\n        // loop over all plugins, sum claimable of account\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).claimable(account, auxData);\n        }\n        return total;\n    }\n\n    /// @dev Checks `claimableAt(account, blockNumber)` of all Plugins.\n    /// @param account Account to query claimable amount\n    /// @param blockNumber Block at which to query claimable amount\n    /// @param auxData Auxiliary data to pass to plugins\n    /// @return Total amount claimable by an account at a specific block number.\n    function claimableAt(address account, uint256 blockNumber, bytes calldata auxData) public view returns (uint256) {\n        uint256 total;\n        // loop over all plugins, sum claimableAt of account\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).claimableAt(account, blockNumber, auxData);\n        }\n        return total;\n    }\n\n    /// @return Amount staked by an account. This does not include claimable yield from plugins.\n    /// @param account Account to query staked amount\n    function stakedBy(address account) external view returns (uint256) {\n        return _stakes[account].latest();\n    }\n\n    /// @return Amount staked by an account at a specific block number excluding claimable yield.\n    /// @param account Account to query staked amount\n    /// @param blockNumber Block at which to query staked amount\n    function stakedByAt(address account, uint256 blockNumber) public view returns (uint256) {\n        return _stakes[account].getAtBlock(blockNumber);\n    }\n\n    /************************************************\n    *   external mutative functions\n    ************************************************/\n\n    /// @notice Stakes some amount of TEL to earn potential rewards.\n    /// @param amount Amount to stake\n    function stake(uint256 amount) external whenNotPaused nonReentrant {\n        _stake({\n            account: msg.sender, \n            from: msg.sender, \n            amount: amount\n        });\n    }\n\n    /// @notice Withdraws staked TEL, does not claim any yield.\n    /// @return Amount withdrawn\n    function exit() external whenNotPaused nonReentrant returns (uint256) {\n        return _exit({\n            account: msg.sender, \n            to: msg.sender\n        });\n    }\n\n    /// @notice Claims yield from an individual plugin and sends it to calling account.\n    /// @param pluginIndex Index of desired plugin\n    /// @param auxData Auxiliary data for the plugin\n    /// @return Amount claimed\n    function claimFromIndividualPlugin(uint256 pluginIndex, bytes calldata auxData) external whenNotPaused nonReentrant returns (uint256) {\n        return _claimFromIndividualPlugin({\n            account: msg.sender, \n            to: msg.sender, \n            pluginIndex: pluginIndex, \n            auxData: auxData\n        });\n    }\n\n    /// @notice Claims yield from all plugins and sends it to calling account.\n    /// @param auxData Auxiliary data for the plugins\n    /// @return Amount claimed\n    function claim(bytes calldata auxData) external whenNotPaused nonReentrant returns (uint256) {\n        return _claim({\n            account: msg.sender, \n            to: msg.sender, \n            auxData: auxData\n        });\n    }\n\n    /// @notice Claims all yield and withdraws all stake.\n    /// @param auxData Auxiliary data for the plugins\n    /// @return Amount claimed\n    /// @return Amount withdrawn\n    function fullClaimAndExit(bytes calldata auxData) external whenNotPaused nonReentrant returns (uint256, uint256) {\n        return (\n            _claim({ account: msg.sender, to: msg.sender, auxData: auxData }), \n            _exit(msg.sender, msg.sender)\n        );\n    }\n\n    /// @notice Claims yield and withdraws some of stake.\n    /// @param amount Amount to withdraw\n    /// @param auxData Auxiliary data for the plugins\n    function partialClaimAndExit(uint256 amount, bytes calldata auxData) external whenNotPaused nonReentrant {\n        _claimAndExit({\n            account: msg.sender, \n            amount: amount, \n            to: msg.sender,\n            auxData: auxData\n        });\n    }\n\n    \n\n    /************************************************\n    *   private mutative functions\n    ************************************************/\n\n    /// @notice Claims earned yield from an individual plugin\n    /// @param account Account to claim on behalf of.\n    /// @param to Address to send the claimed yield to.\n    /// @param pluginIndex Index of the desired plugin to claim from\n    /// @dev Calls `claim` on the desired plugin\n    /// @dev Checks to make sure the amount of tokens the plugins sent matches what the `claim` functions returned. (Probably unnecessary)\n    /// @return Amount claimed\n    function _claimFromIndividualPlugin(address account, address to, uint256 pluginIndex, bytes calldata auxData) private returns (uint256) {\n        require(pluginIndex < nPlugins, \"StakingModule::_claimFromIndividualPlugin: Provided pluginIndex is out of bounds\");\n        \n        // balance of `to` before claiming\n        uint256 balBefore = IERC20Upgradeable(tel).balanceOf(to);\n\n        // xClaimed = \"amount of TEL claimed from the plugin\"\n        uint256 xClaimed = IPlugin(plugins[pluginIndex]).claim(account, to, auxData);\n\n        // we want to make sure the plugin did not return the wrong amount\n        require(IERC20Upgradeable(tel).balanceOf(to) - balBefore == xClaimed, \"The plugin did not send appropriate token amount\");\n\n        // only emit Claimed if anything was actually claimed\n        if (xClaimed > 0) {\n            emit Claimed(account, xClaimed);\n        }\n\n        return xClaimed;\n    }\n\n    /// @notice Claims earned yield\n    /// @param account Account to claim on behalf of.\n    /// @param to Address to send the claimed yield to.\n    /// @param auxData Auxiliary data for the plugins\n    /// @dev Iterates over all plugins and calls `claim`\n    /// @dev Checks to make sure the amount of tokens the plugins sent matches what the `claim` functions returned.\n    /// @dev If amount claimed is >0, emit Claimed\n    /// @return Amount claimed\n    function _claim(address account, address to, bytes calldata auxData) private returns (uint256) {\n        // balance of `to` before claiming\n        uint256 balBefore = IERC20Upgradeable(tel).balanceOf(to);\n\n        // call claim on all plugins and count the total amount claimed\n        uint256 total;\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).claim(account, to, auxData);\n        }\n\n        // make sure `total` actually matches how much we've claimed\n        require(IERC20Upgradeable(tel).balanceOf(to) - balBefore == total, \"one or more plugins did not send appropriate token amount\");\n\n        // only emit Claimed if anything was actually claimed\n        if (total > 0) {\n            emit Claimed(account, total);\n        }\n\n        return total;\n    }\n\n    /// @notice Withdraws staked TEL to the specified `to` address, does not claim any yield.\n    /// @dev Notifies all plugins that account's stake is changing.\n    /// @dev Writes _stakes checkpoint. \n    /// @dev Decrements _totalStaked\n    /// @dev Transfers TEL\n    ///"
    }
  ]
}