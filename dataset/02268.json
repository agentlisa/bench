{
  "Title": "H-4: Slippage/Minimum amount does not work during single-side redemption",
  "Content": "# Issue H-4: Slippage/Minimum amount does not work during single-side redemption \n\nSource: https://github.com/sherlock-audit/2023-02-notional-judging/issues/10 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe slippage or minimum amount of tokens to be received is set to a value much smaller than expected due to the use of `TwoTokenPoolUtils._getMinExitAmounts` function to automatically compute the slippage or minimum amount on behalf of the callers during a single-sided redemption. As a result, the vault will continue to redeem the pool tokens even if the trade incurs significant slippage, resulting in the vault receiving fewer tokens in return, leading to losses for the vault shareholders.\n\n## Vulnerability Detail\n\nThe `Curve2TokenConvexHelper._executeSettlement` function is called by the following functions:\n\n- `Curve2TokenConvexHelper.settleVault`\n  - `Curve2TokenConvexHelper.settleVault` function is called within the `Curve2TokenConvexVault.settleVaultNormal` and `Curve2TokenConvexVault.settleVaultPostMaturity` functions\n- `Curve2TokenConvexHelper.settleVaultEmergency`\n  - `Curve2TokenConvexHelper.settleVaultEmergency` is called by `Curve2TokenConvexVault.settleVaultEmergency`\n\nIn summary, the `Curve2TokenConvexHelper._executeSettlement` function is called during vault settlement.\n\nAn important point to note here is that within the `Curve2TokenConvexHelper._executeSettlement` function, the `params.minPrimary` and `params.minSecondary` are automatically computed and overwritten by the `TwoTokenPoolUtils._getMinExitAmounts` function (Refer to Line 124 below). Therefore, if the caller attempts to define the `params.minPrimary` and `params.minSecondary`, they will be discarded and overwritten. The `params.minPrimary` and `params.minSecondary` is for slippage control when redeeming the Curve's LP tokens.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol#L112\n\n```solidity\nFile: Curve2TokenConvexHelper.sol\n112:     function _executeSettlement(\n113:         StrategyContext calldata strategyContext,\n114:         Curve2TokenPoolContext calldata poolContext,\n115:         uint256 maturity,\n116:         uint256 poolClaimToSettle,\n117:         uint256 redeemStrategyTokenAmount,\n118:         RedeemParams memory params\n119:     ) private {\n120:         (uint256 spotPrice, uint256 oraclePrice) = poolContext._getSpotPriceAndOraclePrice(strategyContext);\n121: \n122:         /// @notice params.minPrimary and params.minSecondary are not required to be passed in by the caller\n123:         /// for this strategy vault\n124:         (params.minPrimary, params.minSecondary) = poolContext.basePool._getMinExitAmounts({\n125:             strategyContext: strategyContext,\n126:             oraclePrice: oraclePrice,\n127:             spotPrice: spotPrice,\n128:             poolClaim: poolClaimToSettle\n129:         });\n```\n\nThe `TwoTokenPoolUtils._getMinExitAmounts` function calculates the minimum amount on the share of the pool with a small discount.\n\nAssume a Curve Pool with the following configuration:\n\n- Consist of two tokens (DAI and USDC). DAI is primary token, USDC is secondary token.\n- Pool holds 200 US Dollars worth of tokens (50 DAI and 150 USDC).\n- DAI <> USDC price is 1:1\n- totalSupply = 100 LP Pool Tokens\n\nAssume that 50 LP Pool Tokens will be claimed during vault settlement. \n\n```solidity\nminPrimary = (poolContext.primaryBalance * poolClaim * strategyContext.vaultSettings.poolSlippageLimitPercent /  (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS)\nminPrimary = (50 DAI * 50 LP_TOKEN * 99.75% /  (100 LP_TOKEN * 100%)\n\nRewrite for clarity (ignoring rounding error):\nminPrimary = 50 DAI * (50 LP_TOKEN/100 LP_TOKEN) * (99.75%/100%) = 24.9375 DAI\n\nminSecondary = same calculation = 74.8125 USDC\n```\n\n`TwoTokenPoolUtils._getMinExitAmounts` function will return `24.9375 DAI` as `params.minPrimary` and `74.8125 USDC` as `params.minSecondary`.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/common/internal/pool/TwoTokenPoolUtils.sol#L48\n\n```solidity\nFile: TwoTokenPoolUtils.sol\n46:     /// @notice calculates the expected primary and secondary amounts based on\n47:     /// the given spot price and oracle price\n48:     function _getMinExitAmounts(\n49:         TwoTokenPoolContext calldata poolContext,\n50:         StrategyContext calldata strategyContext,\n51:         uint256 spotPrice,\n52:         uint256 oraclePrice,\n53:         uint256 poolClaim\n54:     ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n55:         strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n56: \n57:         // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n58:         uint256 totalPoolSupply = poolContext.poolToken.totalSupply();\n59:         minPrimary = (poolContext.primaryBalance * poolClaim * \n60:             strategyContext.vaultSettings.poolSlippageLimitPercent) / \n61:             (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n62:         minSecondary = (poolContext.secondaryBalance * poolClaim * \n63:             strategyContext.vaultSettings.poolSlippageLimitPercent) / \n64:             (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n65:     }\n```\n\nWhen settling the vault, it is possible to instruct the vault to redeem the Curve's LP tokens single-sided or proportionally. Settle vault functions will trigger a chain of functions that will eventually call the `Curve2TokenConvexHelper._unstakeAndExitPool` function that is responsible for redeeming the Curve's LP tokens.\n\nWithin the `Curve2TokenConvexHelper._unstakeAndExitPool` function, if the `params.secondaryTradeParams.length` is zero, the redemption will be single-sided (refer to Line 242 below). Otherwise, the redemption will be executed proportionally (refer to Line 247 below). For a single-sided redemption, only the `params.minPrimary` will be used.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol#L231\n\n```solidity\nFile: Curve2TokenPoolUtils.sol\n231:     function _unstakeAndExitPool(\n232:         Curve2TokenPoolContext memory poolContext,\n233:         ConvexStakingContext memory stakingContext,\n234:         uint256 poolClaim,\n235:         RedeemParams memory params\n236:     ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n237:         // Withdraw pool tokens back to the vault for redemption\n238:         bool success = stakingContext.rewardPool.withdrawAndUnwrap(poolClaim, false); // claimRewards = false\n239:         if (!success) revert Errors.UnstakeFailed();\n240: \n241:         if (params.secondaryTradeParams.length == 0) {\n242:             // Redeem single-sided\n243:             primaryBalance = ICurve2TokenPool(address(poolContext.curvePool)).remove_liquidity_one_coin(\n244:                 poolClaim, int8(poolContext.basePool.primaryIndex), params.minPrimary\n245:             );\n246:         } else {\n247:             // Redeem proportionally\n248:             uint256[2] memory minAmounts;\n249:             minAmounts[poolContext.basePool.primaryIndex] = params.minPrimary;\n250:             minAmounts[poolContext.basePool.secondaryIndex] = params.minSecondary;\n251:             uint256[2] memory exitBalances = ICurve2TokenPool(address(poolContext.curvePool)).remove_liquidity(\n252:                 poolClaim, minAmounts\n253:             );\n254: \n255:             (primaryBalance, secondaryBalance) \n256:                 = (exitBalances[poolContext.basePool.primaryIndex], exitBalances[poolContext.basePool.secondaryIndex]);\n257:         }\n258:     }\n```\n\nAssume that the caller decided to perform a single-sided redemption of 50 LP Pool Tokens, using the earlier example. In this case,\n\n- `poolClaim` =  50 LP Pool Tokens\n- `params.minPrimary ` = 24.9375 DAI\n- `params.minSecondary` = 74.8125 USDC\n\nThe data passed into the `remove_liquidity_one_coin` will be as follows:\n\n```python\n@notice Withdraw a single coin from the pool\n@param _token_amount Amount of LP tokens to burn in the withdrawal\n@param i Index value of the coin to withdraw\n@param _min_amount Minimum amount of coin to receive\n@return Amount of coin received\ndef remove_liquidity_one_coin(\n    _token_amount: uint256,\n    i: int128,\n    _min_amount: uint256\n) -> uint256:\n```\n\n```solidity\nremove_liquidity_one_coin(poolClaim, int8(poolContext.basePool.primaryIndex), params.minPrimary);\nremove_liquidity_one_coin(50 LP_TOKEN, Index 0=DAI, 24.9375 DAI);\n```\n\nAssume the pool holds 200 US dollars worth of tokens (50 DAI and 150 USDC), and the total supply is 100 LP Tokens. The pool's state is imbalanced, so any trade will result in significant slippage.\n\nIntuitively (ignoring the slippage & fee), redeeming 50 LP Tokens should return approximately 100 US dollars worth of tokens, which means around 100 DAI. Thus, the slippage or minimum amount should ideally be around 100 DAI (+/- 5%). \n\nHowever, the trade will be executed in the above example even if the vault receives only 25 DAI because the `params.minPrimary` is set to `24.9375 DAI`. This could result in a loss of around 75 DAI due to slippage (about 75% slippage rate) in the worst-case scenario.\n\n## Impact\n\nThe slippage or minimum amount of tokens to be received is set to a value much smaller than expected. Thus, the vault will continue to redeem the pool tokens even if the trade incurs significant slippage, resulting in the vault receiving fewer tokens in return, leading to losses for the vault shareholders.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol#L112\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen performing a single-side redemption, avoid using the `TwoTokenPoolUtils._getMinExitAmounts` function to automatically compute the slippage or minimum amount of tokens to receive on behalf of the caller. Instead, give the caller the flexibility to define the slippage (`params.minPrimary`). To prevent the caller from setting a slippage that is too large, consider restricting the slippage to an acceptable range.\n\nThe proper way of computing the minimum amount of tokens to receive from a single-side trade (`remove_liquidity_one_coin`) is to call the Curve Pool's [`calc_withdraw_one_coin`](https://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pools/steth/StableSwapSTETH.vy#L646) function off-chain to calculate the amount received when withdrawing a single LP Token, and then apply an acceptable discount.\n\nNote that the `calc_withdraw_one_coin` function cannot be used solely on-chain for computing the minimum amount because the result can be manipulated since it uses spot balances for computation.\n\n## Discussion\n\n**jeffywu**\n\nValid, similar issue to #12 but for the remove_liquidity_one_coin method.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/52",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    Curve2TokenConvexStrategyContext,\n    Curve2TokenPoolContext\n} from \"../CurveVaultTypes.sol\";\nimport {\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState,\n    TwoTokenPoolContext,\n    DepositParams,\n    RedeemParams,\n    ReinvestRewardParams\n} from \"../../common/VaultTypes.sol\";\nimport {TwoTokenPoolUtils} from \"../../common/internal/pool/TwoTokenPoolUtils.sol\";\nimport {SettlementUtils} from \"../../common/internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../../common/internal/strategy/StrategyUtils.sol\";\nimport {VaultStorage} from \"../../common/VaultStorage.sol\";\nimport {VaultEvents} from \"../../common/VaultEvents.sol\";\nimport {Curve2TokenPoolUtils} from \"../internal/pool/Curve2TokenPoolUtils.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\n\nlibrary Curve2TokenConvexHelper {\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using VaultStorage for StrategyVaultState;\n\n    function deposit(\n        Curve2TokenConvexStrategyContext memory context,\n        uint256 deposit,\n        bytes calldata data\n    ) external returns (uint256 strategyTokensMinted) {\n        DepositParams memory params = abi.decode(data, (DepositParams));\n\n        strategyTokensMinted = context.poolContext._deposit({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            deposit: deposit,\n            params: params\n        });\n    }\n\n    function redeem(\n        Curve2TokenConvexStrategyContext memory context,\n        uint256 strategyTokens,\n        bytes calldata data\n    ) external returns (uint256 finalPrimaryBalance) {\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        finalPrimaryBalance = context.poolContext._redeem({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            strategyTokens: strategyTokens,\n            params: params\n        });\n    }\n\n    function settleVault(\n        Curve2TokenConvexStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 poolClaimToSettle = context.baseStrategy._convertStrategyTokensToPoolClaim(strategyTokensToRedeem);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            poolClaimToSettle: poolClaimToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit VaultEvents.VaultSettlement(maturity, poolClaimToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        Curve2TokenConvexStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 poolClaimToSettle = context.baseStrategy._getEmergencySettlementParams({\n            maturity: maturity, \n            totalPoolSupply: context.poolContext.basePool.poolToken.totalSupply()\n        });\n\n        uint256 redeemStrategyTokenAmount = \n            context.baseStrategy._convertPoolClaimToStrategyTokens(poolClaimToSettle);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            poolClaimToSettle: poolClaimToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit VaultEvents.EmergencyVaultSettlement(maturity, poolClaimToSettle, redeemStrategyTokenAmount);    \n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        Curve2TokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 poolClaimToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        (uint256 spotPrice, uint256 oraclePrice) = poolContext._getSpotPriceAndOraclePrice(strategyContext);\n\n        /// @notice params.minPrimary and params.minSecondary are not required to be passed in by the caller\n        /// for this strategy vault\n        (params.minPrimary, params.minSecondary) = poolContext.basePool._getMinExitAmounts({\n            strategyContext: strategyContext,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice,\n            poolClaim: poolClaimToSettle\n        });\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            strategyTokenAmount: redeemStrategyTokenAmount,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });    \n    }\n\n    function reinvestReward(\n        Curve2TokenConvexStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {\n        StrategyContext memory strategyContext = context.baseStrategy;\n        Curve2TokenPoolContext calldata poolContext = context.poolContext; \n\n        (\n            address rewardToken, \n            uint256 primaryAmount, \n            uint256 secondaryAmount\n        ) = poolContext.basePool._executeRewardTrades({\n            rewardTokens: context.stakingContext.rewardTokens,\n            tradingModule: strategyContext.tradingModule,\n            data: params.tradeData\n        });\n\n        // Make sure we are joining with the right proportion to minimize slippage\n        poolContext._validateSpotPriceAndPairPrice({\n            strategyContext: strategyContext,\n            oraclePrice: poolContext.basePool._getOraclePairPrice(strategyContext),\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount\n        });\n\n        uint256 poolClaimAmount = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: context.stakingContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            /// @notice minPoolClaim is not required to be set by the caller because primaryAmount\n            /// and secondaryAmount are already validated\n            minPoolClaim: params.minPoolClaim      \n        });\n\n        strategyContext.vaultState.totalPoolClaim += poolClaimAmount;\n        strategyContext.vaultState.setStrategyVaultState(); \n\n        emit VaultEvents.RewardReinvested(rewardToken, primaryAmount, secondaryAmount, poolClaimAmount);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    TwoTokenPoolContext, \n    StrategyContext, \n    DepositTradeParams, \n    TradeParams,\n    SingleSidedRewardTradeParams,\n    Proportional2TokenRewardTradeParams,\n    RedeemParams\n} from \"../../VaultTypes.sol\";\nimport {VaultConstants} from \"../../VaultConstants.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {RewardUtils} from \"../reward/RewardUtils.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../../../../interfaces/IERC20.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using StrategyUtils for StrategyContext;\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param strategyContext strategy context variables\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 oraclePairPrice) {\n        (int256 rate, int256 decimals) = strategyContext.tradingModule.getOraclePrice(\n            poolContext.primaryToken, poolContext.secondaryToken\n        );\n        require(rate > 0);\n        require(decimals >= 0);\n\n        if (uint256(decimals) != strategyContext.poolClaimPrecision) {\n            rate = (rate * int256(strategyContext.poolClaimPrecision)) / decimals;\n        }\n\n        // No overflow in rate conversion, checked above\n        oraclePairPrice = uint256(rate);\n    }\n\n    /// @notice calculates the expected primary and secondary amounts based on\n    /// the given spot price and oracle price\n    function _getMinExitAmounts(\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 spotPrice,\n        uint256 oraclePrice,\n        uint256 poolClaim\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalPoolSupply = poolContext.poolToken.totalSupply();\n        minPrimary = (poolContext.primaryBalance * poolClaim * \n            strategyContext.vaultSettings.poolSlippageLimitPercent) / \n            (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * poolClaim * \n            strategyContext.vaultSettings.poolSlippageLimitPercent) / \n            (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        uint256 poolClaim,\n        uint256 oraclePrice,\n        uint256 spotPrice\n    ) internal view returns (uint256 primaryAmount) {\n        // Make sure spot price is within oracleDeviationLimit of pairPrice\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n        \n        // Get shares of primary and secondary balances with the provided poolClaim\n        uint256 totalSupply = poolContext.poolToken.totalSupply();\n        uint256 primaryBalance = poolContext.primaryBalance * poolClaim / totalSupply;\n        uint256 secondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply;\n\n        // Value the secondary balance in terms of the primary token using the oraclePairPrice\n        uint256 secondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\n\n        // Make sure primaryAmount is reported in primaryPrecision\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        primaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision;\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) internal returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount,\n            useDynamicSlippage: true\n        });\n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) internal returns (uint256 primaryPurchased) {\n        (TradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (TradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance,\n                useDynamicSlippage: true\n            });\n    }\n\n    function _validateTrades(\n        IERC20[] memory rewardTokens,\n        SingleSidedRewardTradeParams memory primaryTrade,\n        SingleSidedRewardTradeParams memory secondaryTrade,\n        address primaryToken,\n        address secondaryToken\n    ) private pure {\n        // Validate trades\n        if (!RewardUtils._isValidRewardToken(rewardTokens, primaryTrade.sellToken)) {\n            revert Errors.InvalidRewardToken(primaryTrade.sellToken);\n        }\n        if (secondaryTrade.sellToken != primaryTrade.sellToken) {\n            revert Errors.InvalidRewardToken(secondaryTrade.sellToken);\n        }\n        if (primaryTrade.buyToken != primaryToken) {\n            revert Errors.InvalidRewardToken(primaryTrade.buyToken);\n        }\n        if (secondaryTrade.buyToken != secondaryToken) {\n            revert Errors.InvalidRewardToken(secondaryTrade.buyToken);\n        }\n    }\n\n    function _executeRewardTrades(\n        TwoTokenPoolContext calldata poolContext,\n        IERC20[] memory rewardTokens,\n        ITradingModule tradingModule,\n        bytes calldata data\n    ) internal returns (address rewardToken, uint256 primaryAmount, uint256 secondaryAmount) {\n        Proportional2TokenRewardTradeParams memory params = abi.decode(\n            data,\n            (Proportional2TokenRewardTradeParams)\n        );\n\n        _validateTrades(\n            rewardTokens,\n            params.primaryTrade,\n            params.secondaryTrade,\n            poolContext.primaryToken,\n            poolContext.secondaryToken\n        );\n\n        (/*uint256 amountSold*/, primaryAmount) = StrategyUtils._executeTradeExactIn({\n            params: params.primaryTrade.tradeParams,\n            tradingModule: tradingModule,\n            sellToken: params.primaryTrade.sellToken,\n            buyToken: params.primaryTrade.buyToken,\n            amount: params.primaryTrade.amount,\n            useDynamicSlippage: false\n        });\n\n        (/*uint256 amountSold*/, secondaryAmount) = StrategyUtils._executeTradeExactIn({\n            params: params.secondaryTrade.tradeParams,\n            tradingModule: tradingModule,\n            sellToken: params.secondaryTrade.sellToken,\n            buyToken: params.secondaryTrade.buyToken,\n            amount: params.secondaryTrade.amount,\n            useDynamicSlippage: false\n        });\n\n        rewardToken = params.primaryTrade.sellToken;\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {\n    StrategyContext, \n    TwoTokenPoolContext,\n    StrategyVaultSettings, \n    StrategyVaultState,\n    DepositParams,\n    RedeemParams,\n    ReinvestRewardParams\n} from \"../../../common/VaultTypes.sol\";\nimport {CurveConstants} from \"../CurveConstants.sol\";\nimport {Curve2TokenPoolContext, ConvexStakingContext} from \"../../CurveVaultTypes.sol\";\nimport {TwoTokenPoolUtils} from \"../../../common/internal/pool/TwoTokenPoolUtils.sol\";\nimport {StrategyUtils} from \"../../../common/internal/strategy/StrategyUtils.sol\";\nimport {VaultStorage} from \"../../../common/VaultStorage.sol\";\nimport {VaultConstants} from \"../../../common/VaultConstants.sol\";\nimport {ICurve2TokenPool} from \"../../../../../interfaces/curve/ICurvePool.sol\";\n\nlibrary Curve2TokenPoolUtils {\n    using StrategyUtils for StrategyContext;\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultSettings;\n    using VaultStorage for StrategyVaultState;\n\n    function _deposit(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX when joining\n            (uint256 primarySold, uint256 secondaryBought) = poolContext.basePool._tradePrimaryForSecondary({\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 poolClaimMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minPoolClaim: params.minPoolClaim\n        });\n\n        strategyTokensMinted = strategyContext._mintStrategyTokens(poolClaimMinted);\n    }\n\n    function _redeem(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 poolClaim = strategyContext._redeemStrategyTokens(strategyTokens);\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(poolContext, stakingContext, poolClaim, params);\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = poolContext.basePool._sellSecondaryBalance(\n                strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n    }\n\n    function _getSpotPrice(\n        Curve2TokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2);\n        if (tokenIndex == 0) {\n            spotPrice = poolContext.curvePool.get_dy(\n                int8(poolContext.basePool.primaryIndex), \n                int8(poolContext.basePool.secondaryIndex), \n                10**poolContext.basePool.primaryDecimals // 1 unit of primary\n            );\n            uint256 secondaryPrecision = 10**poolContext.basePool.secondaryDecimals;\n            spotPrice = spotPrice * CurveConstants.CURVE_PRECISION / secondaryPrecision;\n        } else {\n            spotPrice = poolContext.curvePool.get_dy(\n                int8(poolContext.basePool.secondaryIndex),\n                int8(poolContext.basePool.primaryIndex), \n                10**poolContext.basePool.secondaryDecimals // 1 unit of secondary\n            );\n            uint256 primaryPrecision = 10**poolContext.basePool.primaryDecimals;\n            spotPrice = spotPrice * CurveConstants.CURVE_PRECISION / primaryPrecision;\n        }\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        Curve2TokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            poolContext: poolContext,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n        uint256 primaryPrecision = 10**poolContext.basePool.primaryDecimals;\n        uint256 secondaryPrecision = 10**poolContext.basePool.secondaryDecimals;\n\n        // Convert input amounts and pool amounts to CURVE_PRECISION (1e18)\n\n        primaryAmount = primaryAmount * strategyContext.poolClaimPrecision / primaryPrecision;\n        secondaryAmount = secondaryAmount * strategyContext.poolClaimPrecision / secondaryPrecision;\n\n        uint256 primaryPoolBalance = poolContext.basePool.primaryBalance * CurveConstants.CURVE_PRECISION \n            / primaryPrecision;\n        uint256 secondaryPoolBalance = poolContext.basePool.secondaryBalance * CurveConstants.CURVE_PRECISION \n            / secondaryPrecision;\n\n        return _checkPrimarySecondaryRatio({\n            strategyContext: strategyContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            primaryPoolBalance: primaryPoolBalance,\n            secondaryPoolBalance: secondaryPoolBalance\n        });\n    }\n    \n    function _checkPrimarySecondaryRatio(\n        StrategyContext memory strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryAmount, \n        uint256 primaryPoolBalance, \n        uint256 secondaryPoolBalance\n    ) private pure {\n        uint256 totalAmount = primaryAmount + secondaryAmount;\n        uint256 totalPoolBalance = primaryPoolBalance + secondaryPoolBalance;\n\n        uint256 primaryPercentage = primaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;        \n        uint256 expectedPrimaryPercentage = primaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n\n        strategyContext._checkPriceLimit(expectedPrimaryPercentage, primaryPercentage);\n\n        uint256 secondaryPercentage = secondaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;\n        uint256 expectedSecondaryPercentage = secondaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n\n        strategyContext._checkPriceLimit(expectedSecondaryPercentage, secondaryPercentage);\n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param strategyContext strategy context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        uint256 strategyTokenAmount,\n        uint256 oraclePrice,\n        uint256 spotPrice\n    ) internal view returns (int256 underlyingValue) {\n        \n        uint256 poolClaim \n            = strategyContext._convertStrategyTokensToPoolClaim(strategyTokenAmount);\n\n        underlyingValue \n            = poolContext.basePool._getTimeWeightedPrimaryBalance({\n                strategyContext: strategyContext,\n                poolClaim: poolClaim,\n                oraclePrice: oraclePrice, \n                spotPrice: spotPrice\n            }).toInt();\n    }   \n\n    function _joinPoolAndStake(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        uint256 minPoolClaim\n    ) internal returns (uint256 poolClaimMinted) {\n        uint256[2] memory amounts;\n        uint256 msgValue;\n        amounts[poolContext.basePool.primaryIndex] = primaryAmount;\n        amounts[poolContext.basePool.secondaryIndex] = secondaryAmount;\n\n        if (poolContext.basePool.primaryToken == Deployments.ETH_ADDRESS) {\n            msgValue = primaryAmount;\n        } else if (poolContext.basePool.secondaryToken == Deployments.ETH_ADDRESS) {\n            msgValue = secondaryAmount;\n        }\n\n        poolClaimMinted = ICurve2TokenPool(address(poolContext.curvePool)).add_liquidity{value: msgValue}(\n            amounts, minPoolClaim\n        );\n\n        // Check pool claim threshold to make sure our share of the pool is\n        // below maxPoolShare\n        uint256 poolClaimThreshold = strategyContext.vaultSettings._poolClaimThreshold(\n            poolContext.basePool.poolToken.totalSupply()\n        );\n        uint256 poolClaimHeldAfterJoin = strategyContext.vaultState.totalPoolClaim + poolClaimMinted;\n        if (poolClaimThreshold < poolClaimHeldAfterJoin)\n            revert Errors.PoolShareTooHigh(poolClaimHeldAfterJoin, poolClaimThreshold);\n\n\n        bool success = stakingContext.booster.deposit(stakingContext.poolId, poolClaimMinted, true); // stake = true\n        require(success);    \n    }\n\n    function _unstakeAndExitPool(\n        Curve2TokenPoolContext memory poolContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 poolClaim,\n        RedeemParams memory params\n    ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n        // Withdraw pool tokens back to the vault for redemption\n        bool success = stakingContext.rewardPool.withdrawAndUnwrap(poolClaim, false); // claimRewards = false\n        if (!success) revert Errors.UnstakeFailed();\n\n        if (params.secondaryTradeParams.length == 0) {\n            // Redeem single-sided\n            primaryBalance = ICurve2TokenPool(address(poolContext.curvePool)).remove_liquidity_one_coin(\n                poolClaim, int8(poolContext.basePool.primaryIndex), params.minPrimary\n            );\n        } else {\n            // Redeem proportionally\n            uint256[2] memory minAmounts;\n            minAmounts[poolContext.basePool.primaryIndex] = params.minPrimary;\n            minAmounts[poolContext.basePool.secondaryIndex] = params.minSecondary;\n            uint256[2] memory exitBalances = ICurve2TokenPool(address(poolContext.curvePool)).remove_liquidity(\n                poolClaim, minAmounts\n            );\n\n            (primaryBalance, secondaryBalance) \n                = (exitBalances[poolContext.basePool.primaryIndex], exitBalances[poolContext.basePool.secondaryIndex]);\n        }\n    }\n\n    function _getSpotPriceAndOraclePrice(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 spotPrice, uint256 oraclePrice) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        spotPrice = poolContext._getSpotPrice(0); // tokenIndex\n        oraclePrice = poolContext.basePool._getOraclePairPrice(strategyContext);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    Curve2TokenConvexStrategyContext,\n    Curve2TokenPoolContext\n} from \"../CurveVaultTypes.sol\";\nimport {\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState,\n    TwoTokenPoolContext,\n    DepositParams,\n    RedeemParams,\n    ReinvestRewardParams\n} from \"../../common/VaultTypes.sol\";\nimport {TwoTokenPoolUtils} from \"../../common/internal/pool/TwoTokenPoolUtils.sol\";\nimport {SettlementUtils} from \"../../common/internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../../common/internal/strategy/StrategyUtils.sol\";\nimport {VaultStorage} from \"../../common/VaultStorage.sol\";\nimport {VaultEvents} from \"../../common/VaultEvents.sol\";\nimport {Curve2TokenPoolUtils} from \"../internal/pool/Curve2TokenPoolUtils.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\n\nlibrary Curve2TokenConvexHelper {\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using VaultStorage for StrategyVaultState;\n\n    function deposit(\n        Curve2TokenConvexStrategyContext memory context,\n        uint256 deposit,\n        bytes calldata data\n    ) external returns (uint256 strategyTokensMinted) {\n        DepositParams memory params = abi.decode(data, (DepositParams));\n\n        strategyTokensMinted = context.poolContext._deposit({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            deposit: deposit,\n            params: params\n        });\n    }\n\n    function redeem(\n        Curve2TokenConvexStrategyContext memory context,\n        uint256 strategyTokens,\n        bytes calldata data\n    ) external returns (uint256 finalPrimaryBalance) {\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        finalPrimaryBalance = context.poolContext._redeem({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            strategyTokens: strategyTokens,\n            params: params\n        });\n    }\n\n    function settleVault(\n        Curve2TokenConvexStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 poolClaimToSettle = context.baseStrategy._convertStrategyTokensToPoolClaim(strategyTokensToRedeem);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            poolClaimToSettle: poolClaimToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit VaultEvents.VaultSettlement(maturity, poolClaimToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        Curve2TokenConvexStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 poolClaimToSettle = context.baseStrategy._getEmergencySettlementParams({\n            maturity: maturity, \n            totalPoolSupply: context.poolContext.basePool.poolToken.totalSupply()\n        });\n\n        uint256 redeemStrategyTokenAmount = \n            context.baseStrategy._convertPoolClaimToStrategyTokens(poolClaimToSettle);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            poolClaimToSettle: poolClaimToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit VaultEvents.EmergencyVaultSettlement(maturity, poolClaimToSettle, redeemStrategyTokenAmount);    \n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        Curve2TokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 poolClaimToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        (uint256 spotPrice, uint256 oraclePrice) = poolContext._getSpotPriceAndOraclePrice(strategyContext);\n\n        /// @notice params.minPrimary and params.minSecondary are not required to be passed in by the caller\n        /// for this strategy vault\n        (params.minPrimary, params.minSecondary) = poolContext.basePool._getMinExitAmounts({\n            strategyContext: strategyContext,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice,\n            poolClaim: poolClaimToSettle\n        });\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            strategyTokenAmount: redeemStrategyTokenAmount,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });    \n    }"
    }
  ]
}