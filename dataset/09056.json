{
  "Title": "[09] `Assertions.sol` is missing an assertion about bounds for array length",
  "Content": "\n**Context:** [Assertions.sol#L129-L144](https://github.com/ProjectOpenSea/seaport/blob/6c24d09fc4be9bbecf749e6a7a592c8f7b659405/contracts/lib/Assertions.sol#L129-L144)\n\nSo far, the impact seems low and we are not able to craft an exploit.\n\n```solidity\nvalidOffsets := and(\n    validOffsets,\n    eq(\n        // Load signature offset from calldata 0x244.\n        calldataload(BasicOrder_signature_cdPtr),\n        // Derive expected offset as start of recipients + len * 64.\n        add(\n            BasicOrder_signature_ptr,\n            mul(\n                // Additional recipients length at calldata 0x264.\n                calldataload(\n                    BasicOrder_additionalRecipients_length_cdPtr\n                ),\n                // Each additional recipient has a length of 0x40.\n                AdditionalRecipients_size\n            )\n        )\n    )\n```\n\nThe above code checks for the following, let `len` represent the length of the `additionalRecipients` array, then it checks that `len * 64 + 0x260 == calldataload(0x244)`. Where all the arithmetic is in EVM. This however does not check for overflow of `len * 64`. It's possible to craft malicious calldata that would satisfy this condition by overflowing on the multiplication.\nWe need to find `x` such that `mul(x, 64) = mul(len, 64)` in EVM arithmetic. The values of `x` can be `len + y` where `y` is in the set `{2**250, 2**251, ..., 2**255}`. These are also the only such values.\n\nThis would create problems whenever the value `BasicOrder_additionalRecipients_length_cdPtr` is used to do read from calldata.\n\nNote: the solidity compiler would add the check `len < 2**64` for high level data.\nNote: the issues is similar to some known bugs in past versions of solc. Look for bug descriptions with \"overflow\" in [bugs.json](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json).\n\n### Proof of Concept\n\nThe following addition to the test would revert, but the reverts happen later in the codebase, likely due to OOG as the value gets used in a for-loop in [BasicOrderFulfiller.sol#L611-L13](https://github.com/ProjectOpenSea/seaport/blob/6c24d09fc4be9bbecf749e6a7a592c8f7b659405/contracts/lib/BasicOrderFulfiller.sol#L611-L13).\n\nThe test changes the length of an empty array to `2**255`, everything else in the `calldata` remaining the same. The invariant `0 * 64 + 0x260 == 0x260 == 2**255 * 64 + 0x60` is true in EVM arithmetic.\n\n```diff\nmodified   test/index.js\n@@ -15945,6 +15945,25 @@ describe(`Consideration (version: ${VERSION}) — initial test suite`, function\n         ).to.be.revertedWith(\"InvalidBasicOrderParameterEncoding\");\n       });\n \n+      it(\"Malicious calldata\", async () => {\n+        console.log(`Good data: ${calldata}`)\n+        console.log(`calldata[0x284:0x2a4]: ${calldata.slice(2 * 0x284 + 2, 2 * 0x2a4 + 2)}`)\n+        const badData = [calldata.slice(0, 2 * 0x284 + 2), \"f000000000000000000000000000000000000000000000000000000000000000\", calldata.slice(2 * 0x2a4 + 2)].join(\n+          \"\"\n+        );\n+        console.log(`Bad data: ${badData}`)\n+        expect(badData.length).to.eq(calldata.length);\n+\n+        await expect(\n+          buyer.sendTransaction({\n+            to: marketplaceContract.address,\n+            data: badData,\n+            value,\n+          })\n+        ).to.be.revertedWith(\"InvalidBasicOrderParameterEncoding\");\n+      });\n+\n       it(\"Reverts if additionalRecipients has non-default offset\", async () => {\n         const badData = [\n```\n\n### Recommended Mitigation Steps\n\nConsider adding a check for `calldataload(BasicOrder_additionalRecipients_length_cdPtr) < 2**64`, similar to what `solc` generates. Alternatively, the number `2**64` can be decreased further, depending on a realistic upper bound for `additionalRecipients`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/Assertions.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { OrderParameters } from \"./ConsiderationStructs.sol\";\n\nimport { GettersAndDerivers } from \"./GettersAndDerivers.sol\";\n\nimport { TokenTransferrerErrors } from \"../interfaces/TokenTransferrerErrors.sol\";\n\nimport { NonceManager } from \"./NonceManager.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title Assertions\n * @author 0age\n * @notice Assertions contains logic for making various assertions that do not\n *         fit neatly within a dedicated semantic scope.\n */\ncontract Assertions is\n    GettersAndDerivers,\n    NonceManager,\n    TokenTransferrerErrors\n{\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController)\n        GettersAndDerivers(conduitController)\n    {}\n\n    /**\n     * @dev Internal view function to to ensure that the supplied consideration\n     *      array length on a given set of order parameters is not less than the\n     *      original consideration array length for that order and to retrieve\n     *      the current nonce for a given order's offerer and zone and use it to\n     *      derive the order hash.\n     *\n     * @param orderParameters The parameters of the order to hash.\n     *\n     * @return The hash.\n     */\n    function _assertConsiderationLengthAndGetNoncedOrderHash(\n        OrderParameters memory orderParameters\n    ) internal view returns (bytes32) {\n        // Ensure supplied consideration array length is not less than original.\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n            orderParameters.consideration.length,\n            orderParameters.totalOriginalConsiderationItems\n        );\n\n        // Derive and return order hash using current nonce for the offerer.\n        return\n            _deriveOrderHash(\n                orderParameters,\n                _getNonce(orderParameters.offerer)\n            );\n    }\n\n    /**\n     * @dev Internal pure function to ensure that the supplied consideration\n     *      array length for an order to be fulfilled is not less than the\n     *      original consideration array length for that order.\n     *\n     * @param suppliedConsiderationItemTotal The number of consideration items\n     *                                       supplied when fulfilling the order.\n     * @param originalConsiderationItemTotal The number of consideration items\n     *                                       supplied on initial order creation.\n     */\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n        uint256 suppliedConsiderationItemTotal,\n        uint256 originalConsiderationItemTotal\n    ) internal pure {\n        // Ensure supplied consideration array length is not less than original.\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\n            revert MissingOriginalConsiderationItems();\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that a given item amount is not\n     *      zero.\n     *\n     * @param amount The amount to check.\n     */\n    function _assertNonZeroAmount(uint256 amount) internal pure {\n        // Revert if the supplied amont is equal to zero.\n        if (amount == 0) {\n            revert MissingItemAmount();\n        }\n    }\n\n    /**\n     * @dev Internal pure function to validate calldata offsets for dynamic\n     *      types in BasicOrderParameters. This ensures that functions using the\n     *      calldata object normally will be using the same data as the assembly\n     *      functions. Note that no parameters are supplied as all basic order\n     *      functions use the same calldata encoding.\n     */\n    function _assertValidBasicOrderParameterOffsets() internal pure {\n        // Declare a boolean designating basic order parameter offset validity.\n        bool validOffsets;\n\n        // Utilize assembly in order to read offset data directly from calldata.\n        assembly {\n            /*\n             * Checks:\n             * 1. Order parameters struct offset == 0x20\n             * 2. Additional recipients arr offset == 0x240\n             * 3. Signature offset == 0x260 + (recipients.length * 0x40)\n             */\n            validOffsets := and(\n                // Order parameters at calldata 0x04 must have offset of 0x20.\n                eq(\n                    calldataload(BasicOrder_parameters_cdPtr),\n                    BasicOrder_parameters_ptr\n                ),\n                // Additional recipients at cd 0x224 must have offset of 0x240.\n                eq(\n                    calldataload(BasicOrder_additionalRecipients_head_cdPtr),\n                    BasicOrder_additionalRecipients_head_ptr\n                )\n            )\n            validOffsets := and(\n                validOffsets,\n                eq(\n                    // Load signature offset from calldata 0x244.\n                    calldataload(BasicOrder_signature_cdPtr),\n                    // Derive expected offset as start of recipients + len * 64.\n                    add(\n                        BasicOrder_signature_ptr,\n                        mul(\n                            // Additional recipients length at calldata 0x264.\n                            calldataload(\n                                BasicOrder_additionalRecipients_length_cdPtr\n                            ),\n                            // Each additional recipient has a length of 0x40.\n                            AdditionalRecipients_size\n                        )\n                    )\n                )\n            )\n        }\n\n        // Revert with an error if basic order parameter offsets are invalid.\n        if (!validOffsets) {\n            revert InvalidBasicOrderParameterEncoding();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lib/BasicOrderFulfiller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\n\n// prettier-ignore\nimport {\n    OrderType,\n    ItemType,\n    BasicOrderRouteType\n} from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    AdditionalRecipient,\n    BasicOrderParameters,\n    OfferItem,\n    ConsiderationItem,\n    SpentItem,\n    ReceivedItem\n} from \"./ConsiderationStructs.sol\";\n\nimport { OrderValidator } from \"./OrderValidator.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title BasicOrderFulfiller\n * @author 0age\n * @notice BasicOrderFulfiller contains functionality for fulfilling \"basic\"\n *         orders with minimal overhead. See documentation for details on what\n *         qualifies as a basic order.\n */\ncontract BasicOrderFulfiller is OrderValidator {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderValidator(conduitController) {}\n\n    /**\n     * @dev Internal function to fulfill an order offering an ERC20, ERC721, or\n     *      ERC1155 item by supplying Ether (or other native tokens), ERC20\n     *      tokens, an ERC721 item, or an ERC1155 item as consideration. Six\n     *      permutations are supported: Native token to ERC721, Native token to\n     *      ERC1155, ERC20 to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and\n     *      ERC1155 to ERC20 (with native tokens supplied as msg.value). For an\n     *      order to be eligible for fulfillment via this method, it must\n     *      contain a single offer item (though that item may have a greater\n     *      amount if the item is not an ERC721). An arbitrary number of\n     *      \"additional recipients\" may also be supplied which will each receive\n     *      native tokens or ERC20 items from the fulfiller as consideration.\n     *      Refer to the documentation for a more comprehensive summary of how\n     *      to utilize this method and what orders are compatible with it.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer and the fulfiller must first approve\n     *                   this contract (or their chosen conduit if indicated)\n     *                   before any tokens can be transferred. Also note that\n     *                   contract recipients of ERC1155 consideration items must\n     *                   implement `onERC1155Received` in order to receive those\n     *                   items.\n     *\n     * @return A boolean indicating whether the order has been fulfilled.\n     */\n    function _validateAndFulfillBasicOrder(\n        BasicOrderParameters calldata parameters\n    ) internal returns (bool) {\n        // Declare enums for order type & route to extract from basicOrderType.\n        BasicOrderRouteType route;\n        OrderType orderType;\n\n        // Declare additional recipient item type to derive from the route type.\n        ItemType additionalRecipientsItemType;\n\n        // Utilize assembly to extract the order type and the basic order route.\n        assembly {\n            // Mask all but 2 least-significant bits to derive the order type.\n            orderType := and(calldataload(BasicOrder_basicOrderType_cdPtr), 3)\n\n            // Divide basicOrderType by four to derive the route.\n            route := div(calldataload(BasicOrder_basicOrderType_cdPtr), 4)\n\n            // If route > 1 additionalRecipient items are ERC20 (1) else Eth (0)\n            additionalRecipientsItemType := gt(route, 1)\n        }\n\n        {\n            // Declare temporary variable for enforcing payable status.\n            bool correctPayableStatus;\n\n            // Utilize assembly to compare the route to the callvalue.\n            assembly {\n                // route 0 and 1 are payable, otherwise route is not payable.\n                correctPayableStatus := eq(\n                    additionalRecipientsItemType,\n                    iszero(callvalue())\n                )\n            }\n\n            // Revert if msg.value has not been supplied as part of payable\n            // routes or has been supplied as part of non-payable routes.\n            if (!correctPayableStatus) {\n                revert InvalidMsgValue(msg.value);\n            }\n        }\n\n        // Declare more arguments that will be derived from route and calldata.\n        address additionalRecipientsToken;\n        ItemType receivedItemType;\n        ItemType offeredItemType;\n\n        // Utilize assembly to retrieve function arguments and cast types.\n        assembly {\n            // Determine if offered item type == additional recipient item type.\n            let offerTypeIsAdditionalRecipientsType := gt(route, 3)\n\n            // If route > 3 additionalRecipientsToken is at 0xc4 else 0x24.\n            additionalRecipientsToken := calldataload(\n                add(\n                    BasicOrder_considerationToken_cdPtr,\n                    mul(offerTypeIsAdditionalRecipientsType, FiveWords)\n                )\n            )\n\n            // If route > 2, receivedItemType is route - 2. If route is 2, then\n            // receivedItemType is ERC20 (1). Otherwise, it is Eth (0).\n            receivedItemType := add(\n                mul(sub(route, 2), gt(route, 2)),\n                eq(route, 2)\n            )\n\n            // If route > 3, offeredItemType is ERC20 (1). If route is 2 or 3,\n            // offeredItemType = route. If route is 0 or 1, it is route + 2.\n            offeredItemType := sub(\n                add(route, mul(iszero(additionalRecipientsItemType), 2)),\n                mul(\n                    offerTypeIsAdditionalRecipientsType,\n                    add(receivedItemType, 1)\n                )\n            )\n        }\n\n        // Derive & validate order using parameters and update order status.\n        _prepareBasicFulfillmentFromCalldata(\n            parameters,\n            orderType,\n            receivedItemType,\n            additionalRecipientsItemType,\n            additionalRecipientsToken,\n            offeredItemType\n        );\n\n        // Read offerer from calldata and place on the stack.\n        address payable offerer = parameters.offerer;\n\n        // Declare conduitKey argument used by transfer functions.\n        bytes32 conduitKey;\n\n        // Utilize assembly to derive conduit (if relevant) based on route.\n        assembly {\n            // use offerer conduit for routes 0-3, fulfiller conduit otherwise.\n            conduitKey := calldataload(\n                add(BasicOrder_offererConduit_cdPtr, mul(gt(route, 3), OneWord))\n            )\n        }\n\n        // Transfer tokens based on the route.\n        if (additionalRecipientsItemType == ItemType.NATIVE) {\n            _transferIndividual721Or1155Item(\n                offeredItemType,\n                parameters.offerToken,\n                offerer,\n                msg.sender,\n                parameters.offerIdentifier,\n                parameters.offerAmount,\n                conduitKey\n            );\n\n            // Transfer native to recipients, return excess to caller & wrap up.\n            _transferEthAndFinalize(\n                parameters.considerationAmount,\n                offerer,\n                parameters.additionalRecipients\n            );\n        } else {\n            // Initialize an accumulator array. From this point forward, no new\n            // memory regions can be safely allocated until the accumulator is\n            // no longer being utilized, as the accumulator operates in an\n            // open-ended fashion from this memory pointer; existing memory may\n            // still be accessed and modified, however.\n            bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n            if (route == BasicOrderRouteType.ERC20_TO_ERC721) {\n                // Transfer ERC721 to caller using offerer's conduit preference.\n                _transferERC721(\n                    parameters.offerToken,\n                    offerer,\n                    msg.sender,\n                    parameters.offerIdentifier,\n                    parameters.offerAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    msg.sender,\n                    offerer,\n                    parameters.considerationToken,\n                    parameters.considerationAmount,\n                    parameters.additionalRecipients,\n                    false, // Send full amount indicated by consideration items.\n                    accumulator\n                );\n            } else if (route == BasicOrderRouteType.ERC20_TO_ERC1155) {\n                // Transfer ERC1155 to caller with offerer's conduit preference.\n                _transferERC1155(\n                    parameters.offerToken,\n                    offerer,\n                    msg.sender,\n                    parameters.offerIdentifier,\n                    parameters.offerAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    msg.sender,\n                    offerer,\n                    parameters.considerationToken,\n                    parameters.considerationAmount,\n                    parameters.additionalRecipients,\n                    false, // Send full amount indicated by consideration items.\n                    accumulator\n                );\n            } else if (route == BasicOrderRouteType.ERC721_TO_ERC20) {\n                // Transfer ERC721 to offerer using caller's conduit preference.\n                _transferERC721(\n                    parameters.considerationToken,\n                    msg.sender,\n                    offerer,\n                    parameters.considerationIdentifier,\n                    parameters.considerationAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    offerer,\n                    msg.sender,\n                    parameters.offerToken,\n                    parameters.offerAmount,\n                    parameters.additionalRecipients,\n                    true, // Reduce fulfiller amount sent by additional amounts.\n                    accumulator\n                );\n            } else {\n                // route == BasicOrderRouteType.ERC1155_TO_ERC20\n\n                // Transfer ERC1155 to offerer with caller's conduit preference.\n                _transferERC1155(\n                    parameters.considerationToken,\n                    msg.sender,\n                    offerer,\n                    parameters.considerationIdentifier,\n                    parameters.considerationAmount,\n                    conduitKey,\n                    accumulator\n                );\n\n                // Transfer ERC20 tokens to all recipients and wrap up.\n                _transferERC20AndFinalize(\n                    offerer,\n                    msg.sender,\n                    parameters.offerToken,\n                    parameters.offerAmount,\n                    parameters.additionalRecipients,\n                    true, // Reduce fulfiller amount sent by additional amounts.\n                    accumulator\n                );\n            }\n\n            // Trigger any remaining accumulated transfers via call to conduit.\n            _triggerIfArmed(accumulator);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Internal function to prepare fulfillment of a basic order with\n     *      manual calldata and memory access. This calculates the order hash,\n     *      emits an OrderFulfilled event, and asserts basic order validity.\n     *      Note that calldata offsets must be validated as this function\n     *      accesses constant calldata pointers for dynamic types that match\n     *      default ABI encoding, but valid ABI encoding can use arbitrary\n     *      offsets. Checking that the offsets were produced by default encoding\n     *      will ensure that other functions using Solidity's calldata accessors\n     *      (which calculate pointers from the stored offsets) are reading the\n     *      same data as the order hash is derived from. Also note that This\n     *      function accesses memory directly. It does not clear the expanded\n     *      memory regions used, nor does it update the free memory pointer, so\n     *      other direct memory access must not assume that unused memory is\n     *      empty.\n     *\n     * @param parameters                   The parameters of the basic order.\n     * @param orderType                    The order type.\n     * @param receivedItemType             The item type of the initial\n     *                                     consideration item on the order.\n     * @param additionalRecipientsItemType The item type of any additional\n     *                                     consideration item on the order.\n     * @param additionalRecipientsToken    The ERC20 token contract address (if\n     *                                     applicable) for any additional\n     *                                     consideration item on the order.\n     * @param offeredItemType              The item type of the offered item on\n     *                                     the order.\n     */\n    function _prepareBasicFulfillmentFromCalldata(\n        BasicOrderParameters calldata parameters,\n        OrderType orderType,\n        ItemType receivedItemType,\n        ItemType additionalRecipientsItemType,\n        address additionalRecipientsToken,\n        ItemType offeredItemType\n    ) internal {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard();\n\n        // Ensure current timestamp falls between order start time and end time.\n        _verifyTime(parameters.startTime, parameters.endTime, true);\n\n        // Verify that calldata offsets for all dynamic types were produced by\n        // default encoding. This ensures that the constants we use for calldata\n        // pointers to dynamic types are the same as those calculated by\n        // Solidity using their offsets.\n        _assertValidBasicOrderParameterOffsets();\n\n        // Ensure supplied consideration array length is not less than original.\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n            parameters.additionalRecipients.length + 1,\n            parameters.totalOriginalAdditionalRecipients\n        );\n\n        // Declare stack element for the order hash.\n        bytes32 orderHash;\n\n        {\n            /**\n             * First, handle consideration items. Memory Layout:\n             *  0x60: final hash of the array of consideration item hashes\n             *  0x80-0x160: reused space for EIP712 hashing of each item\n             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\n             *   - 0xa0: itemType\n             *   - 0xc0: token\n             *   - 0xe0: identifier\n             *   - 0x100: startAmount\n             *   - 0x120: endAmount\n             *   - 0x140: recipient\n             *  0x160-END_ARR: array of consideration item hashes\n             *   - 0x160: primary consideration item EIP712 hash\n             *   - 0x180-END_ARR: additional recipient item EIP712 hashes\n             *  END_ARR: beginning of data for OrderFulfilled event\n             *   - END_ARR + 0x120: length of ReceivedItem array\n             *   - END_ARR + 0x140: beginning of data for first ReceivedItem\n             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)\n             */\n\n            // Load consideration item typehash from runtime and place on stack.\n            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;\n\n            // Utilize assembly to enable reuse of memory regions and use\n            // constant pointers when possible.\n            assembly {\n                /*\n                 * 1. Calculate the EIP712 ConsiderationItem hash for the\n                 * primary consideration item of the basic order.\n                 */\n\n                // Write ConsiderationItem type hash and item type to memory.\n                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)\n                mstore(\n                    BasicOrder_considerationItem_itemType_ptr,\n                    receivedItemType\n                )\n\n                // Copy calldata region with (token, identifier, amount) from\n                // BasicOrderParameters to ConsiderationItem. The\n                // considerationAmount is written to startAmount and endAmount\n                // as basic orders do not have dynamic amounts.\n                calldatacopy(\n                    BasicOrder_considerationItem_token_ptr,\n                    BasicOrder_considerationToken_cdPtr,\n                    ThreeWords\n                )\n\n                // Copy calldata region with considerationAmount and offerer\n                // from BasicOrderParameters to endAmount and recipient in\n                // ConsiderationItem.\n                calldatacopy(\n                    BasicOrder_considerationItem_endAmount_ptr,\n                    BasicOrder_considerationAmount_cdPtr,\n                    TwoWords\n                )\n\n                // Calculate EIP712 ConsiderationItem hash and store it in the\n                // array of EIP712 consideration hashes.\n                mstore(\n                    BasicOrder_considerationHashesArray_ptr,\n                    keccak256(\n                        BasicOrder_considerationItem_typeHash_ptr,\n                        EIP712_ConsiderationItem_size\n                    )\n                )\n\n                /*\n                 * 2. Write a ReceivedItem struct for the primary consideration\n                 * item to the consideration array in OrderFulfilled.\n                 */\n\n                // Get the length of the additional recipients array.\n                let totalAdditionalRecipients := calldataload(\n                    BasicOrder_additionalRecipients_length_cdPtr\n                )\n\n                // Calculate pointer to length of OrderFulfilled consideration\n                // array.\n                let eventConsiderationArrPtr := add(\n                    OrderFulfilled_consideration_length_baseOffset,\n                    mul(totalAdditionalRecipients, OneWord)\n                )\n\n                // Set the length of the consideration array to the number of\n                // additional recipients, plus one for the primary consideration\n                // item.\n                mstore(\n                    eventConsiderationArrPtr,\n                    add(\n                        calldataload(\n                            BasicOrder_additionalRecipients_length_cdPtr\n                        ),\n                        1\n                    )\n                )\n\n                // Overwrite the consideration array pointer so it points to the\n                // body of the first element\n                eventConsiderationArrPtr := add(\n                    eventConsiderationArrPtr,\n                    OneWord\n                )\n\n                // Set itemType at start of the ReceivedItem memory region.\n                mstore(eventConsiderationArrPtr, receivedItemType)\n\n                // Copy calldata region (token, identifier, amount & recipient)\n                // from BasicOrderParameters to ReceivedItem memory.\n                calldatacopy(\n                    add(eventConsiderationArrPtr, Common_token_offset),\n                    BasicOrder_considerationToken_cdPtr,\n                    FourWords\n                )\n\n                /*\n                 * 3. Calculate EIP712 ConsiderationItem hashes for original\n                 * additional recipients and add a ReceivedItem for each to the\n                 * consideration array in the OrderFulfilled event. The original\n                 * additional recipients are all the considerations signed by\n                 * the offerer aside from the primary consideration of the\n                 * order. Uses memory region from 0x80-0x160 as a buffer for\n                 * calculating EIP712 ConsiderationItem hashes.\n                 */\n\n                // Put pointer to consideration hashes array on the stack.\n                // This will be updated as each additional recipient is hashed\n                let\n                    considerationHashesPtr\n                := BasicOrder_considerationHashesArray_ptr\n\n                // Write item type, token, & identifier for additional recipient\n                // to memory region for hashing EIP712 ConsiderationItem; these\n                // values will be reused for each recipient.\n                mstore(\n                    BasicOrder_considerationItem_itemType_ptr,\n                    additionalRecipientsItemType\n                )\n                mstore(\n                    BasicOrder_considerationItem_token_ptr,\n                    additionalRecipientsToken\n                )\n                mstore(BasicOrder_considerationItem_identifier_ptr, 0)\n\n                // Read length of the additionalRecipients array from calldata\n                // and iterate.\n                totalAdditionalRecipients := calldataload(\n                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr\n                )\n                let i := 0\n                // prettier-ignore\n                for {} lt(i, totalAdditionalRecipients) {\n                    i := add(i, 1)\n                } {\n                    /*\n                     * Calculate EIP712 ConsiderationItem hash for recipient.\n                     */\n\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        mul(AdditionalRecipients_size, i)\n                    )\n\n                    // Copy startAmount from calldata to the ConsiderationItem\n                    // struct.\n                    calldatacopy(\n                        BasicOrder_considerationItem_startAmount_ptr,\n                        additionalRecipientCdPtr,\n                        OneWord\n                    )\n\n                    // Copy endAmount and recipient from calldata to the\n                    // ConsiderationItem struct.\n                    calldatacopy(\n                        BasicOrder_considerationItem_endAmount_ptr,\n                        additionalRecipientCdPtr,\n                        AdditionalRecipients_size\n                    )\n\n                    // Add 1 word to the pointer as part of each loop to reduce\n                    // operations needed to get local offset into the array.\n                    considerationHashesPtr := add(\n                        considerationHashesPtr,\n                        OneWord\n                    )\n\n                    // Calculate EIP712 ConsiderationItem hash and store it in\n                    // the array of consideration hashes.\n                    mstore(\n                        considerationHashesPtr,\n                        keccak256(\n                            BasicOrder_considerationItem_typeHash_ptr,\n                            EIP712_ConsiderationItem_size\n                        )\n                    )\n\n                    /*\n                     * Write ReceivedItem to OrderFulfilled data.\n                     */\n\n                    // At this point, eventConsiderationArrPtr points to the\n                    // beginning of the ReceivedItem struct of the previous\n                    // element in the array. Increase it by the size of the\n                    // struct to arrive at the pointer for the current element.\n                    eventConsiderationArrPtr := add(\n                        eventConsiderationArrPtr,\n                        ReceivedItem_size\n                    )\n\n                    // Write itemType to the ReceivedItem struct.\n                    mstore(\n                        eventConsiderationArrPtr,\n                        additionalRecipientsItemType\n                    )\n\n                    // Write token to the next word of the ReceivedItem struct.\n                    mstore(\n                        add(eventConsiderationArrPtr, OneWord),\n                        additionalRecipientsToken\n                    )\n\n                    // Copy endAmount & recipient words to ReceivedItem struct.\n                    calldatacopy(\n                        add(\n                            eventConsiderationArrPtr,\n                            ReceivedItem_amount_offset\n                        ),\n                        additionalRecipientCdPtr,\n                        TwoWords\n                    )\n                }\n\n                /*\n                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:\n                 *   `keccak256(abi.encodePacked(receivedItemHashes))`\n                 * Note that it is set at 0x60 — all other memory begins at\n                 * 0x80. 0x60 is the \"zero slot\" and will be restored at the end\n                 * of the assembly section and before required by the compiler.\n                 */\n                mstore(\n                    receivedItemsHash_ptr,\n                    keccak256(\n                        BasicOrder_considerationHashesArray_ptr,\n                        mul(add(totalAdditionalRecipients, 1), OneWord)\n                    )\n                )\n\n                /*\n                 * 5. Add a ReceivedItem for each tip to the consideration array\n                 * in the OrderFulfilled event. The tips are all the\n                 * consideration items that were not signed by the offerer and\n                 * were provided by the fulfiller.\n                 */\n\n                // Overwrite length to length of the additionalRecipients array.\n                totalAdditionalRecipients := calldataload(\n                    BasicOrder_additionalRecipients_length_cdPtr\n                )\n                // prettier-ignore\n                for {} lt(i, totalAdditionalRecipients) {\n                    i := add(i, 1)\n                } {\n                    // Retrieve calldat"
    }
  ]
}