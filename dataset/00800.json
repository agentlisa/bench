{
  "Title": "Attacker can exploit lock update logic on secondary chains to increase the amount of rewards sent to a specific secondary chain ",
  "Content": "# Attacker can exploit lock update logic on secondary chains to increase the amount of rewards sent to a specific secondary chain \n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L428-L443\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L428-L443</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/base/SDLPool.sol#L408-L434\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/base/SDLPool.sol#L408-L434</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L451-L510\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L451-L510</a>\n\n\n## Summary\n\nUsers with existing reSDL NFTs on secondary chains (prior to a decrease in `maxBoost`) are able to increase `queuedRESDLSupplyChange` by a greater amount than should be possible given the current `maxBoost` value, which then allows them to funnel more rewards to their secondary chain (as `queuedRESDLSupplyChange` maps to `reSDLSupplyByChain[...]`, which is used to calculate the rewards distributed to each secondary chain). \n\n## Vulnerability Details\n\nConsider the scenario in which the stake.link team is decreasing the `maxBoost` value of the `LinearBoostController` so that newer depositors will get less rewards than OG depositors. This will allow an attacker on a secondary chain to perform the following attack to fraudulently increase the amount of rewards sent to their chain:\n\nWe will assume for simplicity that the starting values for the `LinearBoostController` contract is a `maxBoost`=10 and `maxLockingDuration` = 10_000 seconds. The attacker starts with a single (for simplicity) reSDL NFT on a secondary chain which has `amount`=100_000 and `lockingDuration`= 5_000 seconds, meaning their boost is calculated to be: 100_000 * 10 * 5_000/10_000 = 500_000. \n\nThen, the stake.link team decreases `maxBoost` to 5. Following this, the attacker will first call `SDLPoolSecondary:extendLockDuration` with a `_lockingDuration` of 9_999, which then calls the internal [`_queueLockUpdate`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L428-L443), which is defined as follows:\n```solidity\nfunction _queueLockUpdate(\n    address _owner,\n    uint256 _lockId,\n    uint256 _amount,\n    uint64 _lockingDuration\n) internal onlyLockOwner(_lockId, _owner) {\n    Lock memory lock = _getQueuedLockState(_lockId);\n@>    LockUpdate memory lockUpdate = LockUpdate(updateBatchIndex, _updateLock(lock, _amount, _lockingDuration));\n    queuedLockUpdates[_lockId].push(lockUpdate);\n@>    queuedRESDLSupplyChange +=\n        int256(lockUpdate.lock.amount + lockUpdate.lock.boostAmount) -\n        int256(lock.amount + lock.boostAmount);\n    ...\n}\n```\n\nAs part of this function call, [`_updateLock`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/base/SDLPool.sol#L408-L434) is triggered to perform this update, which is defined as follows:\n```solidity\nfunction _updateLock(\n    Lock memory _lock,\n    uint256 _amount,\n    uint64 _lockingDuration\n) internal view returns (Lock memory) {\n@>    if ((_lock.expiry == 0 || _lock.expiry > block.timestamp) && _lockingDuration < _lock.duration) {\n        revert InvalidLockingDuration();\n    }\n\n    Lock memory lock = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n\n    uint256 baseAmount = _lock.amount + _amount;\n@>    uint256 boostAmount = boostController.getBoostAmount(baseAmount, _lockingDuration);\n\n    ...\n    lock.boostAmount = boostAmount;\n    ...\n}\n```\nMost important to note here is that (1) since the `_lockingDuration` of 9_999 is greater than the existing duration of 5_000, this call will succeed, and (2) the `boostAmount` is recalculated now using the new `maxBoost` value of 5. We can calculate the new attacker's `boostAmount` to be: 100_000 * 5 * 9_9999/10_000 = 499_950. Since this value is less than the previous 500_000, `queuedRESDLSupplyChange` in the `_queueLockUpdate` call will be decremented by 50.\n\nAfter the `SDLPoolSecondary:extendLockDuration` function call is complete, this update will be queued. At some point an update to this secondary SDL pool will be triggered & once that's complete, the attacker will then be able to execute this update. To do so, the attacker calls `executeQueuedOperations`, specifying their reNFT, which then triggers [`_executeQueuedLockUpdates`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolSecondary.sol#L451-L510) which has the following logic:\n```solidity\n...\nuint256 numUpdates = queuedLockUpdates[lockId].length;\n\nLock memory curLockState = locks[lockId];\nuint256 j = 0;\nwhile (j < numUpdates) {\n\tif (queuedLockUpdates[lockId][j].updateBatchIndex > finalizedBatchIndex) break;\n\n\tLock memory updateLockState = queuedLockUpdates[lockId][j].lock;\n\tint256 baseAmountDiff = int256(updateLockState.amount) - int256(curLockState.amount);\n@>\tint256 boostAmountDiff = int256(updateLockState.boostAmount) - int256(curLockState.boostAmount);\n\n\tif (baseAmountDiff < 0) {\n\t\t...\n@>\t} else if (boostAmountDiff < 0) {\n@>\t\tlocks[lockId].expiry = updateLockState.expiry;\n@>\t\tlocks[lockId].boostAmount = 0;\n@>\t\temit InitiateUnlock(_owner, lockId, updateLockState.expiry);\n\t} else {\n\t\t...\n\t}\n\t...\n}\n...\n```\n\nRecall that the attacker only has a single update, with the only difference being the decrease of 50 for the `boostAmount`. This will trigger the logic based on the `boostAmountDiff < 0` statement which will set `locks[lockId].boostAmount = 0`. This is clearly incorrect logic & will allow the attacker to then fraudulently increase `queuedRESDLSupplyChange`, which will ultimately lead to more rewards going to this secondary chain.\n\nContinuing this attack, the attacker will again call `SDLPoolSecondary:extendLockDuration`, but this time with a `_lockingDuration` of 10_000. Referencing the same code snippet as earlier, in `_updateLock`, `boostAmount` is now being calculated as: 100_000 * 5 * 10_000/10_000 = 500_000. In `_queueLockUpdate`, `queuedRESDLSupplyChange` is calculated to be: (100_000 + 500_000) - (100_000 + 0) = 500_000, based on this equation:\n```solidity\nqueuedRESDLSupplyChange +=\n\tint256(lockUpdate.lock.amount + lockUpdate.lock.boostAmount) -\n\tint256(lock.amount + lock.boostAmount);\n```\n\nRecall that this value of 0 comes from the improper logic in the `_executeQueuedLockUpdates` function call. Ultimately, in aggregate, `queuedRESDLSupplyChange` has been increased by 500_000 - 50 = 499_950. Had the attacker simply increased their locking duration to the max value of 10_000 after the update, there would be 0 change in the `queuedRESDLSupplyChange`.\n\nThe fundamental bug here is that post a decrease in `maxBoost`, the update logic allows all existing reSDL NFTs to be able to increase `queuedRESDLSupplyChange` more than should be possible, & `queuedRESDLSupplyChange` is a major factor in terms of the percentage of rewards going to a given secondary chain. \n\n## Impact\n\nUsers with existing reSDL NFTs on secondary chains (prior to a decrease in the `maxBoost`) are able to increase `queuedRESDLSupplyChange` by a greater amount than should be possible given the current `maxBoost` value, which then allows them to funnel more rewards to their secondary chain.\n\n## Tools Used\n\nManual review\n\n## Recommendations\n\nThe `_executeQueuedLockUpdates` function implicitly assumes if there's a decrease in `boostAmountDiff` then the lock update comes from calling `initiateUnlock`. There needs to be an additional case to handle this scenario due to a decrease in the `maxBoost`.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/sdlPool/SDLPoolSecondary.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"./base/SDLPool.sol\";\n\n/**\n * @title SDL Pool Secondary\n * @notice Allows users to stake/lock SDL tokens and receive a percentage of the protocol's earned rewards\n * @dev deployed on all supported chains besides the primary chain\n */\ncontract SDLPoolSecondary is SDLPool {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct NewLockPointer {\n        uint128 updateBatchIndex;\n        uint128 index;\n    }\n    struct LockUpdate {\n        uint128 updateBatchIndex;\n        Lock lock;\n    }\n\n    mapping(uint256 => LockUpdate[]) internal queuedLockUpdates;\n\n    uint256 public queuedNewLockLimit;\n    uint256[] internal currentMintLockIdByBatch;\n    Lock[][] internal queuedNewLocks;\n    mapping(address => NewLockPointer[]) internal newLocksByOwner;\n\n    uint128 public updateBatchIndex;\n    uint64 public updateInProgress;\n    uint64 internal updateNeeded;\n    int256 public queuedRESDLSupplyChange;\n\n    event QueueInitiateUnlock(address indexed owner, uint256 indexed lockId, uint64 expiry);\n    event QueueWithdraw(address indexed owner, uint256 indexed lockId, uint256 amount);\n    event QueueCreateLock(address indexed owner, uint256 amount, uint256 boostAmount, uint64 lockingDuration);\n    event QueueUpdateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event OutgoingUpdate(uint128 indexed batchIndex, uint256 numNewQueuedLocks, int256 reSDLSupplyChange);\n    event IncomingUpdate(uint128 indexed batchIndex, uint256 mintStartIndex);\n\n    error CannotTransferWithQueuedUpdates();\n    error UpdateInProgress();\n    error NoUpdateInProgress();\n    error TooManyQueuedLocks();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     * @param _queuedNewLockLimit max amount of queued new locks an account can have\n     **/\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController,\n        uint256 _queuedNewLockLimit\n    ) public initializer {\n        __SDLPoolBase_init(_name, _symbol, _sdlToken, _boostController);\n        updateBatchIndex = 1;\n        currentMintLockIdByBatch.push(0);\n        queuedNewLocks.push();\n        queuedNewLocks.push();\n        queuedNewLockLimit = _queuedNewLockLimit;\n    }\n\n    /**\n     * @notice returns a list of queued new locks for an owner\n     * @param _owner owner of locks\n     * @return list of queued locks and corresponding batch indexes\n     **/\n    function getQueuedNewLocksByOwner(address _owner) external view returns (Lock[] memory, uint256[] memory) {\n        uint256 numNewLocks = newLocksByOwner[_owner].length;\n        Lock[] memory newLocks = new Lock[](numNewLocks);\n        uint256[] memory batchIndexes = new uint256[](numNewLocks);\n\n        for (uint256 i = 0; i < numNewLocks; ++i) {\n            NewLockPointer memory pointer = newLocksByOwner[_owner][i];\n            newLocks[i] = queuedNewLocks[pointer.updateBatchIndex][pointer.index];\n            batchIndexes[i] = pointer.updateBatchIndex;\n        }\n\n        return (newLocks, batchIndexes);\n    }\n\n    /**\n     * @notice returns queued lock updates for a list of lock ids\n     * @param _lockIds list of lock ids\n     * @return list of queued lock updates corresponding to each lock id\n     **/\n    function getQueuedLockUpdates(uint256[] calldata _lockIds) external view returns (LockUpdate[][] memory) {\n        LockUpdate[][] memory updates = new LockUpdate[][](_lockIds.length);\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            updates[i] = queuedLockUpdates[_lockIds[i]];\n        }\n\n        return updates;\n    }\n\n    /**\n     * @notice ERC677 implementation to stake/lock SDL tokens or distribute rewards\n     * @dev operations will be queued until the next update at which point the user can execute (excludes reward distribution)\n     * @dev\n     * - will update/create a lock if the token transferred is SDL or will distribute rewards otherwise\n     *\n     * For Non-SDL:\n     * - reverts if token is unsupported\n     *\n     * For SDL:\n     * - set lockId to 0 to create a new lock or set lockId to > 0 to stake more into an existing lock\n     * - set lockingDuration to 0 to stake without locking or set lockingDuration to > 0 to lock for an amount\n     *   time in seconds\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     * @param _calldata encoded lockId (uint256) and lockingDuration (uint64)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external override {\n        if (msg.sender != address(sdlToken) && !isTokenSupported(msg.sender)) revert UnauthorizedToken();\n\n        if (_value == 0) revert InvalidValue();\n\n        if (msg.sender == address(sdlToken)) {\n            (uint256 lockId, uint64 lockingDuration) = abi.decode(_calldata, (uint256, uint64));\n            if (lockId != 0) {\n                _queueLockUpdate(_sender, lockId, _value, lockingDuration);\n            } else {\n                _queueNewLock(_sender, _value, lockingDuration);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice extends the locking duration of a lock\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` is 0 or exceeds the maximum\n     * @param _lockId id of lock\n     * @param _lockingDuration new locking duration to set\n     **/\n    function extendLockDuration(uint256 _lockId, uint64 _lockingDuration) external {\n        if (_lockingDuration == 0) revert InvalidLockingDuration();\n        _queueLockUpdate(msg.sender, _lockId, 0, _lockingDuration);\n    }\n\n    /**\n     * @notice initiates the unlock period for a lock\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - at least half of the locking duration must have elapsed to initiate the unlock period\n     * - the unlock period consists of half of the locking duration\n     * - boost will be set to 0 upon initiation of the unlock period\n     *\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if a minimum of half the locking duration has not elapsed\n     * @param _lockId id of lock\n     **/\n    function initiateUnlock(uint256 _lockId) external onlyLockOwner(_lockId, msg.sender) updateRewards(msg.sender) {\n        Lock memory lock = _getQueuedLockState(_lockId);\n\n        if (lock.expiry != 0) revert UnlockAlreadyInitiated();\n        uint64 halfDuration = lock.duration / 2;\n        if (lock.startTime + halfDuration > block.timestamp) revert HalfDurationNotElapsed();\n\n        uint64 expiry = uint64(block.timestamp) + halfDuration;\n        lock.expiry = expiry;\n\n        uint256 boostAmount = lock.boostAmount;\n        lock.boostAmount = 0;\n        effectiveBalances[msg.sender] -= boostAmount;\n        totalEffectiveBalance -= boostAmount;\n\n        queuedLockUpdates[_lockId].push(LockUpdate(updateBatchIndex, lock));\n        queuedRESDLSupplyChange -= int256(boostAmount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueInitiateUnlock(msg.sender, _lockId, expiry);\n    }\n\n    /**\n     * @notice withdraws unlocked SDL\n     * @dev operation will be queued until the next update at which point the user can execute\n     * @dev\n     * - SDL can only be withdrawn if unlocked (once the unlock period has elapsed or if it was never\n     *   locked in the first place)\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if not unlocked\n     * - reverts if `_amount` exceeds the amount staked in the lock\n     * @param _lockId id of the lock\n     * @param _amount amount to withdraw from the lock\n     **/\n    function withdraw(uint256 _lockId, uint256 _amount)\n        external\n        onlyLockOwner(_lockId, msg.sender)\n        updateRewards(msg.sender)\n    {\n        Lock memory lock = _getQueuedLockState(_lockId);\n\n        if (lock.startTime != 0) {\n            uint64 expiry = lock.expiry;\n            if (expiry == 0) revert UnlockNotInitiated();\n            if (expiry > block.timestamp) revert TotalDurationNotElapsed();\n        }\n\n        uint256 baseAmount = lock.amount;\n        if (_amount > baseAmount) revert InsufficientBalance();\n\n        lock.amount = baseAmount - _amount;\n        effectiveBalances[msg.sender] -= _amount;\n        totalEffectiveBalance -= _amount;\n\n        queuedLockUpdates[_lockId].push(LockUpdate(updateBatchIndex, lock));\n        queuedRESDLSupplyChange -= int256(_amount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueWithdraw(msg.sender, _lockId, _amount);\n    }\n\n    /**\n     * @notice executes queued operations for the sender\n     * @dev will mint new locks and update existing locks\n     * @dev an operation can only be executed once its encompassing batch is finalized\n     * @param _lockIds ids of locks to update\n     **/\n    function executeQueuedOperations(uint256[] memory _lockIds) external {\n        _executeQueuedLockUpdates(msg.sender, _lockIds);\n        _mintQueuedNewLocks(msg.sender);\n    }\n\n    /**\n     * @notice handles the outgoing transfer of an reSDL lock to another chain\n     * @param _sender sender of the transfer\n     * @param _lockId id of lock\n     * @param _sdlReceiver address to receive underlying SDL on this chain\n     * @return lock the lock being transferred\n     **/\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    ) external onlyCCIPController onlyLockOwner(_lockId, _sender) updateRewards(_sender) returns (Lock memory) {\n        if (queuedLockUpdates[_lockId].length != 0) revert CannotTransferWithQueuedUpdates();\n\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        totalEffectiveBalance -= totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n\n    /**\n     * @notice handles the incoming transfer of an reSDL lock from another chain\n     * @param _receiver receiver of the transfer\n     * @param _lockId id of lock\n     * @param _lock lock\n     **/\n    function handleIncomingRESDL(\n        address _receiver,\n        uint256 _lockId,\n        Lock calldata _lock\n    ) external onlyCCIPController updateRewards(_receiver) {\n        if (lockOwners[_lockId] != address(0)) revert InvalidLockId();\n\n        locks[_lockId] = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n        lockOwners[_lockId] = _receiver;\n        balances[_receiver] += 1;\n\n        uint256 totalAmount = _lock.amount + _lock.boostAmount;\n        effectiveBalances[_receiver] += totalAmount;\n        totalEffectiveBalance += totalAmount;\n\n        if (_lockId > lastLockId) lastLockId = _lockId;\n\n        emit IncomingRESDL(_receiver, _lockId);\n    }\n\n    /**\n     * @notice handles an outgoing update to the primary chain\n     * @return the number of new locks to mint and the reSDL supply change since the last update\n     **/\n    function handleOutgoingUpdate() external onlyCCIPController returns (uint256, int256) {\n        if (updateInProgress == 1) revert UpdateInProgress();\n\n        uint256 numNewQueuedLocks = queuedNewLocks[updateBatchIndex].length;\n        int256 reSDLSupplyChange = queuedRESDLSupplyChange;\n\n        queuedRESDLSupplyChange = 0;\n        updateBatchIndex++;\n        updateInProgress = 1;\n        updateNeeded = 0;\n        queuedNewLocks.push();\n\n        emit OutgoingUpdate(updateBatchIndex - 1, numNewQueuedLocks, reSDLSupplyChange);\n\n        return (numNewQueuedLocks, reSDLSupplyChange);\n    }\n\n    /**\n     * @notice handles an incoming update from the primary chain\n     * @dev an outgoing update must be sent prior to receiving an incoming update\n     * @dev finalizes the most recent batch of operations\n     * @param _mintStartIndex start index to use for minting new locks in the lastest batch\n     **/\n    function handleIncomingUpdate(uint256 _mintStartIndex) external onlyCCIPController {\n        if (updateInProgress == 0) revert NoUpdateInProgress();\n\n        if (_mintStartIndex != 0) {\n            uint256 newLastLockId = _mintStartIndex + queuedNewLocks[updateBatchIndex - 1].length - 1;\n            if (newLastLockId > lastLockId) lastLockId = newLastLockId;\n        }\n\n        currentMintLockIdByBatch.push(_mintStartIndex);\n        updateInProgress = 0;\n        emit IncomingUpdate(updateBatchIndex - 1, _mintStartIndex);\n    }\n\n    /**\n     * @notice returns whether an update should be sent to the primary chain\n     * @return whether update should be sent\n     **/\n    function shouldUpdate() external view returns (bool) {\n        return updateNeeded == 1 && updateInProgress == 0;\n    }\n\n    /**\n     * @notice queues a new lock to be minted\n     * @param _owner owner of lock\n     * @param _amount amount of underlying SDL\n     * @param _lockingDuration locking duration\n     **/\n    function _queueNewLock(\n        address _owner,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal {\n        if (newLocksByOwner[_owner].length >= queuedNewLockLimit) revert TooManyQueuedLocks();\n\n        Lock memory lock = _createLock(_amount, _lockingDuration);\n        queuedNewLocks[updateBatchIndex].push(lock);\n        newLocksByOwner[_owner].push(NewLockPointer(updateBatchIndex, uint128(queuedNewLocks[updateBatchIndex].length - 1)));\n        queuedRESDLSupplyChange += int256(lock.amount + lock.boostAmount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueCreateLock(_owner, _amount, lock.boostAmount, _lockingDuration);\n    }\n\n    /**\n     * @notice mints queued new locks for an owner\n     * @dev will only mint locks that are part of finalized batches\n     * @param _owner owner address\n     **/\n    function _mintQueuedNewLocks(address _owner) internal updateRewards(_owner) {\n        uint256 finalizedBatchIndex = _getFinalizedUpdateBatchIndex();\n        uint256 numNewLocks = newLocksByOwner[_owner].length;\n        uint256 i = 0;\n        while (i < numNewLocks) {\n            NewLockPointer memory newLockPointer = newLocksByOwner[_owner][i];\n            if (newLockPointer.updateBatchIndex > finalizedBatchIndex) break;\n\n            uint256 lockId = currentMintLockIdByBatch[newLockPointer.updateBatchIndex];\n            Lock memory lock = queuedNewLocks[newLockPointer.updateBatchIndex][newLockPointer.index];\n\n            currentMintLockIdByBatch[newLockPointer.updateBatchIndex] += 1;\n\n            locks[lockId] = lock;\n            lockOwners[lockId] = _owner;\n            balances[_owner] += 1;\n\n            uint256 totalAmount = lock.amount + lock.boostAmount;\n            effectiveBalances[_owner] += totalAmount;\n            totalEffectiveBalance += totalAmount;\n\n            emit CreateLock(_owner, lockId, lock.amount, lock.boostAmount, lock.duration);\n            emit Transfer(address(0), _owner, lockId);\n\n            ++i;\n        }\n\n        for (uint256 j = 0; j < numNewLocks; ++j) {\n            if (i == numNewLocks) {\n                newLocksByOwner[_owner].pop();\n            } else {\n                newLocksByOwner[_owner][j] = newLocksByOwner[_owner][i];\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice queued an update for a lock\n     * @param _owner owner of lock\n     * @param _lockId id of lock\n     * @param _amount new amount of underlying SDL\n     * @param _lockingDuration new locking duration\n     **/\n    function _queueLockUpdate(\n        address _owner,\n        uint256 _lockId,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal onlyLockOwner(_lockId, _owner) {\n        Lock memory lock = _getQueuedLockState(_lockId);\n        LockUpdate memory lockUpdate = LockUpdate(updateBatchIndex, _updateLock(lock, _amount, _lockingDuration));\n        queuedLockUpdates[_lockId].push(lockUpdate);\n        queuedRESDLSupplyChange +=\n            int256(lockUpdate.lock.amount + lockUpdate.lock.boostAmount) -\n            int256(lock.amount + lock.boostAmount);\n        if (updateNeeded == 0) updateNeeded = 1;\n\n        emit QueueUpdateLock(_owner, _lockId, lockUpdate.lock.amount, lockUpdate.lock.boostAmount, lockUpdate.lock.duration);\n    }\n\n    /**\n     * @notice executes a series of lock updates\n     * @dev will only update locks that are part of finalized batches\n     * @param _owner owner of locks\n     * @param _lockIds list of ids for locks to update\n     **/\n    function _executeQueuedLockUpdates(address _owner, uint256[] memory _lockIds) internal updateRewards(_owner) {\n        uint256 finalizedBatchIndex = _getFinalizedUpdateBatchIndex();\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            uint256 lockId = _lockIds[i];\n            _onlyLockOwner(lockId, _owner);\n            uint256 numUpdates = queuedLockUpdates[lockId].length;\n\n            Lock memory curLockState = locks[lockId];\n            uint256 j = 0;\n            while (j < numUpdates) {\n                if (queuedLockUpdates[lockId][j].updateBatchIndex > finalizedBatchIndex) break;\n\n                Lock memory updateLockState = queuedLockUpdates[lockId][j].lock;\n                int256 baseAmountDiff = int256(updateLockState.amount) - int256(curLockState.amount);\n                int256 boostAmountDiff = int256(updateLockState.boostAmount) - int256(curLockState.boostAmount);\n\n                if (baseAmountDiff < 0) {\n                    emit Withdraw(_owner, lockId, uint256(-1 * baseAmountDiff));\n                    if (updateLockState.amount == 0) {\n                        delete locks[lockId];\n                        delete lockOwners[lockId];\n                        balances[_owner] -= 1;\n                        if (tokenApprovals[lockId] != address(0)) delete tokenApprovals[lockId];\n                        emit Transfer(_owner, address(0), lockId);\n                    } else {\n                        locks[lockId].amount = updateLockState.amount;\n                    }\n                    sdlToken.safeTransfer(_owner, uint256(-1 * baseAmountDiff));\n                } else if (boostAmountDiff < 0) {\n                    locks[lockId].expiry = updateLockState.expiry;\n                    locks[lockId].boostAmount = 0;\n                    emit InitiateUnlock(_owner, lockId, updateLockState.expiry);\n                } else {\n                    locks[lockId] = updateLockState;\n                    uint256 totalDiff = uint256(baseAmountDiff + boostAmountDiff);\n                    effectiveBalances[_owner] += totalDiff;\n                    totalEffectiveBalance += totalDiff;\n                    emit UpdateLock(\n                        _owner,\n                        lockId,\n                        updateLockState.amount,\n                        updateLockState.boostAmount,\n                        updateLockState.duration\n                    );\n                }\n                curLockState = updateLockState;\n                ++j;\n            }\n\n            for (uint256 k = 0; k < numUpdates; ++k) {\n                if (j == numUpdates) {\n                    queuedLockUpdates[lockId].pop();\n                } else {\n                    queuedLockUpdates[lockId][k] = queuedLockUpdates[lockId][j];\n                    ++j;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice returns the current state of a lock\n     * @dev will return the most recent queued update for a lock or the finalized state if there are no queued updates\n     * @param _lockId id of lock\n     * @return the current state of a lock\n     **/\n    function _getQueuedLockState(uint256 _lockId) internal view returns (Lock memory) {\n        uint256 updatesLength = queuedLockUpdates[_lockId].length;\n\n        if (updatesLength != 0) {\n            return queuedLockUpdates[_lockId][updatesLength - 1].lock;\n        } else {\n            return locks[_lockId];\n        }\n    }\n\n    /**\n     * @notice returns the index of the latest finalized batch\n     * @return latest finalized batch index\n     **/\n    function _getFinalizedUpdateBatchIndex() internal view returns (uint256) {\n        return currentMintLockIdByBatch.length - 1;\n    }\n\n    /**\n     * @notice transfers a lock between accounts\n     * @param _from account to transfer from\n     * @param _to account to transfer to\n     * @param _lockId id of lock to tansfer\n     **/\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) internal override {\n        if (queuedLockUpdates[_lockId].length != 0) revert CannotTransferWithQueuedUpdates();\n        super._transfer(_from, _to, _lockId);\n    }\n}"
    },
    {
      "filename": "contracts/core/sdlPool/base/SDLPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport \"../../base/RewardsPoolController.sol\";\nimport \"../../interfaces/IBoostController.sol\";\nimport \"../../interfaces/IERC721Receiver.sol\";\n\n/**\n * @title SDL Pool\n * @notice Base SDL Pool contract to inherit from\n */\ncontract SDLPool is RewardsPoolController, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Lock {\n        uint256 amount;\n        uint256 boostAmount;\n        uint64 startTime;\n        uint64 duration;\n        uint64 expiry;\n    }\n\n    string public name;\n    string public symbol;\n\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\n    mapping(uint256 => address) internal tokenApprovals;\n\n    IERC20Upgradeable public sdlToken;\n    IBoostController public boostController;\n\n    uint256 public lastLockId;\n    mapping(uint256 => Lock) internal locks;\n    mapping(uint256 => address) internal lockOwners;\n    mapping(address => uint256) internal balances;\n\n    uint256 public totalEffectiveBalance;\n    mapping(address => uint256) internal effectiveBalances;\n\n    address public ccipController;\n\n    string public baseURI;\n\n    event InitiateUnlock(address indexed owner, uint256 indexed lockId, uint64 expiry);\n    event Withdraw(address indexed owner, uint256 indexed lockId, uint256 amount);\n    event CreateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event UpdateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event OutgoingRESDL(address indexed sender, uint256 indexed lockId);\n    event IncomingRESDL(address indexed receiver, uint256 indexed lockId);\n\n    error SenderNotAuthorized();\n    error InvalidLockId();\n    error InvalidLockingDuration();\n    error TransferFromIncorrectOwner();\n    error TransferToZeroAddress();\n    error TransferToNonERC721Implementer();\n    error TransferToCCIPController();\n    error ApprovalToCurrentOwner();\n    error ApprovalToCaller();\n    error InvalidValue();\n    error InvalidParams();\n    error UnauthorizedToken();\n    error TotalDurationNotElapsed();\n    error HalfDurationNotElapsed();\n    error InsufficientBalance();\n    error UnlockNotInitiated();\n    error DuplicateContract();\n    error ContractNotFound();\n    error UnlockAlreadyInitiated();\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     **/\n    function __SDLPoolBase_init(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController\n    ) public onlyInitializing {\n        __RewardsPoolController_init();\n        name = _name;\n        symbol = _symbol;\n        sdlToken = IERC20Upgradeable(_sdlToken);\n        boostController = IBoostController(_boostController);\n    }\n\n    /**\n     * @notice reverts if `_owner` is not the owner of `_lockId`\n     **/\n    modifier onlyLockOwner(uint256 _lockId, address _owner) {\n        _onlyLockOwner(_lockId, _owner);\n        _;\n    }\n\n    /**\n     * @notice reverts if sender is not the CCIP controller\n     **/\n    modifier onlyCCIPController() {\n        if (msg.sender != ccipController) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice returns the effective stake balance of an account\n     * @dev the effective stake balance includes the actual amount of tokens an\n     * account has staked across all locks plus any applicable boost gained by locking\n     * @param _account address of account\n     * @return effective stake balance\n     **/\n    function effectiveBalanceOf(address _account) external view returns (uint256) {\n        return effectiveBalances[_account];\n    }\n\n    /**\n     * @notice returns the number of locks owned by an account\n     * @param _account address of account\n     * @return total number of locks owned by account\n     **/\n    function balanceOf(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    /**\n     * @notice returns the owner of a lock\n     * @dev reverts if `_lockId` is invalid\n     * @param _lockId id of the lock\n     * @return lock owner\n     **/\n    function ownerOf(uint256 _lockId) public view returns (address) {\n        address owner = lockOwners[_lockId];\n        if (owner == address(0)) revert InvalidLockId();\n        return owner;\n    }\n\n    /**\n     * @notice returns the list of locks that corresponds to `_lockIds`\n     * @dev reverts if any lockId is invalid\n     * @param _lockIds list of lock ids\n     * @return list of locks\n     **/\n    function getLocks(uint256[] calldata _lockIds) external view returns (Lock[] memory) {\n        Lock[] memory retLocks = new Lock[](_lockIds.length);\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            uint256 lockId = _lockIds[i];\n            if (lockOwners[lockId] == address(0)) revert InvalidLockId();\n            retLocks[i] = locks[lockId];\n        }\n\n        return retLocks;\n    }\n\n    /**\n     * @notice returns a list of lockIds owned by an account\n     * @param _owner address of account\n     * @return list of lockIds\n     **/\n    function getLockIdsByOwner(address _owner) external view returns (uint256[] memory) {\n        uint256 maxLockId = lastLockId;\n        uint256 lockCount = balanceOf(_owner);\n        uint256 lockIdsFound;\n        uint256[] memory lockIds = new uint256[](lockCount);\n\n        for (uint256 i = 1; i <= maxLockId; ++i) {\n            if (lockOwners[i] == _owner) {\n                lockIds[lockIdsFound] = i;\n                lockIdsFound++;\n                if (lockIdsFound == lockCount) break;\n            }\n        }\n\n        assert(lockIdsFound == lockCount);\n\n        return lockIds;\n    }\n\n    /**\n     * @notice transfers a lock between accounts\n     * @dev reverts if sender is not the owner of and not approved to transfer the lock\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     **/\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) external {\n        if (!_isApprovedOrOwner(msg.sender, _lockId)) revert SenderNotAuthorized();\n        _transfer(_from, _to, _lockId);\n    }\n\n    /**\n     * @notice transfers a lock between accounts and validates that the receiver supports ERC721\n     * @dev\n     * - calls onERC721Received on `_to` if it is a contract or reverts if it is a contract\n     *   and does not implemement onERC721Received\n     * - reverts if sender is not the owner of and not approved to transfer the lock\n     * - reverts if `_lockId` is invalid\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     **/\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) external {\n        safeTransferFrom(_from, _to, _lockId, \"\");\n    }\n\n    /**\n     * @notice transfers a lock between accounts and validates that the receiver supports ERC721\n     * @dev\n     * - calls onERC721Received on `_to` if it is a contract or reverts if it is a contract\n     *   and does not implemement onERC721Received\n     * - reverts if sender is not the owner of and not approved to transfer the lock\n     * - reverts if `_lockId` is invalid\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     * @param _data optional data to pass to receiver\n     **/\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId,\n        bytes memory _data\n    ) public {\n        if (!_isApprovedOrOwner(msg.sender, _lockId)) revert SenderNotAuthorized();\n        _transfer(_from, _to, _lockId);\n        if (!_checkOnERC721Received(_from, _to, _lockId, _data)) revert TransferToNonERC721Implementer();\n    }\n\n    /**\n     * @notice approves `_to` to transfer `_lockId` to another address\n     * @dev\n     * - approval is revoked on transfer and can also be revoked by approving zero address\n     * - reverts if sender is not owner of lock and not an approved operator for the owner\n     * - reverts if `_to` is owner of lock\n     * - reverts if `_lockId` is invalid\n     * @param _to address approved to transfer\n     * @param _lockId id of lock\n     **/\n    function approve(address _to, uint256 _lockId) external {\n        address owner = ownerOf(_lockId);\n\n        if (_to == owner) revert ApprovalToCurrentOwner();\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert SenderNotAuthorized();\n\n        tokenApprovals[_lockId] = _to;\n        emit Approval(owner, _to, _lockId);\n    }\n\n    /**\n     * @notice returns the address approved to transfer a lock\n     * @param _lockId id of lock\n     * @return approved address\n     **/\n    function getApproved(uint256 _lockId) public view returns (address) {\n        if (lockOwners[_lockId] == address(0)) revert InvalidLockId();\n\n        return tokenApprovals[_lockId];\n    }\n\n    /**\n     * @notice approves _operator to transfer all tokens owned by sender\n     * @dev\n     * - approval will not be revoked until this function is called again with\n     *   `_approved` set to false\n     * - reverts if sender is `_operator`\n     * @param _operator address to approve/unapprove\n     * @param _approved whether address is approved or not\n     **/\n    function setApprovalForAll(address _operator, bool _approved) external {\n        address owner = msg.sender;\n        if (owner == _operator) revert ApprovalToCaller();\n\n        operatorApprovals[owner][_operator] = _approved;\n        emit ApprovalForAll(owner, _operator, _approved);\n    }\n\n    /**\n     * @notice returns whether `_operator` is approved to transfer all tokens owned by `_owner`\n     * @param _owner owner of tokens\n     * @param _operator address approved to transfer\n     * @return whether address is approved or not\n     **/\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n    /**\n     * @notice returns an account's staked amount for use by reward pools\n     * controlled by this contract\n     * @param _account account address\n     * @return account's staked amount\n     */\n    function staked(address _account) external view override returns (uint256) {\n        return effectiveBalances[_account];\n    }\n\n    /**\n     * @notice returns the total staked amount for use by reward pools\n     * controlled by this contract\n     * @return total staked amount\n     */\n    function totalStaked"
    }
  ]
}